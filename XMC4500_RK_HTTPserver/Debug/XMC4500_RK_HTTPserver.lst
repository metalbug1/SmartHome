
XMC4500_RK_HTTPserver.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000256d8  08000000  0c000000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000010  080256d8  0c0256d8  0002d6d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .rodata       0000132c  080256e8  0c0256e8  0002d6e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 Stack         00000800  20000000  20000000  00038000  2**0
                  ALLOC
  4 Communication_Buffers 00004920  30000000  30000000  00038000  2**2
                  ALLOC
  5 .bss          00005e50  20000800  20000800  00038000  2**2
                  ALLOC
  6 .data         0000057c  20006650  0c026a20  00036650  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .debug_aranges 00002220  00000000  00000000  00036bd0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0003a9cc  00000000  00000000  00038df0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000070eb  00000000  00000000  000737bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0006c279  00000000  00000000  0007a8a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00006d4c  00000000  00000000  000e6b20  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000b0421  00000000  00000000  000ed86c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000add1  00000000  00000000  0019dc8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001b38  00000000  00000000  001a8a60  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .build_attributes 00001ccd  00000000  00000000  001aa598  2**0
                  CONTENTS, READONLY
 16 .debug_macro  00033487  00000000  00000000  001ac265  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000000 <__Xmc4500_interrupt_vector_cortex_m>:
 8000000:	00 08 00 20 01 02 00 08 b7 02 00 08 c7 02 00 08     ... ............
 8000010:	d7 02 00 08 e7 02 00 08 f7 02 00 08 00 00 00 00     ................
	...
 800002c:	07 03 00 08 17 03 00 08 00 00 00 00 27 03 00 08     ............'...
 800003c:	37 03 00 08 47 03 00 08 57 03 00 08 67 03 00 08     7...G...W...g...
 800004c:	77 03 00 08 87 03 00 08 97 03 00 08 a7 03 00 08     w...............
 800005c:	b7 03 00 08 c7 03 00 08 00 00 00 00 00 00 00 00     ................
 800006c:	00 00 00 00 d7 03 00 08 00 00 00 00 e7 03 00 08     ................
 800007c:	f7 03 00 08 07 04 00 08 17 04 00 08 27 04 00 08     ............'...
 800008c:	37 04 00 08 47 04 00 08 57 04 00 08 67 04 00 08     7...G...W...g...
 800009c:	77 04 00 08 87 04 00 08 97 04 00 08 a7 04 00 08     w...............
 80000ac:	b7 04 00 08 c7 04 00 08 d7 04 00 08 e7 04 00 08     ................
 80000bc:	f7 04 00 08 07 05 00 08 17 05 00 08 27 05 00 08     ............'...
 80000cc:	37 05 00 08 47 05 00 08 57 05 00 08 67 05 00 08     7...G...W...g...
 80000dc:	77 05 00 08 87 05 00 08 97 05 00 08 a7 05 00 08     w...............
 80000ec:	b7 05 00 08 c7 05 00 08 d7 05 00 08 e7 05 00 08     ................
 80000fc:	f7 05 00 08 07 06 00 08 15 06 00 08 23 06 00 08     ............#...
 800010c:	31 06 00 08 3f 06 00 08 4d 06 00 08 5b 06 00 08     1...?...M...[...
 800011c:	69 06 00 08 77 06 00 08 85 06 00 08 93 06 00 08     i...w...........
 800012c:	a1 06 00 08 af 06 00 08 bd 06 00 08 cb 06 00 08     ................
 800013c:	d9 06 00 08 e7 06 00 08 f5 06 00 08 03 07 00 08     ................
 800014c:	11 07 00 08 1f 07 00 08 2d 07 00 08 3b 07 00 08     ........-...;...
 800015c:	49 07 00 08 00 00 00 00 00 00 00 00 00 00 00 00     I...............
 800016c:	00 00 00 00 57 07 00 08 65 07 00 08 73 07 00 08     ....W...e...s...
 800017c:	81 07 00 08 8f 07 00 08 9d 07 00 08 ab 07 00 08     ................
 800018c:	b9 07 00 08 c7 07 00 08 d5 07 00 08 e3 07 00 08     ................
 800019c:	f1 07 00 08 ff 07 00 08 0d 08 00 08 1b 08 00 08     ................
 80001ac:	29 08 00 08 37 08 00 08 45 08 00 08 53 08 00 08     )...7...E...S...
 80001bc:	61 08 00 08 6f 08 00 08 7d 08 00 08 8b 08 00 08     a...o...}.......
 80001cc:	99 08 00 08 a7 08 00 08 b5 08 00 08 c3 08 00 08     ................
 80001dc:	00 00 00 00 d1 08 00 08 df 08 00 08 ed 08 00 08     ................
 80001ec:	fb 08 00 08 09 09 00 08 00 00 00 00 17 09 00 08     ................
 80001fc:	00 00 00 00                                         ....

08000200 <__Xmc4500_reset_cortex_m>:
__Xmc4500_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR SP,=__Xmc4500_stack
 8000200:	f8df d00c 	ldr.w	sp, [pc, #12]	; 8000210 <__Xmc4500_reset_cortex_m+0x10>

    /* Clock tree, External memory setup etc may be done here */    
    LDR     R0, =SystemInit
 8000204:	4803      	ldr	r0, [pc, #12]	; (8000214 <__Xmc4500_reset_cortex_m+0x14>)
    BLX     R0
 8000206:	4780      	blx	r0

/* 
   SystemInit_DAVE3() is provided by DAVE3 code generation engine. It is  
   weakly defined here though for a potential override.
*/
    LDR     R0, =SystemInit_DAVE3     
 8000208:	4803      	ldr	r0, [pc, #12]	; (8000218 <__Xmc4500_reset_cortex_m+0x18>)
    BLX     R0
 800020a:	4780      	blx	r0

    B       __Xmc4500_Program_Loader 
 800020c:	f000 b806 	b.w	800021c <__Xmc4500_Program_Loader>
__Xmc4500_reset_cortex_m:
    .fnstart

    /* C routines are likely to be called. Setup the stack now */
    /* This is already setup by BootROM,hence this step is optional */ 
    LDR SP,=__Xmc4500_stack
 8000210:	20000800 	.word	0x20000800

    /* Clock tree, External memory setup etc may be done here */    
    LDR     R0, =SystemInit
 8000214:	08000ae1 	.word	0x08000ae1

/* 
   SystemInit_DAVE3() is provided by DAVE3 code generation engine. It is  
   weakly defined here though for a potential override.
*/
    LDR     R0, =SystemInit_DAVE3     
 8000218:	0801eb31 	.word	0x0801eb31

0800021c <__Xmc4500_Program_Loader>:
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =eROData
 800021c:	4819      	ldr	r0, [pc, #100]	; (8000284 <SKIPCLEAR+0x20>)
   LDR R1, =__Xmc4500_sData
 800021e:	491a      	ldr	r1, [pc, #104]	; (8000288 <SKIPCLEAR+0x24>)
   LDR R2, =__Xmc4500_Data_Size
 8000220:	4a1a      	ldr	r2, [pc, #104]	; (800028c <SKIPCLEAR+0x28>)

   /* Is there anything to be copied? */
   CMP R2,#0
 8000222:	2a00      	cmp	r2, #0
   BEQ SKIPCOPY
 8000224:	f000 800d 	beq.w	8000242 <SKIPCOPY>

08000228 <STARTCOPY>:
STARTCOPY:
   /* 
      R2 contains byte count. Change it to word count. It is ensured in the 
      linker script that the length is always word aligned.
   */
   LSR R2,R2,#2 /* Divide by 4 to obtain word count */
 8000228:	ea4f 0292 	mov.w	r2, r2, lsr #2

0800022c <COPYLOOP>:

   /* The proverbial loop from the schooldays */
COPYLOOP:
   LDR R3,[R0]
 800022c:	6803      	ldr	r3, [r0, #0]
   STR R3,[R1]
 800022e:	600b      	str	r3, [r1, #0]
   SUBS R2,#1
 8000230:	3a01      	subs	r2, #1
   BEQ SKIPCOPY
 8000232:	f000 8006 	beq.w	8000242 <SKIPCOPY>
   ADD R0,#4
 8000236:	f100 0004 	add.w	r0, r0, #4
   ADD R1,#4
 800023a:	f101 0104 	add.w	r1, r1, #4
   B COPYLOOP
 800023e:	f7ff bff5 	b.w	800022c <COPYLOOP>

08000242 <SKIPCOPY>:
    
SKIPCOPY:
   /* BSS CLEAR */
   LDR R0, =__Xmc4500_sBSS     /* Start of BSS */
 8000242:	4813      	ldr	r0, [pc, #76]	; (8000290 <SKIPCLEAR+0x2c>)
   LDR R1, =__Xmc4500_BSS_Size /* BSS size in bytes */
 8000244:	4913      	ldr	r1, [pc, #76]	; (8000294 <SKIPCLEAR+0x30>)

   /* Find out if there are items assigned to BSS */   
   CMP R1,#0 
 8000246:	2900      	cmp	r1, #0
   BEQ SKIPCLEAR
 8000248:	f000 800c 	beq.w	8000264 <SKIPCLEAR>

0800024c <STARTCLEAR>:

STARTCLEAR:
   LSR R1,R1,#2            /* BSS size in words */
 800024c:	ea4f 0191 	mov.w	r1, r1, lsr #2
   
   MOV R2,#0
 8000250:	f04f 0200 	mov.w	r2, #0

08000254 <CLEARLOOP>:
CLEARLOOP:
   STR R2,[R0]
 8000254:	6002      	str	r2, [r0, #0]
   SUBS R1,#1
 8000256:	3901      	subs	r1, #1
   BEQ SKIPCLEAR
 8000258:	f000 8004 	beq.w	8000264 <SKIPCLEAR>
   ADD R0,#4
 800025c:	f100 0004 	add.w	r0, r0, #4
   B CLEARLOOP
 8000260:	f7ff bff8 	b.w	8000254 <CLEARLOOP>

08000264 <SKIPCLEAR>:
    
SKIPCLEAR:
   /* Remap vector table */
   /* This is already setup by BootROM,hence this step is optional */ 
   LDR R0, =__Xmc4500_interrupt_vector_cortex_m 
 8000264:	480c      	ldr	r0, [pc, #48]	; (8000298 <SKIPCLEAR+0x34>)
   LDR R1, =SCB_VTOR
 8000266:	490d      	ldr	r1, [pc, #52]	; (800029c <SKIPCLEAR+0x38>)
   STR R0,[R1]
 8000268:	6008      	str	r0, [r1, #0]
   
   /* Update System Clock */
   LDR R0,=SystemCoreClockUpdate
 800026a:	480d      	ldr	r0, [pc, #52]	; (80002a0 <SKIPCLEAR+0x3c>)
   BLX R0
 800026c:	4780      	blx	r0
 
   /* C++ : Call global constructors */
   LDR R0,=__libc_init_array
 800026e:	480d      	ldr	r0, [pc, #52]	; (80002a4 <SKIPCLEAR+0x40>)
   BLX R0
 8000270:	4780      	blx	r0

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR SP,=__Xmc4500_stack 
 8000272:	f8df d034 	ldr.w	sp, [pc, #52]	; 80002a8 <SKIPCLEAR+0x44>
   MOV R0,#0
 8000276:	f04f 0000 	mov.w	r0, #0
   MOV R1,#0
 800027a:	f04f 0100 	mov.w	r1, #0
   LDR PC, =main
 800027e:	f8df f02c 	ldr.w	pc, [pc, #44]	; 80002ac <SKIPCLEAR+0x48>
 8000282:	0000      	.short	0x0000
   .fnstart
   /* Memories are accessible now*/
   
   /* DATA COPY */
   /* R0 = Start address, R1 = Destination address, R2 = Size */
   LDR R0, =eROData
 8000284:	0c026a20 	.word	0x0c026a20
   LDR R1, =__Xmc4500_sData
 8000288:	20006650 	.word	0x20006650
   LDR R2, =__Xmc4500_Data_Size
 800028c:	0000057c 	.word	0x0000057c
   ADD R1,#4
   B COPYLOOP
    
SKIPCOPY:
   /* BSS CLEAR */
   LDR R0, =__Xmc4500_sBSS     /* Start of BSS */
 8000290:	20000800 	.word	0x20000800
   LDR R1, =__Xmc4500_BSS_Size /* BSS size in bytes */
 8000294:	00005e50 	.word	0x00005e50
   B CLEARLOOP
    
SKIPCLEAR:
   /* Remap vector table */
   /* This is already setup by BootROM,hence this step is optional */ 
   LDR R0, =__Xmc4500_interrupt_vector_cortex_m 
 8000298:	08000000 	.word	0x08000000
   LDR R1, =SCB_VTOR
 800029c:	e000ed08 	.word	0xe000ed08
   STR R0,[R1]
   
   /* Update System Clock */
   LDR R0,=SystemCoreClockUpdate
 80002a0:	08000b7d 	.word	0x08000b7d
   BLX R0
 
   /* C++ : Call global constructors */
   LDR R0,=__libc_init_array
 80002a4:	08023479 	.word	0x08023479
   BLX R0

   /* Reset stack pointer before zipping off to user application, Optional */
   LDR SP,=__Xmc4500_stack 
 80002a8:	20000800 	.word	0x20000800
   MOV R0,#0
   MOV R1,#0
   LDR PC, =main
 80002ac:	08001815 	.word	0x08001815
*/
     .section ".XmcStartup"
     .weak SystemInit_DAVE3
     .type SystemInit_DAVE3, %function
SystemInit_DAVE3:
     NOP
 80002b0:	bf00      	nop
     BX LR
 80002b2:	4770      	bx	lr

080002b4 <NMI_Handler>:
/* Default exception Handlers - Users may override this default functionality by
   defining handlers of the same name in their C code */
    .thumb
    .text

     Insert_ExceptionHandler NMI_Handler
 80002b4:	e7fe      	b.n	80002b4 <NMI_Handler>

080002b6 <NMI_Handler_Veneer>:
 80002b6:	f8df 0670 	ldr.w	r0, [pc, #1648]	; 8000928 <GPDMA1_0_IRQHandler_Veneer+0x12>
 80002ba:	b500      	push	{lr}
 80002bc:	b081      	sub	sp, #4
 80002be:	4780      	blx	r0
 80002c0:	b001      	add	sp, #4
 80002c2:	bd00      	pop	{pc}

080002c4 <HardFault_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler HardFault_Handler
 80002c4:	e7fe      	b.n	80002c4 <HardFault_Handler>

080002c6 <HardFault_Handler_Veneer>:
 80002c6:	f8df 0664 	ldr.w	r0, [pc, #1636]	; 800092c <GPDMA1_0_IRQHandler_Veneer+0x16>
 80002ca:	b500      	push	{lr}
 80002cc:	b081      	sub	sp, #4
 80002ce:	4780      	blx	r0
 80002d0:	b001      	add	sp, #4
 80002d2:	bd00      	pop	{pc}

080002d4 <MemManage_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler MemManage_Handler
 80002d4:	e7fe      	b.n	80002d4 <MemManage_Handler>

080002d6 <MemManage_Handler_Veneer>:
 80002d6:	f8df 0658 	ldr.w	r0, [pc, #1624]	; 8000930 <GPDMA1_0_IRQHandler_Veneer+0x1a>
 80002da:	b500      	push	{lr}
 80002dc:	b081      	sub	sp, #4
 80002de:	4780      	blx	r0
 80002e0:	b001      	add	sp, #4
 80002e2:	bd00      	pop	{pc}

080002e4 <BusFault_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler BusFault_Handler
 80002e4:	e7fe      	b.n	80002e4 <BusFault_Handler>

080002e6 <BusFault_Handler_Veneer>:
 80002e6:	f8df 064c 	ldr.w	r0, [pc, #1612]	; 8000934 <GPDMA1_0_IRQHandler_Veneer+0x1e>
 80002ea:	b500      	push	{lr}
 80002ec:	b081      	sub	sp, #4
 80002ee:	4780      	blx	r0
 80002f0:	b001      	add	sp, #4
 80002f2:	bd00      	pop	{pc}

080002f4 <UsageFault_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler UsageFault_Handler
 80002f4:	e7fe      	b.n	80002f4 <UsageFault_Handler>

080002f6 <UsageFault_Handler_Veneer>:
 80002f6:	f8df 0640 	ldr.w	r0, [pc, #1600]	; 8000938 <GPDMA1_0_IRQHandler_Veneer+0x22>
 80002fa:	b500      	push	{lr}
 80002fc:	b081      	sub	sp, #4
 80002fe:	4780      	blx	r0
 8000300:	b001      	add	sp, #4
 8000302:	bd00      	pop	{pc}

08000304 <SVC_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler SVC_Handler
 8000304:	e7fe      	b.n	8000304 <SVC_Handler>

08000306 <SVC_Handler_Veneer>:
 8000306:	f8df 0634 	ldr.w	r0, [pc, #1588]	; 800093c <GPDMA1_0_IRQHandler_Veneer+0x26>
 800030a:	b500      	push	{lr}
 800030c:	b081      	sub	sp, #4
 800030e:	4780      	blx	r0
 8000310:	b001      	add	sp, #4
 8000312:	bd00      	pop	{pc}

08000314 <DebugMon_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler DebugMon_Handler
 8000314:	e7fe      	b.n	8000314 <DebugMon_Handler>

08000316 <DebugMon_Handler_Veneer>:
 8000316:	f8df 0628 	ldr.w	r0, [pc, #1576]	; 8000940 <GPDMA1_0_IRQHandler_Veneer+0x2a>
 800031a:	b500      	push	{lr}
 800031c:	b081      	sub	sp, #4
 800031e:	4780      	blx	r0
 8000320:	b001      	add	sp, #4
 8000322:	bd00      	pop	{pc}

08000324 <PendSV_Handler>:
/* ======================================================================== */
     Insert_ExceptionHandler PendSV_Handler
 8000324:	e7fe      	b.n	8000324 <PendSV_Handler>

08000326 <PendSV_Handler_Veneer>:
 8000326:	f8df 061c 	ldr.w	r0, [pc, #1564]	; 8000944 <GPDMA1_0_IRQHandler_Veneer+0x2e>
 800032a:	b500      	push	{lr}
 800032c:	b081      	sub	sp, #4
 800032e:	4780      	blx	r0
 8000330:	b001      	add	sp, #4
 8000332:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler SysTick_Handler
 8000334:	e7fe      	b.n	8000334 <PendSV_Handler_Veneer+0xe>

08000336 <SysTick_Handler_Veneer>:
 8000336:	f8df 0610 	ldr.w	r0, [pc, #1552]	; 8000948 <GPDMA1_0_IRQHandler_Veneer+0x32>
 800033a:	b500      	push	{lr}
 800033c:	b081      	sub	sp, #4
 800033e:	4780      	blx	r0
 8000340:	b001      	add	sp, #4
 8000342:	bd00      	pop	{pc}
/* ============= END OF EXCEPTION HANDLER DEFINITION ======================== */

/* ============= START OF INTERRUPT HANDLER DEFINITION ====================== */

/* IRQ Handlers */
     Insert_ExceptionHandler SCU_0_IRQHandler
 8000344:	e7fe      	b.n	8000344 <SysTick_Handler_Veneer+0xe>

08000346 <SCU_0_IRQHandler_Veneer>:
 8000346:	f8df 0604 	ldr.w	r0, [pc, #1540]	; 800094c <GPDMA1_0_IRQHandler_Veneer+0x36>
 800034a:	b500      	push	{lr}
 800034c:	b081      	sub	sp, #4
 800034e:	4780      	blx	r0
 8000350:	b001      	add	sp, #4
 8000352:	bd00      	pop	{pc}

08000354 <ERU0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_0_IRQHandler
 8000354:	e7fe      	b.n	8000354 <ERU0_0_IRQHandler>

08000356 <ERU0_0_IRQHandler_Veneer>:
 8000356:	f8df 05f8 	ldr.w	r0, [pc, #1528]	; 8000950 <GPDMA1_0_IRQHandler_Veneer+0x3a>
 800035a:	b500      	push	{lr}
 800035c:	b081      	sub	sp, #4
 800035e:	4780      	blx	r0
 8000360:	b001      	add	sp, #4
 8000362:	bd00      	pop	{pc}

08000364 <ERU0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_1_IRQHandler
 8000364:	e7fe      	b.n	8000364 <ERU0_1_IRQHandler>

08000366 <ERU0_1_IRQHandler_Veneer>:
 8000366:	f8df 05ec 	ldr.w	r0, [pc, #1516]	; 8000954 <GPDMA1_0_IRQHandler_Veneer+0x3e>
 800036a:	b500      	push	{lr}
 800036c:	b081      	sub	sp, #4
 800036e:	4780      	blx	r0
 8000370:	b001      	add	sp, #4
 8000372:	bd00      	pop	{pc}

08000374 <ERU0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_2_IRQHandler
 8000374:	e7fe      	b.n	8000374 <ERU0_2_IRQHandler>

08000376 <ERU0_2_IRQHandler_Veneer>:
 8000376:	f8df 05e0 	ldr.w	r0, [pc, #1504]	; 8000958 <GPDMA1_0_IRQHandler_Veneer+0x42>
 800037a:	b500      	push	{lr}
 800037c:	b081      	sub	sp, #4
 800037e:	4780      	blx	r0
 8000380:	b001      	add	sp, #4
 8000382:	bd00      	pop	{pc}

08000384 <ERU0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_3_IRQHandler
 8000384:	e7fe      	b.n	8000384 <ERU0_3_IRQHandler>

08000386 <ERU0_3_IRQHandler_Veneer>:
 8000386:	f8df 05d4 	ldr.w	r0, [pc, #1492]	; 800095c <GPDMA1_0_IRQHandler_Veneer+0x46>
 800038a:	b500      	push	{lr}
 800038c:	b081      	sub	sp, #4
 800038e:	4780      	blx	r0
 8000390:	b001      	add	sp, #4
 8000392:	bd00      	pop	{pc}

08000394 <ERU1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_0_IRQHandler
 8000394:	e7fe      	b.n	8000394 <ERU1_0_IRQHandler>

08000396 <ERU1_0_IRQHandler_Veneer>:
 8000396:	f8df 05c8 	ldr.w	r0, [pc, #1480]	; 8000960 <GPDMA1_0_IRQHandler_Veneer+0x4a>
 800039a:	b500      	push	{lr}
 800039c:	b081      	sub	sp, #4
 800039e:	4780      	blx	r0
 80003a0:	b001      	add	sp, #4
 80003a2:	bd00      	pop	{pc}

080003a4 <ERU1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_1_IRQHandler
 80003a4:	e7fe      	b.n	80003a4 <ERU1_1_IRQHandler>

080003a6 <ERU1_1_IRQHandler_Veneer>:
 80003a6:	f8df 05bc 	ldr.w	r0, [pc, #1468]	; 8000964 <GPDMA1_0_IRQHandler_Veneer+0x4e>
 80003aa:	b500      	push	{lr}
 80003ac:	b081      	sub	sp, #4
 80003ae:	4780      	blx	r0
 80003b0:	b001      	add	sp, #4
 80003b2:	bd00      	pop	{pc}

080003b4 <ERU1_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_2_IRQHandler
 80003b4:	e7fe      	b.n	80003b4 <ERU1_2_IRQHandler>

080003b6 <ERU1_2_IRQHandler_Veneer>:
 80003b6:	f8df 05b0 	ldr.w	r0, [pc, #1456]	; 8000968 <GPDMA1_0_IRQHandler_Veneer+0x52>
 80003ba:	b500      	push	{lr}
 80003bc:	b081      	sub	sp, #4
 80003be:	4780      	blx	r0
 80003c0:	b001      	add	sp, #4
 80003c2:	bd00      	pop	{pc}

080003c4 <ERU1_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_3_IRQHandler
 80003c4:	e7fe      	b.n	80003c4 <ERU1_3_IRQHandler>

080003c6 <ERU1_3_IRQHandler_Veneer>:
 80003c6:	f8df 05a4 	ldr.w	r0, [pc, #1444]	; 800096c <GPDMA1_0_IRQHandler_Veneer+0x56>
 80003ca:	b500      	push	{lr}
 80003cc:	b081      	sub	sp, #4
 80003ce:	4780      	blx	r0
 80003d0:	b001      	add	sp, #4
 80003d2:	bd00      	pop	{pc}

080003d4 <PMU0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler PMU0_0_IRQHandler
 80003d4:	e7fe      	b.n	80003d4 <PMU0_0_IRQHandler>

080003d6 <PMU0_0_IRQHandler_Veneer>:
 80003d6:	f8df 0598 	ldr.w	r0, [pc, #1432]	; 8000970 <GPDMA1_0_IRQHandler_Veneer+0x5a>
 80003da:	b500      	push	{lr}
 80003dc:	b081      	sub	sp, #4
 80003de:	4780      	blx	r0
 80003e0:	b001      	add	sp, #4
 80003e2:	bd00      	pop	{pc}

080003e4 <VADC0_C0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_0_IRQHandler
 80003e4:	e7fe      	b.n	80003e4 <VADC0_C0_0_IRQHandler>

080003e6 <VADC0_C0_0_IRQHandler_Veneer>:
 80003e6:	f8df 058c 	ldr.w	r0, [pc, #1420]	; 8000974 <GPDMA1_0_IRQHandler_Veneer+0x5e>
 80003ea:	b500      	push	{lr}
 80003ec:	b081      	sub	sp, #4
 80003ee:	4780      	blx	r0
 80003f0:	b001      	add	sp, #4
 80003f2:	bd00      	pop	{pc}

080003f4 <VADC0_C0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_1_IRQHandler
 80003f4:	e7fe      	b.n	80003f4 <VADC0_C0_1_IRQHandler>

080003f6 <VADC0_C0_1_IRQHandler_Veneer>:
 80003f6:	f8df 0580 	ldr.w	r0, [pc, #1408]	; 8000978 <GPDMA1_0_IRQHandler_Veneer+0x62>
 80003fa:	b500      	push	{lr}
 80003fc:	b081      	sub	sp, #4
 80003fe:	4780      	blx	r0
 8000400:	b001      	add	sp, #4
 8000402:	bd00      	pop	{pc}

08000404 <VADC0_C0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_2_IRQHandler
 8000404:	e7fe      	b.n	8000404 <VADC0_C0_2_IRQHandler>

08000406 <VADC0_C0_2_IRQHandler_Veneer>:
 8000406:	f8df 0574 	ldr.w	r0, [pc, #1396]	; 800097c <GPDMA1_0_IRQHandler_Veneer+0x66>
 800040a:	b500      	push	{lr}
 800040c:	b081      	sub	sp, #4
 800040e:	4780      	blx	r0
 8000410:	b001      	add	sp, #4
 8000412:	bd00      	pop	{pc}

08000414 <VADC0_C0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_3_IRQHandler
 8000414:	e7fe      	b.n	8000414 <VADC0_C0_3_IRQHandler>

08000416 <VADC0_C0_3_IRQHandler_Veneer>:
 8000416:	f8df 0568 	ldr.w	r0, [pc, #1384]	; 8000980 <GPDMA1_0_IRQHandler_Veneer+0x6a>
 800041a:	b500      	push	{lr}
 800041c:	b081      	sub	sp, #4
 800041e:	4780      	blx	r0
 8000420:	b001      	add	sp, #4
 8000422:	bd00      	pop	{pc}

08000424 <VADC0_G0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_0_IRQHandler
 8000424:	e7fe      	b.n	8000424 <VADC0_G0_0_IRQHandler>

08000426 <VADC0_G0_0_IRQHandler_Veneer>:
 8000426:	f8df 055c 	ldr.w	r0, [pc, #1372]	; 8000984 <GPDMA1_0_IRQHandler_Veneer+0x6e>
 800042a:	b500      	push	{lr}
 800042c:	b081      	sub	sp, #4
 800042e:	4780      	blx	r0
 8000430:	b001      	add	sp, #4
 8000432:	bd00      	pop	{pc}

08000434 <VADC0_G0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_1_IRQHandler
 8000434:	e7fe      	b.n	8000434 <VADC0_G0_1_IRQHandler>

08000436 <VADC0_G0_1_IRQHandler_Veneer>:
 8000436:	f8df 0550 	ldr.w	r0, [pc, #1360]	; 8000988 <GPDMA1_0_IRQHandler_Veneer+0x72>
 800043a:	b500      	push	{lr}
 800043c:	b081      	sub	sp, #4
 800043e:	4780      	blx	r0
 8000440:	b001      	add	sp, #4
 8000442:	bd00      	pop	{pc}

08000444 <VADC0_G0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_2_IRQHandler
 8000444:	e7fe      	b.n	8000444 <VADC0_G0_2_IRQHandler>

08000446 <VADC0_G0_2_IRQHandler_Veneer>:
 8000446:	f8df 0544 	ldr.w	r0, [pc, #1348]	; 800098c <GPDMA1_0_IRQHandler_Veneer+0x76>
 800044a:	b500      	push	{lr}
 800044c:	b081      	sub	sp, #4
 800044e:	4780      	blx	r0
 8000450:	b001      	add	sp, #4
 8000452:	bd00      	pop	{pc}

08000454 <VADC0_G0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_3_IRQHandler
 8000454:	e7fe      	b.n	8000454 <VADC0_G0_3_IRQHandler>

08000456 <VADC0_G0_3_IRQHandler_Veneer>:
 8000456:	f8df 0538 	ldr.w	r0, [pc, #1336]	; 8000990 <GPDMA1_0_IRQHandler_Veneer+0x7a>
 800045a:	b500      	push	{lr}
 800045c:	b081      	sub	sp, #4
 800045e:	4780      	blx	r0
 8000460:	b001      	add	sp, #4
 8000462:	bd00      	pop	{pc}

08000464 <VADC0_G1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_0_IRQHandler
 8000464:	e7fe      	b.n	8000464 <VADC0_G1_0_IRQHandler>

08000466 <VADC0_G1_0_IRQHandler_Veneer>:
 8000466:	f8df 052c 	ldr.w	r0, [pc, #1324]	; 8000994 <GPDMA1_0_IRQHandler_Veneer+0x7e>
 800046a:	b500      	push	{lr}
 800046c:	b081      	sub	sp, #4
 800046e:	4780      	blx	r0
 8000470:	b001      	add	sp, #4
 8000472:	bd00      	pop	{pc}

08000474 <VADC0_G1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_1_IRQHandler
 8000474:	e7fe      	b.n	8000474 <VADC0_G1_1_IRQHandler>

08000476 <VADC0_G1_1_IRQHandler_Veneer>:
 8000476:	f8df 0520 	ldr.w	r0, [pc, #1312]	; 8000998 <GPDMA1_0_IRQHandler_Veneer+0x82>
 800047a:	b500      	push	{lr}
 800047c:	b081      	sub	sp, #4
 800047e:	4780      	blx	r0
 8000480:	b001      	add	sp, #4
 8000482:	bd00      	pop	{pc}

08000484 <VADC0_G1_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_2_IRQHandler
 8000484:	e7fe      	b.n	8000484 <VADC0_G1_2_IRQHandler>

08000486 <VADC0_G1_2_IRQHandler_Veneer>:
 8000486:	f8df 0514 	ldr.w	r0, [pc, #1300]	; 800099c <GPDMA1_0_IRQHandler_Veneer+0x86>
 800048a:	b500      	push	{lr}
 800048c:	b081      	sub	sp, #4
 800048e:	4780      	blx	r0
 8000490:	b001      	add	sp, #4
 8000492:	bd00      	pop	{pc}

08000494 <VADC0_G1_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_3_IRQHandler
 8000494:	e7fe      	b.n	8000494 <VADC0_G1_3_IRQHandler>

08000496 <VADC0_G1_3_IRQHandler_Veneer>:
 8000496:	f8df 0508 	ldr.w	r0, [pc, #1288]	; 80009a0 <GPDMA1_0_IRQHandler_Veneer+0x8a>
 800049a:	b500      	push	{lr}
 800049c:	b081      	sub	sp, #4
 800049e:	4780      	blx	r0
 80004a0:	b001      	add	sp, #4
 80004a2:	bd00      	pop	{pc}

080004a4 <VADC0_G2_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_0_IRQHandler
 80004a4:	e7fe      	b.n	80004a4 <VADC0_G2_0_IRQHandler>

080004a6 <VADC0_G2_0_IRQHandler_Veneer>:
 80004a6:	f8df 04fc 	ldr.w	r0, [pc, #1276]	; 80009a4 <GPDMA1_0_IRQHandler_Veneer+0x8e>
 80004aa:	b500      	push	{lr}
 80004ac:	b081      	sub	sp, #4
 80004ae:	4780      	blx	r0
 80004b0:	b001      	add	sp, #4
 80004b2:	bd00      	pop	{pc}

080004b4 <VADC0_G2_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_1_IRQHandler
 80004b4:	e7fe      	b.n	80004b4 <VADC0_G2_1_IRQHandler>

080004b6 <VADC0_G2_1_IRQHandler_Veneer>:
 80004b6:	f8df 04f0 	ldr.w	r0, [pc, #1264]	; 80009a8 <GPDMA1_0_IRQHandler_Veneer+0x92>
 80004ba:	b500      	push	{lr}
 80004bc:	b081      	sub	sp, #4
 80004be:	4780      	blx	r0
 80004c0:	b001      	add	sp, #4
 80004c2:	bd00      	pop	{pc}

080004c4 <VADC0_G2_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_2_IRQHandler
 80004c4:	e7fe      	b.n	80004c4 <VADC0_G2_2_IRQHandler>

080004c6 <VADC0_G2_2_IRQHandler_Veneer>:
 80004c6:	f8df 04e4 	ldr.w	r0, [pc, #1252]	; 80009ac <GPDMA1_0_IRQHandler_Veneer+0x96>
 80004ca:	b500      	push	{lr}
 80004cc:	b081      	sub	sp, #4
 80004ce:	4780      	blx	r0
 80004d0:	b001      	add	sp, #4
 80004d2:	bd00      	pop	{pc}

080004d4 <VADC0_G2_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_3_IRQHandler
 80004d4:	e7fe      	b.n	80004d4 <VADC0_G2_3_IRQHandler>

080004d6 <VADC0_G2_3_IRQHandler_Veneer>:
 80004d6:	f8df 04d8 	ldr.w	r0, [pc, #1240]	; 80009b0 <GPDMA1_0_IRQHandler_Veneer+0x9a>
 80004da:	b500      	push	{lr}
 80004dc:	b081      	sub	sp, #4
 80004de:	4780      	blx	r0
 80004e0:	b001      	add	sp, #4
 80004e2:	bd00      	pop	{pc}

080004e4 <VADC0_G3_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_0_IRQHandler
 80004e4:	e7fe      	b.n	80004e4 <VADC0_G3_0_IRQHandler>

080004e6 <VADC0_G3_0_IRQHandler_Veneer>:
 80004e6:	f8df 04cc 	ldr.w	r0, [pc, #1228]	; 80009b4 <GPDMA1_0_IRQHandler_Veneer+0x9e>
 80004ea:	b500      	push	{lr}
 80004ec:	b081      	sub	sp, #4
 80004ee:	4780      	blx	r0
 80004f0:	b001      	add	sp, #4
 80004f2:	bd00      	pop	{pc}

080004f4 <VADC0_G3_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_1_IRQHandler
 80004f4:	e7fe      	b.n	80004f4 <VADC0_G3_1_IRQHandler>

080004f6 <VADC0_G3_1_IRQHandler_Veneer>:
 80004f6:	f8df 04c0 	ldr.w	r0, [pc, #1216]	; 80009b8 <GPDMA1_0_IRQHandler_Veneer+0xa2>
 80004fa:	b500      	push	{lr}
 80004fc:	b081      	sub	sp, #4
 80004fe:	4780      	blx	r0
 8000500:	b001      	add	sp, #4
 8000502:	bd00      	pop	{pc}

08000504 <VADC0_G3_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_2_IRQHandler
 8000504:	e7fe      	b.n	8000504 <VADC0_G3_2_IRQHandler>

08000506 <VADC0_G3_2_IRQHandler_Veneer>:
 8000506:	f8df 04b4 	ldr.w	r0, [pc, #1204]	; 80009bc <GPDMA1_0_IRQHandler_Veneer+0xa6>
 800050a:	b500      	push	{lr}
 800050c:	b081      	sub	sp, #4
 800050e:	4780      	blx	r0
 8000510:	b001      	add	sp, #4
 8000512:	bd00      	pop	{pc}

08000514 <VADC0_G3_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_3_IRQHandler
 8000514:	e7fe      	b.n	8000514 <VADC0_G3_3_IRQHandler>

08000516 <VADC0_G3_3_IRQHandler_Veneer>:
 8000516:	f8df 04a8 	ldr.w	r0, [pc, #1192]	; 80009c0 <GPDMA1_0_IRQHandler_Veneer+0xaa>
 800051a:	b500      	push	{lr}
 800051c:	b081      	sub	sp, #4
 800051e:	4780      	blx	r0
 8000520:	b001      	add	sp, #4
 8000522:	bd00      	pop	{pc}

08000524 <DSD0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_0_IRQHandler
 8000524:	e7fe      	b.n	8000524 <DSD0_0_IRQHandler>

08000526 <DSD0_0_IRQHandler_Veneer>:
 8000526:	f8df 049c 	ldr.w	r0, [pc, #1180]	; 80009c4 <GPDMA1_0_IRQHandler_Veneer+0xae>
 800052a:	b500      	push	{lr}
 800052c:	b081      	sub	sp, #4
 800052e:	4780      	blx	r0
 8000530:	b001      	add	sp, #4
 8000532:	bd00      	pop	{pc}

08000534 <DSD0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_1_IRQHandler
 8000534:	e7fe      	b.n	8000534 <DSD0_1_IRQHandler>

08000536 <DSD0_1_IRQHandler_Veneer>:
 8000536:	f8df 0490 	ldr.w	r0, [pc, #1168]	; 80009c8 <GPDMA1_0_IRQHandler_Veneer+0xb2>
 800053a:	b500      	push	{lr}
 800053c:	b081      	sub	sp, #4
 800053e:	4780      	blx	r0
 8000540:	b001      	add	sp, #4
 8000542:	bd00      	pop	{pc}

08000544 <DSD0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_2_IRQHandler
 8000544:	e7fe      	b.n	8000544 <DSD0_2_IRQHandler>

08000546 <DSD0_2_IRQHandler_Veneer>:
 8000546:	f8df 0484 	ldr.w	r0, [pc, #1156]	; 80009cc <GPDMA1_0_IRQHandler_Veneer+0xb6>
 800054a:	b500      	push	{lr}
 800054c:	b081      	sub	sp, #4
 800054e:	4780      	blx	r0
 8000550:	b001      	add	sp, #4
 8000552:	bd00      	pop	{pc}

08000554 <DSD0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_3_IRQHandler
 8000554:	e7fe      	b.n	8000554 <DSD0_3_IRQHandler>

08000556 <DSD0_3_IRQHandler_Veneer>:
 8000556:	f8df 0478 	ldr.w	r0, [pc, #1144]	; 80009d0 <GPDMA1_0_IRQHandler_Veneer+0xba>
 800055a:	b500      	push	{lr}
 800055c:	b081      	sub	sp, #4
 800055e:	4780      	blx	r0
 8000560:	b001      	add	sp, #4
 8000562:	bd00      	pop	{pc}

08000564 <DSD0_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_4_IRQHandler
 8000564:	e7fe      	b.n	8000564 <DSD0_4_IRQHandler>

08000566 <DSD0_4_IRQHandler_Veneer>:
 8000566:	f8df 046c 	ldr.w	r0, [pc, #1132]	; 80009d4 <GPDMA1_0_IRQHandler_Veneer+0xbe>
 800056a:	b500      	push	{lr}
 800056c:	b081      	sub	sp, #4
 800056e:	4780      	blx	r0
 8000570:	b001      	add	sp, #4
 8000572:	bd00      	pop	{pc}

08000574 <DSD0_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_5_IRQHandler
 8000574:	e7fe      	b.n	8000574 <DSD0_5_IRQHandler>

08000576 <DSD0_5_IRQHandler_Veneer>:
 8000576:	f8df 0460 	ldr.w	r0, [pc, #1120]	; 80009d8 <GPDMA1_0_IRQHandler_Veneer+0xc2>
 800057a:	b500      	push	{lr}
 800057c:	b081      	sub	sp, #4
 800057e:	4780      	blx	r0
 8000580:	b001      	add	sp, #4
 8000582:	bd00      	pop	{pc}

08000584 <DSD0_6_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_6_IRQHandler
 8000584:	e7fe      	b.n	8000584 <DSD0_6_IRQHandler>

08000586 <DSD0_6_IRQHandler_Veneer>:
 8000586:	f8df 0454 	ldr.w	r0, [pc, #1108]	; 80009dc <GPDMA1_0_IRQHandler_Veneer+0xc6>
 800058a:	b500      	push	{lr}
 800058c:	b081      	sub	sp, #4
 800058e:	4780      	blx	r0
 8000590:	b001      	add	sp, #4
 8000592:	bd00      	pop	{pc}

08000594 <DSD0_7_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_7_IRQHandler
 8000594:	e7fe      	b.n	8000594 <DSD0_7_IRQHandler>

08000596 <DSD0_7_IRQHandler_Veneer>:
 8000596:	f8df 0448 	ldr.w	r0, [pc, #1096]	; 80009e0 <GPDMA1_0_IRQHandler_Veneer+0xca>
 800059a:	b500      	push	{lr}
 800059c:	b081      	sub	sp, #4
 800059e:	4780      	blx	r0
 80005a0:	b001      	add	sp, #4
 80005a2:	bd00      	pop	{pc}

080005a4 <DAC0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_0_IRQHandler
 80005a4:	e7fe      	b.n	80005a4 <DAC0_0_IRQHandler>

080005a6 <DAC0_0_IRQHandler_Veneer>:
 80005a6:	f8df 043c 	ldr.w	r0, [pc, #1084]	; 80009e4 <GPDMA1_0_IRQHandler_Veneer+0xce>
 80005aa:	b500      	push	{lr}
 80005ac:	b081      	sub	sp, #4
 80005ae:	4780      	blx	r0
 80005b0:	b001      	add	sp, #4
 80005b2:	bd00      	pop	{pc}

080005b4 <DAC0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_1_IRQHandler
 80005b4:	e7fe      	b.n	80005b4 <DAC0_1_IRQHandler>

080005b6 <DAC0_1_IRQHandler_Veneer>:
 80005b6:	f8df 0430 	ldr.w	r0, [pc, #1072]	; 80009e8 <GPDMA1_0_IRQHandler_Veneer+0xd2>
 80005ba:	b500      	push	{lr}
 80005bc:	b081      	sub	sp, #4
 80005be:	4780      	blx	r0
 80005c0:	b001      	add	sp, #4
 80005c2:	bd00      	pop	{pc}

080005c4 <CCU40_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_0_IRQHandler
 80005c4:	e7fe      	b.n	80005c4 <CCU40_0_IRQHandler>

080005c6 <CCU40_0_IRQHandler_Veneer>:
 80005c6:	f8df 0424 	ldr.w	r0, [pc, #1060]	; 80009ec <GPDMA1_0_IRQHandler_Veneer+0xd6>
 80005ca:	b500      	push	{lr}
 80005cc:	b081      	sub	sp, #4
 80005ce:	4780      	blx	r0
 80005d0:	b001      	add	sp, #4
 80005d2:	bd00      	pop	{pc}

080005d4 <CCU40_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_1_IRQHandler
 80005d4:	e7fe      	b.n	80005d4 <CCU40_1_IRQHandler>

080005d6 <CCU40_1_IRQHandler_Veneer>:
 80005d6:	f8df 0418 	ldr.w	r0, [pc, #1048]	; 80009f0 <GPDMA1_0_IRQHandler_Veneer+0xda>
 80005da:	b500      	push	{lr}
 80005dc:	b081      	sub	sp, #4
 80005de:	4780      	blx	r0
 80005e0:	b001      	add	sp, #4
 80005e2:	bd00      	pop	{pc}

080005e4 <CCU40_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_2_IRQHandler
 80005e4:	e7fe      	b.n	80005e4 <CCU40_2_IRQHandler>

080005e6 <CCU40_2_IRQHandler_Veneer>:
 80005e6:	f8df 040c 	ldr.w	r0, [pc, #1036]	; 80009f4 <GPDMA1_0_IRQHandler_Veneer+0xde>
 80005ea:	b500      	push	{lr}
 80005ec:	b081      	sub	sp, #4
 80005ee:	4780      	blx	r0
 80005f0:	b001      	add	sp, #4
 80005f2:	bd00      	pop	{pc}

080005f4 <CCU40_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_3_IRQHandler
 80005f4:	e7fe      	b.n	80005f4 <CCU40_3_IRQHandler>

080005f6 <CCU40_3_IRQHandler_Veneer>:
 80005f6:	f8df 0400 	ldr.w	r0, [pc, #1024]	; 80009f8 <GPDMA1_0_IRQHandler_Veneer+0xe2>
 80005fa:	b500      	push	{lr}
 80005fc:	b081      	sub	sp, #4
 80005fe:	4780      	blx	r0
 8000600:	b001      	add	sp, #4
 8000602:	bd00      	pop	{pc}

08000604 <CCU41_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_0_IRQHandler
 8000604:	e7fe      	b.n	8000604 <CCU41_0_IRQHandler>

08000606 <CCU41_0_IRQHandler_Veneer>:
 8000606:	48fd      	ldr	r0, [pc, #1012]	; (80009fc <GPDMA1_0_IRQHandler_Veneer+0xe6>)
 8000608:	b500      	push	{lr}
 800060a:	b081      	sub	sp, #4
 800060c:	4780      	blx	r0
 800060e:	b001      	add	sp, #4
 8000610:	bd00      	pop	{pc}

08000612 <CCU41_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_1_IRQHandler
 8000612:	e7fe      	b.n	8000612 <CCU41_1_IRQHandler>

08000614 <CCU41_1_IRQHandler_Veneer>:
 8000614:	48fa      	ldr	r0, [pc, #1000]	; (8000a00 <GPDMA1_0_IRQHandler_Veneer+0xea>)
 8000616:	b500      	push	{lr}
 8000618:	b081      	sub	sp, #4
 800061a:	4780      	blx	r0
 800061c:	b001      	add	sp, #4
 800061e:	bd00      	pop	{pc}

08000620 <CCU41_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_2_IRQHandler
 8000620:	e7fe      	b.n	8000620 <CCU41_2_IRQHandler>

08000622 <CCU41_2_IRQHandler_Veneer>:
 8000622:	48f8      	ldr	r0, [pc, #992]	; (8000a04 <GPDMA1_0_IRQHandler_Veneer+0xee>)
 8000624:	b500      	push	{lr}
 8000626:	b081      	sub	sp, #4
 8000628:	4780      	blx	r0
 800062a:	b001      	add	sp, #4
 800062c:	bd00      	pop	{pc}

0800062e <CCU41_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_3_IRQHandler
 800062e:	e7fe      	b.n	800062e <CCU41_3_IRQHandler>

08000630 <CCU41_3_IRQHandler_Veneer>:
 8000630:	48f5      	ldr	r0, [pc, #980]	; (8000a08 <GPDMA1_0_IRQHandler_Veneer+0xf2>)
 8000632:	b500      	push	{lr}
 8000634:	b081      	sub	sp, #4
 8000636:	4780      	blx	r0
 8000638:	b001      	add	sp, #4
 800063a:	bd00      	pop	{pc}

0800063c <CCU42_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_0_IRQHandler
 800063c:	e7fe      	b.n	800063c <CCU42_0_IRQHandler>

0800063e <CCU42_0_IRQHandler_Veneer>:
 800063e:	48f3      	ldr	r0, [pc, #972]	; (8000a0c <GPDMA1_0_IRQHandler_Veneer+0xf6>)
 8000640:	b500      	push	{lr}
 8000642:	b081      	sub	sp, #4
 8000644:	4780      	blx	r0
 8000646:	b001      	add	sp, #4
 8000648:	bd00      	pop	{pc}

0800064a <CCU42_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_1_IRQHandler
 800064a:	e7fe      	b.n	800064a <CCU42_1_IRQHandler>

0800064c <CCU42_1_IRQHandler_Veneer>:
 800064c:	48f0      	ldr	r0, [pc, #960]	; (8000a10 <GPDMA1_0_IRQHandler_Veneer+0xfa>)
 800064e:	b500      	push	{lr}
 8000650:	b081      	sub	sp, #4
 8000652:	4780      	blx	r0
 8000654:	b001      	add	sp, #4
 8000656:	bd00      	pop	{pc}

08000658 <CCU42_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_2_IRQHandler
 8000658:	e7fe      	b.n	8000658 <CCU42_2_IRQHandler>

0800065a <CCU42_2_IRQHandler_Veneer>:
 800065a:	48ee      	ldr	r0, [pc, #952]	; (8000a14 <GPDMA1_0_IRQHandler_Veneer+0xfe>)
 800065c:	b500      	push	{lr}
 800065e:	b081      	sub	sp, #4
 8000660:	4780      	blx	r0
 8000662:	b001      	add	sp, #4
 8000664:	bd00      	pop	{pc}

08000666 <CCU42_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_3_IRQHandler
 8000666:	e7fe      	b.n	8000666 <CCU42_3_IRQHandler>

08000668 <CCU42_3_IRQHandler_Veneer>:
 8000668:	48eb      	ldr	r0, [pc, #940]	; (8000a18 <GPDMA1_0_IRQHandler_Veneer+0x102>)
 800066a:	b500      	push	{lr}
 800066c:	b081      	sub	sp, #4
 800066e:	4780      	blx	r0
 8000670:	b001      	add	sp, #4
 8000672:	bd00      	pop	{pc}

08000674 <CCU43_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_0_IRQHandler
 8000674:	e7fe      	b.n	8000674 <CCU43_0_IRQHandler>

08000676 <CCU43_0_IRQHandler_Veneer>:
 8000676:	48e9      	ldr	r0, [pc, #932]	; (8000a1c <GPDMA1_0_IRQHandler_Veneer+0x106>)
 8000678:	b500      	push	{lr}
 800067a:	b081      	sub	sp, #4
 800067c:	4780      	blx	r0
 800067e:	b001      	add	sp, #4
 8000680:	bd00      	pop	{pc}

08000682 <CCU43_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_1_IRQHandler
 8000682:	e7fe      	b.n	8000682 <CCU43_1_IRQHandler>

08000684 <CCU43_1_IRQHandler_Veneer>:
 8000684:	48e6      	ldr	r0, [pc, #920]	; (8000a20 <GPDMA1_0_IRQHandler_Veneer+0x10a>)
 8000686:	b500      	push	{lr}
 8000688:	b081      	sub	sp, #4
 800068a:	4780      	blx	r0
 800068c:	b001      	add	sp, #4
 800068e:	bd00      	pop	{pc}

08000690 <CCU43_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_2_IRQHandler
 8000690:	e7fe      	b.n	8000690 <CCU43_2_IRQHandler>

08000692 <CCU43_2_IRQHandler_Veneer>:
 8000692:	48e4      	ldr	r0, [pc, #912]	; (8000a24 <GPDMA1_0_IRQHandler_Veneer+0x10e>)
 8000694:	b500      	push	{lr}
 8000696:	b081      	sub	sp, #4
 8000698:	4780      	blx	r0
 800069a:	b001      	add	sp, #4
 800069c:	bd00      	pop	{pc}

0800069e <CCU43_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_3_IRQHandler
 800069e:	e7fe      	b.n	800069e <CCU43_3_IRQHandler>

080006a0 <CCU43_3_IRQHandler_Veneer>:
 80006a0:	48e1      	ldr	r0, [pc, #900]	; (8000a28 <GPDMA1_0_IRQHandler_Veneer+0x112>)
 80006a2:	b500      	push	{lr}
 80006a4:	b081      	sub	sp, #4
 80006a6:	4780      	blx	r0
 80006a8:	b001      	add	sp, #4
 80006aa:	bd00      	pop	{pc}

080006ac <CCU80_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_0_IRQHandler
 80006ac:	e7fe      	b.n	80006ac <CCU80_0_IRQHandler>

080006ae <CCU80_0_IRQHandler_Veneer>:
 80006ae:	48df      	ldr	r0, [pc, #892]	; (8000a2c <GPDMA1_0_IRQHandler_Veneer+0x116>)
 80006b0:	b500      	push	{lr}
 80006b2:	b081      	sub	sp, #4
 80006b4:	4780      	blx	r0
 80006b6:	b001      	add	sp, #4
 80006b8:	bd00      	pop	{pc}

080006ba <CCU80_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_1_IRQHandler
 80006ba:	e7fe      	b.n	80006ba <CCU80_1_IRQHandler>

080006bc <CCU80_1_IRQHandler_Veneer>:
 80006bc:	48dc      	ldr	r0, [pc, #880]	; (8000a30 <GPDMA1_0_IRQHandler_Veneer+0x11a>)
 80006be:	b500      	push	{lr}
 80006c0:	b081      	sub	sp, #4
 80006c2:	4780      	blx	r0
 80006c4:	b001      	add	sp, #4
 80006c6:	bd00      	pop	{pc}

080006c8 <CCU80_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_2_IRQHandler
 80006c8:	e7fe      	b.n	80006c8 <CCU80_2_IRQHandler>

080006ca <CCU80_2_IRQHandler_Veneer>:
 80006ca:	48da      	ldr	r0, [pc, #872]	; (8000a34 <GPDMA1_0_IRQHandler_Veneer+0x11e>)
 80006cc:	b500      	push	{lr}
 80006ce:	b081      	sub	sp, #4
 80006d0:	4780      	blx	r0
 80006d2:	b001      	add	sp, #4
 80006d4:	bd00      	pop	{pc}

080006d6 <CCU80_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_3_IRQHandler
 80006d6:	e7fe      	b.n	80006d6 <CCU80_3_IRQHandler>

080006d8 <CCU80_3_IRQHandler_Veneer>:
 80006d8:	48d7      	ldr	r0, [pc, #860]	; (8000a38 <GPDMA1_0_IRQHandler_Veneer+0x122>)
 80006da:	b500      	push	{lr}
 80006dc:	b081      	sub	sp, #4
 80006de:	4780      	blx	r0
 80006e0:	b001      	add	sp, #4
 80006e2:	bd00      	pop	{pc}

080006e4 <CCU81_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_0_IRQHandler
 80006e4:	e7fe      	b.n	80006e4 <CCU81_0_IRQHandler>

080006e6 <CCU81_0_IRQHandler_Veneer>:
 80006e6:	48d5      	ldr	r0, [pc, #852]	; (8000a3c <GPDMA1_0_IRQHandler_Veneer+0x126>)
 80006e8:	b500      	push	{lr}
 80006ea:	b081      	sub	sp, #4
 80006ec:	4780      	blx	r0
 80006ee:	b001      	add	sp, #4
 80006f0:	bd00      	pop	{pc}

080006f2 <CCU81_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_1_IRQHandler
 80006f2:	e7fe      	b.n	80006f2 <CCU81_1_IRQHandler>

080006f4 <CCU81_1_IRQHandler_Veneer>:
 80006f4:	48d2      	ldr	r0, [pc, #840]	; (8000a40 <GPDMA1_0_IRQHandler_Veneer+0x12a>)
 80006f6:	b500      	push	{lr}
 80006f8:	b081      	sub	sp, #4
 80006fa:	4780      	blx	r0
 80006fc:	b001      	add	sp, #4
 80006fe:	bd00      	pop	{pc}

08000700 <CCU81_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_2_IRQHandler
 8000700:	e7fe      	b.n	8000700 <CCU81_2_IRQHandler>

08000702 <CCU81_2_IRQHandler_Veneer>:
 8000702:	48d0      	ldr	r0, [pc, #832]	; (8000a44 <GPDMA1_0_IRQHandler_Veneer+0x12e>)
 8000704:	b500      	push	{lr}
 8000706:	b081      	sub	sp, #4
 8000708:	4780      	blx	r0
 800070a:	b001      	add	sp, #4
 800070c:	bd00      	pop	{pc}

0800070e <CCU81_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_3_IRQHandler
 800070e:	e7fe      	b.n	800070e <CCU81_3_IRQHandler>

08000710 <CCU81_3_IRQHandler_Veneer>:
 8000710:	48cd      	ldr	r0, [pc, #820]	; (8000a48 <GPDMA1_0_IRQHandler_Veneer+0x132>)
 8000712:	b500      	push	{lr}
 8000714:	b081      	sub	sp, #4
 8000716:	4780      	blx	r0
 8000718:	b001      	add	sp, #4
 800071a:	bd00      	pop	{pc}

0800071c <POSIF0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_0_IRQHandler
 800071c:	e7fe      	b.n	800071c <POSIF0_0_IRQHandler>

0800071e <POSIF0_0_IRQHandler_Veneer>:
 800071e:	48cb      	ldr	r0, [pc, #812]	; (8000a4c <GPDMA1_0_IRQHandler_Veneer+0x136>)
 8000720:	b500      	push	{lr}
 8000722:	b081      	sub	sp, #4
 8000724:	4780      	blx	r0
 8000726:	b001      	add	sp, #4
 8000728:	bd00      	pop	{pc}

0800072a <POSIF0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_1_IRQHandler
 800072a:	e7fe      	b.n	800072a <POSIF0_1_IRQHandler>

0800072c <POSIF0_1_IRQHandler_Veneer>:
 800072c:	48c8      	ldr	r0, [pc, #800]	; (8000a50 <GPDMA1_0_IRQHandler_Veneer+0x13a>)
 800072e:	b500      	push	{lr}
 8000730:	b081      	sub	sp, #4
 8000732:	4780      	blx	r0
 8000734:	b001      	add	sp, #4
 8000736:	bd00      	pop	{pc}

08000738 <POSIF1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_0_IRQHandler
 8000738:	e7fe      	b.n	8000738 <POSIF1_0_IRQHandler>

0800073a <POSIF1_0_IRQHandler_Veneer>:
 800073a:	48c6      	ldr	r0, [pc, #792]	; (8000a54 <GPDMA1_0_IRQHandler_Veneer+0x13e>)
 800073c:	b500      	push	{lr}
 800073e:	b081      	sub	sp, #4
 8000740:	4780      	blx	r0
 8000742:	b001      	add	sp, #4
 8000744:	bd00      	pop	{pc}

08000746 <POSIF1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_1_IRQHandler
 8000746:	e7fe      	b.n	8000746 <POSIF1_1_IRQHandler>

08000748 <POSIF1_1_IRQHandler_Veneer>:
 8000748:	48c3      	ldr	r0, [pc, #780]	; (8000a58 <GPDMA1_0_IRQHandler_Veneer+0x142>)
 800074a:	b500      	push	{lr}
 800074c:	b081      	sub	sp, #4
 800074e:	4780      	blx	r0
 8000750:	b001      	add	sp, #4
 8000752:	bd00      	pop	{pc}

08000754 <CAN0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_0_IRQHandler
 8000754:	e7fe      	b.n	8000754 <CAN0_0_IRQHandler>

08000756 <CAN0_0_IRQHandler_Veneer>:
 8000756:	48c1      	ldr	r0, [pc, #772]	; (8000a5c <GPDMA1_0_IRQHandler_Veneer+0x146>)
 8000758:	b500      	push	{lr}
 800075a:	b081      	sub	sp, #4
 800075c:	4780      	blx	r0
 800075e:	b001      	add	sp, #4
 8000760:	bd00      	pop	{pc}

08000762 <CAN0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_1_IRQHandler
 8000762:	e7fe      	b.n	8000762 <CAN0_1_IRQHandler>

08000764 <CAN0_1_IRQHandler_Veneer>:
 8000764:	48be      	ldr	r0, [pc, #760]	; (8000a60 <GPDMA1_0_IRQHandler_Veneer+0x14a>)
 8000766:	b500      	push	{lr}
 8000768:	b081      	sub	sp, #4
 800076a:	4780      	blx	r0
 800076c:	b001      	add	sp, #4
 800076e:	bd00      	pop	{pc}

08000770 <CAN0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_2_IRQHandler
 8000770:	e7fe      	b.n	8000770 <CAN0_2_IRQHandler>

08000772 <CAN0_2_IRQHandler_Veneer>:
 8000772:	48bc      	ldr	r0, [pc, #752]	; (8000a64 <GPDMA1_0_IRQHandler_Veneer+0x14e>)
 8000774:	b500      	push	{lr}
 8000776:	b081      	sub	sp, #4
 8000778:	4780      	blx	r0
 800077a:	b001      	add	sp, #4
 800077c:	bd00      	pop	{pc}

0800077e <CAN0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_3_IRQHandler
 800077e:	e7fe      	b.n	800077e <CAN0_3_IRQHandler>

08000780 <CAN0_3_IRQHandler_Veneer>:
 8000780:	48b9      	ldr	r0, [pc, #740]	; (8000a68 <GPDMA1_0_IRQHandler_Veneer+0x152>)
 8000782:	b500      	push	{lr}
 8000784:	b081      	sub	sp, #4
 8000786:	4780      	blx	r0
 8000788:	b001      	add	sp, #4
 800078a:	bd00      	pop	{pc}

0800078c <CAN0_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_4_IRQHandler
 800078c:	e7fe      	b.n	800078c <CAN0_4_IRQHandler>

0800078e <CAN0_4_IRQHandler_Veneer>:
 800078e:	48b7      	ldr	r0, [pc, #732]	; (8000a6c <GPDMA1_0_IRQHandler_Veneer+0x156>)
 8000790:	b500      	push	{lr}
 8000792:	b081      	sub	sp, #4
 8000794:	4780      	blx	r0
 8000796:	b001      	add	sp, #4
 8000798:	bd00      	pop	{pc}

0800079a <CAN0_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_5_IRQHandler
 800079a:	e7fe      	b.n	800079a <CAN0_5_IRQHandler>

0800079c <CAN0_5_IRQHandler_Veneer>:
 800079c:	48b4      	ldr	r0, [pc, #720]	; (8000a70 <GPDMA1_0_IRQHandler_Veneer+0x15a>)
 800079e:	b500      	push	{lr}
 80007a0:	b081      	sub	sp, #4
 80007a2:	4780      	blx	r0
 80007a4:	b001      	add	sp, #4
 80007a6:	bd00      	pop	{pc}

080007a8 <CAN0_6_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_6_IRQHandler
 80007a8:	e7fe      	b.n	80007a8 <CAN0_6_IRQHandler>

080007aa <CAN0_6_IRQHandler_Veneer>:
 80007aa:	48b2      	ldr	r0, [pc, #712]	; (8000a74 <GPDMA1_0_IRQHandler_Veneer+0x15e>)
 80007ac:	b500      	push	{lr}
 80007ae:	b081      	sub	sp, #4
 80007b0:	4780      	blx	r0
 80007b2:	b001      	add	sp, #4
 80007b4:	bd00      	pop	{pc}

080007b6 <CAN0_7_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_7_IRQHandler
 80007b6:	e7fe      	b.n	80007b6 <CAN0_7_IRQHandler>

080007b8 <CAN0_7_IRQHandler_Veneer>:
 80007b8:	48af      	ldr	r0, [pc, #700]	; (8000a78 <GPDMA1_0_IRQHandler_Veneer+0x162>)
 80007ba:	b500      	push	{lr}
 80007bc:	b081      	sub	sp, #4
 80007be:	4780      	blx	r0
 80007c0:	b001      	add	sp, #4
 80007c2:	bd00      	pop	{pc}

080007c4 <USIC0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_0_IRQHandler
 80007c4:	e7fe      	b.n	80007c4 <USIC0_0_IRQHandler>

080007c6 <USIC0_0_IRQHandler_Veneer>:
 80007c6:	48ad      	ldr	r0, [pc, #692]	; (8000a7c <GPDMA1_0_IRQHandler_Veneer+0x166>)
 80007c8:	b500      	push	{lr}
 80007ca:	b081      	sub	sp, #4
 80007cc:	4780      	blx	r0
 80007ce:	b001      	add	sp, #4
 80007d0:	bd00      	pop	{pc}

080007d2 <USIC0_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_1_IRQHandler
 80007d2:	e7fe      	b.n	80007d2 <USIC0_1_IRQHandler>

080007d4 <USIC0_1_IRQHandler_Veneer>:
 80007d4:	48aa      	ldr	r0, [pc, #680]	; (8000a80 <GPDMA1_0_IRQHandler_Veneer+0x16a>)
 80007d6:	b500      	push	{lr}
 80007d8:	b081      	sub	sp, #4
 80007da:	4780      	blx	r0
 80007dc:	b001      	add	sp, #4
 80007de:	bd00      	pop	{pc}

080007e0 <USIC0_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_2_IRQHandler
 80007e0:	e7fe      	b.n	80007e0 <USIC0_2_IRQHandler>

080007e2 <USIC0_2_IRQHandler_Veneer>:
 80007e2:	48a8      	ldr	r0, [pc, #672]	; (8000a84 <GPDMA1_0_IRQHandler_Veneer+0x16e>)
 80007e4:	b500      	push	{lr}
 80007e6:	b081      	sub	sp, #4
 80007e8:	4780      	blx	r0
 80007ea:	b001      	add	sp, #4
 80007ec:	bd00      	pop	{pc}

080007ee <USIC0_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_3_IRQHandler
 80007ee:	e7fe      	b.n	80007ee <USIC0_3_IRQHandler>

080007f0 <USIC0_3_IRQHandler_Veneer>:
 80007f0:	48a5      	ldr	r0, [pc, #660]	; (8000a88 <GPDMA1_0_IRQHandler_Veneer+0x172>)
 80007f2:	b500      	push	{lr}
 80007f4:	b081      	sub	sp, #4
 80007f6:	4780      	blx	r0
 80007f8:	b001      	add	sp, #4
 80007fa:	bd00      	pop	{pc}

080007fc <USIC0_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_4_IRQHandler
 80007fc:	e7fe      	b.n	80007fc <USIC0_4_IRQHandler>

080007fe <USIC0_4_IRQHandler_Veneer>:
 80007fe:	48a3      	ldr	r0, [pc, #652]	; (8000a8c <GPDMA1_0_IRQHandler_Veneer+0x176>)
 8000800:	b500      	push	{lr}
 8000802:	b081      	sub	sp, #4
 8000804:	4780      	blx	r0
 8000806:	b001      	add	sp, #4
 8000808:	bd00      	pop	{pc}

0800080a <USIC0_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_5_IRQHandler
 800080a:	e7fe      	b.n	800080a <USIC0_5_IRQHandler>

0800080c <USIC0_5_IRQHandler_Veneer>:
 800080c:	48a0      	ldr	r0, [pc, #640]	; (8000a90 <GPDMA1_0_IRQHandler_Veneer+0x17a>)
 800080e:	b500      	push	{lr}
 8000810:	b081      	sub	sp, #4
 8000812:	4780      	blx	r0
 8000814:	b001      	add	sp, #4
 8000816:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_0_IRQHandler
 8000818:	e7fe      	b.n	8000818 <USIC0_5_IRQHandler_Veneer+0xc>

0800081a <USIC1_0_IRQHandler_Veneer>:
 800081a:	489e      	ldr	r0, [pc, #632]	; (8000a94 <GPDMA1_0_IRQHandler_Veneer+0x17e>)
 800081c:	b500      	push	{lr}
 800081e:	b081      	sub	sp, #4
 8000820:	4780      	blx	r0
 8000822:	b001      	add	sp, #4
 8000824:	bd00      	pop	{pc}

08000826 <USIC1_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_1_IRQHandler
 8000826:	e7fe      	b.n	8000826 <USIC1_1_IRQHandler>

08000828 <USIC1_1_IRQHandler_Veneer>:
 8000828:	489b      	ldr	r0, [pc, #620]	; (8000a98 <GPDMA1_0_IRQHandler_Veneer+0x182>)
 800082a:	b500      	push	{lr}
 800082c:	b081      	sub	sp, #4
 800082e:	4780      	blx	r0
 8000830:	b001      	add	sp, #4
 8000832:	bd00      	pop	{pc}

08000834 <USIC1_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_2_IRQHandler
 8000834:	e7fe      	b.n	8000834 <USIC1_2_IRQHandler>

08000836 <USIC1_2_IRQHandler_Veneer>:
 8000836:	4899      	ldr	r0, [pc, #612]	; (8000a9c <GPDMA1_0_IRQHandler_Veneer+0x186>)
 8000838:	b500      	push	{lr}
 800083a:	b081      	sub	sp, #4
 800083c:	4780      	blx	r0
 800083e:	b001      	add	sp, #4
 8000840:	bd00      	pop	{pc}

08000842 <USIC1_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_3_IRQHandler
 8000842:	e7fe      	b.n	8000842 <USIC1_3_IRQHandler>

08000844 <USIC1_3_IRQHandler_Veneer>:
 8000844:	4896      	ldr	r0, [pc, #600]	; (8000aa0 <GPDMA1_0_IRQHandler_Veneer+0x18a>)
 8000846:	b500      	push	{lr}
 8000848:	b081      	sub	sp, #4
 800084a:	4780      	blx	r0
 800084c:	b001      	add	sp, #4
 800084e:	bd00      	pop	{pc}

08000850 <USIC1_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_4_IRQHandler
 8000850:	e7fe      	b.n	8000850 <USIC1_4_IRQHandler>

08000852 <USIC1_4_IRQHandler_Veneer>:
 8000852:	4894      	ldr	r0, [pc, #592]	; (8000aa4 <GPDMA1_0_IRQHandler_Veneer+0x18e>)
 8000854:	b500      	push	{lr}
 8000856:	b081      	sub	sp, #4
 8000858:	4780      	blx	r0
 800085a:	b001      	add	sp, #4
 800085c:	bd00      	pop	{pc}

0800085e <USIC1_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_5_IRQHandler
 800085e:	e7fe      	b.n	800085e <USIC1_5_IRQHandler>

08000860 <USIC1_5_IRQHandler_Veneer>:
 8000860:	4891      	ldr	r0, [pc, #580]	; (8000aa8 <GPDMA1_0_IRQHandler_Veneer+0x192>)
 8000862:	b500      	push	{lr}
 8000864:	b081      	sub	sp, #4
 8000866:	4780      	blx	r0
 8000868:	b001      	add	sp, #4
 800086a:	bd00      	pop	{pc}

0800086c <USIC2_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_0_IRQHandler
 800086c:	e7fe      	b.n	800086c <USIC2_0_IRQHandler>

0800086e <USIC2_0_IRQHandler_Veneer>:
 800086e:	488f      	ldr	r0, [pc, #572]	; (8000aac <GPDMA1_0_IRQHandler_Veneer+0x196>)
 8000870:	b500      	push	{lr}
 8000872:	b081      	sub	sp, #4
 8000874:	4780      	blx	r0
 8000876:	b001      	add	sp, #4
 8000878:	bd00      	pop	{pc}

0800087a <USIC2_1_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_1_IRQHandler
 800087a:	e7fe      	b.n	800087a <USIC2_1_IRQHandler>

0800087c <USIC2_1_IRQHandler_Veneer>:
 800087c:	488c      	ldr	r0, [pc, #560]	; (8000ab0 <GPDMA1_0_IRQHandler_Veneer+0x19a>)
 800087e:	b500      	push	{lr}
 8000880:	b081      	sub	sp, #4
 8000882:	4780      	blx	r0
 8000884:	b001      	add	sp, #4
 8000886:	bd00      	pop	{pc}

08000888 <USIC2_2_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_2_IRQHandler
 8000888:	e7fe      	b.n	8000888 <USIC2_2_IRQHandler>

0800088a <USIC2_2_IRQHandler_Veneer>:
 800088a:	488a      	ldr	r0, [pc, #552]	; (8000ab4 <GPDMA1_0_IRQHandler_Veneer+0x19e>)
 800088c:	b500      	push	{lr}
 800088e:	b081      	sub	sp, #4
 8000890:	4780      	blx	r0
 8000892:	b001      	add	sp, #4
 8000894:	bd00      	pop	{pc}

08000896 <USIC2_3_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_3_IRQHandler
 8000896:	e7fe      	b.n	8000896 <USIC2_3_IRQHandler>

08000898 <USIC2_3_IRQHandler_Veneer>:
 8000898:	4887      	ldr	r0, [pc, #540]	; (8000ab8 <GPDMA1_0_IRQHandler_Veneer+0x1a2>)
 800089a:	b500      	push	{lr}
 800089c:	b081      	sub	sp, #4
 800089e:	4780      	blx	r0
 80008a0:	b001      	add	sp, #4
 80008a2:	bd00      	pop	{pc}

080008a4 <USIC2_4_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_4_IRQHandler
 80008a4:	e7fe      	b.n	80008a4 <USIC2_4_IRQHandler>

080008a6 <USIC2_4_IRQHandler_Veneer>:
 80008a6:	4885      	ldr	r0, [pc, #532]	; (8000abc <GPDMA1_0_IRQHandler_Veneer+0x1a6>)
 80008a8:	b500      	push	{lr}
 80008aa:	b081      	sub	sp, #4
 80008ac:	4780      	blx	r0
 80008ae:	b001      	add	sp, #4
 80008b0:	bd00      	pop	{pc}

080008b2 <USIC2_5_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_5_IRQHandler
 80008b2:	e7fe      	b.n	80008b2 <USIC2_5_IRQHandler>

080008b4 <USIC2_5_IRQHandler_Veneer>:
 80008b4:	4882      	ldr	r0, [pc, #520]	; (8000ac0 <GPDMA1_0_IRQHandler_Veneer+0x1aa>)
 80008b6:	b500      	push	{lr}
 80008b8:	b081      	sub	sp, #4
 80008ba:	4780      	blx	r0
 80008bc:	b001      	add	sp, #4
 80008be:	bd00      	pop	{pc}

080008c0 <LEDTS0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler LEDTS0_0_IRQHandler
 80008c0:	e7fe      	b.n	80008c0 <LEDTS0_0_IRQHandler>

080008c2 <LEDTS0_0_IRQHandler_Veneer>:
 80008c2:	4880      	ldr	r0, [pc, #512]	; (8000ac4 <GPDMA1_0_IRQHandler_Veneer+0x1ae>)
 80008c4:	b500      	push	{lr}
 80008c6:	b081      	sub	sp, #4
 80008c8:	4780      	blx	r0
 80008ca:	b001      	add	sp, #4
 80008cc:	bd00      	pop	{pc}

080008ce <FCE0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler FCE0_0_IRQHandler
 80008ce:	e7fe      	b.n	80008ce <FCE0_0_IRQHandler>

080008d0 <FCE0_0_IRQHandler_Veneer>:
 80008d0:	487d      	ldr	r0, [pc, #500]	; (8000ac8 <GPDMA1_0_IRQHandler_Veneer+0x1b2>)
 80008d2:	b500      	push	{lr}
 80008d4:	b081      	sub	sp, #4
 80008d6:	4780      	blx	r0
 80008d8:	b001      	add	sp, #4
 80008da:	bd00      	pop	{pc}

080008dc <GPDMA0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA0_0_IRQHandler
 80008dc:	e7fe      	b.n	80008dc <GPDMA0_0_IRQHandler>

080008de <GPDMA0_0_IRQHandler_Veneer>:
 80008de:	487b      	ldr	r0, [pc, #492]	; (8000acc <GPDMA1_0_IRQHandler_Veneer+0x1b6>)
 80008e0:	b500      	push	{lr}
 80008e2:	b081      	sub	sp, #4
 80008e4:	4780      	blx	r0
 80008e6:	b001      	add	sp, #4
 80008e8:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler SDMMC0_0_IRQHandler
 80008ea:	e7fe      	b.n	80008ea <GPDMA0_0_IRQHandler_Veneer+0xc>

080008ec <SDMMC0_0_IRQHandler_Veneer>:
 80008ec:	4878      	ldr	r0, [pc, #480]	; (8000ad0 <GPDMA1_0_IRQHandler_Veneer+0x1ba>)
 80008ee:	b500      	push	{lr}
 80008f0:	b081      	sub	sp, #4
 80008f2:	4780      	blx	r0
 80008f4:	b001      	add	sp, #4
 80008f6:	bd00      	pop	{pc}

080008f8 <USB0_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler USB0_0_IRQHandler
 80008f8:	e7fe      	b.n	80008f8 <USB0_0_IRQHandler>

080008fa <USB0_0_IRQHandler_Veneer>:
 80008fa:	4876      	ldr	r0, [pc, #472]	; (8000ad4 <GPDMA1_0_IRQHandler_Veneer+0x1be>)
 80008fc:	b500      	push	{lr}
 80008fe:	b081      	sub	sp, #4
 8000900:	4780      	blx	r0
 8000902:	b001      	add	sp, #4
 8000904:	bd00      	pop	{pc}
/* ======================================================================== */
     Insert_ExceptionHandler ETH0_0_IRQHandler
 8000906:	e7fe      	b.n	8000906 <USB0_0_IRQHandler_Veneer+0xc>

08000908 <ETH0_0_IRQHandler_Veneer>:
 8000908:	4873      	ldr	r0, [pc, #460]	; (8000ad8 <GPDMA1_0_IRQHandler_Veneer+0x1c2>)
 800090a:	b500      	push	{lr}
 800090c:	b081      	sub	sp, #4
 800090e:	4780      	blx	r0
 8000910:	b001      	add	sp, #4
 8000912:	bd00      	pop	{pc}

08000914 <GPDMA1_0_IRQHandler>:
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA1_0_IRQHandler
 8000914:	e7fe      	b.n	8000914 <GPDMA1_0_IRQHandler>

08000916 <GPDMA1_0_IRQHandler_Veneer>:
 8000916:	4871      	ldr	r0, [pc, #452]	; (8000adc <GPDMA1_0_IRQHandler_Veneer+0x1c6>)
 8000918:	b500      	push	{lr}
 800091a:	b081      	sub	sp, #4
 800091c:	4780      	blx	r0
 800091e:	b001      	add	sp, #4
 8000920:	bd00      	pop	{pc}
   returns FALSE indicating that the code engine has performed the clock setup
*/   
    .weak   AllowPLLInitByStartup
    .type   AllowPLLInitByStartup, %function
AllowPLLInitByStartup:
    MOV R0,#1
 8000922:	f04f 0001 	mov.w	r0, #1
    BX LR
 8000926:	4770      	bx	lr
/* Default exception Handlers - Users may override this default functionality by
   defining handlers of the same name in their C code */
    .thumb
    .text

     Insert_ExceptionHandler NMI_Handler
 8000928:	080002b5 	.word	0x080002b5
/* ======================================================================== */
     Insert_ExceptionHandler HardFault_Handler
 800092c:	080002c5 	.word	0x080002c5
/* ======================================================================== */
     Insert_ExceptionHandler MemManage_Handler
 8000930:	080002d5 	.word	0x080002d5
/* ======================================================================== */
     Insert_ExceptionHandler BusFault_Handler
 8000934:	080002e5 	.word	0x080002e5
/* ======================================================================== */
     Insert_ExceptionHandler UsageFault_Handler
 8000938:	080002f5 	.word	0x080002f5
/* ======================================================================== */
     Insert_ExceptionHandler SVC_Handler
 800093c:	08000305 	.word	0x08000305
/* ======================================================================== */
     Insert_ExceptionHandler DebugMon_Handler
 8000940:	08000315 	.word	0x08000315
/* ======================================================================== */
     Insert_ExceptionHandler PendSV_Handler
 8000944:	08000325 	.word	0x08000325
/* ======================================================================== */
     Insert_ExceptionHandler SysTick_Handler
 8000948:	08004221 	.word	0x08004221
/* ============= END OF EXCEPTION HANDLER DEFINITION ======================== */

/* ============= START OF INTERRUPT HANDLER DEFINITION ====================== */

/* IRQ Handlers */
     Insert_ExceptionHandler SCU_0_IRQHandler
 800094c:	08009c41 	.word	0x08009c41
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_0_IRQHandler
 8000950:	08000355 	.word	0x08000355
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_1_IRQHandler
 8000954:	08000365 	.word	0x08000365
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_2_IRQHandler
 8000958:	08000375 	.word	0x08000375
/* ======================================================================== */
     Insert_ExceptionHandler ERU0_3_IRQHandler
 800095c:	08000385 	.word	0x08000385
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_0_IRQHandler
 8000960:	08000395 	.word	0x08000395
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_1_IRQHandler
 8000964:	080003a5 	.word	0x080003a5
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_2_IRQHandler
 8000968:	080003b5 	.word	0x080003b5
/* ======================================================================== */
     Insert_ExceptionHandler ERU1_3_IRQHandler
 800096c:	080003c5 	.word	0x080003c5
/* ======================================================================== */
     Insert_ExceptionHandler PMU0_0_IRQHandler
 8000970:	080003d5 	.word	0x080003d5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_0_IRQHandler
 8000974:	080003e5 	.word	0x080003e5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_1_IRQHandler
 8000978:	080003f5 	.word	0x080003f5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_2_IRQHandler
 800097c:	08000405 	.word	0x08000405
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_C0_3_IRQHandler
 8000980:	08000415 	.word	0x08000415
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_0_IRQHandler
 8000984:	08000425 	.word	0x08000425
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_1_IRQHandler
 8000988:	08000435 	.word	0x08000435
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_2_IRQHandler
 800098c:	08000445 	.word	0x08000445
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G0_3_IRQHandler
 8000990:	08000455 	.word	0x08000455
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_0_IRQHandler
 8000994:	08000465 	.word	0x08000465
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_1_IRQHandler
 8000998:	08000475 	.word	0x08000475
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_2_IRQHandler
 800099c:	08000485 	.word	0x08000485
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G1_3_IRQHandler
 80009a0:	08000495 	.word	0x08000495
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_0_IRQHandler
 80009a4:	080004a5 	.word	0x080004a5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_1_IRQHandler
 80009a8:	080004b5 	.word	0x080004b5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_2_IRQHandler
 80009ac:	080004c5 	.word	0x080004c5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G2_3_IRQHandler
 80009b0:	080004d5 	.word	0x080004d5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_0_IRQHandler
 80009b4:	080004e5 	.word	0x080004e5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_1_IRQHandler
 80009b8:	080004f5 	.word	0x080004f5
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_2_IRQHandler
 80009bc:	08000505 	.word	0x08000505
/* ======================================================================== */
     Insert_ExceptionHandler VADC0_G3_3_IRQHandler
 80009c0:	08000515 	.word	0x08000515
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_0_IRQHandler
 80009c4:	08000525 	.word	0x08000525
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_1_IRQHandler
 80009c8:	08000535 	.word	0x08000535
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_2_IRQHandler
 80009cc:	08000545 	.word	0x08000545
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_3_IRQHandler
 80009d0:	08000555 	.word	0x08000555
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_4_IRQHandler
 80009d4:	08000565 	.word	0x08000565
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_5_IRQHandler
 80009d8:	08000575 	.word	0x08000575
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_6_IRQHandler
 80009dc:	08000585 	.word	0x08000585
/* ======================================================================== */
     Insert_ExceptionHandler DSD0_7_IRQHandler
 80009e0:	08000595 	.word	0x08000595
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_0_IRQHandler
 80009e4:	080005a5 	.word	0x080005a5
/* ======================================================================== */
     Insert_ExceptionHandler DAC0_1_IRQHandler
 80009e8:	080005b5 	.word	0x080005b5
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_0_IRQHandler
 80009ec:	080005c5 	.word	0x080005c5
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_1_IRQHandler
 80009f0:	080005d5 	.word	0x080005d5
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_2_IRQHandler
 80009f4:	080005e5 	.word	0x080005e5
/* ======================================================================== */
     Insert_ExceptionHandler CCU40_3_IRQHandler
 80009f8:	080005f5 	.word	0x080005f5
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_0_IRQHandler
 80009fc:	08000605 	.word	0x08000605
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_1_IRQHandler
 8000a00:	08000613 	.word	0x08000613
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_2_IRQHandler
 8000a04:	08000621 	.word	0x08000621
/* ======================================================================== */
     Insert_ExceptionHandler CCU41_3_IRQHandler
 8000a08:	0800062f 	.word	0x0800062f
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_0_IRQHandler
 8000a0c:	0800063d 	.word	0x0800063d
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_1_IRQHandler
 8000a10:	0800064b 	.word	0x0800064b
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_2_IRQHandler
 8000a14:	08000659 	.word	0x08000659
/* ======================================================================== */
     Insert_ExceptionHandler CCU42_3_IRQHandler
 8000a18:	08000667 	.word	0x08000667
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_0_IRQHandler
 8000a1c:	08000675 	.word	0x08000675
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_1_IRQHandler
 8000a20:	08000683 	.word	0x08000683
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_2_IRQHandler
 8000a24:	08000691 	.word	0x08000691
/* ======================================================================== */
     Insert_ExceptionHandler CCU43_3_IRQHandler
 8000a28:	0800069f 	.word	0x0800069f
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_0_IRQHandler
 8000a2c:	080006ad 	.word	0x080006ad
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_1_IRQHandler
 8000a30:	080006bb 	.word	0x080006bb
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_2_IRQHandler
 8000a34:	080006c9 	.word	0x080006c9
/* ======================================================================== */
     Insert_ExceptionHandler CCU80_3_IRQHandler
 8000a38:	080006d7 	.word	0x080006d7
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_0_IRQHandler
 8000a3c:	080006e5 	.word	0x080006e5
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_1_IRQHandler
 8000a40:	080006f3 	.word	0x080006f3
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_2_IRQHandler
 8000a44:	08000701 	.word	0x08000701
/* ======================================================================== */
     Insert_ExceptionHandler CCU81_3_IRQHandler
 8000a48:	0800070f 	.word	0x0800070f
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_0_IRQHandler
 8000a4c:	0800071d 	.word	0x0800071d
/* ======================================================================== */
     Insert_ExceptionHandler POSIF0_1_IRQHandler
 8000a50:	0800072b 	.word	0x0800072b
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_0_IRQHandler
 8000a54:	08000739 	.word	0x08000739
/* ======================================================================== */
     Insert_ExceptionHandler POSIF1_1_IRQHandler
 8000a58:	08000747 	.word	0x08000747
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_0_IRQHandler
 8000a5c:	08000755 	.word	0x08000755
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_1_IRQHandler
 8000a60:	08000763 	.word	0x08000763
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_2_IRQHandler
 8000a64:	08000771 	.word	0x08000771
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_3_IRQHandler
 8000a68:	0800077f 	.word	0x0800077f
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_4_IRQHandler
 8000a6c:	0800078d 	.word	0x0800078d
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_5_IRQHandler
 8000a70:	0800079b 	.word	0x0800079b
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_6_IRQHandler
 8000a74:	080007a9 	.word	0x080007a9
/* ======================================================================== */
     Insert_ExceptionHandler CAN0_7_IRQHandler
 8000a78:	080007b7 	.word	0x080007b7
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_0_IRQHandler
 8000a7c:	080007c5 	.word	0x080007c5
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_1_IRQHandler
 8000a80:	080007d3 	.word	0x080007d3
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_2_IRQHandler
 8000a84:	080007e1 	.word	0x080007e1
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_3_IRQHandler
 8000a88:	080007ef 	.word	0x080007ef
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_4_IRQHandler
 8000a8c:	080007fd 	.word	0x080007fd
/* ======================================================================== */
     Insert_ExceptionHandler USIC0_5_IRQHandler
 8000a90:	0800080b 	.word	0x0800080b
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_0_IRQHandler
 8000a94:	080017cd 	.word	0x080017cd
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_1_IRQHandler
 8000a98:	08000827 	.word	0x08000827
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_2_IRQHandler
 8000a9c:	08000835 	.word	0x08000835
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_3_IRQHandler
 8000aa0:	08000843 	.word	0x08000843
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_4_IRQHandler
 8000aa4:	08000851 	.word	0x08000851
/* ======================================================================== */
     Insert_ExceptionHandler USIC1_5_IRQHandler
 8000aa8:	0800085f 	.word	0x0800085f
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_0_IRQHandler
 8000aac:	0800086d 	.word	0x0800086d
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_1_IRQHandler
 8000ab0:	0800087b 	.word	0x0800087b
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_2_IRQHandler
 8000ab4:	08000889 	.word	0x08000889
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_3_IRQHandler
 8000ab8:	08000897 	.word	0x08000897
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_4_IRQHandler
 8000abc:	080008a5 	.word	0x080008a5
/* ======================================================================== */
     Insert_ExceptionHandler USIC2_5_IRQHandler
 8000ac0:	080008b3 	.word	0x080008b3
/* ======================================================================== */
     Insert_ExceptionHandler LEDTS0_0_IRQHandler
 8000ac4:	080008c1 	.word	0x080008c1
/* ======================================================================== */
     Insert_ExceptionHandler FCE0_0_IRQHandler
 8000ac8:	080008cf 	.word	0x080008cf
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA0_0_IRQHandler
 8000acc:	080008dd 	.word	0x080008dd
/* ======================================================================== */
     Insert_ExceptionHandler SDMMC0_0_IRQHandler
 8000ad0:	0800854d 	.word	0x0800854d
/* ======================================================================== */
     Insert_ExceptionHandler USB0_0_IRQHandler
 8000ad4:	080008f9 	.word	0x080008f9
/* ======================================================================== */
     Insert_ExceptionHandler ETH0_0_IRQHandler
 8000ad8:	0801e065 	.word	0x0801e065
/* ======================================================================== */
     Insert_ExceptionHandler GPDMA1_0_IRQHandler
 8000adc:	08000915 	.word	0x08000915

08000ae0 <SystemInit>:
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000ae0:	b580      	push	{r7, lr}
 8000ae2:	b082      	sub	sp, #8
 8000ae4:	af00      	add	r7, sp, #0
int temp;
	
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8000ae6:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8000aea:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000aee:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8000af2:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000af6:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 8000afa:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000afe:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
               (3UL << 11*2)  );               /* set CP11 Full Access */
#endif

/* Enable unaligned memory access - SCB_CCR.UNALIGN_TRP = 0 */
SCB->CCR &= ~(SCB_CCR_UNALIGN_TRP_Msk);
 8000b02:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8000b06:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000b0a:	f44f 426d 	mov.w	r2, #60672	; 0xed00
 8000b0e:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000b12:	6952      	ldr	r2, [r2, #20]
 8000b14:	f022 0208 	bic.w	r2, r2, #8
 8000b18:	615a      	str	r2, [r3, #20]
	
/* Setup the WDT */
#if WDT_SETUP

WDT->CTR &= ~WDTENB_nVal; 
 8000b1a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000b1e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000b22:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8000b26:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000b2a:	6852      	ldr	r2, [r2, #4]
 8000b2c:	f022 0201 	bic.w	r2, r2, #1
 8000b30:	605a      	str	r2, [r3, #4]

#endif

/* Setup the Flash Wait State */
#if PMU_FLASH
temp = FLASH0->FCON; 
 8000b32:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000b36:	f6c5 0300 	movt	r3, #22528	; 0x5800
 8000b3a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8000b3e:	f103 0314 	add.w	r3, r3, #20
 8000b42:	681b      	ldr	r3, [r3, #0]
 8000b44:	607b      	str	r3, [r7, #4]
temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8000b46:	687b      	ldr	r3, [r7, #4]
 8000b48:	f023 030f 	bic.w	r3, r3, #15
 8000b4c:	607b      	str	r3, [r7, #4]
temp |= PMU_FLASH_WS+3;
 8000b4e:	687b      	ldr	r3, [r7, #4]
 8000b50:	f043 0303 	orr.w	r3, r3, #3
 8000b54:	607b      	str	r3, [r7, #4]
FLASH0->FCON = temp;
 8000b56:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000b5a:	f6c5 0300 	movt	r3, #22528	; 0x5800
 8000b5e:	687a      	ldr	r2, [r7, #4]
 8000b60:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8000b64:	f103 0314 	add.w	r3, r3, #20
 8000b68:	601a      	str	r2, [r3, #0]
#endif


/* Setup the System clock */ 
#if SCU_CLOCK_SETUP
SystemClockSetup();
 8000b6a:	f000 f8ab 	bl	8000cc4 <SystemClockSetup>
#endif

/*----------------------------------------------------------------------------
  Clock Variable definitions
 *----------------------------------------------------------------------------*/
SystemCoreClockUpdate();/*!< System Clock Frequency (Core Clock)*/
 8000b6e:	f000 f805 	bl	8000b7c <SystemCoreClockUpdate>
USBClockSetup();
#endif



}
 8000b72:	f107 0708 	add.w	r7, r7, #8
 8000b76:	46bd      	mov	sp, r7
 8000b78:	bd80      	pop	{r7, pc}
 8000b7a:	bf00      	nop

08000b7c <SystemCoreClockUpdate>:
  * @note   -  
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8000b7c:	b480      	push	{r7}
 8000b7e:	b085      	sub	sp, #20
 8000b80:	af00      	add	r7, sp, #0


/*----------------------------------------------------------------------------
  Clock Variable definitions
 *----------------------------------------------------------------------------*/
if (SCU_CLK->SYSCLKCR ==  0x00010000)
 8000b82:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000b86:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000b8a:	68db      	ldr	r3, [r3, #12]
 8000b8c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000b90:	f040 8089 	bne.w	8000ca6 <SystemCoreClockUpdate+0x12a>
{
	if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk){
 8000b94:	f244 7310 	movw	r3, #18192	; 0x4710
 8000b98:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000b9c:	681b      	ldr	r3, [r3, #0]
 8000b9e:	f003 0304 	and.w	r3, r3, #4
 8000ba2:	2b00      	cmp	r3, #0
 8000ba4:	f000 8088 	beq.w	8000cb8 <SystemCoreClockUpdate+0x13c>
		/* check if PLL is locked */
		/* read back divider settings */
		 PDIV = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk)>>24)+1;
 8000ba8:	f244 7310 	movw	r3, #18192	; 0x4710
 8000bac:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000bb0:	689b      	ldr	r3, [r3, #8]
 8000bb2:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 8000bb6:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000bba:	f103 0301 	add.w	r3, r3, #1
 8000bbe:	60fb      	str	r3, [r7, #12]
		 NDIV = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk)>>8)+1;
 8000bc0:	f244 7310 	movw	r3, #18192	; 0x4710
 8000bc4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000bc8:	689b      	ldr	r3, [r3, #8]
 8000bca:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 8000bce:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000bd2:	f103 0301 	add.w	r3, r3, #1
 8000bd6:	60bb      	str	r3, [r7, #8]
		 K2DIV  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk)>>16)+1;
 8000bd8:	f244 7310 	movw	r3, #18192	; 0x4710
 8000bdc:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000be0:	689b      	ldr	r3, [r3, #8]
 8000be2:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 8000be6:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8000bea:	f103 0301 	add.w	r3, r3, #1
 8000bee:	607b      	str	r3, [r7, #4]

		if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk){
 8000bf0:	f244 7310 	movw	r3, #18192	; 0x4710
 8000bf4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000bf8:	68db      	ldr	r3, [r3, #12]
 8000bfa:	f003 0301 	and.w	r3, r3, #1
 8000bfe:	2b00      	cmp	r3, #0
 8000c00:	d028      	beq.n	8000c54 <SystemCoreClockUpdate+0xd8>
		/* the selected clock is the Backup clock fofi */
		VCO = (CLOCK_BACK_UP/PDIV)*NDIV;
 8000c02:	f44f 5358 	mov.w	r3, #13824	; 0x3600
 8000c06:	f2c0 136e 	movt	r3, #366	; 0x16e
 8000c0a:	68fa      	ldr	r2, [r7, #12]
 8000c0c:	fbb3 f3f2 	udiv	r3, r3, r2
 8000c10:	68ba      	ldr	r2, [r7, #8]
 8000c12:	fb02 f303 	mul.w	r3, r2, r3
 8000c16:	603b      	str	r3, [r7, #0]
		SystemCoreClock = VCO/K2DIV;
 8000c18:	683a      	ldr	r2, [r7, #0]
 8000c1a:	687b      	ldr	r3, [r7, #4]
 8000c1c:	fbb2 f2f3 	udiv	r2, r2, r3
 8000c20:	f246 6350 	movw	r3, #26192	; 0x6650
 8000c24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c28:	601a      	str	r2, [r3, #0]
		/* in case the sysclock div is used */
		SystemCoreClock = SystemCoreClock/((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk)+1);
 8000c2a:	f246 6350 	movw	r3, #26192	; 0x6650
 8000c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c32:	681a      	ldr	r2, [r3, #0]
 8000c34:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000c38:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000c3c:	68db      	ldr	r3, [r3, #12]
 8000c3e:	b2db      	uxtb	r3, r3
 8000c40:	f103 0301 	add.w	r3, r3, #1
 8000c44:	fbb2 f2f3 	udiv	r2, r2, r3
 8000c48:	f246 6350 	movw	r3, #26192	; 0x6650
 8000c4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c50:	601a      	str	r2, [r3, #0]
 8000c52:	e031      	b.n	8000cb8 <SystemCoreClockUpdate+0x13c>
		
		}
		else
		{
		/* the selected clock is the PLL external oscillator */		
		VCO = (CLOCK_CRYSTAL_FREQUENCY/PDIV)*NDIV;
 8000c54:	f44f 53d8 	mov.w	r3, #6912	; 0x1b00
 8000c58:	f2c0 03b7 	movt	r3, #183	; 0xb7
 8000c5c:	68fa      	ldr	r2, [r7, #12]
 8000c5e:	fbb3 f3f2 	udiv	r3, r3, r2
 8000c62:	68ba      	ldr	r2, [r7, #8]
 8000c64:	fb02 f303 	mul.w	r3, r2, r3
 8000c68:	603b      	str	r3, [r7, #0]
		SystemCoreClock = VCO/K2DIV;
 8000c6a:	683a      	ldr	r2, [r7, #0]
 8000c6c:	687b      	ldr	r3, [r7, #4]
 8000c6e:	fbb2 f2f3 	udiv	r2, r2, r3
 8000c72:	f246 6350 	movw	r3, #26192	; 0x6650
 8000c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c7a:	601a      	str	r2, [r3, #0]
		/* in case the sysclock div is used */
		SystemCoreClock = SystemCoreClock/((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk)+1);
 8000c7c:	f246 6350 	movw	r3, #26192	; 0x6650
 8000c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c84:	681a      	ldr	r2, [r3, #0]
 8000c86:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000c8a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000c8e:	68db      	ldr	r3, [r3, #12]
 8000c90:	b2db      	uxtb	r3, r3
 8000c92:	f103 0301 	add.w	r3, r3, #1
 8000c96:	fbb2 f2f3 	udiv	r2, r2, r3
 8000c9a:	f246 6350 	movw	r3, #26192	; 0x6650
 8000c9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ca2:	601a      	str	r2, [r3, #0]
 8000ca4:	e008      	b.n	8000cb8 <SystemCoreClockUpdate+0x13c>
	
	}
}
else
{
SystemCoreClock = CLOCK_BACK_UP;
 8000ca6:	f246 6350 	movw	r3, #26192	; 0x6650
 8000caa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cae:	f44f 5258 	mov.w	r2, #13824	; 0x3600
 8000cb2:	f2c0 126e 	movt	r2, #366	; 0x16e
 8000cb6:	601a      	str	r2, [r3, #0]
}


}
 8000cb8:	f107 0714 	add.w	r7, r7, #20
 8000cbc:	46bd      	mov	sp, r7
 8000cbe:	bc80      	pop	{r7}
 8000cc0:	4770      	bx	lr
 8000cc2:	bf00      	nop

08000cc4 <SystemClockSetup>:
  * @param  None
  * @retval None
  */
#if (SCU_CLOCK_SETUP == 1)
static int SystemClockSetup(void)
{
 8000cc4:	b580      	push	{r7, lr}
 8000cc6:	b082      	sub	sp, #8
 8000cc8:	af00      	add	r7, sp, #0
int temp;
unsigned int long VCO;
int stepping_K2DIV;	

/* this weak function enables DAVE3 clock App usage */	
if(AllowPLLInitByStartup()){
 8000cca:	f01e fc9b 	bl	801f604 <AllowPLLInitByStartup>
 8000cce:	4603      	mov	r3, r0
 8000cd0:	2b00      	cmp	r3, #0
 8000cd2:	f000 8255 	beq.w	8001180 <SystemClockSetup+0x4bc>
	
/* check if PLL is switched on */
if ((SCU_PLL->PLLCON0 &(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk)) != 0){
 8000cd6:	f244 7310 	movw	r3, #18192	; 0x4710
 8000cda:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000cde:	685a      	ldr	r2, [r3, #4]
 8000ce0:	f04f 0302 	mov.w	r3, #2
 8000ce4:	f2c0 0301 	movt	r3, #1
 8000ce8:	4013      	ands	r3, r2
 8000cea:	2b00      	cmp	r3, #0
 8000cec:	d00d      	beq.n	8000d0a <SystemClockSetup+0x46>
/* enable PLL first */
  SCU_PLL->PLLCON0 &= ~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8000cee:	f244 7310 	movw	r3, #18192	; 0x4710
 8000cf2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000cf6:	f244 7210 	movw	r2, #18192	; 0x4710
 8000cfa:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000cfe:	6852      	ldr	r2, [r2, #4]
 8000d00:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000d04:	f022 0202 	bic.w	r2, r2, #2
 8000d08:	605a      	str	r2, [r3, #4]
  {
	/********************************************************************************************************************/
	/*   Use external crystal for PLL clock input                                                                            */
	/********************************************************************************************************************/

   if (SCU_OSC->OSCHPCTRL & SCU_OSC_OSCHPCTRL_MODE_Msk){
 8000d0a:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 8000d0e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000d12:	685b      	ldr	r3, [r3, #4]
 8000d14:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8000d18:	2b00      	cmp	r3, #0
 8000d1a:	d072      	beq.n	8000e02 <SystemClockSetup+0x13e>
	   SCU_OSC->OSCHPCTRL &= ~(SCU_OSC_HP_MODE);	 /*enable the OSC_HP*/
 8000d1c:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 8000d20:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000d24:	f44f 428e 	mov.w	r2, #18176	; 0x4700
 8000d28:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000d2c:	6852      	ldr	r2, [r2, #4]
 8000d2e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000d32:	605a      	str	r2, [r3, #4]
	   /* setup OSC WDG devider */
	   SCU_OSC->OSCHPCTRL |= (SCU_OSCHPWDGDIV<<16);         
 8000d34:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 8000d38:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000d3c:	f44f 428e 	mov.w	r2, #18176	; 0x4700
 8000d40:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000d44:	6852      	ldr	r2, [r2, #4]
 8000d46:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8000d4a:	605a      	str	r2, [r3, #4]
	   /* select external OSC as PLL input */
	   SCU_PLL->PLLCON2 &= ~SCU_PLL_PLLCON2_PINSEL_Msk;
 8000d4c:	f244 7310 	movw	r3, #18192	; 0x4710
 8000d50:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000d54:	f244 7210 	movw	r2, #18192	; 0x4710
 8000d58:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000d5c:	68d2      	ldr	r2, [r2, #12]
 8000d5e:	f022 0201 	bic.w	r2, r2, #1
 8000d62:	60da      	str	r2, [r3, #12]
	   /* restart OSC Watchdog */
	   SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCRES_Msk;  
 8000d64:	f244 7310 	movw	r3, #18192	; 0x4710
 8000d68:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000d6c:	f244 7210 	movw	r2, #18192	; 0x4710
 8000d70:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000d74:	6852      	ldr	r2, [r2, #4]
 8000d76:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8000d7a:	605a      	str	r2, [r3, #4]

       /* Timeout for wait loop ~150ms */
	   /********************************/
	   SysTick->LOAD  = ((5000000+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
 8000d7c:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000d80:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000d84:	f644 32a3 	movw	r2, #19363	; 0x4ba3
 8000d88:	f2c0 024c 	movt	r2, #76	; 0x4c
 8000d8c:	605a      	str	r2, [r3, #4]
	   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000d8e:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000d92:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000d96:	f04f 0200 	mov.w	r2, #0
 8000d9a:	609a      	str	r2, [r3, #8]
	   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d9c:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000da0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000da4:	f04f 0205 	mov.w	r2, #5
 8000da8:	601a      	str	r2, [r3, #0]
	                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */		  
	   do 
	   {
       ;/* wait for ~150ms  */
	   }while((((SCU_PLL->PLLSTAT) & (SCU_PLL_PLLSTAT_PLLHV_Msk | SCU_PLL_PLLSTAT_PLLLV_Msk |SCU_PLL_PLLSTAT_PLLSP_Msk)) != 0x380)&&(SysTick->VAL >= 500)); 
 8000daa:	f244 7310 	movw	r3, #18192	; 0x4710
 8000dae:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000db2:	681b      	ldr	r3, [r3, #0]
 8000db4:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8000db8:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000dbc:	d008      	beq.n	8000dd0 <SystemClockSetup+0x10c>
 8000dbe:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000dc2:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000dc6:	689a      	ldr	r2, [r3, #8]
 8000dc8:	f240 13f3 	movw	r3, #499	; 0x1f3
 8000dcc:	429a      	cmp	r2, r3
 8000dce:	d8ec      	bhi.n	8000daa <SystemClockSetup+0xe6>

	   SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000dd0:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000dd4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000dd8:	f24e 0210 	movw	r2, #57360	; 0xe010
 8000ddc:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000de0:	6812      	ldr	r2, [r2, #0]
 8000de2:	f022 0201 	bic.w	r2, r2, #1
 8000de6:	601a      	str	r2, [r3, #0]
	   if (((SCU_PLL->PLLSTAT) & (SCU_PLL_PLLSTAT_PLLHV_Msk | SCU_PLL_PLLSTAT_PLLLV_Msk |SCU_PLL_PLLSTAT_PLLSP_Msk)) != 0x380)
 8000de8:	f244 7310 	movw	r3, #18192	; 0x4710
 8000dec:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000df0:	681b      	ldr	r3, [r3, #0]
 8000df2:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8000df6:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8000dfa:	d002      	beq.n	8000e02 <SystemClockSetup+0x13e>
	   return(0);/* Return Error */
 8000dfc:	f04f 0300 	mov.w	r3, #0
 8000e00:	e1c0      	b.n	8001184 <SystemClockSetup+0x4c0>

	/********************************************************************************************************************/
	/*   Setup and look the main PLL                                                                                    */
	/********************************************************************************************************************/

if (!(SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)){
 8000e02:	f244 7310 	movw	r3, #18192	; 0x4710
 8000e06:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000e0a:	681b      	ldr	r3, [r3, #0]
 8000e0c:	f003 0304 	and.w	r3, r3, #4
 8000e10:	2b00      	cmp	r3, #0
 8000e12:	f040 81b5 	bne.w	8001180 <SystemClockSetup+0x4bc>
	/* Systen is still running from internal clock */
		   /* select FOFI as system clock */
		   if((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk) != 0x0)SCU_CLK->SYSCLKCR &= ~SCU_CLK_SYSCLKCR_SYSSEL_Msk; /*Select FOFI*/
 8000e16:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000e1a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000e1e:	68db      	ldr	r3, [r3, #12]
 8000e20:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000e24:	2b00      	cmp	r3, #0
 8000e26:	d00b      	beq.n	8000e40 <SystemClockSetup+0x17c>
 8000e28:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000e2c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000e30:	f44f 428c 	mov.w	r2, #17920	; 0x4600
 8000e34:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000e38:	68d2      	ldr	r2, [r2, #12]
 8000e3a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000e3e:	60da      	str	r2, [r3, #12]


			 /*calulation for stepping*/
			 if (SCU_PLL_CLOCK_INPUT == SCU_CLOCK_CRYSTAL)VCO = (CLOCK_CRYSTAL_FREQUENCY/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);
 8000e40:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000e44:	f6c1 439c 	movt	r3, #7324	; 0x1c9c
 8000e48:	607b      	str	r3, [r7, #4]
			 if ((SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_AUTOMATIC) ||(SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_FACTORY))
					VCO = (CLOCK_BACK_UP/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);
	 
			 stepping_K2DIV = (VCO/24000000)-1;	
 8000e4a:	687a      	ldr	r2, [r7, #4]
 8000e4c:	f649 7381 	movw	r3, #40833	; 0x9f81
 8000e50:	f2c1 635e 	movt	r3, #5726	; 0x165e
 8000e54:	fba3 1302 	umull	r1, r3, r3, r2
 8000e58:	ea4f 5353 	mov.w	r3, r3, lsr #21
 8000e5c:	f103 33ff 	add.w	r3, r3, #4294967295
 8000e60:	603b      	str	r3, [r7, #0]
			 /* Go to bypass the Main PLL */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_VCOBYP_Msk;
 8000e62:	f244 7310 	movw	r3, #18192	; 0x4710
 8000e66:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000e6a:	f244 7210 	movw	r2, #18192	; 0x4710
 8000e6e:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000e72:	6852      	ldr	r2, [r2, #4]
 8000e74:	f042 0201 	orr.w	r2, r2, #1
 8000e78:	605a      	str	r2, [r3, #4]
		   /* disconnect OSC_HP to PLL */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_FINDIS_Msk;
 8000e7a:	f244 7310 	movw	r3, #18192	; 0x4710
 8000e7e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000e82:	f244 7210 	movw	r2, #18192	; 0x4710
 8000e86:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000e8a:	6852      	ldr	r2, [r2, #4]
 8000e8c:	f042 0210 	orr.w	r2, r2, #16
 8000e90:	605a      	str	r2, [r3, #4]
		   /* Setup devider settings for main PLL */
		   SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (stepping_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 8000e92:	f244 7210 	movw	r2, #18192	; 0x4710
 8000e96:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000e9a:	683b      	ldr	r3, [r7, #0]
 8000e9c:	ea4f 4103 	mov.w	r1, r3, lsl #16
 8000ea0:	f644 7301 	movw	r3, #20225	; 0x4f01
 8000ea4:	f2c0 1300 	movt	r3, #256	; 0x100
 8000ea8:	430b      	orrs	r3, r1
 8000eaa:	6093      	str	r3, [r2, #8]
		   /* we may have to set OSCDISCDIS */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8000eac:	f244 7310 	movw	r3, #18192	; 0x4710
 8000eb0:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000eb4:	f244 7210 	movw	r2, #18192	; 0x4710
 8000eb8:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000ebc:	6852      	ldr	r2, [r2, #4]
 8000ebe:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000ec2:	605a      	str	r2, [r3, #4]
		   /* connect OSC_HP to PLL */
		   SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_FINDIS_Msk;
 8000ec4:	f244 7310 	movw	r3, #18192	; 0x4710
 8000ec8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000ecc:	f244 7210 	movw	r2, #18192	; 0x4710
 8000ed0:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000ed4:	6852      	ldr	r2, [r2, #4]
 8000ed6:	f022 0210 	bic.w	r2, r2, #16
 8000eda:	605a      	str	r2, [r3, #4]
		   /* restart PLL Lock detection */
		   SCU_PLL->PLLCON0 |= SCU_PLL_PLLCON0_RESLD_Msk;
 8000edc:	f244 7310 	movw	r3, #18192	; 0x4710
 8000ee0:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000ee4:	f244 7210 	movw	r2, #18192	; 0x4710
 8000ee8:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000eec:	6852      	ldr	r2, [r2, #4]
 8000eee:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8000ef2:	605a      	str	r2, [r3, #4]
		   /* wait for PLL Lock */
		   /* setup time out loop */
	       /* Timeout for wait loo ~150ms */
		   /********************************/
		   SysTick->LOAD  = ((5000000+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
 8000ef4:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000ef8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000efc:	f644 32a3 	movw	r2, #19363	; 0x4ba3
 8000f00:	f2c0 024c 	movt	r2, #76	; 0x4c
 8000f04:	605a      	str	r2, [r3, #4]
		   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000f06:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000f0a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000f0e:	f04f 0200 	mov.w	r2, #0
 8000f12:	609a      	str	r2, [r3, #8]
		   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f14:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000f18:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000f1c:	f04f 0205 	mov.w	r2, #5
 8000f20:	601a      	str	r2, [r3, #0]
		                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */		  
		   
		   while ((!(SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk))&&(SysTick->VAL >= 500));
 8000f22:	bf00      	nop
 8000f24:	f244 7310 	movw	r3, #18192	; 0x4710
 8000f28:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000f2c:	681b      	ldr	r3, [r3, #0]
 8000f2e:	f003 0304 	and.w	r3, r3, #4
 8000f32:	2b00      	cmp	r3, #0
 8000f34:	d108      	bne.n	8000f48 <SystemClockSetup+0x284>
 8000f36:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000f3a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000f3e:	689a      	ldr	r2, [r3, #8]
 8000f40:	f240 13f3 	movw	r3, #499	; 0x1f3
 8000f44:	429a      	cmp	r2, r3
 8000f46:	d8ed      	bhi.n	8000f24 <SystemClockSetup+0x260>
	       SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8000f48:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000f4c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000f50:	f24e 0210 	movw	r2, #57360	; 0xe010
 8000f54:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000f58:	6812      	ldr	r2, [r2, #0]
 8000f5a:	f022 0201 	bic.w	r2, r2, #1
 8000f5e:	601a      	str	r2, [r3, #0]

		   if ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)==SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 8000f60:	f244 7310 	movw	r3, #18192	; 0x4710
 8000f64:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000f68:	681b      	ldr	r3, [r3, #0]
 8000f6a:	f003 0304 	and.w	r3, r3, #4
 8000f6e:	2b00      	cmp	r3, #0
 8000f70:	d04e      	beq.n	8001010 <SystemClockSetup+0x34c>
		   		{
				/* Go back to the Main PLL */
				SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_VCOBYP_Msk;
 8000f72:	f244 7310 	movw	r3, #18192	; 0x4710
 8000f76:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000f7a:	f244 7210 	movw	r2, #18192	; 0x4710
 8000f7e:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000f82:	6852      	ldr	r2, [r2, #4]
 8000f84:	f022 0201 	bic.w	r2, r2, #1
 8000f88:	605a      	str	r2, [r3, #4]
	
	   /*********************************************************
	   here we need to setup the system clock divider
	   *********************************************************/
	
		SCU_CLK->CPUCLKCR = SCU_CPUCLKCR_DIV;
 8000f8a:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000f8e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000f92:	f04f 0200 	mov.w	r2, #0
 8000f96:	611a      	str	r2, [r3, #16]
		SCU_CLK->PBCLKCR = SCU_PBCLKCR_DIV;	
 8000f98:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000f9c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000fa0:	f04f 0200 	mov.w	r2, #0
 8000fa4:	615a      	str	r2, [r3, #20]
		SCU_CLK->CCUCLKCR = SCU_CCUCLKCR_DIV;
 8000fa6:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000faa:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000fae:	f04f 0200 	mov.w	r2, #0
 8000fb2:	621a      	str	r2, [r3, #32]
	

		 /* Switch system clock to PLL */
	   SCU_CLK->SYSCLKCR |=  0x00010000; 
 8000fb4:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 8000fb8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000fbc:	f44f 428c 	mov.w	r2, #17920	; 0x4600
 8000fc0:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000fc4:	68d2      	ldr	r2, [r2, #12]
 8000fc6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000fca:	60da      	str	r2, [r3, #12]
				
	   /* we may have to reset OSCDISCDIS */
	   SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8000fcc:	f244 7310 	movw	r3, #18192	; 0x4710
 8000fd0:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8000fd4:	f244 7210 	movw	r2, #18192	; 0x4710
 8000fd8:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8000fdc:	6852      	ldr	r2, [r2, #4]
 8000fde:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8000fe2:	605a      	str	r2, [r3, #4]
				
																  
		 /*********************************************************/
		 /* Delay for next K2 step ~50s */
		 /*********************************************************/
		 SysTick->LOAD  = ((1250+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
 8000fe4:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000fe8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000fec:	f240 5245 	movw	r2, #1349	; 0x545
 8000ff0:	605a      	str	r2, [r3, #4]
		 SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 8000ff2:	f24e 0310 	movw	r3, #57360	; 0xe010
 8000ff6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000ffa:	f04f 0200 	mov.w	r2, #0
 8000ffe:	609a      	str	r2, [r3, #8]
		 SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001000:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001004:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001008:	f04f 0205 	mov.w	r2, #5
 800100c:	601a      	str	r2, [r3, #0]
										 SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
	
		 while (SysTick->VAL >= 100);								   /* wait for ~50s  */
 800100e:	e002      	b.n	8001016 <SystemClockSetup+0x352>
		   if ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)==SCU_PLL_PLLSTAT_VCOLOCK_Msk)
		   		{
				/* Go back to the Main PLL */
				SCU_PLL->PLLCON0 &= ~SCU_PLL_PLLCON0_VCOBYP_Msk;
				}
				else return(0);
 8001010:	f04f 0300 	mov.w	r3, #0
 8001014:	e0b6      	b.n	8001184 <SystemClockSetup+0x4c0>
		 SysTick->LOAD  = ((1250+100) & SysTick_LOAD_RELOAD_Msk) - 1;/* set reload register */
		 SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
		 SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
										 SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
	
		 while (SysTick->VAL >= 100);								   /* wait for ~50s  */
 8001016:	f24e 0310 	movw	r3, #57360	; 0xe010
 800101a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800101e:	689b      	ldr	r3, [r3, #8]
 8001020:	2b63      	cmp	r3, #99	; 0x63
 8001022:	d8f8      	bhi.n	8001016 <SystemClockSetup+0x352>
		 SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8001024:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001028:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800102c:	f24e 0210 	movw	r2, #57360	; 0xe010
 8001030:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8001034:	6812      	ldr	r2, [r2, #0]
 8001036:	f022 0201 	bic.w	r2, r2, #1
 800103a:	601a      	str	r2, [r3, #0]
	   /*********************************************************
	   here the ramp up of the system clock starts FSys < 60MHz
	   *********************************************************/
		if (CLOCK_FSYS > 60000000){
			 /*calulation for stepping*/
			 if (SCU_PLL_CLOCK_INPUT == SCU_CLOCK_CRYSTAL)VCO = (CLOCK_CRYSTAL_FREQUENCY/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);
 800103c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001040:	f6c1 439c 	movt	r3, #7324	; 0x1c9c
 8001044:	607b      	str	r3, [r7, #4]
			 if ((SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_AUTOMATIC) ||(SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_FACTORY))
					VCO = (CLOCK_BACK_UP/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);
	 
			 stepping_K2DIV = (VCO/60000000)-1;	
 8001046:	687b      	ldr	r3, [r7, #4]
 8001048:	ea4f 2213 	mov.w	r2, r3, lsr #8
 800104c:	f245 43c7 	movw	r3, #21703	; 0x54c7
 8001050:	f2c0 131e 	movt	r3, #286	; 0x11e
 8001054:	fba3 1302 	umull	r1, r3, r3, r2
 8001058:	ea4f 2393 	mov.w	r3, r3, lsr #10
 800105c:	f103 33ff 	add.w	r3, r3, #4294967295
 8001060:	603b      	str	r3, [r7, #0]

			 /* Setup devider settings for main PLL */
				SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (stepping_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 8001062:	f244 7210 	movw	r2, #18192	; 0x4710
 8001066:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800106a:	683b      	ldr	r3, [r7, #0]
 800106c:	ea4f 4103 	mov.w	r1, r3, lsl #16
 8001070:	f644 7301 	movw	r3, #20225	; 0x4f01
 8001074:	f2c0 1300 	movt	r3, #256	; 0x100
 8001078:	430b      	orrs	r3, r1
 800107a:	6093      	str	r3, [r2, #8]
		 }

		 /*********************************************************/
		 /* Delay for next K2 step ~50s */
		 /*********************************************************/
	   SysTick->LOAD  = ((3000+100) & SysTick_LOAD_RELOAD_Msk) - 1;
 800107c:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001080:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001084:	f640 421b 	movw	r2, #3099	; 0xc1b
 8001088:	605a      	str	r2, [r3, #4]
	   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 800108a:	f24e 0310 	movw	r3, #57360	; 0xe010
 800108e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001092:	f04f 0200 	mov.w	r2, #0
 8001096:	609a      	str	r2, [r3, #8]
	   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001098:	f24e 0310 	movw	r3, #57360	; 0xe010
 800109c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80010a0:	f04f 0205 	mov.w	r2, #5
 80010a4:	601a      	str	r2, [r3, #0]
	                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
	
	   while (SysTick->VAL >= 100);								   /* wait for ~50s  */
 80010a6:	bf00      	nop
 80010a8:	f24e 0310 	movw	r3, #57360	; 0xe010
 80010ac:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80010b0:	689b      	ldr	r3, [r3, #8]
 80010b2:	2b63      	cmp	r3, #99	; 0x63
 80010b4:	d8f8      	bhi.n	80010a8 <SystemClockSetup+0x3e4>
	   SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 80010b6:	f24e 0310 	movw	r3, #57360	; 0xe010
 80010ba:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80010be:	f24e 0210 	movw	r2, #57360	; 0xe010
 80010c2:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80010c6:	6812      	ldr	r2, [r2, #0]
 80010c8:	f022 0201 	bic.w	r2, r2, #1
 80010cc:	601a      	str	r2, [r3, #0]
   /*********************************************************
	   here the ramp up of the system clock starts FSys < 90MHz
	   *********************************************************/
		if (CLOCK_FSYS > 90000000){
			 /*calulation for stepping*/
			 if (SCU_PLL_CLOCK_INPUT == SCU_CLOCK_CRYSTAL)VCO = (CLOCK_CRYSTAL_FREQUENCY/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);
 80010ce:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80010d2:	f6c1 439c 	movt	r3, #7324	; 0x1c9c
 80010d6:	607b      	str	r3, [r7, #4]
			 if ((SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_AUTOMATIC) ||(SCU_PLL_CLOCK_INPUT == SCU_CLOCK_BACK_UP_FACTORY))
					VCO = (CLOCK_BACK_UP/(SCU_PLL_PDIV+1))*(SCU_PLL_NDIV+1);

			 stepping_K2DIV = (VCO/90000000)-1;			
 80010d8:	687b      	ldr	r3, [r7, #4]
 80010da:	ea4f 12d3 	mov.w	r2, r3, lsr #7
 80010de:	f24e 332f 	movw	r3, #58159	; 0xe32f
 80010e2:	f2c0 03be 	movt	r3, #190	; 0xbe
 80010e6:	fba3 1302 	umull	r1, r3, r3, r2
 80010ea:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80010ee:	f103 33ff 	add.w	r3, r3, #4294967295
 80010f2:	603b      	str	r3, [r7, #0]

			 /* Setup devider settings for main PLL */
				SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (stepping_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 80010f4:	f244 7210 	movw	r2, #18192	; 0x4710
 80010f8:	f2c5 0200 	movt	r2, #20480	; 0x5000
 80010fc:	683b      	ldr	r3, [r7, #0]
 80010fe:	ea4f 4103 	mov.w	r1, r3, lsl #16
 8001102:	f644 7301 	movw	r3, #20225	; 0x4f01
 8001106:	f2c0 1300 	movt	r3, #256	; 0x100
 800110a:	430b      	orrs	r3, r1
 800110c:	6093      	str	r3, [r2, #8]
		 }
	
		 /*********************************************************/
		 /* Delay for next K2 step ~50s */
		 /*********************************************************/
	   SysTick->LOAD  = ((4800+100) & SysTick_LOAD_RELOAD_Msk) - 1;
 800110e:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001112:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001116:	f241 3223 	movw	r2, #4899	; 0x1323
 800111a:	605a      	str	r2, [r3, #4]
	   SysTick->VAL   = 0;                                         /* Load the SysTick Counter Value */
 800111c:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001120:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001124:	f04f 0200 	mov.w	r2, #0
 8001128:	609a      	str	r2, [r3, #8]
	   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800112a:	f24e 0310 	movw	r3, #57360	; 0xe010
 800112e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001132:	f04f 0205 	mov.w	r2, #5
 8001136:	601a      	str	r2, [r3, #0]
	                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
	
	   while (SysTick->VAL >= 100);								   /* wait for ~50s  */
 8001138:	bf00      	nop
 800113a:	f24e 0310 	movw	r3, #57360	; 0xe010
 800113e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001142:	689b      	ldr	r3, [r3, #8]
 8001144:	2b63      	cmp	r3, #99	; 0x63
 8001146:	d8f8      	bhi.n	800113a <SystemClockSetup+0x476>
	   SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;                 /* Stop SysTick Timer */
 8001148:	f24e 0310 	movw	r3, #57360	; 0xe010
 800114c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001150:	f24e 0210 	movw	r2, #57360	; 0xe010
 8001154:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8001158:	6812      	ldr	r2, [r2, #0]
 800115a:	f022 0201 	bic.w	r2, r2, #1
 800115e:	601a      	str	r2, [r3, #0]
	   /********************************/
	
	   /* Setup devider settings for main PLL */
	   SCU_PLL->PLLCON1 = ((SCU_PLL_K1DIV) | (SCU_PLL_NDIV<<8) | (SCU_PLL_K2DIV<<16) | (SCU_PLL_PDIV<<24));
 8001160:	f244 7310 	movw	r3, #18192	; 0x4710
 8001164:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8001168:	f644 7201 	movw	r2, #20225	; 0x4f01
 800116c:	f2c0 1203 	movt	r2, #259	; 0x103
 8001170:	609a      	str	r2, [r3, #8]
	
	   SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_SOSCWDGT_Msk | SCU_TRAP_TRAPCLR_SVCOLCKT_Msk;  /* clear request for System OCS Watchdog Trap and System VCO Lock Trap  */
 8001172:	f244 1360 	movw	r3, #16736	; 0x4160
 8001176:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800117a:	f04f 0205 	mov.w	r2, #5
 800117e:	60da      	str	r2, [r3, #12]
	}
 }/* end this weak function enables DAVE3 clock App usage */	
   return(1);
 8001180:	f04f 0301 	mov.w	r3, #1

}
 8001184:	4618      	mov	r0, r3
 8001186:	f107 0708 	add.w	r7, r7, #8
 800118a:	46bd      	mov	sp, r7
 800118c:	bd80      	pop	{r7, pc}
 800118e:	bf00      	nop

08001190 <Queue_Init>:

#include "DataQueue.h"


void Queue_Init(DataQueueType *dq)
{
 8001190:	b480      	push	{r7}
 8001192:	b083      	sub	sp, #12
 8001194:	af00      	add	r7, sp, #0
 8001196:	6078      	str	r0, [r7, #4]
	dq->u8processingIndex = 0;
 8001198:	687b      	ldr	r3, [r7, #4]
 800119a:	f04f 0200 	mov.w	r2, #0
 800119e:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
	dq->u8rxIndex = 0;
 80011a2:	687b      	ldr	r3, [r7, #4]
 80011a4:	f04f 0200 	mov.w	r2, #0
 80011a8:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff
	dq->u8usedSpace = 0;
 80011ac:	687b      	ldr	r3, [r7, #4]
 80011ae:	f04f 0200 	mov.w	r2, #0
 80011b2:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
}
 80011b6:	f107 070c 	add.w	r7, r7, #12
 80011ba:	46bd      	mov	sp, r7
 80011bc:	bc80      	pop	{r7}
 80011be:	4770      	bx	lr

080011c0 <Queue_IsEmpty>:

bool Queue_IsEmpty(DataQueueType dq)
{
 80011c0:	b084      	sub	sp, #16
 80011c2:	b480      	push	{r7}
 80011c4:	af00      	add	r7, sp, #0
 80011c6:	f107 0c04 	add.w	ip, r7, #4
 80011ca:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
	return (0 == dq.u8usedSpace);
 80011ce:	f897 3105 	ldrb.w	r3, [r7, #261]	; 0x105
 80011d2:	2b00      	cmp	r3, #0
 80011d4:	bf14      	ite	ne
 80011d6:	2300      	movne	r3, #0
 80011d8:	2301      	moveq	r3, #1
 80011da:	b2db      	uxtb	r3, r3
}
 80011dc:	4618      	mov	r0, r3
 80011de:	46bd      	mov	sp, r7
 80011e0:	bc80      	pop	{r7}
 80011e2:	b004      	add	sp, #16
 80011e4:	4770      	bx	lr
 80011e6:	bf00      	nop

080011e8 <Queue_IsFull>:

bool Queue_IsFull(DataQueueType dq)
{
 80011e8:	b084      	sub	sp, #16
 80011ea:	b480      	push	{r7}
 80011ec:	af00      	add	r7, sp, #0
 80011ee:	f107 0c04 	add.w	ip, r7, #4
 80011f2:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
	return (QUEUE_MAX_SIZE == dq.u8usedSpace);
 80011f6:	f897 3105 	ldrb.w	r3, [r7, #261]	; 0x105
 80011fa:	2bff      	cmp	r3, #255	; 0xff
 80011fc:	bf14      	ite	ne
 80011fe:	2300      	movne	r3, #0
 8001200:	2301      	moveq	r3, #1
 8001202:	b2db      	uxtb	r3, r3
}
 8001204:	4618      	mov	r0, r3
 8001206:	46bd      	mov	sp, r7
 8001208:	bc80      	pop	{r7}
 800120a:	b004      	add	sp, #16
 800120c:	4770      	bx	lr
 800120e:	bf00      	nop

08001210 <Queue_PutByte>:

uint8_t Queue_PutByte(DataQueueType *dq, uint8_t byte )
{
 8001210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001214:	b0c2      	sub	sp, #264	; 0x108
 8001216:	af3e      	add	r7, sp, #248	; 0xf8
 8001218:	6078      	str	r0, [r7, #4]
 800121a:	460b      	mov	r3, r1
 800121c:	70fb      	strb	r3, [r7, #3]
	StdReturnType ret = NOT_OK;
 800121e:	f04f 0301 	mov.w	r3, #1
 8001222:	73fb      	strb	r3, [r7, #15]

	if (NOT_OK == Queue_IsFull(*dq))
 8001224:	687b      	ldr	r3, [r7, #4]
 8001226:	681a      	ldr	r2, [r3, #0]
 8001228:	f04f 0800 	mov.w	r8, #0
 800122c:	4690      	mov	r8, r2
 800122e:	685a      	ldr	r2, [r3, #4]
 8001230:	f04f 0600 	mov.w	r6, #0
 8001234:	4616      	mov	r6, r2
 8001236:	689a      	ldr	r2, [r3, #8]
 8001238:	f04f 0500 	mov.w	r5, #0
 800123c:	4615      	mov	r5, r2
 800123e:	68da      	ldr	r2, [r3, #12]
 8001240:	f04f 0400 	mov.w	r4, #0
 8001244:	4614      	mov	r4, r2
 8001246:	4669      	mov	r1, sp
 8001248:	f103 0210 	add.w	r2, r3, #16
 800124c:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 8001250:	4608      	mov	r0, r1
 8001252:	4611      	mov	r1, r2
 8001254:	461a      	mov	r2, r3
 8001256:	f022 f9dd 	bl	8023614 <memcpy>
 800125a:	4640      	mov	r0, r8
 800125c:	4631      	mov	r1, r6
 800125e:	462a      	mov	r2, r5
 8001260:	4623      	mov	r3, r4
 8001262:	f7ff ffc1 	bl	80011e8 <Queue_IsFull>
 8001266:	4603      	mov	r3, r0
 8001268:	2b01      	cmp	r3, #1
 800126a:	d125      	bne.n	80012b8 <Queue_PutByte+0xa8>
	{
		dq->au8dataBuffer[dq->u8rxIndex] = byte;
 800126c:	687b      	ldr	r3, [r7, #4]
 800126e:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 8001272:	687a      	ldr	r2, [r7, #4]
 8001274:	78f9      	ldrb	r1, [r7, #3]
 8001276:	54d1      	strb	r1, [r2, r3]
		if (dq->u8rxIndex == QUEUE_MAX_SIZE - 1 )
 8001278:	687b      	ldr	r3, [r7, #4]
 800127a:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800127e:	2bfe      	cmp	r3, #254	; 0xfe
 8001280:	d105      	bne.n	800128e <Queue_PutByte+0x7e>
		{
			dq->u8rxIndex = 0;
 8001282:	687b      	ldr	r3, [r7, #4]
 8001284:	f04f 0200 	mov.w	r2, #0
 8001288:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff
 800128c:	e008      	b.n	80012a0 <Queue_PutByte+0x90>
		}
		else
		{
			dq->u8rxIndex++;
 800128e:	687b      	ldr	r3, [r7, #4]
 8001290:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 8001294:	f103 0301 	add.w	r3, r3, #1
 8001298:	b2da      	uxtb	r2, r3
 800129a:	687b      	ldr	r3, [r7, #4]
 800129c:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff
		}
		dq->u8usedSpace++;
 80012a0:	687b      	ldr	r3, [r7, #4]
 80012a2:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 80012a6:	f103 0301 	add.w	r3, r3, #1
 80012aa:	b2da      	uxtb	r2, r3
 80012ac:	687b      	ldr	r3, [r7, #4]
 80012ae:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
		ret = OK;
 80012b2:	f04f 0300 	mov.w	r3, #0
 80012b6:	73fb      	strb	r3, [r7, #15]
	}

  return ret;
 80012b8:	7bfb      	ldrb	r3, [r7, #15]
}
 80012ba:	4618      	mov	r0, r3
 80012bc:	f107 0710 	add.w	r7, r7, #16
 80012c0:	46bd      	mov	sp, r7
 80012c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80012c6:	bf00      	nop

080012c8 <Queue_PutBuffer>:

StdReturnType Queue_PutBuffer(DataQueueType *dq, uint8_t *dataBuffer, uint8_t numberOfBytes)
{
 80012c8:	b480      	push	{r7}
 80012ca:	b087      	sub	sp, #28
 80012cc:	af00      	add	r7, sp, #0
 80012ce:	60f8      	str	r0, [r7, #12]
 80012d0:	60b9      	str	r1, [r7, #8]
 80012d2:	4613      	mov	r3, r2
 80012d4:	71fb      	strb	r3, [r7, #7]
	StdReturnType ret = NOT_OK;
 80012d6:	f04f 0301 	mov.w	r3, #1
 80012da:	75fb      	strb	r3, [r7, #23]
	uint8_t u8tempIndex;

	if ((QUEUE_MAX_SIZE - dq->u8usedSpace) >= numberOfBytes)
 80012dc:	68fb      	ldr	r3, [r7, #12]
 80012de:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 80012e2:	f1c3 02ff 	rsb	r2, r3, #255	; 0xff
 80012e6:	79fb      	ldrb	r3, [r7, #7]
 80012e8:	429a      	cmp	r2, r3
 80012ea:	db31      	blt.n	8001350 <Queue_PutBuffer+0x88>
	{
		while ( u8tempIndex < numberOfBytes )
 80012ec:	e029      	b.n	8001342 <Queue_PutBuffer+0x7a>
		{
	      dq->au8dataBuffer[dq->u8rxIndex] = dataBuffer[u8tempIndex];
 80012ee:	68fb      	ldr	r3, [r7, #12]
 80012f0:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 80012f4:	7dba      	ldrb	r2, [r7, #22]
 80012f6:	68b9      	ldr	r1, [r7, #8]
 80012f8:	188a      	adds	r2, r1, r2
 80012fa:	7811      	ldrb	r1, [r2, #0]
 80012fc:	68fa      	ldr	r2, [r7, #12]
 80012fe:	54d1      	strb	r1, [r2, r3]
	      if (dq->u8rxIndex == QUEUE_MAX_SIZE - 1)
 8001300:	68fb      	ldr	r3, [r7, #12]
 8001302:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 8001306:	2bfe      	cmp	r3, #254	; 0xfe
 8001308:	d105      	bne.n	8001316 <Queue_PutBuffer+0x4e>
	      {
	    	  dq->u8rxIndex = 0;
 800130a:	68fb      	ldr	r3, [r7, #12]
 800130c:	f04f 0200 	mov.w	r2, #0
 8001310:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff
 8001314:	e008      	b.n	8001328 <Queue_PutBuffer+0x60>
	      }
	      else
	      {
	    	  dq->u8rxIndex++;
 8001316:	68fb      	ldr	r3, [r7, #12]
 8001318:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
 800131c:	f103 0301 	add.w	r3, r3, #1
 8001320:	b2da      	uxtb	r2, r3
 8001322:	68fb      	ldr	r3, [r7, #12]
 8001324:	f883 20ff 	strb.w	r2, [r3, #255]	; 0xff
	      }
	      dq->u8usedSpace++;
 8001328:	68fb      	ldr	r3, [r7, #12]
 800132a:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 800132e:	f103 0301 	add.w	r3, r3, #1
 8001332:	b2da      	uxtb	r2, r3
 8001334:	68fb      	ldr	r3, [r7, #12]
 8001336:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
	      u8tempIndex++;
 800133a:	7dbb      	ldrb	r3, [r7, #22]
 800133c:	f103 0301 	add.w	r3, r3, #1
 8001340:	75bb      	strb	r3, [r7, #22]
	StdReturnType ret = NOT_OK;
	uint8_t u8tempIndex;

	if ((QUEUE_MAX_SIZE - dq->u8usedSpace) >= numberOfBytes)
	{
		while ( u8tempIndex < numberOfBytes )
 8001342:	7dba      	ldrb	r2, [r7, #22]
 8001344:	79fb      	ldrb	r3, [r7, #7]
 8001346:	429a      	cmp	r2, r3
 8001348:	d3d1      	bcc.n	80012ee <Queue_PutBuffer+0x26>
	    	  dq->u8rxIndex++;
	      }
	      dq->u8usedSpace++;
	      u8tempIndex++;
		}
	    ret = OK;
 800134a:	f04f 0300 	mov.w	r3, #0
 800134e:	75fb      	strb	r3, [r7, #23]
	  }
	  return ret;
 8001350:	7dfb      	ldrb	r3, [r7, #23]
}
 8001352:	4618      	mov	r0, r3
 8001354:	f107 071c 	add.w	r7, r7, #28
 8001358:	46bd      	mov	sp, r7
 800135a:	bc80      	pop	{r7}
 800135c:	4770      	bx	lr
 800135e:	bf00      	nop

08001360 <Queue_GetByte>:


StdReturnType Queue_GetByte(DataQueueType *dq, uint8_t *byte)
{
 8001360:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001364:	b0c2      	sub	sp, #264	; 0x108
 8001366:	af3e      	add	r7, sp, #248	; 0xf8
 8001368:	6078      	str	r0, [r7, #4]
 800136a:	6039      	str	r1, [r7, #0]
	StdReturnType ret = NOT_OK;
 800136c:	f04f 0301 	mov.w	r3, #1
 8001370:	73fb      	strb	r3, [r7, #15]

	if (FALSE == Queue_IsEmpty(*dq))
 8001372:	687b      	ldr	r3, [r7, #4]
 8001374:	681a      	ldr	r2, [r3, #0]
 8001376:	f04f 0800 	mov.w	r8, #0
 800137a:	4690      	mov	r8, r2
 800137c:	685a      	ldr	r2, [r3, #4]
 800137e:	f04f 0600 	mov.w	r6, #0
 8001382:	4616      	mov	r6, r2
 8001384:	689a      	ldr	r2, [r3, #8]
 8001386:	f04f 0500 	mov.w	r5, #0
 800138a:	4615      	mov	r5, r2
 800138c:	68da      	ldr	r2, [r3, #12]
 800138e:	f04f 0400 	mov.w	r4, #0
 8001392:	4614      	mov	r4, r2
 8001394:	4669      	mov	r1, sp
 8001396:	f103 0210 	add.w	r2, r3, #16
 800139a:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 800139e:	4608      	mov	r0, r1
 80013a0:	4611      	mov	r1, r2
 80013a2:	461a      	mov	r2, r3
 80013a4:	f022 f936 	bl	8023614 <memcpy>
 80013a8:	4640      	mov	r0, r8
 80013aa:	4631      	mov	r1, r6
 80013ac:	462a      	mov	r2, r5
 80013ae:	4623      	mov	r3, r4
 80013b0:	f7ff ff06 	bl	80011c0 <Queue_IsEmpty>
 80013b4:	4603      	mov	r3, r0
 80013b6:	2b00      	cmp	r3, #0
 80013b8:	d126      	bne.n	8001408 <Queue_GetByte+0xa8>
	{
		*byte = dq->au8dataBuffer[dq->u8processingIndex];
 80013ba:	687b      	ldr	r3, [r7, #4]
 80013bc:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 80013c0:	687a      	ldr	r2, [r7, #4]
 80013c2:	5cd2      	ldrb	r2, [r2, r3]
 80013c4:	683b      	ldr	r3, [r7, #0]
 80013c6:	701a      	strb	r2, [r3, #0]
		if (dq->u8processingIndex == (QUEUE_MAX_SIZE - 1))
 80013c8:	687b      	ldr	r3, [r7, #4]
 80013ca:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 80013ce:	2bfe      	cmp	r3, #254	; 0xfe
 80013d0:	d105      	bne.n	80013de <Queue_GetByte+0x7e>
		{
			dq->u8processingIndex = 0;
 80013d2:	687b      	ldr	r3, [r7, #4]
 80013d4:	f04f 0200 	mov.w	r2, #0
 80013d8:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
 80013dc:	e008      	b.n	80013f0 <Queue_GetByte+0x90>
		}
		else
		{
			dq->u8processingIndex++;
 80013de:	687b      	ldr	r3, [r7, #4]
 80013e0:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 80013e4:	f103 0301 	add.w	r3, r3, #1
 80013e8:	b2da      	uxtb	r2, r3
 80013ea:	687b      	ldr	r3, [r7, #4]
 80013ec:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
		}
		dq->u8usedSpace--;
 80013f0:	687b      	ldr	r3, [r7, #4]
 80013f2:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 80013f6:	f103 33ff 	add.w	r3, r3, #4294967295
 80013fa:	b2da      	uxtb	r2, r3
 80013fc:	687b      	ldr	r3, [r7, #4]
 80013fe:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
		ret = OK;
 8001402:	f04f 0300 	mov.w	r3, #0
 8001406:	73fb      	strb	r3, [r7, #15]
  }

	return ret;
 8001408:	7bfb      	ldrb	r3, [r7, #15]
}
 800140a:	4618      	mov	r0, r3
 800140c:	f107 0710 	add.w	r7, r7, #16
 8001410:	46bd      	mov	sp, r7
 8001412:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001416:	bf00      	nop

08001418 <Queue_GetBuffer>:

StdReturnType Queue_GetBuffer(DataQueueType *dq, uint8_t *buff, uint8_t numberOfBytes)
{
 8001418:	b480      	push	{r7}
 800141a:	b087      	sub	sp, #28
 800141c:	af00      	add	r7, sp, #0
 800141e:	60f8      	str	r0, [r7, #12]
 8001420:	60b9      	str	r1, [r7, #8]
 8001422:	4613      	mov	r3, r2
 8001424:	71fb      	strb	r3, [r7, #7]
	StdReturnType ret = NOT_OK;
 8001426:	f04f 0301 	mov.w	r3, #1
 800142a:	75fb      	strb	r3, [r7, #23]
	uint8_t u8Index = 0;
 800142c:	f04f 0300 	mov.w	r3, #0
 8001430:	75bb      	strb	r3, [r7, #22]

	if (dq->u8usedSpace >= numberOfBytes )
 8001432:	68fb      	ldr	r3, [r7, #12]
 8001434:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8001438:	79fa      	ldrb	r2, [r7, #7]
 800143a:	429a      	cmp	r2, r3
 800143c:	d831      	bhi.n	80014a2 <Queue_GetBuffer+0x8a>
	{
		while (u8Index < numberOfBytes)
 800143e:	e029      	b.n	8001494 <Queue_GetBuffer+0x7c>
		{
			buff[u8Index] = dq->au8dataBuffer[dq->u8processingIndex];
 8001440:	7dbb      	ldrb	r3, [r7, #22]
 8001442:	68ba      	ldr	r2, [r7, #8]
 8001444:	18d3      	adds	r3, r2, r3
 8001446:	68fa      	ldr	r2, [r7, #12]
 8001448:	f892 2100 	ldrb.w	r2, [r2, #256]	; 0x100
 800144c:	68f9      	ldr	r1, [r7, #12]
 800144e:	5c8a      	ldrb	r2, [r1, r2]
 8001450:	701a      	strb	r2, [r3, #0]
			if (dq->u8processingIndex == (QUEUE_MAX_SIZE - 1))
 8001452:	68fb      	ldr	r3, [r7, #12]
 8001454:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 8001458:	2bfe      	cmp	r3, #254	; 0xfe
 800145a:	d105      	bne.n	8001468 <Queue_GetBuffer+0x50>
			{
				dq->u8processingIndex = 0;
 800145c:	68fb      	ldr	r3, [r7, #12]
 800145e:	f04f 0200 	mov.w	r2, #0
 8001462:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
 8001466:	e008      	b.n	800147a <Queue_GetBuffer+0x62>
			}
			else
			{
				dq->u8processingIndex++;
 8001468:	68fb      	ldr	r3, [r7, #12]
 800146a:	f893 3100 	ldrb.w	r3, [r3, #256]	; 0x100
 800146e:	f103 0301 	add.w	r3, r3, #1
 8001472:	b2da      	uxtb	r2, r3
 8001474:	68fb      	ldr	r3, [r7, #12]
 8001476:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
			}
				dq->u8usedSpace--;
 800147a:	68fb      	ldr	r3, [r7, #12]
 800147c:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 8001480:	f103 33ff 	add.w	r3, r3, #4294967295
 8001484:	b2da      	uxtb	r2, r3
 8001486:	68fb      	ldr	r3, [r7, #12]
 8001488:	f883 2101 	strb.w	r2, [r3, #257]	; 0x101
				u8Index++;
 800148c:	7dbb      	ldrb	r3, [r7, #22]
 800148e:	f103 0301 	add.w	r3, r3, #1
 8001492:	75bb      	strb	r3, [r7, #22]
	StdReturnType ret = NOT_OK;
	uint8_t u8Index = 0;

	if (dq->u8usedSpace >= numberOfBytes )
	{
		while (u8Index < numberOfBytes)
 8001494:	7dba      	ldrb	r2, [r7, #22]
 8001496:	79fb      	ldrb	r3, [r7, #7]
 8001498:	429a      	cmp	r2, r3
 800149a:	d3d1      	bcc.n	8001440 <Queue_GetBuffer+0x28>
				dq->u8processingIndex++;
			}
				dq->u8usedSpace--;
				u8Index++;
			}
		ret = OK;
 800149c:	f04f 0300 	mov.w	r3, #0
 80014a0:	75fb      	strb	r3, [r7, #23]
	}

	return ret;
 80014a2:	7dfb      	ldrb	r3, [r7, #23]
}
 80014a4:	4618      	mov	r0, r3
 80014a6:	f107 071c 	add.w	r7, r7, #28
 80014aa:	46bd      	mov	sp, r7
 80014ac:	bc80      	pop	{r7}
 80014ae:	4770      	bx	lr

080014b0 <CGI_led_handler>:
#include "DataQueue.h"

/* Initialisation of functions to be used with CGi*/
//  CGI handler to switch LED status
const char *CGI_led_handler(int iIndex, int iNumParams, char *pcParam[], char *pcValue[])
{
 80014b0:	b580      	push	{r7, lr}
 80014b2:	b086      	sub	sp, #24
 80014b4:	af00      	add	r7, sp, #0
 80014b6:	60f8      	str	r0, [r7, #12]
 80014b8:	60b9      	str	r1, [r7, #8]
 80014ba:	607a      	str	r2, [r7, #4]
 80014bc:	603b      	str	r3, [r7, #0]

	uint32_t i=0;
 80014be:	f04f 0300 	mov.w	r3, #0
 80014c2:	617b      	str	r3, [r7, #20]
	
	/* We have only one CGI handler iIndex = 0 */
	if (iIndex==0)
 80014c4:	68fb      	ldr	r3, [r7, #12]
 80014c6:	2b00      	cmp	r3, #0
 80014c8:	d168      	bne.n	800159c <CGI_led_handler+0xec>
	{

	  /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
	  for (i=0; i<iNumParams; i++)
 80014ca:	f04f 0300 	mov.w	r3, #0
 80014ce:	617b      	str	r3, [r7, #20]
 80014d0:	e060      	b.n	8001594 <CGI_led_handler+0xe4>
	  {
		/* check parameter "led" */
		if (strcmp(pcParam[i] , "led")==0)	 
 80014d2:	697b      	ldr	r3, [r7, #20]
 80014d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80014d8:	687a      	ldr	r2, [r7, #4]
 80014da:	18d3      	adds	r3, r2, r3
 80014dc:	681b      	ldr	r3, [r3, #0]
 80014de:	4618      	mov	r0, r3
 80014e0:	f245 61e8 	movw	r1, #22248	; 0x56e8
 80014e4:	f6c0 0102 	movt	r1, #2050	; 0x802
 80014e8:	f023 f9de 	bl	80248a8 <strcmp>
 80014ec:	4603      	mov	r3, r0
 80014ee:	2b00      	cmp	r3, #0
 80014f0:	d14c      	bne.n	800158c <CGI_led_handler+0xdc>
		{
		  /* switch led1 ON if 1 */
		  if(strcmp(pcValue[i], "1") ==0) 
 80014f2:	697b      	ldr	r3, [r7, #20]
 80014f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80014f8:	683a      	ldr	r2, [r7, #0]
 80014fa:	18d3      	adds	r3, r2, r3
 80014fc:	681b      	ldr	r3, [r3, #0]
 80014fe:	4618      	mov	r0, r3
 8001500:	f245 61ec 	movw	r1, #22252	; 0x56ec
 8001504:	f6c0 0102 	movt	r1, #2050	; 0x802
 8001508:	f023 f9ce 	bl	80248a8 <strcmp>
 800150c:	4603      	mov	r3, r0
 800150e:	2b00      	cmp	r3, #0
 8001510:	d116      	bne.n	8001540 <CGI_led_handler+0x90>
				IO004_TogglePin(IO004_Handle0);
 8001512:	f246 6394 	movw	r3, #26260	; 0x6694
 8001516:	f6c0 0302 	movt	r3, #2050	; 0x802
 800151a:	685a      	ldr	r2, [r3, #4]
 800151c:	f246 6394 	movw	r3, #26260	; 0x6694
 8001520:	f6c0 0302 	movt	r3, #2050	; 0x802
 8001524:	685b      	ldr	r3, [r3, #4]
 8001526:	6859      	ldr	r1, [r3, #4]
 8001528:	f246 6394 	movw	r3, #26260	; 0x6694
 800152c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8001530:	785b      	ldrb	r3, [r3, #1]
 8001532:	f04f 1001 	mov.w	r0, #65537	; 0x10001
 8001536:	fa00 f303 	lsl.w	r3, r0, r3
 800153a:	430b      	orrs	r3, r1
 800153c:	6053      	str	r3, [r2, #4]
 800153e:	e025      	b.n	800158c <CGI_led_handler+0xdc>
			
		  /* switch led2 ON if 2 */
		  else if(strcmp(pcValue[i], "2") ==0) 
 8001540:	697b      	ldr	r3, [r7, #20]
 8001542:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001546:	683a      	ldr	r2, [r7, #0]
 8001548:	18d3      	adds	r3, r2, r3
 800154a:	681b      	ldr	r3, [r3, #0]
 800154c:	4618      	mov	r0, r3
 800154e:	f245 61f0 	movw	r1, #22256	; 0x56f0
 8001552:	f6c0 0102 	movt	r1, #2050	; 0x802
 8001556:	f023 f9a7 	bl	80248a8 <strcmp>
 800155a:	4603      	mov	r3, r0
 800155c:	2b00      	cmp	r3, #0
 800155e:	d115      	bne.n	800158c <CGI_led_handler+0xdc>
				IO004_TogglePin(IO004_Handle0);
 8001560:	f246 6394 	movw	r3, #26260	; 0x6694
 8001564:	f6c0 0302 	movt	r3, #2050	; 0x802
 8001568:	685a      	ldr	r2, [r3, #4]
 800156a:	f246 6394 	movw	r3, #26260	; 0x6694
 800156e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8001572:	685b      	ldr	r3, [r3, #4]
 8001574:	6859      	ldr	r1, [r3, #4]
 8001576:	f246 6394 	movw	r3, #26260	; 0x6694
 800157a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800157e:	785b      	ldrb	r3, [r3, #1]
 8001580:	f04f 1001 	mov.w	r0, #65537	; 0x10001
 8001584:	fa00 f303 	lsl.w	r3, r0, r3
 8001588:	430b      	orrs	r3, r1
 800158a:	6053      	str	r3, [r2, #4]
	/* We have only one CGI handler iIndex = 0 */
	if (iIndex==0)
	{

	  /* Check cgi parameter : example GET /leds.cgi?led=2&led=4 */
	  for (i=0; i<iNumParams; i++)
 800158c:	697b      	ldr	r3, [r7, #20]
 800158e:	f103 0301 	add.w	r3, r3, #1
 8001592:	617b      	str	r3, [r7, #20]
 8001594:	68ba      	ldr	r2, [r7, #8]
 8001596:	697b      	ldr	r3, [r7, #20]
 8001598:	429a      	cmp	r2, r3
 800159a:	d89a      	bhi.n	80014d2 <CGI_led_handler+0x22>
	  }
	}
	/* uri to send after cgi call*/


	return "/LED.htm";
 800159c:	f245 63f4 	movw	r3, #22260	; 0x56f4
 80015a0:	f6c0 0302 	movt	r3, #2050	; 0x802


}
 80015a4:	4618      	mov	r0, r3
 80015a6:	f107 0718 	add.w	r7, r7, #24
 80015aa:	46bd      	mov	sp, r7
 80015ac:	bd80      	pop	{r7, pc}
 80015ae:	bf00      	nop

080015b0 <http_CGI_init>:



//Initialise cgi environment
void http_CGI_init( void)
{
 80015b0:	b580      	push	{r7, lr}
 80015b2:	af00      	add	r7, sp, #0
	//Initialised CGI structure for LED
	CGI_TAB[0] = LED_CGI;
 80015b4:	f645 42d0 	movw	r2, #23760	; 0x5cd0
 80015b8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80015bc:	f245 730c 	movw	r3, #22284	; 0x570c
 80015c0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80015c4:	e893 0003 	ldmia.w	r3, {r0, r1}
 80015c8:	e882 0003 	stmia.w	r2, {r0, r1}

	// Set CGI
	http_set_cgi_handlers(&CGI_TAB[0], 1);
 80015cc:	f645 40d0 	movw	r0, #23760	; 0x5cd0
 80015d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80015d4:	f04f 0101 	mov.w	r1, #1
 80015d8:	f001 fd5c 	bl	8003094 <http_set_cgi_handlers>
}
 80015dc:	bd80      	pop	{r7, pc}
 80015de:	bf00      	nop

080015e0 <SSI_ADC_Handler>:

u16_t SSI_ADC_Handler (int iIndex, char *pcInsert, int iInsertLen)
{
 80015e0:	b590      	push	{r4, r7, lr}
 80015e2:	b089      	sub	sp, #36	; 0x24
 80015e4:	af00      	add	r7, sp, #0
 80015e6:	60f8      	str	r0, [r7, #12]
 80015e8:	60b9      	str	r1, [r7, #8]
 80015ea:	607a      	str	r2, [r7, #4]

    char Digit1=0, Digit2=0, Digit3=0, Digit4=0; 
 80015ec:	f04f 0300 	mov.w	r3, #0
 80015f0:	77fb      	strb	r3, [r7, #31]
 80015f2:	f04f 0300 	mov.w	r3, #0
 80015f6:	77bb      	strb	r3, [r7, #30]
 80015f8:	f04f 0300 	mov.w	r3, #0
 80015fc:	777b      	strb	r3, [r7, #29]
 80015fe:	f04f 0300 	mov.w	r3, #0
 8001602:	773b      	strb	r3, [r7, #28]
    uint16_t ADCVal = 0;        
 8001604:	f04f 0300 	mov.w	r3, #0
 8001608:	82fb      	strh	r3, [r7, #22]
	status_t status;

	/* We have only one SSI handler iIndex = 0 */

	if (iIndex ==0)
 800160a:	68fb      	ldr	r3, [r7, #12]
 800160c:	2b00      	cmp	r3, #0
 800160e:	f040 80a4 	bne.w	800175a <SSI_ADC_Handler+0x17a>
	{  


	/* get ADC conversion value */

	status = ADCCH001_GetResult(&ADCCH001_Handle0, &ADCVal);
 8001612:	f107 0316 	add.w	r3, r7, #22
 8001616:	f646 00c8 	movw	r0, #26824	; 0x68c8
 800161a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800161e:	4619      	mov	r1, r3
 8001620:	f01f fd28 	bl	8021074 <ADCCH001_GetResult>
 8001624:	61b8      	str	r0, [r7, #24]
		//ADCVal = AD_result;//ADC_GetConversionValue(ADC3);
		
		/* convert to Voltage,	step = 0.8 mV */
		ADCVal = (uint16_t)(ADCVal * 0.8);	
 8001626:	8afb      	ldrh	r3, [r7, #22]
 8001628:	4618      	mov	r0, r3
 800162a:	f020 feed 	bl	8022408 <__aeabi_i2d>
 800162e:	4602      	mov	r2, r0
 8001630:	460b      	mov	r3, r1
 8001632:	4610      	mov	r0, r2
 8001634:	4619      	mov	r1, r3
 8001636:	a35a      	add	r3, pc, #360	; (adr r3, 80017a0 <SSI_ADC_Handler+0x1c0>)
 8001638:	e9d3 2300 	ldrd	r2, r3, [r3]
 800163c:	f020 ff4a 	bl	80224d4 <__aeabi_dmul>
 8001640:	4602      	mov	r2, r0
 8001642:	460b      	mov	r3, r1
 8001644:	4610      	mov	r0, r2
 8001646:	4619      	mov	r1, r3
 8001648:	f021 f956 	bl	80228f8 <__aeabi_d2uiz>
 800164c:	4603      	mov	r3, r0
 800164e:	b29b      	uxth	r3, r3
 8001650:	82fb      	strh	r3, [r7, #22]
		
		/* get digits to display */
		
		Digit1= ADCVal/1000;
 8001652:	8afa      	ldrh	r2, [r7, #22]
 8001654:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 8001658:	f2c1 0362 	movt	r3, #4194	; 0x1062
 800165c:	fba3 1302 	umull	r1, r3, r3, r2
 8001660:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8001664:	b29b      	uxth	r3, r3
 8001666:	77fb      	strb	r3, [r7, #31]
		Digit2= (ADCVal-(Digit1*1000))/100 ;
 8001668:	8afb      	ldrh	r3, [r7, #22]
 800166a:	461a      	mov	r2, r3
 800166c:	7ff9      	ldrb	r1, [r7, #31]
 800166e:	f64f 4318 	movw	r3, #64536	; 0xfc18
 8001672:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8001676:	fb03 f301 	mul.w	r3, r3, r1
 800167a:	18d2      	adds	r2, r2, r3
 800167c:	f248 531f 	movw	r3, #34079	; 0x851f
 8001680:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8001684:	fb83 1302 	smull	r1, r3, r3, r2
 8001688:	ea4f 1163 	mov.w	r1, r3, asr #5
 800168c:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8001690:	1acb      	subs	r3, r1, r3
 8001692:	77bb      	strb	r3, [r7, #30]
		Digit3= (ADCVal-((Digit1*1000)+(Digit2*100)))/10;
 8001694:	8afb      	ldrh	r3, [r7, #22]
 8001696:	461a      	mov	r2, r3
 8001698:	7fbb      	ldrb	r3, [r7, #30]
 800169a:	f06f 0163 	mvn.w	r1, #99	; 0x63
 800169e:	fb01 f103 	mul.w	r1, r1, r3
 80016a2:	7ff8      	ldrb	r0, [r7, #31]
 80016a4:	f64f 4318 	movw	r3, #64536	; 0xfc18
 80016a8:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 80016ac:	fb03 f300 	mul.w	r3, r3, r0
 80016b0:	18cb      	adds	r3, r1, r3
 80016b2:	18d2      	adds	r2, r2, r3
 80016b4:	f246 6367 	movw	r3, #26215	; 0x6667
 80016b8:	f2c6 6366 	movt	r3, #26214	; 0x6666
 80016bc:	fb83 1302 	smull	r1, r3, r3, r2
 80016c0:	ea4f 01a3 	mov.w	r1, r3, asr #2
 80016c4:	ea4f 73e2 	mov.w	r3, r2, asr #31
 80016c8:	1acb      	subs	r3, r1, r3
 80016ca:	777b      	strb	r3, [r7, #29]
		Digit4= ADCVal -((Digit1*1000)+(Digit2*100)+ (Digit3*10));
 80016cc:	8afb      	ldrh	r3, [r7, #22]
 80016ce:	b2da      	uxtb	r2, r3
 80016d0:	7f7b      	ldrb	r3, [r7, #29]
 80016d2:	4619      	mov	r1, r3
 80016d4:	ea4f 1141 	mov.w	r1, r1, lsl #5
 80016d8:	1ac9      	subs	r1, r1, r3
 80016da:	ea4f 0181 	mov.w	r1, r1, lsl #2
 80016de:	1acb      	subs	r3, r1, r3
 80016e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80016e4:	b2d9      	uxtb	r1, r3
 80016e6:	7fbb      	ldrb	r3, [r7, #30]
 80016e8:	4618      	mov	r0, r3
 80016ea:	ea4f 0080 	mov.w	r0, r0, lsl #2
 80016ee:	18c0      	adds	r0, r0, r3
 80016f0:	ea4f 00c0 	mov.w	r0, r0, lsl #3
 80016f4:	1ac3      	subs	r3, r0, r3
 80016f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80016fa:	b2d8      	uxtb	r0, r3
 80016fc:	7ffb      	ldrb	r3, [r7, #31]
 80016fe:	461c      	mov	r4, r3
 8001700:	ea4f 0444 	mov.w	r4, r4, lsl #1
 8001704:	18e3      	adds	r3, r4, r3
 8001706:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800170a:	b2db      	uxtb	r3, r3
 800170c:	18c3      	adds	r3, r0, r3
 800170e:	b2db      	uxtb	r3, r3
 8001710:	18cb      	adds	r3, r1, r3
 8001712:	b2db      	uxtb	r3, r3
 8001714:	18d3      	adds	r3, r2, r3
 8001716:	773b      	strb	r3, [r7, #28]
		   
		/* prepare data to be inserted in html */
		*pcInsert		= (char)(Digit1+0x30);
 8001718:	7ffb      	ldrb	r3, [r7, #31]
 800171a:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800171e:	b2da      	uxtb	r2, r3
 8001720:	68bb      	ldr	r3, [r7, #8]
 8001722:	701a      	strb	r2, [r3, #0]
		*(pcInsert + 1) = (char)(Digit2+0x30);
 8001724:	68bb      	ldr	r3, [r7, #8]
 8001726:	f103 0301 	add.w	r3, r3, #1
 800172a:	7fba      	ldrb	r2, [r7, #30]
 800172c:	f102 0230 	add.w	r2, r2, #48	; 0x30
 8001730:	b2d2      	uxtb	r2, r2
 8001732:	701a      	strb	r2, [r3, #0]
		*(pcInsert + 2) = (char)(Digit3+0x30);
 8001734:	68bb      	ldr	r3, [r7, #8]
 8001736:	f103 0302 	add.w	r3, r3, #2
 800173a:	7f7a      	ldrb	r2, [r7, #29]
 800173c:	f102 0230 	add.w	r2, r2, #48	; 0x30
 8001740:	b2d2      	uxtb	r2, r2
 8001742:	701a      	strb	r2, [r3, #0]
		*(pcInsert + 3) = (char)(Digit4+0x30);
 8001744:	68bb      	ldr	r3, [r7, #8]
 8001746:	f103 0303 	add.w	r3, r3, #3
 800174a:	7f3a      	ldrb	r2, [r7, #28]
 800174c:	f102 0230 	add.w	r2, r2, #48	; 0x30
 8001750:	b2d2      	uxtb	r2, r2
 8001752:	701a      	strb	r2, [r3, #0]
	   
	   /* 4 characters need to be inserted in html*/
	   return 4;
 8001754:	f04f 0304 	mov.w	r3, #4
 8001758:	e01d      	b.n	8001796 <SSI_ADC_Handler+0x1b6>

	}

	if (iIndex == 1)
 800175a:	68fb      	ldr	r3, [r7, #12]
 800175c:	2b01      	cmp	r3, #1
 800175e:	d118      	bne.n	8001792 <SSI_ADC_Handler+0x1b2>
	{
		*pcInsert		= (char)'c';
 8001760:	68bb      	ldr	r3, [r7, #8]
 8001762:	f04f 0263 	mov.w	r2, #99	; 0x63
 8001766:	701a      	strb	r2, [r3, #0]
		*(pcInsert + 1) = (char)'a';
 8001768:	68bb      	ldr	r3, [r7, #8]
 800176a:	f103 0301 	add.w	r3, r3, #1
 800176e:	f04f 0261 	mov.w	r2, #97	; 0x61
 8001772:	701a      	strb	r2, [r3, #0]
		*(pcInsert + 2) = (char)'l';
 8001774:	68bb      	ldr	r3, [r7, #8]
 8001776:	f103 0302 	add.w	r3, r3, #2
 800177a:	f04f 026c 	mov.w	r2, #108	; 0x6c
 800177e:	701a      	strb	r2, [r3, #0]
		*(pcInsert + 3) = (char)'d';
 8001780:	68bb      	ldr	r3, [r7, #8]
 8001782:	f103 0303 	add.w	r3, r3, #3
 8001786:	f04f 0264 	mov.w	r2, #100	; 0x64
 800178a:	701a      	strb	r2, [r3, #0]

	   /* 4 characters need to be inserted in html*/
	   return 4;
 800178c:	f04f 0304 	mov.w	r3, #4
 8001790:	e001      	b.n	8001796 <SSI_ADC_Handler+0x1b6>
	}

		return 0;
 8001792:	f04f 0300 	mov.w	r3, #0
}
 8001796:	4618      	mov	r0, r3
 8001798:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800179c:	46bd      	mov	sp, r7
 800179e:	bd90      	pop	{r4, r7, pc}
 80017a0:	9999999a 	.word	0x9999999a
 80017a4:	3fe99999 	.word	0x3fe99999

080017a8 <http_SSI_init>:
char const* TAGCHAR2="u";
char const** TAGS= {&TAGCHAR, &TAGCHAR2};


void http_SSI_init (void)
{
 80017a8:	b580      	push	{r7, lr}
 80017aa:	af00      	add	r7, sp, #0
	SSI is a method used to dynamically include dynamic data in HTML code.
	This done by placing a specific tag inside the HTML code of the web page. The tag should
	have the following format: <!--#tag-->
	For the ADC conversion page, the following tag "t" is used inside the HTML code: <!--#t-->
	*/
	http_set_ssi_handler(SSI_ADC_Handler, (char const **)TAGS, 2);
 80017ac:	f246 635c 	movw	r3, #26204	; 0x665c
 80017b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017b4:	681b      	ldr	r3, [r3, #0]
 80017b6:	f241 50e1 	movw	r0, #5601	; 0x15e1
 80017ba:	f6c0 0000 	movt	r0, #2048	; 0x800
 80017be:	4619      	mov	r1, r3
 80017c0:	f04f 0202 	mov.w	r2, #2
 80017c4:	f001 fc48 	bl	8003058 <http_set_ssi_handler>
}
 80017c8:	bd80      	pop	{r7, pc}
 80017ca:	bf00      	nop

080017cc <USIC1_0_IRQHandler>:


DataQueueType receivedData;

void UART_ReceiveInterrupt(void)
{
 80017cc:	b580      	push	{r7, lr}
 80017ce:	f5ad 7d02 	sub.w	sp, sp, #520	; 0x208
 80017d2:	af00      	add	r7, sp, #0
	uint16_t au16tempBuffer[256];
	uint16_t u16numberOfReceivedBytes;
	uint16_t u16tempIndex;

	u16numberOfReceivedBytes = UART001_ReadDataMultiple(&UART001_Handle0, au16tempBuffer, QUEUE_MAX_SIZE);
 80017d4:	f107 0304 	add.w	r3, r7, #4
 80017d8:	f246 5058 	movw	r0, #25944	; 0x6558
 80017dc:	f6c0 0002 	movt	r0, #2050	; 0x802
 80017e0:	4619      	mov	r1, r3
 80017e2:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80017e6:	f002 f917 	bl	8003a18 <UART001_ReadDataMultiple>
 80017ea:	4603      	mov	r3, r0
 80017ec:	f8a7 3206 	strh.w	r3, [r7, #518]	; 0x206

	Queue_PutBuffer(&receivedData, au16tempBuffer, u16numberOfReceivedBytes);
 80017f0:	f8b7 3206 	ldrh.w	r3, [r7, #518]	; 0x206
 80017f4:	b2db      	uxtb	r3, r3
 80017f6:	f107 0204 	add.w	r2, r7, #4
 80017fa:	f645 30b8 	movw	r0, #23480	; 0x5bb8
 80017fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001802:	4611      	mov	r1, r2
 8001804:	461a      	mov	r2, r3
 8001806:	f7ff fd5f 	bl	80012c8 <Queue_PutBuffer>
}
 800180a:	f507 7702 	add.w	r7, r7, #520	; 0x208
 800180e:	46bd      	mov	sp, r7
 8001810:	bd80      	pop	{r7, pc}
 8001812:	bf00      	nop

08001814 <main>:

RoomInformationType roomInformation[NUMBER_OF_ROOMS];


int main(void)
{
 8001814:	b580      	push	{r7, lr}
 8001816:	b082      	sub	sp, #8
 8001818:	af00      	add	r7, sp, #0
	char Data[] = {'a','b','c'};
 800181a:	f245 731c 	movw	r3, #22300	; 0x571c
 800181e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8001822:	f107 0204 	add.w	r2, r7, #4
 8001826:	8819      	ldrh	r1, [r3, #0]
 8001828:	789b      	ldrb	r3, [r3, #2]
 800182a:	8011      	strh	r1, [r2, #0]
 800182c:	7093      	strb	r3, [r2, #2]
	uint8_t k = 0;
 800182e:	f04f 0300 	mov.w	r3, #0
 8001832:	71fb      	strb	r3, [r7, #7]
 	DAVE_Init();			// Initialization of DAVE Apps
 8001834:	f01d f950 	bl	801ead8 <DAVE_Init>

	ADC002_InitializeQueue((ADC002_HandleType*)&ADC002_Handle0);
 8001838:	f646 00e4 	movw	r0, #26852	; 0x68e4
 800183c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001840:	f01f ffd8 	bl	80217f4 <ADC002_InitializeQueue>
    lwIPStack_init();
 8001844:	f010 fdc8 	bl	80123d8 <lwIPStack_init>
    http_CGI_init();
 8001848:	f7ff feb2 	bl	80015b0 <http_CGI_init>
    http_SSI_init();
 800184c:	f7ff ffac 	bl	80017a8 <http_SSI_init>

    Queue_Init(&receivedData);
 8001850:	f645 30b8 	movw	r0, #23480	; 0x5bb8
 8001854:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001858:	f7ff fc9a 	bl	8001190 <Queue_Init>
 800185c:	e000      	b.n	8001860 <main+0x4c>
			Queue_GetBuffer(&receivedData, Data, 3);
			UART001_WriteDataBytes(&UART001_Handle0, Data, 3);
			k = 1;
		}

	}
 800185e:	bf00      	nop

    Queue_Init(&receivedData);

	while(1)
	{
		if ((receivedData.u8usedSpace > 3))
 8001860:	f645 33b8 	movw	r3, #23480	; 0x5bb8
 8001864:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001868:	f893 3101 	ldrb.w	r3, [r3, #257]	; 0x101
 800186c:	2b03      	cmp	r3, #3
 800186e:	d9f6      	bls.n	800185e <main+0x4a>
		{
			Queue_GetBuffer(&receivedData, Data, 3);
 8001870:	f107 0304 	add.w	r3, r7, #4
 8001874:	f645 30b8 	movw	r0, #23480	; 0x5bb8
 8001878:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800187c:	4619      	mov	r1, r3
 800187e:	f04f 0203 	mov.w	r2, #3
 8001882:	f7ff fdc9 	bl	8001418 <Queue_GetBuffer>
			UART001_WriteDataBytes(&UART001_Handle0, Data, 3);
 8001886:	f107 0304 	add.w	r3, r7, #4
 800188a:	f246 5058 	movw	r0, #25944	; 0x6558
 800188e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001892:	4619      	mov	r1, r3
 8001894:	f04f 0203 	mov.w	r2, #3
 8001898:	f002 f986 	bl	8003ba8 <UART001_WriteDataBytes>
			k = 1;
 800189c:	f04f 0301 	mov.w	r3, #1
 80018a0:	71fb      	strb	r3, [r7, #7]
		}

	}
 80018a2:	e7dc      	b.n	800185e <main+0x4a>
/* ========================================================================= */
/*
 * File open
 */
__attribute__((weak)) int _open(const char *name, int flags, int mode)
{
 80018a4:	b480      	push	{r7}
 80018a6:	b085      	sub	sp, #20
 80018a8:	af00      	add	r7, sp, #0
 80018aa:	60f8      	str	r0, [r7, #12]
 80018ac:	60b9      	str	r1, [r7, #8]
 80018ae:	607a      	str	r2, [r7, #4]
 flags = flags;
 mode = mode;
 return -1;
 80018b0:	f04f 33ff 	mov.w	r3, #4294967295
}
 80018b4:	4618      	mov	r0, r3
 80018b6:	f107 0714 	add.w	r7, r7, #20
 80018ba:	46bd      	mov	sp, r7
 80018bc:	bc80      	pop	{r7}
 80018be:	4770      	bx	lr

/*
 * File position seek
 */
__attribute__((weak)) int _lseek(int file, int offset, int whence)
{
 80018c0:	b480      	push	{r7}
 80018c2:	b085      	sub	sp, #20
 80018c4:	af00      	add	r7, sp, #0
 80018c6:	60f8      	str	r0, [r7, #12]
 80018c8:	60b9      	str	r1, [r7, #8]
 80018ca:	607a      	str	r2, [r7, #4]
 file = file;
 offset = offset;
 whence = whence;
 return -1;
 80018cc:	f04f 33ff 	mov.w	r3, #4294967295
}
 80018d0:	4618      	mov	r0, r3
 80018d2:	f107 0714 	add.w	r7, r7, #20
 80018d6:	46bd      	mov	sp, r7
 80018d8:	bc80      	pop	{r7}
 80018da:	4770      	bx	lr

080018dc <_read>:

/*
 * File read
 */
__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80018dc:	b480      	push	{r7}
 80018de:	b085      	sub	sp, #20
 80018e0:	af00      	add	r7, sp, #0
 80018e2:	60f8      	str	r0, [r7, #12]
 80018e4:	60b9      	str	r1, [r7, #8]
 80018e6:	607a      	str	r2, [r7, #4]
 file = file;
 len  = len;
 return 0;
 80018e8:	f04f 0300 	mov.w	r3, #0
}
 80018ec:	4618      	mov	r0, r3
 80018ee:	f107 0714 	add.w	r7, r7, #20
 80018f2:	46bd      	mov	sp, r7
 80018f4:	bc80      	pop	{r7}
 80018f6:	4770      	bx	lr

080018f8 <_write>:

/*
 * File write
 */
__attribute__((weak)) int _write(int file, char *buf, int nbytes)
{
 80018f8:	b480      	push	{r7}
 80018fa:	b085      	sub	sp, #20
 80018fc:	af00      	add	r7, sp, #0
 80018fe:	60f8      	str	r0, [r7, #12]
 8001900:	60b9      	str	r1, [r7, #8]
 8001902:	607a      	str	r2, [r7, #4]
 return -1;
 8001904:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001908:	4618      	mov	r0, r3
 800190a:	f107 0714 	add.w	r7, r7, #20
 800190e:	46bd      	mov	sp, r7
 8001910:	bc80      	pop	{r7}
 8001912:	4770      	bx	lr

/*
 * File close
 */
__attribute__((weak)) int _close(void)
{
 8001914:	b480      	push	{r7}
 8001916:	af00      	add	r7, sp, #0
 return -1;
 8001918:	f04f 33ff 	mov.w	r3, #4294967295
}
 800191c:	4618      	mov	r0, r3
 800191e:	46bd      	mov	sp, r7
 8001920:	bc80      	pop	{r7}
 8001922:	4770      	bx	lr

/*
 * File status
 */
__attribute__((weak)) int _fstat(int file, struct stat *st)
{
 8001924:	b480      	push	{r7}
 8001926:	b083      	sub	sp, #12
 8001928:	af00      	add	r7, sp, #0
 800192a:	6078      	str	r0, [r7, #4]
 800192c:	6039      	str	r1, [r7, #0]
 file = file;
 if(st)
 800192e:	683b      	ldr	r3, [r7, #0]
 8001930:	2b00      	cmp	r3, #0
 8001932:	d002      	beq.n	800193a <_write+0x42>
  return -1;
 8001934:	f04f 33ff 	mov.w	r3, #4294967295
 8001938:	e001      	b.n	800193e <_write+0x46>
 else
  return -2;
 800193a:	f06f 0301 	mvn.w	r3, #1
}
 800193e:	4618      	mov	r0, r3
 8001940:	f107 070c 	add.w	r7, r7, #12
 8001944:	46bd      	mov	sp, r7
 8001946:	bc80      	pop	{r7}
 8001948:	4770      	bx	lr
 800194a:	bf00      	nop
/*
 * File linking
 */
__attribute__((weak)) int _link (char *old, char *new)
{
 800194c:	b480      	push	{r7}
 800194e:	b083      	sub	sp, #12
 8001950:	af00      	add	r7, sp, #0
 8001952:	6078      	str	r0, [r7, #4]
 8001954:	6039      	str	r1, [r7, #0]
 if (old == new)
 8001956:	687a      	ldr	r2, [r7, #4]
 8001958:	683b      	ldr	r3, [r7, #0]
 800195a:	429a      	cmp	r2, r3
 800195c:	d102      	bne.n	8001964 <_write+0x6c>
  return -1;
 800195e:	f04f 33ff 	mov.w	r3, #4294967295
 8001962:	e001      	b.n	8001968 <_write+0x70>
 else
  return -2;
 8001964:	f06f 0301 	mvn.w	r3, #1
}
 8001968:	4618      	mov	r0, r3
 800196a:	f107 070c 	add.w	r7, r7, #12
 800196e:	46bd      	mov	sp, r7
 8001970:	bc80      	pop	{r7}
 8001972:	4770      	bx	lr

/*
 * Unlinking directory entry
 */
__attribute__((weak)) int _unlink(char *name)
{
 8001974:	b480      	push	{r7}
 8001976:	b083      	sub	sp, #12
 8001978:	af00      	add	r7, sp, #0
 800197a:	6078      	str	r0, [r7, #4]
 return -1;
 800197c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001980:	4618      	mov	r0, r3
 8001982:	f107 070c 	add.w	r7, r7, #12
 8001986:	46bd      	mov	sp, r7
 8001988:	bc80      	pop	{r7}
 800198a:	4770      	bx	lr

0800198c <_sbrk>:
/* ========================================================================= */
/*
 * Heap break (position)
 */
__attribute__((weak)) void *_sbrk(int RequestedSize)
{
 800198c:	b480      	push	{r7}
 800198e:	b087      	sub	sp, #28
 8001990:	af00      	add	r7, sp, #0
 8001992:	6078      	str	r0, [r7, #4]
 unsigned int  HeapSize;
 static unsigned char *HeapBound;
 static unsigned char * heap= (unsigned char *)NULL;


 HeapSize   = (unsigned int)(&Heap_Bank1_Size);
 8001994:	f249 4330 	movw	r3, #37936	; 0x9430
 8001998:	f2c0 0300 	movt	r3, #0
 800199c:	617b      	str	r3, [r7, #20]

 /*
  * If this is the first time malloc() was invoked, we start with the
  * begining of the heap.
  */
 if(heap == (unsigned char *)NULL)
 800199e:	f640 0304 	movw	r3, #2052	; 0x804
 80019a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019a6:	681b      	ldr	r3, [r3, #0]
 80019a8:	2b00      	cmp	r3, #0
 80019aa:	d114      	bne.n	80019d6 <_sbrk+0x4a>
  {
   heap = (unsigned char *)&Heap_Bank1_Start;
 80019ac:	f640 0304 	movw	r3, #2052	; 0x804
 80019b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019b4:	f646 32d0 	movw	r2, #27600	; 0x6bd0
 80019b8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80019bc:	601a      	str	r2, [r3, #0]
   HeapBound  = (unsigned char *) (heap + HeapSize);
 80019be:	f640 0304 	movw	r3, #2052	; 0x804
 80019c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019c6:	681a      	ldr	r2, [r3, #0]
 80019c8:	697b      	ldr	r3, [r7, #20]
 80019ca:	18d2      	adds	r2, r2, r3
 80019cc:	f640 0308 	movw	r3, #2056	; 0x808
 80019d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019d4:	601a      	str	r2, [r3, #0]
  }

 /* Super duper algo to find out if we have memory for the latest request */
 /* Given conditions are: */
 /* 1. Latest break */
 CurrBreak = heap;
 80019d6:	f640 0304 	movw	r3, #2052	; 0x804
 80019da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019de:	681b      	ldr	r3, [r3, #0]
 80019e0:	613b      	str	r3, [r7, #16]

 /* And 2. Potential break based on requested size */
 NextBreak = (unsigned char *)( (((unsigned int)(heap)) + RequestedSize + 7)
 80019e2:	f640 0304 	movw	r3, #2052	; 0x804
 80019e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019ea:	681b      	ldr	r3, [r3, #0]
 80019ec:	461a      	mov	r2, r3
 80019ee:	687b      	ldr	r3, [r7, #4]
 80019f0:	18d3      	adds	r3, r2, r3
 80019f2:	f103 0307 	add.w	r3, r3, #7
                                          & 0xFFFFFFF8);
 80019f6:	f023 0307 	bic.w	r3, r3, #7
 /* Given conditions are: */
 /* 1. Latest break */
 CurrBreak = heap;

 /* And 2. Potential break based on requested size */
 NextBreak = (unsigned char *)( (((unsigned int)(heap)) + RequestedSize + 7)
 80019fa:	60fb      	str	r3, [r7, #12]
                                          & 0xFFFFFFF8);

 /* Return no memory condition if we sense we are crossing the limit */
 if (NextBreak >=  HeapBound )
 80019fc:	f640 0308 	movw	r3, #2056	; 0x808
 8001a00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a04:	681b      	ldr	r3, [r3, #0]
 8001a06:	68fa      	ldr	r2, [r7, #12]
 8001a08:	429a      	cmp	r2, r3
 8001a0a:	d302      	bcc.n	8001a12 <_sbrk+0x86>
  return ((unsigned char *)NULL);
 8001a0c:	f04f 0300 	mov.w	r3, #0
 8001a10:	e006      	b.n	8001a20 <_sbrk+0x94>
 else
 {
  heap = NextBreak;
 8001a12:	f640 0304 	movw	r3, #2052	; 0x804
 8001a16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a1a:	68fa      	ldr	r2, [r7, #12]
 8001a1c:	601a      	str	r2, [r3, #0]
  return CurrBreak;
 8001a1e:	693b      	ldr	r3, [r7, #16]
 }
}
 8001a20:	4618      	mov	r0, r3
 8001a22:	f107 071c 	add.w	r7, r7, #28
 8001a26:	46bd      	mov	sp, r7
 8001a28:	bc80      	pop	{r7}
 8001a2a:	4770      	bx	lr

08001a2c <_times>:
/* ========================================================================= */
/*
 * Process timing information
 */
__attribute__((weak)) int _times(struct tms *buf)
{
 8001a2c:	b480      	push	{r7}
 8001a2e:	b083      	sub	sp, #12
 8001a30:	af00      	add	r7, sp, #0
 8001a32:	6078      	str	r0, [r7, #4]
 return -1;
 8001a34:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001a38:	4618      	mov	r0, r3
 8001a3a:	f107 070c 	add.w	r7, r7, #12
 8001a3e:	46bd      	mov	sp, r7
 8001a40:	bc80      	pop	{r7}
 8001a42:	4770      	bx	lr

08001a44 <_wait>:
/*
 * Waiting for a child process to complete
 */
__attribute__((weak)) int _wait(int *status)
{
 8001a44:	b480      	push	{r7}
 8001a46:	b083      	sub	sp, #12
 8001a48:	af00      	add	r7, sp, #0
 8001a4a:	6078      	str	r0, [r7, #4]
 return -1;
 8001a4c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001a50:	4618      	mov	r0, r3
 8001a52:	f107 070c 	add.w	r7, r7, #12
 8001a56:	46bd      	mov	sp, r7
 8001a58:	bc80      	pop	{r7}
 8001a5a:	4770      	bx	lr

08001a5c <_kill>:

/*
 * Kill a process
 */
__attribute__((weak)) int _kill(int pid,int sig)
{
 8001a5c:	b480      	push	{r7}
 8001a5e:	b083      	sub	sp, #12
 8001a60:	af00      	add	r7, sp, #0
 8001a62:	6078      	str	r0, [r7, #4]
 8001a64:	6039      	str	r1, [r7, #0]
 pid = pid;
 sig = sig;
 return -1;
 8001a66:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001a6a:	4618      	mov	r0, r3
 8001a6c:	f107 070c 	add.w	r7, r7, #12
 8001a70:	46bd      	mov	sp, r7
 8001a72:	bc80      	pop	{r7}
 8001a74:	4770      	bx	lr
 8001a76:	bf00      	nop

08001a78 <_fork>:

/*
 * Forking a child process
 */
__attribute__((weak)) int _fork(void)
{
 8001a78:	b480      	push	{r7}
 8001a7a:	af00      	add	r7, sp, #0
 return -1;
 8001a7c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001a80:	4618      	mov	r0, r3
 8001a82:	46bd      	mov	sp, r7
 8001a84:	bc80      	pop	{r7}
 8001a86:	4770      	bx	lr

08001a88 <_getpid>:

/*
 * Process ID
 */
__attribute__((weak)) int _getpid(void)
{
 8001a88:	b480      	push	{r7}
 8001a8a:	af00      	add	r7, sp, #0
 return -1;
 8001a8c:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001a90:	4618      	mov	r0, r3
 8001a92:	46bd      	mov	sp, r7
 8001a94:	bc80      	pop	{r7}
 8001a96:	4770      	bx	lr

08001a98 <_exit>:

/*
 * Program/process exit
 */
__attribute__((weak)) void _exit(int rc)
{
 8001a98:	b480      	push	{r7}
 8001a9a:	b083      	sub	sp, #12
 8001a9c:	af00      	add	r7, sp, #0
 8001a9e:	6078      	str	r0, [r7, #4]
 rc = rc;
 while(1){}
 8001aa0:	e7fe      	b.n	8001aa0 <_exit+0x8>
 8001aa2:	bf00      	nop

08001aa4 <_init>:
}

/* Init */
__attribute__((weak)) void _init(void)
{}
 8001aa4:	b480      	push	{r7}
 8001aa6:	af00      	add	r7, sp, #0
 8001aa8:	46bd      	mov	sp, r7
 8001aaa:	bc80      	pop	{r7}
 8001aac:	4770      	bx	lr
 8001aae:	bf00      	nop

/*
 * Terminal type evaluation
 */
__attribute__((weak)) int _isatty(int file)
{
 8001ab0:	b480      	push	{r7}
 8001ab2:	b083      	sub	sp, #12
 8001ab4:	af00      	add	r7, sp, #0
 8001ab6:	6078      	str	r0, [r7, #4]
 file = file;
 return -1;
 8001ab8:	f04f 33ff 	mov.w	r3, #4294967295
}
 8001abc:	4618      	mov	r0, r3
 8001abe:	f107 070c 	add.w	r7, r7, #12
 8001ac2:	46bd      	mov	sp, r7
 8001ac4:	bc80      	pop	{r7}
 8001ac6:	4770      	bx	lr

08001ac8 <fs_malloc>:
#endif /* LWIP_HTTPD_CUSTOM_FILES */

/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
 8001ac8:	b480      	push	{r7}
 8001aca:	b083      	sub	sp, #12
 8001acc:	af00      	add	r7, sp, #0
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8001ace:	f04f 0300 	mov.w	r3, #0
 8001ad2:	607b      	str	r3, [r7, #4]
 8001ad4:	e032      	b.n	8001b3c <fs_malloc+0x74>
    if(fs_memory[i].inuse == 0) {
 8001ad6:	f645 42d8 	movw	r2, #23768	; 0x5cd8
 8001ada:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001ade:	6879      	ldr	r1, [r7, #4]
 8001ae0:	460b      	mov	r3, r1
 8001ae2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8001ae6:	1a5b      	subs	r3, r3, r1
 8001ae8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001aec:	18d3      	adds	r3, r2, r3
 8001aee:	f103 0318 	add.w	r3, r3, #24
 8001af2:	781b      	ldrb	r3, [r3, #0]
 8001af4:	2b00      	cmp	r3, #0
 8001af6:	d11d      	bne.n	8001b34 <fs_malloc+0x6c>
      fs_memory[i].inuse = 1;
 8001af8:	f645 42d8 	movw	r2, #23768	; 0x5cd8
 8001afc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001b00:	6879      	ldr	r1, [r7, #4]
 8001b02:	460b      	mov	r3, r1
 8001b04:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8001b08:	1a5b      	subs	r3, r3, r1
 8001b0a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001b0e:	18d3      	adds	r3, r2, r3
 8001b10:	f103 0318 	add.w	r3, r3, #24
 8001b14:	f04f 0201 	mov.w	r2, #1
 8001b18:	701a      	strb	r2, [r3, #0]
      return(&fs_memory[i].file);
 8001b1a:	687a      	ldr	r2, [r7, #4]
 8001b1c:	4613      	mov	r3, r2
 8001b1e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8001b22:	1a9b      	subs	r3, r3, r2
 8001b24:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001b28:	f645 42d8 	movw	r2, #23768	; 0x5cd8
 8001b2c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001b30:	189b      	adds	r3, r3, r2
 8001b32:	e008      	b.n	8001b46 <fs_malloc+0x7e>
/*-----------------------------------------------------------------------------------*/
static struct fs_file *
fs_malloc(void)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8001b34:	687b      	ldr	r3, [r7, #4]
 8001b36:	f103 0301 	add.w	r3, r3, #1
 8001b3a:	607b      	str	r3, [r7, #4]
 8001b3c:	687b      	ldr	r3, [r7, #4]
 8001b3e:	2b09      	cmp	r3, #9
 8001b40:	ddc9      	ble.n	8001ad6 <fs_malloc+0xe>
    if(fs_memory[i].inuse == 0) {
      fs_memory[i].inuse = 1;
      return(&fs_memory[i].file);
    }
  }
  return(NULL);
 8001b42:	f04f 0300 	mov.w	r3, #0
}
 8001b46:	4618      	mov	r0, r3
 8001b48:	f107 070c 	add.w	r7, r7, #12
 8001b4c:	46bd      	mov	sp, r7
 8001b4e:	bc80      	pop	{r7}
 8001b50:	4770      	bx	lr
 8001b52:	bf00      	nop

08001b54 <fs_free>:

/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
 8001b54:	b480      	push	{r7}
 8001b56:	b085      	sub	sp, #20
 8001b58:	af00      	add	r7, sp, #0
 8001b5a:	6078      	str	r0, [r7, #4]
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8001b5c:	f04f 0300 	mov.w	r3, #0
 8001b60:	60fb      	str	r3, [r7, #12]
 8001b62:	e026      	b.n	8001bb2 <fs_free+0x5e>
    if(&fs_memory[i].file == file) {
 8001b64:	68fa      	ldr	r2, [r7, #12]
 8001b66:	4613      	mov	r3, r2
 8001b68:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8001b6c:	1a9b      	subs	r3, r3, r2
 8001b6e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001b72:	f645 42d8 	movw	r2, #23768	; 0x5cd8
 8001b76:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001b7a:	189a      	adds	r2, r3, r2
 8001b7c:	687b      	ldr	r3, [r7, #4]
 8001b7e:	429a      	cmp	r2, r3
 8001b80:	d113      	bne.n	8001baa <fs_free+0x56>
      fs_memory[i].inuse = 0;
 8001b82:	f645 42d8 	movw	r2, #23768	; 0x5cd8
 8001b86:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001b8a:	68f9      	ldr	r1, [r7, #12]
 8001b8c:	460b      	mov	r3, r1
 8001b8e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8001b92:	1a5b      	subs	r3, r3, r1
 8001b94:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001b98:	18d3      	adds	r3, r2, r3
 8001b9a:	f103 0318 	add.w	r3, r3, #24
 8001b9e:	f04f 0200 	mov.w	r2, #0
 8001ba2:	701a      	strb	r2, [r3, #0]
      break;
 8001ba4:	bf00      	nop
    }
  }
  return;
 8001ba6:	bf00      	nop
 8001ba8:	e006      	b.n	8001bb8 <fs_free+0x64>
/*-----------------------------------------------------------------------------------*/
static void
fs_free(struct fs_file *file)
{
  int i;
  for(i = 0; i < LWIP_MAX_OPEN_FILES; i++) {
 8001baa:	68fb      	ldr	r3, [r7, #12]
 8001bac:	f103 0301 	add.w	r3, r3, #1
 8001bb0:	60fb      	str	r3, [r7, #12]
 8001bb2:	68fb      	ldr	r3, [r7, #12]
 8001bb4:	2b09      	cmp	r3, #9
 8001bb6:	ddd5      	ble.n	8001b64 <fs_free+0x10>
    if(&fs_memory[i].file == file) {
      fs_memory[i].inuse = 0;
      break;
    }
  }
  return;
 8001bb8:	bf00      	nop
}
 8001bba:	f107 0714 	add.w	r7, r7, #20
 8001bbe:	46bd      	mov	sp, r7
 8001bc0:	bc80      	pop	{r7}
 8001bc2:	4770      	bx	lr

08001bc4 <fs_open>:

/*-----------------------------------------------------------------------------------*/
struct fs_file *
fs_open(const char *name)
{
 8001bc4:	b580      	push	{r7, lr}
 8001bc6:	b092      	sub	sp, #72	; 0x48
 8001bc8:	af00      	add	r7, sp, #0
 8001bca:	6078      	str	r0, [r7, #4]
#else
  const struct fsdata_file *f;
#endif
  struct fs_file *file;

  file = fs_malloc();
 8001bcc:	f7ff ff7c 	bl	8001ac8 <fs_malloc>
 8001bd0:	6478      	str	r0, [r7, #68]	; 0x44
  if(file == NULL) {
 8001bd2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001bd4:	2b00      	cmp	r3, #0
 8001bd6:	d102      	bne.n	8001bde <fs_open+0x1a>
    return NULL;
 8001bd8:	f04f 0300 	mov.w	r3, #0
 8001bdc:	e029      	b.n	8001c32 <fs_open+0x6e>
    return file;
  }
  file->is_custom_file = 0;
#endif /* LWIP_HTTPD_CUSTOM_FILES */
#if  HTTPD_FAT_FS
    file->fatFS_File =  fopen(name, "r");
 8001bde:	6878      	ldr	r0, [r7, #4]
 8001be0:	f246 4118 	movw	r1, #25624	; 0x6418
 8001be4:	f6c0 0102 	movt	r1, #2050	; 0x802
 8001be8:	f021 f8fc 	bl	8022de4 <fopen>
 8001bec:	4602      	mov	r2, r0
 8001bee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001bf0:	615a      	str	r2, [r3, #20]
    if(NULL != file->fatFS_File)
 8001bf2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001bf4:	695b      	ldr	r3, [r3, #20]
 8001bf6:	2b00      	cmp	r3, #0
 8001bf8:	d016      	beq.n	8001c28 <fs_open+0x64>
    {
      stat(name,&fileStat);
 8001bfa:	f107 0308 	add.w	r3, r7, #8
 8001bfe:	6878      	ldr	r0, [r7, #4]
 8001c00:	4619      	mov	r1, r3
 8001c02:	f023 fbbf 	bl	8025384 <stat>

      file->len = fileStat.st_size;
 8001c06:	69ba      	ldr	r2, [r7, #24]
 8001c08:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001c0a:	605a      	str	r2, [r3, #4]
      file->index = 0;
 8001c0c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001c0e:	f04f 0200 	mov.w	r2, #0
 8001c12:	609a      	str	r2, [r3, #8]
    	  file->pextension = NULL;
 8001c14:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001c16:	f04f 0200 	mov.w	r2, #0
 8001c1a:	60da      	str	r2, [r3, #12]
    	  file->http_header_included = 1;
 8001c1c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001c1e:	f04f 0201 	mov.w	r2, #1
 8001c22:	741a      	strb	r2, [r3, #16]
    	  return file;
 8001c24:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001c26:	e004      	b.n	8001c32 <fs_open+0x6e>
      }
    else
    {
      fs_free(file);
 8001c28:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8001c2a:	f7ff ff93 	bl	8001b54 <fs_free>
      return NULL;
 8001c2e:	f04f 0300 	mov.w	r3, #0
    }
  }
#endif
  fs_free(file);
  return NULL;
}
 8001c32:	4618      	mov	r0, r3
 8001c34:	f107 0748 	add.w	r7, r7, #72	; 0x48
 8001c38:	46bd      	mov	sp, r7
 8001c3a:	bd80      	pop	{r7, pc}

08001c3c <fs_close>:

/*-----------------------------------------------------------------------------------*/
void
fs_close(struct fs_file *file)
{
 8001c3c:	b580      	push	{r7, lr}
 8001c3e:	b082      	sub	sp, #8
 8001c40:	af00      	add	r7, sp, #0
 8001c42:	6078      	str	r0, [r7, #4]
#endif /* LWIP_HTTPD_CUSTOM_FILES */
#if LWIP_HTTPD_FILE_STATE
  fs_state_free(file, file->state);
#endif /* #if LWIP_HTTPD_FILE_STATE */
#if HTTPD_FAT_FS
 fclose (file->fatFS_File);
 8001c44:	687b      	ldr	r3, [r7, #4]
 8001c46:	695b      	ldr	r3, [r3, #20]
 8001c48:	4618      	mov	r0, r3
 8001c4a:	f020 fed1 	bl	80229f0 <fclose>

#endif
  fs_free(file);
 8001c4e:	6878      	ldr	r0, [r7, #4]
 8001c50:	f7ff ff80 	bl	8001b54 <fs_free>
}
 8001c54:	f107 0708 	add.w	r7, r7, #8
 8001c58:	46bd      	mov	sp, r7
 8001c5a:	bd80      	pop	{r7, pc}

08001c5c <fs_read>:
/*-----------------------------------------------------------------------------------*/
int
fs_read(struct fs_file *file, char *buffer, int count)
{
 8001c5c:	b580      	push	{r7, lr}
 8001c5e:	b086      	sub	sp, #24
 8001c60:	af00      	add	r7, sp, #0
 8001c62:	60f8      	str	r0, [r7, #12]
 8001c64:	60b9      	str	r1, [r7, #8]
 8001c66:	607a      	str	r2, [r7, #4]

#if HTTPD_FAT_FS
	int result;
	result=fread(buffer,1,count,file->fatFS_File);
 8001c68:	687a      	ldr	r2, [r7, #4]
 8001c6a:	68fb      	ldr	r3, [r7, #12]
 8001c6c:	695b      	ldr	r3, [r3, #20]
 8001c6e:	68b8      	ldr	r0, [r7, #8]
 8001c70:	f04f 0101 	mov.w	r1, #1
 8001c74:	f021 f994 	bl	8022fa0 <fread>
 8001c78:	4603      	mov	r3, r0
 8001c7a:	617b      	str	r3, [r7, #20]
	if (result <=0) {
 8001c7c:	697b      	ldr	r3, [r7, #20]
 8001c7e:	2b00      	cmp	r3, #0
 8001c80:	dc02      	bgt.n	8001c88 <fs_read+0x2c>
		return -1;
 8001c82:	f04f 33ff 	mov.w	r3, #4294967295
 8001c86:	e006      	b.n	8001c96 <fs_read+0x3a>
	}
	else {
		file->index += result;
 8001c88:	68fb      	ldr	r3, [r7, #12]
 8001c8a:	689a      	ldr	r2, [r3, #8]
 8001c8c:	697b      	ldr	r3, [r7, #20]
 8001c8e:	18d2      	adds	r2, r2, r3
 8001c90:	68fb      	ldr	r3, [r7, #12]
 8001c92:	609a      	str	r2, [r3, #8]
		return result;
 8001c94:	697b      	ldr	r3, [r7, #20]
  MEMCPY(buffer, (file->data + file->index), read);
  file->index += read;

  return(read);
#endif
}
 8001c96:	4618      	mov	r0, r3
 8001c98:	f107 0718 	add.w	r7, r7, #24
 8001c9c:	46bd      	mov	sp, r7
 8001c9e:	bd80      	pop	{r7, pc}

08001ca0 <fs_bytes_left>:
/*-----------------------------------------------------------------------------------*/
int fs_bytes_left(struct fs_file *file)
{
 8001ca0:	b480      	push	{r7}
 8001ca2:	b083      	sub	sp, #12
 8001ca4:	af00      	add	r7, sp, #0
 8001ca6:	6078      	str	r0, [r7, #4]
  return file->len - file->index;
 8001ca8:	687b      	ldr	r3, [r7, #4]
 8001caa:	685a      	ldr	r2, [r3, #4]
 8001cac:	687b      	ldr	r3, [r7, #4]
 8001cae:	689b      	ldr	r3, [r3, #8]
 8001cb0:	1ad3      	subs	r3, r2, r3
}
 8001cb2:	4618      	mov	r0, r3
 8001cb4:	f107 070c 	add.w	r7, r7, #12
 8001cb8:	46bd      	mov	sp, r7
 8001cba:	bc80      	pop	{r7}
 8001cbc:	4770      	bx	lr
 8001cbe:	bf00      	nop

08001cc0 <strnstr>:

#if LWIP_HTTPD_STRNSTR_PRIVATE
/** Like strstr but does not need 'buffer' to be NULL-terminated */
static char*
strnstr(const char* buffer, const char* token, size_t n)
{
 8001cc0:	b580      	push	{r7, lr}
 8001cc2:	b086      	sub	sp, #24
 8001cc4:	af00      	add	r7, sp, #0
 8001cc6:	60f8      	str	r0, [r7, #12]
 8001cc8:	60b9      	str	r1, [r7, #8]
 8001cca:	607a      	str	r2, [r7, #4]
  const char* p;
  int tokenlen = (int)strlen(token);
 8001ccc:	68b8      	ldr	r0, [r7, #8]
 8001cce:	f022 ff37 	bl	8024b40 <strlen>
 8001cd2:	4603      	mov	r3, r0
 8001cd4:	613b      	str	r3, [r7, #16]
  if (tokenlen == 0) {
 8001cd6:	693b      	ldr	r3, [r7, #16]
 8001cd8:	2b00      	cmp	r3, #0
 8001cda:	d101      	bne.n	8001ce0 <strnstr+0x20>
    return (char *)buffer;
 8001cdc:	68fb      	ldr	r3, [r7, #12]
 8001cde:	e025      	b.n	8001d2c <strnstr+0x6c>
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 8001ce0:	68fb      	ldr	r3, [r7, #12]
 8001ce2:	617b      	str	r3, [r7, #20]
 8001ce4:	e014      	b.n	8001d10 <strnstr+0x50>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
 8001ce6:	697b      	ldr	r3, [r7, #20]
 8001ce8:	781a      	ldrb	r2, [r3, #0]
 8001cea:	68bb      	ldr	r3, [r7, #8]
 8001cec:	781b      	ldrb	r3, [r3, #0]
 8001cee:	429a      	cmp	r2, r3
 8001cf0:	d10a      	bne.n	8001d08 <strnstr+0x48>
 8001cf2:	693b      	ldr	r3, [r7, #16]
 8001cf4:	6978      	ldr	r0, [r7, #20]
 8001cf6:	68b9      	ldr	r1, [r7, #8]
 8001cf8:	461a      	mov	r2, r3
 8001cfa:	f022 ff51 	bl	8024ba0 <strncmp>
 8001cfe:	4603      	mov	r3, r0
 8001d00:	2b00      	cmp	r3, #0
 8001d02:	d101      	bne.n	8001d08 <strnstr+0x48>
      return (char *)p;
 8001d04:	697b      	ldr	r3, [r7, #20]
 8001d06:	e011      	b.n	8001d2c <strnstr+0x6c>
  const char* p;
  int tokenlen = (int)strlen(token);
  if (tokenlen == 0) {
    return (char *)buffer;
  }
  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
 8001d08:	697b      	ldr	r3, [r7, #20]
 8001d0a:	f103 0301 	add.w	r3, r3, #1
 8001d0e:	617b      	str	r3, [r7, #20]
 8001d10:	697b      	ldr	r3, [r7, #20]
 8001d12:	781b      	ldrb	r3, [r3, #0]
 8001d14:	2b00      	cmp	r3, #0
 8001d16:	d007      	beq.n	8001d28 <strnstr+0x68>
 8001d18:	693b      	ldr	r3, [r7, #16]
 8001d1a:	697a      	ldr	r2, [r7, #20]
 8001d1c:	18d2      	adds	r2, r2, r3
 8001d1e:	68f9      	ldr	r1, [r7, #12]
 8001d20:	687b      	ldr	r3, [r7, #4]
 8001d22:	18cb      	adds	r3, r1, r3
 8001d24:	429a      	cmp	r2, r3
 8001d26:	d9de      	bls.n	8001ce6 <strnstr+0x26>
    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
      return (char *)p;
    }
  }
  return NULL;
 8001d28:	f04f 0300 	mov.w	r3, #0
} 
 8001d2c:	4618      	mov	r0, r3
 8001d2e:	f107 0718 	add.w	r7, r7, #24
 8001d32:	46bd      	mov	sp, r7
 8001d34:	bd80      	pop	{r7, pc}
 8001d36:	bf00      	nop

08001d38 <http_state_alloc>:
#endif /* LWIP_HTTPD_STRNSTR_PRIVATE */

/** Allocate a struct http_state. */
static struct http_state*
http_state_alloc(void)
{
 8001d38:	b580      	push	{r7, lr}
 8001d3a:	b082      	sub	sp, #8
 8001d3c:	af00      	add	r7, sp, #0
  struct http_state *ret;
#if HTTPD_USE_MEM_POOL
  ret = (struct http_state *)memp_malloc(MEMP_HTTPD_STATE);
#else /* HTTPD_USE_MEM_POOL */
  ret = (struct http_state *)mem_malloc(sizeof(struct http_state));
 8001d3e:	f44f 70be 	mov.w	r0, #380	; 0x17c
 8001d42:	f010 f9e5 	bl	8012110 <mem_malloc>
 8001d46:	6078      	str	r0, [r7, #4]
#endif /* HTTPD_USE_MEM_POOL */
  if (ret != NULL) {
 8001d48:	687b      	ldr	r3, [r7, #4]
 8001d4a:	2b00      	cmp	r3, #0
 8001d4c:	d006      	beq.n	8001d5c <http_state_alloc+0x24>
    /* Initialize the structure. */
    memset(ret, 0, sizeof(struct http_state));
 8001d4e:	6878      	ldr	r0, [r7, #4]
 8001d50:	f04f 0100 	mov.w	r1, #0
 8001d54:	f44f 72be 	mov.w	r2, #380	; 0x17c
 8001d58:	f021 fdca 	bl	80238f0 <memset>
#if LWIP_HTTPD_DYNAMIC_HEADERS
    /* Indicate that the headers are not yet valid */
    ret->hdr_index = NUM_FILE_HDR_STRINGS;
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
  }
  return ret;
 8001d5c:	687b      	ldr	r3, [r7, #4]
}
 8001d5e:	4618      	mov	r0, r3
 8001d60:	f107 0708 	add.w	r7, r7, #8
 8001d64:	46bd      	mov	sp, r7
 8001d66:	bd80      	pop	{r7, pc}

08001d68 <http_state_free>:
/** Free a struct http_state.
 * Also frees the file data if dynamic.
 */
static void
http_state_free(struct http_state *hs)
{
 8001d68:	b580      	push	{r7, lr}
 8001d6a:	b082      	sub	sp, #8
 8001d6c:	af00      	add	r7, sp, #0
 8001d6e:	6078      	str	r0, [r7, #4]
  if (hs != NULL) {
 8001d70:	687b      	ldr	r3, [r7, #4]
 8001d72:	2b00      	cmp	r3, #0
 8001d74:	d01c      	beq.n	8001db0 <http_state_free+0x48>
    if(hs->handle) {
 8001d76:	687b      	ldr	r3, [r7, #4]
 8001d78:	681b      	ldr	r3, [r3, #0]
 8001d7a:	2b00      	cmp	r3, #0
 8001d7c:	d008      	beq.n	8001d90 <http_state_free+0x28>
      u32_t ms_needed = sys_now() - hs->time_started;
      u32_t needed = LWIP_MAX(1, (ms_needed/100));
      LWIP_DEBUGF(HTTPD_DEBUG_TIMING, ("httpd: needed %"U32_F" ms to send file of %d bytes -> %"U32_F" bytes/sec\n",
        ms_needed, hs->handle->len, ((((u32_t)hs->handle->len) * 10) / needed)));
#endif /* LWIP_HTTPD_TIMING */
      fs_close(hs->handle);
 8001d7e:	687b      	ldr	r3, [r7, #4]
 8001d80:	681b      	ldr	r3, [r3, #0]
 8001d82:	4618      	mov	r0, r3
 8001d84:	f7ff ff5a 	bl	8001c3c <fs_close>
      hs->handle = NULL;
 8001d88:	687b      	ldr	r3, [r7, #4]
 8001d8a:	f04f 0200 	mov.w	r2, #0
 8001d8e:	601a      	str	r2, [r3, #0]
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    if (hs->buf != NULL) {
 8001d90:	687b      	ldr	r3, [r7, #4]
 8001d92:	68db      	ldr	r3, [r3, #12]
 8001d94:	2b00      	cmp	r3, #0
 8001d96:	d008      	beq.n	8001daa <http_state_free+0x42>
      mem_free(hs->buf);
 8001d98:	687b      	ldr	r3, [r7, #4]
 8001d9a:	68db      	ldr	r3, [r3, #12]
 8001d9c:	4618      	mov	r0, r3
 8001d9e:	f010 f88b 	bl	8011eb8 <mem_free>
      hs->buf = NULL;
 8001da2:	687b      	ldr	r3, [r7, #4]
 8001da4:	f04f 0200 	mov.w	r2, #0
 8001da8:	60da      	str	r2, [r3, #12]
    }
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
#if HTTPD_USE_MEM_POOL
    memp_free(MEMP_HTTPD_STATE, hs);
#else /* HTTPD_USE_MEM_POOL */
    mem_free(hs);
 8001daa:	6878      	ldr	r0, [r7, #4]
 8001dac:	f010 f884 	bl	8011eb8 <mem_free>
#endif /* HTTPD_USE_MEM_POOL */
  }
}
 8001db0:	f107 0708 	add.w	r7, r7, #8
 8001db4:	46bd      	mov	sp, r7
 8001db6:	bd80      	pop	{r7, pc}

08001db8 <http_write>:
 * @param apiflags directly passed to tcp_write
 * @return the return value of tcp_write
 */
static err_t
http_write(struct tcp_pcb *pcb, const void* ptr, u16_t *length, u8_t apiflags)
{
 8001db8:	b580      	push	{r7, lr}
 8001dba:	b086      	sub	sp, #24
 8001dbc:	af00      	add	r7, sp, #0
 8001dbe:	60f8      	str	r0, [r7, #12]
 8001dc0:	60b9      	str	r1, [r7, #8]
 8001dc2:	607a      	str	r2, [r7, #4]
 8001dc4:	70fb      	strb	r3, [r7, #3]
   u16_t len;
   err_t err;
   LWIP_ASSERT("length != NULL", length != NULL);
   len = *length;
 8001dc6:	687b      	ldr	r3, [r7, #4]
 8001dc8:	881b      	ldrh	r3, [r3, #0]
 8001dca:	82fb      	strh	r3, [r7, #22]
   do {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Trying go send %d bytes\n", len));
     err = tcp_write(pcb, ptr, len, apiflags);
 8001dcc:	8afa      	ldrh	r2, [r7, #22]
 8001dce:	78fb      	ldrb	r3, [r7, #3]
 8001dd0:	68f8      	ldr	r0, [r7, #12]
 8001dd2:	68b9      	ldr	r1, [r7, #8]
 8001dd4:	f014 fec2 	bl	8016b5c <tcp_write>
 8001dd8:	4603      	mov	r3, r0
 8001dda:	757b      	strb	r3, [r7, #21]
     if (err == ERR_MEM) {
 8001ddc:	f997 3015 	ldrsb.w	r3, [r7, #21]
 8001de0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001de4:	d10c      	bne.n	8001e00 <http_write+0x48>
       if ((tcp_sndbuf(pcb) == 0))// ||            (tcp_sndqueuelen(pcb) >= TCP_SND_QUEUELEN)) {
 8001de6:	68fb      	ldr	r3, [r7, #12]
 8001de8:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8001dec:	2b00      	cmp	r3, #0
 8001dee:	d103      	bne.n	8001df8 <http_write+0x40>
       {/* no need to try smaller sizes */
         len = 1;
 8001df0:	f04f 0301 	mov.w	r3, #1
 8001df4:	82fb      	strh	r3, [r7, #22]
 8001df6:	e003      	b.n	8001e00 <http_write+0x48>
       } else {
         len /= 2;
 8001df8:	8afb      	ldrh	r3, [r7, #22]
 8001dfa:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8001dfe:	82fb      	strh	r3, [r7, #22]
       }
       LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, 
                   ("Send failed, trying less (%d bytes)\n", len));
     }
   } while ((err == ERR_MEM) && (len > 1));
 8001e00:	f997 3015 	ldrsb.w	r3, [r7, #21]
 8001e04:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001e08:	d102      	bne.n	8001e10 <http_write+0x58>
 8001e0a:	8afb      	ldrh	r3, [r7, #22]
 8001e0c:	2b01      	cmp	r3, #1
 8001e0e:	d8dd      	bhi.n	8001dcc <http_write+0x14>
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Sent %d bytes\n", len));
   } else {
     LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Send failed with err %d (\"%s\")\n", err, lwip_strerr(err)));
   }

   *length = len;
 8001e10:	687b      	ldr	r3, [r7, #4]
 8001e12:	8afa      	ldrh	r2, [r7, #22]
 8001e14:	801a      	strh	r2, [r3, #0]
   return err;
 8001e16:	7d7b      	ldrb	r3, [r7, #21]
 8001e18:	b25b      	sxtb	r3, r3
}
 8001e1a:	4618      	mov	r0, r3
 8001e1c:	f107 0718 	add.w	r7, r7, #24
 8001e20:	46bd      	mov	sp, r7
 8001e22:	bd80      	pop	{r7, pc}

08001e24 <http_close_conn>:
 * @param pcb the tcp pcb to reset callbacks
 * @param hs connection state to free
 */
static err_t
http_close_conn(struct tcp_pcb *pcb, struct http_state *hs)
{
 8001e24:	b580      	push	{r7, lr}
 8001e26:	b084      	sub	sp, #16
 8001e28:	af00      	add	r7, sp, #0
 8001e2a:	6078      	str	r0, [r7, #4]
 8001e2c:	6039      	str	r1, [r7, #0]
    }
  }
#endif /* LWIP_HTTPD_SUPPORT_POST*/


  tcp_arg(pcb, NULL);
 8001e2e:	6878      	ldr	r0, [r7, #4]
 8001e30:	f04f 0100 	mov.w	r1, #0
 8001e34:	f012 fd20 	bl	8014878 <tcp_arg>
  tcp_recv(pcb, NULL);
 8001e38:	6878      	ldr	r0, [r7, #4]
 8001e3a:	f04f 0100 	mov.w	r1, #0
 8001e3e:	f012 fd29 	bl	8014894 <tcp_recv>
  tcp_err(pcb, NULL);
 8001e42:	6878      	ldr	r0, [r7, #4]
 8001e44:	f04f 0100 	mov.w	r1, #0
 8001e48:	f012 fd40 	bl	80148cc <tcp_err>
  tcp_poll(pcb, NULL, 0);
 8001e4c:	6878      	ldr	r0, [r7, #4]
 8001e4e:	f04f 0100 	mov.w	r1, #0
 8001e52:	f04f 0200 	mov.w	r2, #0
 8001e56:	f012 fd55 	bl	8014904 <tcp_poll>
  tcp_sent(pcb, NULL);
 8001e5a:	6878      	ldr	r0, [r7, #4]
 8001e5c:	f04f 0100 	mov.w	r1, #0
 8001e60:	f012 fd26 	bl	80148b0 <tcp_sent>
  if(hs != NULL) {
 8001e64:	683b      	ldr	r3, [r7, #0]
 8001e66:	2b00      	cmp	r3, #0
 8001e68:	d002      	beq.n	8001e70 <http_close_conn+0x4c>
    http_state_free(hs);
 8001e6a:	6838      	ldr	r0, [r7, #0]
 8001e6c:	f7ff ff7c 	bl	8001d68 <http_state_free>
  }

  err = tcp_close(pcb);
 8001e70:	6878      	ldr	r0, [r7, #4]
 8001e72:	f011 fc35 	bl	80136e0 <tcp_close>
 8001e76:	4603      	mov	r3, r0
 8001e78:	73fb      	strb	r3, [r7, #15]
  if (err != ERR_OK) {
 8001e7a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8001e7e:	2b00      	cmp	r3, #0
 8001e80:	d008      	beq.n	8001e94 <http_close_conn+0x70>
    LWIP_DEBUGF(HTTPD_DEBUG, ("Error %d closing %p\n", err, (void*)pcb));
    /* error closing, try again later in poll */
    tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 8001e82:	6878      	ldr	r0, [r7, #4]
 8001e84:	f642 6111 	movw	r1, #11793	; 0x2e11
 8001e88:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001e8c:	f04f 0204 	mov.w	r2, #4
 8001e90:	f012 fd38 	bl	8014904 <tcp_poll>
  }
  return err;
 8001e94:	7bfb      	ldrb	r3, [r7, #15]
 8001e96:	b25b      	sxtb	r3, r3
}
 8001e98:	4618      	mov	r0, r3
 8001e9a:	f107 0710 	add.w	r7, r7, #16
 8001e9e:	46bd      	mov	sp, r7
 8001ea0:	bd80      	pop	{r7, pc}
 8001ea2:	bf00      	nop

08001ea4 <extract_uri_parameters>:
 * @param params pointer to the NULL-terminated parameter string from the URI
 * @return number of parameters extracted
 */
static int
extract_uri_parameters(struct http_state *hs, char *params)
{
 8001ea4:	b580      	push	{r7, lr}
 8001ea6:	b086      	sub	sp, #24
 8001ea8:	af00      	add	r7, sp, #0
 8001eaa:	6078      	str	r0, [r7, #4]
 8001eac:	6039      	str	r1, [r7, #0]
  char *pair;
  char *equals;
  int loop;

  /* If we have no parameters at all, return immediately. */
  if(!params || (params[0] == '\0')) {
 8001eae:	683b      	ldr	r3, [r7, #0]
 8001eb0:	2b00      	cmp	r3, #0
 8001eb2:	d003      	beq.n	8001ebc <extract_uri_parameters+0x18>
 8001eb4:	683b      	ldr	r3, [r7, #0]
 8001eb6:	781b      	ldrb	r3, [r3, #0]
 8001eb8:	2b00      	cmp	r3, #0
 8001eba:	d102      	bne.n	8001ec2 <extract_uri_parameters+0x1e>
      return(0);
 8001ebc:	f04f 0300 	mov.w	r3, #0
 8001ec0:	e060      	b.n	8001f84 <extract_uri_parameters+0xe0>
  }

  /* Get a pointer to our first parameter */
  pair = params;
 8001ec2:	683b      	ldr	r3, [r7, #0]
 8001ec4:	617b      	str	r3, [r7, #20]

  /* Parse up to LWIP_HTTPD_MAX_CGI_PARAMETERS from the passed string and ignore the
   * remainder (if any) */
  for(loop = 0; (loop < LWIP_HTTPD_MAX_CGI_PARAMETERS) && pair; loop++) {
 8001ec6:	f04f 0300 	mov.w	r3, #0
 8001eca:	613b      	str	r3, [r7, #16]
 8001ecc:	e053      	b.n	8001f76 <extract_uri_parameters+0xd2>

    /* Save the name of the parameter */
    hs->params[loop] = pair;
 8001ece:	687a      	ldr	r2, [r7, #4]
 8001ed0:	693b      	ldr	r3, [r7, #16]
 8001ed2:	f103 033e 	add.w	r3, r3, #62	; 0x3e
 8001ed6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001eda:	18d3      	adds	r3, r2, r3
 8001edc:	697a      	ldr	r2, [r7, #20]
 8001ede:	605a      	str	r2, [r3, #4]

    /* Remember the start of this name=value pair */
    equals = pair;
 8001ee0:	697b      	ldr	r3, [r7, #20]
 8001ee2:	60fb      	str	r3, [r7, #12]

    /* Find the start of the next name=value pair and replace the delimiter
     * with a 0 to terminate the previous pair string. */
    pair = strchr(pair, '&');
 8001ee4:	6978      	ldr	r0, [r7, #20]
 8001ee6:	f04f 0126 	mov.w	r1, #38	; 0x26
 8001eea:	f022 fc5f 	bl	80247ac <strchr>
 8001eee:	6178      	str	r0, [r7, #20]
    if(pair) {
 8001ef0:	697b      	ldr	r3, [r7, #20]
 8001ef2:	2b00      	cmp	r3, #0
 8001ef4:	d008      	beq.n	8001f08 <extract_uri_parameters+0x64>
      *pair = '\0';
 8001ef6:	697b      	ldr	r3, [r7, #20]
 8001ef8:	f04f 0200 	mov.w	r2, #0
 8001efc:	701a      	strb	r2, [r3, #0]
      pair++;
 8001efe:	697b      	ldr	r3, [r7, #20]
 8001f00:	f103 0301 	add.w	r3, r3, #1
 8001f04:	617b      	str	r3, [r7, #20]
 8001f06:	e00f      	b.n	8001f28 <extract_uri_parameters+0x84>
    } else {
       /* We didn't find a new parameter so find the end of the URI and
        * replace the space with a '\0' */
        pair = strchr(equals, ' ');
 8001f08:	68f8      	ldr	r0, [r7, #12]
 8001f0a:	f04f 0120 	mov.w	r1, #32
 8001f0e:	f022 fc4d 	bl	80247ac <strchr>
 8001f12:	6178      	str	r0, [r7, #20]
        if(pair) {
 8001f14:	697b      	ldr	r3, [r7, #20]
 8001f16:	2b00      	cmp	r3, #0
 8001f18:	d003      	beq.n	8001f22 <extract_uri_parameters+0x7e>
            *pair = '\0';
 8001f1a:	697b      	ldr	r3, [r7, #20]
 8001f1c:	f04f 0200 	mov.w	r2, #0
 8001f20:	701a      	strb	r2, [r3, #0]
        }

        /* Revert to NULL so that we exit the loop as expected. */
        pair = NULL;
 8001f22:	f04f 0300 	mov.w	r3, #0
 8001f26:	617b      	str	r3, [r7, #20]
    }

    /* Now find the '=' in the previous pair, replace it with '\0' and save
     * the parameter value string. */
    equals = strchr(equals, '=');
 8001f28:	68f8      	ldr	r0, [r7, #12]
 8001f2a:	f04f 013d 	mov.w	r1, #61	; 0x3d
 8001f2e:	f022 fc3d 	bl	80247ac <strchr>
 8001f32:	60f8      	str	r0, [r7, #12]
    if(equals) {
 8001f34:	68fb      	ldr	r3, [r7, #12]
 8001f36:	2b00      	cmp	r3, #0
 8001f38:	d00f      	beq.n	8001f5a <extract_uri_parameters+0xb6>
      *equals = '\0';
 8001f3a:	68fb      	ldr	r3, [r7, #12]
 8001f3c:	f04f 0200 	mov.w	r2, #0
 8001f40:	701a      	strb	r2, [r3, #0]
      hs->param_vals[loop] = equals + 1;
 8001f42:	68fb      	ldr	r3, [r7, #12]
 8001f44:	f103 0201 	add.w	r2, r3, #1
 8001f48:	6879      	ldr	r1, [r7, #4]
 8001f4a:	693b      	ldr	r3, [r7, #16]
 8001f4c:	f103 034e 	add.w	r3, r3, #78	; 0x4e
 8001f50:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f54:	18cb      	adds	r3, r1, r3
 8001f56:	605a      	str	r2, [r3, #4]
 8001f58:	e009      	b.n	8001f6e <extract_uri_parameters+0xca>
    } else {
      hs->param_vals[loop] = NULL;
 8001f5a:	687a      	ldr	r2, [r7, #4]
 8001f5c:	693b      	ldr	r3, [r7, #16]
 8001f5e:	f103 034e 	add.w	r3, r3, #78	; 0x4e
 8001f62:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f66:	18d3      	adds	r3, r2, r3
 8001f68:	f04f 0200 	mov.w	r2, #0
 8001f6c:	605a      	str	r2, [r3, #4]
  /* Get a pointer to our first parameter */
  pair = params;

  /* Parse up to LWIP_HTTPD_MAX_CGI_PARAMETERS from the passed string and ignore the
   * remainder (if any) */
  for(loop = 0; (loop < LWIP_HTTPD_MAX_CGI_PARAMETERS) && pair; loop++) {
 8001f6e:	693b      	ldr	r3, [r7, #16]
 8001f70:	f103 0301 	add.w	r3, r3, #1
 8001f74:	613b      	str	r3, [r7, #16]
 8001f76:	693b      	ldr	r3, [r7, #16]
 8001f78:	2b0f      	cmp	r3, #15
 8001f7a:	dc02      	bgt.n	8001f82 <extract_uri_parameters+0xde>
 8001f7c:	697b      	ldr	r3, [r7, #20]
 8001f7e:	2b00      	cmp	r3, #0
 8001f80:	d1a5      	bne.n	8001ece <extract_uri_parameters+0x2a>
    } else {
      hs->param_vals[loop] = NULL;
    }
  }

  return loop;
 8001f82:	693b      	ldr	r3, [r7, #16]
}
 8001f84:	4618      	mov	r0, r3
 8001f86:	f107 0718 	add.w	r7, r7, #24
 8001f8a:	46bd      	mov	sp, r7
 8001f8c:	bd80      	pop	{r7, pc}
 8001f8e:	bf00      	nop

08001f90 <get_tag_insert>:
 *
 * @param hs http connection state
 */
static void
get_tag_insert(struct http_state *hs)
{
 8001f90:	b580      	push	{r7, lr}
 8001f92:	b084      	sub	sp, #16
 8001f94:	af00      	add	r7, sp, #0
 8001f96:	6078      	str	r0, [r7, #4]
#if LWIP_HTTPD_SSI_MULTIPART
  u16_t current_tag_part = hs->tag_part;
  hs->tag_part = HTTPD_LAST_TAG_PART;
#endif /* LWIP_HTTPD_SSI_MULTIPART */

  if(g_pfnSSIHandler && g_ppcTags && g_iNumTags) {
 8001f98:	f640 430c 	movw	r3, #3084	; 0xc0c
 8001f9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fa0:	681b      	ldr	r3, [r3, #0]
 8001fa2:	2b00      	cmp	r3, #0
 8001fa4:	d043      	beq.n	800202e <get_tag_insert+0x9e>
 8001fa6:	f640 4314 	movw	r3, #3092	; 0xc14
 8001faa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fae:	681b      	ldr	r3, [r3, #0]
 8001fb0:	2b00      	cmp	r3, #0
 8001fb2:	d03c      	beq.n	800202e <get_tag_insert+0x9e>
 8001fb4:	f640 4310 	movw	r3, #3088	; 0xc10
 8001fb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fbc:	681b      	ldr	r3, [r3, #0]
 8001fbe:	2b00      	cmp	r3, #0
 8001fc0:	d035      	beq.n	800202e <get_tag_insert+0x9e>

    /* Find this tag in the list we have been provided. */
    for(loop = 0; loop < g_iNumTags; loop++) {
 8001fc2:	f04f 0300 	mov.w	r3, #0
 8001fc6:	60fb      	str	r3, [r7, #12]
 8001fc8:	e029      	b.n	800201e <get_tag_insert+0x8e>
      if(strcmp(hs->tag_name, g_ppcTags[loop]) == 0) {
 8001fca:	687b      	ldr	r3, [r7, #4]
 8001fcc:	f103 022e 	add.w	r2, r3, #46	; 0x2e
 8001fd0:	f640 4314 	movw	r3, #3092	; 0xc14
 8001fd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fd8:	6819      	ldr	r1, [r3, #0]
 8001fda:	68fb      	ldr	r3, [r7, #12]
 8001fdc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fe0:	18cb      	adds	r3, r1, r3
 8001fe2:	681b      	ldr	r3, [r3, #0]
 8001fe4:	4610      	mov	r0, r2
 8001fe6:	4619      	mov	r1, r3
 8001fe8:	f022 fc5e 	bl	80248a8 <strcmp>
 8001fec:	4603      	mov	r3, r0
 8001fee:	2b00      	cmp	r3, #0
 8001ff0:	d111      	bne.n	8002016 <get_tag_insert+0x86>
        hs->tag_insert_len = g_pfnSSIHandler(loop, hs->tag_insert,
 8001ff2:	f640 430c 	movw	r3, #3084	; 0xc0c
 8001ff6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ffa:	681b      	ldr	r3, [r3, #0]
 8001ffc:	687a      	ldr	r2, [r7, #4]
 8001ffe:	f102 0237 	add.w	r2, r2, #55	; 0x37
 8002002:	68f8      	ldr	r0, [r7, #12]
 8002004:	4611      	mov	r1, r2
 8002006:	f04f 02c0 	mov.w	r2, #192	; 0xc0
 800200a:	4798      	blx	r3
 800200c:	4603      	mov	r3, r0
 800200e:	461a      	mov	r2, r3
 8002010:	687b      	ldr	r3, [r7, #4]
 8002012:	855a      	strh	r2, [r3, #42]	; 0x2a
#endif /* LWIP_HTTPD_SSI_MULTIPART */
#if LWIP_HTTPD_FILE_STATE
           , hs->handle->state
#endif /* LWIP_HTTPD_FILE_STATE */
           );
        return;
 8002014:	e05c      	b.n	80020d0 <get_tag_insert+0x140>
#endif /* LWIP_HTTPD_SSI_MULTIPART */

  if(g_pfnSSIHandler && g_ppcTags && g_iNumTags) {

    /* Find this tag in the list we have been provided. */
    for(loop = 0; loop < g_iNumTags; loop++) {
 8002016:	68fb      	ldr	r3, [r7, #12]
 8002018:	f103 0301 	add.w	r3, r3, #1
 800201c:	60fb      	str	r3, [r7, #12]
 800201e:	f640 4310 	movw	r3, #3088	; 0xc10
 8002022:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002026:	681b      	ldr	r3, [r3, #0]
 8002028:	68fa      	ldr	r2, [r7, #12]
 800202a:	429a      	cmp	r2, r3
 800202c:	dbcd      	blt.n	8001fca <get_tag_insert+0x3a>
   * marker. */
#define UNKNOWN_TAG1_TEXT "<b>***UNKNOWN TAG "
#define UNKNOWN_TAG1_LEN  18
#define UNKNOWN_TAG2_TEXT "***</b>"
#define UNKNOWN_TAG2_LEN  7
  len = LWIP_MIN(strlen(hs->tag_name),
 800202e:	687b      	ldr	r3, [r7, #4]
 8002030:	f103 032e 	add.w	r3, r3, #46	; 0x2e
 8002034:	4618      	mov	r0, r3
 8002036:	f022 fd83 	bl	8024b40 <strlen>
 800203a:	4603      	mov	r3, r0
 800203c:	2ba6      	cmp	r3, #166	; 0xa6
 800203e:	d807      	bhi.n	8002050 <get_tag_insert+0xc0>
 8002040:	687b      	ldr	r3, [r7, #4]
 8002042:	f103 032e 	add.w	r3, r3, #46	; 0x2e
 8002046:	4618      	mov	r0, r3
 8002048:	f022 fd7a 	bl	8024b40 <strlen>
 800204c:	4603      	mov	r3, r0
 800204e:	e001      	b.n	8002054 <get_tag_insert+0xc4>
 8002050:	f04f 03a7 	mov.w	r3, #167	; 0xa7
 8002054:	60bb      	str	r3, [r7, #8]
    LWIP_HTTPD_MAX_TAG_INSERT_LEN - (UNKNOWN_TAG1_LEN + UNKNOWN_TAG2_LEN));
  MEMCPY(hs->tag_insert, UNKNOWN_TAG1_TEXT, UNKNOWN_TAG1_LEN);
 8002056:	687b      	ldr	r3, [r7, #4]
 8002058:	f103 0337 	add.w	r3, r3, #55	; 0x37
 800205c:	4618      	mov	r0, r3
 800205e:	f246 41b8 	movw	r1, #25784	; 0x64b8
 8002062:	f6c0 0102 	movt	r1, #2050	; 0x802
 8002066:	f04f 0212 	mov.w	r2, #18
 800206a:	f021 fad3 	bl	8023614 <memcpy>
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN], hs->tag_name, len);
 800206e:	687b      	ldr	r3, [r7, #4]
 8002070:	f103 0249 	add.w	r2, r3, #73	; 0x49
 8002074:	687b      	ldr	r3, [r7, #4]
 8002076:	f103 032e 	add.w	r3, r3, #46	; 0x2e
 800207a:	4610      	mov	r0, r2
 800207c:	4619      	mov	r1, r3
 800207e:	68ba      	ldr	r2, [r7, #8]
 8002080:	f021 fac8 	bl	8023614 <memcpy>
  MEMCPY(&hs->tag_insert[UNKNOWN_TAG1_LEN + len], UNKNOWN_TAG2_TEXT, UNKNOWN_TAG2_LEN);
 8002084:	68bb      	ldr	r3, [r7, #8]
 8002086:	f103 0312 	add.w	r3, r3, #18
 800208a:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800208e:	687a      	ldr	r2, [r7, #4]
 8002090:	18d3      	adds	r3, r2, r3
 8002092:	f103 0307 	add.w	r3, r3, #7
 8002096:	4618      	mov	r0, r3
 8002098:	f246 41cc 	movw	r1, #25804	; 0x64cc
 800209c:	f6c0 0102 	movt	r1, #2050	; 0x802
 80020a0:	f04f 0207 	mov.w	r2, #7
 80020a4:	f021 fab6 	bl	8023614 <memcpy>
  hs->tag_insert[UNKNOWN_TAG1_LEN + len + UNKNOWN_TAG2_LEN] = 0;
 80020a8:	68bb      	ldr	r3, [r7, #8]
 80020aa:	f103 0319 	add.w	r3, r3, #25
 80020ae:	687a      	ldr	r2, [r7, #4]
 80020b0:	18d3      	adds	r3, r2, r3
 80020b2:	f04f 0200 	mov.w	r2, #0
 80020b6:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37

  len = strlen(hs->tag_insert);
 80020ba:	687b      	ldr	r3, [r7, #4]
 80020bc:	f103 0337 	add.w	r3, r3, #55	; 0x37
 80020c0:	4618      	mov	r0, r3
 80020c2:	f022 fd3d 	bl	8024b40 <strlen>
 80020c6:	60b8      	str	r0, [r7, #8]
  LWIP_ASSERT("len <= 0xffff", len <= 0xffff);
  hs->tag_insert_len = (u16_t)len;
 80020c8:	68bb      	ldr	r3, [r7, #8]
 80020ca:	b29a      	uxth	r2, r3
 80020cc:	687b      	ldr	r3, [r7, #4]
 80020ce:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 80020d0:	f107 0710 	add.w	r7, r7, #16
 80020d4:	46bd      	mov	sp, r7
 80020d6:	bd80      	pop	{r7, pc}

080020d8 <http_send_data>:
 * @param pcb the pcb to send data
 * @param hs connection state
 */
static u8_t
http_send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
 80020d8:	b580      	push	{r7, lr}
 80020da:	b086      	sub	sp, #24
 80020dc:	af00      	add	r7, sp, #0
 80020de:	6078      	str	r0, [r7, #4]
 80020e0:	6039      	str	r1, [r7, #0]
  err_t err;
  u16_t len;
  u16_t mss;
  u8_t data_to_send = false;
 80020e2:	f04f 0300 	mov.w	r3, #0
 80020e6:	75bb      	strb	r3, [r7, #22]
      return 1;
    }
  }
#else /* LWIP_HTTPD_DYNAMIC_HEADERS */
  /* Assume no error until we find otherwise */
  err = ERR_OK;
 80020e8:	f04f 0300 	mov.w	r3, #0
 80020ec:	75fb      	strb	r3, [r7, #23]
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */

  /* Have we run out of file data to send? If so, we need to read the next
   * block from the file. */
  if (hs->left == 0) {
 80020ee:	683b      	ldr	r3, [r7, #0]
 80020f0:	695b      	ldr	r3, [r3, #20]
 80020f2:	2b00      	cmp	r3, #0
 80020f4:	d169      	bne.n	80021ca <http_send_data+0xf2>
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    int count;
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */

    /* Do we have a valid file handle? */
    if (hs->handle == NULL) {
 80020f6:	683b      	ldr	r3, [r7, #0]
 80020f8:	681b      	ldr	r3, [r3, #0]
 80020fa:	2b00      	cmp	r3, #0
 80020fc:	d106      	bne.n	800210c <http_send_data+0x34>
      /* No - close the connection. */
      http_close_conn(pcb, hs);
 80020fe:	6878      	ldr	r0, [r7, #4]
 8002100:	6839      	ldr	r1, [r7, #0]
 8002102:	f7ff fe8f 	bl	8001e24 <http_close_conn>
      return 0;
 8002106:	f04f 0300 	mov.w	r3, #0
 800210a:	e3ab      	b.n	8002864 <http_send_data+0x78c>
    }
    if (fs_bytes_left(hs->handle) <= 0) {
 800210c:	683b      	ldr	r3, [r7, #0]
 800210e:	681b      	ldr	r3, [r3, #0]
 8002110:	4618      	mov	r0, r3
 8002112:	f7ff fdc5 	bl	8001ca0 <fs_bytes_left>
 8002116:	4603      	mov	r3, r0
 8002118:	2b00      	cmp	r3, #0
 800211a:	dc06      	bgt.n	800212a <http_send_data+0x52>
      /* We reached the end of the file so this request is done.
       * @todo: don't close here for HTTP/1.1? */
      LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
      http_close_conn(pcb, hs);
 800211c:	6878      	ldr	r0, [r7, #4]
 800211e:	6839      	ldr	r1, [r7, #0]
 8002120:	f7ff fe80 	bl	8001e24 <http_close_conn>
      return 0;
 8002124:	f04f 0300 	mov.w	r3, #0
 8002128:	e39c      	b.n	8002864 <http_send_data+0x78c>
    }
#if LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS
    /* Do we already have a send buffer allocated? */
    if(hs->buf) {
 800212a:	683b      	ldr	r3, [r7, #0]
 800212c:	68db      	ldr	r3, [r3, #12]
 800212e:	2b00      	cmp	r3, #0
 8002130:	d003      	beq.n	800213a <http_send_data+0x62>
      /* Yes - get the length of the buffer */
      count = hs->buf_len;
 8002132:	683b      	ldr	r3, [r7, #0]
 8002134:	691b      	ldr	r3, [r3, #16]
 8002136:	613b      	str	r3, [r7, #16]
 8002138:	e025      	b.n	8002186 <http_send_data+0xae>
    } else {
      /* We don't have a send buffer so allocate one up to 2mss bytes long. */
      count = 2 * tcp_mss(pcb);
 800213a:	687b      	ldr	r3, [r7, #4]
 800213c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 800213e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002142:	613b      	str	r3, [r7, #16]
      do {
        hs->buf = (char*)mem_malloc((mem_size_t)count);
 8002144:	693b      	ldr	r3, [r7, #16]
 8002146:	b29b      	uxth	r3, r3
 8002148:	4618      	mov	r0, r3
 800214a:	f00f ffe1 	bl	8012110 <mem_malloc>
 800214e:	4602      	mov	r2, r0
 8002150:	683b      	ldr	r3, [r7, #0]
 8002152:	60da      	str	r2, [r3, #12]
        if (hs->buf != NULL) {
 8002154:	683b      	ldr	r3, [r7, #0]
 8002156:	68db      	ldr	r3, [r3, #12]
 8002158:	2b00      	cmp	r3, #0
 800215a:	d003      	beq.n	8002164 <http_send_data+0x8c>
          hs->buf_len = count;
 800215c:	683b      	ldr	r3, [r7, #0]
 800215e:	693a      	ldr	r2, [r7, #16]
 8002160:	611a      	str	r2, [r3, #16]
          break;
 8002162:	e009      	b.n	8002178 <http_send_data+0xa0>
        }
        count = count / 2;
 8002164:	693b      	ldr	r3, [r7, #16]
 8002166:	ea4f 72d3 	mov.w	r2, r3, lsr #31
 800216a:	18d3      	adds	r3, r2, r3
 800216c:	ea4f 0363 	mov.w	r3, r3, asr #1
 8002170:	613b      	str	r3, [r7, #16]
      } while (count > 100);
 8002172:	693b      	ldr	r3, [r7, #16]
 8002174:	2b64      	cmp	r3, #100	; 0x64
 8002176:	dce5      	bgt.n	8002144 <http_send_data+0x6c>

      /* Did we get a send buffer? If not, return immediately. */
      if (hs->buf == NULL) {
 8002178:	683b      	ldr	r3, [r7, #0]
 800217a:	68db      	ldr	r3, [r3, #12]
 800217c:	2b00      	cmp	r3, #0
 800217e:	d102      	bne.n	8002186 <http_send_data+0xae>
        LWIP_DEBUGF(HTTPD_DEBUG, ("No buff\n"));
        return 0;
 8002180:	f04f 0300 	mov.w	r3, #0
 8002184:	e36e      	b.n	8002864 <http_send_data+0x78c>
    }

    /* Read a block of data from the file. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Trying to read %d bytes.\n", count));

    count = fs_read(hs->handle, hs->buf, count);
 8002186:	683b      	ldr	r3, [r7, #0]
 8002188:	681a      	ldr	r2, [r3, #0]
 800218a:	683b      	ldr	r3, [r7, #0]
 800218c:	68db      	ldr	r3, [r3, #12]
 800218e:	4610      	mov	r0, r2
 8002190:	4619      	mov	r1, r3
 8002192:	693a      	ldr	r2, [r7, #16]
 8002194:	f7ff fd62 	bl	8001c5c <fs_read>
 8002198:	6138      	str	r0, [r7, #16]
    if(count < 0) {
 800219a:	693b      	ldr	r3, [r7, #16]
 800219c:	2b00      	cmp	r3, #0
 800219e:	da06      	bge.n	80021ae <http_send_data+0xd6>
      /* We reached the end of the file so this request is done.
       * @todo: don't close here for HTTP/1.1? */
      LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
      http_close_conn(pcb, hs);
 80021a0:	6878      	ldr	r0, [r7, #4]
 80021a2:	6839      	ldr	r1, [r7, #0]
 80021a4:	f7ff fe3e 	bl	8001e24 <http_close_conn>
      return 1;
 80021a8:	f04f 0301 	mov.w	r3, #1
 80021ac:	e35a      	b.n	8002864 <http_send_data+0x78c>
    }

    /* Set up to send the block of data we just read */
    LWIP_DEBUGF(HTTPD_DEBUG, ("Read %d bytes.\n", count));
    hs->left = count;
 80021ae:	693a      	ldr	r2, [r7, #16]
 80021b0:	683b      	ldr	r3, [r7, #0]
 80021b2:	615a      	str	r2, [r3, #20]
    hs->file = hs->buf;
 80021b4:	683b      	ldr	r3, [r7, #0]
 80021b6:	68da      	ldr	r2, [r3, #12]
 80021b8:	683b      	ldr	r3, [r7, #0]
 80021ba:	605a      	str	r2, [r3, #4]
#if LWIP_HTTPD_SSI
    hs->parse_left = count;
 80021bc:	693a      	ldr	r2, [r7, #16]
 80021be:	683b      	ldr	r3, [r7, #0]
 80021c0:	625a      	str	r2, [r3, #36]	; 0x24
    hs->parsed = hs->buf;
 80021c2:	683b      	ldr	r3, [r7, #0]
 80021c4:	68da      	ldr	r2, [r3, #12]
 80021c6:	683b      	ldr	r3, [r7, #0]
 80021c8:	61da      	str	r2, [r3, #28]
    LWIP_ASSERT("SSI and DYNAMIC_HEADERS turned off but eof not reached", 0);
#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
  }

#if LWIP_HTTPD_SSI
  if(!hs->tag_check) {
 80021ca:	683b      	ldr	r3, [r7, #0]
 80021cc:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80021d0:	2b00      	cmp	r3, #0
 80021d2:	d141      	bne.n	8002258 <http_send_data+0x180>
    /* We are not processing an SHTML file so no tag checking is necessary.
     * Just send the data as we received it from the file. */

    /* We cannot send more data than space available in the send
       buffer. */
    if (tcp_sndbuf(pcb) < hs->left) {
 80021d4:	687b      	ldr	r3, [r7, #4]
 80021d6:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 80021da:	461a      	mov	r2, r3
 80021dc:	683b      	ldr	r3, [r7, #0]
 80021de:	695b      	ldr	r3, [r3, #20]
 80021e0:	429a      	cmp	r2, r3
 80021e2:	d204      	bcs.n	80021ee <http_send_data+0x116>
      len = tcp_sndbuf(pcb);
 80021e4:	687b      	ldr	r3, [r7, #4]
 80021e6:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 80021ea:	81bb      	strh	r3, [r7, #12]
 80021ec:	e003      	b.n	80021f6 <http_send_data+0x11e>
    } else {
      len = (u16_t)hs->left;
 80021ee:	683b      	ldr	r3, [r7, #0]
 80021f0:	695b      	ldr	r3, [r3, #20]
 80021f2:	b29b      	uxth	r3, r3
 80021f4:	81bb      	strh	r3, [r7, #12]
      LWIP_ASSERT("hs->left did not fit into u16_t!", (len == hs->left));
    }
    mss = tcp_mss(pcb);
 80021f6:	687b      	ldr	r3, [r7, #4]
 80021f8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80021fa:	81fb      	strh	r3, [r7, #14]
    if(len > (2 * mss)) {
 80021fc:	89bb      	ldrh	r3, [r7, #12]
 80021fe:	461a      	mov	r2, r3
 8002200:	89fb      	ldrh	r3, [r7, #14]
 8002202:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002206:	429a      	cmp	r2, r3
 8002208:	dd04      	ble.n	8002214 <http_send_data+0x13c>
      len = 2 * mss;
 800220a:	89fb      	ldrh	r3, [r7, #14]
 800220c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002210:	b29b      	uxth	r3, r3
 8002212:	81bb      	strh	r3, [r7, #12]
    }

    err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 8002214:	683b      	ldr	r3, [r7, #0]
 8002216:	685a      	ldr	r2, [r3, #4]
 8002218:	f107 030c 	add.w	r3, r7, #12
 800221c:	6878      	ldr	r0, [r7, #4]
 800221e:	4611      	mov	r1, r2
 8002220:	461a      	mov	r2, r3
 8002222:	f04f 0301 	mov.w	r3, #1
 8002226:	f7ff fdc7 	bl	8001db8 <http_write>
 800222a:	4603      	mov	r3, r0
 800222c:	75fb      	strb	r3, [r7, #23]
    if (err == ERR_OK) {
 800222e:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8002232:	2b00      	cmp	r3, #0
 8002234:	f040 8302 	bne.w	800283c <http_send_data+0x764>
      data_to_send = true;
 8002238:	f04f 0301 	mov.w	r3, #1
 800223c:	75bb      	strb	r3, [r7, #22]
      hs->file += len;
 800223e:	683b      	ldr	r3, [r7, #0]
 8002240:	685a      	ldr	r2, [r3, #4]
 8002242:	89bb      	ldrh	r3, [r7, #12]
 8002244:	18d2      	adds	r2, r2, r3
 8002246:	683b      	ldr	r3, [r7, #0]
 8002248:	605a      	str	r2, [r3, #4]
      hs->left -= len;
 800224a:	683b      	ldr	r3, [r7, #0]
 800224c:	695a      	ldr	r2, [r3, #20]
 800224e:	89bb      	ldrh	r3, [r7, #12]
 8002250:	1ad2      	subs	r2, r2, r3
 8002252:	683b      	ldr	r3, [r7, #0]
 8002254:	615a      	str	r2, [r3, #20]
 8002256:	e2f1      	b.n	800283c <http_send_data+0x764>
     * them with insert strings. We need to be careful here since a tag may
     * straddle the boundary of two blocks read from the file and we may also
     * have to split the insert string between two tcp_write operations. */

    /* How much data could we send? */
    len = tcp_sndbuf(pcb);
 8002258:	687b      	ldr	r3, [r7, #4]
 800225a:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 800225e:	81bb      	strh	r3, [r7, #12]

    /* Do we have remaining data to send before parsing more? */
    if(hs->parsed > hs->file) {
 8002260:	683b      	ldr	r3, [r7, #0]
 8002262:	69da      	ldr	r2, [r3, #28]
 8002264:	683b      	ldr	r3, [r7, #0]
 8002266:	685b      	ldr	r3, [r3, #4]
 8002268:	429a      	cmp	r2, r3
 800226a:	f240 8287 	bls.w	800277c <http_send_data+0x6a4>
      /* We cannot send more data than space available in the send
         buffer. */
      if (tcp_sndbuf(pcb) < (hs->parsed - hs->file)) {
 800226e:	687b      	ldr	r3, [r7, #4]
 8002270:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8002274:	461a      	mov	r2, r3
 8002276:	683b      	ldr	r3, [r7, #0]
 8002278:	69db      	ldr	r3, [r3, #28]
 800227a:	4619      	mov	r1, r3
 800227c:	683b      	ldr	r3, [r7, #0]
 800227e:	685b      	ldr	r3, [r3, #4]
 8002280:	1acb      	subs	r3, r1, r3
 8002282:	429a      	cmp	r2, r3
 8002284:	da04      	bge.n	8002290 <http_send_data+0x1b8>
        len = tcp_sndbuf(pcb);
 8002286:	687b      	ldr	r3, [r7, #4]
 8002288:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 800228c:	81bb      	strh	r3, [r7, #12]
 800228e:	e007      	b.n	80022a0 <http_send_data+0x1c8>
      } else {
        LWIP_ASSERT("Data size does not fit into u16_t!",
                    (hs->parsed - hs->file) <= 0xffff);
        len = (u16_t)(hs->parsed - hs->file);
 8002290:	683b      	ldr	r3, [r7, #0]
 8002292:	69db      	ldr	r3, [r3, #28]
 8002294:	461a      	mov	r2, r3
 8002296:	683b      	ldr	r3, [r7, #0]
 8002298:	685b      	ldr	r3, [r3, #4]
 800229a:	1ad3      	subs	r3, r2, r3
 800229c:	b29b      	uxth	r3, r3
 800229e:	81bb      	strh	r3, [r7, #12]
      }
      mss = tcp_mss(pcb);
 80022a0:	687b      	ldr	r3, [r7, #4]
 80022a2:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80022a4:	81fb      	strh	r3, [r7, #14]
      if(len > (2 * mss)) {
 80022a6:	89bb      	ldrh	r3, [r7, #12]
 80022a8:	461a      	mov	r2, r3
 80022aa:	89fb      	ldrh	r3, [r7, #14]
 80022ac:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80022b0:	429a      	cmp	r2, r3
 80022b2:	dd04      	ble.n	80022be <http_send_data+0x1e6>
        len = 2 * mss;
 80022b4:	89fb      	ldrh	r3, [r7, #14]
 80022b6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80022ba:	b29b      	uxth	r3, r3
 80022bc:	81bb      	strh	r3, [r7, #12]
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 80022be:	683b      	ldr	r3, [r7, #0]
 80022c0:	685a      	ldr	r2, [r3, #4]
 80022c2:	f107 030c 	add.w	r3, r7, #12
 80022c6:	6878      	ldr	r0, [r7, #4]
 80022c8:	4611      	mov	r1, r2
 80022ca:	461a      	mov	r2, r3
 80022cc:	f04f 0301 	mov.w	r3, #1
 80022d0:	f7ff fd72 	bl	8001db8 <http_write>
 80022d4:	4603      	mov	r3, r0
 80022d6:	75fb      	strb	r3, [r7, #23]
      if (err == ERR_OK) {
 80022d8:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80022dc:	2b00      	cmp	r3, #0
 80022de:	d10e      	bne.n	80022fe <http_send_data+0x226>
        data_to_send = true;
 80022e0:	f04f 0301 	mov.w	r3, #1
 80022e4:	75bb      	strb	r3, [r7, #22]
        hs->file += len;
 80022e6:	683b      	ldr	r3, [r7, #0]
 80022e8:	685a      	ldr	r2, [r3, #4]
 80022ea:	89bb      	ldrh	r3, [r7, #12]
 80022ec:	18d2      	adds	r2, r2, r3
 80022ee:	683b      	ldr	r3, [r7, #0]
 80022f0:	605a      	str	r2, [r3, #4]
        hs->left -= len;
 80022f2:	683b      	ldr	r3, [r7, #0]
 80022f4:	695a      	ldr	r2, [r3, #20]
 80022f6:	89bb      	ldrh	r3, [r7, #12]
 80022f8:	1ad2      	subs	r2, r2, r3
 80022fa:	683b      	ldr	r3, [r7, #0]
 80022fc:	615a      	str	r2, [r3, #20]
      }

      /* If the send buffer is full, return now. */
      if(tcp_sndbuf(pcb) == 0) {
 80022fe:	687b      	ldr	r3, [r7, #4]
 8002300:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8002304:	2b00      	cmp	r3, #0
 8002306:	f040 8239 	bne.w	800277c <http_send_data+0x6a4>
        return data_to_send;
 800230a:	7dbb      	ldrb	r3, [r7, #22]
 800230c:	e2aa      	b.n	8002864 <http_send_data+0x78c>

    /* We have sent all the data that was already parsed so continue parsing
     * the buffer contents looking for SSI tags. */
    while((hs->parse_left) && (err == ERR_OK)) {
      /* @todo: somewhere in this loop, 'len' should grow again... */
      if (len == 0) {
 800230e:	89bb      	ldrh	r3, [r7, #12]
 8002310:	2b00      	cmp	r3, #0
 8002312:	d101      	bne.n	8002318 <http_send_data+0x240>
        return data_to_send;
 8002314:	7dbb      	ldrb	r3, [r7, #22]
 8002316:	e2a5      	b.n	8002864 <http_send_data+0x78c>
      }
      switch(hs->tag_state) {
 8002318:	683b      	ldr	r3, [r7, #0]
 800231a:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
 800231e:	2b04      	cmp	r3, #4
 8002320:	f200 8231 	bhi.w	8002786 <http_send_data+0x6ae>
 8002324:	a201      	add	r2, pc, #4	; (adr r2, 800232c <http_send_data+0x254>)
 8002326:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800232a:	bf00      	nop
 800232c:	08002341 	.word	0x08002341
 8002330:	08002383 	.word	0x08002383
 8002334:	080023ef 	.word	0x080023ef
 8002338:	08002527 	.word	0x08002527
 800233c:	08002677 	.word	0x08002677
        case TAG_NONE:
          /* We are not currently processing an SSI tag so scan for the
           * start of the lead-in marker. */
          if(*hs->parsed == g_pcTagLeadIn[0]) {
 8002340:	683b      	ldr	r3, [r7, #0]
 8002342:	69db      	ldr	r3, [r3, #28]
 8002344:	781a      	ldrb	r2, [r3, #0]
 8002346:	f246 43ac 	movw	r3, #25772	; 0x64ac
 800234a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800234e:	681b      	ldr	r3, [r3, #0]
 8002350:	781b      	ldrb	r3, [r3, #0]
 8002352:	429a      	cmp	r2, r3
 8002354:	d108      	bne.n	8002368 <http_send_data+0x290>
            /* We found what could be the lead-in for a new tag so change
             * state appropriately. */
            hs->tag_state = TAG_LEADIN;
 8002356:	683b      	ldr	r3, [r7, #0]
 8002358:	f04f 0201 	mov.w	r2, #1
 800235c:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
            hs->tag_index = 1;
 8002360:	683b      	ldr	r3, [r7, #0]
 8002362:	f04f 0201 	mov.w	r2, #1
 8002366:	851a      	strh	r2, [r3, #40]	; 0x28
            hs->tag_started = hs->parsed;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG */
          }

          /* Move on to the next character in the buffer */
          hs->parse_left--;
 8002368:	683b      	ldr	r3, [r7, #0]
 800236a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800236c:	f103 32ff 	add.w	r2, r3, #4294967295
 8002370:	683b      	ldr	r3, [r7, #0]
 8002372:	625a      	str	r2, [r3, #36]	; 0x24
          hs->parsed++;
 8002374:	683b      	ldr	r3, [r7, #0]
 8002376:	69db      	ldr	r3, [r3, #28]
 8002378:	f103 0201 	add.w	r2, r3, #1
 800237c:	683b      	ldr	r3, [r7, #0]
 800237e:	61da      	str	r2, [r3, #28]
          break;
 8002380:	e201      	b.n	8002786 <http_send_data+0x6ae>
        case TAG_LEADIN:
          /* We are processing the lead-in marker, looking for the start of
           * the tag name. */

          /* Have we reached the end of the leadin? */
          if(hs->tag_index == LEN_TAG_LEAD_IN) {
 8002382:	683b      	ldr	r3, [r7, #0]
 8002384:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002386:	2b05      	cmp	r3, #5
 8002388:	d109      	bne.n	800239e <http_send_data+0x2c6>
            hs->tag_index = 0;
 800238a:	683b      	ldr	r3, [r7, #0]
 800238c:	f04f 0200 	mov.w	r2, #0
 8002390:	851a      	strh	r2, [r3, #40]	; 0x28
            hs->tag_state = TAG_FOUND;
 8002392:	683b      	ldr	r3, [r7, #0]
 8002394:	f04f 0202 	mov.w	r2, #2
 8002398:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8

            /* Move on to the next character in the buffer */
            hs->parse_left--;
            hs->parsed++;
          }
          break;
 800239c:	e1f3      	b.n	8002786 <http_send_data+0x6ae>
          if(hs->tag_index == LEN_TAG_LEAD_IN) {
            hs->tag_index = 0;
            hs->tag_state = TAG_FOUND;
          } else {
            /* Have we found the next character we expect for the tag leadin? */
            if(*hs->parsed == g_pcTagLeadIn[hs->tag_index]) {
 800239e:	683b      	ldr	r3, [r7, #0]
 80023a0:	69db      	ldr	r3, [r3, #28]
 80023a2:	781a      	ldrb	r2, [r3, #0]
 80023a4:	f246 43ac 	movw	r3, #25772	; 0x64ac
 80023a8:	f6c0 0302 	movt	r3, #2050	; 0x802
 80023ac:	6819      	ldr	r1, [r3, #0]
 80023ae:	683b      	ldr	r3, [r7, #0]
 80023b0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80023b2:	18cb      	adds	r3, r1, r3
 80023b4:	781b      	ldrb	r3, [r3, #0]
 80023b6:	429a      	cmp	r2, r3
 80023b8:	d107      	bne.n	80023ca <http_send_data+0x2f2>
              /* Yes - move to the next one unless we have found the complete
               * leadin, in which case we start looking for the tag itself */
              hs->tag_index++;
 80023ba:	683b      	ldr	r3, [r7, #0]
 80023bc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80023be:	f103 0301 	add.w	r3, r3, #1
 80023c2:	b29a      	uxth	r2, r3
 80023c4:	683b      	ldr	r3, [r7, #0]
 80023c6:	851a      	strh	r2, [r3, #40]	; 0x28
 80023c8:	e004      	b.n	80023d4 <http_send_data+0x2fc>
            } else {
              /* We found an unexpected character so this is not a tag. Move
               * back to idle state. */
              hs->tag_state = TAG_NONE;
 80023ca:	683b      	ldr	r3, [r7, #0]
 80023cc:	f04f 0200 	mov.w	r2, #0
 80023d0:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
            }

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 80023d4:	683b      	ldr	r3, [r7, #0]
 80023d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80023d8:	f103 32ff 	add.w	r2, r3, #4294967295
 80023dc:	683b      	ldr	r3, [r7, #0]
 80023de:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 80023e0:	683b      	ldr	r3, [r7, #0]
 80023e2:	69db      	ldr	r3, [r3, #28]
 80023e4:	f103 0201 	add.w	r2, r3, #1
 80023e8:	683b      	ldr	r3, [r7, #0]
 80023ea:	61da      	str	r2, [r3, #28]
          }
          break;
 80023ec:	e1cb      	b.n	8002786 <http_send_data+0x6ae>
          /* We are reading the tag name, looking for the start of the
           * lead-out marker and removing any whitespace found. */

          /* Remove leading whitespace between the tag leading and the first
           * tag name character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 80023ee:	683b      	ldr	r3, [r7, #0]
 80023f0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80023f2:	2b00      	cmp	r3, #0
 80023f4:	d120      	bne.n	8002438 <http_send_data+0x360>
 80023f6:	683b      	ldr	r3, [r7, #0]
 80023f8:	69db      	ldr	r3, [r3, #28]
 80023fa:	781b      	ldrb	r3, [r3, #0]
 80023fc:	2b20      	cmp	r3, #32
 80023fe:	d00e      	beq.n	800241e <http_send_data+0x346>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 8002400:	683b      	ldr	r3, [r7, #0]
 8002402:	69db      	ldr	r3, [r3, #28]
 8002404:	781b      	ldrb	r3, [r3, #0]
          /* We are reading the tag name, looking for the start of the
           * lead-out marker and removing any whitespace found. */

          /* Remove leading whitespace between the tag leading and the first
           * tag name character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 8002406:	2b09      	cmp	r3, #9
 8002408:	d009      	beq.n	800241e <http_send_data+0x346>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 800240a:	683b      	ldr	r3, [r7, #0]
 800240c:	69db      	ldr	r3, [r3, #28]
 800240e:	781b      	ldrb	r3, [r3, #0]
 8002410:	2b0a      	cmp	r3, #10
 8002412:	d004      	beq.n	800241e <http_send_data+0x346>
             (*hs->parsed == '\r'))) {
 8002414:	683b      	ldr	r3, [r7, #0]
 8002416:	69db      	ldr	r3, [r3, #28]
 8002418:	781b      	ldrb	r3, [r3, #0]
           * lead-out marker and removing any whitespace found. */

          /* Remove leading whitespace between the tag leading and the first
           * tag name character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 800241a:	2b0d      	cmp	r3, #13
 800241c:	d10c      	bne.n	8002438 <http_send_data+0x360>
             (*hs->parsed == '\r'))) {
            /* Move on to the next character in the buffer */
            hs->parse_left--;
 800241e:	683b      	ldr	r3, [r7, #0]
 8002420:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002422:	f103 32ff 	add.w	r2, r3, #4294967295
 8002426:	683b      	ldr	r3, [r7, #0]
 8002428:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 800242a:	683b      	ldr	r3, [r7, #0]
 800242c:	69db      	ldr	r3, [r3, #28]
 800242e:	f103 0201 	add.w	r2, r3, #1
 8002432:	683b      	ldr	r3, [r7, #0]
 8002434:	61da      	str	r2, [r3, #28]
            break;
 8002436:	e1a6      	b.n	8002786 <http_send_data+0x6ae>
          }

          /* Have we found the end of the tag name? This is signalled by
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
 8002438:	683b      	ldr	r3, [r7, #0]
 800243a:	69db      	ldr	r3, [r3, #28]
 800243c:	781a      	ldrb	r2, [r3, #0]
 800243e:	f246 43b4 	movw	r3, #25780	; 0x64b4
 8002442:	f6c0 0302 	movt	r3, #2050	; 0x802
 8002446:	681b      	ldr	r3, [r3, #0]
 8002448:	781b      	ldrb	r3, [r3, #0]
 800244a:	429a      	cmp	r2, r3
 800244c:	d013      	beq.n	8002476 <http_send_data+0x39e>
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
 800244e:	683b      	ldr	r3, [r7, #0]
 8002450:	69db      	ldr	r3, [r3, #28]
 8002452:	781b      	ldrb	r3, [r3, #0]
            break;
          }

          /* Have we found the end of the tag name? This is signalled by
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
 8002454:	2b20      	cmp	r3, #32
 8002456:	d00e      	beq.n	8002476 <http_send_data+0x39e>
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
 8002458:	683b      	ldr	r3, [r7, #0]
 800245a:	69db      	ldr	r3, [r3, #28]
 800245c:	781b      	ldrb	r3, [r3, #0]
 800245e:	2b09      	cmp	r3, #9
 8002460:	d009      	beq.n	8002476 <http_send_data+0x39e>
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {
 8002462:	683b      	ldr	r3, [r7, #0]
 8002464:	69db      	ldr	r3, [r3, #28]
 8002466:	781b      	ldrb	r3, [r3, #0]
          }

          /* Have we found the end of the tag name? This is signalled by
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
 8002468:	2b0a      	cmp	r3, #10
 800246a:	d004      	beq.n	8002476 <http_send_data+0x39e>
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {
 800246c:	683b      	ldr	r3, [r7, #0]
 800246e:	69db      	ldr	r3, [r3, #28]
 8002470:	781b      	ldrb	r3, [r3, #0]
 8002472:	2b0d      	cmp	r3, #13
 8002474:	d131      	bne.n	80024da <http_send_data+0x402>

            if(hs->tag_index == 0) {
 8002476:	683b      	ldr	r3, [r7, #0]
 8002478:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800247a:	2b00      	cmp	r3, #0
 800247c:	d105      	bne.n	800248a <http_send_data+0x3b2>
              /* We read a zero length tag so ignore it. */
              hs->tag_state = TAG_NONE;
 800247e:	683b      	ldr	r3, [r7, #0]
 8002480:	f04f 0200 	mov.w	r2, #0
 8002484:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {

            if(hs->tag_index == 0) {
 8002488:	e040      	b.n	800250c <http_send_data+0x434>
              /* We read a zero length tag so ignore it. */
              hs->tag_state = TAG_NONE;
            } else {
              /* We read a non-empty tag so go ahead and look for the
               * leadout string. */
              hs->tag_state = TAG_LEADOUT;
 800248a:	683b      	ldr	r3, [r7, #0]
 800248c:	f04f 0203 	mov.w	r2, #3
 8002490:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
              LWIP_ASSERT("hs->tag_index <= 0xff", hs->tag_index <= 0xff);
              hs->tag_name_len = (u8_t)hs->tag_index;
 8002494:	683b      	ldr	r3, [r7, #0]
 8002496:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002498:	b2da      	uxtb	r2, r3
 800249a:	683b      	ldr	r3, [r7, #0]
 800249c:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
              hs->tag_name[hs->tag_index] = '\0';
 80024a0:	683b      	ldr	r3, [r7, #0]
 80024a2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80024a4:	683a      	ldr	r2, [r7, #0]
 80024a6:	18d3      	adds	r3, r2, r3
 80024a8:	f04f 0200 	mov.w	r2, #0
 80024ac:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
              if(*hs->parsed == g_pcTagLeadOut[0]) {
 80024b0:	683b      	ldr	r3, [r7, #0]
 80024b2:	69db      	ldr	r3, [r3, #28]
 80024b4:	781a      	ldrb	r2, [r3, #0]
 80024b6:	f246 43b4 	movw	r3, #25780	; 0x64b4
 80024ba:	f6c0 0302 	movt	r3, #2050	; 0x802
 80024be:	681b      	ldr	r3, [r3, #0]
 80024c0:	781b      	ldrb	r3, [r3, #0]
 80024c2:	429a      	cmp	r2, r3
 80024c4:	d104      	bne.n	80024d0 <http_send_data+0x3f8>
                hs->tag_index = 1;
 80024c6:	683b      	ldr	r3, [r7, #0]
 80024c8:	f04f 0201 	mov.w	r2, #1
 80024cc:	851a      	strh	r2, [r3, #40]	; 0x28
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {

            if(hs->tag_index == 0) {
 80024ce:	e01d      	b.n	800250c <http_send_data+0x434>
              hs->tag_name_len = (u8_t)hs->tag_index;
              hs->tag_name[hs->tag_index] = '\0';
              if(*hs->parsed == g_pcTagLeadOut[0]) {
                hs->tag_index = 1;
              } else {
                hs->tag_index = 0;
 80024d0:	683b      	ldr	r3, [r7, #0]
 80024d2:	f04f 0200 	mov.w	r2, #0
 80024d6:	851a      	strh	r2, [r3, #40]	; 0x28
           * us finding the first leadout character or whitespace */
          if((*hs->parsed == g_pcTagLeadOut[0]) ||
             (*hs->parsed == ' ') || (*hs->parsed == '\t') ||
             (*hs->parsed == '\n')  || (*hs->parsed == '\r')) {

            if(hs->tag_index == 0) {
 80024d8:	e018      	b.n	800250c <http_send_data+0x434>
                hs->tag_index = 0;
              }
            }
          } else {
            /* This character is part of the tag name so save it */
            if(hs->tag_index < LWIP_HTTPD_MAX_TAG_NAME_LEN) {
 80024da:	683b      	ldr	r3, [r7, #0]
 80024dc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80024de:	2b07      	cmp	r3, #7
 80024e0:	d80f      	bhi.n	8002502 <http_send_data+0x42a>
              hs->tag_name[hs->tag_index++] = *hs->parsed;
 80024e2:	683b      	ldr	r3, [r7, #0]
 80024e4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80024e6:	461a      	mov	r2, r3
 80024e8:	6839      	ldr	r1, [r7, #0]
 80024ea:	69c9      	ldr	r1, [r1, #28]
 80024ec:	7809      	ldrb	r1, [r1, #0]
 80024ee:	6838      	ldr	r0, [r7, #0]
 80024f0:	1882      	adds	r2, r0, r2
 80024f2:	f882 102e 	strb.w	r1, [r2, #46]	; 0x2e
 80024f6:	f103 0301 	add.w	r3, r3, #1
 80024fa:	b29a      	uxth	r2, r3
 80024fc:	683b      	ldr	r3, [r7, #0]
 80024fe:	851a      	strh	r2, [r3, #40]	; 0x28
 8002500:	e004      	b.n	800250c <http_send_data+0x434>
            } else {
              /* The tag was too long so ignore it. */
              hs->tag_state = TAG_NONE;
 8002502:	683b      	ldr	r3, [r7, #0]
 8002504:	f04f 0200 	mov.w	r2, #0
 8002508:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
            }
          }

          /* Move on to the next character in the buffer */
          hs->parse_left--;
 800250c:	683b      	ldr	r3, [r7, #0]
 800250e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002510:	f103 32ff 	add.w	r2, r3, #4294967295
 8002514:	683b      	ldr	r3, [r7, #0]
 8002516:	625a      	str	r2, [r3, #36]	; 0x24
          hs->parsed++;
 8002518:	683b      	ldr	r3, [r7, #0]
 800251a:	69db      	ldr	r3, [r3, #28]
 800251c:	f103 0201 	add.w	r2, r3, #1
 8002520:	683b      	ldr	r3, [r7, #0]
 8002522:	61da      	str	r2, [r3, #28]

          break;
 8002524:	e12f      	b.n	8002786 <http_send_data+0x6ae>

        /* We are looking for the end of the lead-out marker. */
        case TAG_LEADOUT:
          /* Remove leading whitespace between the tag leading and the first
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 8002526:	683b      	ldr	r3, [r7, #0]
 8002528:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800252a:	2b00      	cmp	r3, #0
 800252c:	d120      	bne.n	8002570 <http_send_data+0x498>
 800252e:	683b      	ldr	r3, [r7, #0]
 8002530:	69db      	ldr	r3, [r3, #28]
 8002532:	781b      	ldrb	r3, [r3, #0]
 8002534:	2b20      	cmp	r3, #32
 8002536:	d00e      	beq.n	8002556 <http_send_data+0x47e>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 8002538:	683b      	ldr	r3, [r7, #0]
 800253a:	69db      	ldr	r3, [r3, #28]
 800253c:	781b      	ldrb	r3, [r3, #0]

        /* We are looking for the end of the lead-out marker. */
        case TAG_LEADOUT:
          /* Remove leading whitespace between the tag leading and the first
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
 800253e:	2b09      	cmp	r3, #9
 8002540:	d009      	beq.n	8002556 <http_send_data+0x47e>
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 8002542:	683b      	ldr	r3, [r7, #0]
 8002544:	69db      	ldr	r3, [r3, #28]
 8002546:	781b      	ldrb	r3, [r3, #0]
 8002548:	2b0a      	cmp	r3, #10
 800254a:	d004      	beq.n	8002556 <http_send_data+0x47e>
             (*hs->parsed == '\r'))) {
 800254c:	683b      	ldr	r3, [r7, #0]
 800254e:	69db      	ldr	r3, [r3, #28]
 8002550:	781b      	ldrb	r3, [r3, #0]
        /* We are looking for the end of the lead-out marker. */
        case TAG_LEADOUT:
          /* Remove leading whitespace between the tag leading and the first
           * tag leadout character. */
          if((hs->tag_index == 0) && ((*hs->parsed == ' ') ||
             (*hs->parsed == '\t') || (*hs->parsed == '\n') ||
 8002552:	2b0d      	cmp	r3, #13
 8002554:	d10c      	bne.n	8002570 <http_send_data+0x498>
             (*hs->parsed == '\r'))) {
            /* Move on to the next character in the buffer */
            hs->parse_left--;
 8002556:	683b      	ldr	r3, [r7, #0]
 8002558:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800255a:	f103 32ff 	add.w	r2, r3, #4294967295
 800255e:	683b      	ldr	r3, [r7, #0]
 8002560:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 8002562:	683b      	ldr	r3, [r7, #0]
 8002564:	69db      	ldr	r3, [r3, #28]
 8002566:	f103 0201 	add.w	r2, r3, #1
 800256a:	683b      	ldr	r3, [r7, #0]
 800256c:	61da      	str	r2, [r3, #28]
            break;
 800256e:	e10a      	b.n	8002786 <http_send_data+0x6ae>
          }

          /* Have we found the next character we expect for the tag leadout? */
          if(*hs->parsed == g_pcTagLeadOut[hs->tag_index]) {
 8002570:	683b      	ldr	r3, [r7, #0]
 8002572:	69db      	ldr	r3, [r3, #28]
 8002574:	781a      	ldrb	r2, [r3, #0]
 8002576:	f246 43b4 	movw	r3, #25780	; 0x64b4
 800257a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800257e:	6819      	ldr	r1, [r3, #0]
 8002580:	683b      	ldr	r3, [r7, #0]
 8002582:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002584:	18cb      	adds	r3, r1, r3
 8002586:	781b      	ldrb	r3, [r3, #0]
 8002588:	429a      	cmp	r2, r3
 800258a:	d162      	bne.n	8002652 <http_send_data+0x57a>
            /* Yes - move to the next one unless we have found the complete
             * leadout, in which case we need to call the client to process
             * the tag. */

            /* Move on to the next character in the buffer */
            hs->parse_left--;
 800258c:	683b      	ldr	r3, [r7, #0]
 800258e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002590:	f103 32ff 	add.w	r2, r3, #4294967295
 8002594:	683b      	ldr	r3, [r7, #0]
 8002596:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 8002598:	683b      	ldr	r3, [r7, #0]
 800259a:	69db      	ldr	r3, [r3, #28]
 800259c:	f103 0201 	add.w	r2, r3, #1
 80025a0:	683b      	ldr	r3, [r7, #0]
 80025a2:	61da      	str	r2, [r3, #28]

            if(hs->tag_index == (LEN_TAG_LEAD_OUT - 1)) {
 80025a4:	683b      	ldr	r3, [r7, #0]
 80025a6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80025a8:	2b02      	cmp	r3, #2
 80025aa:	d14a      	bne.n	8002642 <http_send_data+0x56a>
              /* Call the client to ask for the insert string for the
               * tag we just found. */
#if LWIP_HTTPD_SSI_MULTIPART
              hs->tag_part = 0; /* start with tag part 0 */
#endif /* LWIP_HTTPD_SSI_MULTIPART */
              get_tag_insert(hs);
 80025ac:	6838      	ldr	r0, [r7, #0]
 80025ae:	f7ff fcef 	bl	8001f90 <get_tag_insert>

              /* Next time through, we are going to be sending data
               * immediately, either the end of the block we start
               * sending here or the insert string. */
              hs->tag_index = 0;
 80025b2:	683b      	ldr	r3, [r7, #0]
 80025b4:	f04f 0200 	mov.w	r2, #0
 80025b8:	851a      	strh	r2, [r3, #40]	; 0x28
              hs->tag_state = TAG_SENDING;
 80025ba:	683b      	ldr	r3, [r7, #0]
 80025bc:	f04f 0204 	mov.w	r2, #4
 80025c0:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
              hs->tag_end = hs->parsed;
 80025c4:	683b      	ldr	r3, [r7, #0]
 80025c6:	69da      	ldr	r2, [r3, #28]
 80025c8:	683b      	ldr	r3, [r7, #0]
 80025ca:	621a      	str	r2, [r3, #32]
              hs->parsed = hs->tag_started;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/

              /* If there is any unsent data in the buffer prior to the
               * tag, we need to send it now. */
              if (hs->tag_end > hs->file) {
 80025cc:	683b      	ldr	r3, [r7, #0]
 80025ce:	6a1a      	ldr	r2, [r3, #32]
 80025d0:	683b      	ldr	r3, [r7, #0]
 80025d2:	685b      	ldr	r3, [r3, #4]
 80025d4:	429a      	cmp	r2, r3
 80025d6:	f240 80d3 	bls.w	8002780 <http_send_data+0x6a8>
                /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
                if(len > hs->tag_end - hs->file) {
 80025da:	89bb      	ldrh	r3, [r7, #12]
 80025dc:	461a      	mov	r2, r3
 80025de:	683b      	ldr	r3, [r7, #0]
 80025e0:	6a1b      	ldr	r3, [r3, #32]
 80025e2:	4619      	mov	r1, r3
 80025e4:	683b      	ldr	r3, [r7, #0]
 80025e6:	685b      	ldr	r3, [r3, #4]
 80025e8:	1acb      	subs	r3, r1, r3
 80025ea:	429a      	cmp	r2, r3
 80025ec:	dd07      	ble.n	80025fe <http_send_data+0x526>
                  len = (u16_t)(hs->tag_end - hs->file);
 80025ee:	683b      	ldr	r3, [r7, #0]
 80025f0:	6a1b      	ldr	r3, [r3, #32]
 80025f2:	461a      	mov	r2, r3
 80025f4:	683b      	ldr	r3, [r7, #0]
 80025f6:	685b      	ldr	r3, [r3, #4]
 80025f8:	1ad3      	subs	r3, r2, r3
 80025fa:	b29b      	uxth	r3, r3
 80025fc:	81bb      	strh	r3, [r7, #12]
                  /* we would include the tag in sending */
                  len = (u16_t)(hs->tag_started - hs->file);
                }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/

                err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 80025fe:	683b      	ldr	r3, [r7, #0]
 8002600:	685a      	ldr	r2, [r3, #4]
 8002602:	f107 030c 	add.w	r3, r7, #12
 8002606:	6878      	ldr	r0, [r7, #4]
 8002608:	4611      	mov	r1, r2
 800260a:	461a      	mov	r2, r3
 800260c:	f04f 0301 	mov.w	r3, #1
 8002610:	f7ff fbd2 	bl	8001db8 <http_write>
 8002614:	4603      	mov	r3, r0
 8002616:	75fb      	strb	r3, [r7, #23]
                if (err == ERR_OK) {
 8002618:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800261c:	2b00      	cmp	r3, #0
 800261e:	f040 80af 	bne.w	8002780 <http_send_data+0x6a8>
                  data_to_send = true;
 8002622:	f04f 0301 	mov.w	r3, #1
 8002626:	75bb      	strb	r3, [r7, #22]
                  if(hs->tag_started <= hs->file) {
                    /* pretend to have sent the tag, too */
                    len += hs->tag_end - hs->tag_started;
                  }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
                  hs->file += len;
 8002628:	683b      	ldr	r3, [r7, #0]
 800262a:	685a      	ldr	r2, [r3, #4]
 800262c:	89bb      	ldrh	r3, [r7, #12]
 800262e:	18d2      	adds	r2, r2, r3
 8002630:	683b      	ldr	r3, [r7, #0]
 8002632:	605a      	str	r2, [r3, #4]
                  hs->left -= len;
 8002634:	683b      	ldr	r3, [r7, #0]
 8002636:	695a      	ldr	r2, [r3, #20]
 8002638:	89bb      	ldrh	r3, [r7, #12]
 800263a:	1ad2      	subs	r2, r2, r3
 800263c:	683b      	ldr	r3, [r7, #0]
 800263e:	615a      	str	r2, [r3, #20]
             * back to idle state. */
            hs->parse_left--;
            hs->parsed++;
            hs->tag_state = TAG_NONE;
          }
          break;
 8002640:	e09e      	b.n	8002780 <http_send_data+0x6a8>
                  hs->file += len;
                  hs->left -= len;
                }
              }
            } else {
              hs->tag_index++;
 8002642:	683b      	ldr	r3, [r7, #0]
 8002644:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002646:	f103 0301 	add.w	r3, r3, #1
 800264a:	b29a      	uxth	r2, r3
 800264c:	683b      	ldr	r3, [r7, #0]
 800264e:	851a      	strh	r2, [r3, #40]	; 0x28
             * back to idle state. */
            hs->parse_left--;
            hs->parsed++;
            hs->tag_state = TAG_NONE;
          }
          break;
 8002650:	e096      	b.n	8002780 <http_send_data+0x6a8>
              hs->tag_index++;
            }
          } else {
            /* We found an unexpected character so this is not a tag. Move
             * back to idle state. */
            hs->parse_left--;
 8002652:	683b      	ldr	r3, [r7, #0]
 8002654:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002656:	f103 32ff 	add.w	r2, r3, #4294967295
 800265a:	683b      	ldr	r3, [r7, #0]
 800265c:	625a      	str	r2, [r3, #36]	; 0x24
            hs->parsed++;
 800265e:	683b      	ldr	r3, [r7, #0]
 8002660:	69db      	ldr	r3, [r3, #28]
 8002662:	f103 0201 	add.w	r2, r3, #1
 8002666:	683b      	ldr	r3, [r7, #0]
 8002668:	61da      	str	r2, [r3, #28]
            hs->tag_state = TAG_NONE;
 800266a:	683b      	ldr	r3, [r7, #0]
 800266c:	f04f 0200 	mov.w	r2, #0
 8002670:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
          }
          break;
 8002674:	e084      	b.n	8002780 <http_send_data+0x6a8>
         * from the file prior to the insert point or the insert string itself.
         */
        case TAG_SENDING:
          /* Do we have any remaining file data to send from the buffer prior
           * to the tag? */
          if(hs->tag_end > hs->file) {
 8002676:	683b      	ldr	r3, [r7, #0]
 8002678:	6a1a      	ldr	r2, [r3, #32]
 800267a:	683b      	ldr	r3, [r7, #0]
 800267c:	685b      	ldr	r3, [r3, #4]
 800267e:	429a      	cmp	r2, r3
 8002680:	d939      	bls.n	80026f6 <http_send_data+0x61e>
            /* How much of the data can we send? */
#if LWIP_HTTPD_SSI_INCLUDE_TAG
            if(len > hs->tag_end - hs->file) {
 8002682:	89bb      	ldrh	r3, [r7, #12]
 8002684:	461a      	mov	r2, r3
 8002686:	683b      	ldr	r3, [r7, #0]
 8002688:	6a1b      	ldr	r3, [r3, #32]
 800268a:	4619      	mov	r1, r3
 800268c:	683b      	ldr	r3, [r7, #0]
 800268e:	685b      	ldr	r3, [r3, #4]
 8002690:	1acb      	subs	r3, r1, r3
 8002692:	429a      	cmp	r2, r3
 8002694:	dd07      	ble.n	80026a6 <http_send_data+0x5ce>
              len = (u16_t)(hs->tag_end - hs->file);
 8002696:	683b      	ldr	r3, [r7, #0]
 8002698:	6a1b      	ldr	r3, [r3, #32]
 800269a:	461a      	mov	r2, r3
 800269c:	683b      	ldr	r3, [r7, #0]
 800269e:	685b      	ldr	r3, [r3, #4]
 80026a0:	1ad3      	subs	r3, r2, r3
 80026a2:	b29b      	uxth	r3, r3
 80026a4:	81bb      	strh	r3, [r7, #12]
            if (len > hs->tag_started - hs->file) {
              /* we would include the tag in sending */
              len = (u16_t)(hs->tag_started - hs->file);
            }
#endif /* LWIP_HTTPD_SSI_INCLUDE_TAG*/
            if (len != 0) {
 80026a6:	89bb      	ldrh	r3, [r7, #12]
 80026a8:	2b00      	cmp	r3, #0
 80026aa:	d00d      	beq.n	80026c8 <http_send_data+0x5f0>
              err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 80026ac:	683b      	ldr	r3, [r7, #0]
 80026ae:	685a      	ldr	r2, [r3, #4]
 80026b0:	f107 030c 	add.w	r3, r7, #12
 80026b4:	6878      	ldr	r0, [r7, #4]
 80026b6:	4611      	mov	r1, r2
 80026b8:	461a      	mov	r2, r3
 80026ba:	f04f 0301 	mov.w	r3, #1
 80026be:	f7ff fb7b 	bl	8001db8 <http_write>
 80026c2:	4603      	mov	r3, r0
 80026c4:	75fb      	strb	r3, [r7, #23]
 80026c6:	e002      	b.n	80026ce <http_send_data+0x5f6>
            } else {
              err = ERR_OK;
 80026c8:	f04f 0300 	mov.w	r3, #0
 80026cc:	75fb      	strb	r3, [r7, #23]
            }
            if (err == ERR_OK) {
 80026ce:	f997 3017 	ldrsb.w	r3, [r7, #23]
 80026d2:	2b00      	cmp	r3, #0
 80026d4:	d157      	bne.n	8002786 <http_send_data+0x6ae>
              data_to_send = true;
 80026d6:	f04f 0301 	mov.w	r3, #1
 80026da:	75bb      	strb	r3, [r7, #22]
              if(hs->tag_started <= hs->file) {
                /* pretend to have sent the tag, too */
                len += hs->tag_end - hs->tag_started;
              }
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
              hs->file += len;
 80026dc:	683b      	ldr	r3, [r7, #0]
 80026de:	685a      	ldr	r2, [r3, #4]
 80026e0:	89bb      	ldrh	r3, [r7, #12]
 80026e2:	18d2      	adds	r2, r2, r3
 80026e4:	683b      	ldr	r3, [r7, #0]
 80026e6:	605a      	str	r2, [r3, #4]
              hs->left -= len;
 80026e8:	683b      	ldr	r3, [r7, #0]
 80026ea:	695a      	ldr	r2, [r3, #20]
 80026ec:	89bb      	ldrh	r3, [r7, #12]
 80026ee:	1ad2      	subs	r2, r2, r3
 80026f0:	683b      	ldr	r3, [r7, #0]
 80026f2:	615a      	str	r2, [r3, #20]
 80026f4:	e047      	b.n	8002786 <http_send_data+0x6ae>
              }
            }
#endif /* LWIP_HTTPD_SSI_MULTIPART */

            /* Do we still have insert data left to send? */
            if(hs->tag_index < hs->tag_insert_len) {
 80026f6:	683b      	ldr	r3, [r7, #0]
 80026f8:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 80026fa:	683b      	ldr	r3, [r7, #0]
 80026fc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80026fe:	429a      	cmp	r2, r3
 8002700:	d232      	bcs.n	8002768 <http_send_data+0x690>
              /* We are sending the insert string itself. How much of the
               * insert can we send? */
              if(len > (hs->tag_insert_len - hs->tag_index)) {
 8002702:	89bb      	ldrh	r3, [r7, #12]
 8002704:	461a      	mov	r2, r3
 8002706:	683b      	ldr	r3, [r7, #0]
 8002708:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800270a:	4619      	mov	r1, r3
 800270c:	683b      	ldr	r3, [r7, #0]
 800270e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002710:	1acb      	subs	r3, r1, r3
 8002712:	429a      	cmp	r2, r3
 8002714:	dd06      	ble.n	8002724 <http_send_data+0x64c>
                len = (hs->tag_insert_len - hs->tag_index);
 8002716:	683b      	ldr	r3, [r7, #0]
 8002718:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
 800271a:	683b      	ldr	r3, [r7, #0]
 800271c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800271e:	1ad3      	subs	r3, r2, r3
 8002720:	b29b      	uxth	r3, r3
 8002722:	81bb      	strh	r3, [r7, #12]

              /* Note that we set the copy flag here since we only have a
               * single tag insert buffer per connection. If we don't do
               * this, insert corruption can occur if more than one insert
               * is processed before we call tcp_output. */
              err = http_write(pcb, &(hs->tag_insert[hs->tag_index]), &len,
 8002724:	683b      	ldr	r3, [r7, #0]
 8002726:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8002728:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800272c:	683a      	ldr	r2, [r7, #0]
 800272e:	18d3      	adds	r3, r2, r3
 8002730:	f103 0207 	add.w	r2, r3, #7
 8002734:	f107 030c 	add.w	r3, r7, #12
 8002738:	6878      	ldr	r0, [r7, #4]
 800273a:	4611      	mov	r1, r2
 800273c:	461a      	mov	r2, r3
 800273e:	f04f 0301 	mov.w	r3, #1
 8002742:	f7ff fb39 	bl	8001db8 <http_write>
 8002746:	4603      	mov	r3, r0
 8002748:	75fb      	strb	r3, [r7, #23]
                               HTTP_IS_TAG_VOLATILE(hs));
              if (err == ERR_OK) {
 800274a:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800274e:	2b00      	cmp	r3, #0
 8002750:	d118      	bne.n	8002784 <http_send_data+0x6ac>
                data_to_send = true;
 8002752:	f04f 0301 	mov.w	r3, #1
 8002756:	75bb      	strb	r3, [r7, #22]
                hs->tag_index += len;
 8002758:	683b      	ldr	r3, [r7, #0]
 800275a:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 800275c:	89bb      	ldrh	r3, [r7, #12]
 800275e:	18d3      	adds	r3, r2, r3
 8002760:	b29a      	uxth	r2, r3
 8002762:	683b      	ldr	r3, [r7, #0]
 8002764:	851a      	strh	r2, [r3, #40]	; 0x28
              hs->tag_state = TAG_NONE;
#if !LWIP_HTTPD_SSI_INCLUDE_TAG
              hs->parsed = hs->tag_end;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
            }
            break;
 8002766:	e00d      	b.n	8002784 <http_send_data+0x6ac>
              }
            } else {
              /* We have sent all the insert data so go back to looking for
               * a new tag. */
              LWIP_DEBUGF(HTTPD_DEBUG, ("Everything sent.\n"));
              hs->tag_index = 0;
 8002768:	683b      	ldr	r3, [r7, #0]
 800276a:	f04f 0200 	mov.w	r2, #0
 800276e:	851a      	strh	r2, [r3, #40]	; 0x28
              hs->tag_state = TAG_NONE;
 8002770:	683b      	ldr	r3, [r7, #0]
 8002772:	f04f 0200 	mov.w	r2, #0
 8002776:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
#if !LWIP_HTTPD_SSI_INCLUDE_TAG
              hs->parsed = hs->tag_end;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
            }
            break;
 800277a:	e003      	b.n	8002784 <http_send_data+0x6ac>

    LWIP_DEBUGF(HTTPD_DEBUG, ("State %d, %d left\n", hs->tag_state, hs->parse_left));

    /* We have sent all the data that was already parsed so continue parsing
     * the buffer contents looking for SSI tags. */
    while((hs->parse_left) && (err == ERR_OK)) {
 800277c:	bf00      	nop
 800277e:	e002      	b.n	8002786 <http_send_data+0x6ae>
             * back to idle state. */
            hs->parse_left--;
            hs->parsed++;
            hs->tag_state = TAG_NONE;
          }
          break;
 8002780:	bf00      	nop
 8002782:	e000      	b.n	8002786 <http_send_data+0x6ae>
              hs->tag_state = TAG_NONE;
#if !LWIP_HTTPD_SSI_INCLUDE_TAG
              hs->parsed = hs->tag_end;
#endif /* !LWIP_HTTPD_SSI_INCLUDE_TAG*/
            }
            break;
 8002784:	bf00      	nop

    LWIP_DEBUGF(HTTPD_DEBUG, ("State %d, %d left\n", hs->tag_state, hs->parse_left));

    /* We have sent all the data that was already parsed so continue parsing
     * the buffer contents looking for SSI tags. */
    while((hs->parse_left) && (err == ERR_OK)) {
 8002786:	683b      	ldr	r3, [r7, #0]
 8002788:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800278a:	2b00      	cmp	r3, #0
 800278c:	d004      	beq.n	8002798 <http_send_data+0x6c0>
 800278e:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8002792:	2b00      	cmp	r3, #0
 8002794:	f43f adbb 	beq.w	800230e <http_send_data+0x236>
    }

    /* If we drop out of the end of the for loop, this implies we must have
     * file data to send so send it now. In TAG_SENDING state, we've already
     * handled this so skip the send if that's the case. */
    if((hs->tag_state != TAG_SENDING) && (hs->parsed > hs->file)) {
 8002798:	683b      	ldr	r3, [r7, #0]
 800279a:	f893 30f8 	ldrb.w	r3, [r3, #248]	; 0xf8
 800279e:	2b04      	cmp	r3, #4
 80027a0:	d04c      	beq.n	800283c <http_send_data+0x764>
 80027a2:	683b      	ldr	r3, [r7, #0]
 80027a4:	69da      	ldr	r2, [r3, #28]
 80027a6:	683b      	ldr	r3, [r7, #0]
 80027a8:	685b      	ldr	r3, [r3, #4]
 80027aa:	429a      	cmp	r2, r3
 80027ac:	d946      	bls.n	800283c <http_send_data+0x764>
      /* We cannot send more data than space available in the send
         buffer. */
      if (tcp_sndbuf(pcb) < (hs->parsed - hs->file)) {
 80027ae:	687b      	ldr	r3, [r7, #4]
 80027b0:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 80027b4:	461a      	mov	r2, r3
 80027b6:	683b      	ldr	r3, [r7, #0]
 80027b8:	69db      	ldr	r3, [r3, #28]
 80027ba:	4619      	mov	r1, r3
 80027bc:	683b      	ldr	r3, [r7, #0]
 80027be:	685b      	ldr	r3, [r3, #4]
 80027c0:	1acb      	subs	r3, r1, r3
 80027c2:	429a      	cmp	r2, r3
 80027c4:	da04      	bge.n	80027d0 <http_send_data+0x6f8>
        len = tcp_sndbuf(pcb);
 80027c6:	687b      	ldr	r3, [r7, #4]
 80027c8:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 80027cc:	81bb      	strh	r3, [r7, #12]
 80027ce:	e007      	b.n	80027e0 <http_send_data+0x708>
      } else {
        LWIP_ASSERT("Data size does not fit into u16_t!",
                    (hs->parsed - hs->file) <= 0xffff);
        len = (u16_t)(hs->parsed - hs->file);
 80027d0:	683b      	ldr	r3, [r7, #0]
 80027d2:	69db      	ldr	r3, [r3, #28]
 80027d4:	461a      	mov	r2, r3
 80027d6:	683b      	ldr	r3, [r7, #0]
 80027d8:	685b      	ldr	r3, [r3, #4]
 80027da:	1ad3      	subs	r3, r2, r3
 80027dc:	b29b      	uxth	r3, r3
 80027de:	81bb      	strh	r3, [r7, #12]
      }
      if(len > (2 * tcp_mss(pcb))) {
 80027e0:	89bb      	ldrh	r3, [r7, #12]
 80027e2:	461a      	mov	r2, r3
 80027e4:	687b      	ldr	r3, [r7, #4]
 80027e6:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80027e8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80027ec:	429a      	cmp	r2, r3
 80027ee:	dd05      	ble.n	80027fc <http_send_data+0x724>
        len = 2 * tcp_mss(pcb);
 80027f0:	687b      	ldr	r3, [r7, #4]
 80027f2:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80027f4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80027f8:	b29b      	uxth	r3, r3
 80027fa:	81bb      	strh	r3, [r7, #12]
      }

      err = http_write(pcb, hs->file, &len, HTTP_IS_DATA_VOLATILE(hs));
 80027fc:	683b      	ldr	r3, [r7, #0]
 80027fe:	685a      	ldr	r2, [r3, #4]
 8002800:	f107 030c 	add.w	r3, r7, #12
 8002804:	6878      	ldr	r0, [r7, #4]
 8002806:	4611      	mov	r1, r2
 8002808:	461a      	mov	r2, r3
 800280a:	f04f 0301 	mov.w	r3, #1
 800280e:	f7ff fad3 	bl	8001db8 <http_write>
 8002812:	4603      	mov	r3, r0
 8002814:	75fb      	strb	r3, [r7, #23]
      if (err == ERR_OK) {
 8002816:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800281a:	2b00      	cmp	r3, #0
 800281c:	d10e      	bne.n	800283c <http_send_data+0x764>
        data_to_send = true;
 800281e:	f04f 0301 	mov.w	r3, #1
 8002822:	75bb      	strb	r3, [r7, #22]
        hs->file += len;
 8002824:	683b      	ldr	r3, [r7, #0]
 8002826:	685a      	ldr	r2, [r3, #4]
 8002828:	89bb      	ldrh	r3, [r7, #12]
 800282a:	18d2      	adds	r2, r2, r3
 800282c:	683b      	ldr	r3, [r7, #0]
 800282e:	605a      	str	r2, [r3, #4]
        hs->left -= len;
 8002830:	683b      	ldr	r3, [r7, #0]
 8002832:	695a      	ldr	r2, [r3, #20]
 8002834:	89bb      	ldrh	r3, [r7, #12]
 8002836:	1ad2      	subs	r2, r2, r3
 8002838:	683b      	ldr	r3, [r7, #0]
 800283a:	615a      	str	r2, [r3, #20]
      }
    }
  }
#endif /* LWIP_HTTPD_SSI */

  if((hs->left == 0) && (fs_bytes_left(hs->handle) <= 0)) {
 800283c:	683b      	ldr	r3, [r7, #0]
 800283e:	695b      	ldr	r3, [r3, #20]
 8002840:	2b00      	cmp	r3, #0
 8002842:	d10e      	bne.n	8002862 <http_send_data+0x78a>
 8002844:	683b      	ldr	r3, [r7, #0]
 8002846:	681b      	ldr	r3, [r3, #0]
 8002848:	4618      	mov	r0, r3
 800284a:	f7ff fa29 	bl	8001ca0 <fs_bytes_left>
 800284e:	4603      	mov	r3, r0
 8002850:	2b00      	cmp	r3, #0
 8002852:	dc06      	bgt.n	8002862 <http_send_data+0x78a>
    /* We reached the end of the file so this request is done.
     * This adds the FIN flag right into the last data segment.
     * @todo: don't close here for HTTP/1.1? */
    LWIP_DEBUGF(HTTPD_DEBUG, ("End of file.\n"));
    http_close_conn(pcb, hs);
 8002854:	6878      	ldr	r0, [r7, #4]
 8002856:	6839      	ldr	r1, [r7, #0]
 8002858:	f7ff fae4 	bl	8001e24 <http_close_conn>
    return 0;
 800285c:	f04f 0300 	mov.w	r3, #0
 8002860:	e000      	b.n	8002864 <http_send_data+0x78c>
  }
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("send_data end.\n"));
  return data_to_send;
 8002862:	7dbb      	ldrb	r3, [r7, #22]
}
 8002864:	4618      	mov	r0, r3
 8002866:	f107 0718 	add.w	r7, r7, #24
 800286a:	46bd      	mov	sp, r7
 800286c:	bd80      	pop	{r7, pc}
 800286e:	bf00      	nop

08002870 <http_find_error_file>:
 * @return ERR_OK if file was found and hs has been initialized correctly
 *         another err_t otherwise
 */
static err_t
http_find_error_file(struct http_state *hs, u16_t error_nr)
{
 8002870:	b580      	push	{r7, lr}
 8002872:	b086      	sub	sp, #24
 8002874:	af00      	add	r7, sp, #0
 8002876:	6078      	str	r0, [r7, #4]
 8002878:	460b      	mov	r3, r1
 800287a:	807b      	strh	r3, [r7, #2]
  const char *uri1, *uri2, *uri3;
  struct fs_file *file;

  if (error_nr == 501) {
 800287c:	887a      	ldrh	r2, [r7, #2]
 800287e:	f240 13f5 	movw	r3, #501	; 0x1f5
 8002882:	429a      	cmp	r2, r3
 8002884:	d10f      	bne.n	80028a6 <http_find_error_file+0x36>
    uri1 = "/501.html";
 8002886:	f246 43d4 	movw	r3, #25812	; 0x64d4
 800288a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800288e:	617b      	str	r3, [r7, #20]
    uri2 = "/501.htm";
 8002890:	f246 43e0 	movw	r3, #25824	; 0x64e0
 8002894:	f6c0 0302 	movt	r3, #2050	; 0x802
 8002898:	613b      	str	r3, [r7, #16]
    uri3 = "/501.shtml";
 800289a:	f246 43ec 	movw	r3, #25836	; 0x64ec
 800289e:	f6c0 0302 	movt	r3, #2050	; 0x802
 80028a2:	60fb      	str	r3, [r7, #12]
 80028a4:	e00e      	b.n	80028c4 <http_find_error_file+0x54>
  } else {
    /* 400 (bad request is the default) */
    uri1 = "/400.txt";
 80028a6:	f246 43f8 	movw	r3, #25848	; 0x64f8
 80028aa:	f6c0 0302 	movt	r3, #2050	; 0x802
 80028ae:	617b      	str	r3, [r7, #20]
    uri2 = "/400.htm";
 80028b0:	f246 5304 	movw	r3, #25860	; 0x6504
 80028b4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80028b8:	613b      	str	r3, [r7, #16]
    uri3 = "/400.shtml";
 80028ba:	f246 5310 	movw	r3, #25872	; 0x6510
 80028be:	f6c0 0302 	movt	r3, #2050	; 0x802
 80028c2:	60fb      	str	r3, [r7, #12]
  }
  file = fs_open(uri1);
 80028c4:	6978      	ldr	r0, [r7, #20]
 80028c6:	f7ff f97d 	bl	8001bc4 <fs_open>
 80028ca:	60b8      	str	r0, [r7, #8]
  if (file == NULL) {
 80028cc:	68bb      	ldr	r3, [r7, #8]
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d110      	bne.n	80028f4 <http_find_error_file+0x84>
    file = fs_open(uri2);
 80028d2:	6938      	ldr	r0, [r7, #16]
 80028d4:	f7ff f976 	bl	8001bc4 <fs_open>
 80028d8:	60b8      	str	r0, [r7, #8]
    if (file == NULL) {
 80028da:	68bb      	ldr	r3, [r7, #8]
 80028dc:	2b00      	cmp	r3, #0
 80028de:	d109      	bne.n	80028f4 <http_find_error_file+0x84>
      file = fs_open(uri3);
 80028e0:	68f8      	ldr	r0, [r7, #12]
 80028e2:	f7ff f96f 	bl	8001bc4 <fs_open>
 80028e6:	60b8      	str	r0, [r7, #8]
      if (file == NULL) {
 80028e8:	68bb      	ldr	r3, [r7, #8]
 80028ea:	2b00      	cmp	r3, #0
 80028ec:	d102      	bne.n	80028f4 <http_find_error_file+0x84>
        LWIP_DEBUGF(HTTPD_DEBUG, ("Error page for error %"U16_F" not found\n",
          error_nr));
        return ERR_ARG;
 80028ee:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 80028f2:	e008      	b.n	8002906 <http_find_error_file+0x96>
      }
    }
  }
  return http_init_file(hs, file, 0, NULL);
 80028f4:	6878      	ldr	r0, [r7, #4]
 80028f6:	68b9      	ldr	r1, [r7, #8]
 80028f8:	f04f 0200 	mov.w	r2, #0
 80028fc:	f04f 0300 	mov.w	r3, #0
 8002900:	f000 fa0c 	bl	8002d1c <http_init_file>
 8002904:	4603      	mov	r3, r0
 8002906:	b25b      	sxtb	r3, r3
}
 8002908:	4618      	mov	r0, r3
 800290a:	f107 0718 	add.w	r7, r7, #24
 800290e:	46bd      	mov	sp, r7
 8002910:	bd80      	pop	{r7, pc}
 8002912:	bf00      	nop

08002914 <http_get_404_file>:
 * @param uri pointer that receives the actual file name URI
 * @return file struct for the error page or NULL no matching file was found
 */
static struct fs_file *
http_get_404_file(const char **uri)
{
 8002914:	b580      	push	{r7, lr}
 8002916:	b084      	sub	sp, #16
 8002918:	af00      	add	r7, sp, #0
 800291a:	6078      	str	r0, [r7, #4]
  struct fs_file *file;

  *uri = "/404.html";
 800291c:	687a      	ldr	r2, [r7, #4]
 800291e:	f246 531c 	movw	r3, #25884	; 0x651c
 8002922:	f6c0 0302 	movt	r3, #2050	; 0x802
 8002926:	6013      	str	r3, [r2, #0]
#if HTTPD_FAT_FS
  file = fs_open("404.htm");
 8002928:	f246 5028 	movw	r0, #25896	; 0x6528
 800292c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002930:	f7ff f948 	bl	8001bc4 <fs_open>
 8002934:	60f8      	str	r0, [r7, #12]
#else
  file = fs_open(*uri);
#endif
  if(file == NULL) {
 8002936:	68fb      	ldr	r3, [r7, #12]
 8002938:	2b00      	cmp	r3, #0
 800293a:	d121      	bne.n	8002980 <http_get_404_file+0x6c>
    /* 404.html doesn't exist. Try 404.htm instead. */
    *uri = "/404.htm";
 800293c:	687a      	ldr	r2, [r7, #4]
 800293e:	f246 5330 	movw	r3, #25904	; 0x6530
 8002942:	f6c0 0302 	movt	r3, #2050	; 0x802
 8002946:	6013      	str	r3, [r2, #0]
    file = fs_open(*uri);
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	681b      	ldr	r3, [r3, #0]
 800294c:	4618      	mov	r0, r3
 800294e:	f7ff f939 	bl	8001bc4 <fs_open>
 8002952:	60f8      	str	r0, [r7, #12]
    if(file == NULL) {
 8002954:	68fb      	ldr	r3, [r7, #12]
 8002956:	2b00      	cmp	r3, #0
 8002958:	d112      	bne.n	8002980 <http_get_404_file+0x6c>
      /* 404.htm doesn't exist either. Try 404.shtml instead. */
      *uri = "/404.shtml";
 800295a:	687a      	ldr	r2, [r7, #4]
 800295c:	f246 533c 	movw	r3, #25916	; 0x653c
 8002960:	f6c0 0302 	movt	r3, #2050	; 0x802
 8002964:	6013      	str	r3, [r2, #0]
      file = fs_open(*uri);
 8002966:	687b      	ldr	r3, [r7, #4]
 8002968:	681b      	ldr	r3, [r3, #0]
 800296a:	4618      	mov	r0, r3
 800296c:	f7ff f92a 	bl	8001bc4 <fs_open>
 8002970:	60f8      	str	r0, [r7, #12]
      if(file == NULL) {
 8002972:	68fb      	ldr	r3, [r7, #12]
 8002974:	2b00      	cmp	r3, #0
 8002976:	d103      	bne.n	8002980 <http_get_404_file+0x6c>
        /* 404.htm doesn't exist either. Indicate to the caller that it should
         * send back a default 404 page.
         */
        *uri = NULL;
 8002978:	687b      	ldr	r3, [r7, #4]
 800297a:	f04f 0200 	mov.w	r2, #0
 800297e:	601a      	str	r2, [r3, #0]
      }
    }
  }

  return file;
 8002980:	68fb      	ldr	r3, [r7, #12]
}
 8002982:	4618      	mov	r0, r3
 8002984:	f107 0710 	add.w	r7, r7, #16
 8002988:	46bd      	mov	sp, r7
 800298a:	bd80      	pop	{r7, pc}

0800298c <http_parse_request>:
 *         ERR_INPROGRESS if request was OK so far but not fully received
 *         another err_t otherwise
 */
static err_t
http_parse_request(struct pbuf **inp, struct http_state *hs, struct tcp_pcb *pcb)
{
 800298c:	b580      	push	{r7, lr}
 800298e:	b090      	sub	sp, #64	; 0x40
 8002990:	af00      	add	r7, sp, #0
 8002992:	60f8      	str	r0, [r7, #12]
 8002994:	60b9      	str	r1, [r7, #8]
 8002996:	607a      	str	r2, [r7, #4]
  char *data;
  char *crlf;
  u16_t data_len;
  struct pbuf *p = *inp;
 8002998:	68fb      	ldr	r3, [r7, #12]
 800299a:	681b      	ldr	r3, [r3, #0]
 800299c:	637b      	str	r3, [r7, #52]	; 0x34

  LWIP_UNUSED_ARG(pcb); /* only used for post */
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("hs != NULL", hs != NULL);

  if ((hs->handle != NULL) || (hs->file != NULL)) {
 800299e:	68bb      	ldr	r3, [r7, #8]
 80029a0:	681b      	ldr	r3, [r3, #0]
 80029a2:	2b00      	cmp	r3, #0
 80029a4:	d103      	bne.n	80029ae <http_parse_request+0x22>
 80029a6:	68bb      	ldr	r3, [r7, #8]
 80029a8:	685b      	ldr	r3, [r3, #4]
 80029aa:	2b00      	cmp	r3, #0
 80029ac:	d002      	beq.n	80029b4 <http_parse_request+0x28>
    LWIP_DEBUGF(HTTPD_DEBUG, ("Received data while sending a file\n"));
    /* already sending a file */
    /* @todo: abort? */
    return ERR_USE;
 80029ae:	f04f 03f5 	mov.w	r3, #245	; 0xf5
 80029b2:	e0b7      	b.n	8002b24 <http_parse_request+0x198>
  LWIP_DEBUGF(HTTPD_DEBUG, ("Received %"U16_F" bytes\n", p->tot_len));

  /* first check allowed characters in this pbuf? */

  /* enqueue the pbuf */
  if (hs->req == NULL) {
 80029b4:	68bb      	ldr	r3, [r7, #8]
 80029b6:	689b      	ldr	r3, [r3, #8]
 80029b8:	2b00      	cmp	r3, #0
 80029ba:	d103      	bne.n	80029c4 <http_parse_request+0x38>
    LWIP_DEBUGF(HTTPD_DEBUG, ("First pbuf\n"));
    hs->req = p;
 80029bc:	68bb      	ldr	r3, [r7, #8]
 80029be:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80029c0:	609a      	str	r2, [r3, #8]
 80029c2:	e005      	b.n	80029d0 <http_parse_request+0x44>
  } else {
    LWIP_DEBUGF(HTTPD_DEBUG, ("pbuf enqueued\n"));
    pbuf_cat(hs->req, p);
 80029c4:	68bb      	ldr	r3, [r7, #8]
 80029c6:	689b      	ldr	r3, [r3, #8]
 80029c8:	4618      	mov	r0, r3
 80029ca:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80029cc:	f010 fafa 	bl	8012fc4 <pbuf_cat>
  }

  if (hs->req->next != NULL) {
 80029d0:	68bb      	ldr	r3, [r7, #8]
 80029d2:	689b      	ldr	r3, [r3, #8]
 80029d4:	681b      	ldr	r3, [r3, #0]
 80029d6:	2b00      	cmp	r3, #0
 80029d8:	d01b      	beq.n	8002a12 <http_parse_request+0x86>
    data_len = LWIP_MIN(hs->req->tot_len, LWIP_HTTPD_MAX_REQ_LENGTH);
 80029da:	68bb      	ldr	r3, [r7, #8]
 80029dc:	689b      	ldr	r3, [r3, #8]
 80029de:	891a      	ldrh	r2, [r3, #8]
 80029e0:	f240 33ff 	movw	r3, #1023	; 0x3ff
 80029e4:	429a      	cmp	r2, r3
 80029e6:	bf38      	it	cc
 80029e8:	4613      	movcc	r3, r2
 80029ea:	877b      	strh	r3, [r7, #58]	; 0x3a
    pbuf_copy_partial(hs->req, httpd_req_buf, data_len, 0);
 80029ec:	68bb      	ldr	r3, [r7, #8]
 80029ee:	689a      	ldr	r2, [r3, #8]
 80029f0:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80029f2:	4610      	mov	r0, r2
 80029f4:	f640 010c 	movw	r1, #2060	; 0x80c
 80029f8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80029fc:	461a      	mov	r2, r3
 80029fe:	f04f 0300 	mov.w	r3, #0
 8002a02:	f010 fbd3 	bl	80131ac <pbuf_copy_partial>
    data = httpd_req_buf;
 8002a06:	f640 030c 	movw	r3, #2060	; 0x80c
 8002a0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002a0e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8002a10:	e005      	b.n	8002a1e <http_parse_request+0x92>
  } else
#endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
  {
    data = (char *)p->payload;
 8002a12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002a14:	685b      	ldr	r3, [r3, #4]
 8002a16:	63fb      	str	r3, [r7, #60]	; 0x3c
    data_len = p->len;
 8002a18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002a1a:	895b      	ldrh	r3, [r3, #10]
 8002a1c:	877b      	strh	r3, [r7, #58]	; 0x3a
      LWIP_DEBUGF(HTTPD_DEBUG, ("Warning: incomplete header due to chained pbufs\n"));
    }
  }

  /* received enough data for minimal request? */
  if (data_len >= MIN_REQ_LEN) {
 8002a1e:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8002a20:	2b06      	cmp	r3, #6
 8002a22:	d965      	bls.n	8002af0 <http_parse_request+0x164>
    /* wait for CRLF before parsing anything */
    crlf = strnstr(data, CRLF, data_len);
 8002a24:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8002a26:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8002a28:	f246 5148 	movw	r1, #25928	; 0x6548
 8002a2c:	f6c0 0102 	movt	r1, #2050	; 0x802
 8002a30:	461a      	mov	r2, r3
 8002a32:	f7ff f945 	bl	8001cc0 <strnstr>
 8002a36:	6338      	str	r0, [r7, #48]	; 0x30
    if (crlf != NULL) {
 8002a38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002a3a:	2b00      	cmp	r3, #0
 8002a3c:	d058      	beq.n	8002af0 <http_parse_request+0x164>
#if LWIP_HTTPD_SUPPORT_POST
      int is_post = 0;
#endif /* LWIP_HTTPD_SUPPORT_POST */
      int is_09 = 0;
 8002a3e:	f04f 0300 	mov.w	r3, #0
 8002a42:	62fb      	str	r3, [r7, #44]	; 0x2c
      char *sp1, *sp2;
      u16_t left_len, uri_len;
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("CRLF received, parsing request\n"));
      /* parse method */
      if (!strncmp(data, "GET ", 4)) {
 8002a44:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8002a46:	f246 514c 	movw	r1, #25932	; 0x654c
 8002a4a:	f6c0 0102 	movt	r1, #2050	; 0x802
 8002a4e:	f04f 0204 	mov.w	r2, #4
 8002a52:	f022 f8a5 	bl	8024ba0 <strncmp>
 8002a56:	4603      	mov	r3, r0
 8002a58:	2b00      	cmp	r3, #0
 8002a5a:	d123      	bne.n	8002aa4 <http_parse_request+0x118>
        sp1 = data + 3;
 8002a5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002a5e:	f103 0303 	add.w	r3, r3, #3
 8002a62:	62bb      	str	r3, [r7, #40]	; 0x28
        LWIP_DEBUGF(HTTPD_DEBUG, ("Unsupported request method (not implemented): \"%s\"\n",
          data));
        return http_find_error_file(hs, 501);
      }
      /* if we come here, method is OK, parse URI */
      left_len = data_len - ((sp1 +1) - data);
 8002a64:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8002a66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a68:	f103 0301 	add.w	r3, r3, #1
 8002a6c:	1ad3      	subs	r3, r2, r3
 8002a6e:	b29a      	uxth	r2, r3
 8002a70:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8002a72:	18d3      	adds	r3, r2, r3
 8002a74:	84fb      	strh	r3, [r7, #38]	; 0x26
      sp2 = strnstr(sp1 + 1, " ", left_len);
 8002a76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a78:	f103 0201 	add.w	r2, r3, #1
 8002a7c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8002a7e:	4610      	mov	r0, r2
 8002a80:	f246 5154 	movw	r1, #25940	; 0x6554
 8002a84:	f6c0 0102 	movt	r1, #2050	; 0x802
 8002a88:	461a      	mov	r2, r3
 8002a8a:	f7ff f919 	bl	8001cc0 <strnstr>
 8002a8e:	6238      	str	r0, [r7, #32]
          goto badrequest;
        }
#endif /* LWIP_HTTPD_SUPPORT_POST */
      }
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
 8002a90:	6a3a      	ldr	r2, [r7, #32]
 8002a92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a94:	f103 0301 	add.w	r3, r3, #1
 8002a98:	1ad3      	subs	r3, r2, r3
 8002a9a:	83fb      	strh	r3, [r7, #30]
      if ((sp2 != 0) && (sp2 > sp1)) {
 8002a9c:	6a3b      	ldr	r3, [r7, #32]
 8002a9e:	2b00      	cmp	r3, #0
 8002aa0:	d10d      	bne.n	8002abe <http_parse_request+0x132>
 8002aa2:	e025      	b.n	8002af0 <http_parse_request+0x164>
        /* received GET request */
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Received POST request\n"));
#endif /* LWIP_HTTPD_SUPPORT_POST */
      } else {
        /* null-terminate the METHOD (pbuf is freed anyway wen returning) */
        data[4] = 0;
 8002aa4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002aa6:	f103 0304 	add.w	r3, r3, #4
 8002aaa:	f04f 0200 	mov.w	r2, #0
 8002aae:	701a      	strb	r2, [r3, #0]
        /* unsupported method! */
        LWIP_DEBUGF(HTTPD_DEBUG, ("Unsupported request method (not implemented): \"%s\"\n",
          data));
        return http_find_error_file(hs, 501);
 8002ab0:	68b8      	ldr	r0, [r7, #8]
 8002ab2:	f240 11f5 	movw	r1, #501	; 0x1f5
 8002ab6:	f7ff fedb 	bl	8002870 <http_find_error_file>
 8002aba:	4603      	mov	r3, r0
 8002abc:	e032      	b.n	8002b24 <http_parse_request+0x198>
        }
#endif /* LWIP_HTTPD_SUPPORT_POST */
      }
#endif /* LWIP_HTTPD_SUPPORT_V09 */
      uri_len = sp2 - (sp1 + 1);
      if ((sp2 != 0) && (sp2 > sp1)) {
 8002abe:	6a3a      	ldr	r2, [r7, #32]
 8002ac0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ac2:	429a      	cmp	r2, r3
 8002ac4:	d914      	bls.n	8002af0 <http_parse_request+0x164>
        char *uri = sp1 + 1;
 8002ac6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ac8:	f103 0301 	add.w	r3, r3, #1
 8002acc:	61bb      	str	r3, [r7, #24]
        /* null-terminate the METHOD (pbuf is freed anyway wen returning) */
        *sp1 = 0;
 8002ace:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ad0:	f04f 0200 	mov.w	r2, #0
 8002ad4:	701a      	strb	r2, [r3, #0]
        uri[uri_len] = 0;
 8002ad6:	8bfb      	ldrh	r3, [r7, #30]
 8002ad8:	69ba      	ldr	r2, [r7, #24]
 8002ada:	18d3      	adds	r3, r2, r3
 8002adc:	f04f 0200 	mov.w	r2, #0
 8002ae0:	701a      	strb	r2, [r3, #0]
          }
          return err;
        } else
#endif /* LWIP_HTTPD_SUPPORT_POST */
        {
          return http_find_file(hs, uri, is_09);
 8002ae2:	68b8      	ldr	r0, [r7, #8]
 8002ae4:	69b9      	ldr	r1, [r7, #24]
 8002ae6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002ae8:	f000 f822 	bl	8002b30 <http_find_file>
 8002aec:	4603      	mov	r3, r0
 8002aee:	e019      	b.n	8002b24 <http_parse_request+0x198>
      }
    }
  }

#if LWIP_HTTPD_SUPPORT_REQUESTLIST
  clen = pbuf_clen(hs->req);
 8002af0:	68bb      	ldr	r3, [r7, #8]
 8002af2:	689b      	ldr	r3, [r3, #8]
 8002af4:	4618      	mov	r0, r3
 8002af6:	f010 fa37 	bl	8012f68 <pbuf_clen>
 8002afa:	4603      	mov	r3, r0
 8002afc:	82fb      	strh	r3, [r7, #22]
  if ((hs->req->tot_len <= LWIP_HTTPD_REQ_BUFSIZE) &&
 8002afe:	68bb      	ldr	r3, [r7, #8]
 8002b00:	689b      	ldr	r3, [r3, #8]
 8002b02:	891a      	ldrh	r2, [r3, #8]
 8002b04:	f240 33ff 	movw	r3, #1023	; 0x3ff
 8002b08:	429a      	cmp	r2, r3
 8002b0a:	d805      	bhi.n	8002b18 <http_parse_request+0x18c>
 8002b0c:	8afb      	ldrh	r3, [r7, #22]
 8002b0e:	2b0a      	cmp	r3, #10
 8002b10:	d802      	bhi.n	8002b18 <http_parse_request+0x18c>
    (clen <= LWIP_HTTPD_REQ_QUEUELEN)) {
    /* request not fully received (too short or CRLF is missing) */
    return ERR_INPROGRESS;
 8002b12:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 8002b16:	e005      	b.n	8002b24 <http_parse_request+0x198>
#if LWIP_HTTPD_SUPPORT_POST
badrequest:
#endif /* LWIP_HTTPD_SUPPORT_POST */
    LWIP_DEBUGF(HTTPD_DEBUG, ("bad request\n"));
    /* could not parse request */
    return http_find_error_file(hs, 400);
 8002b18:	68b8      	ldr	r0, [r7, #8]
 8002b1a:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8002b1e:	f7ff fea7 	bl	8002870 <http_find_error_file>
 8002b22:	4603      	mov	r3, r0
 8002b24:	b25b      	sxtb	r3, r3
  }
}
 8002b26:	4618      	mov	r0, r3
 8002b28:	f107 0740 	add.w	r7, r7, #64	; 0x40
 8002b2c:	46bd      	mov	sp, r7
 8002b2e:	bd80      	pop	{r7, pc}

08002b30 <http_find_file>:
 * @return ERR_OK if file was found and hs has been initialized correctly
 *         another err_t otherwise
 */
static err_t
http_find_file(struct http_state *hs, const char *uri, int is_09)
{
 8002b30:	b590      	push	{r4, r7, lr}
 8002b32:	b08b      	sub	sp, #44	; 0x2c
 8002b34:	af00      	add	r7, sp, #0
 8002b36:	60f8      	str	r0, [r7, #12]
 8002b38:	60b9      	str	r1, [r7, #8]
 8002b3a:	607a      	str	r2, [r7, #4]
  size_t loop;
  struct fs_file *file = NULL;
 8002b3c:	f04f 0300 	mov.w	r3, #0
 8002b40:	623b      	str	r3, [r7, #32]
#if LWIP_HTTPD_SSI
  /*
   * By default, assume we will not be processing server-side-includes
   * tags
   */
  hs->tag_check = false;
 8002b42:	68fb      	ldr	r3, [r7, #12]
 8002b44:	f04f 0200 	mov.w	r2, #0
 8002b48:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
#endif /* LWIP_HTTPD_SSI */

  /* Have we been asked for the default root file? */
  if((uri[0] == '/') &&  (uri[1] == 0)) {
 8002b4c:	68bb      	ldr	r3, [r7, #8]
 8002b4e:	781b      	ldrb	r3, [r3, #0]
 8002b50:	2b2f      	cmp	r3, #47	; 0x2f
 8002b52:	d143      	bne.n	8002bdc <http_find_file+0xac>
 8002b54:	68bb      	ldr	r3, [r7, #8]
 8002b56:	f103 0301 	add.w	r3, r3, #1
 8002b5a:	781b      	ldrb	r3, [r3, #0]
 8002b5c:	2b00      	cmp	r3, #0
 8002b5e:	d13d      	bne.n	8002bdc <http_find_file+0xac>
    /* Try each of the configured default filenames until we find one
       that exists. */
    for (loop = 0; loop < NUM_DEFAULT_FILENAMES; loop++) {
 8002b60:	f04f 0300 	mov.w	r3, #0
 8002b64:	627b      	str	r3, [r7, #36]	; 0x24
 8002b66:	e026      	b.n	8002bb6 <http_find_file+0x86>
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Looking for %s...\n", g_psDefaultFilenames[loop].name));
      file = fs_open((char *)g_psDefaultFilenames[loop].name);
 8002b68:	f246 435c 	movw	r3, #25692	; 0x645c
 8002b6c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8002b70:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002b72:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002b76:	4618      	mov	r0, r3
 8002b78:	f7ff f824 	bl	8001bc4 <fs_open>
 8002b7c:	6238      	str	r0, [r7, #32]
      uri = (char *)g_psDefaultFilenames[loop].name;
 8002b7e:	f246 435c 	movw	r3, #25692	; 0x645c
 8002b82:	f6c0 0302 	movt	r3, #2050	; 0x802
 8002b86:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002b88:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8002b8c:	60bb      	str	r3, [r7, #8]
      if(file != NULL) {
 8002b8e:	6a3b      	ldr	r3, [r7, #32]
 8002b90:	2b00      	cmp	r3, #0
 8002b92:	d00c      	beq.n	8002bae <http_find_file+0x7e>
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Opened.\n"));
#if LWIP_HTTPD_SSI
        hs->tag_check = g_psDefaultFilenames[loop].shtml;
 8002b94:	f246 425c 	movw	r2, #25692	; 0x645c
 8002b98:	f6c0 0202 	movt	r2, #2050	; 0x802
 8002b9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002b9e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002ba2:	18d3      	adds	r3, r2, r3
 8002ba4:	791a      	ldrb	r2, [r3, #4]
 8002ba6:	68fb      	ldr	r3, [r7, #12]
 8002ba8:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
#endif /* LWIP_HTTPD_SSI */
        break;
 8002bac:	e006      	b.n	8002bbc <http_find_file+0x8c>

  /* Have we been asked for the default root file? */
  if((uri[0] == '/') &&  (uri[1] == 0)) {
    /* Try each of the configured default filenames until we find one
       that exists. */
    for (loop = 0; loop < NUM_DEFAULT_FILENAMES; loop++) {
 8002bae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002bb0:	f103 0301 	add.w	r3, r3, #1
 8002bb4:	627b      	str	r3, [r7, #36]	; 0x24
 8002bb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002bb8:	2b04      	cmp	r3, #4
 8002bba:	d9d5      	bls.n	8002b68 <http_find_file+0x38>
        hs->tag_check = g_psDefaultFilenames[loop].shtml;
#endif /* LWIP_HTTPD_SSI */
        break;
      }
    }
    if (file == NULL) {
 8002bbc:	6a3b      	ldr	r3, [r7, #32]
 8002bbe:	2b00      	cmp	r3, #0
 8002bc0:	f040 809f 	bne.w	8002d02 <http_find_file+0x1d2>
      /* None of the default filenames exist so send back a 404 page */
      file = http_get_404_file(&uri);
 8002bc4:	f107 0308 	add.w	r3, r7, #8
 8002bc8:	4618      	mov	r0, r3
 8002bca:	f7ff fea3 	bl	8002914 <http_get_404_file>
 8002bce:	6238      	str	r0, [r7, #32]
#if LWIP_HTTPD_SSI
      hs->tag_check = false;
 8002bd0:	68fb      	ldr	r3, [r7, #12]
 8002bd2:	f04f 0200 	mov.w	r2, #0
 8002bd6:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
        hs->tag_check = g_psDefaultFilenames[loop].shtml;
#endif /* LWIP_HTTPD_SSI */
        break;
      }
    }
    if (file == NULL) {
 8002bda:	e092      	b.n	8002d02 <http_find_file+0x1d2>
#endif /* LWIP_HTTPD_SSI */
    }
  } else {
    /* No - we've been asked for a specific file. */
    /* First, isolate the base URI (without any parameters) */
    params = (char *)strchr(uri, '?');
 8002bdc:	68bb      	ldr	r3, [r7, #8]
 8002bde:	4618      	mov	r0, r3
 8002be0:	f04f 013f 	mov.w	r1, #63	; 0x3f
 8002be4:	f021 fde2 	bl	80247ac <strchr>
 8002be8:	61f8      	str	r0, [r7, #28]
    if (params != NULL) {
 8002bea:	69fb      	ldr	r3, [r7, #28]
 8002bec:	2b00      	cmp	r3, #0
 8002bee:	d007      	beq.n	8002c00 <http_find_file+0xd0>
      /* URI contains parameters. NULL-terminate the base URI */
      *params = '\0';
 8002bf0:	69fb      	ldr	r3, [r7, #28]
 8002bf2:	f04f 0200 	mov.w	r2, #0
 8002bf6:	701a      	strb	r2, [r3, #0]
      params++;
 8002bf8:	69fb      	ldr	r3, [r7, #28]
 8002bfa:	f103 0301 	add.w	r3, r3, #1
 8002bfe:	61fb      	str	r3, [r7, #28]
    }

#if LWIP_HTTPD_CGI
    /* Does the base URI we have isolated correspond to a CGI handler? */
    if (g_iNumCGIs && g_pCGIs) {
 8002c00:	f640 431c 	movw	r3, #3100	; 0xc1c
 8002c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c08:	681b      	ldr	r3, [r3, #0]
 8002c0a:	2b00      	cmp	r3, #0
 8002c0c:	d043      	beq.n	8002c96 <http_find_file+0x166>
 8002c0e:	f640 4318 	movw	r3, #3096	; 0xc18
 8002c12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c16:	681b      	ldr	r3, [r3, #0]
 8002c18:	2b00      	cmp	r3, #0
 8002c1a:	d03c      	beq.n	8002c96 <http_find_file+0x166>
      for (i = 0; i < g_iNumCGIs; i++) {
 8002c1c:	f04f 0300 	mov.w	r3, #0
 8002c20:	61bb      	str	r3, [r7, #24]
 8002c22:	e030      	b.n	8002c86 <http_find_file+0x156>
        if (strcmp(uri, g_pCGIs[i].pcCGIName) == 0) {
 8002c24:	68ba      	ldr	r2, [r7, #8]
 8002c26:	f640 4318 	movw	r3, #3096	; 0xc18
 8002c2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c2e:	6819      	ldr	r1, [r3, #0]
 8002c30:	69bb      	ldr	r3, [r7, #24]
 8002c32:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002c36:	18cb      	adds	r3, r1, r3
 8002c38:	681b      	ldr	r3, [r3, #0]
 8002c3a:	4610      	mov	r0, r2
 8002c3c:	4619      	mov	r1, r3
 8002c3e:	f021 fe33 	bl	80248a8 <strcmp>
 8002c42:	4603      	mov	r3, r0
 8002c44:	2b00      	cmp	r3, #0
 8002c46:	d11a      	bne.n	8002c7e <http_find_file+0x14e>
          /*
           * We found a CGI that handles this URI so extract the
           * parameters and call the handler.
           */
           count = extract_uri_parameters(hs, params);
 8002c48:	68f8      	ldr	r0, [r7, #12]
 8002c4a:	69f9      	ldr	r1, [r7, #28]
 8002c4c:	f7ff f92a 	bl	8001ea4 <extract_uri_parameters>
 8002c50:	6178      	str	r0, [r7, #20]
           uri = g_pCGIs[i].pfnCGIHandler(i, count, hs->params,
 8002c52:	f640 4318 	movw	r3, #3096	; 0xc18
 8002c56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c5a:	681a      	ldr	r2, [r3, #0]
 8002c5c:	69bb      	ldr	r3, [r7, #24]
 8002c5e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8002c62:	18d3      	adds	r3, r2, r3
 8002c64:	685c      	ldr	r4, [r3, #4]
 8002c66:	68fb      	ldr	r3, [r7, #12]
 8002c68:	f103 02fc 	add.w	r2, r3, #252	; 0xfc
                                          hs->param_vals);
 8002c6c:	68fb      	ldr	r3, [r7, #12]
 8002c6e:	f503 739e 	add.w	r3, r3, #316	; 0x13c
          /*
           * We found a CGI that handles this URI so extract the
           * parameters and call the handler.
           */
           count = extract_uri_parameters(hs, params);
           uri = g_pCGIs[i].pfnCGIHandler(i, count, hs->params,
 8002c72:	69b8      	ldr	r0, [r7, #24]
 8002c74:	6979      	ldr	r1, [r7, #20]
 8002c76:	47a0      	blx	r4
 8002c78:	4603      	mov	r3, r0
 8002c7a:	60bb      	str	r3, [r7, #8]
                                          hs->param_vals);
           break;
 8002c7c:	e00b      	b.n	8002c96 <http_find_file+0x166>
    }

#if LWIP_HTTPD_CGI
    /* Does the base URI we have isolated correspond to a CGI handler? */
    if (g_iNumCGIs && g_pCGIs) {
      for (i = 0; i < g_iNumCGIs; i++) {
 8002c7e:	69bb      	ldr	r3, [r7, #24]
 8002c80:	f103 0301 	add.w	r3, r3, #1
 8002c84:	61bb      	str	r3, [r7, #24]
 8002c86:	f640 431c 	movw	r3, #3100	; 0xc1c
 8002c8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c8e:	681b      	ldr	r3, [r3, #0]
 8002c90:	69ba      	ldr	r2, [r7, #24]
 8002c92:	429a      	cmp	r2, r3
 8002c94:	dbc6      	blt.n	8002c24 <http_find_file+0xf4>
    }
#endif /* LWIP_HTTPD_CGI */

    LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("Opening %s\n", uri));

    file = fs_open(uri);
 8002c96:	68bb      	ldr	r3, [r7, #8]
 8002c98:	4618      	mov	r0, r3
 8002c9a:	f7fe ff93 	bl	8001bc4 <fs_open>
 8002c9e:	6238      	str	r0, [r7, #32]
    if (file == NULL) {
 8002ca0:	6a3b      	ldr	r3, [r7, #32]
 8002ca2:	2b00      	cmp	r3, #0
 8002ca4:	d105      	bne.n	8002cb2 <http_find_file+0x182>
      file = http_get_404_file(&uri);
 8002ca6:	f107 0308 	add.w	r3, r7, #8
 8002caa:	4618      	mov	r0, r3
 8002cac:	f7ff fe32 	bl	8002914 <http_get_404_file>
 8002cb0:	6238      	str	r0, [r7, #32]
    }
#if LWIP_HTTPD_SSI
    if (file != NULL) {
 8002cb2:	6a3b      	ldr	r3, [r7, #32]
 8002cb4:	2b00      	cmp	r3, #0
 8002cb6:	d024      	beq.n	8002d02 <http_find_file+0x1d2>
      /*
       * See if we have been asked for an shtml file and, if so,
       * enable tag checking.
       */
      hs->tag_check = false;
 8002cb8:	68fb      	ldr	r3, [r7, #12]
 8002cba:	f04f 0200 	mov.w	r2, #0
 8002cbe:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
 8002cc2:	f04f 0300 	mov.w	r3, #0
 8002cc6:	627b      	str	r3, [r7, #36]	; 0x24
 8002cc8:	e018      	b.n	8002cfc <http_find_file+0x1cc>
        if (strstr(uri, g_pcSSIExtensions[loop])) {
 8002cca:	68ba      	ldr	r2, [r7, #8]
 8002ccc:	f246 6360 	movw	r3, #26208	; 0x6660
 8002cd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002cd4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002cd6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8002cda:	4610      	mov	r0, r2
 8002cdc:	4619      	mov	r1, r3
 8002cde:	f022 f9d9 	bl	8025094 <strstr>
 8002ce2:	4603      	mov	r3, r0
 8002ce4:	2b00      	cmp	r3, #0
 8002ce6:	d005      	beq.n	8002cf4 <http_find_file+0x1c4>
          hs->tag_check = true;
 8002ce8:	68fb      	ldr	r3, [r7, #12]
 8002cea:	f04f 0201 	mov.w	r2, #1
 8002cee:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
          break;
 8002cf2:	e006      	b.n	8002d02 <http_find_file+0x1d2>
      /*
       * See if we have been asked for an shtml file and, if so,
       * enable tag checking.
       */
      hs->tag_check = false;
      for (loop = 0; loop < NUM_SHTML_EXTENSIONS; loop++) {
 8002cf4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002cf6:	f103 0301 	add.w	r3, r3, #1
 8002cfa:	627b      	str	r3, [r7, #36]	; 0x24
 8002cfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002cfe:	2b03      	cmp	r3, #3
 8002d00:	d9e3      	bls.n	8002cca <http_find_file+0x19a>
        }
      }
    }
#endif /* LWIP_HTTPD_SSI */
  }
  return http_init_file(hs, file, is_09, uri);
 8002d02:	68bb      	ldr	r3, [r7, #8]
 8002d04:	68f8      	ldr	r0, [r7, #12]
 8002d06:	6a39      	ldr	r1, [r7, #32]
 8002d08:	687a      	ldr	r2, [r7, #4]
 8002d0a:	f000 f807 	bl	8002d1c <http_init_file>
 8002d0e:	4603      	mov	r3, r0
}
 8002d10:	4618      	mov	r0, r3
 8002d12:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 8002d16:	46bd      	mov	sp, r7
 8002d18:	bd90      	pop	{r4, r7, pc}
 8002d1a:	bf00      	nop

08002d1c <http_init_file>:
 * @return ERR_OK if file was found and hs has been initialized correctly
 *         another err_t otherwise
 */
static err_t
http_init_file(struct http_state *hs, struct fs_file *file, int is_09, const char *uri)
{
 8002d1c:	b480      	push	{r7}
 8002d1e:	b085      	sub	sp, #20
 8002d20:	af00      	add	r7, sp, #0
 8002d22:	60f8      	str	r0, [r7, #12]
 8002d24:	60b9      	str	r1, [r7, #8]
 8002d26:	607a      	str	r2, [r7, #4]
 8002d28:	603b      	str	r3, [r7, #0]
  if (file != NULL) {
 8002d2a:	68bb      	ldr	r3, [r7, #8]
 8002d2c:	2b00      	cmp	r3, #0
 8002d2e:	d024      	beq.n	8002d7a <http_init_file+0x5e>
    /* file opened, initialise struct http_state */
#if LWIP_HTTPD_SSI
    hs->tag_index = 0;
 8002d30:	68fb      	ldr	r3, [r7, #12]
 8002d32:	f04f 0200 	mov.w	r2, #0
 8002d36:	851a      	strh	r2, [r3, #40]	; 0x28
    hs->tag_state = TAG_NONE;
 8002d38:	68fb      	ldr	r3, [r7, #12]
 8002d3a:	f04f 0200 	mov.w	r2, #0
 8002d3e:	f883 20f8 	strb.w	r2, [r3, #248]	; 0xf8
#if HTTPD_FAT_FS
    hs->parsed = NULL;
 8002d42:	68fb      	ldr	r3, [r7, #12]
 8002d44:	f04f 0200 	mov.w	r2, #0
 8002d48:	61da      	str	r2, [r3, #28]
    hs->parse_left = 0;
 8002d4a:	68fb      	ldr	r3, [r7, #12]
 8002d4c:	f04f 0200 	mov.w	r2, #0
 8002d50:	625a      	str	r2, [r3, #36]	; 0x24
    hs->tag_end = NULL;
 8002d52:	68fb      	ldr	r3, [r7, #12]
 8002d54:	f04f 0200 	mov.w	r2, #0
 8002d58:	621a      	str	r2, [r3, #32]
    hs->parsed = file->data;
    hs->parse_left = file->len;
    hs->tag_end = file->data;
#endif //HTTPD_FAT_FS
#endif /* LWIP_HTTPD_SSI */
    hs->handle = file;
 8002d5a:	68fb      	ldr	r3, [r7, #12]
 8002d5c:	68ba      	ldr	r2, [r7, #8]
 8002d5e:	601a      	str	r2, [r3, #0]
#if HTTPD_FAT_FS
    hs->file = NULL;
 8002d60:	68fb      	ldr	r3, [r7, #12]
 8002d62:	f04f 0200 	mov.w	r2, #0
 8002d66:	605a      	str	r2, [r3, #4]
    hs->left = 0;
 8002d68:	68fb      	ldr	r3, [r7, #12]
 8002d6a:	f04f 0200 	mov.w	r2, #0
 8002d6e:	615a      	str	r2, [r3, #20]
#else
    hs->file = (char*)file->data;
    LWIP_ASSERT("File length must be positive!", (file->len >= 0));
    hs->left = file->len;
#endif //HTTPD_FAT_FS
    hs->retries = 0;
 8002d70:	68fb      	ldr	r3, [r7, #12]
 8002d72:	f04f 0200 	mov.w	r2, #0
 8002d76:	761a      	strb	r2, [r3, #24]
 8002d78:	e00f      	b.n	8002d9a <http_init_file+0x7e>
        hs->left -= (u32_t)diff;
      }
    }
#endif /* LWIP_HTTPD_SUPPORT_V09*/
  } else {
    hs->handle = NULL;
 8002d7a:	68fb      	ldr	r3, [r7, #12]
 8002d7c:	f04f 0200 	mov.w	r2, #0
 8002d80:	601a      	str	r2, [r3, #0]
    hs->file = NULL;
 8002d82:	68fb      	ldr	r3, [r7, #12]
 8002d84:	f04f 0200 	mov.w	r2, #0
 8002d88:	605a      	str	r2, [r3, #4]
    hs->left = 0;
 8002d8a:	68fb      	ldr	r3, [r7, #12]
 8002d8c:	f04f 0200 	mov.w	r2, #0
 8002d90:	615a      	str	r2, [r3, #20]
    hs->retries = 0;
 8002d92:	68fb      	ldr	r3, [r7, #12]
 8002d94:	f04f 0200 	mov.w	r2, #0
 8002d98:	761a      	strb	r2, [r3, #24]
    get_http_headers(hs, (char*)uri);
  }
#else /* LWIP_HTTPD_DYNAMIC_HEADERS */
  LWIP_UNUSED_ARG(uri);
#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
  return ERR_OK;
 8002d9a:	f04f 0300 	mov.w	r3, #0
 8002d9e:	b25b      	sxtb	r3, r3
}
 8002da0:	4618      	mov	r0, r3
 8002da2:	f107 0714 	add.w	r7, r7, #20
 8002da6:	46bd      	mov	sp, r7
 8002da8:	bc80      	pop	{r7}
 8002daa:	4770      	bx	lr

08002dac <http_err>:
 * The pcb had an error and is already deallocated.
 * The argument might still be valid (if != NULL).
 */
static void
http_err(void *arg, err_t err)
{
 8002dac:	b580      	push	{r7, lr}
 8002dae:	b084      	sub	sp, #16
 8002db0:	af00      	add	r7, sp, #0
 8002db2:	6078      	str	r0, [r7, #4]
 8002db4:	460b      	mov	r3, r1
 8002db6:	70fb      	strb	r3, [r7, #3]
  struct http_state *hs = (struct http_state *)arg;
 8002db8:	687b      	ldr	r3, [r7, #4]
 8002dba:	60fb      	str	r3, [r7, #12]
  LWIP_UNUSED_ARG(err);

  LWIP_DEBUGF(HTTPD_DEBUG, ("http_err: %s", lwip_strerr(err)));

  if (hs != NULL) {
 8002dbc:	68fb      	ldr	r3, [r7, #12]
 8002dbe:	2b00      	cmp	r3, #0
 8002dc0:	d002      	beq.n	8002dc8 <http_err+0x1c>
    http_state_free(hs);
 8002dc2:	68f8      	ldr	r0, [r7, #12]
 8002dc4:	f7fe ffd0 	bl	8001d68 <http_state_free>
  }
}
 8002dc8:	f107 0710 	add.w	r7, r7, #16
 8002dcc:	46bd      	mov	sp, r7
 8002dce:	bd80      	pop	{r7, pc}

08002dd0 <http_sent>:
 * Data has been sent and acknowledged by the remote host.
 * This means that more data can be sent.
 */
static err_t
http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 8002dd0:	b580      	push	{r7, lr}
 8002dd2:	b086      	sub	sp, #24
 8002dd4:	af00      	add	r7, sp, #0
 8002dd6:	60f8      	str	r0, [r7, #12]
 8002dd8:	60b9      	str	r1, [r7, #8]
 8002dda:	4613      	mov	r3, r2
 8002ddc:	80fb      	strh	r3, [r7, #6]
  struct http_state *hs = (struct http_state *)arg;
 8002dde:	68fb      	ldr	r3, [r7, #12]
 8002de0:	617b      	str	r3, [r7, #20]

  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_sent %p\n", (void*)pcb));

  LWIP_UNUSED_ARG(len);

  if (hs == NULL) {
 8002de2:	697b      	ldr	r3, [r7, #20]
 8002de4:	2b00      	cmp	r3, #0
 8002de6:	d102      	bne.n	8002dee <http_sent+0x1e>
    return ERR_OK;
 8002de8:	f04f 0300 	mov.w	r3, #0
 8002dec:	e009      	b.n	8002e02 <http_sent+0x32>
  }

  hs->retries = 0;
 8002dee:	697b      	ldr	r3, [r7, #20]
 8002df0:	f04f 0200 	mov.w	r2, #0
 8002df4:	761a      	strb	r2, [r3, #24]

  http_send_data(pcb, hs);
 8002df6:	68b8      	ldr	r0, [r7, #8]
 8002df8:	6979      	ldr	r1, [r7, #20]
 8002dfa:	f7ff f96d 	bl	80020d8 <http_send_data>

  return ERR_OK;
 8002dfe:	f04f 0300 	mov.w	r3, #0
 8002e02:	b25b      	sxtb	r3, r3
}
 8002e04:	4618      	mov	r0, r3
 8002e06:	f107 0718 	add.w	r7, r7, #24
 8002e0a:	46bd      	mov	sp, r7
 8002e0c:	bd80      	pop	{r7, pc}
 8002e0e:	bf00      	nop

08002e10 <http_poll>:
 *
 * This could be increased, but we don't want to waste resources for bad connections.
 */
static err_t
http_poll(void *arg, struct tcp_pcb *pcb)
{
 8002e10:	b580      	push	{r7, lr}
 8002e12:	b084      	sub	sp, #16
 8002e14:	af00      	add	r7, sp, #0
 8002e16:	6078      	str	r0, [r7, #4]
 8002e18:	6039      	str	r1, [r7, #0]
  struct http_state *hs = (struct http_state *)arg;
 8002e1a:	687b      	ldr	r3, [r7, #4]
 8002e1c:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_poll: pcb=%p hs=%p pcb_state=%s\n",
    (void*)pcb, (void*)hs, tcp_debug_state_str(pcb->state)));

  if (hs == NULL) {
 8002e1e:	68fb      	ldr	r3, [r7, #12]
 8002e20:	2b00      	cmp	r3, #0
 8002e22:	d108      	bne.n	8002e36 <http_poll+0x26>
    err_t closed;
    /* arg is null, close. */
    LWIP_DEBUGF(HTTPD_DEBUG, ("http_poll: arg is NULL, close\n"));
    closed = http_close_conn(pcb, hs);
 8002e24:	6838      	ldr	r0, [r7, #0]
 8002e26:	68f9      	ldr	r1, [r7, #12]
 8002e28:	f7fe fffc 	bl	8001e24 <http_close_conn>
 8002e2c:	4603      	mov	r3, r0
 8002e2e:	72fb      	strb	r3, [r7, #11]
    if (closed == ERR_MEM) {
       tcp_abort(pcb);
       return ERR_ABRT;
    }
#endif /* LWIP_HTTPD_ABORT_ON_CLOSE_MEM_ERROR */
    return ERR_OK;
 8002e30:	f04f 0300 	mov.w	r3, #0
 8002e34:	e024      	b.n	8002e80 <http_poll+0x70>
  } else {
    hs->retries++;
 8002e36:	68fb      	ldr	r3, [r7, #12]
 8002e38:	7e1b      	ldrb	r3, [r3, #24]
 8002e3a:	f103 0301 	add.w	r3, r3, #1
 8002e3e:	b2da      	uxtb	r2, r3
 8002e40:	68fb      	ldr	r3, [r7, #12]
 8002e42:	761a      	strb	r2, [r3, #24]
    if (hs->retries == HTTPD_MAX_RETRIES) {
 8002e44:	68fb      	ldr	r3, [r7, #12]
 8002e46:	7e1b      	ldrb	r3, [r3, #24]
 8002e48:	2b04      	cmp	r3, #4
 8002e4a:	d106      	bne.n	8002e5a <http_poll+0x4a>
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_poll: too many retries, close\n"));
      http_close_conn(pcb, hs);
 8002e4c:	6838      	ldr	r0, [r7, #0]
 8002e4e:	68f9      	ldr	r1, [r7, #12]
 8002e50:	f7fe ffe8 	bl	8001e24 <http_close_conn>
      return ERR_OK;
 8002e54:	f04f 0300 	mov.w	r3, #0
 8002e58:	e012      	b.n	8002e80 <http_poll+0x70>
    }

    /* If this connection has a file open, try to send some more data. If
     * it has not yet received a GET request, don't do this since it will
     * cause the connection to close immediately. */
    if(hs && (hs->handle)) {
 8002e5a:	68fb      	ldr	r3, [r7, #12]
 8002e5c:	2b00      	cmp	r3, #0
 8002e5e:	d00d      	beq.n	8002e7c <http_poll+0x6c>
 8002e60:	68fb      	ldr	r3, [r7, #12]
 8002e62:	681b      	ldr	r3, [r3, #0]
 8002e64:	2b00      	cmp	r3, #0
 8002e66:	d009      	beq.n	8002e7c <http_poll+0x6c>
      LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_poll: try to send more data\n"));
      if(http_send_data(pcb, hs)) {
 8002e68:	6838      	ldr	r0, [r7, #0]
 8002e6a:	68f9      	ldr	r1, [r7, #12]
 8002e6c:	f7ff f934 	bl	80020d8 <http_send_data>
 8002e70:	4603      	mov	r3, r0
 8002e72:	2b00      	cmp	r3, #0
 8002e74:	d002      	beq.n	8002e7c <http_poll+0x6c>
        /* If we wrote anything to be sent, go ahead and send it now. */
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("tcp_output\n"));
        tcp_output(pcb);
 8002e76:	6838      	ldr	r0, [r7, #0]
 8002e78:	f014 f9f6 	bl	8017268 <tcp_output>
      }
    }
  }

  return ERR_OK;
 8002e7c:	f04f 0300 	mov.w	r3, #0
 8002e80:	b25b      	sxtb	r3, r3
}
 8002e82:	4618      	mov	r0, r3
 8002e84:	f107 0710 	add.w	r7, r7, #16
 8002e88:	46bd      	mov	sp, r7
 8002e8a:	bd80      	pop	{r7, pc}

08002e8c <http_recv>:
 * Data has been received on this pcb.
 * For HTTP 1.0, this should normally only happen once (if the request fits in one packet).
 */
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 8002e8c:	b580      	push	{r7, lr}
 8002e8e:	b086      	sub	sp, #24
 8002e90:	af00      	add	r7, sp, #0
 8002e92:	60f8      	str	r0, [r7, #12]
 8002e94:	60b9      	str	r1, [r7, #8]
 8002e96:	607a      	str	r2, [r7, #4]
 8002e98:	70fb      	strb	r3, [r7, #3]
  err_t parsed = ERR_ABRT;
 8002e9a:	f04f 03fb 	mov.w	r3, #251	; 0xfb
 8002e9e:	75fb      	strb	r3, [r7, #23]
  struct http_state *hs = (struct http_state *)arg;
 8002ea0:	68fb      	ldr	r3, [r7, #12]
 8002ea2:	613b      	str	r3, [r7, #16]
  LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: pcb=%p pbuf=%p err=%s\n", (void*)pcb,
    (void*)p, lwip_strerr(err)));

  if ((err != ERR_OK) || (p == NULL) || (hs == NULL)) {
 8002ea4:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8002ea8:	2b00      	cmp	r3, #0
 8002eaa:	d105      	bne.n	8002eb8 <http_recv+0x2c>
 8002eac:	687b      	ldr	r3, [r7, #4]
 8002eae:	2b00      	cmp	r3, #0
 8002eb0:	d002      	beq.n	8002eb8 <http_recv+0x2c>
 8002eb2:	693b      	ldr	r3, [r7, #16]
 8002eb4:	2b00      	cmp	r3, #0
 8002eb6:	d113      	bne.n	8002ee0 <http_recv+0x54>
    /* error or closed by other side? */
    if (p != NULL) {
 8002eb8:	687b      	ldr	r3, [r7, #4]
 8002eba:	2b00      	cmp	r3, #0
 8002ebc:	d009      	beq.n	8002ed2 <http_recv+0x46>
      /* Inform TCP that we have taken the data. */
      tcp_recved(pcb, p->tot_len);
 8002ebe:	687b      	ldr	r3, [r7, #4]
 8002ec0:	891b      	ldrh	r3, [r3, #8]
 8002ec2:	68b8      	ldr	r0, [r7, #8]
 8002ec4:	4619      	mov	r1, r3
 8002ec6:	f010 ff29 	bl	8013d1c <tcp_recved>
      pbuf_free(p);
 8002eca:	687b      	ldr	r3, [r7, #4]
 8002ecc:	4618      	mov	r0, r3
 8002ece:	f00f fff7 	bl	8012ec0 <pbuf_free>
    }
    if (hs == NULL) {
      /* this should not happen, only to be robust */
      LWIP_DEBUGF(HTTPD_DEBUG, ("Error, http_recv: hs is NULL, close\n"));
    }
    http_close_conn(pcb, hs);
 8002ed2:	68b8      	ldr	r0, [r7, #8]
 8002ed4:	6939      	ldr	r1, [r7, #16]
 8002ed6:	f7fe ffa5 	bl	8001e24 <http_close_conn>
    return ERR_OK;
 8002eda:	f04f 0300 	mov.w	r3, #0
 8002ede:	e038      	b.n	8002f52 <http_recv+0xc6>
     hs->unrecved_bytes += p->tot_len;
  } else
#endif /* LWIP_HTTPD_SUPPORT_POST && LWIP_HTTPD_POST_MANUAL_WND */
  {
    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
 8002ee0:	687b      	ldr	r3, [r7, #4]
 8002ee2:	891b      	ldrh	r3, [r3, #8]
 8002ee4:	68b8      	ldr	r0, [r7, #8]
 8002ee6:	4619      	mov	r1, r3
 8002ee8:	f010 ff18 	bl	8013d1c <tcp_recved>
    }
    return ERR_OK;
  } else
#endif /* LWIP_HTTPD_SUPPORT_POST */
  {
    if (hs->handle == NULL) {
 8002eec:	693b      	ldr	r3, [r7, #16]
 8002eee:	681b      	ldr	r3, [r3, #0]
 8002ef0:	2b00      	cmp	r3, #0
 8002ef2:	d108      	bne.n	8002f06 <http_recv+0x7a>
      parsed = http_parse_request(&p, hs, pcb);
 8002ef4:	f107 0304 	add.w	r3, r7, #4
 8002ef8:	4618      	mov	r0, r3
 8002efa:	6939      	ldr	r1, [r7, #16]
 8002efc:	68ba      	ldr	r2, [r7, #8]
 8002efe:	f7ff fd45 	bl	800298c <http_parse_request>
 8002f02:	4603      	mov	r3, r0
 8002f04:	75fb      	strb	r3, [r7, #23]
        || parsed == ERR_INPROGRESS ||parsed == ERR_ARG || parsed == ERR_USE);
    } else {
      LWIP_DEBUGF(HTTPD_DEBUG, ("http_recv: already sending data\n"));
    }
#if LWIP_HTTPD_SUPPORT_REQUESTLIST
    if (parsed != ERR_INPROGRESS) {
 8002f06:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8002f0a:	f113 0f0e 	cmn.w	r3, #14
 8002f0e:	d00c      	beq.n	8002f2a <http_recv+0x9e>
      /* request fully parsed or error */
      if (hs->req != NULL) {
 8002f10:	693b      	ldr	r3, [r7, #16]
 8002f12:	689b      	ldr	r3, [r3, #8]
 8002f14:	2b00      	cmp	r3, #0
 8002f16:	d008      	beq.n	8002f2a <http_recv+0x9e>
        pbuf_free(hs->req);
 8002f18:	693b      	ldr	r3, [r7, #16]
 8002f1a:	689b      	ldr	r3, [r3, #8]
 8002f1c:	4618      	mov	r0, r3
 8002f1e:	f00f ffcf 	bl	8012ec0 <pbuf_free>
        hs->req = NULL;
 8002f22:	693b      	ldr	r3, [r7, #16]
 8002f24:	f04f 0200 	mov.w	r2, #0
 8002f28:	609a      	str	r2, [r3, #8]
    if (p != NULL) {
      /* pbuf not passed to application, free it now */
      pbuf_free(p);
    }
#endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
    if (parsed == ERR_OK) {
 8002f2a:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8002f2e:	2b00      	cmp	r3, #0
 8002f30:	d104      	bne.n	8002f3c <http_recv+0xb0>
#if LWIP_HTTPD_SUPPORT_POST
      if (hs->post_content_len_left == 0)
#endif /* LWIP_HTTPD_SUPPORT_POST */
      {
        LWIP_DEBUGF(HTTPD_DEBUG | LWIP_DBG_TRACE, ("http_recv: data %p len %"S32_F"\n", hs->file, hs->left));
        http_send_data(pcb, hs);
 8002f32:	68b8      	ldr	r0, [r7, #8]
 8002f34:	6939      	ldr	r1, [r7, #16]
 8002f36:	f7ff f8cf 	bl	80020d8 <http_send_data>
 8002f3a:	e008      	b.n	8002f4e <http_recv+0xc2>
      }
    } else if (parsed == ERR_ARG) {
 8002f3c:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8002f40:	f113 0f0a 	cmn.w	r3, #10
 8002f44:	d103      	bne.n	8002f4e <http_recv+0xc2>
      /* @todo: close on ERR_USE? */
      http_close_conn(pcb, hs);
 8002f46:	68b8      	ldr	r0, [r7, #8]
 8002f48:	6939      	ldr	r1, [r7, #16]
 8002f4a:	f7fe ff6b 	bl	8001e24 <http_close_conn>
    }
  }
  return ERR_OK;
 8002f4e:	f04f 0300 	mov.w	r3, #0
 8002f52:	b25b      	sxtb	r3, r3
}
 8002f54:	4618      	mov	r0, r3
 8002f56:	f107 0718 	add.w	r7, r7, #24
 8002f5a:	46bd      	mov	sp, r7
 8002f5c:	bd80      	pop	{r7, pc}
 8002f5e:	bf00      	nop

08002f60 <http_accept>:
/**
 * A new incoming connection has been accepted.
 */
static err_t
http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
 8002f60:	b580      	push	{r7, lr}
 8002f62:	b086      	sub	sp, #24
 8002f64:	af00      	add	r7, sp, #0
 8002f66:	60f8      	str	r0, [r7, #12]
 8002f68:	60b9      	str	r1, [r7, #8]
 8002f6a:	4613      	mov	r3, r2
 8002f6c:	71fb      	strb	r3, [r7, #7]
  LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept %p / %p\n", (void*)pcb, arg));

  /* Decrease the listen backlog counter */
  tcp_accepted((struct tcp_pcb_listen*)arg);
  /* Set priority */
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 8002f6e:	68b8      	ldr	r0, [r7, #8]
 8002f70:	f04f 0101 	mov.w	r1, #1
 8002f74:	f011 fb1c 	bl	80145b0 <tcp_setprio>

  /* Allocate memory for the structure that holds the state of the
     connection - initialized by that function. */
  hs = http_state_alloc();
 8002f78:	f7fe fede 	bl	8001d38 <http_state_alloc>
 8002f7c:	6178      	str	r0, [r7, #20]
  if (hs == NULL) {
 8002f7e:	697b      	ldr	r3, [r7, #20]
 8002f80:	2b00      	cmp	r3, #0
 8002f82:	d102      	bne.n	8002f8a <http_accept+0x2a>
    LWIP_DEBUGF(HTTPD_DEBUG, ("http_accept: Out of memory, RST\n"));
    return ERR_MEM;
 8002f84:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8002f88:	e023      	b.n	8002fd2 <http_accept+0x72>
  }

  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
 8002f8a:	68b8      	ldr	r0, [r7, #8]
 8002f8c:	6979      	ldr	r1, [r7, #20]
 8002f8e:	f011 fc73 	bl	8014878 <tcp_arg>

  /* Set up the various callback functions */
  tcp_recv(pcb, http_recv);
 8002f92:	68b8      	ldr	r0, [r7, #8]
 8002f94:	f642 618d 	movw	r1, #11917	; 0x2e8d
 8002f98:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002f9c:	f011 fc7a 	bl	8014894 <tcp_recv>
  tcp_err(pcb, http_err);
 8002fa0:	68b8      	ldr	r0, [r7, #8]
 8002fa2:	f642 51ad 	movw	r1, #11693	; 0x2dad
 8002fa6:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002faa:	f011 fc8f 	bl	80148cc <tcp_err>
  tcp_poll(pcb, http_poll, HTTPD_POLL_INTERVAL);
 8002fae:	68b8      	ldr	r0, [r7, #8]
 8002fb0:	f642 6111 	movw	r1, #11793	; 0x2e11
 8002fb4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002fb8:	f04f 0204 	mov.w	r2, #4
 8002fbc:	f011 fca2 	bl	8014904 <tcp_poll>
  tcp_sent(pcb, http_sent);
 8002fc0:	68b8      	ldr	r0, [r7, #8]
 8002fc2:	f642 51d1 	movw	r1, #11729	; 0x2dd1
 8002fc6:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002fca:	f011 fc71 	bl	80148b0 <tcp_sent>

  return ERR_OK;
 8002fce:	f04f 0300 	mov.w	r3, #0
 8002fd2:	b25b      	sxtb	r3, r3
}
 8002fd4:	4618      	mov	r0, r3
 8002fd6:	f107 0718 	add.w	r7, r7, #24
 8002fda:	46bd      	mov	sp, r7
 8002fdc:	bd80      	pop	{r7, pc}
 8002fde:	bf00      	nop

08002fe0 <httpd_init_addr>:
/**
 * Initialize the httpd with the specified local address.
 */
static void
httpd_init_addr(struct ip_addr *local_addr)
{
 8002fe0:	b580      	push	{r7, lr}
 8002fe2:	b084      	sub	sp, #16
 8002fe4:	af00      	add	r7, sp, #0
 8002fe6:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *pcb;
  err_t err;

  pcb = tcp_new();
 8002fe8:	f011 fc3c 	bl	8014864 <tcp_new>
 8002fec:	60f8      	str	r0, [r7, #12]
  LWIP_ASSERT("httpd_init: tcp_new failed", pcb != NULL);
  tcp_setprio(pcb, HTTPD_TCP_PRIO);
 8002fee:	68f8      	ldr	r0, [r7, #12]
 8002ff0:	f04f 0101 	mov.w	r1, #1
 8002ff4:	f011 fadc 	bl	80145b0 <tcp_setprio>
  /* set SOF_REUSEADDR here to explicitly bind httpd to multiple interfaces */
  err = tcp_bind(pcb, local_addr, HTTPD_SERVER_PORT);
 8002ff8:	68f8      	ldr	r0, [r7, #12]
 8002ffa:	6879      	ldr	r1, [r7, #4]
 8002ffc:	f04f 0250 	mov.w	r2, #80	; 0x50
 8003000:	f010 fcbc 	bl	801397c <tcp_bind>
 8003004:	4603      	mov	r3, r0
 8003006:	72fb      	strb	r3, [r7, #11]
  LWIP_ASSERT("httpd_init: tcp_bind failed", err == ERR_OK);
  pcb = tcp_listen(pcb);
 8003008:	68f8      	ldr	r0, [r7, #12]
 800300a:	f04f 01ff 	mov.w	r1, #255	; 0xff
 800300e:	f010 fd93 	bl	8013b38 <tcp_listen_with_backlog>
 8003012:	60f8      	str	r0, [r7, #12]
  LWIP_ASSERT("httpd_init: tcp_listen failed", pcb != NULL);
  /* initialize callback arg and accept callback */
  tcp_arg(pcb, pcb);
 8003014:	68f8      	ldr	r0, [r7, #12]
 8003016:	68f9      	ldr	r1, [r7, #12]
 8003018:	f011 fc2e 	bl	8014878 <tcp_arg>
  tcp_accept(pcb, http_accept);
 800301c:	68f8      	ldr	r0, [r7, #12]
 800301e:	f642 7161 	movw	r1, #12129	; 0x2f61
 8003022:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003026:	f011 fc5f 	bl	80148e8 <tcp_accept>
}
 800302a:	f107 0710 	add.w	r7, r7, #16
 800302e:	46bd      	mov	sp, r7
 8003030:	bd80      	pop	{r7, pc}
 8003032:	bf00      	nop

08003034 <httpd_init>:
/**
 * Initialize the httpd: set up a listening PCB and bind it to the defined port
 */
void
httpd_init(void)
{
 8003034:	b580      	push	{r7, lr}
 8003036:	af00      	add	r7, sp, #0
#if HTTPD_FAT_FS
    /* Mount the Drive. Mandatory step to drive a card through Software */
    f_mount(0, &myfsObject);
 8003038:	f04f 0000 	mov.w	r0, #0
 800303c:	f645 51f0 	movw	r1, #24048	; 0x5df0
 8003040:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8003044:	f00a f812 	bl	800d06c <f_mount>
  LWIP_ASSERT("memp_sizes[MEMP_HTTPD_STATE] >= sizeof(http_state)",
     memp_sizes[MEMP_HTTPD_STATE] >= sizeof(http_state));
#endif
  LWIP_DEBUGF(HTTPD_DEBUG, ("httpd_init\n"));

  httpd_init_addr(IP_ADDR_ANY);
 8003048:	f646 0078 	movw	r0, #26744	; 0x6878
 800304c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003050:	f7ff ffc6 	bl	8002fe0 <httpd_init_addr>
}
 8003054:	bd80      	pop	{r7, pc}
 8003056:	bf00      	nop

08003058 <http_set_ssi_handler>:
 * @param tags an array of SSI tag strings to search for in SSI-enabled files
 * @param num_tags number of tags in the 'tags' array
 */
void
http_set_ssi_handler(tSSIHandler ssi_handler, const char **tags, int num_tags)
{
 8003058:	b480      	push	{r7}
 800305a:	b085      	sub	sp, #20
 800305c:	af00      	add	r7, sp, #0
 800305e:	60f8      	str	r0, [r7, #12]
 8003060:	60b9      	str	r1, [r7, #8]
 8003062:	607a      	str	r2, [r7, #4]

  LWIP_ASSERT("no ssi_handler given", ssi_handler != NULL);
  LWIP_ASSERT("no tags given", tags != NULL);
  LWIP_ASSERT("invalid number of tags", num_tags > 0);

  g_pfnSSIHandler = ssi_handler;
 8003064:	f640 430c 	movw	r3, #3084	; 0xc0c
 8003068:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800306c:	68fa      	ldr	r2, [r7, #12]
 800306e:	601a      	str	r2, [r3, #0]
  g_ppcTags = tags;
 8003070:	f640 4314 	movw	r3, #3092	; 0xc14
 8003074:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003078:	68ba      	ldr	r2, [r7, #8]
 800307a:	601a      	str	r2, [r3, #0]
  g_iNumTags = num_tags;
 800307c:	f640 4310 	movw	r3, #3088	; 0xc10
 8003080:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003084:	687a      	ldr	r2, [r7, #4]
 8003086:	601a      	str	r2, [r3, #0]
}
 8003088:	f107 0714 	add.w	r7, r7, #20
 800308c:	46bd      	mov	sp, r7
 800308e:	bc80      	pop	{r7}
 8003090:	4770      	bx	lr
 8003092:	bf00      	nop

08003094 <http_set_cgi_handlers>:
 * @param cgis an array of CGI filenames/handler functions
 * @param num_handlers number of elements in the 'cgis' array
 */
void
http_set_cgi_handlers(const tCGI *cgis, int num_handlers)
{
 8003094:	b480      	push	{r7}
 8003096:	b083      	sub	sp, #12
 8003098:	af00      	add	r7, sp, #0
 800309a:	6078      	str	r0, [r7, #4]
 800309c:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("no cgis given", cgis != NULL);
  LWIP_ASSERT("invalid number of handlers", num_handlers > 0);
  
  g_pCGIs = cgis;
 800309e:	f640 4318 	movw	r3, #3096	; 0xc18
 80030a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80030a6:	687a      	ldr	r2, [r7, #4]
 80030a8:	601a      	str	r2, [r3, #0]
  g_iNumCGIs = num_handlers;
 80030aa:	f640 431c 	movw	r3, #3100	; 0xc1c
 80030ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80030b2:	683a      	ldr	r2, [r7, #0]
 80030b4:	601a      	str	r2, [r3, #0]
}
 80030b6:	f107 070c 	add.w	r7, r7, #12
 80030ba:	46bd      	mov	sp, r7
 80030bc:	bc80      	pop	{r7}
 80030be:	4770      	bx	lr

080030c0 <UART001_lInit>:
 * @return  None <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/ 
void UART001_lInit (const UART001_HandleType* Handle)
{
 80030c0:	b480      	push	{r7}
 80030c2:	b085      	sub	sp, #20
 80030c4:	af00      	add	r7, sp, #0
 80030c6:	6078      	str	r0, [r7, #4]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
 80030c8:	687b      	ldr	r3, [r7, #4]
 80030ca:	681b      	ldr	r3, [r3, #0]
 80030cc:	60fb      	str	r3, [r7, #12]
 
  /** UART initialisation  */

  /* Disable UART mode before configuring all USIC registers to avoid 
   * unintended edges */ 
  UartRegs->CCR &= ~( ((uint32_t)(UART_MODE  & USIC_CH_CCR_MODE_Msk))); 
 80030ce:	68fb      	ldr	r3, [r7, #12]
 80030d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80030d2:	f023 0202 	bic.w	r2, r3, #2
 80030d6:	68fb      	ldr	r3, [r7, #12]
 80030d8:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enable the USIC Channel */
  UartRegs->KSCFG |= ((((uint32_t)MASK_ONE  & USIC_CH_KSCFG_MODEN_Msk)) | \
 80030da:	68fb      	ldr	r3, [r7, #12]
 80030dc:	68db      	ldr	r3, [r3, #12]
 80030de:	f043 0203 	orr.w	r2, r3, #3
 80030e2:	68fb      	ldr	r3, [r7, #12]
 80030e4:	60da      	str	r2, [r3, #12]
                         USIC_CH_KSCFG_BPMODEN_Msk)); 
   
  /* Configuration of USIC Channel Fractional Divider */

  /* Fractional divider mode selected */
  UartRegs->FDR |= (((uint32_t)SHIFT_TWO << USIC_CH_FDR_DM_Pos) \
 80030e6:	68fb      	ldr	r3, [r7, #12]
 80030e8:	691b      	ldr	r3, [r3, #16]
 80030ea:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 80030ee:	68fb      	ldr	r3, [r7, #12]
 80030f0:	611a      	str	r2, [r3, #16]
                                                     & USIC_CH_FDR_DM_Msk);
  
  /* Step value */
  UartRegs->FDR |= ((Handle->BGR_STEP) & USIC_CH_FDR_STEP_Msk);
 80030f2:	68fb      	ldr	r3, [r7, #12]
 80030f4:	691a      	ldr	r2, [r3, #16]
 80030f6:	687b      	ldr	r3, [r7, #4]
 80030f8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80030fa:	ea4f 5383 	mov.w	r3, r3, lsl #22
 80030fe:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8003102:	431a      	orrs	r2, r3
 8003104:	68fb      	ldr	r3, [r7, #12]
 8003106:	611a      	str	r2, [r3, #16]
          
  /* The PreDivider for CTQ, PCTQ = 0  */
  /* The Denominator for CTQ, DCTQ = 16 */
    
  UartRegs->BRG |= \
 8003108:	68fb      	ldr	r3, [r7, #12]
 800310a:	695a      	ldr	r2, [r3, #20]
	  ((((uint32_t)(Handle->BGR_PCTQ) << USIC_CH_BRG_PCTQ_Pos) & \
 800310c:	687b      	ldr	r3, [r7, #4]
 800310e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8003112:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8003116:	f403 7140 	and.w	r1, r3, #768	; 0x300
		  	     USIC_CH_BRG_PCTQ_Msk) | \
      (((uint32_t)(Handle->BGR_DCTQ) << USIC_CH_BRG_DCTQ_Pos) & \
 800311a:	687b      	ldr	r3, [r7, #4]
 800311c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800311e:	ea4f 2383 	mov.w	r3, r3, lsl #10
 8003122:	f403 43f8 	and.w	r3, r3, #31744	; 0x7c00
  /* The PreDivider for CTQ, PCTQ = 0  */
  /* The Denominator for CTQ, DCTQ = 16 */
    
  UartRegs->BRG |= \
	  ((((uint32_t)(Handle->BGR_PCTQ) << USIC_CH_BRG_PCTQ_Pos) & \
		  	     USIC_CH_BRG_PCTQ_Msk) | \
 8003126:	4319      	orrs	r1, r3
      (((uint32_t)(Handle->BGR_DCTQ) << USIC_CH_BRG_DCTQ_Pos) & \
	     USIC_CH_BRG_DCTQ_Msk) | \
      (((uint32_t)(Handle->BGR_PDIV) << USIC_CH_BRG_PDIV_Pos) &  \
 8003128:	687b      	ldr	r3, [r7, #4]
 800312a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800312c:	ea4f 4003 	mov.w	r0, r3, lsl #16
 8003130:	f04f 0300 	mov.w	r3, #0
 8003134:	f2c0 33ff 	movt	r3, #1023	; 0x3ff
 8003138:	4003      	ands	r3, r0
    
  UartRegs->BRG |= \
	  ((((uint32_t)(Handle->BGR_PCTQ) << USIC_CH_BRG_PCTQ_Pos) & \
		  	     USIC_CH_BRG_PCTQ_Msk) | \
      (((uint32_t)(Handle->BGR_DCTQ) << USIC_CH_BRG_DCTQ_Pos) & \
	     USIC_CH_BRG_DCTQ_Msk) | \
 800313a:	430b      	orrs	r3, r1
  UartRegs->FDR |= ((Handle->BGR_STEP) & USIC_CH_FDR_STEP_Msk);
          
  /* The PreDivider for CTQ, PCTQ = 0  */
  /* The Denominator for CTQ, DCTQ = 16 */
    
  UartRegs->BRG |= \
 800313c:	431a      	orrs	r2, r3
 800313e:	68fb      	ldr	r3, [r7, #12]
 8003140:	615a      	str	r2, [r3, #20]
  /* Configuration of USIC Shift Control */
  
  /* Transmit/Receive LSB first is selected  */
  /* Transmission Mode (TRM) = 1  */
  /* Passive Data Level (PDL) = 1 */
  UartRegs->SCTR |= ((((uint32_t)SHIFT_ONE  << USIC_CH_SCTR_PDL_Pos) & \
 8003142:	68fb      	ldr	r3, [r7, #12]
 8003144:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003146:	f443 7281 	orr.w	r2, r3, #258	; 0x102
 800314a:	68fb      	ldr	r3, [r7, #12]
 800314c:	635a      	str	r2, [r3, #52]	; 0x34
    USIC_CH_SCTR_PDL_Msk ) | \
    (((uint32_t)SHIFT_ONE  <<  USIC_CH_SCTR_TRM_Pos ) & USIC_CH_SCTR_TRM_Msk ));
  /* Set Word Length (WLE) & Frame Length (FLE) */
  UartRegs->SCTR |= ((((uint32_t)Handle->DataBits  << USIC_CH_SCTR_FLE_Pos) & \
 800314e:	68fb      	ldr	r3, [r7, #12]
 8003150:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003152:	687b      	ldr	r3, [r7, #4]
 8003154:	8b9b      	ldrh	r3, [r3, #28]
 8003156:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800315a:	f403 117c 	and.w	r1, r3, #4128768	; 0x3f0000
                      USIC_CH_SCTR_FLE_Msk ) | \
                     (((uint32_t)Handle->DataBits  << USIC_CH_SCTR_WLE_Pos) & \
 800315e:	687b      	ldr	r3, [r7, #4]
 8003160:	8b9b      	ldrh	r3, [r3, #28]
 8003162:	ea4f 6303 	mov.w	r3, r3, lsl #24
 8003166:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
  UartRegs->SCTR |= ((((uint32_t)SHIFT_ONE  << USIC_CH_SCTR_PDL_Pos) & \
    USIC_CH_SCTR_PDL_Msk ) | \
    (((uint32_t)SHIFT_ONE  <<  USIC_CH_SCTR_TRM_Pos ) & USIC_CH_SCTR_TRM_Msk ));
  /* Set Word Length (WLE) & Frame Length (FLE) */
  UartRegs->SCTR |= ((((uint32_t)Handle->DataBits  << USIC_CH_SCTR_FLE_Pos) & \
                      USIC_CH_SCTR_FLE_Msk ) | \
 800316a:	430b      	orrs	r3, r1
  /* Passive Data Level (PDL) = 1 */
  UartRegs->SCTR |= ((((uint32_t)SHIFT_ONE  << USIC_CH_SCTR_PDL_Pos) & \
    USIC_CH_SCTR_PDL_Msk ) | \
    (((uint32_t)SHIFT_ONE  <<  USIC_CH_SCTR_TRM_Pos ) & USIC_CH_SCTR_TRM_Msk ));
  /* Set Word Length (WLE) & Frame Length (FLE) */
  UartRegs->SCTR |= ((((uint32_t)Handle->DataBits  << USIC_CH_SCTR_FLE_Pos) & \
 800316c:	431a      	orrs	r2, r3
 800316e:	68fb      	ldr	r3, [r7, #12]
 8003170:	635a      	str	r2, [r3, #52]	; 0x34
       
  /* Configuration of USIC Transmit Control/Status Register */ 
  /* TBUF Data Enable (TDEN) = 1 */
  /* TBUF Data Single Shot Mode (TDSSM) = 1 */
	
  UartRegs->TCSR |= ((((uint32_t)SHIFT_ONE  << USIC_CH_TCSR_TDEN_Pos) & \
 8003172:	68fb      	ldr	r3, [r7, #12]
 8003174:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003176:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
 800317a:	68fb      	ldr	r3, [r7, #12]
 800317c:	639a      	str	r2, [r3, #56]	; 0x38
  /* Sample Mode (SMD) = 1 */
  /* 1 Stop bit is selected */   
  /* Sample Point (SP) as configured */
  /* Pulse Length (PL) = 0 */
  
  UartRegs->PCR_ASCMode |= ((((uint32_t)MASK_ONE & USIC_CH_PCR_ASCMode_SMD_Msk)) |\
 800317e:	68fb      	ldr	r3, [r7, #12]
 8003180:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    (((uint32_t)Handle->StopBit  << USIC_CH_PCR_ASCMode_STPB_Pos) & \
 8003182:	687b      	ldr	r3, [r7, #4]
 8003184:	7d5b      	ldrb	r3, [r3, #21]
 8003186:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800318a:	f003 0102 	and.w	r1, r3, #2
    USIC_CH_PCR_ASCMode_STPB_Msk) | \
    (((uint32_t)(Handle->BGR_SP) << USIC_CH_PCR_ASCMode_SP_Pos) & \
 800318e:	687b      	ldr	r3, [r7, #4]
 8003190:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 8003192:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8003196:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
  /* Sample Point (SP) as configured */
  /* Pulse Length (PL) = 0 */
  
  UartRegs->PCR_ASCMode |= ((((uint32_t)MASK_ONE & USIC_CH_PCR_ASCMode_SMD_Msk)) |\
    (((uint32_t)Handle->StopBit  << USIC_CH_PCR_ASCMode_STPB_Pos) & \
    USIC_CH_PCR_ASCMode_STPB_Msk) | \
 800319a:	430b      	orrs	r3, r1
  /* Sample Mode (SMD) = 1 */
  /* 1 Stop bit is selected */   
  /* Sample Point (SP) as configured */
  /* Pulse Length (PL) = 0 */
  
  UartRegs->PCR_ASCMode |= ((((uint32_t)MASK_ONE & USIC_CH_PCR_ASCMode_SMD_Msk)) |\
 800319c:	4313      	orrs	r3, r2
 800319e:	f043 0201 	orr.w	r2, r3, #1
 80031a2:	68fb      	ldr	r3, [r7, #12]
 80031a4:	63da      	str	r2, [r3, #60]	; 0x3c
    (((uint32_t)Handle->StopBit  << USIC_CH_PCR_ASCMode_STPB_Pos) & \
    USIC_CH_PCR_ASCMode_STPB_Msk) | \
    (((uint32_t)(Handle->BGR_SP) << USIC_CH_PCR_ASCMode_SP_Pos) & \
    USIC_CH_PCR_ASCMode_SP_Msk));
      
  if(Handle->RecvNoiseEn)
 80031a6:	687b      	ldr	r3, [r7, #4]
 80031a8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80031ac:	2b00      	cmp	r3, #0
 80031ae:	d005      	beq.n	80031bc <UART001_lInit+0xfc>
  {
   	/* Enable Receiver Noise Interrupt*/  
    UartRegs->PCR_ASCMode |=(((uint32_t)SHIFT_ONE  << USIC_CH_PCR_CTR5_Pos) & \
 80031b0:	68fb      	ldr	r3, [r7, #12]
 80031b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80031b4:	f043 0220 	orr.w	r2, r3, #32
 80031b8:	68fb      	ldr	r3, [r7, #12]
 80031ba:	63da      	str	r2, [r3, #60]	; 0x3c
		  	  	  	  	  USIC_CH_PCR_CTR5_Msk); 
  }
  
  if(Handle->FormatErrEn)
 80031bc:	687b      	ldr	r3, [r7, #4]
 80031be:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80031c2:	2b00      	cmp	r3, #0
 80031c4:	d005      	beq.n	80031d2 <UART001_lInit+0x112>
  {
   	/* Enable Format Error Interrupt*/  
    UartRegs->PCR_ASCMode |=(((uint32_t)SHIFT_ONE  << USIC_CH_PCR_CTR6_Pos) & \
 80031c6:	68fb      	ldr	r3, [r7, #12]
 80031c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80031ca:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80031ce:	68fb      	ldr	r3, [r7, #12]
 80031d0:	63da      	str	r2, [r3, #60]	; 0x3c
		  	  	  	  	                             USIC_CH_PCR_CTR6_Msk); 
  }
  
  if(Handle->FrameFinEn)
 80031d2:	687b      	ldr	r3, [r7, #4]
 80031d4:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80031d8:	2b00      	cmp	r3, #0
 80031da:	d005      	beq.n	80031e8 <UART001_lInit+0x128>
  {
   	/* Enable Frame Finished Interrupt*/  
    UartRegs->PCR_ASCMode |=(((uint32_t)SHIFT_ONE  << USIC_CH_PCR_CTR7_Pos) & \
 80031dc:	68fb      	ldr	r3, [r7, #12]
 80031de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80031e0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 80031e4:	68fb      	ldr	r3, [r7, #12]
 80031e6:	63da      	str	r2, [r3, #60]	; 0x3c
		  	                                   	  	 USIC_CH_PCR_CTR7_Msk); 
  } 
  
  if (Handle->TxFifoEn)
 80031e8:	687b      	ldr	r3, [r7, #4]
 80031ea:	7f9b      	ldrb	r3, [r3, #30]
 80031ec:	2b00      	cmp	r3, #0
 80031ee:	d00e      	beq.n	800320e <UART001_lInit+0x14e>
  {	
	  /* Configuration of Transmitter Buffer Control Register */ 
	  UartRegs->TBCTR |= ((((uint32_t)Handle->TxLimit  << \
 80031f0:	68fb      	ldr	r3, [r7, #12]
 80031f2:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
 80031f6:	687b      	ldr	r3, [r7, #4]
 80031f8:	f893 3020 	ldrb.w	r3, [r3, #32]
 80031fc:	ea4f 2303 	mov.w	r3, r3, lsl #8
						USIC_CH_TBCTR_LIMIT_Pos ) & USIC_CH_TBCTR_LIMIT_Msk));
 8003200:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
  } 
  
  if (Handle->TxFifoEn)
  {	
	  /* Configuration of Transmitter Buffer Control Register */ 
	  UartRegs->TBCTR |= ((((uint32_t)Handle->TxLimit  << \
 8003204:	431a      	orrs	r2, r3
 8003206:	68fb      	ldr	r3, [r7, #12]
 8003208:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
 800320c:	e005      	b.n	800321a <UART001_lInit+0x15a>
						USIC_CH_TBCTR_LIMIT_Pos ) & USIC_CH_TBCTR_LIMIT_Msk));
  }
  else
  {
	  /* TBIF is set to simplify polling*/
	  UartRegs->PSR_ASCMode |= (((uint32_t)SHIFT_ONE  << USIC_CH_PSR_TBIF_Pos) & \
 800320e:	68fb      	ldr	r3, [r7, #12]
 8003210:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003212:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
 8003216:	68fb      	ldr	r3, [r7, #12]
 8003218:	649a      	str	r2, [r3, #72]	; 0x48
	 		  (uint32_t)USIC_CH_PSR_TBIF_Msk);
  }
  
  if (Handle->RxFifoEn)
 800321a:	687b      	ldr	r3, [r7, #4]
 800321c:	7fdb      	ldrb	r3, [r3, #31]
 800321e:	2b00      	cmp	r3, #0
 8003220:	d00f      	beq.n	8003242 <UART001_lInit+0x182>
  {
	  /* Configuration of Receiver Buffer Control Register */ 
	  UartRegs->RBCTR |= ((((uint32_t)Handle->RxLimit  << \
 8003222:	68fb      	ldr	r3, [r7, #12]
 8003224:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8003228:	687b      	ldr	r3, [r7, #4]
 800322a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800322e:	ea4f 2303 	mov.w	r3, r3, lsl #8
						   USIC_CH_RBCTR_LIMIT_Pos) & USIC_CH_RBCTR_LIMIT_Msk) | \
 8003232:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
  }
  
  if (Handle->RxFifoEn)
  {
	  /* Configuration of Receiver Buffer Control Register */ 
	  UartRegs->RBCTR |= ((((uint32_t)Handle->RxLimit  << \
 8003236:	4313      	orrs	r3, r2
 8003238:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 800323c:	68fb      	ldr	r3, [r7, #12]
 800323e:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
							(((uint32_t)SHIFT_ONE << USIC_CH_RBCTR_LOF_Pos) & \
						   USIC_CH_RBCTR_LOF_Msk));
  }else{}
  
  /* Configuration of Channel Control Register */ 
  UartRegs->CCR |= (((uint32_t)(UART_MODE  & USIC_CH_CCR_MODE_Msk)) | \
 8003242:	68fb      	ldr	r3, [r7, #12]
 8003244:	6c1a      	ldr	r2, [r3, #64]	; 0x40
                    (((uint32_t)Handle->Parity  << USIC_CH_CCR_PM_Pos) & \
 8003246:	687b      	ldr	r3, [r7, #4]
 8003248:	7d9b      	ldrb	r3, [r3, #22]
 800324a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800324e:	f403 7340 	and.w	r3, r3, #768	; 0x300
							(((uint32_t)SHIFT_ONE << USIC_CH_RBCTR_LOF_Pos) & \
						   USIC_CH_RBCTR_LOF_Msk));
  }else{}
  
  /* Configuration of Channel Control Register */ 
  UartRegs->CCR |= (((uint32_t)(UART_MODE  & USIC_CH_CCR_MODE_Msk)) | \
 8003252:	4313      	orrs	r3, r2
 8003254:	f043 0202 	orr.w	r2, r3, #2
 8003258:	68fb      	ldr	r3, [r7, #12]
 800325a:	641a      	str	r2, [r3, #64]	; 0x40
                    (((uint32_t)Handle->Parity  << USIC_CH_CCR_PM_Pos) & \
                     USIC_CH_CCR_PM_Msk));

}
 800325c:	f107 0714 	add.w	r7, r7, #20
 8003260:	46bd      	mov	sp, r7
 8003262:	bc80      	pop	{r7}
 8003264:	4770      	bx	lr
 8003266:	bf00      	nop

08003268 <UART001_lConfigTXPin>:
 * @return  None <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/ 
void UART001_lConfigTXPin(const UART001_HandleType* Handle)
{
 8003268:	b480      	push	{r7}
 800326a:	b085      	sub	sp, #20
 800326c:	af00      	add	r7, sp, #0
 800326e:	6078      	str	r0, [r7, #4]
	uint32_t TempPortPin;

    /* set the TX portpin to '1' */
    Handle->PinHandle.TX_PortBase->OMR |= (uint32_t)SHIFT_ONE << \
 8003270:	687b      	ldr	r3, [r7, #4]
 8003272:	685b      	ldr	r3, [r3, #4]
 8003274:	687a      	ldr	r2, [r7, #4]
 8003276:	6852      	ldr	r2, [r2, #4]
 8003278:	6851      	ldr	r1, [r2, #4]
   		                                (uint32_t)Handle->PinHandle.TX_Pin;
 800327a:	687a      	ldr	r2, [r7, #4]
 800327c:	7a12      	ldrb	r2, [r2, #8]
void UART001_lConfigTXPin(const UART001_HandleType* Handle)
{
	uint32_t TempPortPin;

    /* set the TX portpin to '1' */
    Handle->PinHandle.TX_PortBase->OMR |= (uint32_t)SHIFT_ONE << \
 800327e:	f04f 0001 	mov.w	r0, #1
 8003282:	fa00 f202 	lsl.w	r2, r0, r2
 8003286:	430a      	orrs	r2, r1
 8003288:	605a      	str	r2, [r3, #4]
   		                                (uint32_t)Handle->PinHandle.TX_Pin;
     
	/* Configure TX portpin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.TX_Pin;
 800328a:	687b      	ldr	r3, [r7, #4]
 800328c:	7a1b      	ldrb	r3, [r3, #8]
 800328e:	60fb      	str	r3, [r7, #12]

    if (FIRST_NIBBLE > TempPortPin)
 8003290:	68fb      	ldr	r3, [r7, #12]
 8003292:	2b03      	cmp	r3, #3
 8003294:	d810      	bhi.n	80032b8 <UART001_lConfigTXPin+0x50>
    {
   	  Handle->PinHandle.TX_PortBase->IOCR0 |= \
 8003296:	687b      	ldr	r3, [r7, #4]
 8003298:	685b      	ldr	r3, [r3, #4]
 800329a:	687a      	ldr	r2, [r7, #4]
 800329c:	6852      	ldr	r2, [r2, #4]
 800329e:	6911      	ldr	r1, [r2, #16]
   			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
 80032a0:	68fa      	ldr	r2, [r7, #12]
 80032a2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    TempPortPin = (uint32_t)Handle->PinHandle.TX_Pin;

    if (FIRST_NIBBLE > TempPortPin)
    {
   	  Handle->PinHandle.TX_PortBase->IOCR0 |= \
   			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
 80032a6:	f102 0203 	add.w	r2, r2, #3
 80032aa:	f04f 0018 	mov.w	r0, #24
 80032ae:	fa00 f202 	lsl.w	r2, r0, r2
	/* Configure TX portpin as Open-drain General-purpose output */
    TempPortPin = (uint32_t)Handle->PinHandle.TX_Pin;

    if (FIRST_NIBBLE > TempPortPin)
    {
   	  Handle->PinHandle.TX_PortBase->IOCR0 |= \
 80032b2:	430a      	orrs	r2, r1
 80032b4:	611a      	str	r2, [r3, #16]
 80032b6:	e04f      	b.n	8003358 <UART001_lConfigTXPin+0xf0>
   			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
 80032b8:	68fb      	ldr	r3, [r7, #12]
 80032ba:	2b03      	cmp	r3, #3
 80032bc:	d917      	bls.n	80032ee <UART001_lConfigTXPin+0x86>
 80032be:	68fb      	ldr	r3, [r7, #12]
 80032c0:	2b07      	cmp	r3, #7
 80032c2:	d814      	bhi.n	80032ee <UART001_lConfigTXPin+0x86>
    {
	  TempPortPin = TempPortPin - FIRST_NIBBLE;
 80032c4:	68fb      	ldr	r3, [r7, #12]
 80032c6:	f1a3 0304 	sub.w	r3, r3, #4
 80032ca:	60fb      	str	r3, [r7, #12]
	  Handle->PinHandle.TX_PortBase->IOCR4 |= \
 80032cc:	687b      	ldr	r3, [r7, #4]
 80032ce:	685b      	ldr	r3, [r3, #4]
 80032d0:	687a      	ldr	r2, [r7, #4]
 80032d2:	6852      	ldr	r2, [r2, #4]
 80032d4:	6951      	ldr	r1, [r2, #20]
			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
 80032d6:	68fa      	ldr	r2, [r7, #12]
 80032d8:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - FIRST_NIBBLE;
	  Handle->PinHandle.TX_PortBase->IOCR4 |= \
			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
 80032dc:	f102 0203 	add.w	r2, r2, #3
 80032e0:	f04f 0018 	mov.w	r0, #24
 80032e4:	fa00 f202 	lsl.w	r2, r0, r2
							(TempPortPin * 8U)));
    }
    else if ((FIRST_NIBBLE <= TempPortPin) && (SECOND_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - FIRST_NIBBLE;
	  Handle->PinHandle.TX_PortBase->IOCR4 |= \
 80032e8:	430a      	orrs	r2, r1
 80032ea:	615a      	str	r2, [r3, #20]
 80032ec:	e034      	b.n	8003358 <UART001_lConfigTXPin+0xf0>
			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE > TempPortPin))
 80032ee:	68fb      	ldr	r3, [r7, #12]
 80032f0:	2b07      	cmp	r3, #7
 80032f2:	d917      	bls.n	8003324 <UART001_lConfigTXPin+0xbc>
 80032f4:	68fb      	ldr	r3, [r7, #12]
 80032f6:	2b0b      	cmp	r3, #11
 80032f8:	d814      	bhi.n	8003324 <UART001_lConfigTXPin+0xbc>
    {
 	  TempPortPin = TempPortPin - SECOND_NIBBLE;
 80032fa:	68fb      	ldr	r3, [r7, #12]
 80032fc:	f1a3 0308 	sub.w	r3, r3, #8
 8003300:	60fb      	str	r3, [r7, #12]
 	  Handle->PinHandle.TX_PortBase->IOCR8 |= \
 8003302:	687b      	ldr	r3, [r7, #4]
 8003304:	685b      	ldr	r3, [r3, #4]
 8003306:	687a      	ldr	r2, [r7, #4]
 8003308:	6852      	ldr	r2, [r2, #4]
 800330a:	6991      	ldr	r1, [r2, #24]
 			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
 800330c:	68fa      	ldr	r2, [r7, #12]
 800330e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - SECOND_NIBBLE;
 	  Handle->PinHandle.TX_PortBase->IOCR8 |= \
 			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
 8003312:	f102 0203 	add.w	r2, r2, #3
 8003316:	f04f 0018 	mov.w	r0, #24
 800331a:	fa00 f202 	lsl.w	r2, r0, r2
							(TempPortPin * 8U)));
    }
    else if ((SECOND_NIBBLE <= TempPortPin) && (THIRD_NIBBLE > TempPortPin))
    {
 	  TempPortPin = TempPortPin - SECOND_NIBBLE;
 	  Handle->PinHandle.TX_PortBase->IOCR8 |= \
 800331e:	430a      	orrs	r2, r1
 8003320:	619a      	str	r2, [r3, #24]
 8003322:	e019      	b.n	8003358 <UART001_lConfigTXPin+0xf0>
 			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE > TempPortPin))
 8003324:	68fb      	ldr	r3, [r7, #12]
 8003326:	2b0b      	cmp	r3, #11
 8003328:	d916      	bls.n	8003358 <UART001_lConfigTXPin+0xf0>
 800332a:	68fb      	ldr	r3, [r7, #12]
 800332c:	2b0f      	cmp	r3, #15
 800332e:	d813      	bhi.n	8003358 <UART001_lConfigTXPin+0xf0>
    {
	  TempPortPin = TempPortPin - THIRD_NIBBLE;
 8003330:	68fb      	ldr	r3, [r7, #12]
 8003332:	f1a3 030c 	sub.w	r3, r3, #12
 8003336:	60fb      	str	r3, [r7, #12]
	  Handle->PinHandle.TX_PortBase->IOCR12 |= \
 8003338:	687b      	ldr	r3, [r7, #4]
 800333a:	685b      	ldr	r3, [r3, #4]
 800333c:	687a      	ldr	r2, [r7, #4]
 800333e:	6852      	ldr	r2, [r2, #4]
 8003340:	69d1      	ldr	r1, [r2, #28]
			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
							(TempPortPin * 8U)));
 8003342:	68fa      	ldr	r2, [r7, #12]
 8003344:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - THIRD_NIBBLE;
	  Handle->PinHandle.TX_PortBase->IOCR12 |= \
			                ((uint32_t)UART001_OPENDRAIN_OUT << (3U + \
 8003348:	f102 0203 	add.w	r2, r2, #3
 800334c:	f04f 0018 	mov.w	r0, #24
 8003350:	fa00 f202 	lsl.w	r2, r0, r2
							(TempPortPin * 8U)));
    }
    else if ((THIRD_NIBBLE <= TempPortPin) && (FOURTH_NIBBLE > TempPortPin))
    {
	  TempPortPin = TempPortPin - THIRD_NIBBLE;
	  Handle->PinHandle.TX_PortBase->IOCR12 |= \
 8003354:	430a      	orrs	r2, r1
 8003356:	61da      	str	r2, [r3, #28]
							(TempPortPin * 8U)));
    }
	else
	{}

}
 8003358:	f107 0714 	add.w	r7, r7, #20
 800335c:	46bd      	mov	sp, r7
 800335e:	bc80      	pop	{r7}
 8003360:	4770      	bx	lr
 8003362:	bf00      	nop

08003364 <UART001_labsRealType>:
 * 				 -ve float value if Number is >= 0.0 <BR>
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/
float UART001_labsRealType(float Number)
{
 8003364:	b480      	push	{r7}
 8003366:	b085      	sub	sp, #20
 8003368:	af00      	add	r7, sp, #0
 800336a:	6078      	str	r0, [r7, #4]
   float return_value;
	if (Number < 0.0F){
 800336c:	edd7 7a01 	vldr	s15, [r7, #4]
 8003370:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8003374:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003378:	d506      	bpl.n	8003388 <UART001_labsRealType+0x24>
		return_value = -Number;
 800337a:	edd7 7a01 	vldr	s15, [r7, #4]
 800337e:	eef1 7a67 	vneg.f32	s15, s15
 8003382:	edc7 7a03 	vstr	s15, [r7, #12]
 8003386:	e001      	b.n	800338c <UART001_labsRealType+0x28>
	}
	else{
		return_value = Number;
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	60fb      	str	r3, [r7, #12]
	}
	return return_value;
 800338c:	68fb      	ldr	r3, [r7, #12]
}
 800338e:	4618      	mov	r0, r3
 8003390:	f107 0714 	add.w	r7, r7, #20
 8003394:	46bd      	mov	sp, r7
 8003396:	bc80      	pop	{r7}
 8003398:	4770      	bx	lr
 800339a:	bf00      	nop

0800339c <UART001_lConfigureBaudRate>:
 *
 * <b>Reentrant: No </b><BR>
 ******************************************************************************/
void UART001_lConfigureBaudRate\
                              (uint32_t BaudRate,uint32_t* Pdiv,uint32_t* Step)
{
 800339c:	b580      	push	{r7, lr}
 800339e:	ed2d 8b02 	vpush	{d8}
 80033a2:	b0ae      	sub	sp, #184	; 0xb8
 80033a4:	af00      	add	r7, sp, #0
 80033a6:	60f8      	str	r0, [r7, #12]
 80033a8:	60b9      	str	r1, [r7, #8]
 80033aa:	607a      	str	r2, [r7, #4]
	uint32_t fdr_step = 0x00U;
 80033ac:	f04f 0300 	mov.w	r3, #0
 80033b0:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	uint32_t brg_pdiv = 0x00U;
 80033b4:	f04f 0300 	mov.w	r3, #0
 80033b8:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
	uint32_t divisor_in = BaudRate ;
 80033bc:	68fb      	ldr	r3, [r7, #12]
 80033be:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	/* fPB / 1024 * (Brg_dctq + 1) */
	uint32_t dividend_in = 0U;
 80033c2:	f04f 0300 	mov.w	r3, #0
 80033c6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	uint32_t divisor_array[4];
	uint32_t dividend_array[4];
	uint32_t div_array[4];
	uint32_t max, frac,divisor1,divisor2,dividend1,dividend2;
	uint32_t array_count,array_count_1,array_count_2;
	uint32_t do_while_break = 0U;
 80033ca:	f04f 0300 	mov.w	r3, #0
 80033ce:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
	uint32_t temp = 0U;
 80033d2:	f04f 0300 	mov.w	r3, #0
 80033d6:	67fb      	str	r3, [r7, #124]	; 0x7c
	float div_factor;
	uint32_t loop_cnt;
	bool swapped;
	dividend_in = (uint32_t)((uint32_t)(UART001_CLOCK * 1000000)/ \
 80033d8:	f642 53c6 	movw	r3, #11718	; 0x2dc6
 80033dc:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
                    	(UART001_MAX_VALUE * UART001_DCTQ_VALUE)); 
	/* swap if divisor_in/dividend_in > max_divisor/max_dividend */
	div_factor = (float) divisor_in/(float) dividend_in;
 80033e0:	edd7 7a2b 	vldr	s15, [r7, #172]	; 0xac
 80033e4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 80033e8:	edd7 7a2a 	vldr	s15, [r7, #168]	; 0xa8
 80033ec:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80033f0:	eec7 7a27 	vdiv.f32	s15, s14, s15
 80033f4:	edc7 7a1e 	vstr	s15, [r7, #120]	; 0x78
	if ( div_factor > 1.0F)
 80033f8:	ed97 7a1e 	vldr	s14, [r7, #120]	; 0x78
 80033fc:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 8003400:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8003404:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8003408:	dd12      	ble.n	8003430 <UART001_lConfigureBaudRate+0x94>
	{
		max = UART001_MAX_VALUE;
 800340a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800340e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		swapped = 1U;
 8003412:	f04f 0301 	mov.w	r3, #1
 8003416:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
		temp = divisor_in;
 800341a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800341e:	67fb      	str	r3, [r7, #124]	; 0x7c
		divisor_in = dividend_in;
 8003420:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8003424:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
		dividend_in = temp;
 8003428:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800342a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 800342e:	e007      	b.n	8003440 <UART001_lConfigureBaudRate+0xa4>
	}
	else
	{
		swapped = 0U;
 8003430:	f04f 0300 	mov.w	r3, #0
 8003434:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
		max = UART001_MAX_VALUE;
 8003438:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800343c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
	}
	/*Init parameters*/
	loop_cnt = 0U;
 8003440:	f04f 0300 	mov.w	r3, #0
 8003444:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
	array_count = 0U;
 8003448:	f04f 0300 	mov.w	r3, #0
 800344c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
	array_count_1 = 0U;
 8003450:	f04f 0300 	mov.w	r3, #0
 8003454:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
	divisor[0] = divisor_in;
 8003458:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800345c:	663b      	str	r3, [r7, #96]	; 0x60
	remainder[0] = dividend_in;
 800345e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8003462:	643b      	str	r3, [r7, #64]	; 0x40
	divisor_array[0] = 1U;
 8003464:	f04f 0301 	mov.w	r3, #1
 8003468:	633b      	str	r3, [r7, #48]	; 0x30
	dividend_array[0] = 0U;
 800346a:	f04f 0300 	mov.w	r3, #0
 800346e:	623b      	str	r3, [r7, #32]
	do {
			++loop_cnt;
 8003470:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8003474:	f103 0301 	add.w	r3, r3, #1
 8003478:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
			array_count_2 = array_count_1; /* on first loop is not used */
 800347c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8003480:	677b      	str	r3, [r7, #116]	; 0x74
			array_count_1 = array_count;
 8003482:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8003486:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
			array_count = loop_cnt % 4U;
 800348a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800348e:	f003 0303 	and.w	r3, r3, #3
 8003492:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
			dividend[array_count] = divisor[array_count_1];
 8003496:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800349a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800349e:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80034a2:	18cb      	adds	r3, r1, r3
 80034a4:	f853 2c58 	ldr.w	r2, [r3, #-88]
 80034a8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80034ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034b0:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80034b4:	18cb      	adds	r3, r1, r3
 80034b6:	f843 2c68 	str.w	r2, [r3, #-104]
			
			divisor[array_count] = remainder[array_count_1];
 80034ba:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80034be:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034c2:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80034c6:	18d3      	adds	r3, r2, r3
 80034c8:	f853 2c78 	ldr.w	r2, [r3, #-120]
 80034cc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80034d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034d4:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80034d8:	18cb      	adds	r3, r1, r3
 80034da:	f843 2c58 	str.w	r2, [r3, #-88]
			
			div_array[array_count] = \
			                       dividend[array_count] / divisor[array_count];
 80034de:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80034e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034e6:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80034ea:	18d3      	adds	r3, r2, r3
 80034ec:	f853 2c68 	ldr.w	r2, [r3, #-104]
 80034f0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80034f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80034f8:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80034fc:	18cb      	adds	r3, r1, r3
 80034fe:	f853 3c58 	ldr.w	r3, [r3, #-88]
 8003502:	fbb2 f2f3 	udiv	r2, r2, r3
			array_count = loop_cnt % 4U;
			dividend[array_count] = divisor[array_count_1];
			
			divisor[array_count] = remainder[array_count_1];
			
			div_array[array_count] = \
 8003506:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800350a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800350e:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8003512:	18cb      	adds	r3, r1, r3
 8003514:	f843 2ca8 	str.w	r2, [r3, #-168]
			                       dividend[array_count] / divisor[array_count];
			
			remainder[array_count] = \
			                       dividend[array_count] % divisor[array_count];
 8003518:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800351c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003520:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8003524:	18d3      	adds	r3, r2, r3
 8003526:	f853 2c68 	ldr.w	r2, [r3, #-104]
 800352a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800352e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003532:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8003536:	18cb      	adds	r3, r1, r3
 8003538:	f853 3c58 	ldr.w	r3, [r3, #-88]
 800353c:	fbb2 f1f3 	udiv	r1, r2, r3
 8003540:	fb03 f301 	mul.w	r3, r3, r1
 8003544:	1ad2      	subs	r2, r2, r3
			divisor[array_count] = remainder[array_count_1];
			
			div_array[array_count] = \
			                       dividend[array_count] / divisor[array_count];
			
			remainder[array_count] = \
 8003546:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800354a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800354e:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8003552:	18cb      	adds	r3, r1, r3
 8003554:	f843 2c78 	str.w	r2, [r3, #-120]
			                       dividend[array_count] % divisor[array_count];
			
			/* This executed only on first loop */
			if (loop_cnt == 1U)
 8003558:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800355c:	2b01      	cmp	r3, #1
 800355e:	d105      	bne.n	800356c <UART001_lConfigureBaudRate+0x1d0>
			{ 
				divisor_array[1] = div_array[1];
 8003560:	697b      	ldr	r3, [r7, #20]
 8003562:	637b      	str	r3, [r7, #52]	; 0x34
				dividend_array[1] = 1U;
 8003564:	f04f 0301 	mov.w	r3, #1
 8003568:	627b      	str	r3, [r7, #36]	; 0x24
 800356a:	e04b      	b.n	8003604 <UART001_lConfigureBaudRate+0x268>
			}
			else
			{
				divisor_array[array_count] = \
				      (div_array[array_count] * divisor_array[array_count_1]) + \
 800356c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8003570:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003574:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8003578:	18d3      	adds	r3, r2, r3
 800357a:	f853 2ca8 	ldr.w	r2, [r3, #-168]
 800357e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8003582:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003586:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 800358a:	18cb      	adds	r3, r1, r3
 800358c:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8003590:	fb03 f202 	mul.w	r2, r3, r2
				       divisor_array[array_count_2];
 8003594:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8003596:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800359a:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 800359e:	18cb      	adds	r3, r1, r3
 80035a0:	f853 3c88 	ldr.w	r3, [r3, #-136]
				dividend_array[1] = 1U;
			}
			else
			{
				divisor_array[array_count] = \
				      (div_array[array_count] * divisor_array[array_count_1]) + \
 80035a4:	18d2      	adds	r2, r2, r3
				divisor_array[1] = div_array[1];
				dividend_array[1] = 1U;
			}
			else
			{
				divisor_array[array_count] = \
 80035a6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80035aa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80035ae:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80035b2:	18cb      	adds	r3, r1, r3
 80035b4:	f843 2c88 	str.w	r2, [r3, #-136]
				      (div_array[array_count] * divisor_array[array_count_1]) + \
				       divisor_array[array_count_2];
				dividend_array[array_count] = \
				      (div_array[array_count] * dividend_array[array_count_1]) + \
 80035b8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80035bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80035c0:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80035c4:	18d3      	adds	r3, r2, r3
 80035c6:	f853 2ca8 	ldr.w	r2, [r3, #-168]
 80035ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80035ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80035d2:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80035d6:	18cb      	adds	r3, r1, r3
 80035d8:	f853 3c98 	ldr.w	r3, [r3, #-152]
 80035dc:	fb03 f202 	mul.w	r2, r3, r2
				       dividend_array[array_count_2];
 80035e0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80035e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80035e6:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80035ea:	18cb      	adds	r3, r1, r3
 80035ec:	f853 3c98 	ldr.w	r3, [r3, #-152]
			{
				divisor_array[array_count] = \
				      (div_array[array_count] * divisor_array[array_count_1]) + \
				       divisor_array[array_count_2];
				dividend_array[array_count] = \
				      (div_array[array_count] * dividend_array[array_count_1]) + \
 80035f0:	18d2      	adds	r2, r2, r3
			else
			{
				divisor_array[array_count] = \
				      (div_array[array_count] * divisor_array[array_count_1]) + \
				       divisor_array[array_count_2];
				dividend_array[array_count] = \
 80035f2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80035f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80035fa:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80035fe:	18cb      	adds	r3, r1, r3
 8003600:	f843 2c98 	str.w	r2, [r3, #-152]
				      (div_array[array_count] * dividend_array[array_count_1]) + \
				       dividend_array[array_count_2];
			}
			if (dividend_array[array_count] > max) 
 8003604:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8003608:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800360c:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8003610:	18d3      	adds	r3, r2, r3
 8003612:	f853 2c98 	ldr.w	r2, [r3, #-152]
 8003616:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800361a:	429a      	cmp	r2, r3
 800361c:	f240 80df 	bls.w	80037de <UART001_lConfigureBaudRate+0x442>
			{
				divisor1 = divisor_array[array_count_1];
 8003620:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8003624:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003628:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 800362c:	18cb      	adds	r3, r1, r3
 800362e:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8003632:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
				dividend1 = dividend_array[array_count_1];
 8003636:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800363a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800363e:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8003642:	18d3      	adds	r3, r2, r3
 8003644:	f853 3c98 	ldr.w	r3, [r3, #-152]
 8003648:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
				frac = (max - dividend_array[array_count_2]) / \
 800364c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800364e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003652:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8003656:	18cb      	adds	r3, r1, r3
 8003658:	f853 3c98 	ldr.w	r3, [r3, #-152]
 800365c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8003660:	1ad2      	subs	r2, r2, r3
				                               dividend_array[array_count_1];
 8003662:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8003666:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800366a:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 800366e:	18cb      	adds	r3, r1, r3
 8003670:	f853 3c98 	ldr.w	r3, [r3, #-152]
			}
			if (dividend_array[array_count] > max) 
			{
				divisor1 = divisor_array[array_count_1];
				dividend1 = dividend_array[array_count_1];
				frac = (max - dividend_array[array_count_2]) / \
 8003674:	fbb2 f3f3 	udiv	r3, r2, r3
 8003678:	673b      	str	r3, [r7, #112]	; 0x70
				                               dividend_array[array_count_1];
				divisor2 = (frac * divisor_array[array_count-1U]) + \
 800367a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800367e:	f103 33ff 	add.w	r3, r3, #4294967295
 8003682:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003686:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 800368a:	18d3      	adds	r3, r2, r3
 800368c:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8003690:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8003692:	fb02 f203 	mul.w	r2, r2, r3
				                                divisor_array[array_count-2U];
 8003696:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800369a:	f1a3 0302 	sub.w	r3, r3, #2
 800369e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80036a2:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80036a6:	18cb      	adds	r3, r1, r3
 80036a8:	f853 3c88 	ldr.w	r3, [r3, #-136]
			{
				divisor1 = divisor_array[array_count_1];
				dividend1 = dividend_array[array_count_1];
				frac = (max - dividend_array[array_count_2]) / \
				                               dividend_array[array_count_1];
				divisor2 = (frac * divisor_array[array_count-1U]) + \
 80036ac:	18d3      	adds	r3, r2, r3
 80036ae:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
				                                divisor_array[array_count-2U];
				dividend2 = (frac * dividend_array[array_count-1U]) + \
 80036b2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80036b6:	f103 33ff 	add.w	r3, r3, #4294967295
 80036ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80036be:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80036c2:	18d3      	adds	r3, r2, r3
 80036c4:	f853 3c98 	ldr.w	r3, [r3, #-152]
 80036c8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80036ca:	fb02 f203 	mul.w	r2, r2, r3
				                               dividend_array[array_count_2];
 80036ce:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80036d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80036d4:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 80036d8:	18cb      	adds	r3, r1, r3
 80036da:	f853 3c98 	ldr.w	r3, [r3, #-152]
				dividend1 = dividend_array[array_count_1];
				frac = (max - dividend_array[array_count_2]) / \
				                               dividend_array[array_count_1];
				divisor2 = (frac * divisor_array[array_count-1U]) + \
				                                divisor_array[array_count-2U];
				dividend2 = (frac * dividend_array[array_count-1U]) + \
 80036de:	18d3      	adds	r3, r2, r3
 80036e0:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
				                               dividend_array[array_count_2];
				/* Swap if required */
				if (swapped) {
 80036e4:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 80036e8:	2b00      	cmp	r3, #0
 80036ea:	d013      	beq.n	8003714 <UART001_lConfigureBaudRate+0x378>
						/* Swap divisor1 and dividend1 */
						temp = divisor1;
 80036ec:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80036f0:	67fb      	str	r3, [r7, #124]	; 0x7c
						divisor1 = dividend1;
 80036f2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80036f6:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
						dividend1 = temp;
 80036fa:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80036fc:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
						/* Swap divisor2 and dividend2 */
						temp = divisor2;
 8003700:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003704:	67fb      	str	r3, [r7, #124]	; 0x7c
						divisor2 = dividend2;
 8003706:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800370a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
						dividend2 = temp;
 800370e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8003710:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
					}
				/* Remove if one of has divisor 0 */
				if ((dividend1 == 0U) || (divisor1 == 0U)) {
 8003714:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8003718:	2b00      	cmp	r3, #0
 800371a:	d003      	beq.n	8003724 <UART001_lConfigureBaudRate+0x388>
 800371c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8003720:	2b00      	cmp	r3, #0
 8003722:	d108      	bne.n	8003736 <UART001_lConfigureBaudRate+0x39a>
					fdr_step = divisor2;
 8003724:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003728:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
					brg_pdiv = dividend2;
 800372c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8003730:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8003734:	e04e      	b.n	80037d4 <UART001_lConfigureBaudRate+0x438>
				}else if ((dividend2 == 0U) || (divisor2 == 0U)) {
 8003736:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800373a:	2b00      	cmp	r3, #0
 800373c:	d003      	beq.n	8003746 <UART001_lConfigureBaudRate+0x3aa>
 800373e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8003742:	2b00      	cmp	r3, #0
 8003744:	d108      	bne.n	8003758 <UART001_lConfigureBaudRate+0x3bc>
					fdr_step = divisor1;
 8003746:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800374a:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
					brg_pdiv = dividend1;
 800374e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8003752:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8003756:	e03d      	b.n	80037d4 <UART001_lConfigureBaudRate+0x438>
				}else { 
					/*  Find the most nearest to target division */
					if (UART001_labsRealType(div_factor - \
					    ((float) divisor1 / (float) dividend1 )) > \
 8003758:	edd7 7a28 	vldr	s15, [r7, #160]	; 0xa0
 800375c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8003760:	edd7 7a26 	vldr	s15, [r7, #152]	; 0x98
 8003764:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003768:	eec7 7a27 	vdiv.f32	s15, s14, s15
				}else if ((dividend2 == 0U) || (divisor2 == 0U)) {
					fdr_step = divisor1;
					brg_pdiv = dividend1;
				}else { 
					/*  Find the most nearest to target division */
					if (UART001_labsRealType(div_factor - \
 800376c:	ed97 7a1e 	vldr	s14, [r7, #120]	; 0x78
 8003770:	ee77 7a67 	vsub.f32	s15, s14, s15
 8003774:	ee17 0a90 	vmov	r0, s15
 8003778:	f7ff fdf4 	bl	8003364 <UART001_labsRealType>
 800377c:	ee08 0a10 	vmov	s16, r0
					    ((float) divisor1 / (float) dividend1 )) > \
					    UART001_labsRealType(div_factor - \
					    ((float) divisor2 / (float) dividend2 ))) 
 8003780:	edd7 7a27 	vldr	s15, [r7, #156]	; 0x9c
 8003784:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8003788:	edd7 7a25 	vldr	s15, [r7, #148]	; 0x94
 800378c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8003790:	eec7 7a27 	vdiv.f32	s15, s14, s15
					brg_pdiv = dividend1;
				}else { 
					/*  Find the most nearest to target division */
					if (UART001_labsRealType(div_factor - \
					    ((float) divisor1 / (float) dividend1 )) > \
					    UART001_labsRealType(div_factor - \
 8003794:	ed97 7a1e 	vldr	s14, [r7, #120]	; 0x78
 8003798:	ee77 7a67 	vsub.f32	s15, s14, s15
 800379c:	ee17 0a90 	vmov	r0, s15
 80037a0:	f7ff fde0 	bl	8003364 <UART001_labsRealType>
 80037a4:	ee07 0a90 	vmov	s15, r0
				}else if ((dividend2 == 0U) || (divisor2 == 0U)) {
					fdr_step = divisor1;
					brg_pdiv = dividend1;
				}else { 
					/*  Find the most nearest to target division */
					if (UART001_labsRealType(div_factor - \
 80037a8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80037ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80037b0:	dd08      	ble.n	80037c4 <UART001_lConfigureBaudRate+0x428>
					    ((float) divisor1 / (float) dividend1 )) > \
					    UART001_labsRealType(div_factor - \
					    ((float) divisor2 / (float) dividend2 ))) 
					{
						fdr_step = divisor2;
 80037b2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80037b6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
						brg_pdiv = dividend2;
 80037ba:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80037be:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 80037c2:	e007      	b.n	80037d4 <UART001_lConfigureBaudRate+0x438>
					}else {
						fdr_step = divisor1;
 80037c4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80037c8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
						brg_pdiv = dividend1;
 80037cc:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80037d0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
					}
				}
				do_while_break = 0x05U;
 80037d4:	f04f 0305 	mov.w	r3, #5
 80037d8:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 80037dc:	e032      	b.n	8003844 <UART001_lConfigureBaudRate+0x4a8>
			}
			else if (remainder[array_count]== 0U) 
 80037de:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80037e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80037e6:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 80037ea:	18d3      	adds	r3, r2, r3
 80037ec:	f853 3c78 	ldr.w	r3, [r3, #-120]
 80037f0:	2b00      	cmp	r3, #0
 80037f2:	d127      	bne.n	8003844 <UART001_lConfigureBaudRate+0x4a8>
			{
				fdr_step = divisor_array[array_count];
 80037f4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80037f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80037fc:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 8003800:	18cb      	adds	r3, r1, r3
 8003802:	f853 3c88 	ldr.w	r3, [r3, #-136]
 8003806:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
				brg_pdiv = dividend_array[array_count];
 800380a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800380e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003812:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
 8003816:	18d3      	adds	r3, r2, r3
 8003818:	f853 3c98 	ldr.w	r3, [r3, #-152]
 800381c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
				if (swapped)
 8003820:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 8003824:	2b00      	cmp	r3, #0
 8003826:	d009      	beq.n	800383c <UART001_lConfigureBaudRate+0x4a0>
				{
					/* Swap fdr_step and brg_pdiv */
					temp = fdr_step;
 8003828:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 800382c:	67fb      	str	r3, [r7, #124]	; 0x7c
					fdr_step = brg_pdiv;
 800382e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8003832:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
					brg_pdiv = temp;
 8003836:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8003838:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
				}
				do_while_break = 0x05U;
 800383c:	f04f 0305 	mov.w	r3, #5
 8003840:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
			}
			else {
			  /* Do Nothing */
			}
		} while (do_while_break != 0x05U);
 8003844:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8003848:	2b05      	cmp	r3, #5
 800384a:	f47f ae11 	bne.w	8003470 <UART001_lConfigureBaudRate+0xd4>

	if(fdr_step >= UART001_MAX_VALUE)
 800384e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003852:	f240 33ff 	movw	r3, #1023	; 0x3ff
 8003856:	429a      	cmp	r2, r3
 8003858:	d903      	bls.n	8003862 <UART001_lConfigureBaudRate+0x4c6>
	{
	   fdr_step = 1023U;
 800385a:	f240 33ff 	movw	r3, #1023	; 0x3ff
 800385e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	}

	*Step = fdr_step;
 8003862:	687b      	ldr	r3, [r7, #4]
 8003864:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8003868:	601a      	str	r2, [r3, #0]

	*Pdiv = brg_pdiv - 1U;
 800386a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800386e:	f103 32ff 	add.w	r2, r3, #4294967295
 8003872:	68bb      	ldr	r3, [r7, #8]
 8003874:	601a      	str	r2, [r3, #0]
}
 8003876:	f107 07b8 	add.w	r7, r7, #184	; 0xb8
 800387a:	46bd      	mov	sp, r7
 800387c:	ecbd 8b02 	vpop	{d8}
 8003880:	bd80      	pop	{r7, pc}
 8003882:	bf00      	nop

08003884 <UART001_Init>:
 *
 * <b>Reentrant: No </b><BR>
 *
 ******************************************************************************/
void UART001_Init(void)
{
 8003884:	b580      	push	{r7, lr}
 8003886:	b082      	sub	sp, #8
 8003888:	af00      	add	r7, sp, #0
	  /* Reset the Peripheral*/
   #if defined(UART001_PER0_USIC0_ENABLED)
	  RESET001_DeassertReset(PER0_USIC0);
   #endif
   #if defined(UART001_PER1_USIC1_ENABLED)
	  RESET001_DeassertReset(PER1_USIC1); 
 800388a:	f04f 0080 	mov.w	r0, #128	; 0x80
 800388e:	f2c1 0000 	movt	r0, #4096	; 0x1000
 8003892:	f006 f88f 	bl	80099b4 <RESET001_DeassertReset>
   #if defined(UART001_PER1_USIC2_ENABLED)
	  RESET001_DeassertReset(PER1_USIC2); 
   #endif 
   #endif  
	  
   for (LoopIndex = (uint32_t)0; LoopIndex < (uint32_t)UART001_NUM_HANDLES; \
 8003896:	f04f 0300 	mov.w	r3, #0
 800389a:	607b      	str	r3, [r7, #4]
 800389c:	e021      	b.n	80038e2 <UART001_Init+0x5e>
	                           LoopIndex++)
   {
	  if (UART001_HandleArray[LoopIndex]->Mode == UART_HALFDUPLEX)
 800389e:	f246 6370 	movw	r3, #26224	; 0x6670
 80038a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038a6:	687a      	ldr	r2, [r7, #4]
 80038a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80038ac:	7d1b      	ldrb	r3, [r3, #20]
 80038ae:	2b01      	cmp	r3, #1
 80038b0:	d109      	bne.n	80038c6 <UART001_Init+0x42>
	  {
	   /*Configure TX Pin in Open-drain mode to allow the Wired-AND connection*/
		UART001_lConfigTXPin(UART001_HandleArray[LoopIndex]);
 80038b2:	f246 6370 	movw	r3, #26224	; 0x6670
 80038b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038ba:	687a      	ldr	r2, [r7, #4]
 80038bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80038c0:	4618      	mov	r0, r3
 80038c2:	f7ff fcd1 	bl	8003268 <UART001_lConfigTXPin>
	  }
	  
	  UART001_lInit(UART001_HandleArray[LoopIndex]);
 80038c6:	f246 6370 	movw	r3, #26224	; 0x6670
 80038ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038ce:	687a      	ldr	r2, [r7, #4]
 80038d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80038d4:	4618      	mov	r0, r3
 80038d6:	f7ff fbf3 	bl	80030c0 <UART001_lInit>
	  RESET001_DeassertReset(PER1_USIC2); 
   #endif 
   #endif  
	  
   for (LoopIndex = (uint32_t)0; LoopIndex < (uint32_t)UART001_NUM_HANDLES; \
	                           LoopIndex++)
 80038da:	687b      	ldr	r3, [r7, #4]
 80038dc:	f103 0301 	add.w	r3, r3, #1
 80038e0:	607b      	str	r3, [r7, #4]
   #if defined(UART001_PER1_USIC2_ENABLED)
	  RESET001_DeassertReset(PER1_USIC2); 
   #endif 
   #endif  
	  
   for (LoopIndex = (uint32_t)0; LoopIndex < (uint32_t)UART001_NUM_HANDLES; \
 80038e2:	687b      	ldr	r3, [r7, #4]
 80038e4:	2b00      	cmp	r3, #0
 80038e6:	d0da      	beq.n	800389e <UART001_Init+0x1a>
	  }
	  
	  UART001_lInit(UART001_HandleArray[LoopIndex]);
   }
   
}
 80038e8:	f107 0708 	add.w	r7, r7, #8
 80038ec:	46bd      	mov	sp, r7
 80038ee:	bd80      	pop	{r7, pc}

080038f0 <UART001_DeInit>:
 *
 * <b>Reentrant: No </b><BR>
 *
 ******************************************************************************/
 void  UART001_DeInit (const UART001_HandleType* Handle)
{
 80038f0:	b480      	push	{r7}
 80038f2:	b083      	sub	sp, #12
 80038f4:	af00      	add	r7, sp, #0
 80038f6:	6078      	str	r0, [r7, #4]
  /* <<<DD_UART001_API_2>>> */
  /* Place holder function */      
}
 80038f8:	f107 070c 	add.w	r7, r7, #12
 80038fc:	46bd      	mov	sp, r7
 80038fe:	bc80      	pop	{r7}
 8003900:	4770      	bx	lr
 8003902:	bf00      	nop

08003904 <UART001_Configure>:
  const UART001_HandleType* Handle,
  uint32_t BaudRate,
  UART_ParityType Parity,
  UART_StopBitType Stopbit
)
{
 8003904:	b580      	push	{r7, lr}
 8003906:	b08a      	sub	sp, #40	; 0x28
 8003908:	af00      	add	r7, sp, #0
 800390a:	60f8      	str	r0, [r7, #12]
 800390c:	60b9      	str	r1, [r7, #8]
 800390e:	71fa      	strb	r2, [r7, #7]
 8003910:	71bb      	strb	r3, [r7, #6]
   uint32_t Brg_Pdiv = 0x00U;
 8003912:	f04f 0300 	mov.w	r3, #0
 8003916:	617b      	str	r3, [r7, #20]
   uint32_t Fdr_Step = 0x00U;
 8003918:	f04f 0300 	mov.w	r3, #0
 800391c:	613b      	str	r3, [r7, #16]
   uint32_t TXIDLE_status;
   uint32_t RXIDLE_status;
   USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
 800391e:	68fb      	ldr	r3, [r7, #12]
 8003920:	681b      	ldr	r3, [r3, #0]
 8003922:	623b      	str	r3, [r7, #32]
   status_t Status = (status_t)UART001_ERROR;
 8003924:	f04f 0305 	mov.w	r3, #5
 8003928:	627b      	str	r3, [r7, #36]	; 0x24
   
   /* <<<DD_UART001_API_3>>>*/

   TXIDLE_status = (uint32_t)\
                 RD_REG(UartRegs->PSR_ASCMode,USIC_CH_PSR_ASCMode_TXIDLE_Msk, \
 800392a:	6a3b      	ldr	r3, [r7, #32]
 800392c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
   status_t Status = (status_t)UART001_ERROR;
   
   /* <<<DD_UART001_API_3>>>*/

   TXIDLE_status = (uint32_t)\
 800392e:	f003 0301 	and.w	r3, r3, #1
 8003932:	61fb      	str	r3, [r7, #28]
                 RD_REG(UartRegs->PSR_ASCMode,USIC_CH_PSR_ASCMode_TXIDLE_Msk, \
	                       USIC_CH_PSR_ASCMode_TXIDLE_Pos);

   RXIDLE_status = (uint32_t)\
                 RD_REG(UartRegs->PSR_ASCMode,USIC_CH_PSR_ASCMode_RXIDLE_Msk, \
 8003934:	6a3b      	ldr	r3, [r7, #32]
 8003936:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003938:	f003 0302 	and.w	r3, r3, #2

   TXIDLE_status = (uint32_t)\
                 RD_REG(UartRegs->PSR_ASCMode,USIC_CH_PSR_ASCMode_TXIDLE_Msk, \
	                       USIC_CH_PSR_ASCMode_TXIDLE_Pos);

   RXIDLE_status = (uint32_t)\
 800393c:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8003940:	61bb      	str	r3, [r7, #24]
                 RD_REG(UartRegs->PSR_ASCMode,USIC_CH_PSR_ASCMode_RXIDLE_Msk, \
	                       USIC_CH_PSR_ASCMode_RXIDLE_Pos);
   if(( TXIDLE_status & RXIDLE_status) == 0x01U)
 8003942:	69fa      	ldr	r2, [r7, #28]
 8003944:	69bb      	ldr	r3, [r7, #24]
 8003946:	4013      	ands	r3, r2
 8003948:	2b01      	cmp	r3, #1
 800394a:	d15b      	bne.n	8003a04 <UART001_Configure+0x100>
    {
      /* Disable UART mode before configuring all USIC registers to avoid 
       * unintended edges */ 
      UartRegs->CCR &= ~( ((uint32_t)(UART_MODE  & USIC_CH_CCR_MODE_Msk)));  
 800394c:	6a3b      	ldr	r3, [r7, #32]
 800394e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003950:	f023 0202 	bic.w	r2, r3, #2
 8003954:	6a3b      	ldr	r3, [r7, #32]
 8003956:	641a      	str	r2, [r3, #64]	; 0x40
	  
      /* Configuration of USIC Channel Fractional Divider */
      UART001_lConfigureBaudRate(BaudRate,&Brg_Pdiv,&Fdr_Step);
 8003958:	f107 0214 	add.w	r2, r7, #20
 800395c:	f107 0310 	add.w	r3, r7, #16
 8003960:	68b8      	ldr	r0, [r7, #8]
 8003962:	4611      	mov	r1, r2
 8003964:	461a      	mov	r2, r3
 8003966:	f7ff fd19 	bl	800339c <UART001_lConfigureBaudRate>

      /* Step value: 0x3FF */
      UartRegs->FDR &= ~(USIC_CH_FDR_STEP_Msk);
 800396a:	6a3b      	ldr	r3, [r7, #32]
 800396c:	691b      	ldr	r3, [r3, #16]
 800396e:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8003972:	f023 0303 	bic.w	r3, r3, #3
 8003976:	6a3a      	ldr	r2, [r7, #32]
 8003978:	6113      	str	r3, [r2, #16]
      UartRegs->FDR |= ( Fdr_Step & USIC_CH_FDR_STEP_Msk);
 800397a:	6a3b      	ldr	r3, [r7, #32]
 800397c:	691a      	ldr	r2, [r3, #16]
 800397e:	693b      	ldr	r3, [r7, #16]
 8003980:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8003984:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8003988:	431a      	orrs	r2, r3
 800398a:	6a3b      	ldr	r3, [r7, #32]
 800398c:	611a      	str	r2, [r3, #16]
              
      /* The PreDivider for CTQ, PCTQ = 0  */
      /* The Denominator for CTQ, DCTQ = 16 */

      UartRegs->BRG &= ~(USIC_CH_BRG_PDIV_Msk);
 800398e:	6a3b      	ldr	r3, [r7, #32]
 8003990:	695b      	ldr	r3, [r3, #20]
 8003992:	f023 737f 	bic.w	r3, r3, #66846720	; 0x3fc0000
 8003996:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 800399a:	6a3a      	ldr	r2, [r7, #32]
 800399c:	6153      	str	r3, [r2, #20]
      UartRegs->BRG |= ((((uint32_t)Brg_Pdiv  << USIC_CH_BRG_PDIV_Pos) \
 800399e:	6a3b      	ldr	r3, [r7, #32]
 80039a0:	695a      	ldr	r2, [r3, #20]
 80039a2:	697b      	ldr	r3, [r7, #20]
 80039a4:	ea4f 4103 	mov.w	r1, r3, lsl #16
    		                                          &  USIC_CH_BRG_PDIV_Msk));
 80039a8:	f04f 0300 	mov.w	r3, #0
 80039ac:	f2c0 33ff 	movt	r3, #1023	; 0x3ff
 80039b0:	400b      	ands	r3, r1
              
      /* The PreDivider for CTQ, PCTQ = 0  */
      /* The Denominator for CTQ, DCTQ = 16 */

      UartRegs->BRG &= ~(USIC_CH_BRG_PDIV_Msk);
      UartRegs->BRG |= ((((uint32_t)Brg_Pdiv  << USIC_CH_BRG_PDIV_Pos) \
 80039b2:	431a      	orrs	r2, r3
 80039b4:	6a3b      	ldr	r3, [r7, #32]
 80039b6:	615a      	str	r2, [r3, #20]
    		                                          &  USIC_CH_BRG_PDIV_Msk));

      /* Configure StopBit */
      UartRegs->PCR_ASCMode &= ~(USIC_CH_PCR_ASCMode_STPB_Msk);
 80039b8:	6a3b      	ldr	r3, [r7, #32]
 80039ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80039bc:	f023 0202 	bic.w	r2, r3, #2
 80039c0:	6a3b      	ldr	r3, [r7, #32]
 80039c2:	63da      	str	r2, [r3, #60]	; 0x3c
      UartRegs->PCR_ASCMode |= \
 80039c4:	6a3b      	ldr	r3, [r7, #32]
 80039c6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
                      (((uint32_t)Stopbit << USIC_CH_PCR_ASCMode_STPB_Pos) & \
 80039c8:	79bb      	ldrb	r3, [r7, #6]
 80039ca:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80039ce:	f003 0302 	and.w	r3, r3, #2
      UartRegs->BRG |= ((((uint32_t)Brg_Pdiv  << USIC_CH_BRG_PDIV_Pos) \
    		                                          &  USIC_CH_BRG_PDIV_Msk));

      /* Configure StopBit */
      UartRegs->PCR_ASCMode &= ~(USIC_CH_PCR_ASCMode_STPB_Msk);
      UartRegs->PCR_ASCMode |= \
 80039d2:	431a      	orrs	r2, r3
 80039d4:	6a3b      	ldr	r3, [r7, #32]
 80039d6:	63da      	str	r2, [r3, #60]	; 0x3c
                      (((uint32_t)Stopbit << USIC_CH_PCR_ASCMode_STPB_Pos) & \
                       USIC_CH_PCR_ASCMode_STPB_Msk);
          
      /* Configure Parity*/
      UartRegs->CCR &= ~(USIC_CH_CCR_PM_Msk);
 80039d8:	6a3b      	ldr	r3, [r7, #32]
 80039da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80039dc:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80039e0:	6a3b      	ldr	r3, [r7, #32]
 80039e2:	641a      	str	r2, [r3, #64]	; 0x40
      UartRegs->CCR |= (((UART_MODE  & USIC_CH_CCR_MODE_Msk)) | \
 80039e4:	6a3b      	ldr	r3, [r7, #32]
 80039e6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
                        (((uint32_t)Parity  << USIC_CH_CCR_PM_Pos) & \
 80039e8:	79fb      	ldrb	r3, [r7, #7]
 80039ea:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80039ee:	f403 7340 	and.w	r3, r3, #768	; 0x300
                      (((uint32_t)Stopbit << USIC_CH_PCR_ASCMode_STPB_Pos) & \
                       USIC_CH_PCR_ASCMode_STPB_Msk);
          
      /* Configure Parity*/
      UartRegs->CCR &= ~(USIC_CH_CCR_PM_Msk);
      UartRegs->CCR |= (((UART_MODE  & USIC_CH_CCR_MODE_Msk)) | \
 80039f2:	4313      	orrs	r3, r2
 80039f4:	f043 0202 	orr.w	r2, r3, #2
 80039f8:	6a3b      	ldr	r3, [r7, #32]
 80039fa:	641a      	str	r2, [r3, #64]	; 0x40
                        (((uint32_t)Parity  << USIC_CH_CCR_PM_Pos) & \
                                                       USIC_CH_CCR_PM_Msk));

      Status = (status_t)DAVEApp_SUCCESS;
 80039fc:	f04f 0300 	mov.w	r3, #0
 8003a00:	627b      	str	r3, [r7, #36]	; 0x24
 8003a02:	e002      	b.n	8003a0a <UART001_Configure+0x106>
    }
    else
    {
      Status = (status_t)UART001_BUSY;
 8003a04:	f04f 0303 	mov.w	r3, #3
 8003a08:	627b      	str	r3, [r7, #36]	; 0x24
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Status), &Status);
    }
  
  return Status;
 8003a0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8003a0c:	4618      	mov	r0, r3
 8003a0e:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8003a12:	46bd      	mov	sp, r7
 8003a14:	bd80      	pop	{r7, pc}
 8003a16:	bf00      	nop

08003a18 <UART001_ReadDataMultiple>:
(
  const UART001_HandleType* Handle,
  uint16_t* DataPtr,
  uint32_t Count
)
{ 
 8003a18:	b480      	push	{r7}
 8003a1a:	b087      	sub	sp, #28
 8003a1c:	af00      	add	r7, sp, #0
 8003a1e:	60f8      	str	r0, [r7, #12]
 8003a20:	60b9      	str	r1, [r7, #8]
 8003a22:	607a      	str	r2, [r7, #4]
  uint32_t ReadCount = 0x00U;
 8003a24:	f04f 0300 	mov.w	r3, #0
 8003a28:	617b      	str	r3, [r7, #20]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;  
 8003a2a:	68fb      	ldr	r3, [r7, #12]
 8003a2c:	681b      	ldr	r3, [r3, #0]
 8003a2e:	613b      	str	r3, [r7, #16]
  /* <<<DD_UART001_API_4>>>*/
  /* If FIFO is enabled read data from receive FIFO buffer */
  if(Handle->RxFifoEn) 
 8003a30:	68fb      	ldr	r3, [r7, #12]
 8003a32:	7fdb      	ldrb	r3, [r3, #31]
 8003a34:	2b00      	cmp	r3, #0
 8003a36:	d01f      	beq.n	8003a78 <UART001_ReadDataMultiple+0x60>
  {
	  while(! USIC_ubIsRxFIFOempty(UartRegs) && Count)
 8003a38:	e011      	b.n	8003a5e <UART001_ReadDataMultiple+0x46>
	  {
		*DataPtr = (uint16_t)UartRegs->OUTR;
 8003a3a:	693b      	ldr	r3, [r7, #16]
 8003a3c:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 8003a40:	b29a      	uxth	r2, r3
 8003a42:	68bb      	ldr	r3, [r7, #8]
 8003a44:	801a      	strh	r2, [r3, #0]
		Count--;
 8003a46:	687b      	ldr	r3, [r7, #4]
 8003a48:	f103 33ff 	add.w	r3, r3, #4294967295
 8003a4c:	607b      	str	r3, [r7, #4]
		ReadCount++;
 8003a4e:	697b      	ldr	r3, [r7, #20]
 8003a50:	f103 0301 	add.w	r3, r3, #1
 8003a54:	617b      	str	r3, [r7, #20]
		DataPtr++;
 8003a56:	68bb      	ldr	r3, [r7, #8]
 8003a58:	f103 0302 	add.w	r3, r3, #2
 8003a5c:	60bb      	str	r3, [r7, #8]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;  
  /* <<<DD_UART001_API_4>>>*/
  /* If FIFO is enabled read data from receive FIFO buffer */
  if(Handle->RxFifoEn) 
  {
	  while(! USIC_ubIsRxFIFOempty(UartRegs) && Count)
 8003a5e:	693b      	ldr	r3, [r7, #16]
 8003a60:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8003a64:	f003 0308 	and.w	r3, r3, #8
 8003a68:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8003a6c:	2b00      	cmp	r3, #0
 8003a6e:	d10c      	bne.n	8003a8a <UART001_ReadDataMultiple+0x72>
 8003a70:	687b      	ldr	r3, [r7, #4]
 8003a72:	2b00      	cmp	r3, #0
 8003a74:	d1e1      	bne.n	8003a3a <UART001_ReadDataMultiple+0x22>
 8003a76:	e008      	b.n	8003a8a <UART001_ReadDataMultiple+0x72>
	  }
  }
  else
  {
	  /* If FIFO is disabled read data from standard receive buffer */
	  *DataPtr = (uint16_t)UartRegs->RBUF;
 8003a78:	693b      	ldr	r3, [r7, #16]
 8003a7a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003a7c:	b29a      	uxth	r2, r3
 8003a7e:	68bb      	ldr	r3, [r7, #8]
 8003a80:	801a      	strh	r2, [r3, #0]
	  ReadCount++;
 8003a82:	697b      	ldr	r3, [r7, #20]
 8003a84:	f103 0301 	add.w	r3, r3, #1
 8003a88:	617b      	str	r3, [r7, #20]
  }
  return ReadCount;
 8003a8a:	697b      	ldr	r3, [r7, #20]
}
 8003a8c:	4618      	mov	r0, r3
 8003a8e:	f107 071c 	add.w	r7, r7, #28
 8003a92:	46bd      	mov	sp, r7
 8003a94:	bc80      	pop	{r7}
 8003a96:	4770      	bx	lr

08003a98 <UART001_ReadDataBytes>:
(
  const UART001_HandleType* Handle,
  uint8_t* DataPtr,
  uint32_t Count
)
{ 
 8003a98:	b480      	push	{r7}
 8003a9a:	b087      	sub	sp, #28
 8003a9c:	af00      	add	r7, sp, #0
 8003a9e:	60f8      	str	r0, [r7, #12]
 8003aa0:	60b9      	str	r1, [r7, #8]
 8003aa2:	607a      	str	r2, [r7, #4]
  uint32_t ReadCount = 0x00U;
 8003aa4:	f04f 0300 	mov.w	r3, #0
 8003aa8:	617b      	str	r3, [r7, #20]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;  
 8003aaa:	68fb      	ldr	r3, [r7, #12]
 8003aac:	681b      	ldr	r3, [r3, #0]
 8003aae:	613b      	str	r3, [r7, #16]
  /* <<<DD_UART001_API_4>>>*/
  /* If FIFO is enabled read data from receive FIFO buffer */
  if(Handle->RxFifoEn) 
 8003ab0:	68fb      	ldr	r3, [r7, #12]
 8003ab2:	7fdb      	ldrb	r3, [r3, #31]
 8003ab4:	2b00      	cmp	r3, #0
 8003ab6:	d01f      	beq.n	8003af8 <UART001_ReadDataBytes+0x60>
  {
	  while(! USIC_ubIsRxFIFOempty(UartRegs) && Count)
 8003ab8:	e011      	b.n	8003ade <UART001_ReadDataBytes+0x46>
	  {
		*DataPtr = (uint8_t)UartRegs->OUTR;
 8003aba:	693b      	ldr	r3, [r7, #16]
 8003abc:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 8003ac0:	b2da      	uxtb	r2, r3
 8003ac2:	68bb      	ldr	r3, [r7, #8]
 8003ac4:	701a      	strb	r2, [r3, #0]
		Count--;
 8003ac6:	687b      	ldr	r3, [r7, #4]
 8003ac8:	f103 33ff 	add.w	r3, r3, #4294967295
 8003acc:	607b      	str	r3, [r7, #4]
		ReadCount++;
 8003ace:	697b      	ldr	r3, [r7, #20]
 8003ad0:	f103 0301 	add.w	r3, r3, #1
 8003ad4:	617b      	str	r3, [r7, #20]
		DataPtr++;
 8003ad6:	68bb      	ldr	r3, [r7, #8]
 8003ad8:	f103 0301 	add.w	r3, r3, #1
 8003adc:	60bb      	str	r3, [r7, #8]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;  
  /* <<<DD_UART001_API_4>>>*/
  /* If FIFO is enabled read data from receive FIFO buffer */
  if(Handle->RxFifoEn) 
  {
	  while(! USIC_ubIsRxFIFOempty(UartRegs) && Count)
 8003ade:	693b      	ldr	r3, [r7, #16]
 8003ae0:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8003ae4:	f003 0308 	and.w	r3, r3, #8
 8003ae8:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8003aec:	2b00      	cmp	r3, #0
 8003aee:	d10c      	bne.n	8003b0a <UART001_ReadDataBytes+0x72>
 8003af0:	687b      	ldr	r3, [r7, #4]
 8003af2:	2b00      	cmp	r3, #0
 8003af4:	d1e1      	bne.n	8003aba <UART001_ReadDataBytes+0x22>
 8003af6:	e008      	b.n	8003b0a <UART001_ReadDataBytes+0x72>
	  }
  }
  else
  {
	  /* If FIFO is disabled read data from standard receive buffer */
	  *DataPtr = (uint8_t)UartRegs->RBUF;
 8003af8:	693b      	ldr	r3, [r7, #16]
 8003afa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003afc:	b2da      	uxtb	r2, r3
 8003afe:	68bb      	ldr	r3, [r7, #8]
 8003b00:	701a      	strb	r2, [r3, #0]
	  ReadCount++;
 8003b02:	697b      	ldr	r3, [r7, #20]
 8003b04:	f103 0301 	add.w	r3, r3, #1
 8003b08:	617b      	str	r3, [r7, #20]
  }  
  return ReadCount;
 8003b0a:	697b      	ldr	r3, [r7, #20]
}
 8003b0c:	4618      	mov	r0, r3
 8003b0e:	f107 071c 	add.w	r7, r7, #28
 8003b12:	46bd      	mov	sp, r7
 8003b14:	bc80      	pop	{r7}
 8003b16:	4770      	bx	lr

08003b18 <UART001_WriteDataMultiple>:
(
  const UART001_HandleType* Handle,
  uint16_t* DataPtr,
  uint32_t Count
)
{
 8003b18:	b480      	push	{r7}
 8003b1a:	b087      	sub	sp, #28
 8003b1c:	af00      	add	r7, sp, #0
 8003b1e:	60f8      	str	r0, [r7, #12]
 8003b20:	60b9      	str	r1, [r7, #8]
 8003b22:	607a      	str	r2, [r7, #4]
  uint32_t WriteCount = 0x00U;
 8003b24:	f04f 0300 	mov.w	r3, #0
 8003b28:	617b      	str	r3, [r7, #20]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs; 
 8003b2a:	68fb      	ldr	r3, [r7, #12]
 8003b2c:	681b      	ldr	r3, [r3, #0]
 8003b2e:	613b      	str	r3, [r7, #16]
  /* <<<DD_UART001_API_5>>>*/
  /* If FIFO is enabled write data to the transmit FIFO buffer */
  if(Handle->TxFifoEn) 
 8003b30:	68fb      	ldr	r3, [r7, #12]
 8003b32:	7f9b      	ldrb	r3, [r3, #30]
 8003b34:	2b00      	cmp	r3, #0
 8003b36:	d01f      	beq.n	8003b78 <UART001_WriteDataMultiple+0x60>
  {
	  while(! USIC_IsTxFIFOfull(UartRegs)&& Count)
 8003b38:	e011      	b.n	8003b5e <UART001_WriteDataMultiple+0x46>
	  {
		UartRegs->IN[0] = *DataPtr;
 8003b3a:	68bb      	ldr	r3, [r7, #8]
 8003b3c:	881b      	ldrh	r3, [r3, #0]
 8003b3e:	461a      	mov	r2, r3
 8003b40:	693b      	ldr	r3, [r7, #16]
 8003b42:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
		Count--;
 8003b46:	687b      	ldr	r3, [r7, #4]
 8003b48:	f103 33ff 	add.w	r3, r3, #4294967295
 8003b4c:	607b      	str	r3, [r7, #4]
		WriteCount++;
 8003b4e:	697b      	ldr	r3, [r7, #20]
 8003b50:	f103 0301 	add.w	r3, r3, #1
 8003b54:	617b      	str	r3, [r7, #20]
		DataPtr++;
 8003b56:	68bb      	ldr	r3, [r7, #8]
 8003b58:	f103 0302 	add.w	r3, r3, #2
 8003b5c:	60bb      	str	r3, [r7, #8]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs; 
  /* <<<DD_UART001_API_5>>>*/
  /* If FIFO is enabled write data to the transmit FIFO buffer */
  if(Handle->TxFifoEn) 
  {
	  while(! USIC_IsTxFIFOfull(UartRegs)&& Count)
 8003b5e:	693b      	ldr	r3, [r7, #16]
 8003b60:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8003b64:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8003b68:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8003b6c:	2b00      	cmp	r3, #0
 8003b6e:	d113      	bne.n	8003b98 <UART001_WriteDataMultiple+0x80>
 8003b70:	687b      	ldr	r3, [r7, #4]
 8003b72:	2b00      	cmp	r3, #0
 8003b74:	d1e1      	bne.n	8003b3a <UART001_WriteDataMultiple+0x22>
 8003b76:	e00f      	b.n	8003b98 <UART001_WriteDataMultiple+0x80>
	  }
  }
  else
  {	  
	  /* If FIFO is disabled write data to the standard transmit buffer */
	  if (!(USIC_CH_TCSR_TDV_Msk & UartRegs->TCSR))
 8003b78:	693b      	ldr	r3, [r7, #16]
 8003b7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003b7c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003b80:	2b00      	cmp	r3, #0
 8003b82:	d109      	bne.n	8003b98 <UART001_WriteDataMultiple+0x80>
	  {
		UartRegs->TBUF[0] = *DataPtr;	
 8003b84:	68bb      	ldr	r3, [r7, #8]
 8003b86:	881b      	ldrh	r3, [r3, #0]
 8003b88:	461a      	mov	r2, r3
 8003b8a:	693b      	ldr	r3, [r7, #16]
 8003b8c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		WriteCount++; 
 8003b90:	697b      	ldr	r3, [r7, #20]
 8003b92:	f103 0301 	add.w	r3, r3, #1
 8003b96:	617b      	str	r3, [r7, #20]
	  }
  }
  return WriteCount;
 8003b98:	697b      	ldr	r3, [r7, #20]
}
 8003b9a:	4618      	mov	r0, r3
 8003b9c:	f107 071c 	add.w	r7, r7, #28
 8003ba0:	46bd      	mov	sp, r7
 8003ba2:	bc80      	pop	{r7}
 8003ba4:	4770      	bx	lr
 8003ba6:	bf00      	nop

08003ba8 <UART001_WriteDataBytes>:
(
  const UART001_HandleType* Handle,
  const uint8_t* DataPtr,
  uint32_t Count
)
{
 8003ba8:	b480      	push	{r7}
 8003baa:	b087      	sub	sp, #28
 8003bac:	af00      	add	r7, sp, #0
 8003bae:	60f8      	str	r0, [r7, #12]
 8003bb0:	60b9      	str	r1, [r7, #8]
 8003bb2:	607a      	str	r2, [r7, #4]
  uint32_t WriteCount = 0x00U;
 8003bb4:	f04f 0300 	mov.w	r3, #0
 8003bb8:	617b      	str	r3, [r7, #20]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs; 
 8003bba:	68fb      	ldr	r3, [r7, #12]
 8003bbc:	681b      	ldr	r3, [r3, #0]
 8003bbe:	613b      	str	r3, [r7, #16]
  /* <<<DD_UART001_API_6>>> */
  
  /* If FIFO is enabled write data to the transmit FIFO buffer */  
  if(Handle->TxFifoEn) 
 8003bc0:	68fb      	ldr	r3, [r7, #12]
 8003bc2:	7f9b      	ldrb	r3, [r3, #30]
 8003bc4:	2b00      	cmp	r3, #0
 8003bc6:	d01f      	beq.n	8003c08 <UART001_WriteDataBytes+0x60>
  {
	  while(! USIC_IsTxFIFOfull(UartRegs)&& Count)
 8003bc8:	e011      	b.n	8003bee <UART001_WriteDataBytes+0x46>
	  {
		UartRegs->IN[0] = *DataPtr;
 8003bca:	68bb      	ldr	r3, [r7, #8]
 8003bcc:	781b      	ldrb	r3, [r3, #0]
 8003bce:	461a      	mov	r2, r3
 8003bd0:	693b      	ldr	r3, [r7, #16]
 8003bd2:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
		Count--;
 8003bd6:	687b      	ldr	r3, [r7, #4]
 8003bd8:	f103 33ff 	add.w	r3, r3, #4294967295
 8003bdc:	607b      	str	r3, [r7, #4]
		WriteCount++;
 8003bde:	697b      	ldr	r3, [r7, #20]
 8003be0:	f103 0301 	add.w	r3, r3, #1
 8003be4:	617b      	str	r3, [r7, #20]
		DataPtr++;
 8003be6:	68bb      	ldr	r3, [r7, #8]
 8003be8:	f103 0301 	add.w	r3, r3, #1
 8003bec:	60bb      	str	r3, [r7, #8]
  /* <<<DD_UART001_API_6>>> */
  
  /* If FIFO is enabled write data to the transmit FIFO buffer */  
  if(Handle->TxFifoEn) 
  {
	  while(! USIC_IsTxFIFOfull(UartRegs)&& Count)
 8003bee:	693b      	ldr	r3, [r7, #16]
 8003bf0:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8003bf4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8003bf8:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8003bfc:	2b00      	cmp	r3, #0
 8003bfe:	d113      	bne.n	8003c28 <UART001_WriteDataBytes+0x80>
 8003c00:	687b      	ldr	r3, [r7, #4]
 8003c02:	2b00      	cmp	r3, #0
 8003c04:	d1e1      	bne.n	8003bca <UART001_WriteDataBytes+0x22>
 8003c06:	e00f      	b.n	8003c28 <UART001_WriteDataBytes+0x80>
	  }
  }
  else
  {	  
	  /* If FIFO is disabled write data to the standard transmit buffer */  
	  if (!(USIC_CH_TCSR_TDV_Msk & UartRegs->TCSR))
 8003c08:	693b      	ldr	r3, [r7, #16]
 8003c0a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8003c0c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003c10:	2b00      	cmp	r3, #0
 8003c12:	d109      	bne.n	8003c28 <UART001_WriteDataBytes+0x80>
	  {
		UartRegs->TBUF[0] = *DataPtr;	
 8003c14:	68bb      	ldr	r3, [r7, #8]
 8003c16:	781b      	ldrb	r3, [r3, #0]
 8003c18:	461a      	mov	r2, r3
 8003c1a:	693b      	ldr	r3, [r7, #16]
 8003c1c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		WriteCount++; 
 8003c20:	697b      	ldr	r3, [r7, #20]
 8003c22:	f103 0301 	add.w	r3, r3, #1
 8003c26:	617b      	str	r3, [r7, #20]
	  }
  }
  return WriteCount;
 8003c28:	697b      	ldr	r3, [r7, #20]
}
 8003c2a:	4618      	mov	r0, r3
 8003c2c:	f107 071c 	add.w	r7, r7, #28
 8003c30:	46bd      	mov	sp, r7
 8003c32:	bc80      	pop	{r7}
 8003c34:	4770      	bx	lr
 8003c36:	bf00      	nop

08003c38 <UART001_GetFlagStatus>:
status_t UART001_GetFlagStatus 
(
  const UART001_HandleType* Handle,
  UART001_FlagStatusType Flag
)
{
 8003c38:	b480      	push	{r7}
 8003c3a:	b087      	sub	sp, #28
 8003c3c:	af00      	add	r7, sp, #0
 8003c3e:	6078      	str	r0, [r7, #4]
 8003c40:	460b      	mov	r3, r1
 8003c42:	70fb      	strb	r3, [r7, #3]
  status_t Status = (status_t)UART001_RESET;
 8003c44:	f04f 0301 	mov.w	r3, #1
 8003c48:	617b      	str	r3, [r7, #20]
  uint32_t TempValue = 0x00U;
 8003c4a:	f04f 0300 	mov.w	r3, #0
 8003c4e:	613b      	str	r3, [r7, #16]
  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
 8003c50:	687b      	ldr	r3, [r7, #4]
 8003c52:	681b      	ldr	r3, [r3, #0]
 8003c54:	60fb      	str	r3, [r7, #12]
  
  /* <<<DD_UART001_API_7>>>*/
  if(Flag <= UART001_ALT_REC_IND_FLAG)
 8003c56:	78fb      	ldrb	r3, [r7, #3]
 8003c58:	2b0f      	cmp	r3, #15
 8003c5a:	d80b      	bhi.n	8003c74 <UART001_GetFlagStatus+0x3c>
  {
    TempValue = UartRegs->PSR_ASCMode;
 8003c5c:	68fb      	ldr	r3, [r7, #12]
 8003c5e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003c60:	613b      	str	r3, [r7, #16]
    TempValue  &= ((uint32_t)SHIFT_ONE << (uint32_t)Flag);    
 8003c62:	78fb      	ldrb	r3, [r7, #3]
 8003c64:	f04f 0201 	mov.w	r2, #1
 8003c68:	fa02 f303 	lsl.w	r3, r2, r3
 8003c6c:	693a      	ldr	r2, [r7, #16]
 8003c6e:	4013      	ands	r3, r2
 8003c70:	613b      	str	r3, [r7, #16]
 8003c72:	e01f      	b.n	8003cb4 <UART001_GetFlagStatus+0x7c>
  }
  else if(Flag <= UART001_FIFO_ALTRECV_BUF_FLAG)
 8003c74:	78fb      	ldrb	r3, [r7, #3]
 8003c76:	2b12      	cmp	r3, #18
 8003c78:	d80e      	bhi.n	8003c98 <UART001_GetFlagStatus+0x60>
  {
    TempValue = UartRegs->TRBSR;
 8003c7a:	68fb      	ldr	r3, [r7, #12]
 8003c7c:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8003c80:	613b      	str	r3, [r7, #16]
    TempValue  &= ((uint32_t)SHIFT_ONE << \
                  ((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG));
 8003c82:	78fb      	ldrb	r3, [r7, #3]
 8003c84:	f1a3 0310 	sub.w	r3, r3, #16
    TempValue  &= ((uint32_t)SHIFT_ONE << (uint32_t)Flag);    
  }
  else if(Flag <= UART001_FIFO_ALTRECV_BUF_FLAG)
  {
    TempValue = UartRegs->TRBSR;
    TempValue  &= ((uint32_t)SHIFT_ONE << \
 8003c88:	f04f 0201 	mov.w	r2, #1
 8003c8c:	fa02 f303 	lsl.w	r3, r2, r3
 8003c90:	693a      	ldr	r2, [r7, #16]
 8003c92:	4013      	ands	r3, r2
 8003c94:	613b      	str	r3, [r7, #16]
 8003c96:	e00d      	b.n	8003cb4 <UART001_GetFlagStatus+0x7c>
                  ((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG));
    
  }
  else
  {
    TempValue = UartRegs->TRBSR;
 8003c98:	68fb      	ldr	r3, [r7, #12]
 8003c9a:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
 8003c9e:	613b      	str	r3, [r7, #16]
    TempValue  &= ((uint32_t)SHIFT_ONE << \
       (((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG) + 0x05U ));
 8003ca0:	78fb      	ldrb	r3, [r7, #3]
 8003ca2:	f1a3 030b 	sub.w	r3, r3, #11
    
  }
  else
  {
    TempValue = UartRegs->TRBSR;
    TempValue  &= ((uint32_t)SHIFT_ONE << \
 8003ca6:	f04f 0201 	mov.w	r2, #1
 8003caa:	fa02 f303 	lsl.w	r3, r2, r3
 8003cae:	693a      	ldr	r2, [r7, #16]
 8003cb0:	4013      	ands	r3, r2
 8003cb2:	613b      	str	r3, [r7, #16]
       (((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG) + 0x05U ));
  } 

  if(TempValue)
 8003cb4:	693b      	ldr	r3, [r7, #16]
 8003cb6:	2b00      	cmp	r3, #0
 8003cb8:	d002      	beq.n	8003cc0 <UART001_GetFlagStatus+0x88>
  {
    Status = (status_t)UART001_SET;
 8003cba:	f04f 0302 	mov.w	r3, #2
 8003cbe:	617b      	str	r3, [r7, #20]
  }
  return Status;
 8003cc0:	697b      	ldr	r3, [r7, #20]
}
 8003cc2:	4618      	mov	r0, r3
 8003cc4:	f107 071c 	add.w	r7, r7, #28
 8003cc8:	46bd      	mov	sp, r7
 8003cca:	bc80      	pop	{r7}
 8003ccc:	4770      	bx	lr
 8003cce:	bf00      	nop

08003cd0 <UART001_ClearFlag>:
void UART001_ClearFlag
(
  const UART001_HandleType* Handle,
  UART001_FlagStatusType Flag
)
{
 8003cd0:	b480      	push	{r7}
 8003cd2:	b085      	sub	sp, #20
 8003cd4:	af00      	add	r7, sp, #0
 8003cd6:	6078      	str	r0, [r7, #4]
 8003cd8:	460b      	mov	r3, r1
 8003cda:	70fb      	strb	r3, [r7, #3]

  USIC_CH_TypeDef* UartRegs = Handle->UartRegs;
 8003cdc:	687b      	ldr	r3, [r7, #4]
 8003cde:	681b      	ldr	r3, [r3, #0]
 8003ce0:	60fb      	str	r3, [r7, #12]
  
  /* <<<DD_UART001_API_8>>>*/
  if(Flag <= UART001_ALT_REC_IND_FLAG)
 8003ce2:	78fb      	ldrb	r3, [r7, #3]
 8003ce4:	2b0f      	cmp	r3, #15
 8003ce6:	d80a      	bhi.n	8003cfe <UART001_ClearFlag+0x2e>
  {
    UartRegs->PSCR  |= ((uint32_t)SHIFT_ONE << (uint32_t)Flag);    
 8003ce8:	68fb      	ldr	r3, [r7, #12]
 8003cea:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8003cec:	78fb      	ldrb	r3, [r7, #3]
 8003cee:	f04f 0101 	mov.w	r1, #1
 8003cf2:	fa01 f303 	lsl.w	r3, r1, r3
 8003cf6:	431a      	orrs	r2, r3
 8003cf8:	68fb      	ldr	r3, [r7, #12]
 8003cfa:	64da      	str	r2, [r3, #76]	; 0x4c
 8003cfc:	e01f      	b.n	8003d3e <UART001_ClearFlag+0x6e>
  }
  else if(Flag <= UART001_FIFO_ALTRECV_BUF_FLAG)
 8003cfe:	78fb      	ldrb	r3, [r7, #3]
 8003d00:	2b12      	cmp	r3, #18
 8003d02:	d80e      	bhi.n	8003d22 <UART001_ClearFlag+0x52>
  {
    UartRegs->TRBSCR  |= ((uint32_t)SHIFT_ONE << \
 8003d04:	68fb      	ldr	r3, [r7, #12]
 8003d06:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
                 ((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG)); 
 8003d0a:	78fb      	ldrb	r3, [r7, #3]
 8003d0c:	f1a3 0310 	sub.w	r3, r3, #16
  {
    UartRegs->PSCR  |= ((uint32_t)SHIFT_ONE << (uint32_t)Flag);    
  }
  else if(Flag <= UART001_FIFO_ALTRECV_BUF_FLAG)
  {
    UartRegs->TRBSCR  |= ((uint32_t)SHIFT_ONE << \
 8003d10:	f04f 0101 	mov.w	r1, #1
 8003d14:	fa01 f303 	lsl.w	r3, r1, r3
 8003d18:	431a      	orrs	r2, r3
 8003d1a:	68fb      	ldr	r3, [r7, #12]
 8003d1c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
 8003d20:	e00d      	b.n	8003d3e <UART001_ClearFlag+0x6e>
                 ((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG)); 
  }
  else
  {
    UartRegs->TRBSCR  |= ((uint32_t)SHIFT_ONE << \
 8003d22:	68fb      	ldr	r3, [r7, #12]
 8003d24:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
               (((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG) + \
 8003d28:	78fb      	ldrb	r3, [r7, #3]
 8003d2a:	f1a3 030b 	sub.w	r3, r3, #11
    UartRegs->TRBSCR  |= ((uint32_t)SHIFT_ONE << \
                 ((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG)); 
  }
  else
  {
    UartRegs->TRBSCR  |= ((uint32_t)SHIFT_ONE << \
 8003d2e:	f04f 0101 	mov.w	r1, #1
 8003d32:	fa01 f303 	lsl.w	r3, r1, r3
 8003d36:	431a      	orrs	r2, r3
 8003d38:	68fb      	ldr	r3, [r7, #12]
 8003d3a:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
               (((uint32_t)Flag - (uint32_t)UART001_FIFO_STD_RECV_BUF_FLAG) + \
                                                       UART001_FLAG_OFFSET ));
  }  
  
}
 8003d3e:	f107 0714 	add.w	r7, r7, #20
 8003d42:	46bd      	mov	sp, r7
 8003d44:	bc80      	pop	{r7}
 8003d46:	4770      	bx	lr

08003d48 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8003d48:	b480      	push	{r7}
 8003d4a:	af00      	add	r7, sp, #0
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 8003d4c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003d50:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003d54:	68db      	ldr	r3, [r3, #12]
 8003d56:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8003d5a:	ea4f 2313 	mov.w	r3, r3, lsr #8
}
 8003d5e:	4618      	mov	r0, r3
 8003d60:	46bd      	mov	sp, r7
 8003d62:	bc80      	pop	{r7}
 8003d64:	4770      	bx	lr
 8003d66:	bf00      	nop

08003d68 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003d68:	b480      	push	{r7}
 8003d6a:	b083      	sub	sp, #12
 8003d6c:	af00      	add	r7, sp, #0
 8003d6e:	4603      	mov	r3, r0
 8003d70:	6039      	str	r1, [r7, #0]
 8003d72:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8003d74:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003d78:	2b00      	cmp	r3, #0
 8003d7a:	da10      	bge.n	8003d9e <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8003d7c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003d80:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003d84:	79fa      	ldrb	r2, [r7, #7]
 8003d86:	f002 020f 	and.w	r2, r2, #15
 8003d8a:	f1a2 0104 	sub.w	r1, r2, #4
 8003d8e:	683a      	ldr	r2, [r7, #0]
 8003d90:	b2d2      	uxtb	r2, r2
 8003d92:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8003d96:	b2d2      	uxtb	r2, r2
 8003d98:	185b      	adds	r3, r3, r1
 8003d9a:	761a      	strb	r2, [r3, #24]
 8003d9c:	e00d      	b.n	8003dba <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8003d9e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8003da2:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003da6:	f997 1007 	ldrsb.w	r1, [r7, #7]
 8003daa:	683a      	ldr	r2, [r7, #0]
 8003dac:	b2d2      	uxtb	r2, r2
 8003dae:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8003db2:	b2d2      	uxtb	r2, r2
 8003db4:	185b      	adds	r3, r3, r1
 8003db6:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8003dba:	f107 070c 	add.w	r7, r7, #12
 8003dbe:	46bd      	mov	sp, r7
 8003dc0:	bc80      	pop	{r7}
 8003dc2:	4770      	bx	lr

08003dc4 <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8003dc4:	b480      	push	{r7}
 8003dc6:	b089      	sub	sp, #36	; 0x24
 8003dc8:	af00      	add	r7, sp, #0
 8003dca:	60f8      	str	r0, [r7, #12]
 8003dcc:	60b9      	str	r1, [r7, #8]
 8003dce:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
 8003dd0:	68fb      	ldr	r3, [r7, #12]
 8003dd2:	f003 0307 	and.w	r3, r3, #7
 8003dd6:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 8003dd8:	69fb      	ldr	r3, [r7, #28]
 8003dda:	f1c3 0307 	rsb	r3, r3, #7
 8003dde:	2b06      	cmp	r3, #6
 8003de0:	bf28      	it	cs
 8003de2:	2306      	movcs	r3, #6
 8003de4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 8003de6:	69fb      	ldr	r3, [r7, #28]
 8003de8:	f103 0306 	add.w	r3, r3, #6
 8003dec:	2b06      	cmp	r3, #6
 8003dee:	d903      	bls.n	8003df8 <NVIC_EncodePriority+0x34>
 8003df0:	69fb      	ldr	r3, [r7, #28]
 8003df2:	f103 33ff 	add.w	r3, r3, #4294967295
 8003df6:	e001      	b.n	8003dfc <NVIC_EncodePriority+0x38>
 8003df8:	f04f 0300 	mov.w	r3, #0
 8003dfc:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 8003dfe:	69bb      	ldr	r3, [r7, #24]
 8003e00:	f04f 0201 	mov.w	r2, #1
 8003e04:	fa02 f303 	lsl.w	r3, r2, r3
 8003e08:	f103 33ff 	add.w	r3, r3, #4294967295
 8003e0c:	461a      	mov	r2, r3
 8003e0e:	68bb      	ldr	r3, [r7, #8]
 8003e10:	401a      	ands	r2, r3
 8003e12:	697b      	ldr	r3, [r7, #20]
 8003e14:	fa02 f203 	lsl.w	r2, r2, r3
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 8003e18:	697b      	ldr	r3, [r7, #20]
 8003e1a:	f04f 0101 	mov.w	r1, #1
 8003e1e:	fa01 f303 	lsl.w	r3, r1, r3
 8003e22:	f103 33ff 	add.w	r3, r3, #4294967295
 8003e26:	4619      	mov	r1, r3
 8003e28:	687b      	ldr	r3, [r7, #4]
 8003e2a:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

  return (
 8003e2c:	4313      	orrs	r3, r2
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}
 8003e2e:	4618      	mov	r0, r3
 8003e30:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8003e34:	46bd      	mov	sp, r7
 8003e36:	bc80      	pop	{r7}
 8003e38:	4770      	bx	lr
 8003e3a:	bf00      	nop

08003e3c <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8003e3c:	b580      	push	{r7, lr}
 8003e3e:	b082      	sub	sp, #8
 8003e40:	af00      	add	r7, sp, #0
 8003e42:	6078      	str	r0, [r7, #4]
  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
 8003e44:	687b      	ldr	r3, [r7, #4]
 8003e46:	f103 32ff 	add.w	r2, r3, #4294967295
 8003e4a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8003e4e:	429a      	cmp	r2, r3
 8003e50:	d902      	bls.n	8003e58 <SysTick_Config+0x1c>
 8003e52:	f04f 0301 	mov.w	r3, #1
 8003e56:	e01d      	b.n	8003e94 <SysTick_Config+0x58>

  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
 8003e58:	f24e 0310 	movw	r3, #57360	; 0xe010
 8003e5c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003e60:	687a      	ldr	r2, [r7, #4]
 8003e62:	f102 32ff 	add.w	r2, r2, #4294967295
 8003e66:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
 8003e68:	f04f 30ff 	mov.w	r0, #4294967295
 8003e6c:	f04f 013f 	mov.w	r1, #63	; 0x3f
 8003e70:	f7ff ff7a 	bl	8003d68 <NVIC_SetPriority>
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
 8003e74:	f24e 0310 	movw	r3, #57360	; 0xe010
 8003e78:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003e7c:	f04f 0200 	mov.w	r2, #0
 8003e80:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8003e82:	f24e 0310 	movw	r3, #57360	; 0xe010
 8003e86:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003e8a:	f04f 0207 	mov.w	r2, #7
 8003e8e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
  return (0);                                                  /* Function successful */
 8003e90:	f04f 0300 	mov.w	r3, #0
}
 8003e94:	4618      	mov	r0, r3
 8003e96:	f107 0708 	add.w	r7, r7, #8
 8003e9a:	46bd      	mov	sp, r7
 8003e9c:	bd80      	pop	{r7, pc}
 8003e9e:	bf00      	nop

08003ea0 <SYSTM001_lInsertTimerList>:

/*
 * This function is called to insert a timer into the timer list.
 */
static void  SYSTM001_lInsertTimerList (uint32_t Index)
{
 8003ea0:	b480      	push	{r7}
 8003ea2:	b087      	sub	sp, #28
 8003ea4:	af00      	add	r7, sp, #0
 8003ea6:	6078      	str	r0, [r7, #4]
  SYSTM001_TimerObject* TmrObjPtr;
  int32_t DeltaTicks;
  uint32_t TempTmrCnt;
   /* Get timer time */
  TempTmrCnt = TimerTbl[Index].TimerCount;
 8003ea8:	f246 0324 	movw	r3, #24612	; 0x6024
 8003eac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003eb0:	687a      	ldr	r2, [r7, #4]
 8003eb2:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8003eb6:	189b      	adds	r3, r3, r2
 8003eb8:	f103 0308 	add.w	r3, r3, #8
 8003ebc:	681b      	ldr	r3, [r3, #0]
 8003ebe:	60fb      	str	r3, [r7, #12]
  /* Check if timer count is zero */
  /* <<<DD_SYSTM001_PRIV _API_1>>> */

  /* Check if Timer list is NULL */
  if(TimerList == NULL)
 8003ec0:	f640 4320 	movw	r3, #3104	; 0xc20
 8003ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ec8:	681b      	ldr	r3, [r3, #0]
 8003eca:	2b00      	cmp	r3, #0
 8003ecc:	d10d      	bne.n	8003eea <SYSTM001_lInsertTimerList+0x4a>
  {
      /* Set this as first Timer */
      TimerList = &TimerTbl[Index];
 8003ece:	687b      	ldr	r3, [r7, #4]
 8003ed0:	ea4f 1243 	mov.w	r2, r3, lsl #5
 8003ed4:	f246 0324 	movw	r3, #24612	; 0x6024
 8003ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003edc:	18d2      	adds	r2, r2, r3
 8003ede:	f640 4320 	movw	r3, #3104	; 0xc20
 8003ee2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ee6:	601a      	str	r2, [r3, #0]
 8003ee8:	e0de      	b.n	80040a8 <SYSTM001_lInsertTimerList+0x208>
  }
  /* IF Not, find the correct place ,and insert the specified timer */
  else
  {
    TmrObjPtr = TimerList;
 8003eea:	f640 4320 	movw	r3, #3104	; 0xc20
 8003eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ef2:	681b      	ldr	r3, [r3, #0]
 8003ef4:	617b      	str	r3, [r7, #20]
    /* Get timer tick */
    DeltaTicks = (int32_t)TempTmrCnt;
 8003ef6:	68fb      	ldr	r3, [r7, #12]
 8003ef8:	613b      	str	r3, [r7, #16]
    /* Find correct place for inserting the timer */
    while(TmrObjPtr != NULL)
 8003efa:	e0d1      	b.n	80040a0 <SYSTM001_lInsertTimerList+0x200>
    {
      /* Get timer Count Difference  */
      DeltaTicks -= (int32_t)TmrObjPtr->TimerCount;
 8003efc:	697b      	ldr	r3, [r7, #20]
 8003efe:	689b      	ldr	r3, [r3, #8]
 8003f00:	693a      	ldr	r2, [r7, #16]
 8003f02:	1ad3      	subs	r3, r2, r3
 8003f04:	613b      	str	r3, [r7, #16]
      /* Is delta ticks<0? */
      if(DeltaTicks < 0)
 8003f06:	693b      	ldr	r3, [r7, #16]
 8003f08:	2b00      	cmp	r3, #0
 8003f0a:	f280 809c 	bge.w	8004046 <SYSTM001_lInsertTimerList+0x1a6>
      {
        /*  Check If head item */
        if(TmrObjPtr->TimerPrev!= NULL)
 8003f0e:	697b      	ldr	r3, [r7, #20]
 8003f10:	69db      	ldr	r3, [r3, #28]
 8003f12:	2b00      	cmp	r3, #0
 8003f14:	d02e      	beq.n	8003f74 <SYSTM001_lInsertTimerList+0xd4>
        {
          /* If Insert to list */
          TmrObjPtr->TimerPrev->TimerNext = &TimerTbl[Index];
 8003f16:	697b      	ldr	r3, [r7, #20]
 8003f18:	69da      	ldr	r2, [r3, #28]
 8003f1a:	687b      	ldr	r3, [r7, #4]
 8003f1c:	ea4f 1143 	mov.w	r1, r3, lsl #5
 8003f20:	f246 0324 	movw	r3, #24612	; 0x6024
 8003f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f28:	18cb      	adds	r3, r1, r3
 8003f2a:	6193      	str	r3, [r2, #24]
          TimerTbl[Index].TimerPrev = TmrObjPtr->TimerPrev;
 8003f2c:	697b      	ldr	r3, [r7, #20]
 8003f2e:	69da      	ldr	r2, [r3, #28]
 8003f30:	f246 0324 	movw	r3, #24612	; 0x6024
 8003f34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f38:	6879      	ldr	r1, [r7, #4]
 8003f3a:	ea4f 1141 	mov.w	r1, r1, lsl #5
 8003f3e:	185b      	adds	r3, r3, r1
 8003f40:	f103 031c 	add.w	r3, r3, #28
 8003f44:	601a      	str	r2, [r3, #0]
          TimerTbl[Index].TimerNext = TmrObjPtr;
 8003f46:	f246 0324 	movw	r3, #24612	; 0x6024
 8003f4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f4e:	687a      	ldr	r2, [r7, #4]
 8003f50:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8003f54:	189b      	adds	r3, r3, r2
 8003f56:	f103 0318 	add.w	r3, r3, #24
 8003f5a:	697a      	ldr	r2, [r7, #20]
 8003f5c:	601a      	str	r2, [r3, #0]
          TmrObjPtr->TimerPrev = &TimerTbl[Index];
 8003f5e:	687b      	ldr	r3, [r7, #4]
 8003f60:	ea4f 1243 	mov.w	r2, r3, lsl #5
 8003f64:	f246 0324 	movw	r3, #24612	; 0x6024
 8003f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f6c:	18d2      	adds	r2, r2, r3
 8003f6e:	697b      	ldr	r3, [r7, #20]
 8003f70:	61da      	str	r2, [r3, #28]
 8003f72:	e02a      	b.n	8003fca <SYSTM001_lInsertTimerList+0x12a>
        }
        else
        {
          /* Set Timer as first item */
          TimerTbl[Index].TimerNext = TimerList;
 8003f74:	f640 4320 	movw	r3, #3104	; 0xc20
 8003f78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f7c:	681a      	ldr	r2, [r3, #0]
 8003f7e:	f246 0324 	movw	r3, #24612	; 0x6024
 8003f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f86:	6879      	ldr	r1, [r7, #4]
 8003f88:	ea4f 1141 	mov.w	r1, r1, lsl #5
 8003f8c:	185b      	adds	r3, r3, r1
 8003f8e:	f103 0318 	add.w	r3, r3, #24
 8003f92:	601a      	str	r2, [r3, #0]
          TimerList->TimerPrev = &TimerTbl[Index];
 8003f94:	f640 4320 	movw	r3, #3104	; 0xc20
 8003f98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f9c:	681a      	ldr	r2, [r3, #0]
 8003f9e:	687b      	ldr	r3, [r7, #4]
 8003fa0:	ea4f 1143 	mov.w	r1, r3, lsl #5
 8003fa4:	f246 0324 	movw	r3, #24612	; 0x6024
 8003fa8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fac:	18cb      	adds	r3, r1, r3
 8003fae:	61d3      	str	r3, [r2, #28]
          TimerList = &TimerTbl[Index];
 8003fb0:	687b      	ldr	r3, [r7, #4]
 8003fb2:	ea4f 1243 	mov.w	r2, r3, lsl #5
 8003fb6:	f246 0324 	movw	r3, #24612	; 0x6024
 8003fba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fbe:	18d2      	adds	r2, r2, r3
 8003fc0:	f640 4320 	movw	r3, #3104	; 0xc20
 8003fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fc8:	601a      	str	r2, [r3, #0]
        }
        TimerTbl[Index].TimerCount = \
                TimerTbl[Index].TimerNext->TimerCount + (uint32_t)DeltaTicks;
 8003fca:	f246 0324 	movw	r3, #24612	; 0x6024
 8003fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fd2:	687a      	ldr	r2, [r7, #4]
 8003fd4:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8003fd8:	189b      	adds	r3, r3, r2
 8003fda:	f103 0318 	add.w	r3, r3, #24
 8003fde:	681b      	ldr	r3, [r3, #0]
 8003fe0:	689a      	ldr	r2, [r3, #8]
 8003fe2:	693b      	ldr	r3, [r7, #16]
 8003fe4:	18d2      	adds	r2, r2, r3
          /* Set Timer as first item */
          TimerTbl[Index].TimerNext = TimerList;
          TimerList->TimerPrev = &TimerTbl[Index];
          TimerList = &TimerTbl[Index];
        }
        TimerTbl[Index].TimerCount = \
 8003fe6:	f246 0324 	movw	r3, #24612	; 0x6024
 8003fea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fee:	6879      	ldr	r1, [r7, #4]
 8003ff0:	ea4f 1141 	mov.w	r1, r1, lsl #5
 8003ff4:	185b      	adds	r3, r3, r1
 8003ff6:	f103 0308 	add.w	r3, r3, #8
 8003ffa:	601a      	str	r2, [r3, #0]
                TimerTbl[Index].TimerNext->TimerCount + (uint32_t)DeltaTicks;
        TimerTbl[Index].TimerNext->TimerCount  -= TimerTbl[Index].TimerCount;
 8003ffc:	f246 0324 	movw	r3, #24612	; 0x6024
 8004000:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004004:	687a      	ldr	r2, [r7, #4]
 8004006:	ea4f 1242 	mov.w	r2, r2, lsl #5
 800400a:	189b      	adds	r3, r3, r2
 800400c:	f103 0318 	add.w	r3, r3, #24
 8004010:	681a      	ldr	r2, [r3, #0]
 8004012:	f246 0324 	movw	r3, #24612	; 0x6024
 8004016:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800401a:	6879      	ldr	r1, [r7, #4]
 800401c:	ea4f 1141 	mov.w	r1, r1, lsl #5
 8004020:	185b      	adds	r3, r3, r1
 8004022:	f103 0318 	add.w	r3, r3, #24
 8004026:	681b      	ldr	r3, [r3, #0]
 8004028:	6899      	ldr	r1, [r3, #8]
 800402a:	f246 0324 	movw	r3, #24612	; 0x6024
 800402e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004032:	6878      	ldr	r0, [r7, #4]
 8004034:	ea4f 1040 	mov.w	r0, r0, lsl #5
 8004038:	181b      	adds	r3, r3, r0
 800403a:	f103 0308 	add.w	r3, r3, #8
 800403e:	681b      	ldr	r3, [r3, #0]
 8004040:	1acb      	subs	r3, r1, r3
 8004042:	6093      	str	r3, [r2, #8]
        break;
 8004044:	e030      	b.n	80040a8 <SYSTM001_lInsertTimerList+0x208>
      }
      /* Is last item in list? */
      else
      {
        if((DeltaTicks >= 0) && (TmrObjPtr->TimerNext == NULL))
 8004046:	693b      	ldr	r3, [r7, #16]
 8004048:	2b00      	cmp	r3, #0
 800404a:	db26      	blt.n	800409a <SYSTM001_lInsertTimerList+0x1fa>
 800404c:	697b      	ldr	r3, [r7, #20]
 800404e:	699b      	ldr	r3, [r3, #24]
 8004050:	2b00      	cmp	r3, #0
 8004052:	d122      	bne.n	800409a <SYSTM001_lInsertTimerList+0x1fa>
        {
          /* Yes,insert into */
          TimerTbl[Index].TimerPrev = TmrObjPtr;
 8004054:	f246 0324 	movw	r3, #24612	; 0x6024
 8004058:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800405c:	687a      	ldr	r2, [r7, #4]
 800405e:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8004062:	189b      	adds	r3, r3, r2
 8004064:	f103 031c 	add.w	r3, r3, #28
 8004068:	697a      	ldr	r2, [r7, #20]
 800406a:	601a      	str	r2, [r3, #0]
          TmrObjPtr->TimerNext = &TimerTbl[Index];
 800406c:	687b      	ldr	r3, [r7, #4]
 800406e:	ea4f 1243 	mov.w	r2, r3, lsl #5
 8004072:	f246 0324 	movw	r3, #24612	; 0x6024
 8004076:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800407a:	18d2      	adds	r2, r2, r3
 800407c:	697b      	ldr	r3, [r7, #20]
 800407e:	619a      	str	r2, [r3, #24]
          TimerTbl[Index].TimerCount = (uint32_t)DeltaTicks;
 8004080:	693a      	ldr	r2, [r7, #16]
 8004082:	f246 0324 	movw	r3, #24612	; 0x6024
 8004086:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800408a:	6879      	ldr	r1, [r7, #4]
 800408c:	ea4f 1141 	mov.w	r1, r1, lsl #5
 8004090:	185b      	adds	r3, r3, r1
 8004092:	f103 0308 	add.w	r3, r3, #8
 8004096:	601a      	str	r2, [r3, #0]
          break;
 8004098:	e006      	b.n	80040a8 <SYSTM001_lInsertTimerList+0x208>
        }
      }
      /* Get the next item in timer list    */
      TmrObjPtr = TmrObjPtr->TimerNext;
 800409a:	697b      	ldr	r3, [r7, #20]
 800409c:	699b      	ldr	r3, [r3, #24]
 800409e:	617b      	str	r3, [r7, #20]
  {
    TmrObjPtr = TimerList;
    /* Get timer tick */
    DeltaTicks = (int32_t)TempTmrCnt;
    /* Find correct place for inserting the timer */
    while(TmrObjPtr != NULL)
 80040a0:	697b      	ldr	r3, [r7, #20]
 80040a2:	2b00      	cmp	r3, #0
 80040a4:	f47f af2a 	bne.w	8003efc <SYSTM001_lInsertTimerList+0x5c>
      }
      /* Get the next item in timer list    */
      TmrObjPtr = TmrObjPtr->TimerNext;
    }
  }
}
 80040a8:	f107 071c 	add.w	r7, r7, #28
 80040ac:	46bd      	mov	sp, r7
 80040ae:	bc80      	pop	{r7}
 80040b0:	4770      	bx	lr
 80040b2:	bf00      	nop

080040b4 <SYSTM001_lRemoveTimerList>:

/*
 * This function is called to remove a timer from the timer list. 
 */
static void  SYSTM001_lRemoveTimerList(uint32_t Index)
{
 80040b4:	b480      	push	{r7}
 80040b6:	b085      	sub	sp, #20
 80040b8:	af00      	add	r7, sp, #0
 80040ba:	6078      	str	r0, [r7, #4]
  SYSTM001_TimerObject* TmrObjPtr;
  TmrObjPtr = &TimerTbl[Index];
 80040bc:	687b      	ldr	r3, [r7, #4]
 80040be:	ea4f 1243 	mov.w	r2, r3, lsl #5
 80040c2:	f246 0324 	movw	r3, #24612	; 0x6024
 80040c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040ca:	18d3      	adds	r3, r2, r3
 80040cc:	60fb      	str	r3, [r7, #12]
  /* Check whether only one timer available */
  /* <<<DD_SYSTM001_PRIV _API_2>>> */
  if((TmrObjPtr->TimerPrev == NULL) && (TmrObjPtr->TimerNext == NULL))
 80040ce:	68fb      	ldr	r3, [r7, #12]
 80040d0:	69db      	ldr	r3, [r3, #28]
 80040d2:	2b00      	cmp	r3, #0
 80040d4:	d10b      	bne.n	80040ee <SYSTM001_lRemoveTimerList+0x3a>
 80040d6:	68fb      	ldr	r3, [r7, #12]
 80040d8:	699b      	ldr	r3, [r3, #24]
 80040da:	2b00      	cmp	r3, #0
 80040dc:	d107      	bne.n	80040ee <SYSTM001_lRemoveTimerList+0x3a>
  {
    /* set timer list as NULL */ 
    TimerList = NULL;                 	
 80040de:	f640 4320 	movw	r3, #3104	; 0xc20
 80040e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040e6:	f04f 0200 	mov.w	r2, #0
 80040ea:	601a      	str	r2, [r3, #0]
 80040ec:	e049      	b.n	8004182 <SYSTM001_lRemoveTimerList+0xce>
  }
   /* Check if the first item in timer list   */
  else if(TmrObjPtr->TimerPrev == NULL)     
 80040ee:	68fb      	ldr	r3, [r7, #12]
 80040f0:	69db      	ldr	r3, [r3, #28]
 80040f2:	2b00      	cmp	r3, #0
 80040f4:	d11c      	bne.n	8004130 <SYSTM001_lRemoveTimerList+0x7c>
  {   
    /* Remove timer from list,and reset timer list */
    TimerList  = TmrObjPtr->TimerNext;
 80040f6:	68fb      	ldr	r3, [r7, #12]
 80040f8:	699a      	ldr	r2, [r3, #24]
 80040fa:	f640 4320 	movw	r3, #3104	; 0xc20
 80040fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004102:	601a      	str	r2, [r3, #0]
    TimerList->TimerPrev = NULL;
 8004104:	f640 4320 	movw	r3, #3104	; 0xc20
 8004108:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800410c:	681b      	ldr	r3, [r3, #0]
 800410e:	f04f 0200 	mov.w	r2, #0
 8004112:	61da      	str	r2, [r3, #28]
    TmrObjPtr->TimerNext->TimerCount += TmrObjPtr->TimerCount;
 8004114:	68fb      	ldr	r3, [r7, #12]
 8004116:	699b      	ldr	r3, [r3, #24]
 8004118:	68fa      	ldr	r2, [r7, #12]
 800411a:	6992      	ldr	r2, [r2, #24]
 800411c:	6891      	ldr	r1, [r2, #8]
 800411e:	68fa      	ldr	r2, [r7, #12]
 8004120:	6892      	ldr	r2, [r2, #8]
 8004122:	188a      	adds	r2, r1, r2
 8004124:	609a      	str	r2, [r3, #8]
    TmrObjPtr->TimerNext    = NULL;  
 8004126:	68fb      	ldr	r3, [r7, #12]
 8004128:	f04f 0200 	mov.w	r2, #0
 800412c:	619a      	str	r2, [r3, #24]
 800412e:	e028      	b.n	8004182 <SYSTM001_lRemoveTimerList+0xce>
  }
  /* Check if the last item in timer list   */
  else if(TmrObjPtr->TimerNext == NULL)      
 8004130:	68fb      	ldr	r3, [r7, #12]
 8004132:	699b      	ldr	r3, [r3, #24]
 8004134:	2b00      	cmp	r3, #0
 8004136:	d109      	bne.n	800414c <SYSTM001_lRemoveTimerList+0x98>
  {
    /* Remove timer from list */
    TmrObjPtr->TimerPrev->TimerNext = NULL;	
 8004138:	68fb      	ldr	r3, [r7, #12]
 800413a:	69db      	ldr	r3, [r3, #28]
 800413c:	f04f 0200 	mov.w	r2, #0
 8004140:	619a      	str	r2, [r3, #24]
    TmrObjPtr->TimerPrev = NULL;
 8004142:	68fb      	ldr	r3, [r7, #12]
 8004144:	f04f 0200 	mov.w	r2, #0
 8004148:	61da      	str	r2, [r3, #28]
 800414a:	e01a      	b.n	8004182 <SYSTM001_lRemoveTimerList+0xce>
  }
  else                                /*  remove timer from list         */
  {
    /*  Remove timer from list */
    TmrObjPtr->TimerPrev->TimerNext  =  TmrObjPtr->TimerNext;
 800414c:	68fb      	ldr	r3, [r7, #12]
 800414e:	69db      	ldr	r3, [r3, #28]
 8004150:	68fa      	ldr	r2, [r7, #12]
 8004152:	6992      	ldr	r2, [r2, #24]
 8004154:	619a      	str	r2, [r3, #24]
    TmrObjPtr->TimerNext->TimerPrev  =  TmrObjPtr->TimerPrev;
 8004156:	68fb      	ldr	r3, [r7, #12]
 8004158:	699b      	ldr	r3, [r3, #24]
 800415a:	68fa      	ldr	r2, [r7, #12]
 800415c:	69d2      	ldr	r2, [r2, #28]
 800415e:	61da      	str	r2, [r3, #28]
    TmrObjPtr->TimerNext->TimerCount  += TmrObjPtr->TimerCount;
 8004160:	68fb      	ldr	r3, [r7, #12]
 8004162:	699b      	ldr	r3, [r3, #24]
 8004164:	68fa      	ldr	r2, [r7, #12]
 8004166:	6992      	ldr	r2, [r2, #24]
 8004168:	6891      	ldr	r1, [r2, #8]
 800416a:	68fa      	ldr	r2, [r7, #12]
 800416c:	6892      	ldr	r2, [r2, #8]
 800416e:	188a      	adds	r2, r1, r2
 8004170:	609a      	str	r2, [r3, #8]
    TmrObjPtr->TimerNext = NULL;
 8004172:	68fb      	ldr	r3, [r7, #12]
 8004174:	f04f 0200 	mov.w	r2, #0
 8004178:	619a      	str	r2, [r3, #24]
    TmrObjPtr->TimerPrev = NULL;
 800417a:	68fb      	ldr	r3, [r7, #12]
 800417c:	f04f 0200 	mov.w	r2, #0
 8004180:	61da      	str	r2, [r3, #28]
  }
}
 8004182:	f107 0714 	add.w	r7, r7, #20
 8004186:	46bd      	mov	sp, r7
 8004188:	bc80      	pop	{r7}
 800418a:	4770      	bx	lr

0800418c <SYSTM001_lTimerHandler>:

/*
 * Handler function  called from Systick event handler. 
 */
static void  SYSTM001_lTimerHandler (void)
{
 800418c:	b580      	push	{r7, lr}
 800418e:	b082      	sub	sp, #8
 8004190:	af00      	add	r7, sp, #0
  SYSTM001_TimerObject* TmrObjPtr;
   /* Get first item of timer list       */
  TmrObjPtr = TimerList;         
 8004192:	f640 4320 	movw	r3, #3104	; 0xc20
 8004196:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800419a:	681b      	ldr	r3, [r3, #0]
 800419c:	607b      	str	r3, [r7, #4]
  /* <<<DD_SYSTM001_PRIV _API_3>>> */  
  while((TmrObjPtr != NULL) && (TmrObjPtr->TimerCount == 0UL) )
 800419e:	e031      	b.n	8004204 <SYSTM001_lTimerHandler+0x78>
  {	
    /* Check whether timer is a one shot timer */
    if(TmrObjPtr->TimerType == SYSTM001_ONE_SHOT)
 80041a0:	687b      	ldr	r3, [r7, #4]
 80041a2:	791b      	ldrb	r3, [r3, #4]
 80041a4:	2b00      	cmp	r3, #0
 80041a6:	d10f      	bne.n	80041c8 <SYSTM001_lTimerHandler+0x3c>
    {
      /* Yes,remove this timer from timer list */
      SYSTM001_lRemoveTimerList(TmrObjPtr->TimerID);
 80041a8:	687b      	ldr	r3, [r7, #4]
 80041aa:	681b      	ldr	r3, [r3, #0]
 80041ac:	4618      	mov	r0, r3
 80041ae:	f7ff ff81 	bl	80040b4 <SYSTM001_lRemoveTimerList>
      /* Set timer status as SYSTM001_STATE_STOPPED */
      TmrObjPtr->TimerState = SYSTM001_STATE_STOPPED;
 80041b2:	687b      	ldr	r3, [r7, #4]
 80041b4:	f04f 0201 	mov.w	r2, #1
 80041b8:	715a      	strb	r2, [r3, #5]
      /* Call timer callback function */
      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);
 80041ba:	687b      	ldr	r3, [r7, #4]
 80041bc:	691b      	ldr	r3, [r3, #16]
 80041be:	687a      	ldr	r2, [r7, #4]
 80041c0:	6952      	ldr	r2, [r2, #20]
 80041c2:	4610      	mov	r0, r2
 80041c4:	4798      	blx	r3
 80041c6:	e017      	b.n	80041f8 <SYSTM001_lTimerHandler+0x6c>
    }
    /* Check whether timer is SYSTM001_PERIODIC */
    else if(TmrObjPtr->TimerType == SYSTM001_PERIODIC)
 80041c8:	687b      	ldr	r3, [r7, #4]
 80041ca:	791b      	ldrb	r3, [r3, #4]
 80041cc:	2b01      	cmp	r3, #1
 80041ce:	d121      	bne.n	8004214 <SYSTM001_lTimerHandler+0x88>
    {
      /* Yes,remove this timer from timer list */
      SYSTM001_lRemoveTimerList(TmrObjPtr->TimerID);
 80041d0:	687b      	ldr	r3, [r7, #4]
 80041d2:	681b      	ldr	r3, [r3, #0]
 80041d4:	4618      	mov	r0, r3
 80041d6:	f7ff ff6d 	bl	80040b4 <SYSTM001_lRemoveTimerList>
      /* Reset timer tick             */
      TmrObjPtr->TimerCount = TmrObjPtr->TimerReload;
 80041da:	687b      	ldr	r3, [r7, #4]
 80041dc:	68da      	ldr	r2, [r3, #12]
 80041de:	687b      	ldr	r3, [r7, #4]
 80041e0:	609a      	str	r2, [r3, #8]
        /* Insert timer into timer list */
      SYSTM001_lInsertTimerList(TmrObjPtr->TimerID);
 80041e2:	687b      	ldr	r3, [r7, #4]
 80041e4:	681b      	ldr	r3, [r3, #0]
 80041e6:	4618      	mov	r0, r3
 80041e8:	f7ff fe5a 	bl	8003ea0 <SYSTM001_lInsertTimerList>
      /* Call timer callback function */
      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);
 80041ec:	687b      	ldr	r3, [r7, #4]
 80041ee:	691b      	ldr	r3, [r3, #16]
 80041f0:	687a      	ldr	r2, [r7, #4]
 80041f2:	6952      	ldr	r2, [r2, #20]
 80041f4:	4610      	mov	r0, r2
 80041f6:	4798      	blx	r3
    else
    {
      break;
    }
    /* Get first item of timer list */
    TmrObjPtr = TimerList;
 80041f8:	f640 4320 	movw	r3, #3104	; 0xc20
 80041fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004200:	681b      	ldr	r3, [r3, #0]
 8004202:	607b      	str	r3, [r7, #4]
{
  SYSTM001_TimerObject* TmrObjPtr;
   /* Get first item of timer list       */
  TmrObjPtr = TimerList;         
  /* <<<DD_SYSTM001_PRIV _API_3>>> */  
  while((TmrObjPtr != NULL) && (TmrObjPtr->TimerCount == 0UL) )
 8004204:	687b      	ldr	r3, [r7, #4]
 8004206:	2b00      	cmp	r3, #0
 8004208:	d005      	beq.n	8004216 <SYSTM001_lTimerHandler+0x8a>
 800420a:	687b      	ldr	r3, [r7, #4]
 800420c:	689b      	ldr	r3, [r3, #8]
 800420e:	2b00      	cmp	r3, #0
 8004210:	d0c6      	beq.n	80041a0 <SYSTM001_lTimerHandler+0x14>
 8004212:	e000      	b.n	8004216 <SYSTM001_lTimerHandler+0x8a>
      /* Call timer callback function */
      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);
    }
    else
    {
      break;
 8004214:	bf00      	nop
    }
    /* Get first item of timer list */
    TmrObjPtr = TimerList;
  }
}
 8004216:	f107 0708 	add.w	r7, r7, #8
 800421a:	46bd      	mov	sp, r7
 800421c:	bd80      	pop	{r7, pc}
 800421e:	bf00      	nop

08004220 <SysTick_Handler>:

/*
 *  SysTick Event Handler 
 */
void  SysTick_Handler(void)
{ 
 8004220:	b580      	push	{r7, lr}
 8004222:	b082      	sub	sp, #8
 8004224:	af00      	add	r7, sp, #0
  SYSTM001_TimerObject* TmrObjPtr;
  TmrObjPtr = TimerList;
 8004226:	f640 4320 	movw	r3, #3104	; 0xc20
 800422a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800422e:	681b      	ldr	r3, [r3, #0]
 8004230:	607b      	str	r3, [r7, #4]
  /* <<<DD_SYSTM001_PRIV _API_4>>> */
  SysTickCount++;
 8004232:	f640 4328 	movw	r3, #3112	; 0xc28
 8004236:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800423a:	681b      	ldr	r3, [r3, #0]
 800423c:	f103 0201 	add.w	r2, r3, #1
 8004240:	f640 4328 	movw	r3, #3112	; 0xc28
 8004244:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004248:	601a      	str	r2, [r3, #0]

  if(TmrObjPtr == NULL)
 800424a:	687b      	ldr	r3, [r7, #4]
 800424c:	2b00      	cmp	r3, #0
 800424e:	d010      	beq.n	8004272 <SysTick_Handler+0x52>
    /* Not supposed to be here */
    DBG002_ERROR(APP_GID,SYSTM001_INVALID_HANDLE_ERROR, 0, NULL);
  }
  else
  {
    if(TmrObjPtr->TimerCount > 1UL)
 8004250:	687b      	ldr	r3, [r7, #4]
 8004252:	689b      	ldr	r3, [r3, #8]
 8004254:	2b01      	cmp	r3, #1
 8004256:	d906      	bls.n	8004266 <SysTick_Handler+0x46>
    {
      TmrObjPtr->TimerCount--;
 8004258:	687b      	ldr	r3, [r7, #4]
 800425a:	689b      	ldr	r3, [r3, #8]
 800425c:	f103 32ff 	add.w	r2, r3, #4294967295
 8004260:	687b      	ldr	r3, [r7, #4]
 8004262:	609a      	str	r2, [r3, #8]
 8004264:	e005      	b.n	8004272 <SysTick_Handler+0x52>
    }
    else
    { 
      TmrObjPtr->TimerCount = 0;
 8004266:	687b      	ldr	r3, [r7, #4]
 8004268:	f04f 0200 	mov.w	r2, #0
 800426c:	609a      	str	r2, [r3, #8]
      SYSTM001_lTimerHandler();
 800426e:	f7ff ff8d 	bl	800418c <SYSTM001_lTimerHandler>
    }
  }
}
 8004272:	f107 0708 	add.w	r7, r7, #8
 8004276:	46bd      	mov	sp, r7
 8004278:	bd80      	pop	{r7, pc}
 800427a:	bf00      	nop

0800427c <SYSTM001_Init>:
/*
 *  Initialization function which initializes the App internal data
 *  structures to default values. 
 */
void  SYSTM001_Init( void)
{
 800427c:	b580      	push	{r7, lr}
 800427e:	b082      	sub	sp, #8
 8004280:	af00      	add	r7, sp, #0
    uint32_t Status = 0UL;
 8004282:	f04f 0300 	mov.w	r3, #0
 8004286:	607b      	str	r3, [r7, #4]
  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM001_FUNCTION_ENTRY);
   /* <<<DD_SYSTM001 _API_1>>> */
  /** Initialize the header of the list */
  TimerList = NULL;
 8004288:	f640 4320 	movw	r3, #3104	; 0xc20
 800428c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004290:	f04f 0200 	mov.w	r2, #0
 8004294:	601a      	str	r2, [r3, #0]
  /* Clock Initialization */
  CLK001_Init();     
 8004296:	f01b f99d 	bl	801f5d4 <CLK001_Init>
  /**   Initialize timer tracker  */
  Status = SysTick_Config((uint32_t)(SYSTM001_SYSTICK_INTERVAL * SYSTM001_SYS_CORE_CLOCK * 1000U));
 800429a:	f24d 40c0 	movw	r0, #54464	; 0xd4c0
 800429e:	f2c0 0001 	movt	r0, #1
 80042a2:	f7ff fdcb 	bl	8003e3c <SysTick_Config>
 80042a6:	6078      	str	r0, [r7, #4]
  if(Status == 1U)
  {
        DBG002_ERROR(APP_GID,SYSTM001_ERROR, 0, NULL);
  }
    NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),10,0));
 80042a8:	f7ff fd4e 	bl	8003d48 <NVIC_GetPriorityGrouping>
 80042ac:	4603      	mov	r3, r0
 80042ae:	4618      	mov	r0, r3
 80042b0:	f04f 010a 	mov.w	r1, #10
 80042b4:	f04f 0200 	mov.w	r2, #0
 80042b8:	f7ff fd84 	bl	8003dc4 <NVIC_EncodePriority>
 80042bc:	4603      	mov	r3, r0
 80042be:	f04f 30ff 	mov.w	r0, #4294967295
 80042c2:	4619      	mov	r1, r3
 80042c4:	f7ff fd50 	bl	8003d68 <NVIC_SetPriority>
  TimerTracker = 0UL;
 80042c8:	f640 4324 	movw	r3, #3108	; 0xc24
 80042cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042d0:	f04f 0200 	mov.w	r2, #0
 80042d4:	601a      	str	r2, [r3, #0]
  DBG002_FUNCTION_EXIT(APP_GID,SYSTM001_FUNCTION_EXIT);
}
 80042d6:	f107 0708 	add.w	r7, r7, #8
 80042da:	46bd      	mov	sp, r7
 80042dc:	bd80      	pop	{r7, pc}
 80042de:	bf00      	nop

080042e0 <SYSTM001_CreateTimer>:
  uint32_t Period,
  SYSTM001_TimerType TimerType, 
  SYSTM001_TimerCallBackPtr TimerCallBack, 
  void  * pCallBackArgPtr
)
{
 80042e0:	b480      	push	{r7}
 80042e2:	b089      	sub	sp, #36	; 0x24
 80042e4:	af00      	add	r7, sp, #0
 80042e6:	60f8      	str	r0, [r7, #12]
 80042e8:	607a      	str	r2, [r7, #4]
 80042ea:	603b      	str	r3, [r7, #0]
 80042ec:	460b      	mov	r3, r1
 80042ee:	72fb      	strb	r3, [r7, #11]
  uint32_t TimerID = 0UL;
 80042f0:	f04f 0300 	mov.w	r3, #0
 80042f4:	61fb      	str	r3, [r7, #28]
  uint32_t Count = 0UL;
 80042f6:	f04f 0300 	mov.w	r3, #0
 80042fa:	61bb      	str	r3, [r7, #24]
  uint32_t Error = 0UL;  
 80042fc:	f04f 0300 	mov.w	r3, #0
 8004300:	617b      	str	r3, [r7, #20]
  /* <<<DD_SYSTM001 _API_2>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM001_FUNCTION_ENTRY);
  /* Check for input parameter */
    if((TimerType != SYSTM001_ONE_SHOT) && (TimerType != SYSTM001_PERIODIC))
 8004302:	7afb      	ldrb	r3, [r7, #11]
 8004304:	2b00      	cmp	r3, #0
 8004306:	d005      	beq.n	8004314 <SYSTM001_CreateTimer+0x34>
 8004308:	7afb      	ldrb	r3, [r7, #11]
 800430a:	2b01      	cmp	r3, #1
 800430c:	d002      	beq.n	8004314 <SYSTM001_CreateTimer+0x34>
    {
      DBG002_ERROR(GID_SYSTM001,SYSTM001_INVALID_HANDLE_ERROR, 0, NULL);
      Error=(uint32_t)1UL;
 800430e:	f04f 0301 	mov.w	r3, #1
 8004312:	617b      	str	r3, [r7, #20]
    }
    if(Period < (uint32_t)SYSTM001_SYSTICK_INTERVAL)
 8004314:	68fb      	ldr	r3, [r7, #12]
 8004316:	2b00      	cmp	r3, #0
 8004318:	d102      	bne.n	8004320 <SYSTM001_CreateTimer+0x40>
    {
      DBG002_ERROR(GID_SYSTM001,SYSTM001_INVALID_HANDLE_ERROR, 0, NULL);
      Error=(uint32_t)1UL;
 800431a:	f04f 0301 	mov.w	r3, #1
 800431e:	617b      	str	r3, [r7, #20]
    }
    if(Period == 0)          /* Timer with '0' time is not allowed. */
 8004320:	68fb      	ldr	r3, [r7, #12]
 8004322:	2b00      	cmp	r3, #0
 8004324:	d102      	bne.n	800432c <SYSTM001_CreateTimer+0x4c>
    {
      DBG002_ERROR(GID_SYSTM001,SYSTM001_INVALID_HANDLE_ERROR, 0, NULL);
      Error=(uint32_t)1UL;
 8004326:	f04f 0301 	mov.w	r3, #1
 800432a:	617b      	str	r3, [r7, #20]
    }

    if(TimerCallBack == NULL)
 800432c:	687b      	ldr	r3, [r7, #4]
 800432e:	2b00      	cmp	r3, #0
 8004330:	d102      	bne.n	8004338 <SYSTM001_CreateTimer+0x58>
    {
      DBG002_ERROR(GID_SYSTM001,SYSTM001_INVALID_HANDLE_ERROR, 0, NULL);
      Error=(uint32_t)1UL;
 8004332:	f04f 0301 	mov.w	r3, #1
 8004336:	617b      	str	r3, [r7, #20]
    }
    if (!Error)	
 8004338:	697b      	ldr	r3, [r7, #20]
 800433a:	2b00      	cmp	r3, #0
 800433c:	f040 8098 	bne.w	8004470 <SYSTM001_CreateTimer+0x190>
    {
       for(Count = 0UL; Count < SYSTM001_CFG_MAX_TMR; Count++)
 8004340:	f04f 0300 	mov.w	r3, #0
 8004344:	61bb      	str	r3, [r7, #24]
 8004346:	e08f      	b.n	8004468 <SYSTM001_CreateTimer+0x188>
       {
           /* Check for free timer ID */
           if((TimerTracker & ((uint32_t)1U << Count)) == 0U)
 8004348:	f640 4324 	movw	r3, #3108	; 0xc24
 800434c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004350:	681a      	ldr	r2, [r3, #0]
 8004352:	69bb      	ldr	r3, [r7, #24]
 8004354:	fa22 f303 	lsr.w	r3, r2, r3
 8004358:	f003 0301 	and.w	r3, r3, #1
 800435c:	2b00      	cmp	r3, #0
 800435e:	d17f      	bne.n	8004460 <SYSTM001_CreateTimer+0x180>
           {
               /* If yes,assign ID to this timer      */
               TimerTracker |= ((uint32_t)1U << Count);
 8004360:	69bb      	ldr	r3, [r7, #24]
 8004362:	f04f 0201 	mov.w	r2, #1
 8004366:	fa02 f203 	lsl.w	r2, r2, r3
 800436a:	f640 4324 	movw	r3, #3108	; 0xc24
 800436e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004372:	681b      	ldr	r3, [r3, #0]
 8004374:	431a      	orrs	r2, r3
 8004376:	f640 4324 	movw	r3, #3108	; 0xc24
 800437a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800437e:	601a      	str	r2, [r3, #0]
               /* Initialize timer as per input values */
               TimerTbl[Count].TimerID     = Count;
 8004380:	f246 0324 	movw	r3, #24612	; 0x6024
 8004384:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004388:	69ba      	ldr	r2, [r7, #24]
 800438a:	ea4f 1242 	mov.w	r2, r2, lsl #5
 800438e:	189b      	adds	r3, r3, r2
 8004390:	69ba      	ldr	r2, [r7, #24]
 8004392:	601a      	str	r2, [r3, #0]
               TimerTbl[Count].TimerType   = TimerType;
 8004394:	f246 0324 	movw	r3, #24612	; 0x6024
 8004398:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800439c:	69ba      	ldr	r2, [r7, #24]
 800439e:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80043a2:	189b      	adds	r3, r3, r2
 80043a4:	7afa      	ldrb	r2, [r7, #11]
 80043a6:	711a      	strb	r2, [r3, #4]
               TimerTbl[Count].TimerState  = SYSTM001_STATE_STOPPED;
 80043a8:	f246 0324 	movw	r3, #24612	; 0x6024
 80043ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043b0:	69ba      	ldr	r2, [r7, #24]
 80043b2:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80043b6:	189b      	adds	r3, r3, r2
 80043b8:	f04f 0201 	mov.w	r2, #1
 80043bc:	715a      	strb	r2, [r3, #5]
             TimerTbl[Count].TimerCount  = ((Period / SYSTM001_SYSTICK_INTERVAL)\
                                                    +HW_TIMER_ADDITIONAL_CNT);
 80043be:	68fb      	ldr	r3, [r7, #12]
 80043c0:	f103 0201 	add.w	r2, r3, #1
               TimerTracker |= ((uint32_t)1U << Count);
               /* Initialize timer as per input values */
               TimerTbl[Count].TimerID     = Count;
               TimerTbl[Count].TimerType   = TimerType;
               TimerTbl[Count].TimerState  = SYSTM001_STATE_STOPPED;
             TimerTbl[Count].TimerCount  = ((Period / SYSTM001_SYSTICK_INTERVAL)\
 80043c4:	f246 0324 	movw	r3, #24612	; 0x6024
 80043c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043cc:	69b9      	ldr	r1, [r7, #24]
 80043ce:	ea4f 1141 	mov.w	r1, r1, lsl #5
 80043d2:	185b      	adds	r3, r3, r1
 80043d4:	f103 0308 	add.w	r3, r3, #8
 80043d8:	601a      	str	r2, [r3, #0]
                                                    +HW_TIMER_ADDITIONAL_CNT);
               TimerTbl[Count].TimerReload	= (Period / SYSTM001_SYSTICK_INTERVAL);
 80043da:	f246 0324 	movw	r3, #24612	; 0x6024
 80043de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043e2:	69ba      	ldr	r2, [r7, #24]
 80043e4:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80043e8:	189b      	adds	r3, r3, r2
 80043ea:	f103 030c 	add.w	r3, r3, #12
 80043ee:	68fa      	ldr	r2, [r7, #12]
 80043f0:	601a      	str	r2, [r3, #0]
               TimerTbl[Count].TimerCallBack = TimerCallBack;
 80043f2:	f246 0324 	movw	r3, #24612	; 0x6024
 80043f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043fa:	69ba      	ldr	r2, [r7, #24]
 80043fc:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8004400:	189b      	adds	r3, r3, r2
 8004402:	f103 0310 	add.w	r3, r3, #16
 8004406:	687a      	ldr	r2, [r7, #4]
 8004408:	601a      	str	r2, [r3, #0]
               TimerTbl[Count].ParamToCallBack = pCallBackArgPtr;
 800440a:	f246 0324 	movw	r3, #24612	; 0x6024
 800440e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004412:	69ba      	ldr	r2, [r7, #24]
 8004414:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8004418:	189b      	adds	r3, r3, r2
 800441a:	f103 0314 	add.w	r3, r3, #20
 800441e:	683a      	ldr	r2, [r7, #0]
 8004420:	601a      	str	r2, [r3, #0]
               TimerTbl[Count].TimerPrev   = NULL;
 8004422:	f246 0324 	movw	r3, #24612	; 0x6024
 8004426:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800442a:	69ba      	ldr	r2, [r7, #24]
 800442c:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8004430:	189b      	adds	r3, r3, r2
 8004432:	f103 031c 	add.w	r3, r3, #28
 8004436:	f04f 0200 	mov.w	r2, #0
 800443a:	601a      	str	r2, [r3, #0]
               TimerTbl[Count].TimerNext   = NULL;
 800443c:	f246 0324 	movw	r3, #24612	; 0x6024
 8004440:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004444:	69ba      	ldr	r2, [r7, #24]
 8004446:	ea4f 1242 	mov.w	r2, r2, lsl #5
 800444a:	189b      	adds	r3, r3, r2
 800444c:	f103 0318 	add.w	r3, r3, #24
 8004450:	f04f 0200 	mov.w	r2, #0
 8004454:	601a      	str	r2, [r3, #0]
               TimerID = Count + 1U;
 8004456:	69bb      	ldr	r3, [r7, #24]
 8004458:	f103 0301 	add.w	r3, r3, #1
 800445c:	61fb      	str	r3, [r7, #28]
               break;
 800445e:	e007      	b.n	8004470 <SYSTM001_CreateTimer+0x190>
      DBG002_ERROR(GID_SYSTM001,SYSTM001_INVALID_HANDLE_ERROR, 0, NULL);
      Error=(uint32_t)1UL;
    }
    if (!Error)	
    {
       for(Count = 0UL; Count < SYSTM001_CFG_MAX_TMR; Count++)
 8004460:	69bb      	ldr	r3, [r7, #24]
 8004462:	f103 0301 	add.w	r3, r3, #1
 8004466:	61bb      	str	r3, [r7, #24]
 8004468:	69bb      	ldr	r3, [r7, #24]
 800446a:	2b1f      	cmp	r3, #31
 800446c:	f67f af6c 	bls.w	8004348 <SYSTM001_CreateTimer+0x68>
               break;
            }
        }
    }
  DBG002_FUNCTION_EXIT(APP_GID,SYSTM001_FUNCTION_EXIT);
  return (handle_t)TimerID;
 8004470:	69fb      	ldr	r3, [r7, #28]
}  
 8004472:	4618      	mov	r0, r3
 8004474:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8004478:	46bd      	mov	sp, r7
 800447a:	bc80      	pop	{r7}
 800447c:	4770      	bx	lr
 800447e:	bf00      	nop

08004480 <SYSTM001_StartTimer>:

/*
 *  Interface to start the software timer .
 */
status_t SYSTM001_StartTimer(handle_t  Handle) 
{
 8004480:	b580      	push	{r7, lr}
 8004482:	b084      	sub	sp, #16
 8004484:	af00      	add	r7, sp, #0
 8004486:	6078      	str	r0, [r7, #4]
  status_t Error = (status_t )DAVEApp_SUCCESS;
 8004488:	f04f 0300 	mov.w	r3, #0
 800448c:	60fb      	str	r3, [r7, #12]
  /* <<<DD_SYSTM001 _API_3>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM001_FUNCTION_ENTRY);

  /* Check validity of parameter */
  if(Handle > SYSTM001_CFG_MAX_TMR)
 800448e:	687b      	ldr	r3, [r7, #4]
 8004490:	2b20      	cmp	r3, #32
 8004492:	d902      	bls.n	800449a <SYSTM001_StartTimer+0x1a>
  {
    Error = (status_t)SYSTM001_INVALID_HANDLE_ERROR;
 8004494:	f04f 0301 	mov.w	r3, #1
 8004498:	60fb      	str	r3, [r7, #12]
    DBG002_ERROR(APP_GID,Error, 0, NULL);
  }
  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)
 800449a:	f640 4324 	movw	r3, #3108	; 0xc24
 800449e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044a2:	681a      	ldr	r2, [r3, #0]
 80044a4:	687b      	ldr	r3, [r7, #4]
 80044a6:	f103 33ff 	add.w	r3, r3, #4294967295
 80044aa:	fa22 f303 	lsr.w	r3, r2, r3
 80044ae:	f003 0301 	and.w	r3, r3, #1
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d102      	bne.n	80044bc <SYSTM001_StartTimer+0x3c>
  {
    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;
 80044b6:	f04f 0301 	mov.w	r3, #1
 80044ba:	60fb      	str	r3, [r7, #12]
    DBG002_ERROR(APP_GID,Error, 0, NULL);
  }
  /* Any timer with time '0', can't start again. */
  if(TimerTbl[Handle - 1U].TimerCount == 0UL)
 80044bc:	687b      	ldr	r3, [r7, #4]
 80044be:	f103 32ff 	add.w	r2, r3, #4294967295
 80044c2:	f246 0324 	movw	r3, #24612	; 0x6024
 80044c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044ca:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80044ce:	189b      	adds	r3, r3, r2
 80044d0:	f103 0308 	add.w	r3, r3, #8
 80044d4:	681b      	ldr	r3, [r3, #0]
 80044d6:	2b00      	cmp	r3, #0
 80044d8:	d102      	bne.n	80044e0 <SYSTM001_StartTimer+0x60>
  {
    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;
 80044da:	f04f 0301 	mov.w	r3, #1
 80044de:	60fb      	str	r3, [r7, #12]
    DBG002_ERROR(APP_GID,Error, 0, NULL);
  }
  
  
  if(Error == (status_t)DAVEApp_SUCCESS)
 80044e0:	68fb      	ldr	r3, [r7, #12]
 80044e2:	2b00      	cmp	r3, #0
 80044e4:	d11f      	bne.n	8004526 <SYSTM001_StartTimer+0xa6>
  {
    /* Check if timer is running */
    if(TimerTbl[(Handle - 1U)].TimerState != SYSTM001_STATE_RUNNING)
 80044e6:	687b      	ldr	r3, [r7, #4]
 80044e8:	f103 32ff 	add.w	r2, r3, #4294967295
 80044ec:	f246 0324 	movw	r3, #24612	; 0x6024
 80044f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044f4:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80044f8:	189b      	adds	r3, r3, r2
 80044fa:	795b      	ldrb	r3, [r3, #5]
 80044fc:	2b00      	cmp	r3, #0
 80044fe:	d012      	beq.n	8004526 <SYSTM001_StartTimer+0xa6>
    {
      /* set timer status as SYSTM001_STATE_RUNNING */
      TimerTbl[(Handle - 1U)].TimerState = SYSTM001_STATE_RUNNING;
 8004500:	687b      	ldr	r3, [r7, #4]
 8004502:	f103 32ff 	add.w	r2, r3, #4294967295
 8004506:	f246 0324 	movw	r3, #24612	; 0x6024
 800450a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800450e:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8004512:	189b      	adds	r3, r3, r2
 8004514:	f04f 0200 	mov.w	r2, #0
 8004518:	715a      	strb	r2, [r3, #5]
      /* Insert this timer into timer list  */
      SYSTM001_lInsertTimerList((Handle - 1U));
 800451a:	687b      	ldr	r3, [r7, #4]
 800451c:	f103 33ff 	add.w	r3, r3, #4294967295
 8004520:	4618      	mov	r0, r3
 8004522:	f7ff fcbd 	bl	8003ea0 <SYSTM001_lInsertTimerList>
    }
  }

  DBG002_FUNCTION_EXIT(APP_GID,SYSTM001_FUNCTION_EXIT);
  return Error;
 8004526:	68fb      	ldr	r3, [r7, #12]
}
 8004528:	4618      	mov	r0, r3
 800452a:	f107 0710 	add.w	r7, r7, #16
 800452e:	46bd      	mov	sp, r7
 8004530:	bd80      	pop	{r7, pc}
 8004532:	bf00      	nop

08004534 <SYSTM001_StopTimer>:

/*
 *  Interface to stop the software timer.
 */
status_t SYSTM001_StopTimer(handle_t Handle) 
{
 8004534:	b580      	push	{r7, lr}
 8004536:	b084      	sub	sp, #16
 8004538:	af00      	add	r7, sp, #0
 800453a:	6078      	str	r0, [r7, #4]
  status_t Error = (status_t )DAVEApp_SUCCESS;
 800453c:	f04f 0300 	mov.w	r3, #0
 8004540:	60fb      	str	r3, [r7, #12]
  /* <<<DD_SYSTM001 _API_4>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM001_FUNCTION_ENTRY);

  /* Check validity of parameter        */
  if(Handle > SYSTM001_CFG_MAX_TMR)
 8004542:	687b      	ldr	r3, [r7, #4]
 8004544:	2b20      	cmp	r3, #32
 8004546:	d902      	bls.n	800454e <SYSTM001_StopTimer+0x1a>
  {
    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;
 8004548:	f04f 0301 	mov.w	r3, #1
 800454c:	60fb      	str	r3, [r7, #12]
    DBG002_ERROR(APP_GID,Error, 0, NULL);
  }
  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)
 800454e:	f640 4324 	movw	r3, #3108	; 0xc24
 8004552:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004556:	681a      	ldr	r2, [r3, #0]
 8004558:	687b      	ldr	r3, [r7, #4]
 800455a:	f103 33ff 	add.w	r3, r3, #4294967295
 800455e:	fa22 f303 	lsr.w	r3, r2, r3
 8004562:	f003 0301 	and.w	r3, r3, #1
 8004566:	2b00      	cmp	r3, #0
 8004568:	d102      	bne.n	8004570 <SYSTM001_StopTimer+0x3c>
  {
    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;
 800456a:	f04f 0301 	mov.w	r3, #1
 800456e:	60fb      	str	r3, [r7, #12]
    DBG002_ERROR(APP_GID,Error, 0, NULL);
  }

  if(Error == (status_t)DAVEApp_SUCCESS)
 8004570:	68fb      	ldr	r3, [r7, #12]
 8004572:	2b00      	cmp	r3, #0
 8004574:	d11f      	bne.n	80045b6 <SYSTM001_StopTimer+0x82>
  {
    /* Check whether Timer is in Stop state */
    if(TimerTbl[(Handle - 1U)].TimerState != SYSTM001_STATE_STOPPED)
 8004576:	687b      	ldr	r3, [r7, #4]
 8004578:	f103 32ff 	add.w	r2, r3, #4294967295
 800457c:	f246 0324 	movw	r3, #24612	; 0x6024
 8004580:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004584:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8004588:	189b      	adds	r3, r3, r2
 800458a:	795b      	ldrb	r3, [r3, #5]
 800458c:	2b01      	cmp	r3, #1
 800458e:	d012      	beq.n	80045b6 <SYSTM001_StopTimer+0x82>
    {
      /* remove Timer from node list */
      SYSTM001_lRemoveTimerList((Handle - 1U));
 8004590:	687b      	ldr	r3, [r7, #4]
 8004592:	f103 33ff 	add.w	r3, r3, #4294967295
 8004596:	4618      	mov	r0, r3
 8004598:	f7ff fd8c 	bl	80040b4 <SYSTM001_lRemoveTimerList>

      /* Set timer status as SYSTM001_STATE_STOPPED  */
      TimerTbl[(Handle - 1U)].TimerState = SYSTM001_STATE_STOPPED;
 800459c:	687b      	ldr	r3, [r7, #4]
 800459e:	f103 32ff 	add.w	r2, r3, #4294967295
 80045a2:	f246 0324 	movw	r3, #24612	; 0x6024
 80045a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045aa:	ea4f 1242 	mov.w	r2, r2, lsl #5
 80045ae:	189b      	adds	r3, r3, r2
 80045b0:	f04f 0201 	mov.w	r2, #1
 80045b4:	715a      	strb	r2, [r3, #5]
    }
  }

  DBG002_FUNCTION_EXIT(APP_GID,SYSTM001_FUNCTION_EXIT);
  return Error;
 80045b6:	68fb      	ldr	r3, [r7, #12]
}
 80045b8:	4618      	mov	r0, r3
 80045ba:	f107 0710 	add.w	r7, r7, #16
 80045be:	46bd      	mov	sp, r7
 80045c0:	bd80      	pop	{r7, pc}
 80045c2:	bf00      	nop

080045c4 <SYSTM001_DeleteTimer>:

/*
 *  Function to delete the Timer instance.
 */
status_t SYSTM001_DeleteTimer(handle_t Handle) 
{
 80045c4:	b580      	push	{r7, lr}
 80045c6:	b084      	sub	sp, #16
 80045c8:	af00      	add	r7, sp, #0
 80045ca:	6078      	str	r0, [r7, #4]
  status_t Error = (status_t )DAVEApp_SUCCESS;
 80045cc:	f04f 0300 	mov.w	r3, #0
 80045d0:	60fb      	str	r3, [r7, #12]
  /* <<<DD_SYSTM001 _API_5>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,SYSTM001_FUNCTION_ENTRY);

  /* Check validity of parameter        */
  if(Handle > SYSTM001_CFG_MAX_TMR)
 80045d2:	687b      	ldr	r3, [r7, #4]
 80045d4:	2b20      	cmp	r3, #32
 80045d6:	d902      	bls.n	80045de <SYSTM001_DeleteTimer+0x1a>
  {
    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;
 80045d8:	f04f 0301 	mov.w	r3, #1
 80045dc:	60fb      	str	r3, [r7, #12]
    DBG002_ERROR(APP_GID,Error, 0, NULL);
  }
  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)
 80045de:	f640 4324 	movw	r3, #3108	; 0xc24
 80045e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045e6:	681a      	ldr	r2, [r3, #0]
 80045e8:	687b      	ldr	r3, [r7, #4]
 80045ea:	f103 33ff 	add.w	r3, r3, #4294967295
 80045ee:	fa22 f303 	lsr.w	r3, r2, r3
 80045f2:	f003 0301 	and.w	r3, r3, #1
 80045f6:	2b00      	cmp	r3, #0
 80045f8:	d102      	bne.n	8004600 <SYSTM001_DeleteTimer+0x3c>
  {
    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;
 80045fa:	f04f 0301 	mov.w	r3, #1
 80045fe:	60fb      	str	r3, [r7, #12]
    DBG002_ERROR(APP_GID,Error, 0, NULL);
  }

  if(Error == (status_t)DAVEApp_SUCCESS)
 8004600:	68fb      	ldr	r3, [r7, #12]
 8004602:	2b00      	cmp	r3, #0
 8004604:	d126      	bne.n	8004654 <SYSTM001_DeleteTimer+0x90>
  {
    /* Check if timer is running */
    if(TimerTbl[(Handle - 1U)].TimerState == SYSTM001_STATE_RUNNING)
 8004606:	687b      	ldr	r3, [r7, #4]
 8004608:	f103 32ff 	add.w	r2, r3, #4294967295
 800460c:	f246 0324 	movw	r3, #24612	; 0x6024
 8004610:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004614:	ea4f 1242 	mov.w	r2, r2, lsl #5
 8004618:	189b      	adds	r3, r3, r2
 800461a:	795b      	ldrb	r3, [r3, #5]
 800461c:	2b00      	cmp	r3, #0
 800461e:	d105      	bne.n	800462c <SYSTM001_DeleteTimer+0x68>
    {
      /* Yes,remove this timer from timer list*/
      SYSTM001_lRemoveTimerList((Handle - 1U));
 8004620:	687b      	ldr	r3, [r7, #4]
 8004622:	f103 33ff 	add.w	r3, r3, #4294967295
 8004626:	4618      	mov	r0, r3
 8004628:	f7ff fd44 	bl	80040b4 <SYSTM001_lRemoveTimerList>
    }

    /* Release resource that this timer hold*/
    TimerTracker &=~((uint32_t)1U << (Handle - 1U));
 800462c:	687b      	ldr	r3, [r7, #4]
 800462e:	f103 33ff 	add.w	r3, r3, #4294967295
 8004632:	f04f 0201 	mov.w	r2, #1
 8004636:	fa02 f303 	lsl.w	r3, r2, r3
 800463a:	ea6f 0203 	mvn.w	r2, r3
 800463e:	f640 4324 	movw	r3, #3108	; 0xc24
 8004642:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004646:	681b      	ldr	r3, [r3, #0]
 8004648:	401a      	ands	r2, r3
 800464a:	f640 4324 	movw	r3, #3108	; 0xc24
 800464e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004652:	601a      	str	r2, [r3, #0]
  }

  DBG002_FUNCTION_EXIT(APP_GID,SYSTM001_FUNCTION_EXIT);
  return Error;
 8004654:	68fb      	ldr	r3, [r7, #12]

}
 8004656:	4618      	mov	r0, r3
 8004658:	f107 0710 	add.w	r7, r7, #16
 800465c:	46bd      	mov	sp, r7
 800465e:	bd80      	pop	{r7, pc}

08004660 <SYSTM001_GetTime>:

/*
 *  Interface to get the current system time.
 */
uint32_t  SYSTM001_GetTime(void)
{
 8004660:	b480      	push	{r7}
 8004662:	af00      	add	r7, sp, #0
  /* <<<DD_SYSTM001 _API_6>>> */
  return CONVERT_SYSTICK_COUNT_TO_MSEC(SysTickCount);
 8004664:	f640 4328 	movw	r3, #3112	; 0xc28
 8004668:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800466c:	681b      	ldr	r3, [r3, #0]
}
 800466e:	4618      	mov	r0, r3
 8004670:	46bd      	mov	sp, r7
 8004672:	bc80      	pop	{r7}
 8004674:	4770      	bx	lr
 8004676:	bf00      	nop

08004678 <SYSTM001_GetSysTickCount>:
/*
 *  Utility function to get the no of system ticks for the 
 *  specified period.
 */
uint32_t  SYSTM001_GetSysTickCount(uint32_t Period ) 
{
 8004678:	b480      	push	{r7}
 800467a:	b085      	sub	sp, #20
 800467c:	af00      	add	r7, sp, #0
 800467e:	6078      	str	r0, [r7, #4]
  /* <<<DD_SYSTM001 _API_7>>> */
  uint32_t	Count  = CONVERT_MSEC_TO_SYSICK_COUNT(Period);
 8004680:	687a      	ldr	r2, [r7, #4]
 8004682:	f24d 43c0 	movw	r3, #54464	; 0xd4c0
 8004686:	f2c0 0301 	movt	r3, #1
 800468a:	fb03 f302 	mul.w	r3, r3, r2
 800468e:	60fb      	str	r3, [r7, #12]
  return Count;
 8004690:	68fb      	ldr	r3, [r7, #12]
}
 8004692:	4618      	mov	r0, r3
 8004694:	f107 0714 	add.w	r7, r7, #20
 8004698:	46bd      	mov	sp, r7
 800469a:	bc80      	pop	{r7}
 800469c:	4770      	bx	lr
 800469e:	bf00      	nop

080046a0 <_malloc_r>:
 *  Size bytes of storage available. If the space is available, malloc returns a
 *  pointer to a newly allocated block as its result. *
 * This API is only applicable for XMC4500 device
 */
void* _malloc_r( struct _reent* Rptr, size_t Size )
{
 80046a0:	b580      	push	{r7, lr}
 80046a2:	b082      	sub	sp, #8
 80046a4:	af00      	add	r7, sp, #0
 80046a6:	6078      	str	r0, [r7, #4]
 80046a8:	6039      	str	r1, [r7, #0]
/* Call malloc function of GMM App. */
  return (GMM001_malloc(Size)); 
 80046aa:	6838      	ldr	r0, [r7, #0]
 80046ac:	f006 fcd8 	bl	800b060 <GMM001_malloc>
 80046b0:	4603      	mov	r3, r0
}
 80046b2:	4618      	mov	r0, r3
 80046b4:	f107 0708 	add.w	r7, r7, #8
 80046b8:	46bd      	mov	sp, r7
 80046ba:	bd80      	pop	{r7, pc}

080046bc <_calloc_r>:
 * but the memory block is initialized to all zero bytes. *
 * This API is only applicable for XMC4500 device
 */
/* <<<DD_SLTHA003_API_2>>> */
void* _calloc_r( struct _reent *Rptr, size_t NoOfElem, size_t ElemSize )
{
 80046bc:	b580      	push	{r7, lr}
 80046be:	b086      	sub	sp, #24
 80046c0:	af00      	add	r7, sp, #0
 80046c2:	60f8      	str	r0, [r7, #12]
 80046c4:	60b9      	str	r1, [r7, #8]
 80046c6:	607a      	str	r2, [r7, #4]
  void *MemPtr = NULL;
 80046c8:	f04f 0300 	mov.w	r3, #0
 80046cc:	617b      	str	r3, [r7, #20]
/* Call malloc function of GMM App. */
  MemPtr = GMM001_malloc( NoOfElem * ElemSize);
 80046ce:	68bb      	ldr	r3, [r7, #8]
 80046d0:	687a      	ldr	r2, [r7, #4]
 80046d2:	fb02 f303 	mul.w	r3, r2, r3
 80046d6:	4618      	mov	r0, r3
 80046d8:	f006 fcc2 	bl	800b060 <GMM001_malloc>
 80046dc:	6178      	str	r0, [r7, #20]
  memset(MemPtr, 0, (NoOfElem * ElemSize));
 80046de:	68bb      	ldr	r3, [r7, #8]
 80046e0:	687a      	ldr	r2, [r7, #4]
 80046e2:	fb02 f303 	mul.w	r3, r2, r3
 80046e6:	6978      	ldr	r0, [r7, #20]
 80046e8:	f04f 0100 	mov.w	r1, #0
 80046ec:	461a      	mov	r2, r3
 80046ee:	f01f f8ff 	bl	80238f0 <memset>
  return MemPtr;
 80046f2:	697b      	ldr	r3, [r7, #20]
}
 80046f4:	4618      	mov	r0, r3
 80046f6:	f107 0718 	add.w	r7, r7, #24
 80046fa:	46bd      	mov	sp, r7
 80046fc:	bd80      	pop	{r7, pc}
 80046fe:	bf00      	nop

08004700 <_free_r>:
 * object as the argument. *
 * This API is only applicable for XMC4500 device
 */ 
/* <<<DD_SLTHA003_API_3>>> */
void _free_r( struct _reent *Rptr, void *Ptr )
{
 8004700:	b580      	push	{r7, lr}
 8004702:	b082      	sub	sp, #8
 8004704:	af00      	add	r7, sp, #0
 8004706:	6078      	str	r0, [r7, #4]
 8004708:	6039      	str	r1, [r7, #0]
/* Call free function of GMM App. */
  GMM001_free(Ptr);
 800470a:	6838      	ldr	r0, [r7, #0]
 800470c:	f006 fd44 	bl	800b198 <GMM001_free>
}
 8004710:	f107 0708 	add.w	r7, r7, #8
 8004714:	46bd      	mov	sp, r7
 8004716:	bd80      	pop	{r7, pc}

08004718 <_realloc_r>:
 * object matches the contents of the original object. *
 * This API is only applicable for XMC4500 device
 */
/* <<<DD_SLTHA003_API_4>>> */
void* _realloc_r( struct _reent *Rptr, void *Ptr, size_t Size )
{
 8004718:	b580      	push	{r7, lr}
 800471a:	b084      	sub	sp, #16
 800471c:	af00      	add	r7, sp, #0
 800471e:	60f8      	str	r0, [r7, #12]
 8004720:	60b9      	str	r1, [r7, #8]
 8004722:	607a      	str	r2, [r7, #4]
/* Call realloc function of GMM App. */
  return (GMM001_realloc( Size, Ptr));
 8004724:	6878      	ldr	r0, [r7, #4]
 8004726:	68b9      	ldr	r1, [r7, #8]
 8004728:	f006 fcc6 	bl	800b0b8 <GMM001_realloc>
 800472c:	4603      	mov	r3, r0
}
 800472e:	4618      	mov	r0, r3
 8004730:	f107 0710 	add.w	r7, r7, #16
 8004734:	46bd      	mov	sp, r7
 8004736:	bd80      	pop	{r7, pc}

08004738 <_gettimeofday_r>:
/* <<<DD_SLTHA003_API_5>>> */
/*
 * This function gets the calendar time in seconds.
 */
SLTHA003_Time()
{
 8004738:	b580      	push	{r7, lr}
 800473a:	b088      	sub	sp, #32
 800473c:	af00      	add	r7, sp, #0
 800473e:	60f8      	str	r0, [r7, #12]
 8004740:	60b9      	str	r1, [r7, #8]
 8004742:	607a      	str	r2, [r7, #4]
   time_t Seconds ;
   status_t Status;
#if defined (__GNUC__)
       struct timezone *TimeZonePtr;
#endif
   if (TimePtr)
 8004744:	68bb      	ldr	r3, [r7, #8]
 8004746:	2b00      	cmp	r3, #0
 8004748:	d00f      	beq.n	800476a <_gettimeofday_r+0x32>
   {
     Status = RTC001_Time(&Seconds);
 800474a:	f107 0314 	add.w	r3, r7, #20
 800474e:	4618      	mov	r0, r3
 8004750:	f004 ff04 	bl	800955c <RTC001_Time>
 8004754:	61f8      	str	r0, [r7, #28]
     if (Status == (uint32_t)DAVEApp_SUCCESS)
 8004756:	69fb      	ldr	r3, [r7, #28]
 8004758:	2b00      	cmp	r3, #0
 800475a:	d106      	bne.n	800476a <_gettimeofday_r+0x32>
     {
#if defined (__GNUC__)
      TimePtr->tv_sec =  Seconds;
 800475c:	697a      	ldr	r2, [r7, #20]
 800475e:	68bb      	ldr	r3, [r7, #8]
 8004760:	601a      	str	r2, [r3, #0]
      TimePtr->tv_usec = 0;
 8004762:	68bb      	ldr	r3, [r7, #8]
 8004764:	f04f 0200 	mov.w	r2, #0
 8004768:	605a      	str	r2, [r3, #4]
#endif
    }
  }
#if defined (__GNUC__)
  /*  Return fixed data for the timezone */
  TimeZonePtr =  (struct timezone *)TimeZone;
 800476a:	687b      	ldr	r3, [r7, #4]
 800476c:	61bb      	str	r3, [r7, #24]
	TimeZonePtr->tz_minuteswest = 0;
 800476e:	69bb      	ldr	r3, [r7, #24]
 8004770:	f04f 0200 	mov.w	r2, #0
 8004774:	601a      	str	r2, [r3, #0]
  TimeZonePtr->tz_dsttime = 0;
 8004776:	69bb      	ldr	r3, [r7, #24]
 8004778:	f04f 0200 	mov.w	r2, #0
 800477c:	605a      	str	r2, [r3, #4]
#endif
  return (int)Seconds;
 800477e:	697b      	ldr	r3, [r7, #20]
}
 8004780:	4618      	mov	r0, r3
 8004782:	f107 0720 	add.w	r7, r7, #32
 8004786:	46bd      	mov	sp, r7
 8004788:	bd80      	pop	{r7, pc}
 800478a:	bf00      	nop

0800478c <_times_r>:
/* <<<DD_SLTHA003_API_6>>> */
/*
 * This function gets the processor time. 
 */
SLTHA003_Clock()
{
 800478c:	b480      	push	{r7}
 800478e:	b083      	sub	sp, #12
 8004790:	af00      	add	r7, sp, #0
 8004792:	6078      	str	r0, [r7, #4]
 8004794:	6039      	str	r1, [r7, #0]
#if  defined (__GNUC__)
  TmsPtr->tms_utime = 0;
 8004796:	683b      	ldr	r3, [r7, #0]
 8004798:	f04f 0200 	mov.w	r2, #0
 800479c:	601a      	str	r2, [r3, #0]
  TmsPtr->tms_stime = 0;
 800479e:	683b      	ldr	r3, [r7, #0]
 80047a0:	f04f 0200 	mov.w	r2, #0
 80047a4:	605a      	str	r2, [r3, #4]
  TmsPtr->tms_cutime = 0;
 80047a6:	683b      	ldr	r3, [r7, #0]
 80047a8:	f04f 0200 	mov.w	r2, #0
 80047ac:	609a      	str	r2, [r3, #8]
  TmsPtr->tms_cstime = 0;
 80047ae:	683b      	ldr	r3, [r7, #0]
 80047b0:	f04f 0200 	mov.w	r2, #0
 80047b4:	60da      	str	r2, [r3, #12]
#endif
  return 0;
 80047b6:	f04f 0300 	mov.w	r3, #0
}
 80047ba:	4618      	mov	r0, r3
 80047bc:	f107 070c 	add.w	r7, r7, #12
 80047c0:	46bd      	mov	sp, r7
 80047c2:	bc80      	pop	{r7}
 80047c4:	4770      	bx	lr
 80047c6:	bf00      	nop

080047c8 <SLTHA001_lFindAvailableSlot>:
/* 
 * Function to find whether the file is already opened and also assign a slot for any new 
 * file to open.
 */
uint32_t  SLTHA001_lFindAvailableSlot(int FileDesc)
{
 80047c8:	b480      	push	{r7}
 80047ca:	b083      	sub	sp, #12
 80047cc:	af00      	add	r7, sp, #0
 80047ce:	6078      	str	r0, [r7, #4]
  static int LastAllocFileHandle = -1;
  do
  {
/* <<<DD_SLTHA001_nonAPI_1_1>>> */
    /* Check if the File handle is the last allocated one */
    if( (FileDesc != -1)  && (FileDesc == LastAllocFileHandle))
 80047d0:	687b      	ldr	r3, [r7, #4]
 80047d2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80047d6:	d007      	beq.n	80047e8 <SLTHA001_lFindAvailableSlot+0x20>
 80047d8:	f246 63c0 	movw	r3, #26304	; 0x66c0
 80047dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047e0:	681b      	ldr	r3, [r3, #0]
 80047e2:	687a      	ldr	r2, [r7, #4]
 80047e4:	429a      	cmp	r2, r3
 80047e6:	d037      	beq.n	8004858 <SLTHA001_lFindAvailableSlot+0x90>
    {
      break;
    }
/* <<<DD_SLTHA001_nonAPI_1_2>>> */
    /* Check the FileHandle array to find the match for the File Handle*/
    for (Slot=0; Slot< MAX_OPEN_FILES; Slot++)
 80047e8:	f640 53bc 	movw	r3, #3516	; 0xdbc
 80047ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047f0:	f04f 0200 	mov.w	r2, #0
 80047f4:	601a      	str	r2, [r3, #0]
 80047f6:	e01f      	b.n	8004838 <SLTHA001_lFindAvailableSlot+0x70>
    {
      if(FileHandle[Slot].Fd == FileDesc)
 80047f8:	f640 53bc 	movw	r3, #3516	; 0xdbc
 80047fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004800:	6819      	ldr	r1, [r3, #0]
 8004802:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004806:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800480a:	460b      	mov	r3, r1
 800480c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004810:	185b      	adds	r3, r3, r1
 8004812:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004816:	18d3      	adds	r3, r2, r3
 8004818:	681a      	ldr	r2, [r3, #0]
 800481a:	687b      	ldr	r3, [r7, #4]
 800481c:	429a      	cmp	r2, r3
 800481e:	d013      	beq.n	8004848 <SLTHA001_lFindAvailableSlot+0x80>
    {
      break;
    }
/* <<<DD_SLTHA001_nonAPI_1_2>>> */
    /* Check the FileHandle array to find the match for the File Handle*/
    for (Slot=0; Slot< MAX_OPEN_FILES; Slot++)
 8004820:	f640 53bc 	movw	r3, #3516	; 0xdbc
 8004824:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004828:	681b      	ldr	r3, [r3, #0]
 800482a:	f103 0201 	add.w	r2, r3, #1
 800482e:	f640 53bc 	movw	r3, #3516	; 0xdbc
 8004832:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004836:	601a      	str	r2, [r3, #0]
 8004838:	f640 53bc 	movw	r3, #3516	; 0xdbc
 800483c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004840:	681b      	ldr	r3, [r3, #0]
 8004842:	2b13      	cmp	r3, #19
 8004844:	ddd8      	ble.n	80047f8 <SLTHA001_lFindAvailableSlot+0x30>
 8004846:	e000      	b.n	800484a <SLTHA001_lFindAvailableSlot+0x82>
    {
      if(FileHandle[Slot].Fd == FileDesc)
      break;
 8004848:	bf00      	nop
    }
    /* Save the last Allocated File Handle.*/
    LastAllocFileHandle = FileDesc;
 800484a:	f246 63c0 	movw	r3, #26304	; 0x66c0
 800484e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004852:	687a      	ldr	r2, [r7, #4]
 8004854:	601a      	str	r2, [r3, #0]
 8004856:	e000      	b.n	800485a <SLTHA001_lFindAvailableSlot+0x92>
  {
/* <<<DD_SLTHA001_nonAPI_1_1>>> */
    /* Check if the File handle is the last allocated one */
    if( (FileDesc != -1)  && (FileDesc == LastAllocFileHandle))
    {
      break;
 8004858:	bf00      	nop
      break;
    }
    /* Save the last Allocated File Handle.*/
    LastAllocFileHandle = FileDesc;
  } while(0);
  return Slot;
 800485a:	f640 53bc 	movw	r3, #3516	; 0xdbc
 800485e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004862:	681b      	ldr	r3, [r3, #0]
}
 8004864:	4618      	mov	r0, r3
 8004866:	f107 070c 	add.w	r7, r7, #12
 800486a:	46bd      	mov	sp, r7
 800486c:	bc80      	pop	{r7}
 800486e:	4770      	bx	lr

08004870 <SLTHA001_lLocalInitialize>:
/*
 * Function to Initialize all the local variables and file descriptors. This function should be
 * called very first .
 */
void SLTHA001_lLocalInitialize()
{
 8004870:	b480      	push	{r7}
 8004872:	b083      	sub	sp, #12
 8004874:	af00      	add	r7, sp, #0
  int Slot;
/* Initialize Handle in the FileHandle Structure to -1*/
  for(Slot=0; Slot<MAX_OPEN_FILES; Slot++)
 8004876:	f04f 0300 	mov.w	r3, #0
 800487a:	607b      	str	r3, [r7, #4]
 800487c:	e012      	b.n	80048a4 <SLTHA001_lLocalInitialize+0x34>
  {
    FileHandle[Slot].Fd = -1;
 800487e:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004882:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004886:	6879      	ldr	r1, [r7, #4]
 8004888:	460b      	mov	r3, r1
 800488a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800488e:	185b      	adds	r3, r3, r1
 8004890:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004894:	18d3      	adds	r3, r2, r3
 8004896:	f04f 32ff 	mov.w	r2, #4294967295
 800489a:	601a      	str	r2, [r3, #0]
 */
void SLTHA001_lLocalInitialize()
{
  int Slot;
/* Initialize Handle in the FileHandle Structure to -1*/
  for(Slot=0; Slot<MAX_OPEN_FILES; Slot++)
 800489c:	687b      	ldr	r3, [r7, #4]
 800489e:	f103 0301 	add.w	r3, r3, #1
 80048a2:	607b      	str	r3, [r7, #4]
 80048a4:	687b      	ldr	r3, [r7, #4]
 80048a6:	2b13      	cmp	r3, #19
 80048a8:	dde9      	ble.n	800487e <SLTHA001_lLocalInitialize+0xe>
  {
    FileHandle[Slot].Fd = -1;
  }
/* Preserve the 0th, 1th and 2nd File Handles for Standard I/O and Error.*/
  FileHandle [0].Fd = STDIN_HANDLE;
 80048aa:	f640 432c 	movw	r3, #3116	; 0xc2c
 80048ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048b2:	f04f 0200 	mov.w	r2, #0
 80048b6:	601a      	str	r2, [r3, #0]
  FileHandle [1].Fd = STDOUT_HANDLE;
 80048b8:	f640 432c 	movw	r3, #3116	; 0xc2c
 80048bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048c0:	f04f 0201 	mov.w	r2, #1
 80048c4:	615a      	str	r2, [r3, #20]
  FileHandle [2].Fd = STDERR_HANDLE;
 80048c6:	f640 432c 	movw	r3, #3116	; 0xc2c
 80048ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048ce:	f04f 0202 	mov.w	r2, #2
 80048d2:	629a      	str	r2, [r3, #40]	; 0x28
}
 80048d4:	f107 070c 	add.w	r7, r7, #12
 80048d8:	46bd      	mov	sp, r7
 80048da:	bc80      	pop	{r7}
 80048dc:	4770      	bx	lr
 80048de:	bf00      	nop

080048e0 <SLTHA001_lTimeFormat>:
/* <<<DD_SLTHA001_nonAPI_4>>> */
/*
 * This function converts the time format 
 */
static time_t SLTHA001_lTimeFormat(FILINFO *FatFsInfoPtr)
{
 80048e0:	b580      	push	{r7, lr}
 80048e2:	b08c      	sub	sp, #48	; 0x30
 80048e4:	af00      	add	r7, sp, #0
 80048e6:	6078      	str	r0, [r7, #4]
  struct tm TimeStruct;
  TimeStruct.tm_sec  = (FatFsInfoPtr->ftime & 0x001f) << 1;
 80048e8:	687b      	ldr	r3, [r7, #4]
 80048ea:	88db      	ldrh	r3, [r3, #6]
 80048ec:	f003 031f 	and.w	r3, r3, #31
 80048f0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80048f4:	60fb      	str	r3, [r7, #12]
  TimeStruct.tm_min  = (FatFsInfoPtr->ftime & 0x07e0) >> 5;
 80048f6:	687b      	ldr	r3, [r7, #4]
 80048f8:	88db      	ldrh	r3, [r3, #6]
 80048fa:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
 80048fe:	ea4f 1363 	mov.w	r3, r3, asr #5
 8004902:	613b      	str	r3, [r7, #16]
  TimeStruct.tm_hour = (FatFsInfoPtr->ftime & 0xf800) >> 11;
 8004904:	687b      	ldr	r3, [r7, #4]
 8004906:	88db      	ldrh	r3, [r3, #6]
 8004908:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 800490c:	b29b      	uxth	r3, r3
 800490e:	617b      	str	r3, [r7, #20]
  TimeStruct.tm_mday = (FatFsInfoPtr->fdate & 0x001f);
 8004910:	687b      	ldr	r3, [r7, #4]
 8004912:	889b      	ldrh	r3, [r3, #4]
 8004914:	f003 031f 	and.w	r3, r3, #31
 8004918:	61bb      	str	r3, [r7, #24]
  TimeStruct.tm_mon  = ((FatFsInfoPtr->fdate & 0x01e0) >> 5) - 1;
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	889b      	ldrh	r3, [r3, #4]
 800491e:	f403 73f0 	and.w	r3, r3, #480	; 0x1e0
 8004922:	ea4f 1363 	mov.w	r3, r3, asr #5
 8004926:	f103 33ff 	add.w	r3, r3, #4294967295
 800492a:	61fb      	str	r3, [r7, #28]
  TimeStruct.tm_year = ((FatFsInfoPtr->fdate & 0xfe00) >> 9) + 80;
 800492c:	687b      	ldr	r3, [r7, #4]
 800492e:	889b      	ldrh	r3, [r3, #4]
 8004930:	ea4f 2353 	mov.w	r3, r3, lsr #9
 8004934:	b29b      	uxth	r3, r3
 8004936:	f103 0350 	add.w	r3, r3, #80	; 0x50
 800493a:	623b      	str	r3, [r7, #32]
  TimeStruct.tm_isdst = 0;
 800493c:	f04f 0300 	mov.w	r3, #0
 8004940:	62fb      	str	r3, [r7, #44]	; 0x2c
  return mktime(&TimeStruct);
 8004942:	f107 030c 	add.w	r3, r7, #12
 8004946:	4618      	mov	r0, r3
 8004948:	f01f f96e 	bl	8023c28 <mktime>
 800494c:	4603      	mov	r3, r0
}
 800494e:	4618      	mov	r0, r3
 8004950:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8004954:	46bd      	mov	sp, r7
 8004956:	bd80      	pop	{r7, pc}

08004958 <SLTHA001_lFatInfoToStatus>:
 *  Function to store the file information in the file status pointer 
 */
#if defined (__GNUC__) || defined ( __TASKING__)
static void SLTHA001_lFatInfoToStatus(struct stat *FileStatusPtr, \
                                      FILINFO *FatFsInfoPtr)
{
 8004958:	b580      	push	{r7, lr}
 800495a:	b082      	sub	sp, #8
 800495c:	af00      	add	r7, sp, #0
 800495e:	6078      	str	r0, [r7, #4]
 8004960:	6039      	str	r1, [r7, #0]
  memset(FileStatusPtr, 0, sizeof(*FileStatusPtr));
 8004962:	6878      	ldr	r0, [r7, #4]
 8004964:	f04f 0100 	mov.w	r1, #0
 8004968:	f04f 023c 	mov.w	r2, #60	; 0x3c
 800496c:	f01e ffc0 	bl	80238f0 <memset>
  /*Populate the Argument Status Pointer with the Fat FS status Pointer*/
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_DIR) ? \
 8004970:	687b      	ldr	r3, [r7, #4]
 8004972:	685a      	ldr	r2, [r3, #4]
 8004974:	683b      	ldr	r3, [r7, #0]
 8004976:	7a1b      	ldrb	r3, [r3, #8]
 8004978:	f003 0310 	and.w	r3, r3, #16
 800497c:	2b00      	cmp	r3, #0
 800497e:	d002      	beq.n	8004986 <SLTHA001_lFatInfoToStatus+0x2e>
 8004980:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8004984:	e001      	b.n	800498a <SLTHA001_lFatInfoToStatus+0x32>
 8004986:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800498a:	431a      	orrs	r2, r3
 800498c:	687b      	ldr	r3, [r7, #4]
 800498e:	605a      	str	r2, [r3, #4]
                                                            S_IFDIR : S_IFREG;
  
#if defined (__GNUC__)
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ? \
 8004990:	687b      	ldr	r3, [r7, #4]
 8004992:	685a      	ldr	r2, [r3, #4]
 8004994:	683b      	ldr	r3, [r7, #0]
 8004996:	7a1b      	ldrb	r3, [r3, #8]
 8004998:	f003 0301 	and.w	r3, r3, #1
 800499c:	2b00      	cmp	r3, #0
 800499e:	d002      	beq.n	80049a6 <SLTHA001_lFatInfoToStatus+0x4e>
 80049a0:	f240 136d 	movw	r3, #365	; 0x16d
 80049a4:	e001      	b.n	80049aa <SLTHA001_lFatInfoToStatus+0x52>
 80049a6:	f240 13ff 	movw	r3, #511	; 0x1ff
 80049aa:	431a      	orrs	r2, r3
 80049ac:	687b      	ldr	r3, [r7, #4]
 80049ae:	605a      	str	r2, [r3, #4]

  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ? \
                                                    (~_S_IWRITE)  : \
                                                    (_S_IWRITE);
#endif
  FileStatusPtr->st_size = FatFsInfoPtr->fsize;
 80049b0:	683b      	ldr	r3, [r7, #0]
 80049b2:	681b      	ldr	r3, [r3, #0]
 80049b4:	461a      	mov	r2, r3
 80049b6:	687b      	ldr	r3, [r7, #4]
 80049b8:	611a      	str	r2, [r3, #16]
  FileStatusPtr->st_ctime = SLTHA001_lTimeFormat(FatFsInfoPtr);
 80049ba:	6838      	ldr	r0, [r7, #0]
 80049bc:	f7ff ff90 	bl	80048e0 <SLTHA001_lTimeFormat>
 80049c0:	4602      	mov	r2, r0
 80049c2:	687b      	ldr	r3, [r7, #4]
 80049c4:	625a      	str	r2, [r3, #36]	; 0x24
  FileStatusPtr->st_mtime = FileStatusPtr->st_ctime;
 80049c6:	687b      	ldr	r3, [r7, #4]
 80049c8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80049ca:	687b      	ldr	r3, [r7, #4]
 80049cc:	61da      	str	r2, [r3, #28]
  FileStatusPtr->st_atime = FileStatusPtr->st_ctime;
 80049ce:	687b      	ldr	r3, [r7, #4]
 80049d0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80049d2:	687b      	ldr	r3, [r7, #4]
 80049d4:	615a      	str	r2, [r3, #20]
#if defined (__GNUC__)
  FileStatusPtr->st_blksize = 512;
 80049d6:	687b      	ldr	r3, [r7, #4]
 80049d8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80049dc:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
}
 80049de:	f107 0708 	add.w	r7, r7, #8
 80049e2:	46bd      	mov	sp, r7
 80049e4:	bd80      	pop	{r7, pc}
 80049e6:	bf00      	nop

080049e8 <SLTHA001_lSetFlagsAccessModes>:
                                            BYTE *FatFsFlagPtr )
#else
  static status_t SLTHA001_lSetFlagsAccessModes( int *FlagsPtr, \
                                                 BYTE *FatFsFlagPtr )
#endif
{
 80049e8:	b580      	push	{r7, lr}
 80049ea:	b084      	sub	sp, #16
 80049ec:	af00      	add	r7, sp, #0
 80049ee:	6078      	str	r0, [r7, #4]
 80049f0:	6039      	str	r1, [r7, #0]
#ifdef  __TASKING__
  _err_t Status = FILE_WRAPPER_ERROR;
#else
  int Status = FILE_WRAPPER_ERROR;
 80049f2:	f04f 33ff 	mov.w	r3, #4294967295
 80049f6:	60fb      	str	r3, [r7, #12]
  do
  {
#if defined(__GNUC__) || defined( __TASKING__) || defined(__ICCARM__ )
/*<<<DD_SLTHA001_nonAPI_6_1>>> */
     /*  Append and Truncate flags cannot be set together */
    if (*FlagsPtr & SLTHA001_APPEND)
 80049f8:	687b      	ldr	r3, [r7, #4]
 80049fa:	681b      	ldr	r3, [r3, #0]
 80049fc:	f003 0308 	and.w	r3, r3, #8
 8004a00:	2b00      	cmp	r3, #0
 8004a02:	d005      	beq.n	8004a10 <SLTHA001_lSetFlagsAccessModes+0x28>
    {
      *FlagsPtr &= ~SLTHA001_TRUNC ;
 8004a04:	687b      	ldr	r3, [r7, #4]
 8004a06:	681b      	ldr	r3, [r3, #0]
 8004a08:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8004a0c:	687b      	ldr	r3, [r7, #4]
 8004a0e:	601a      	str	r2, [r3, #0]
    }
/*<<<DD_SLTHA001_nonAPI_6_2>>> */
    /* Create & Truncate & Access mode is Write */
    if ( ((*FlagsPtr & (SLTHA001_CREAT | SLTHA001_TRUNC)) ==
 8004a10:	687b      	ldr	r3, [r7, #4]
 8004a12:	681b      	ldr	r3, [r3, #0]
 8004a14:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8004a18:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8004a1c:	d10a      	bne.n	8004a34 <SLTHA001_lSetFlagsAccessModes+0x4c>
         (SLTHA001_CREAT | SLTHA001_TRUNC)) && (*FlagsPtr & (SLTHA001_RDWR | \
 8004a1e:	687b      	ldr	r3, [r7, #4]
 8004a20:	681b      	ldr	r3, [r3, #0]
 8004a22:	f003 0303 	and.w	r3, r3, #3
 8004a26:	2b00      	cmp	r3, #0
 8004a28:	d004      	beq.n	8004a34 <SLTHA001_lSetFlagsAccessModes+0x4c>
                                                             SLTHA001_WRONLY)))
    {
#if _FS_READONLY
      break;
#else
      *FatFsFlagPtr = FA_CREATE_ALWAYS;
 8004a2a:	683b      	ldr	r3, [r7, #0]
 8004a2c:	f04f 0208 	mov.w	r2, #8
 8004a30:	701a      	strb	r2, [r3, #0]
 8004a32:	e02e      	b.n	8004a92 <SLTHA001_lSetFlagsAccessModes+0xaa>
#endif
    }
    /* O_EXCL  When used with O_CREAT, if the file already exists it is an error
    *  and the open() will fail. */
/*<<<DD_SLTHA001_nonAPI_6_3>>> */
    else if ((*FlagsPtr & (SLTHA001_CREAT | SLTHA001_EXCL)) ==
 8004a34:	687b      	ldr	r3, [r7, #4]
 8004a36:	681b      	ldr	r3, [r3, #0]
 8004a38:	f403 6320 	and.w	r3, r3, #2560	; 0xa00
 8004a3c:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
 8004a40:	d104      	bne.n	8004a4c <SLTHA001_lSetFlagsAccessModes+0x64>
                          (SLTHA001_CREAT | SLTHA001_EXCL))
    {
      *FatFsFlagPtr = FA_OPEN_EXISTING;
 8004a42:	683b      	ldr	r3, [r7, #0]
 8004a44:	f04f 0200 	mov.w	r2, #0
 8004a48:	701a      	strb	r2, [r3, #0]
 8004a4a:	e022      	b.n	8004a92 <SLTHA001_lSetFlagsAccessModes+0xaa>
    }
/*<<<DD_SLTHA001_nonAPI_6_4>>> */
    /* Only create flag is set, opens the file if exist else creates a new file */
    else if ((*FlagsPtr & SLTHA001_CREAT) == SLTHA001_CREAT)
 8004a4c:	687b      	ldr	r3, [r7, #4]
 8004a4e:	681b      	ldr	r3, [r3, #0]
 8004a50:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004a54:	2b00      	cmp	r3, #0
 8004a56:	d004      	beq.n	8004a62 <SLTHA001_lSetFlagsAccessModes+0x7a>
    {
#if _FS_READONLY
       break;
#else
      *FatFsFlagPtr = FA_OPEN_ALWAYS;
 8004a58:	683b      	ldr	r3, [r7, #0]
 8004a5a:	f04f 0210 	mov.w	r2, #16
 8004a5e:	701a      	strb	r2, [r3, #0]
 8004a60:	e017      	b.n	8004a92 <SLTHA001_lSetFlagsAccessModes+0xaa>
#endif
    }
/*<<<DD_SLTHA001_nonAPI_6_5>>> */
    /* Opens the file if any of the read, write or r/w flags are only set*/
    else if ((*FlagsPtr == SLTHA001_RDONLY) || (*FlagsPtr == SLTHA001_WRONLY)
 8004a62:	687b      	ldr	r3, [r7, #4]
 8004a64:	681b      	ldr	r3, [r3, #0]
 8004a66:	2b00      	cmp	r3, #0
 8004a68:	d007      	beq.n	8004a7a <SLTHA001_lSetFlagsAccessModes+0x92>
 8004a6a:	687b      	ldr	r3, [r7, #4]
 8004a6c:	681b      	ldr	r3, [r3, #0]
 8004a6e:	2b01      	cmp	r3, #1
 8004a70:	d003      	beq.n	8004a7a <SLTHA001_lSetFlagsAccessModes+0x92>
                                            || (*FlagsPtr == SLTHA001_RDWR))
 8004a72:	687b      	ldr	r3, [r7, #4]
 8004a74:	681b      	ldr	r3, [r3, #0]
 8004a76:	2b02      	cmp	r3, #2
 8004a78:	d104      	bne.n	8004a84 <SLTHA001_lSetFlagsAccessModes+0x9c>
    {
      *FatFsFlagPtr = FA_OPEN_EXISTING;
 8004a7a:	683b      	ldr	r3, [r7, #0]
 8004a7c:	f04f 0200 	mov.w	r2, #0
 8004a80:	701a      	strb	r2, [r3, #0]
 8004a82:	e006      	b.n	8004a92 <SLTHA001_lSetFlagsAccessModes+0xaa>
    }
/*<<<DD_SLTHA001_nonAPI_6_6>>> */
    else
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EINVAL;
 8004a84:	f01d ff64 	bl	8022950 <__errno>
 8004a88:	4603      	mov	r3, r0
 8004a8a:	f04f 0216 	mov.w	r2, #22
 8004a8e:	601a      	str	r2, [r3, #0]
#elif defined( __ICCARM__)                              
      errno = _LLIO_ERROR;
#endif
      break;
 8004a90:	e033      	b.n	8004afa <SLTHA001_lSetFlagsAccessModes+0x112>
    }
#endif
/*<<<DD_SLTHA001_nonAPI_6_7>>> */
    /* Check the access mode */
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    if ((*FlagsPtr & SLTHA001_RDWRMASK) == SLTHA001_RDONLY)
 8004a92:	687b      	ldr	r3, [r7, #4]
 8004a94:	681b      	ldr	r3, [r3, #0]
 8004a96:	f003 0303 	and.w	r3, r3, #3
 8004a9a:	2b00      	cmp	r3, #0
 8004a9c:	d107      	bne.n	8004aae <SLTHA001_lSetFlagsAccessModes+0xc6>
#elif defined __CC_ARM
    if (*FlagsPtr &  SLTHA001_RDONLY)
#endif
    {
      *FatFsFlagPtr |= FA_READ;
 8004a9e:	683b      	ldr	r3, [r7, #0]
 8004aa0:	781b      	ldrb	r3, [r3, #0]
 8004aa2:	f043 0301 	orr.w	r3, r3, #1
 8004aa6:	b2da      	uxtb	r2, r3
 8004aa8:	683b      	ldr	r3, [r7, #0]
 8004aaa:	701a      	strb	r2, [r3, #0]
 8004aac:	e022      	b.n	8004af4 <SLTHA001_lSetFlagsAccessModes+0x10c>
    }
/*<<<DD_SLTHA001_nonAPI_6_8>>> */
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    else if ((*FlagsPtr & SLTHA001_RDWRMASK) == SLTHA001_WRONLY)
 8004aae:	687b      	ldr	r3, [r7, #4]
 8004ab0:	681b      	ldr	r3, [r3, #0]
 8004ab2:	f003 0303 	and.w	r3, r3, #3
 8004ab6:	2b01      	cmp	r3, #1
 8004ab8:	d107      	bne.n	8004aca <SLTHA001_lSetFlagsAccessModes+0xe2>
#endif
    {
#if _FS_READONLY
      break;
#else
      *FatFsFlagPtr |= FA_WRITE;
 8004aba:	683b      	ldr	r3, [r7, #0]
 8004abc:	781b      	ldrb	r3, [r3, #0]
 8004abe:	f043 0302 	orr.w	r3, r3, #2
 8004ac2:	b2da      	uxtb	r2, r3
 8004ac4:	683b      	ldr	r3, [r7, #0]
 8004ac6:	701a      	strb	r2, [r3, #0]
 8004ac8:	e014      	b.n	8004af4 <SLTHA001_lSetFlagsAccessModes+0x10c>
#endif
    }
/*<<<DD_SLTHA001_nonAPI_6_9>>> */
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    else if ((*FlagsPtr & SLTHA001_RDWRMASK) == SLTHA001_RDWR)
 8004aca:	687b      	ldr	r3, [r7, #4]
 8004acc:	681b      	ldr	r3, [r3, #0]
 8004ace:	f003 0303 	and.w	r3, r3, #3
 8004ad2:	2b02      	cmp	r3, #2
 8004ad4:	d107      	bne.n	8004ae6 <SLTHA001_lSetFlagsAccessModes+0xfe>
#endif
    {
#if _FS_READONLY
      break;
#else
      *FatFsFlagPtr |= (FA_READ | FA_WRITE);
 8004ad6:	683b      	ldr	r3, [r7, #0]
 8004ad8:	781b      	ldrb	r3, [r3, #0]
 8004ada:	f043 0303 	orr.w	r3, r3, #3
 8004ade:	b2da      	uxtb	r2, r3
 8004ae0:	683b      	ldr	r3, [r7, #0]
 8004ae2:	701a      	strb	r2, [r3, #0]
 8004ae4:	e006      	b.n	8004af4 <SLTHA001_lSetFlagsAccessModes+0x10c>
    }
/*<<<DD_SLTHA001_nonAPI_6_10>>> */
    else
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EINVAL;
 8004ae6:	f01d ff33 	bl	8022950 <__errno>
 8004aea:	4603      	mov	r3, r0
 8004aec:	f04f 0216 	mov.w	r2, #22
 8004af0:	601a      	str	r2, [r3, #0]
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#elif defined __CC_ARM
      errno = EINVAL;
#endif
      break;
 8004af2:	e002      	b.n	8004afa <SLTHA001_lSetFlagsAccessModes+0x112>
    }
    Status = DAVEApp_SUCCESS;
 8004af4:	f04f 0300 	mov.w	r3, #0
 8004af8:	60fb      	str	r3, [r7, #12]
  } while(0);
  return Status;
 8004afa:	68fb      	ldr	r3, [r7, #12]
}
 8004afc:	4618      	mov	r0, r3
 8004afe:	f107 0710 	add.w	r7, r7, #16
 8004b02:	46bd      	mov	sp, r7
 8004b04:	bd80      	pop	{r7, pc}
 8004b06:	bf00      	nop

08004b08 <_open>:
(
  const char * Path,
  int Flags
)
#endif
{
 8004b08:	b40e      	push	{r1, r2, r3}
 8004b0a:	b580      	push	{r7, lr}
 8004b0c:	b089      	sub	sp, #36	; 0x24
 8004b0e:	af00      	add	r7, sp, #0
 8004b10:	6078      	str	r0, [r7, #4]
#ifdef  __TASKING__
  _err_t Status = FILE_WRAPPER_ERROR;
  _err_t FileDesc = 0;
#else
  int Status = FILE_WRAPPER_ERROR;
 8004b12:	f04f 33ff 	mov.w	r3, #4294967295
 8004b16:	61bb      	str	r3, [r7, #24]
  int FileDesc = 0;
 8004b18:	f04f 0300 	mov.w	r3, #0
 8004b1c:	61fb      	str	r3, [r7, #28]
#endif
  int  SlotNumber;
  uint32_t PathLen = 0;
 8004b1e:	f04f 0300 	mov.w	r3, #0
 8004b22:	617b      	str	r3, [r7, #20]
  BYTE FatFsFlags = FA_OPEN_EXISTING;
 8004b24:	f04f 0300 	mov.w	r3, #0
 8004b28:	73bb      	strb	r3, [r7, #14]
  FRESULT Result;
  do
  {
/* <<<DD_SLTHA001_API_1_1>>> */
/*  Check free slot is available to open the file. If not then return error. */
    SlotNumber = SLTHA001_lFindAvailableSlot(EMPTY_SLOT);
 8004b2a:	f04f 30ff 	mov.w	r0, #4294967295
 8004b2e:	f7ff fe4b 	bl	80047c8 <SLTHA001_lFindAvailableSlot>
 8004b32:	4603      	mov	r3, r0
 8004b34:	613b      	str	r3, [r7, #16]
    if (SlotNumber == MAX_OPEN_FILES)
 8004b36:	693b      	ldr	r3, [r7, #16]
 8004b38:	2b14      	cmp	r3, #20
 8004b3a:	d106      	bne.n	8004b4a <_open+0x42>
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = ENFILE;
 8004b3c:	f01d ff08 	bl	8022950 <__errno>
 8004b40:	4603      	mov	r3, r0
 8004b42:	f04f 0217 	mov.w	r2, #23
 8004b46:	601a      	str	r2, [r3, #0]
#elif defined __CC_ARM
      errno =  EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
 8004b48:	e147      	b.n	8004dda <_open+0x2d2>
    }/* End of "if (SlotNumber == MAX_OPEN_FILES)"*/
    
    /* Check the file path name should not exceed the maximum value*/
    PathLen = strlen(Path);
 8004b4a:	6878      	ldr	r0, [r7, #4]
 8004b4c:	f01f fff8 	bl	8024b40 <strlen>
 8004b50:	6178      	str	r0, [r7, #20]
    if (PathLen > FILENAME_MAX )
 8004b52:	697b      	ldr	r3, [r7, #20]
 8004b54:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8004b58:	f200 813c 	bhi.w	8004dd4 <_open+0x2cc>
    {
      break;
    }
/* <<<DD_SLTHA001_API_1_2>>> */
/* Check and Set Flags Accordingly */
    Status = SLTHA001_lSetFlagsAccessModes(&Flags,&FatFsFlags);
 8004b5c:	f107 030e 	add.w	r3, r7, #14
 8004b60:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8004b64:	4619      	mov	r1, r3
 8004b66:	f7ff ff3f 	bl	80049e8 <SLTHA001_lSetFlagsAccessModes>
 8004b6a:	4603      	mov	r3, r0
 8004b6c:	61bb      	str	r3, [r7, #24]
    if( Status != DAVEApp_SUCCESS)
 8004b6e:	69bb      	ldr	r3, [r7, #24]
 8004b70:	2b00      	cmp	r3, #0
 8004b72:	d003      	beq.n	8004b7c <_open+0x74>
    {
      FileDesc = -1;
 8004b74:	f04f 33ff 	mov.w	r3, #4294967295
 8004b78:	61fb      	str	r3, [r7, #28]
      break;
 8004b7a:	e12e      	b.n	8004dda <_open+0x2d2>
    } /* End of "if ( Status != DAVEApp_SUCCESS))"*/
    /* Allocate memory to store the file path name.*/
    FileHandle[SlotNumber].FilePath = (char *)malloc(PathLen+1);
 8004b7c:	697b      	ldr	r3, [r7, #20]
 8004b7e:	f103 0301 	add.w	r3, r3, #1
 8004b82:	4618      	mov	r0, r3
 8004b84:	f01e fd36 	bl	80235f4 <malloc>
 8004b88:	4603      	mov	r3, r0
 8004b8a:	4618      	mov	r0, r3
 8004b8c:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004b90:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004b94:	6939      	ldr	r1, [r7, #16]
 8004b96:	460b      	mov	r3, r1
 8004b98:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004b9c:	185b      	adds	r3, r3, r1
 8004b9e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004ba2:	18d3      	adds	r3, r2, r3
 8004ba4:	f103 0310 	add.w	r3, r3, #16
 8004ba8:	6018      	str	r0, [r3, #0]
    if( FileHandle[SlotNumber].FilePath  == NULL )
 8004baa:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004bae:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004bb2:	6939      	ldr	r1, [r7, #16]
 8004bb4:	460b      	mov	r3, r1
 8004bb6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004bba:	185b      	adds	r3, r3, r1
 8004bbc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004bc0:	18d3      	adds	r3, r2, r3
 8004bc2:	f103 0310 	add.w	r3, r3, #16
 8004bc6:	681b      	ldr	r3, [r3, #0]
 8004bc8:	2b00      	cmp	r3, #0
 8004bca:	f000 8105 	beq.w	8004dd8 <_open+0x2d0>
    {
      break;
    }
    /* Store the file path name */
    strcpy(FileHandle[SlotNumber].FilePath ,Path);
 8004bce:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004bd2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004bd6:	6939      	ldr	r1, [r7, #16]
 8004bd8:	460b      	mov	r3, r1
 8004bda:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004bde:	185b      	adds	r3, r3, r1
 8004be0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004be4:	18d3      	adds	r3, r2, r3
 8004be6:	f103 0310 	add.w	r3, r3, #16
 8004bea:	681b      	ldr	r3, [r3, #0]
 8004bec:	4618      	mov	r0, r3
 8004bee:	6879      	ldr	r1, [r7, #4]
 8004bf0:	f01f ff48 	bl	8024a84 <strcpy>
/* Set File Handle to -1 and error no variable to default EIO */
    FileDesc = -1;
 8004bf4:	f04f 33ff 	mov.w	r3, #4294967295
 8004bf8:	61fb      	str	r3, [r7, #28]
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EIO;
 8004bfa:	f01d fea9 	bl	8022950 <__errno>
 8004bfe:	4603      	mov	r3, r0
 8004c00:	f04f 0205 	mov.w	r2, #5
 8004c04:	601a      	str	r2, [r3, #0]
#elif  __ICCARM__
    errno = _LLIO_ERROR;
#endif
/* <<<DD_SLTHA001_API_1_3>>> */
    /* If File Pointer is NULL, then allocate the memory to open a file  */
    if (FileHandle[SlotNumber].FatFsPtr == NULL)
 8004c06:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004c0a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004c0e:	6939      	ldr	r1, [r7, #16]
 8004c10:	460b      	mov	r3, r1
 8004c12:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c16:	185b      	adds	r3, r3, r1
 8004c18:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c1c:	18d3      	adds	r3, r2, r3
 8004c1e:	f103 030c 	add.w	r3, r3, #12
 8004c22:	681b      	ldr	r3, [r3, #0]
 8004c24:	2b00      	cmp	r3, #0
 8004c26:	d12b      	bne.n	8004c80 <_open+0x178>
    {
      FileHandle[SlotNumber].FatFsPtr = (FIL *)calloc(1, sizeof(FIL));
 8004c28:	f04f 0001 	mov.w	r0, #1
 8004c2c:	f44f 7109 	mov.w	r1, #548	; 0x224
 8004c30:	f01d fe82 	bl	8022938 <calloc>
 8004c34:	4603      	mov	r3, r0
 8004c36:	4618      	mov	r0, r3
 8004c38:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004c3c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004c40:	6939      	ldr	r1, [r7, #16]
 8004c42:	460b      	mov	r3, r1
 8004c44:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c48:	185b      	adds	r3, r3, r1
 8004c4a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c4e:	18d3      	adds	r3, r2, r3
 8004c50:	f103 030c 	add.w	r3, r3, #12
 8004c54:	6018      	str	r0, [r3, #0]
/* <<<DD_SLTHA001_API_1_4>>> */
      if (FileHandle[SlotNumber].FatFsPtr == NULL)
 8004c56:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004c5a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004c5e:	6939      	ldr	r1, [r7, #16]
 8004c60:	460b      	mov	r3, r1
 8004c62:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c66:	185b      	adds	r3, r3, r1
 8004c68:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c6c:	18d3      	adds	r3, r2, r3
 8004c6e:	f103 030c 	add.w	r3, r3, #12
 8004c72:	681b      	ldr	r3, [r3, #0]
 8004c74:	2b00      	cmp	r3, #0
 8004c76:	d103      	bne.n	8004c80 <_open+0x178>
      {
        Status = FILE_WRAPPER_ERROR;
 8004c78:	f04f 33ff 	mov.w	r3, #4294967295
 8004c7c:	61bb      	str	r3, [r7, #24]
        break;
 8004c7e:	e0ac      	b.n	8004dda <_open+0x2d2>
      } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL))"*/
    } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL)"*/
/* Call the f_open function */
   Result = f_open(FileHandle[SlotNumber].FatFsPtr,Path,FatFsFlags);
 8004c80:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004c84:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004c88:	6939      	ldr	r1, [r7, #16]
 8004c8a:	460b      	mov	r3, r1
 8004c8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c90:	185b      	adds	r3, r3, r1
 8004c92:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004c96:	18d3      	adds	r3, r2, r3
 8004c98:	f103 030c 	add.w	r3, r3, #12
 8004c9c:	681a      	ldr	r2, [r3, #0]
 8004c9e:	7bbb      	ldrb	r3, [r7, #14]
 8004ca0:	4610      	mov	r0, r2
 8004ca2:	6879      	ldr	r1, [r7, #4]
 8004ca4:	461a      	mov	r2, r3
 8004ca6:	f008 fa13 	bl	800d0d0 <f_open>
 8004caa:	4603      	mov	r3, r0
 8004cac:	73fb      	strb	r3, [r7, #15]
/* <<<DD_SLTHA001_API_1_5>>> */
   if( Result != FR_OK)
 8004cae:	7bfb      	ldrb	r3, [r7, #15]
 8004cb0:	2b00      	cmp	r3, #0
 8004cb2:	d00b      	beq.n	8004ccc <_open+0x1c4>
   {
     errno = ErrorCodes[ Result];
 8004cb4:	f01d fe4c 	bl	8022950 <__errno>
 8004cb8:	4602      	mov	r2, r0
 8004cba:	7bf9      	ldrb	r1, [r7, #15]
 8004cbc:	f246 6374 	movw	r3, #26228	; 0x6674
 8004cc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cc4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8004cc8:	6013      	str	r3, [r2, #0]
     break;
 8004cca:	e086      	b.n	8004dda <_open+0x2d2>
   } /* End of "if( Result != FR_OK)"*/
   FileDesc = SlotNumber + MONITOR_FATFS;
 8004ccc:	693b      	ldr	r3, [r7, #16]
 8004cce:	f103 0303 	add.w	r3, r3, #3
 8004cd2:	61fb      	str	r3, [r7, #28]
   FileHandle[SlotNumber].Fd = FileDesc;
 8004cd4:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004cd8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004cdc:	6939      	ldr	r1, [r7, #16]
 8004cde:	460b      	mov	r3, r1
 8004ce0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004ce4:	185b      	adds	r3, r3, r1
 8004ce6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004cea:	18d3      	adds	r3, r2, r3
 8004cec:	69fa      	ldr	r2, [r7, #28]
 8004cee:	601a      	str	r2, [r3, #0]
   FileHandle[SlotNumber].Flags = Flags;
 8004cf0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004cf2:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004cf6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004cfa:	6939      	ldr	r1, [r7, #16]
 8004cfc:	460b      	mov	r3, r1
 8004cfe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d02:	185b      	adds	r3, r3, r1
 8004d04:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d08:	18d3      	adds	r3, r2, r3
 8004d0a:	f103 0308 	add.w	r3, r3, #8
 8004d0e:	6018      	str	r0, [r3, #0]
   FileHandle[SlotNumber].CurrentPos = 0;
 8004d10:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004d14:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004d18:	6939      	ldr	r1, [r7, #16]
 8004d1a:	460b      	mov	r3, r1
 8004d1c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d20:	185b      	adds	r3, r3, r1
 8004d22:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d26:	18d3      	adds	r3, r2, r3
 8004d28:	f103 0304 	add.w	r3, r3, #4
 8004d2c:	f04f 0200 	mov.w	r2, #0
 8004d30:	601a      	str	r2, [r3, #0]
/* <<<DD_SLTHA001_API_1_6>>> */
/* if Append flag set, Get the end position by using FatFS lseek function */
   if (Flags & SLTHA001_APPEND)
 8004d32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004d34:	f003 0308 	and.w	r3, r3, #8
 8004d38:	2b00      	cmp	r3, #0
 8004d3a:	d04e      	beq.n	8004dda <_open+0x2d2>
   {
#if _FS_MINIMIZE == 3
     Result = FR_DENIED;
#else
     Result = f_lseek( FileHandle[SlotNumber].FatFsPtr, \
 8004d3c:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004d40:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004d44:	6939      	ldr	r1, [r7, #16]
 8004d46:	460b      	mov	r3, r1
 8004d48:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d4c:	185b      	adds	r3, r3, r1
 8004d4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d52:	18d3      	adds	r3, r2, r3
 8004d54:	f103 030c 	add.w	r3, r3, #12
 8004d58:	6818      	ldr	r0, [r3, #0]
                       FileHandle[SlotNumber].FatFsPtr->fsize );
 8004d5a:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004d5e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004d62:	6939      	ldr	r1, [r7, #16]
 8004d64:	460b      	mov	r3, r1
 8004d66:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d6a:	185b      	adds	r3, r3, r1
 8004d6c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004d70:	18d3      	adds	r3, r2, r3
 8004d72:	f103 030c 	add.w	r3, r3, #12
 8004d76:	681b      	ldr	r3, [r3, #0]
   if (Flags & SLTHA001_APPEND)
   {
#if _FS_MINIMIZE == 3
     Result = FR_DENIED;
#else
     Result = f_lseek( FileHandle[SlotNumber].FatFsPtr, \
 8004d78:	68db      	ldr	r3, [r3, #12]
 8004d7a:	4619      	mov	r1, r3
 8004d7c:	f008 ffec 	bl	800dd58 <f_lseek>
 8004d80:	4603      	mov	r3, r0
 8004d82:	73fb      	strb	r3, [r7, #15]
                       FileHandle[SlotNumber].FatFsPtr->fsize );
#endif
/* <<<DD_SLTHA001_API_1_7>>> */
     if (Result != FR_OK)
 8004d84:	7bfb      	ldrb	r3, [r7, #15]
 8004d86:	2b00      	cmp	r3, #0
 8004d88:	d003      	beq.n	8004d92 <_open+0x28a>
     {
       FileDesc = -1;
 8004d8a:	f04f 33ff 	mov.w	r3, #4294967295
 8004d8e:	61fb      	str	r3, [r7, #28]
       break;
 8004d90:	e023      	b.n	8004dda <_open+0x2d2>
     }/* End of "if( Result != FR_OK)"*/
     FileHandle[SlotNumber].CurrentPos = FileHandle[SlotNumber].FatFsPtr->fptr;
 8004d92:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004d96:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004d9a:	6939      	ldr	r1, [r7, #16]
 8004d9c:	460b      	mov	r3, r1
 8004d9e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004da2:	185b      	adds	r3, r3, r1
 8004da4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004da8:	18d3      	adds	r3, r2, r3
 8004daa:	f103 030c 	add.w	r3, r3, #12
 8004dae:	681b      	ldr	r3, [r3, #0]
 8004db0:	689b      	ldr	r3, [r3, #8]
 8004db2:	4618      	mov	r0, r3
 8004db4:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004db8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004dbc:	6939      	ldr	r1, [r7, #16]
 8004dbe:	460b      	mov	r3, r1
 8004dc0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004dc4:	185b      	adds	r3, r3, r1
 8004dc6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004dca:	18d3      	adds	r3, r2, r3
 8004dcc:	f103 0304 	add.w	r3, r3, #4
 8004dd0:	6018      	str	r0, [r3, #0]
 8004dd2:	e002      	b.n	8004dda <_open+0x2d2>
    
    /* Check the file path name should not exceed the maximum value*/
    PathLen = strlen(Path);
    if (PathLen > FILENAME_MAX )
    {
      break;
 8004dd4:	bf00      	nop
 8004dd6:	e000      	b.n	8004dda <_open+0x2d2>
    } /* End of "if ( Status != DAVEApp_SUCCESS))"*/
    /* Allocate memory to store the file path name.*/
    FileHandle[SlotNumber].FilePath = (char *)malloc(PathLen+1);
    if( FileHandle[SlotNumber].FilePath  == NULL )
    {
      break;
 8004dd8:	bf00      	nop
       break;
     }/* End of "if( Result != FR_OK)"*/
     FileHandle[SlotNumber].CurrentPos = FileHandle[SlotNumber].FatFsPtr->fptr;
   } /* End of "if(Flags & SLTHA001_APPEND)"*/
 } while(0);
  Status = FileDesc;
 8004dda:	69fb      	ldr	r3, [r7, #28]
 8004ddc:	61bb      	str	r3, [r7, #24]
/* <<<DD_SLTHA001_API_1_8>>> */
/* Free the memory if File Handle is -1 and Valid FatFsPtr exists */
 if ((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )
 8004dde:	69fb      	ldr	r3, [r7, #28]
 8004de0:	2b00      	cmp	r3, #0
 8004de2:	da56      	bge.n	8004e92 <_open+0x38a>
 8004de4:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004de8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004dec:	6939      	ldr	r1, [r7, #16]
 8004dee:	460b      	mov	r3, r1
 8004df0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004df4:	185b      	adds	r3, r3, r1
 8004df6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004dfa:	18d3      	adds	r3, r2, r3
 8004dfc:	f103 030c 	add.w	r3, r3, #12
 8004e00:	681b      	ldr	r3, [r3, #0]
 8004e02:	2b00      	cmp	r3, #0
 8004e04:	d045      	beq.n	8004e92 <_open+0x38a>
 {
   free (FileHandle[SlotNumber].FilePath);
 8004e06:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004e0a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004e0e:	6939      	ldr	r1, [r7, #16]
 8004e10:	460b      	mov	r3, r1
 8004e12:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e16:	185b      	adds	r3, r3, r1
 8004e18:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e1c:	18d3      	adds	r3, r2, r3
 8004e1e:	f103 0310 	add.w	r3, r3, #16
 8004e22:	681b      	ldr	r3, [r3, #0]
 8004e24:	4618      	mov	r0, r3
 8004e26:	f01e fbed 	bl	8023604 <free>
   free (FileHandle [SlotNumber].FatFsPtr);
 8004e2a:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004e2e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004e32:	6939      	ldr	r1, [r7, #16]
 8004e34:	460b      	mov	r3, r1
 8004e36:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e3a:	185b      	adds	r3, r3, r1
 8004e3c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e40:	18d3      	adds	r3, r2, r3
 8004e42:	f103 030c 	add.w	r3, r3, #12
 8004e46:	681b      	ldr	r3, [r3, #0]
 8004e48:	4618      	mov	r0, r3
 8004e4a:	f01e fbdb 	bl	8023604 <free>
   FileHandle[SlotNumber].FilePath = NULL;
 8004e4e:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004e52:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004e56:	6939      	ldr	r1, [r7, #16]
 8004e58:	460b      	mov	r3, r1
 8004e5a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e5e:	185b      	adds	r3, r3, r1
 8004e60:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e64:	18d3      	adds	r3, r2, r3
 8004e66:	f103 0310 	add.w	r3, r3, #16
 8004e6a:	f04f 0200 	mov.w	r2, #0
 8004e6e:	601a      	str	r2, [r3, #0]
   FileHandle [SlotNumber].FatFsPtr = NULL;
 8004e70:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004e74:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004e78:	6939      	ldr	r1, [r7, #16]
 8004e7a:	460b      	mov	r3, r1
 8004e7c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e80:	185b      	adds	r3, r3, r1
 8004e82:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004e86:	18d3      	adds	r3, r2, r3
 8004e88:	f103 030c 	add.w	r3, r3, #12
 8004e8c:	f04f 0200 	mov.w	r2, #0
 8004e90:	601a      	str	r2, [r3, #0]
 } /* End of "if((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )"*/
 return Status;
 8004e92:	69bb      	ldr	r3, [r7, #24]
}
 8004e94:	4618      	mov	r0, r3
 8004e96:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8004e9a:	46bd      	mov	sp, r7
 8004e9c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8004ea0:	b003      	add	sp, #12
 8004ea2:	4770      	bx	lr

08004ea4 <_close>:
#elif defined  __TASKING__
_err_t  _close(_fd_t Fd)
#elif defined  __ICCARM__
int __close(int Fd)
#endif
{
 8004ea4:	b580      	push	{r7, lr}
 8004ea6:	b086      	sub	sp, #24
 8004ea8:	af00      	add	r7, sp, #0
 8004eaa:	6078      	str	r0, [r7, #4]
#ifdef  __TASKING__
  _err_t Status = FILE_WRAPPER_ERROR;
#else
  int Status = FILE_WRAPPER_ERROR;
 8004eac:	f04f 33ff 	mov.w	r3, #4294967295
 8004eb0:	617b      	str	r3, [r7, #20]
  int SlotNumber;
  FRESULT Result;
  do
  {
    /* Find the Slot number */
    SlotNumber = SLTHA001_lFindAvailableSlot(Fd);
 8004eb2:	6878      	ldr	r0, [r7, #4]
 8004eb4:	f7ff fc88 	bl	80047c8 <SLTHA001_lFindAvailableSlot>
 8004eb8:	4603      	mov	r3, r0
 8004eba:	613b      	str	r3, [r7, #16]
/* <<<DD_SLTHA001_API_2_1>>> */
    if (SlotNumber == MAX_OPEN_FILES)
 8004ebc:	693b      	ldr	r3, [r7, #16]
 8004ebe:	2b14      	cmp	r3, #20
 8004ec0:	d106      	bne.n	8004ed0 <_close+0x2c>
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EBADF;
 8004ec2:	f01d fd45 	bl	8022950 <__errno>
 8004ec6:	4603      	mov	r3, r0
 8004ec8:	f04f 0209 	mov.w	r2, #9
 8004ecc:	601a      	str	r2, [r3, #0]
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
 8004ece:	e07a      	b.n	8004fc6 <_close+0x122>
    }
 /* Set the handle in the file info structure to -1 */
    FileHandle [SlotNumber].Fd = -1;
 8004ed0:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004ed4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004ed8:	6939      	ldr	r1, [r7, #16]
 8004eda:	460b      	mov	r3, r1
 8004edc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004ee0:	185b      	adds	r3, r3, r1
 8004ee2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004ee6:	18d3      	adds	r3, r2, r3
 8004ee8:	f04f 32ff 	mov.w	r2, #4294967295
 8004eec:	601a      	str	r2, [r3, #0]
/* Check FilePtr is not Null */
/* <<<DD_SLTHA001_API_2_2>>> */
    if (FileHandle [SlotNumber].FatFsPtr != NULL )
 8004eee:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004ef2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004ef6:	6939      	ldr	r1, [r7, #16]
 8004ef8:	460b      	mov	r3, r1
 8004efa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004efe:	185b      	adds	r3, r3, r1
 8004f00:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004f04:	18d3      	adds	r3, r2, r3
 8004f06:	f103 030c 	add.w	r3, r3, #12
 8004f0a:	681b      	ldr	r3, [r3, #0]
 8004f0c:	2b00      	cmp	r3, #0
 8004f0e:	d05a      	beq.n	8004fc6 <_close+0x122>
    {
      Result = f_close (FileHandle[SlotNumber].FatFsPtr);
 8004f10:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004f14:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004f18:	6939      	ldr	r1, [r7, #16]
 8004f1a:	460b      	mov	r3, r1
 8004f1c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004f20:	185b      	adds	r3, r3, r1
 8004f22:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004f26:	18d3      	adds	r3, r2, r3
 8004f28:	f103 030c 	add.w	r3, r3, #12
 8004f2c:	681b      	ldr	r3, [r3, #0]
 8004f2e:	4618      	mov	r0, r3
 8004f30:	f008 fe78 	bl	800dc24 <f_close>
 8004f34:	4603      	mov	r3, r0
 8004f36:	73fb      	strb	r3, [r7, #15]
      if (Result != FR_OK)
 8004f38:	7bfb      	ldrb	r3, [r7, #15]
 8004f3a:	2b00      	cmp	r3, #0
 8004f3c:	d00b      	beq.n	8004f56 <_close+0xb2>
      {
        errno = ErrorCodes[ Result];
 8004f3e:	f01d fd07 	bl	8022950 <__errno>
 8004f42:	4602      	mov	r2, r0
 8004f44:	7bf9      	ldrb	r1, [r7, #15]
 8004f46:	f246 6374 	movw	r3, #26228	; 0x6674
 8004f4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f4e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8004f52:	6013      	str	r3, [r2, #0]
        break;
 8004f54:	e037      	b.n	8004fc6 <_close+0x122>
      }
      free (FileHandle[SlotNumber].FilePath);
 8004f56:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004f5a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004f5e:	6939      	ldr	r1, [r7, #16]
 8004f60:	460b      	mov	r3, r1
 8004f62:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004f66:	185b      	adds	r3, r3, r1
 8004f68:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004f6c:	18d3      	adds	r3, r2, r3
 8004f6e:	f103 0310 	add.w	r3, r3, #16
 8004f72:	681b      	ldr	r3, [r3, #0]
 8004f74:	4618      	mov	r0, r3
 8004f76:	f01e fb45 	bl	8023604 <free>
      free (FileHandle[SlotNumber].FatFsPtr);
 8004f7a:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004f7e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004f82:	6939      	ldr	r1, [r7, #16]
 8004f84:	460b      	mov	r3, r1
 8004f86:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004f8a:	185b      	adds	r3, r3, r1
 8004f8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004f90:	18d3      	adds	r3, r2, r3
 8004f92:	f103 030c 	add.w	r3, r3, #12
 8004f96:	681b      	ldr	r3, [r3, #0]
 8004f98:	4618      	mov	r0, r3
 8004f9a:	f01e fb33 	bl	8023604 <free>
      FileHandle [SlotNumber].FatFsPtr = NULL;
 8004f9e:	f640 422c 	movw	r2, #3116	; 0xc2c
 8004fa2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004fa6:	6939      	ldr	r1, [r7, #16]
 8004fa8:	460b      	mov	r3, r1
 8004faa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004fae:	185b      	adds	r3, r3, r1
 8004fb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8004fb4:	18d3      	adds	r3, r2, r3
 8004fb6:	f103 030c 	add.w	r3, r3, #12
 8004fba:	f04f 0200 	mov.w	r2, #0
 8004fbe:	601a      	str	r2, [r3, #0]
/* <<<DD_SLTHA001_API_2_3>>> */
      Status = DAVEApp_SUCCESS;
 8004fc0:	f04f 0300 	mov.w	r3, #0
 8004fc4:	617b      	str	r3, [r7, #20]
    }
  } while(0);
  return Status;
 8004fc6:	697b      	ldr	r3, [r7, #20]
}
 8004fc8:	4618      	mov	r0, r3
 8004fca:	f107 0718 	add.w	r7, r7, #24
 8004fce:	46bd      	mov	sp, r7
 8004fd0:	bd80      	pop	{r7, pc}
 8004fd2:	bf00      	nop

08004fd4 <_read_r>:
  int Fd,
  unsigned char *BufferPtr,
  size_t Length
)
#endif
{
 8004fd4:	b580      	push	{r7, lr}
 8004fd6:	b088      	sub	sp, #32
 8004fd8:	af00      	add	r7, sp, #0
 8004fda:	60f8      	str	r0, [r7, #12]
 8004fdc:	60b9      	str	r1, [r7, #8]
 8004fde:	607a      	str	r2, [r7, #4]
 8004fe0:	603b      	str	r3, [r7, #0]
  int SlotNumber;
  int BytesRead = 0;
 8004fe2:	f04f 0300 	mov.w	r3, #0
 8004fe6:	613b      	str	r3, [r7, #16]
  int BytesUnRead = -1;
 8004fe8:	f04f 33ff 	mov.w	r3, #4294967295
 8004fec:	61fb      	str	r3, [r7, #28]
		   return std_read( r,DM_GET_FD(Fd), BufferPtr, Length );
	   }
#endif
/* Re-map the adjusted File Handle  */
/* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA001_lFindAvailableSlot(Fd);
 8004fee:	68b8      	ldr	r0, [r7, #8]
 8004ff0:	f7ff fbea 	bl	80047c8 <SLTHA001_lFindAvailableSlot>
 8004ff4:	4603      	mov	r3, r0
 8004ff6:	61bb      	str	r3, [r7, #24]
/* <<<DD_SLTHA001_API_3_1>>> */
/* Check If write only flag is set  or Max Files are opened.*/
    if ( (SlotNumber == MAX_OPEN_FILES) || 
 8004ff8:	69bb      	ldr	r3, [r7, #24]
 8004ffa:	2b14      	cmp	r3, #20
 8004ffc:	d012      	beq.n	8005024 <_read_r+0x50>
		     ((FileHandle[SlotNumber].Flags & SLTHA001_WRONLY) != 0UL ))
 8004ffe:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005002:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005006:	69b9      	ldr	r1, [r7, #24]
 8005008:	460b      	mov	r3, r1
 800500a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800500e:	185b      	adds	r3, r3, r1
 8005010:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005014:	18d3      	adds	r3, r2, r3
 8005016:	f103 0308 	add.w	r3, r3, #8
 800501a:	681b      	ldr	r3, [r3, #0]
 800501c:	f003 0301 	and.w	r3, r3, #1
/* Re-map the adjusted File Handle  */
/* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA001_lFindAvailableSlot(Fd);
/* <<<DD_SLTHA001_API_3_1>>> */
/* Check If write only flag is set  or Max Files are opened.*/
    if ( (SlotNumber == MAX_OPEN_FILES) || 
 8005020:	2b00      	cmp	r3, #0
 8005022:	d009      	beq.n	8005038 <_read_r+0x64>
		     ((FileHandle[SlotNumber].Flags & SLTHA001_WRONLY) != 0UL ))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EBADF;
 8005024:	f01d fc94 	bl	8022950 <__errno>
 8005028:	4603      	mov	r3, r0
 800502a:	f04f 0209 	mov.w	r2, #9
 800502e:	601a      	str	r2, [r3, #0]
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined __ICCARM__
      errno = _LLIO_ERROR;
#endif
      BytesRead = -1;
 8005030:	f04f 33ff 	mov.w	r3, #4294967295
 8005034:	613b      	str	r3, [r7, #16]
      break;
 8005036:	e078      	b.n	800512a <_read_r+0x156>
    }
/* Switch as per the file descriptor.*/
   switch(Fd)
 8005038:	68bb      	ldr	r3, [r7, #8]
 800503a:	2b01      	cmp	r3, #1
 800503c:	d043      	beq.n	80050c6 <_read_r+0xf2>
 800503e:	2b02      	cmp	r3, #2
 8005040:	d043      	beq.n	80050ca <_read_r+0xf6>
 8005042:	2b00      	cmp	r3, #0
 8005044:	d043      	beq.n	80050ce <_read_r+0xfa>
     case STDERR_HANDLE:
           break;

     default:
/* <<<DD_SLTHA001_API_3_2>>> */
       if (FileHandle[SlotNumber].FatFsPtr != NULL)
 8005046:	f640 422c 	movw	r2, #3116	; 0xc2c
 800504a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800504e:	69b9      	ldr	r1, [r7, #24]
 8005050:	460b      	mov	r3, r1
 8005052:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005056:	185b      	adds	r3, r3, r1
 8005058:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800505c:	18d3      	adds	r3, r2, r3
 800505e:	f103 030c 	add.w	r3, r3, #12
 8005062:	681b      	ldr	r3, [r3, #0]
 8005064:	2b00      	cmp	r3, #0
 8005066:	d034      	beq.n	80050d2 <_read_r+0xfe>
       {
/* Call the Fat FS f_read function */
         Result = f_read(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length,
 8005068:	f640 422c 	movw	r2, #3116	; 0xc2c
 800506c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005070:	69b9      	ldr	r1, [r7, #24]
 8005072:	460b      	mov	r3, r1
 8005074:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005078:	185b      	adds	r3, r3, r1
 800507a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800507e:	18d3      	adds	r3, r2, r3
 8005080:	f103 030c 	add.w	r3, r3, #12
 8005084:	681a      	ldr	r2, [r3, #0]
                          (UINT *)&BytesRead);
 8005086:	f107 0310 	add.w	r3, r7, #16
     default:
/* <<<DD_SLTHA001_API_3_2>>> */
       if (FileHandle[SlotNumber].FatFsPtr != NULL)
       {
/* Call the Fat FS f_read function */
         Result = f_read(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length,
 800508a:	4610      	mov	r0, r2
 800508c:	6879      	ldr	r1, [r7, #4]
 800508e:	683a      	ldr	r2, [r7, #0]
 8005090:	f008 f9c6 	bl	800d420 <f_read>
 8005094:	4603      	mov	r3, r0
 8005096:	75fb      	strb	r3, [r7, #23]
                          (UINT *)&BytesRead);
/* <<<DD_SLTHA001_API_3_3>>> */
         if (Result != FR_OK)
 8005098:	7dfb      	ldrb	r3, [r7, #23]
 800509a:	2b00      	cmp	r3, #0
 800509c:	d00e      	beq.n	80050bc <_read_r+0xe8>
         {
           errno = ErrorCodes[ Result];
 800509e:	f01d fc57 	bl	8022950 <__errno>
 80050a2:	4602      	mov	r2, r0
 80050a4:	7df9      	ldrb	r1, [r7, #23]
 80050a6:	f246 6374 	movw	r3, #26228	; 0x6674
 80050aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050ae:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80050b2:	6013      	str	r3, [r2, #0]
           BytesRead = -1;
 80050b4:	f04f 33ff 	mov.w	r3, #4294967295
 80050b8:	613b      	str	r3, [r7, #16]
           break;
 80050ba:	e00b      	b.n	80050d4 <_read_r+0x100>
         }
         BytesUnRead = Length - BytesRead;
 80050bc:	693b      	ldr	r3, [r7, #16]
 80050be:	683a      	ldr	r2, [r7, #0]
 80050c0:	1ad3      	subs	r3, r2, r3
 80050c2:	61fb      	str	r3, [r7, #28]
       }
       break;
 80050c4:	e005      	b.n	80050d2 <_read_r+0xfe>
   {
     case STDIN_HANDLE:
          break;

     case STDOUT_HANDLE:
           break;
 80050c6:	bf00      	nop
 80050c8:	e004      	b.n	80050d4 <_read_r+0x100>

     case STDERR_HANDLE:
           break;
 80050ca:	bf00      	nop
 80050cc:	e002      	b.n	80050d4 <_read_r+0x100>
    }
/* Switch as per the file descriptor.*/
   switch(Fd)
   {
     case STDIN_HANDLE:
          break;
 80050ce:	bf00      	nop
 80050d0:	e000      	b.n	80050d4 <_read_r+0x100>
           BytesRead = -1;
           break;
         }
         BytesUnRead = Length - BytesRead;
       }
       break;
 80050d2:	bf00      	nop
    }
/* <<<DD_SLTHA001_API_3_4>>> */
    if (BytesUnRead < 0)
 80050d4:	69fb      	ldr	r3, [r7, #28]
 80050d6:	2b00      	cmp	r3, #0
 80050d8:	da03      	bge.n	80050e2 <_read_r+0x10e>
    {
      BytesRead = -1;
 80050da:	f04f 33ff 	mov.w	r3, #4294967295
 80050de:	613b      	str	r3, [r7, #16]
      break;
 80050e0:	e023      	b.n	800512a <_read_r+0x156>
    }
    FileHandle[SlotNumber].CurrentPos += (Length - BytesUnRead);
 80050e2:	f640 422c 	movw	r2, #3116	; 0xc2c
 80050e6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80050ea:	69b9      	ldr	r1, [r7, #24]
 80050ec:	460b      	mov	r3, r1
 80050ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80050f2:	185b      	adds	r3, r3, r1
 80050f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80050f8:	18d3      	adds	r3, r2, r3
 80050fa:	f103 0304 	add.w	r3, r3, #4
 80050fe:	681b      	ldr	r3, [r3, #0]
 8005100:	461a      	mov	r2, r3
 8005102:	69fb      	ldr	r3, [r7, #28]
 8005104:	6839      	ldr	r1, [r7, #0]
 8005106:	1acb      	subs	r3, r1, r3
 8005108:	18d3      	adds	r3, r2, r3
 800510a:	4618      	mov	r0, r3
 800510c:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005110:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005114:	69b9      	ldr	r1, [r7, #24]
 8005116:	460b      	mov	r3, r1
 8005118:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800511c:	185b      	adds	r3, r3, r1
 800511e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005122:	18d3      	adds	r3, r2, r3
 8005124:	f103 0304 	add.w	r3, r3, #4
 8005128:	6018      	str	r0, [r3, #0]
  } while(0);
  return BytesRead;
 800512a:	693b      	ldr	r3, [r7, #16]
}
 800512c:	4618      	mov	r0, r3
 800512e:	f107 0720 	add.w	r7, r7, #32
 8005132:	46bd      	mov	sp, r7
 8005134:	bd80      	pop	{r7, pc}
 8005136:	bf00      	nop

08005138 <_write_r>:
  int Fd,
  const unsigned char * BufferPtr,
  size_t Length
)
#endif
{
 8005138:	b580      	push	{r7, lr}
 800513a:	b088      	sub	sp, #32
 800513c:	af00      	add	r7, sp, #0
 800513e:	60f8      	str	r0, [r7, #12]
 8005140:	60b9      	str	r1, [r7, #8]
 8005142:	607a      	str	r2, [r7, #4]
 8005144:	603b      	str	r3, [r7, #0]
  int SlotNumber;
  int BytesWritten = 0;
 8005146:	f04f 0300 	mov.w	r3, #0
 800514a:	613b      	str	r3, [r7, #16]
  int BytesUnWritten = -1;
 800514c:	f04f 33ff 	mov.w	r3, #4294967295
 8005150:	61fb      	str	r3, [r7, #28]
	  {
		  return std_write( r,DM_GET_FD(Fd), BufferPtr, Length );
	  }
#endif
/* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA001_lFindAvailableSlot(Fd);
 8005152:	68b8      	ldr	r0, [r7, #8]
 8005154:	f7ff fb38 	bl	80047c8 <SLTHA001_lFindAvailableSlot>
 8005158:	4603      	mov	r3, r0
 800515a:	61bb      	str	r3, [r7, #24]
/* <<<DD_SLTHA001_API_4_1>>> */
/* Check If read only flag is set or Max Files are opened. */
    if ( (SlotNumber == MAX_OPEN_FILES) || 
 800515c:	69bb      	ldr	r3, [r7, #24]
 800515e:	2b14      	cmp	r3, #20
 8005160:	d106      	bne.n	8005170 <_write_r+0x38>
		   ((FileHandle[SlotNumber].Flags & SLTHA001_RDONLY ) == 1UL ))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EBADF;
 8005162:	f01d fbf5 	bl	8022950 <__errno>
 8005166:	4603      	mov	r3, r0
 8005168:	f04f 0209 	mov.w	r2, #9
 800516c:	601a      	str	r2, [r3, #0]
#elif defined  __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
 800516e:	e04a      	b.n	8005206 <_write_r+0xce>
    }
/* Switch as per the file descriptor.*/
    switch(Fd)
 8005170:	68bb      	ldr	r3, [r7, #8]
 8005172:	2b01      	cmp	r3, #1
 8005174:	d040      	beq.n	80051f8 <_write_r+0xc0>
 8005176:	2b02      	cmp	r3, #2
 8005178:	d040      	beq.n	80051fc <_write_r+0xc4>
 800517a:	2b00      	cmp	r3, #0
 800517c:	d040      	beq.n	8005200 <_write_r+0xc8>
      default:
#if _FS_READONLY   
    break;
#else 
/* <<<DD_SLTHA001_API_4_2>>> */
        if (FileHandle[SlotNumber].FatFsPtr != NULL)
 800517e:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005182:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005186:	69b9      	ldr	r1, [r7, #24]
 8005188:	460b      	mov	r3, r1
 800518a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800518e:	185b      	adds	r3, r3, r1
 8005190:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005194:	18d3      	adds	r3, r2, r3
 8005196:	f103 030c 	add.w	r3, r3, #12
 800519a:	681b      	ldr	r3, [r3, #0]
 800519c:	2b00      	cmp	r3, #0
 800519e:	d031      	beq.n	8005204 <_write_r+0xcc>
        {
          /* Call the Fat FS f_write function */
          Result = f_write(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length,
 80051a0:	f640 422c 	movw	r2, #3116	; 0xc2c
 80051a4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80051a8:	69b9      	ldr	r1, [r7, #24]
 80051aa:	460b      	mov	r3, r1
 80051ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80051b0:	185b      	adds	r3, r3, r1
 80051b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80051b6:	18d3      	adds	r3, r2, r3
 80051b8:	f103 030c 	add.w	r3, r3, #12
 80051bc:	681a      	ldr	r2, [r3, #0]
                        (UINT *)&BytesWritten);
 80051be:	f107 0310 	add.w	r3, r7, #16
#else 
/* <<<DD_SLTHA001_API_4_2>>> */
        if (FileHandle[SlotNumber].FatFsPtr != NULL)
        {
          /* Call the Fat FS f_write function */
          Result = f_write(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length,
 80051c2:	4610      	mov	r0, r2
 80051c4:	6879      	ldr	r1, [r7, #4]
 80051c6:	683a      	ldr	r2, [r7, #0]
 80051c8:	f008 faa2 	bl	800d710 <f_write>
 80051cc:	4603      	mov	r3, r0
 80051ce:	75fb      	strb	r3, [r7, #23]
                        (UINT *)&BytesWritten);
/* <<<DD_SLTHA001_API_4_3>>> */
          if (Result != FR_OK)
 80051d0:	7dfb      	ldrb	r3, [r7, #23]
 80051d2:	2b00      	cmp	r3, #0
 80051d4:	d00b      	beq.n	80051ee <_write_r+0xb6>
          {
            errno = ErrorCodes[Result];
 80051d6:	f01d fbbb 	bl	8022950 <__errno>
 80051da:	4602      	mov	r2, r0
 80051dc:	7df9      	ldrb	r1, [r7, #23]
 80051de:	f246 6374 	movw	r3, #26228	; 0x6674
 80051e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051e6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80051ea:	6013      	str	r3, [r2, #0]
            break;
 80051ec:	e00b      	b.n	8005206 <_write_r+0xce>
          }
          BytesUnWritten = Length - BytesWritten;
 80051ee:	693b      	ldr	r3, [r7, #16]
 80051f0:	683a      	ldr	r2, [r7, #0]
 80051f2:	1ad3      	subs	r3, r2, r3
 80051f4:	61fb      	str	r3, [r7, #28]
        }
        break;
 80051f6:	e005      	b.n	8005204 <_write_r+0xcc>
    {
      case STDIN_HANDLE:
           break;

      case STDOUT_HANDLE:
           break;
 80051f8:	bf00      	nop
 80051fa:	e004      	b.n	8005206 <_write_r+0xce>

      case STDERR_HANDLE:
           break;
 80051fc:	bf00      	nop
 80051fe:	e002      	b.n	8005206 <_write_r+0xce>
    }
/* Switch as per the file descriptor.*/
    switch(Fd)
    {
      case STDIN_HANDLE:
           break;
 8005200:	bf00      	nop
 8005202:	e000      	b.n	8005206 <_write_r+0xce>
            errno = ErrorCodes[Result];
            break;
          }
          BytesUnWritten = Length - BytesWritten;
        }
        break;
 8005204:	bf00      	nop
#endif
    }
  } while(0);
/* <<<DD_SLTHA001_API_4_4>>> */
  if((BytesUnWritten  == -1) || (BytesUnWritten == Length))
 8005206:	69fb      	ldr	r3, [r7, #28]
 8005208:	f1b3 3fff 	cmp.w	r3, #4294967295
 800520c:	d003      	beq.n	8005216 <_write_r+0xde>
 800520e:	69fa      	ldr	r2, [r7, #28]
 8005210:	683b      	ldr	r3, [r7, #0]
 8005212:	429a      	cmp	r2, r3
 8005214:	d103      	bne.n	800521e <_write_r+0xe6>
  {
    BytesWritten = -1;
 8005216:	f04f 33ff 	mov.w	r3, #4294967295
 800521a:	613b      	str	r3, [r7, #16]
 800521c:	e023      	b.n	8005266 <_write_r+0x12e>
  }
/* <<<DD_SLTHA001_API_4_5>>> */
  else
  {
    FileHandle[SlotNumber].CurrentPos += (Length - BytesUnWritten);
 800521e:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005222:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005226:	69b9      	ldr	r1, [r7, #24]
 8005228:	460b      	mov	r3, r1
 800522a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800522e:	185b      	adds	r3, r3, r1
 8005230:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005234:	18d3      	adds	r3, r2, r3
 8005236:	f103 0304 	add.w	r3, r3, #4
 800523a:	681b      	ldr	r3, [r3, #0]
 800523c:	461a      	mov	r2, r3
 800523e:	69fb      	ldr	r3, [r7, #28]
 8005240:	6839      	ldr	r1, [r7, #0]
 8005242:	1acb      	subs	r3, r1, r3
 8005244:	18d3      	adds	r3, r2, r3
 8005246:	4618      	mov	r0, r3
 8005248:	f640 422c 	movw	r2, #3116	; 0xc2c
 800524c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005250:	69b9      	ldr	r1, [r7, #24]
 8005252:	460b      	mov	r3, r1
 8005254:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005258:	185b      	adds	r3, r3, r1
 800525a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800525e:	18d3      	adds	r3, r2, r3
 8005260:	f103 0304 	add.w	r3, r3, #4
 8005264:	6018      	str	r0, [r3, #0]
  }
  return BytesWritten;
 8005266:	693b      	ldr	r3, [r7, #16]
}
 8005268:	4618      	mov	r0, r3
 800526a:	f107 0720 	add.w	r7, r7, #32
 800526e:	46bd      	mov	sp, r7
 8005270:	bd80      	pop	{r7, pc}
 8005272:	bf00      	nop

08005274 <_lseek>:
  int Fd,
  long Offset,
  int DirMode
)
#endif
{
 8005274:	b580      	push	{r7, lr}
 8005276:	b088      	sub	sp, #32
 8005278:	af00      	add	r7, sp, #0
 800527a:	60f8      	str	r0, [r7, #12]
 800527c:	60b9      	str	r1, [r7, #8]
 800527e:	607a      	str	r2, [r7, #4]
  int FileOffset = -1;
 8005280:	f04f 33ff 	mov.w	r3, #4294967295
 8005284:	61fb      	str	r3, [r7, #28]
  {
#if _FS_MINIMIZE == 3
    break;
#else
    /* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA001_lFindAvailableSlot(Fd);
 8005286:	68f8      	ldr	r0, [r7, #12]
 8005288:	f7ff fa9e 	bl	80047c8 <SLTHA001_lFindAvailableSlot>
 800528c:	4603      	mov	r3, r0
 800528e:	617b      	str	r3, [r7, #20]
/* <<<DD_SLTHA001_API_5_1>>> */
    if ( (SlotNumber == MAX_OPEN_FILES) ||
 8005290:	697b      	ldr	r3, [r7, #20]
 8005292:	2b14      	cmp	r3, #20
 8005294:	d010      	beq.n	80052b8 <_lseek+0x44>
         (FileHandle[SlotNumber].FatFsPtr == NULL))
 8005296:	f640 422c 	movw	r2, #3116	; 0xc2c
 800529a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800529e:	6979      	ldr	r1, [r7, #20]
 80052a0:	460b      	mov	r3, r1
 80052a2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80052a6:	185b      	adds	r3, r3, r1
 80052a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80052ac:	18d3      	adds	r3, r2, r3
 80052ae:	f103 030c 	add.w	r3, r3, #12
 80052b2:	681b      	ldr	r3, [r3, #0]
    break;
#else
    /* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA001_lFindAvailableSlot(Fd);
/* <<<DD_SLTHA001_API_5_1>>> */
    if ( (SlotNumber == MAX_OPEN_FILES) ||
 80052b4:	2b00      	cmp	r3, #0
 80052b6:	d106      	bne.n	80052c6 <_lseek+0x52>
         (FileHandle[SlotNumber].FatFsPtr == NULL))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EBADF;
 80052b8:	f01d fb4a 	bl	8022950 <__errno>
 80052bc:	4603      	mov	r3, r0
 80052be:	f04f 0209 	mov.w	r2, #9
 80052c2:	601a      	str	r2, [r3, #0]
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
 80052c4:	e0ad      	b.n	8005422 <_lseek+0x1ae>
    }
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    /* Check Direction Mode */
/* <<<DD_SLTHA001_API_5_2>>> */
    if (DirMode == SEEK_SET)
 80052c6:	687b      	ldr	r3, [r7, #4]
 80052c8:	2b00      	cmp	r3, #0
 80052ca:	d116      	bne.n	80052fa <_lseek+0x86>
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, Offset);
 80052cc:	f640 422c 	movw	r2, #3116	; 0xc2c
 80052d0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80052d4:	6979      	ldr	r1, [r7, #20]
 80052d6:	460b      	mov	r3, r1
 80052d8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80052dc:	185b      	adds	r3, r3, r1
 80052de:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80052e2:	18d3      	adds	r3, r2, r3
 80052e4:	f103 030c 	add.w	r3, r3, #12
 80052e8:	681a      	ldr	r2, [r3, #0]
 80052ea:	68bb      	ldr	r3, [r7, #8]
 80052ec:	4610      	mov	r0, r2
 80052ee:	4619      	mov	r1, r3
 80052f0:	f008 fd32 	bl	800dd58 <f_lseek>
 80052f4:	4603      	mov	r3, r0
 80052f6:	76fb      	strb	r3, [r7, #27]
 80052f8:	e052      	b.n	80053a0 <_lseek+0x12c>
    }
/* <<<DD_SLTHA001_API_5_3>>> */
    else if (DirMode == SEEK_CUR)
 80052fa:	687b      	ldr	r3, [r7, #4]
 80052fc:	2b01      	cmp	r3, #1
 80052fe:	d126      	bne.n	800534e <_lseek+0xda>
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr,  \
 8005300:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005304:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005308:	6979      	ldr	r1, [r7, #20]
 800530a:	460b      	mov	r3, r1
 800530c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005310:	185b      	adds	r3, r3, r1
 8005312:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005316:	18d3      	adds	r3, r2, r3
 8005318:	f103 030c 	add.w	r3, r3, #12
 800531c:	6818      	ldr	r0, [r3, #0]
                     FileHandle [SlotNumber].FatFsPtr->fptr + Offset);
 800531e:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005322:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005326:	6979      	ldr	r1, [r7, #20]
 8005328:	460b      	mov	r3, r1
 800532a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800532e:	185b      	adds	r3, r3, r1
 8005330:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005334:	18d3      	adds	r3, r2, r3
 8005336:	f103 030c 	add.w	r3, r3, #12
 800533a:	681b      	ldr	r3, [r3, #0]
 800533c:	689a      	ldr	r2, [r3, #8]
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, Offset);
    }
/* <<<DD_SLTHA001_API_5_3>>> */
    else if (DirMode == SEEK_CUR)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr,  \
 800533e:	68bb      	ldr	r3, [r7, #8]
 8005340:	18d3      	adds	r3, r2, r3
 8005342:	4619      	mov	r1, r3
 8005344:	f008 fd08 	bl	800dd58 <f_lseek>
 8005348:	4603      	mov	r3, r0
 800534a:	76fb      	strb	r3, [r7, #27]
 800534c:	e028      	b.n	80053a0 <_lseek+0x12c>
                     FileHandle [SlotNumber].FatFsPtr->fptr + Offset);
    }
/* <<<DD_SLTHA001_API_5_4>>> */
    else if (DirMode == SEEK_END)
 800534e:	687b      	ldr	r3, [r7, #4]
 8005350:	2b02      	cmp	r3, #2
 8005352:	d165      	bne.n	8005420 <_lseek+0x1ac>
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr,  \
 8005354:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005358:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800535c:	6979      	ldr	r1, [r7, #20]
 800535e:	460b      	mov	r3, r1
 8005360:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005364:	185b      	adds	r3, r3, r1
 8005366:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800536a:	18d3      	adds	r3, r2, r3
 800536c:	f103 030c 	add.w	r3, r3, #12
 8005370:	6818      	ldr	r0, [r3, #0]
                        FileHandle [SlotNumber].FatFsPtr->fsize + Offset);
 8005372:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005376:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800537a:	6979      	ldr	r1, [r7, #20]
 800537c:	460b      	mov	r3, r1
 800537e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005382:	185b      	adds	r3, r3, r1
 8005384:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005388:	18d3      	adds	r3, r2, r3
 800538a:	f103 030c 	add.w	r3, r3, #12
 800538e:	681b      	ldr	r3, [r3, #0]
 8005390:	68da      	ldr	r2, [r3, #12]
                     FileHandle [SlotNumber].FatFsPtr->fptr + Offset);
    }
/* <<<DD_SLTHA001_API_5_4>>> */
    else if (DirMode == SEEK_END)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr,  \
 8005392:	68bb      	ldr	r3, [r7, #8]
 8005394:	18d3      	adds	r3, r2, r3
 8005396:	4619      	mov	r1, r3
 8005398:	f008 fcde 	bl	800dd58 <f_lseek>
 800539c:	4603      	mov	r3, r0
 800539e:	76fb      	strb	r3, [r7, #27]
/* <<<DD_SLTHA001_API_5_5>>> */
    Result= f_lseek (FileHandle[SlotNumber].FatFsPtr,Offset);
#endif
    /* If Fat FS Function call returns Error*/
/* <<<DD_SLTHA001_API_5_6>>> */
    if (Result != FR_OK)
 80053a0:	7efb      	ldrb	r3, [r7, #27]
 80053a2:	2b00      	cmp	r3, #0
 80053a4:	d00b      	beq.n	80053be <_lseek+0x14a>
    {
      errno = ErrorCodes[Result];
 80053a6:	f01d fad3 	bl	8022950 <__errno>
 80053aa:	4602      	mov	r2, r0
 80053ac:	7ef9      	ldrb	r1, [r7, #27]
 80053ae:	f246 6374 	movw	r3, #26228	; 0x6674
 80053b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053b6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80053ba:	6013      	str	r3, [r2, #0]
      break;
 80053bc:	e031      	b.n	8005422 <_lseek+0x1ae>
    }
    FileHandle[SlotNumber].CurrentPos = FileHandle [SlotNumber].FatFsPtr->fptr;
 80053be:	f640 422c 	movw	r2, #3116	; 0xc2c
 80053c2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80053c6:	6979      	ldr	r1, [r7, #20]
 80053c8:	460b      	mov	r3, r1
 80053ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80053ce:	185b      	adds	r3, r3, r1
 80053d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80053d4:	18d3      	adds	r3, r2, r3
 80053d6:	f103 030c 	add.w	r3, r3, #12
 80053da:	681b      	ldr	r3, [r3, #0]
 80053dc:	689b      	ldr	r3, [r3, #8]
 80053de:	4618      	mov	r0, r3
 80053e0:	f640 422c 	movw	r2, #3116	; 0xc2c
 80053e4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80053e8:	6979      	ldr	r1, [r7, #20]
 80053ea:	460b      	mov	r3, r1
 80053ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80053f0:	185b      	adds	r3, r3, r1
 80053f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80053f6:	18d3      	adds	r3, r2, r3
 80053f8:	f103 0304 	add.w	r3, r3, #4
 80053fc:	6018      	str	r0, [r3, #0]
    FileOffset = FileHandle[SlotNumber].CurrentPos;
 80053fe:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005402:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005406:	6979      	ldr	r1, [r7, #20]
 8005408:	460b      	mov	r3, r1
 800540a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800540e:	185b      	adds	r3, r3, r1
 8005410:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005414:	18d3      	adds	r3, r2, r3
 8005416:	f103 0304 	add.w	r3, r3, #4
 800541a:	681b      	ldr	r3, [r3, #0]
 800541c:	61fb      	str	r3, [r7, #28]
 800541e:	e000      	b.n	8005422 <_lseek+0x1ae>
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr,  \
                        FileHandle [SlotNumber].FatFsPtr->fsize + Offset);
    }
    else
      break;
 8005420:	bf00      	nop
    }
    FileHandle[SlotNumber].CurrentPos = FileHandle [SlotNumber].FatFsPtr->fptr;
    FileOffset = FileHandle[SlotNumber].CurrentPos;
#endif
  } while(0);
  return FileOffset;
 8005422:	69fb      	ldr	r3, [r7, #28]
}
 8005424:	4618      	mov	r0, r3
 8005426:	f107 0720 	add.w	r7, r7, #32
 800542a:	46bd      	mov	sp, r7
 800542c:	bd80      	pop	{r7, pc}
 800542e:	bf00      	nop

08005430 <_unlink>:
#elif  __TASKING__
int remove (const char *Path)
#elif __ICCARM__
int remove(const char * Path)
#endif
{
 8005430:	b580      	push	{r7, lr}
 8005432:	b084      	sub	sp, #16
 8005434:	af00      	add	r7, sp, #0
 8005436:	6078      	str	r0, [r7, #4]
  int Status = FILE_WRAPPER_ERROR;
 8005438:	f04f 33ff 	mov.w	r3, #4294967295
 800543c:	60fb      	str	r3, [r7, #12]
  {
#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))   
    break;
#else  
    /* Call the Fat FS unlink function */
    Result = f_unlink (Path);
 800543e:	6878      	ldr	r0, [r7, #4]
 8005440:	f009 f878 	bl	800e534 <f_unlink>
 8005444:	4603      	mov	r3, r0
 8005446:	72fb      	strb	r3, [r7, #11]
/* <<<DD_SLTHA001_API_6_1>>> */
    if( Result != FR_OK)
 8005448:	7afb      	ldrb	r3, [r7, #11]
 800544a:	2b00      	cmp	r3, #0
 800544c:	d00b      	beq.n	8005466 <_unlink+0x36>
    {
      errno = ErrorCodes[Result];
 800544e:	f01d fa7f 	bl	8022950 <__errno>
 8005452:	4602      	mov	r2, r0
 8005454:	7af9      	ldrb	r1, [r7, #11]
 8005456:	f246 6374 	movw	r3, #26228	; 0x6674
 800545a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800545e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8005462:	6013      	str	r3, [r2, #0]
      break;
 8005464:	e002      	b.n	800546c <_unlink+0x3c>
    }
    Status = DAVEApp_SUCCESS;
 8005466:	f04f 0300 	mov.w	r3, #0
 800546a:	60fb      	str	r3, [r7, #12]
#endif
  } while(0);
  return Status;
 800546c:	68fb      	ldr	r3, [r7, #12]
}
 800546e:	4618      	mov	r0, r3
 8005470:	f107 0710 	add.w	r7, r7, #16
 8005474:	46bd      	mov	sp, r7
 8005476:	bd80      	pop	{r7, pc}

08005478 <_fstat>:
#if defined (__GNUC__)
int _fstat(int Fd, struct stat *FileStatusPtr)
#elif  defined (  __TASKING__)
int fstat(int Fd, struct stat *FileStatusPtr)
#endif
{
 8005478:	b580      	push	{r7, lr}
 800547a:	b08c      	sub	sp, #48	; 0x30
 800547c:	af00      	add	r7, sp, #0
 800547e:	6078      	str	r0, [r7, #4]
 8005480:	6039      	str	r1, [r7, #0]
  int Status = FILE_WRAPPER_ERROR;
 8005482:	f04f 33ff 	mov.w	r3, #4294967295
 8005486:	62fb      	str	r3, [r7, #44]	; 0x2c
#if _FS_MINIMIZE == 0   
  FILINFO FatFsInfoStruct = {0};
 8005488:	f107 030c 	add.w	r3, r7, #12
 800548c:	f04f 0200 	mov.w	r2, #0
 8005490:	601a      	str	r2, [r3, #0]
 8005492:	f103 0304 	add.w	r3, r3, #4
 8005496:	f04f 0200 	mov.w	r2, #0
 800549a:	601a      	str	r2, [r3, #0]
 800549c:	f103 0304 	add.w	r3, r3, #4
 80054a0:	f04f 0200 	mov.w	r2, #0
 80054a4:	601a      	str	r2, [r3, #0]
 80054a6:	f103 0304 	add.w	r3, r3, #4
 80054aa:	f04f 0200 	mov.w	r2, #0
 80054ae:	601a      	str	r2, [r3, #0]
 80054b0:	f103 0304 	add.w	r3, r3, #4
 80054b4:	f04f 0200 	mov.w	r2, #0
 80054b8:	601a      	str	r2, [r3, #0]
 80054ba:	f103 0304 	add.w	r3, r3, #4
 80054be:	f04f 0200 	mov.w	r2, #0
 80054c2:	601a      	str	r2, [r3, #0]
 80054c4:	f103 0304 	add.w	r3, r3, #4
  int SlotNumber;
 
  do
  {

  if( ( Fd >= STDIN_HANDLE ) && ( Fd <= STDERR_HANDLE ) )
 80054c8:	687b      	ldr	r3, [r7, #4]
 80054ca:	2b00      	cmp	r3, #0
 80054cc:	db09      	blt.n	80054e2 <_fstat+0x6a>
 80054ce:	687b      	ldr	r3, [r7, #4]
 80054d0:	2b02      	cmp	r3, #2
 80054d2:	dc06      	bgt.n	80054e2 <_fstat+0x6a>
	{
	  FileStatusPtr->st_mode = S_IFCHR;
 80054d4:	683b      	ldr	r3, [r7, #0]
 80054d6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80054da:	605a      	str	r2, [r3, #4]
	  return 0;
 80054dc:	f04f 0300 	mov.w	r3, #0
 80054e0:	e037      	b.n	8005552 <_fstat+0xda>
	}
    /* Find the Slot number occupied by the file to read the status*/
    SlotNumber = SLTHA001_lFindAvailableSlot(Fd);
 80054e2:	6878      	ldr	r0, [r7, #4]
 80054e4:	f7ff f970 	bl	80047c8 <SLTHA001_lFindAvailableSlot>
 80054e8:	4603      	mov	r3, r0
 80054ea:	62bb      	str	r3, [r7, #40]	; 0x28
    /* Call the Fat FS Status function */
    Result = f_stat(FileHandle[SlotNumber].FilePath, &FatFsInfoStruct);
 80054ec:	f640 422c 	movw	r2, #3116	; 0xc2c
 80054f0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80054f4:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80054f6:	460b      	mov	r3, r1
 80054f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80054fc:	185b      	adds	r3, r3, r1
 80054fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005502:	18d3      	adds	r3, r2, r3
 8005504:	f103 0310 	add.w	r3, r3, #16
 8005508:	681a      	ldr	r2, [r3, #0]
 800550a:	f107 030c 	add.w	r3, r7, #12
 800550e:	4610      	mov	r0, r2
 8005510:	4619      	mov	r1, r3
 8005512:	f008 fe53 	bl	800e1bc <f_stat>
 8005516:	4603      	mov	r3, r0
 8005518:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
/* <<<DD_SLTHA001_API_7_1>>> */
    if (Result != FR_OK)
 800551c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8005520:	2b00      	cmp	r3, #0
 8005522:	d00c      	beq.n	800553e <_fstat+0xc6>
    {
      errno = ErrorCodes[Result];
 8005524:	f01d fa14 	bl	8022950 <__errno>
 8005528:	4602      	mov	r2, r0
 800552a:	f897 1027 	ldrb.w	r1, [r7, #39]	; 0x27
 800552e:	f246 6374 	movw	r3, #26228	; 0x6674
 8005532:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005536:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800553a:	6013      	str	r3, [r2, #0]
      break;
 800553c:	e008      	b.n	8005550 <_fstat+0xd8>
    }
    SLTHA001_lFatInfoToStatus(FileStatusPtr,&FatFsInfoStruct);
 800553e:	f107 030c 	add.w	r3, r7, #12
 8005542:	6838      	ldr	r0, [r7, #0]
 8005544:	4619      	mov	r1, r3
 8005546:	f7ff fa07 	bl	8004958 <SLTHA001_lFatInfoToStatus>
    Status = DAVEApp_SUCCESS;
 800554a:	f04f 0300 	mov.w	r3, #0
 800554e:	62fb      	str	r3, [r7, #44]	; 0x2c
  } while(0);
#endif
  return Status;
 8005550:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 8005552:	4618      	mov	r0, r3
 8005554:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8005558:	46bd      	mov	sp, r7
 800555a:	bd80      	pop	{r7, pc}

0800555c <_stat>:
#if defined (__GNUC__)
int _stat(const char *Path,  struct stat *FileStatusPtr)
#elif  defined (  __TASKING__)
int stat(const char *Path,  struct stat *FileStatusPtr)
#endif
{
 800555c:	b580      	push	{r7, lr}
 800555e:	b08a      	sub	sp, #40	; 0x28
 8005560:	af00      	add	r7, sp, #0
 8005562:	6078      	str	r0, [r7, #4]
 8005564:	6039      	str	r1, [r7, #0]
  int Status = FILE_WRAPPER_ERROR;
 8005566:	f04f 33ff 	mov.w	r3, #4294967295
 800556a:	627b      	str	r3, [r7, #36]	; 0x24
#if _FS_MINIMIZE == 0 
  FILINFO FatFsInfoStruct = {0};
 800556c:	f107 0308 	add.w	r3, r7, #8
 8005570:	f04f 0200 	mov.w	r2, #0
 8005574:	601a      	str	r2, [r3, #0]
 8005576:	f103 0304 	add.w	r3, r3, #4
 800557a:	f04f 0200 	mov.w	r2, #0
 800557e:	601a      	str	r2, [r3, #0]
 8005580:	f103 0304 	add.w	r3, r3, #4
 8005584:	f04f 0200 	mov.w	r2, #0
 8005588:	601a      	str	r2, [r3, #0]
 800558a:	f103 0304 	add.w	r3, r3, #4
 800558e:	f04f 0200 	mov.w	r2, #0
 8005592:	601a      	str	r2, [r3, #0]
 8005594:	f103 0304 	add.w	r3, r3, #4
 8005598:	f04f 0200 	mov.w	r2, #0
 800559c:	601a      	str	r2, [r3, #0]
 800559e:	f103 0304 	add.w	r3, r3, #4
 80055a2:	f04f 0200 	mov.w	r2, #0
 80055a6:	601a      	str	r2, [r3, #0]
 80055a8:	f103 0304 	add.w	r3, r3, #4
  FRESULT Result;
  do
  {
    /* Call the Fat FS Status function */
    Result = f_stat (Path, &FatFsInfoStruct);
 80055ac:	f107 0308 	add.w	r3, r7, #8
 80055b0:	6878      	ldr	r0, [r7, #4]
 80055b2:	4619      	mov	r1, r3
 80055b4:	f008 fe02 	bl	800e1bc <f_stat>
 80055b8:	4603      	mov	r3, r0
 80055ba:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
/* <<<DD_SLTHA001_API_8_1>>> */
    if( Result != FR_OK)
 80055be:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80055c2:	2b00      	cmp	r3, #0
 80055c4:	d00c      	beq.n	80055e0 <_stat+0x84>
    {
      errno = ErrorCodes[Result];
 80055c6:	f01d f9c3 	bl	8022950 <__errno>
 80055ca:	4602      	mov	r2, r0
 80055cc:	f897 1023 	ldrb.w	r1, [r7, #35]	; 0x23
 80055d0:	f246 6374 	movw	r3, #26228	; 0x6674
 80055d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055d8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80055dc:	6013      	str	r3, [r2, #0]
      break;
 80055de:	e008      	b.n	80055f2 <_stat+0x96>
    }
    SLTHA001_lFatInfoToStatus(FileStatusPtr,&FatFsInfoStruct);
 80055e0:	f107 0308 	add.w	r3, r7, #8
 80055e4:	6838      	ldr	r0, [r7, #0]
 80055e6:	4619      	mov	r1, r3
 80055e8:	f7ff f9b6 	bl	8004958 <SLTHA001_lFatInfoToStatus>
    Status = DAVEApp_SUCCESS;
 80055ec:	f04f 0300 	mov.w	r3, #0
 80055f0:	627b      	str	r3, [r7, #36]	; 0x24
  } while(0);
#endif
  return Status;
 80055f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 80055f4:	4618      	mov	r0, r3
 80055f6:	f107 0728 	add.w	r7, r7, #40	; 0x28
 80055fa:	46bd      	mov	sp, r7
 80055fc:	bd80      	pop	{r7, pc}
 80055fe:	bf00      	nop

08005600 <rename>:
#elif __CC_ARM
int rename(const char *OldPath, const char *NewPath)
#elif  __ICCARM__
int rename(const char *OldPath, const char *NewPath)
#endif
{
 8005600:	b580      	push	{r7, lr}
 8005602:	b084      	sub	sp, #16
 8005604:	af00      	add	r7, sp, #0
 8005606:	6078      	str	r0, [r7, #4]
 8005608:	6039      	str	r1, [r7, #0]
#if ((!_FS_READONLY) && ( _FS_MINIMIZE == 0))
  FRESULT Result;
#endif
  int Status = FILE_WRAPPER_ERROR;
 800560a:	f04f 33ff 	mov.w	r3, #4294967295
 800560e:	60fb      	str	r3, [r7, #12]
  {
#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))
    break;
#else   
    /* Call the Fat FS Status function */
    Result = f_rename(OldPath, NewPath);
 8005610:	6878      	ldr	r0, [r7, #4]
 8005612:	6839      	ldr	r1, [r7, #0]
 8005614:	f009 fb1a 	bl	800ec4c <f_rename>
 8005618:	4603      	mov	r3, r0
 800561a:	72fb      	strb	r3, [r7, #11]
/* <<<DD_SLTHA001_API_9_1>>> */
    if( Result != FR_OK)
 800561c:	7afb      	ldrb	r3, [r7, #11]
 800561e:	2b00      	cmp	r3, #0
 8005620:	d00b      	beq.n	800563a <rename+0x3a>
    {
      errno = ErrorCodes[Result];
 8005622:	f01d f995 	bl	8022950 <__errno>
 8005626:	4602      	mov	r2, r0
 8005628:	7af9      	ldrb	r1, [r7, #11]
 800562a:	f246 6374 	movw	r3, #26228	; 0x6674
 800562e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005632:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8005636:	6013      	str	r3, [r2, #0]
      break;
 8005638:	e002      	b.n	8005640 <rename+0x40>
    }
    Status = DAVEApp_SUCCESS;
 800563a:	f04f 0300 	mov.w	r3, #0
 800563e:	60fb      	str	r3, [r7, #12]
#endif
  } while(0);
  return Status;
 8005640:	68fb      	ldr	r3, [r7, #12]
}
 8005642:	4618      	mov	r0, r3
 8005644:	f107 0710 	add.w	r7, r7, #16
 8005648:	46bd      	mov	sp, r7
 800564a:	bd80      	pop	{r7, pc}

0800564c <_chmod>:
#if defined __GNUC__
int _chmod (const char *Path, mode_t Mode)
#elif defined __CC_ARM || defined  __TASKING__ || defined  __ICCARM__
int chmod (const char *Path, mode_t Mode)
#endif
{
 800564c:	b580      	push	{r7, lr}
 800564e:	b084      	sub	sp, #16
 8005650:	af00      	add	r7, sp, #0
 8005652:	6078      	str	r0, [r7, #4]
 8005654:	6039      	str	r1, [r7, #0]
#if ((!_FS_READONLY) && ( _FS_MINIMIZE == 0))
  FRESULT Result;
#endif
  int Status = FILE_WRAPPER_ERROR;
 8005656:	f04f 33ff 	mov.w	r3, #4294967295
 800565a:	60fb      	str	r3, [r7, #12]
  {
#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))
    break;
#else  
    /* Call the Fat FS Status function */
    Result = f_chmod(Path, Mode, AM_RDO);
 800565c:	683b      	ldr	r3, [r7, #0]
 800565e:	b2db      	uxtb	r3, r3
 8005660:	6878      	ldr	r0, [r7, #4]
 8005662:	4619      	mov	r1, r3
 8005664:	f04f 0201 	mov.w	r2, #1
 8005668:	f009 fa0c 	bl	800ea84 <f_chmod>
 800566c:	4603      	mov	r3, r0
 800566e:	72fb      	strb	r3, [r7, #11]
/* <<<DD_SLTHA001_API_10_1>>> */
    if( Result != FR_OK)
 8005670:	7afb      	ldrb	r3, [r7, #11]
 8005672:	2b00      	cmp	r3, #0
 8005674:	d00b      	beq.n	800568e <_chmod+0x42>
    {
      errno = ErrorCodes[Result];
 8005676:	f01d f96b 	bl	8022950 <__errno>
 800567a:	4602      	mov	r2, r0
 800567c:	7af9      	ldrb	r1, [r7, #11]
 800567e:	f246 6374 	movw	r3, #26228	; 0x6674
 8005682:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005686:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800568a:	6013      	str	r3, [r2, #0]
      break;
 800568c:	e002      	b.n	8005694 <_chmod+0x48>
    }
    Status = DAVEApp_SUCCESS;
 800568e:	f04f 0300 	mov.w	r3, #0
 8005692:	60fb      	str	r3, [r7, #12]
#endif
  } while(0);
  return Status;
 8005694:	68fb      	ldr	r3, [r7, #12]
}
 8005696:	4618      	mov	r0, r3
 8005698:	f107 0710 	add.w	r7, r7, #16
 800569c:	46bd      	mov	sp, r7
 800569e:	bd80      	pop	{r7, pc}

080056a0 <_mkdir>:
#if defined __GNUC__
int _mkdir (const char *Path, mode_t Mode)
#elif defined __CC_ARM || defined  __TASKING__ || defined  __ICCARM__
int mkdir (const char *Path, mode_t Mode)
#endif
{
 80056a0:	b580      	push	{r7, lr}
 80056a2:	b084      	sub	sp, #16
 80056a4:	af00      	add	r7, sp, #0
 80056a6:	6078      	str	r0, [r7, #4]
 80056a8:	6039      	str	r1, [r7, #0]
#if ((!_FS_READONLY) && ( _FS_MINIMIZE == 0))  
  FRESULT Result;
#endif
  int Status = FILE_WRAPPER_ERROR;
 80056aa:	f04f 33ff 	mov.w	r3, #4294967295
 80056ae:	60fb      	str	r3, [r7, #12]
  {
#if ((_FS_READONLY) || ( _FS_MINIMIZE != 0))  
    break;
#else 
    /* Call the Fat FS Mkdir function */
    Result = f_mkdir(Path);
 80056b0:	6878      	ldr	r0, [r7, #4]
 80056b2:	f009 f825 	bl	800e700 <f_mkdir>
 80056b6:	4603      	mov	r3, r0
 80056b8:	72fb      	strb	r3, [r7, #11]
/* <<<DD_SLTHA001_API_11_1>>> */
    if( Result != FR_OK)
 80056ba:	7afb      	ldrb	r3, [r7, #11]
 80056bc:	2b00      	cmp	r3, #0
 80056be:	d00b      	beq.n	80056d8 <_mkdir+0x38>
    {
      errno = ErrorCodes[Result];
 80056c0:	f01d f946 	bl	8022950 <__errno>
 80056c4:	4602      	mov	r2, r0
 80056c6:	7af9      	ldrb	r1, [r7, #11]
 80056c8:	f246 6374 	movw	r3, #26228	; 0x6674
 80056cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056d0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80056d4:	6013      	str	r3, [r2, #0]
      break;
 80056d6:	e002      	b.n	80056de <_mkdir+0x3e>
    }
    Status = DAVEApp_SUCCESS;
 80056d8:	f04f 0300 	mov.w	r3, #0
 80056dc:	60fb      	str	r3, [r7, #12]
#endif
  } while(0);
  return Status;
 80056de:	68fb      	ldr	r3, [r7, #12]
}
 80056e0:	4618      	mov	r0, r3
 80056e2:	f107 0710 	add.w	r7, r7, #16
 80056e6:	46bd      	mov	sp, r7
 80056e8:	bd80      	pop	{r7, pc}
 80056ea:	bf00      	nop

080056ec <_sync>:
#if defined (__GNUC__) || defined ( __TASKING__)
void  _sync (void)
#elif defined (__CC_ARM) || defined ( __ICCARM__)
void  sync (void)
#endif
{
 80056ec:	b580      	push	{r7, lr}
 80056ee:	b082      	sub	sp, #8
 80056f0:	af00      	add	r7, sp, #0
#if !_FS_READONLY 
  int SlotNumber;
  for( SlotNumber = 0; SlotNumber < MAX_OPEN_FILES; SlotNumber++ )
 80056f2:	f04f 0300 	mov.w	r3, #0
 80056f6:	607b      	str	r3, [r7, #4]
 80056f8:	e026      	b.n	8005748 <_sync+0x5c>
  {
/* <<<DD_SLTHA001_API_12_1>>> */
    if (FileHandle[SlotNumber].FatFsPtr)
 80056fa:	f640 422c 	movw	r2, #3116	; 0xc2c
 80056fe:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005702:	6879      	ldr	r1, [r7, #4]
 8005704:	460b      	mov	r3, r1
 8005706:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800570a:	185b      	adds	r3, r3, r1
 800570c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005710:	18d3      	adds	r3, r2, r3
 8005712:	f103 030c 	add.w	r3, r3, #12
 8005716:	681b      	ldr	r3, [r3, #0]
 8005718:	2b00      	cmp	r3, #0
 800571a:	d011      	beq.n	8005740 <_sync+0x54>
      f_sync (FileHandle[SlotNumber].FatFsPtr);
 800571c:	f640 422c 	movw	r2, #3116	; 0xc2c
 8005720:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005724:	6879      	ldr	r1, [r7, #4]
 8005726:	460b      	mov	r3, r1
 8005728:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800572c:	185b      	adds	r3, r3, r1
 800572e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005732:	18d3      	adds	r3, r2, r3
 8005734:	f103 030c 	add.w	r3, r3, #12
 8005738:	681b      	ldr	r3, [r3, #0]
 800573a:	4618      	mov	r0, r3
 800573c:	f008 f992 	bl	800da64 <f_sync>
void  sync (void)
#endif
{
#if !_FS_READONLY 
  int SlotNumber;
  for( SlotNumber = 0; SlotNumber < MAX_OPEN_FILES; SlotNumber++ )
 8005740:	687b      	ldr	r3, [r7, #4]
 8005742:	f103 0301 	add.w	r3, r3, #1
 8005746:	607b      	str	r3, [r7, #4]
 8005748:	687b      	ldr	r3, [r7, #4]
 800574a:	2b13      	cmp	r3, #19
 800574c:	ddd5      	ble.n	80056fa <_sync+0xe>
/* <<<DD_SLTHA001_API_12_1>>> */
    if (FileHandle[SlotNumber].FatFsPtr)
      f_sync (FileHandle[SlotNumber].FatFsPtr);
  }
#endif
}
 800574e:	f107 0708 	add.w	r7, r7, #8
 8005752:	46bd      	mov	sp, r7
 8005754:	bd80      	pop	{r7, pc}
 8005756:	bf00      	nop

08005758 <mkfs>:
/* <<<DD_SLTHA001_API_13>>> */
/*
 * This function creates the file system on the drive.
 */
int mkfs( uint8_t DriveNumber, uint8_t PartitioningRule,uint32_t AllocSize)
{
 8005758:	b580      	push	{r7, lr}
 800575a:	b084      	sub	sp, #16
 800575c:	af00      	add	r7, sp, #0
 800575e:	460b      	mov	r3, r1
 8005760:	603a      	str	r2, [r7, #0]
 8005762:	4602      	mov	r2, r0
 8005764:	71fa      	strb	r2, [r7, #7]
 8005766:	71bb      	strb	r3, [r7, #6]
  int Status = FILE_WRAPPER_ERROR;
 8005768:	f04f 33ff 	mov.w	r3, #4294967295
 800576c:	60fb      	str	r3, [r7, #12]
#if _USE_MKFS
  FRESULT Result;
  do
  {
    Result = f_mkfs(DriveNumber,PartitioningRule,AllocSize);
 800576e:	79fa      	ldrb	r2, [r7, #7]
 8005770:	79bb      	ldrb	r3, [r7, #6]
 8005772:	4610      	mov	r0, r2
 8005774:	4619      	mov	r1, r3
 8005776:	683a      	ldr	r2, [r7, #0]
 8005778:	f009 fba2 	bl	800eec0 <f_mkfs>
 800577c:	4603      	mov	r3, r0
 800577e:	72fb      	strb	r3, [r7, #11]
/* <<<DD_SLTHA001_API_13_1>>> */
    if(Result != FR_OK)
 8005780:	7afb      	ldrb	r3, [r7, #11]
 8005782:	2b00      	cmp	r3, #0
 8005784:	d00b      	beq.n	800579e <mkfs+0x46>
    {
      errno = ErrorCodes[Result];
 8005786:	f01d f8e3 	bl	8022950 <__errno>
 800578a:	4602      	mov	r2, r0
 800578c:	7af9      	ldrb	r1, [r7, #11]
 800578e:	f246 6374 	movw	r3, #26228	; 0x6674
 8005792:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005796:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 800579a:	6013      	str	r3, [r2, #0]
      break;
 800579c:	e002      	b.n	80057a4 <mkfs+0x4c>
    }
    Status = DAVEApp_SUCCESS;
 800579e:	f04f 0300 	mov.w	r3, #0
 80057a2:	60fb      	str	r3, [r7, #12]
  }while(0);
#endif
  return Status;
 80057a4:	68fb      	ldr	r3, [r7, #12]
}
 80057a6:	4618      	mov	r0, r3
 80057a8:	f107 0710 	add.w	r7, r7, #16
 80057ac:	46bd      	mov	sp, r7
 80057ae:	bd80      	pop	{r7, pc}

080057b0 <mount>:
/* <<<DD_SLTHA001_API_14>>> */
/*
 * This function registers/unregisters a work area.
 */
int mount( uint8_t DriveNumber, FATFS *FatFSObj)
{
 80057b0:	b580      	push	{r7, lr}
 80057b2:	b084      	sub	sp, #16
 80057b4:	af00      	add	r7, sp, #0
 80057b6:	4603      	mov	r3, r0
 80057b8:	6039      	str	r1, [r7, #0]
 80057ba:	71fb      	strb	r3, [r7, #7]
  FRESULT Result;
  int Status = FILE_WRAPPER_ERROR;
 80057bc:	f04f 33ff 	mov.w	r3, #4294967295
 80057c0:	60fb      	str	r3, [r7, #12]
  do
  {
    Result = f_mount(DriveNumber,FatFSObj);
 80057c2:	79fb      	ldrb	r3, [r7, #7]
 80057c4:	4618      	mov	r0, r3
 80057c6:	6839      	ldr	r1, [r7, #0]
 80057c8:	f007 fc50 	bl	800d06c <f_mount>
 80057cc:	4603      	mov	r3, r0
 80057ce:	72fb      	strb	r3, [r7, #11]
/* <<<DD_SLTHA001_API_14_1>>> */
    if(Result != FR_OK)
 80057d0:	7afb      	ldrb	r3, [r7, #11]
 80057d2:	2b00      	cmp	r3, #0
 80057d4:	d00b      	beq.n	80057ee <mount+0x3e>
    {
      errno = ErrorCodes[Result];
 80057d6:	f01d f8bb 	bl	8022950 <__errno>
 80057da:	4602      	mov	r2, r0
 80057dc:	7af9      	ldrb	r1, [r7, #11]
 80057de:	f246 6374 	movw	r3, #26228	; 0x6674
 80057e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057e6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80057ea:	6013      	str	r3, [r2, #0]
      break;
 80057ec:	e002      	b.n	80057f4 <mount+0x44>
    }
    Status = DAVEApp_SUCCESS;
 80057ee:	f04f 0300 	mov.w	r3, #0
 80057f2:	60fb      	str	r3, [r7, #12]
  }while(0);
  return  Status;
 80057f4:	68fb      	ldr	r3, [r7, #12]
}
 80057f6:	4618      	mov	r0, r3
 80057f8:	f107 0710 	add.w	r7, r7, #16
 80057fc:	46bd      	mov	sp, r7
 80057fe:	bd80      	pop	{r7, pc}

08005800 <_isatty>:
#if defined(__GNUC__)
int _isatty(int Fd)
#elif defined (__CC_ARM)
int _sys_istty(FILEHANDLE Fd)
#endif
{
 8005800:	b480      	push	{r7}
 8005802:	b083      	sub	sp, #12
 8005804:	af00      	add	r7, sp, #0
 8005806:	6078      	str	r0, [r7, #4]
  return (Fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
 8005808:	687b      	ldr	r3, [r7, #4]
 800580a:	2b02      	cmp	r3, #2
 800580c:	bfcc      	ite	gt
 800580e:	2300      	movgt	r3, #0
 8005810:	2301      	movle	r3, #1
 8005812:	b2db      	uxtb	r3, r3
}
 8005814:	4618      	mov	r0, r3
 8005816:	f107 070c 	add.w	r7, r7, #12
 800581a:	46bd      	mov	sp, r7
 800581c:	bc80      	pop	{r7}
 800581e:	4770      	bx	lr

08005820 <SLTHA001_Init>:
/*
 *  Function to Initialize all the local variables of Standard Librarry App 
 */
/* <<<DD_SLTHA001_API_16>>> */
void SLTHA001_Init()
{
 8005820:	b580      	push	{r7, lr}
 8005822:	af00      	add	r7, sp, #0
   SLTHA001_lLocalInitialize();
 8005824:	f7ff f824 	bl	8004870 <SLTHA001_lLocalInitialize>
}
 8005828:	bd80      	pop	{r7, pc}
 800582a:	bf00      	nop

0800582c <_link>:
/* This function establish a new name for an existing file. This function is
 * not supported by Fat File system.
 */
/* <<<DD_SLTHA001_API_17>>> */
int _link (char *OldName, char *NewName)
{
 800582c:	b580      	push	{r7, lr}
 800582e:	b082      	sub	sp, #8
 8005830:	af00      	add	r7, sp, #0
 8005832:	6078      	str	r0, [r7, #4]
 8005834:	6039      	str	r1, [r7, #0]
  errno = EMLINK;
 8005836:	f01d f88b 	bl	8022950 <__errno>
 800583a:	4603      	mov	r3, r0
 800583c:	f04f 021f 	mov.w	r2, #31
 8005840:	601a      	str	r2, [r3, #0]
  return -1;
 8005842:	f04f 33ff 	mov.w	r3, #4294967295
}
 8005846:	4618      	mov	r0, r3
 8005848:	f107 0708 	add.w	r7, r7, #8
 800584c:	46bd      	mov	sp, r7
 800584e:	bd80      	pop	{r7, pc}

08005850 <fdisk>:

/* This function creates a partition table into the MBR of the physical drive.
 */
/* <<<DD_SLTHA001_API_18>>> */
int fdisk( uint8_t DriveNumber, const uint32_t Partitions[], void * Work)
{
 8005850:	b480      	push	{r7}
 8005852:	b087      	sub	sp, #28
 8005854:	af00      	add	r7, sp, #0
 8005856:	4603      	mov	r3, r0
 8005858:	60b9      	str	r1, [r7, #8]
 800585a:	607a      	str	r2, [r7, #4]
 800585c:	73fb      	strb	r3, [r7, #15]
  int Status = FILE_WRAPPER_ERROR;
 800585e:	f04f 33ff 	mov.w	r3, #4294967295
 8005862:	617b      	str	r3, [r7, #20]
      break;
    }
    Status = DAVEApp_SUCCESS;
  } while(0);
#endif
  return  Status;
 8005864:	697b      	ldr	r3, [r7, #20]
}
 8005866:	4618      	mov	r0, r3
 8005868:	f107 071c 	add.w	r7, r7, #28
 800586c:	46bd      	mov	sp, r7
 800586e:	bc80      	pop	{r7}
 8005870:	4770      	bx	lr
 8005872:	bf00      	nop

08005874 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8005874:	b480      	push	{r7}
 8005876:	af00      	add	r7, sp, #0
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 8005878:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800587c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8005880:	68db      	ldr	r3, [r3, #12]
 8005882:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005886:	ea4f 2313 	mov.w	r3, r3, lsr #8
}
 800588a:	4618      	mov	r0, r3
 800588c:	46bd      	mov	sp, r7
 800588e:	bc80      	pop	{r7}
 8005890:	4770      	bx	lr
 8005892:	bf00      	nop

08005894 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8005894:	b480      	push	{r7}
 8005896:	b083      	sub	sp, #12
 8005898:	af00      	add	r7, sp, #0
 800589a:	4603      	mov	r3, r0
 800589c:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 800589e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80058a2:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80058a6:	f997 2007 	ldrsb.w	r2, [r7, #7]
 80058aa:	ea4f 1252 	mov.w	r2, r2, lsr #5
 80058ae:	79f9      	ldrb	r1, [r7, #7]
 80058b0:	f001 011f 	and.w	r1, r1, #31
 80058b4:	f04f 0001 	mov.w	r0, #1
 80058b8:	fa00 f101 	lsl.w	r1, r0, r1
 80058bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80058c0:	f107 070c 	add.w	r7, r7, #12
 80058c4:	46bd      	mov	sp, r7
 80058c6:	bc80      	pop	{r7}
 80058c8:	4770      	bx	lr
 80058ca:	bf00      	nop

080058cc <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 80058cc:	b480      	push	{r7}
 80058ce:	b083      	sub	sp, #12
 80058d0:	af00      	add	r7, sp, #0
 80058d2:	4603      	mov	r3, r0
 80058d4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
 80058d6:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80058da:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80058de:	f997 2007 	ldrsb.w	r2, [r7, #7]
 80058e2:	ea4f 1252 	mov.w	r2, r2, lsr #5
 80058e6:	79f9      	ldrb	r1, [r7, #7]
 80058e8:	f001 011f 	and.w	r1, r1, #31
 80058ec:	f04f 0001 	mov.w	r0, #1
 80058f0:	fa00 f101 	lsl.w	r1, r0, r1
 80058f4:	f102 0260 	add.w	r2, r2, #96	; 0x60
 80058f8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80058fc:	f107 070c 	add.w	r7, r7, #12
 8005900:	46bd      	mov	sp, r7
 8005902:	bc80      	pop	{r7}
 8005904:	4770      	bx	lr
 8005906:	bf00      	nop

08005908 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8005908:	b480      	push	{r7}
 800590a:	b083      	sub	sp, #12
 800590c:	af00      	add	r7, sp, #0
 800590e:	4603      	mov	r3, r0
 8005910:	6039      	str	r1, [r7, #0]
 8005912:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8005914:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8005918:	2b00      	cmp	r3, #0
 800591a:	da10      	bge.n	800593e <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800591c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8005920:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8005924:	79fa      	ldrb	r2, [r7, #7]
 8005926:	f002 020f 	and.w	r2, r2, #15
 800592a:	f1a2 0104 	sub.w	r1, r2, #4
 800592e:	683a      	ldr	r2, [r7, #0]
 8005930:	b2d2      	uxtb	r2, r2
 8005932:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8005936:	b2d2      	uxtb	r2, r2
 8005938:	185b      	adds	r3, r3, r1
 800593a:	761a      	strb	r2, [r3, #24]
 800593c:	e00d      	b.n	800595a <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800593e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8005942:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8005946:	f997 1007 	ldrsb.w	r1, [r7, #7]
 800594a:	683a      	ldr	r2, [r7, #0]
 800594c:	b2d2      	uxtb	r2, r2
 800594e:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8005952:	b2d2      	uxtb	r2, r2
 8005954:	185b      	adds	r3, r3, r1
 8005956:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800595a:	f107 070c 	add.w	r7, r7, #12
 800595e:	46bd      	mov	sp, r7
 8005960:	bc80      	pop	{r7}
 8005962:	4770      	bx	lr

08005964 <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8005964:	b480      	push	{r7}
 8005966:	b089      	sub	sp, #36	; 0x24
 8005968:	af00      	add	r7, sp, #0
 800596a:	60f8      	str	r0, [r7, #12]
 800596c:	60b9      	str	r1, [r7, #8]
 800596e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
 8005970:	68fb      	ldr	r3, [r7, #12]
 8005972:	f003 0307 	and.w	r3, r3, #7
 8005976:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 8005978:	69fb      	ldr	r3, [r7, #28]
 800597a:	f1c3 0307 	rsb	r3, r3, #7
 800597e:	2b06      	cmp	r3, #6
 8005980:	bf28      	it	cs
 8005982:	2306      	movcs	r3, #6
 8005984:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 8005986:	69fb      	ldr	r3, [r7, #28]
 8005988:	f103 0306 	add.w	r3, r3, #6
 800598c:	2b06      	cmp	r3, #6
 800598e:	d903      	bls.n	8005998 <NVIC_EncodePriority+0x34>
 8005990:	69fb      	ldr	r3, [r7, #28]
 8005992:	f103 33ff 	add.w	r3, r3, #4294967295
 8005996:	e001      	b.n	800599c <NVIC_EncodePriority+0x38>
 8005998:	f04f 0300 	mov.w	r3, #0
 800599c:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 800599e:	69bb      	ldr	r3, [r7, #24]
 80059a0:	f04f 0201 	mov.w	r2, #1
 80059a4:	fa02 f303 	lsl.w	r3, r2, r3
 80059a8:	f103 33ff 	add.w	r3, r3, #4294967295
 80059ac:	461a      	mov	r2, r3
 80059ae:	68bb      	ldr	r3, [r7, #8]
 80059b0:	401a      	ands	r2, r3
 80059b2:	697b      	ldr	r3, [r7, #20]
 80059b4:	fa02 f203 	lsl.w	r2, r2, r3
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 80059b8:	697b      	ldr	r3, [r7, #20]
 80059ba:	f04f 0101 	mov.w	r1, #1
 80059be:	fa01 f303 	lsl.w	r3, r1, r3
 80059c2:	f103 33ff 	add.w	r3, r3, #4294967295
 80059c6:	4619      	mov	r1, r3
 80059c8:	687b      	ldr	r3, [r7, #4]
 80059ca:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

  return (
 80059cc:	4313      	orrs	r3, r2
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}
 80059ce:	4618      	mov	r0, r3
 80059d0:	f107 0724 	add.w	r7, r7, #36	; 0x24
 80059d4:	46bd      	mov	sp, r7
 80059d6:	bc80      	pop	{r7}
 80059d8:	4770      	bx	lr
 80059da:	bf00      	nop

080059dc <SDMMC003_HostControllerInit>:
/*
 * The function initializes the Host Controller with the reset values and
 * configure values in the Host Controller registers.
 */
status_t SDMMC003_HostControllerInit(void)
{
 80059dc:	b580      	push	{r7, lr}
 80059de:	b082      	sub	sp, #8
 80059e0:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t) DAVEApp_SUCCESS;
 80059e2:	f04f 0300 	mov.w	r3, #0
 80059e6:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
/*<<<DD_SDMMC_API_1_1>>> */
    /* Check Host Controller is initialized or not */
    if ((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) != 0)
 80059e8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80059ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059f0:	881b      	ldrh	r3, [r3, #0]
 80059f2:	b29b      	uxth	r3, r3
 80059f4:	f003 0320 	and.w	r3, r3, #32
 80059f8:	2b00      	cmp	r3, #0
 80059fa:	d003      	beq.n	8005a04 <SDMMC003_HostControllerInit+0x28>
    {
      Status = (uint32_t)SDMMC003_HOST_CONTROLLER_INITIALIZED;
 80059fc:	f04f 032c 	mov.w	r3, #44	; 0x2c
 8005a00:	607b      	str	r3, [r7, #4]
      break;
 8005a02:	e063      	b.n	8005acc <SDMMC003_HostControllerInit+0xf0>
    }
    /* 1. Reset the registers to default values in Software Reset Control
     * Register
     */
/*<<<DD_SDMMC_API_1_2>>> */
    Status  = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_ALL_Msk );
 8005a04:	f04f 0001 	mov.w	r0, #1
 8005a08:	f000 ff00 	bl	800680c <SDMMC003_lReset>
 8005a0c:	6078      	str	r0, [r7, #4]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005a0e:	687b      	ldr	r3, [r7, #4]
 8005a10:	2b00      	cmp	r3, #0
 8005a12:	d15a      	bne.n	8005aca <SDMMC003_HostControllerInit+0xee>
    {
      break;
    }
    /* Set Clock Control  register */
    SDMMC->CLOCK_CTRL |= ((SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL_Msk & \
 8005a14:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005a18:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005a1c:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005a20:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8005a24:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
 8005a26:	b292      	uxth	r2, r2
 8005a28:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005a2c:	f042 0201 	orr.w	r2, r2, #1
 8005a30:	b292      	uxth	r2, r2
 8005a32:	859a      	strh	r2, [r3, #44]	; 0x2c
                          (SDMMC003_CTRL_SDCLK_FREQ_SEL_VALUE << \
                          SDMMC_CLOCK_CTRL_SDCLK_FREQ_SEL_Pos)) | \
                          (SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_EN_Msk) \
    );
    /* Set Normal Interrupt Status Enable & Error Interrupt Status Enable register */
    SDMMC->EN_INT_STATUS_NORM = SDMMC003_NORMAL_INT_STATUS_ENABLE;
 8005a34:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005a38:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005a3c:	f04f 02f3 	mov.w	r2, #243	; 0xf3
 8005a40:	869a      	strh	r2, [r3, #52]	; 0x34
    SDMMC->EN_INT_STATUS_ERR = SDMMC003_ERROR_INT_STATUS_ENABLE ;
 8005a42:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005a46:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005a4a:	f24e 02ff 	movw	r2, #57599	; 0xe0ff
 8005a4e:	86da      	strh	r2, [r3, #54]	; 0x36

    /* Set Interrupt Signal Enable & Error Interrupt Signal Enable register*/
    SDMMC->EN_INT_SIGNAL_NORM = SDMMC003_NORMAL_INT_SIGNAL_ENABLE;
 8005a50:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005a54:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005a58:	f04f 0233 	mov.w	r2, #51	; 0x33
 8005a5c:	871a      	strh	r2, [r3, #56]	; 0x38
    SDMMC->EN_INT_SIGNAL_ERR = SDMMC003_ERROR_INT_SIGNAL_ENABLE;
 8005a5e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005a62:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005a66:	f24e 02ff 	movw	r2, #57599	; 0xe0ff
 8005a6a:	875a      	strh	r2, [r3, #58]	; 0x3a

    /* Set Timeout Control Register */
    SDMMC->TIMEOUT_CTRL |= ( SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL_Msk &\
 8005a6c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005a70:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005a74:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005a78:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8005a7c:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
 8005a80:	b2d2      	uxtb	r2, r2
 8005a82:	f042 020e 	orr.w	r2, r2, #14
 8005a86:	b2d2      	uxtb	r2, r2
 8005a88:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
                                 ( SDMMC003_CTRL_DAT_TIMEOUT_CNT_VAL_VALUE << \
                                    SDMMC_TIMEOUT_CTRL_DAT_TIMEOUT_CNT_VAL_Pos )\
                                 );
   /* Set bus voltage in the Power Control Register */
    SDMMC->POWER_CTRL |= ( SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL_Msk &\
 8005a8c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005a90:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005a94:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005a98:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8005a9c:	f892 2029 	ldrb.w	r2, [r2, #41]	; 0x29
 8005aa0:	b2d2      	uxtb	r2, r2
 8005aa2:	f042 020e 	orr.w	r2, r2, #14
 8005aa6:	b2d2      	uxtb	r2, r2
 8005aa8:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
                           (SDMMC003_CTRL_SD_BUS_VOLTAGE_SEL_VALUE  << \
                            SDMMC_POWER_CTRL_SD_BUS_VOLTAGE_SEL_Pos )
                          );
    /* Update the state status to card initialized  */
    SDMMC003_Handle.State |= (SDMMC003_STATE_HC_INITIALIZED | SDMMC003_STATE_NO_CARD) ;
 8005aac:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005ab0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ab4:	881b      	ldrh	r3, [r3, #0]
 8005ab6:	b29b      	uxth	r3, r3
 8005ab8:	f043 0322 	orr.w	r3, r3, #34	; 0x22
 8005abc:	b29a      	uxth	r2, r3
 8005abe:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005ac2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ac6:	801a      	strh	r2, [r3, #0]
 8005ac8:	e000      	b.n	8005acc <SDMMC003_HostControllerInit+0xf0>
     */
/*<<<DD_SDMMC_API_1_2>>> */
    Status  = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_ALL_Msk );
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8005aca:	bf00      	nop
    SDMMC003_Handle.State |= (SDMMC003_STATE_HC_INITIALIZED | SDMMC003_STATE_NO_CARD) ;
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8005acc:	687b      	ldr	r3, [r7, #4]
}
 8005ace:	4618      	mov	r0, r3
 8005ad0:	f107 0708 	add.w	r7, r7, #8
 8005ad4:	46bd      	mov	sp, r7
 8005ad6:	bd80      	pop	{r7, pc}

08005ad8 <SDMMC003_HostControllerDeInit>:
/* <<<DD_SDMMC_API_2 >>> */
/*
 * The function de-initialize the Host Controller to the reset values.
 */
status_t  SDMMC003_HostControllerDeInit(void)
{
 8005ad8:	b580      	push	{r7, lr}
 8005ada:	b082      	sub	sp, #8
 8005adc:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8005ade:	f04f 0301 	mov.w	r3, #1
 8005ae2:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
/* <<<DD_SDMMC_API_2_1>>> */
    /* Check the host controller is initialized or not */
    if((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) == 0)
 8005ae4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005aec:	881b      	ldrh	r3, [r3, #0]
 8005aee:	b29b      	uxth	r3, r3
 8005af0:	f003 0320 	and.w	r3, r3, #32
 8005af4:	2b00      	cmp	r3, #0
 8005af6:	d00d      	beq.n	8005b14 <SDMMC003_HostControllerDeInit+0x3c>
    {
      break;
    }/*End of"if((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED)== 0)"*/
    /* Cleanup the card. */
    SDMMC003_lCardCleanUp();
 8005af8:	f000 fece 	bl	8006898 <SDMMC003_lCardCleanUp>
    /* Reset the Host Controller registers */
/* <<<DD_SDMMC_API_2_2>>> */
    Status = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_ALL_Msk );
 8005afc:	f04f 0001 	mov.w	r0, #1
 8005b00:	f000 fe84 	bl	800680c <SDMMC003_lReset>
 8005b04:	6078      	str	r0, [r7, #4]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005b06:	687b      	ldr	r3, [r7, #4]
 8005b08:	2b00      	cmp	r3, #0
 8005b0a:	d105      	bne.n	8005b18 <SDMMC003_HostControllerDeInit+0x40>
    {
      break;
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
 8005b0c:	f04f 0300 	mov.w	r3, #0
 8005b10:	607b      	str	r3, [r7, #4]
 8005b12:	e002      	b.n	8005b1a <SDMMC003_HostControllerDeInit+0x42>
  {
/* <<<DD_SDMMC_API_2_1>>> */
    /* Check the host controller is initialized or not */
    if((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) == 0)
    {
      break;
 8005b14:	bf00      	nop
 8005b16:	e000      	b.n	8005b1a <SDMMC003_HostControllerDeInit+0x42>
    /* Reset the Host Controller registers */
/* <<<DD_SDMMC_API_2_2>>> */
    Status = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_ALL_Msk );
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8005b18:	bf00      	nop
    Status = (uint32_t)DAVEApp_SUCCESS;
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8005b1a:	687b      	ldr	r3, [r7, #4]
}
 8005b1c:	4618      	mov	r0, r3
 8005b1e:	f107 0708 	add.w	r7, r7, #8
 8005b22:	46bd      	mov	sp, r7
 8005b24:	bd80      	pop	{r7, pc}
 8005b26:	bf00      	nop

08005b28 <SDMMC003_CardReadMultipleBlocks>:
(
  uint32_t  *ReadBufPtr,
  uint32_t  ReadAddr,
  uint32_t  NumberOfBlocks
)
{
 8005b28:	b580      	push	{r7, lr}
 8005b2a:	b088      	sub	sp, #32
 8005b2c:	af02      	add	r7, sp, #8
 8005b2e:	60f8      	str	r0, [r7, #12]
 8005b30:	60b9      	str	r1, [r7, #8]
 8005b32:	607a      	str	r2, [r7, #4]
  status_t Status = (uint32_t)SDMMC003_READ_ERROR;
 8005b34:	f04f 0322 	mov.w	r3, #34	; 0x22
 8005b38:	617b      	str	r3, [r7, #20]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;
 8005b3a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005b3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b42:	f04f 0201 	mov.w	r2, #1
 8005b46:	711a      	strb	r2, [r3, #4]
    SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;
 8005b48:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b50:	f04f 0201 	mov.w	r2, #1
 8005b54:	70da      	strb	r2, [r3, #3]
    SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;
 8005b56:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005b5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b5e:	f04f 0201 	mov.w	r2, #1
 8005b62:	715a      	strb	r2, [r3, #5]
/* <<<DD_SDMMC_API_3_1>>> */    
    /*Check Whether Initialization Process is successful */
    if (SDMMC003_Handle.InitializeFlag != 1 )
 8005b64:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005b68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b6c:	7a1b      	ldrb	r3, [r3, #8]
 8005b6e:	b2db      	uxtb	r3, r3
 8005b70:	2b01      	cmp	r3, #1
 8005b72:	d003      	beq.n	8005b7c <SDMMC003_CardReadMultipleBlocks+0x54>
    {
      Status = (uint32_t)SDMMC003_INIT_FAIL;     
 8005b74:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8005b78:	617b      	str	r3, [r7, #20]
      break;
 8005b7a:	e030      	b.n	8005bde <SDMMC003_CardReadMultipleBlocks+0xb6>
    }
/* <<<DD_SDMMC_API_3_2>>> */
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(ReadAddr,NumberOfBlocks);
 8005b7c:	68bb      	ldr	r3, [r7, #8]
 8005b7e:	4618      	mov	r0, r3
 8005b80:	6879      	ldr	r1, [r7, #4]
 8005b82:	f002 fde3 	bl	800874c <SDMMC003_lCheckSectorBound>
 8005b86:	6178      	str	r0, [r7, #20]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005b88:	697b      	ldr	r3, [r7, #20]
 8005b8a:	2b00      	cmp	r3, #0
 8005b8c:	d126      	bne.n	8005bdc <SDMMC003_CardReadMultipleBlocks+0xb4>
    {
      break;
    }
    /* Set transfer direction select in the Transfer Mode Register */
    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
 8005b8e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005b92:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005b96:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005b9a:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8005b9e:	8992      	ldrh	r2, [r2, #12]
 8005ba0:	b292      	uxth	r2, r2
 8005ba2:	f042 0210 	orr.w	r2, r2, #16
 8005ba6:	b292      	uxth	r2, r2
 8005ba8:	819a      	strh	r2, [r3, #12]
/* <<<DD_SDMMC_API_3_3>>> */
    /* Send Multiple Block  Read Command i.e CMD18 */
    Status = SDMMC003_lMultiBlockTransfer( &ReadAddr, \
                                           NumberOfBlocks, \
                                           &(SDMMC003_COMMON_COMMAND(18)), \
 8005baa:	f246 6304 	movw	r3, #26116	; 0x6604
 8005bae:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005bb2:	7c9b      	ldrb	r3, [r3, #18]
    }
    /* Set transfer direction select in the Transfer Mode Register */
    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
/* <<<DD_SDMMC_API_3_3>>> */
    /* Send Multiple Block  Read Command i.e CMD18 */
    Status = SDMMC003_lMultiBlockTransfer( &ReadAddr, \
 8005bb4:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8005bb8:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8005bbc:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005bc0:	18d3      	adds	r3, r2, r3
 8005bc2:	f107 0208 	add.w	r2, r7, #8
 8005bc6:	f04f 0101 	mov.w	r1, #1
 8005bca:	9100      	str	r1, [sp, #0]
 8005bcc:	4610      	mov	r0, r2
 8005bce:	6879      	ldr	r1, [r7, #4]
 8005bd0:	461a      	mov	r2, r3
 8005bd2:	68fb      	ldr	r3, [r7, #12]
 8005bd4:	f001 fe0a 	bl	80077ec <SDMMC003_lMultiBlockTransfer>
 8005bd8:	6178      	str	r0, [r7, #20]
 8005bda:	e000      	b.n	8005bde <SDMMC003_CardReadMultipleBlocks+0xb6>
/* <<<DD_SDMMC_API_3_2>>> */
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(ReadAddr,NumberOfBlocks);
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8005bdc:	bf00      	nop
                                           SDMMC003_READ_FROM_BUFF);
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8005bde:	697b      	ldr	r3, [r7, #20]
}
 8005be0:	4618      	mov	r0, r3
 8005be2:	f107 0718 	add.w	r7, r7, #24
 8005be6:	46bd      	mov	sp, r7
 8005be8:	bd80      	pop	{r7, pc}
 8005bea:	bf00      	nop

08005bec <SDMMC003_CardReadSingleBlock>:
status_t SDMMC003_CardReadSingleBlock
(
  uint32_t *ReadBufPtr,
  uint32_t  ReadAddr
)
{
 8005bec:	b580      	push	{r7, lr}
 8005bee:	b086      	sub	sp, #24
 8005bf0:	af02      	add	r7, sp, #8
 8005bf2:	6078      	str	r0, [r7, #4]
 8005bf4:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)SDMMC003_READ_ERROR;
 8005bf6:	f04f 0322 	mov.w	r3, #34	; 0x22
 8005bfa:	60fb      	str	r3, [r7, #12]
  uint32_t SectorCount = 1UL;
 8005bfc:	f04f 0301 	mov.w	r3, #1
 8005c00:	60bb      	str	r3, [r7, #8]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
/* <<<DD_SDMMC_API_4_1>>> */
    /*Check Whether Initialization Process is successful */
    if (SDMMC003_Handle.InitializeFlag != 1 )
 8005c02:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005c06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c0a:	7a1b      	ldrb	r3, [r3, #8]
 8005c0c:	b2db      	uxtb	r3, r3
 8005c0e:	2b01      	cmp	r3, #1
 8005c10:	d003      	beq.n	8005c1a <SDMMC003_CardReadSingleBlock+0x2e>
    {
      Status = (uint32_t)SDMMC003_INIT_FAIL;
 8005c12:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8005c16:	60fb      	str	r3, [r7, #12]
      break;
 8005c18:	e03c      	b.n	8005c94 <SDMMC003_CardReadSingleBlock+0xa8>
    }
/* <<<DD_SDMMC_API_4_2>>> */
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(ReadAddr,SectorCount);
 8005c1a:	6838      	ldr	r0, [r7, #0]
 8005c1c:	68b9      	ldr	r1, [r7, #8]
 8005c1e:	f002 fd95 	bl	800874c <SDMMC003_lCheckSectorBound>
 8005c22:	60f8      	str	r0, [r7, #12]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005c24:	68fb      	ldr	r3, [r7, #12]
 8005c26:	2b00      	cmp	r3, #0
 8005c28:	d133      	bne.n	8005c92 <SDMMC003_CardReadSingleBlock+0xa6>
    {
      break;
    }
/* <<<DD_SDMMC_API_4_3>>> */
    /* Block Addressing or Byte Addressing */
    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)
 8005c2a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005c2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c32:	789b      	ldrb	r3, [r3, #2]
 8005c34:	b2db      	uxtb	r3, r3
 8005c36:	f003 0308 	and.w	r3, r3, #8
 8005c3a:	2b00      	cmp	r3, #0
 8005c3c:	d103      	bne.n	8005c46 <SDMMC003_CardReadSingleBlock+0x5a>
    {
      ReadAddr *= 512UL;
 8005c3e:	683b      	ldr	r3, [r7, #0]
 8005c40:	ea4f 2343 	mov.w	r3, r3, lsl #9
 8005c44:	603b      	str	r3, [r7, #0]
    } /*End of "if((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING)== 0UL)"*/
    /* Set Direction select in transfer mode register */
    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
 8005c46:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005c4a:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005c4e:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005c52:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8005c56:	8992      	ldrh	r2, [r2, #12]
 8005c58:	b292      	uxth	r2, r2
 8005c5a:	f042 0210 	orr.w	r2, r2, #16
 8005c5e:	b292      	uxth	r2, r2
 8005c60:	819a      	strh	r2, [r3, #12]
    /* Perform the Single block transfer operation */
/* <<<DD_SDMMC_API_4_4>>> */
    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_COMMON_COMMAND(17)), \
 8005c62:	f246 6304 	movw	r3, #26116	; 0x6604
 8005c66:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005c6a:	7c5b      	ldrb	r3, [r3, #17]
 8005c6c:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8005c70:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8005c74:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005c78:	18d3      	adds	r3, r2, r3
 8005c7a:	f04f 0201 	mov.w	r2, #1
 8005c7e:	9200      	str	r2, [sp, #0]
 8005c80:	4618      	mov	r0, r3
 8005c82:	6839      	ldr	r1, [r7, #0]
 8005c84:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c88:	687b      	ldr	r3, [r7, #4]
 8005c8a:	f001 fdfd 	bl	8007888 <SDMMC003_lSingleBlockTransfer>
 8005c8e:	60f8      	str	r0, [r7, #12]
 8005c90:	e000      	b.n	8005c94 <SDMMC003_CardReadSingleBlock+0xa8>
/* <<<DD_SDMMC_API_4_2>>> */
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(ReadAddr,SectorCount);
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8005c92:	bf00      	nop
                                            SDMMC003_READ_FROM_BUFF  );
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8005c94:	68fb      	ldr	r3, [r7, #12]
}
 8005c96:	4618      	mov	r0, r3
 8005c98:	f107 0710 	add.w	r7, r7, #16
 8005c9c:	46bd      	mov	sp, r7
 8005c9e:	bd80      	pop	{r7, pc}

08005ca0 <SDMMC003_CardWriteMultipleBlocks>:
(
  const uint32_t *WriteBufPtr,
  uint32_t WriteAddr,
  uint32_t NumberOfBlocks
)
{
 8005ca0:	b580      	push	{r7, lr}
 8005ca2:	b088      	sub	sp, #32
 8005ca4:	af02      	add	r7, sp, #8
 8005ca6:	60f8      	str	r0, [r7, #12]
 8005ca8:	60b9      	str	r1, [r7, #8]
 8005caa:	607a      	str	r2, [r7, #4]
  status_t Status = (uint32_t)SDMMC003_WRITE_ERROR; 
 8005cac:	f04f 0323 	mov.w	r3, #35	; 0x23
 8005cb0:	617b      	str	r3, [r7, #20]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;
 8005cb2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005cb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cba:	f04f 0201 	mov.w	r2, #1
 8005cbe:	711a      	strb	r2, [r3, #4]
    SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;
 8005cc0:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005cc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cc8:	f04f 0201 	mov.w	r2, #1
 8005ccc:	70da      	strb	r2, [r3, #3]
    SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;
 8005cce:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005cd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cd6:	f04f 0201 	mov.w	r2, #1
 8005cda:	715a      	strb	r2, [r3, #5]
/* <<<DD_SDMMC_API_5_1>>> */    
    /*Check Whether Initialization Process is successfull */
    if (SDMMC003_Handle.InitializeFlag != 1 )
 8005cdc:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005ce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ce4:	7a1b      	ldrb	r3, [r3, #8]
 8005ce6:	b2db      	uxtb	r3, r3
 8005ce8:	2b01      	cmp	r3, #1
 8005cea:	d003      	beq.n	8005cf4 <SDMMC003_CardWriteMultipleBlocks+0x54>
    {
      Status = (uint32_t)SDMMC003_INIT_FAIL;
 8005cec:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8005cf0:	617b      	str	r3, [r7, #20]
      break;
 8005cf2:	e030      	b.n	8005d56 <SDMMC003_CardWriteMultipleBlocks+0xb6>
    }
/* <<<DD_SDMMC_API_5_2>>> */       
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(WriteAddr,NumberOfBlocks);
 8005cf4:	68bb      	ldr	r3, [r7, #8]
 8005cf6:	4618      	mov	r0, r3
 8005cf8:	6879      	ldr	r1, [r7, #4]
 8005cfa:	f002 fd27 	bl	800874c <SDMMC003_lCheckSectorBound>
 8005cfe:	6178      	str	r0, [r7, #20]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005d00:	697b      	ldr	r3, [r7, #20]
 8005d02:	2b00      	cmp	r3, #0
 8005d04:	d126      	bne.n	8005d54 <SDMMC003_CardWriteMultipleBlocks+0xb4>
    {
      break;
    }
/* Clear transfer direction select in Transfer Mode Register */
    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
 8005d06:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005d0a:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005d0e:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005d12:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8005d16:	8992      	ldrh	r2, [r2, #12]
 8005d18:	b292      	uxth	r2, r2
 8005d1a:	f022 0210 	bic.w	r2, r2, #16
 8005d1e:	b292      	uxth	r2, r2
 8005d20:	819a      	strh	r2, [r3, #12]

/* Send Multiple Block  Write  Command i.e CMD25 */
/* <<<DD_SDMMC_API_5_3>>> */
    Status = SDMMC003_lMultiBlockTransfer( &WriteAddr, \
                                           NumberOfBlocks,\
                                           &(SDMMC003_COMMON_COMMAND(25)),\
 8005d22:	f246 6304 	movw	r3, #26116	; 0x6604
 8005d26:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005d2a:	7e5b      	ldrb	r3, [r3, #25]
/* Clear transfer direction select in Transfer Mode Register */
    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);

/* Send Multiple Block  Write  Command i.e CMD25 */
/* <<<DD_SDMMC_API_5_3>>> */
    Status = SDMMC003_lMultiBlockTransfer( &WriteAddr, \
 8005d2c:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8005d30:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8005d34:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005d38:	18d3      	adds	r3, r2, r3
 8005d3a:	f107 0208 	add.w	r2, r7, #8
 8005d3e:	f04f 0102 	mov.w	r1, #2
 8005d42:	9100      	str	r1, [sp, #0]
 8005d44:	4610      	mov	r0, r2
 8005d46:	6879      	ldr	r1, [r7, #4]
 8005d48:	461a      	mov	r2, r3
 8005d4a:	68fb      	ldr	r3, [r7, #12]
 8005d4c:	f001 fd4e 	bl	80077ec <SDMMC003_lMultiBlockTransfer>
 8005d50:	6178      	str	r0, [r7, #20]
 8005d52:	e000      	b.n	8005d56 <SDMMC003_CardWriteMultipleBlocks+0xb6>
/* <<<DD_SDMMC_API_5_2>>> */       
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(WriteAddr,NumberOfBlocks);
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8005d54:	bf00      	nop
                                           SDMMC003_WRITE_INTO_BUFF);
    } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8005d56:	697b      	ldr	r3, [r7, #20]
}
 8005d58:	4618      	mov	r0, r3
 8005d5a:	f107 0718 	add.w	r7, r7, #24
 8005d5e:	46bd      	mov	sp, r7
 8005d60:	bd80      	pop	{r7, pc}
 8005d62:	bf00      	nop

08005d64 <SDMMC003_CardWriteSingleBlock>:
status_t SDMMC003_CardWriteSingleBlock
(
  const uint32_t *WriteBufPtr,
  uint32_t WriteAddr
)
{
 8005d64:	b580      	push	{r7, lr}
 8005d66:	b086      	sub	sp, #24
 8005d68:	af02      	add	r7, sp, #8
 8005d6a:	6078      	str	r0, [r7, #4]
 8005d6c:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)SDMMC003_WRITE_ERROR;
 8005d6e:	f04f 0323 	mov.w	r3, #35	; 0x23
 8005d72:	60fb      	str	r3, [r7, #12]
  uint32_t SectorCount = 1UL;
 8005d74:	f04f 0301 	mov.w	r3, #1
 8005d78:	60bb      	str	r3, [r7, #8]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
/* <<<DD_SDMMC_API_6_1>>> */    
    /*Check Whether Initialization Process is successful */
    if (SDMMC003_Handle.InitializeFlag != 1 )
 8005d7a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005d7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d82:	7a1b      	ldrb	r3, [r3, #8]
 8005d84:	b2db      	uxtb	r3, r3
 8005d86:	2b01      	cmp	r3, #1
 8005d88:	d003      	beq.n	8005d92 <SDMMC003_CardWriteSingleBlock+0x2e>
    {
      Status = (uint32_t)SDMMC003_INIT_FAIL;
 8005d8a:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8005d8e:	60fb      	str	r3, [r7, #12]
      break;
 8005d90:	e03c      	b.n	8005e0c <SDMMC003_CardWriteSingleBlock+0xa8>
    }
/* <<<DD_SDMMC_API_6_2>>> */    
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(WriteAddr,SectorCount);
 8005d92:	6838      	ldr	r0, [r7, #0]
 8005d94:	68b9      	ldr	r1, [r7, #8]
 8005d96:	f002 fcd9 	bl	800874c <SDMMC003_lCheckSectorBound>
 8005d9a:	60f8      	str	r0, [r7, #12]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005d9c:	68fb      	ldr	r3, [r7, #12]
 8005d9e:	2b00      	cmp	r3, #0
 8005da0:	d133      	bne.n	8005e0a <SDMMC003_CardWriteSingleBlock+0xa6>
    {
      break;
    }
    /* If not Block Addressing then multiply by 512 bytes. */
/* <<<DD_SDMMC_API_6_3>>> */
    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)
 8005da2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005daa:	789b      	ldrb	r3, [r3, #2]
 8005dac:	b2db      	uxtb	r3, r3
 8005dae:	f003 0308 	and.w	r3, r3, #8
 8005db2:	2b00      	cmp	r3, #0
 8005db4:	d103      	bne.n	8005dbe <SDMMC003_CardWriteSingleBlock+0x5a>
    {
      WriteAddr *= 512UL;
 8005db6:	683b      	ldr	r3, [r7, #0]
 8005db8:	ea4f 2343 	mov.w	r3, r3, lsl #9
 8005dbc:	603b      	str	r3, [r7, #0]
    } /*End of "if((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)"*/
    /* Clear Transfer Direction Select bit in Transfer Mode Register */
    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
 8005dbe:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8005dc2:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8005dc6:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8005dca:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8005dce:	8992      	ldrh	r2, [r2, #12]
 8005dd0:	b292      	uxth	r2, r2
 8005dd2:	f022 0210 	bic.w	r2, r2, #16
 8005dd6:	b292      	uxth	r2, r2
 8005dd8:	819a      	strh	r2, [r3, #12]
    /* Single Block Transfer function */
/* <<<DD_SDMMC_API_6_4>>> */
    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_COMMON_COMMAND(24)), \
 8005dda:	f246 6304 	movw	r3, #26116	; 0x6604
 8005dde:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005de2:	7e1b      	ldrb	r3, [r3, #24]
 8005de4:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8005de8:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8005dec:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005df0:	18d3      	adds	r3, r2, r3
 8005df2:	f04f 0202 	mov.w	r2, #2
 8005df6:	9200      	str	r2, [sp, #0]
 8005df8:	4618      	mov	r0, r3
 8005dfa:	6839      	ldr	r1, [r7, #0]
 8005dfc:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005e00:	687b      	ldr	r3, [r7, #4]
 8005e02:	f001 fd41 	bl	8007888 <SDMMC003_lSingleBlockTransfer>
 8005e06:	60f8      	str	r0, [r7, #12]
 8005e08:	e000      	b.n	8005e0c <SDMMC003_CardWriteSingleBlock+0xa8>
/* <<<DD_SDMMC_API_6_2>>> */    
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(WriteAddr,SectorCount);
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8005e0a:	bf00      	nop
                                            SDMMC003_WRITE_INTO_BUFF);
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8005e0c:	68fb      	ldr	r3, [r7, #12]
}
 8005e0e:	4618      	mov	r0, r3
 8005e10:	f107 0710 	add.w	r7, r7, #16
 8005e14:	46bd      	mov	sp, r7
 8005e16:	bd80      	pop	{r7, pc}

08005e18 <SDMMC003_EraseBlock>:
status_t SDMMC003_EraseBlock
(
  uint32_t StartAddr,
  uint32_t EndAddr
)
{
 8005e18:	b5b0      	push	{r4, r5, r7, lr}
 8005e1a:	b0a4      	sub	sp, #144	; 0x90
 8005e1c:	af00      	add	r7, sp, #0
 8005e1e:	6078      	str	r0, [r7, #4]
 8005e20:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8005e22:	f04f 0301 	mov.w	r3, #1
 8005e26:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  uint32_t NumOfSectors = 0;
 8005e2a:	f04f 0300 	mov.w	r3, #0
 8005e2e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 /* Alocation Unit to No. of Sectors in 1 AU table mapping*/
  uint32_t AuToSectors[10] = { 0,   32,  64,  128,  256,
 8005e32:	f246 538c 	movw	r3, #25996	; 0x658c
 8005e36:	f6c0 0302 	movt	r3, #2050	; 0x802
 8005e3a:	f107 044c 	add.w	r4, r7, #76	; 0x4c
 8005e3e:	461d      	mov	r5, r3
 8005e40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005e42:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8005e44:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005e46:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8005e48:	e895 0003 	ldmia.w	r5, {r0, r1}
 8005e4c:	e884 0003 	stmia.w	r4, {r0, r1}
                               512, 1024, 2048, 4096, 8192
                             };
  uint16_t EraseSize = 0;
 8005e50:	f04f 0300 	mov.w	r3, #0
 8005e54:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
  uint8_t EraseOffset = 0;
 8005e58:	f04f 0300 	mov.w	r3, #0
 8005e5c:	f887 3085 	strb.w	r3, [r7, #133]	; 0x85
  uint8_t EraseTimeout = 0;
 8005e60:	f04f 0300 	mov.w	r3, #0
 8005e64:	f887 3084 	strb.w	r3, [r7, #132]	; 0x84
  uint8_t AUSize = 0;
 8005e68:	f04f 0300 	mov.w	r3, #0
 8005e6c:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
  uint32_t SectorsInAu = 0;
 8005e70:	f04f 0300 	mov.w	r3, #0
 8005e74:	67fb      	str	r3, [r7, #124]	; 0x7c
  uint32_t SectorsInEraseCluster = 0;
 8005e76:	f04f 0300 	mov.w	r3, #0
 8005e7a:	67bb      	str	r3, [r7, #120]	; 0x78
  /* Read SD Status  */
  uint32_t SdStatus[16] = {0};
 8005e7c:	f107 020c 	add.w	r2, r7, #12
 8005e80:	f04f 0340 	mov.w	r3, #64	; 0x40
 8005e84:	4610      	mov	r0, r2
 8005e86:	f04f 0100 	mov.w	r1, #0
 8005e8a:	461a      	mov	r2, r3
 8005e8c:	f01d fd30 	bl	80238f0 <memset>
  uint32_t EraseTimeoutPerCluster = 0;
 8005e90:	f04f 0300 	mov.w	r3, #0
 8005e94:	677b      	str	r3, [r7, #116]	; 0x74
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;
 8005e96:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005e9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e9e:	f04f 0201 	mov.w	r2, #1
 8005ea2:	711a      	strb	r2, [r3, #4]
  SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;
 8005ea4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005ea8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005eac:	f04f 0201 	mov.w	r2, #1
 8005eb0:	70da      	strb	r2, [r3, #3]
  SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;
 8005eb2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005eb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005eba:	f04f 0201 	mov.w	r2, #1
 8005ebe:	715a      	strb	r2, [r3, #5]
  do
  {
/* <<<DD_SDMMC_API_7_1>>> */
    /*Check Whether Initialization Process is successful */
    if (SDMMC003_Handle.InitializeFlag != 1 )
 8005ec0:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8005ec4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ec8:	7a1b      	ldrb	r3, [r3, #8]
 8005eca:	b2db      	uxtb	r3, r3
 8005ecc:	2b01      	cmp	r3, #1
 8005ece:	d004      	beq.n	8005eda <SDMMC003_EraseBlock+0xc2>
    {
      Status = (uint32_t)SDMMC003_INIT_FAIL;
 8005ed0:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8005ed4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
      break;
 8005ed8:	e089      	b.n	8005fee <SDMMC003_EraseBlock+0x1d6>
    }
    NumOfSectors = EndAddr - StartAddr;
 8005eda:	683a      	ldr	r2, [r7, #0]
 8005edc:	687b      	ldr	r3, [r7, #4]
 8005ede:	1ad3      	subs	r3, r2, r3
 8005ee0:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
/* <<<DD_SDMMC_API_7_2>>> */    
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(StartAddr,NumOfSectors);
 8005ee4:	6878      	ldr	r0, [r7, #4]
 8005ee6:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8005eea:	f002 fc2f 	bl	800874c <SDMMC003_lCheckSectorBound>
 8005eee:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005ef2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8005ef6:	2b00      	cmp	r3, #0
 8005ef8:	d176      	bne.n	8005fe8 <SDMMC003_EraseBlock+0x1d0>
    {
      break;
    }
/* Erase Timeout Calculation */
/* Get SD Status */
    Status  = SDMMC003_GetSdStatus((void*)&(SdStatus[0]));
 8005efa:	f107 030c 	add.w	r3, r7, #12
 8005efe:	4618      	mov	r0, r3
 8005f00:	f000 fb82 	bl	8006608 <SDMMC003_GetSdStatus>
 8005f04:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
/* <<<DD_SDMMC_API_7_3>>> */
    if (Status != DAVEApp_SUCCESS)
 8005f08:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8005f0c:	2b00      	cmp	r3, #0
 8005f0e:	d16d      	bne.n	8005fec <SDMMC003_EraseBlock+0x1d4>
    {
      break;
    }
    /* Bits 400-401 in SD status is Erase Offset */
    EraseOffset =  ((SdStatus[3] & 0x00000300)) >> 8;
 8005f10:	69bb      	ldr	r3, [r7, #24]
 8005f12:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005f16:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8005f1a:	f887 3085 	strb.w	r3, [r7, #133]	; 0x85
    /* Bits 402-407 in SD status is Erase Timeout */
    EraseTimeout = ((SdStatus[3] & 0x0000FC00)) >> 10;
 8005f1e:	69bb      	ldr	r3, [r7, #24]
 8005f20:	f403 437c 	and.w	r3, r3, #64512	; 0xfc00
 8005f24:	ea4f 2393 	mov.w	r3, r3, lsr #10
 8005f28:	f887 3084 	strb.w	r3, [r7, #132]	; 0x84
    /* Bits 408-423 in SD status is Erase Size */
    EraseSize = ( (((SdStatus[2] & 0xFF000000) >> 24) << 8) | \
 8005f2c:	697b      	ldr	r3, [r7, #20]
 8005f2e:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8005f32:	b29b      	uxth	r3, r3
 8005f34:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8005f38:	b29a      	uxth	r2, r3
                   (SdStatus[3] & 0x000000FF) );
 8005f3a:	69bb      	ldr	r3, [r7, #24]
    /* Bits 400-401 in SD status is Erase Offset */
    EraseOffset =  ((SdStatus[3] & 0x00000300)) >> 8;
    /* Bits 402-407 in SD status is Erase Timeout */
    EraseTimeout = ((SdStatus[3] & 0x0000FC00)) >> 10;
    /* Bits 408-423 in SD status is Erase Size */
    EraseSize = ( (((SdStatus[2] & 0xFF000000) >> 24) << 8) | \
 8005f3c:	b29b      	uxth	r3, r3
 8005f3e:	b2db      	uxtb	r3, r3
 8005f40:	b29b      	uxth	r3, r3
 8005f42:	4313      	orrs	r3, r2
 8005f44:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
                   (SdStatus[3] & 0x000000FF) );
    /* Bits 428-431 in SD status is Allocation unit Size*/              
    AUSize  =    (( SdStatus[2] & 0x00F00000) >> 20);
 8005f48:	697b      	ldr	r3, [r7, #20]
 8005f4a:	f403 0370 	and.w	r3, r3, #15728640	; 0xf00000
 8005f4e:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8005f52:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
    /* Erase Timeout Calculations */
    EraseTimeoutPerCluster = (EraseTimeout/EraseSize) +  EraseOffset  ;
 8005f56:	f897 2084 	ldrb.w	r2, [r7, #132]	; 0x84
 8005f5a:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8005f5e:	fb92 f2f3 	sdiv	r2, r2, r3
 8005f62:	f897 3085 	ldrb.w	r3, [r7, #133]	; 0x85
 8005f66:	18d3      	adds	r3, r2, r3
 8005f68:	677b      	str	r3, [r7, #116]	; 0x74
    /* Number of Sectors in 1AU */
    SectorsInAu = AuToSectors[AUSize];
 8005f6a:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 8005f6e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8005f72:	f107 0290 	add.w	r2, r7, #144	; 0x90
 8005f76:	18d3      	adds	r3, r2, r3
 8005f78:	f853 3c44 	ldr.w	r3, [r3, #-68]
 8005f7c:	67fb      	str	r3, [r7, #124]	; 0x7c
    SectorsInEraseCluster = SectorsInAu * EraseSize;
 8005f7e:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8005f82:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8005f84:	fb02 f303 	mul.w	r3, r2, r3
 8005f88:	67bb      	str	r3, [r7, #120]	; 0x78
  if (Test_TriggerInterrupt.Trigger_TC23_1Error == TRUE)
  {
    Test_TriggerInterrupt.Trigger_EraseEndError = TRUE;
  }
#endif
    while (NumOfSectors > SectorsInEraseCluster)
 8005f8a:	e017      	b.n	8005fbc <SDMMC003_EraseBlock+0x1a4>
    {
      Status = SDMMC003_lLocalErase(StartAddr,(StartAddr + SectorsInEraseCluster), \
 8005f8c:	687a      	ldr	r2, [r7, #4]
 8005f8e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8005f90:	18d3      	adds	r3, r2, r3
 8005f92:	6878      	ldr	r0, [r7, #4]
 8005f94:	4619      	mov	r1, r3
 8005f96:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8005f98:	f002 fbfa 	bl	8008790 <SDMMC003_lLocalErase>
 8005f9c:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
                                    EraseTimeoutPerCluster);
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005fa0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8005fa4:	2b00      	cmp	r3, #0
 8005fa6:	d10f      	bne.n	8005fc8 <SDMMC003_EraseBlock+0x1b0>
      {
        break;
      }
      StartAddr  = StartAddr + SectorsInEraseCluster;
 8005fa8:	687a      	ldr	r2, [r7, #4]
 8005faa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8005fac:	18d3      	adds	r3, r2, r3
 8005fae:	607b      	str	r3, [r7, #4]
      NumOfSectors = NumOfSectors - SectorsInEraseCluster;
 8005fb0:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8005fb4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8005fb6:	1ad3      	subs	r3, r2, r3
 8005fb8:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  if (Test_TriggerInterrupt.Trigger_TC23_1Error == TRUE)
  {
    Test_TriggerInterrupt.Trigger_EraseEndError = TRUE;
  }
#endif
    while (NumOfSectors > SectorsInEraseCluster)
 8005fbc:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8005fc0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8005fc2:	429a      	cmp	r2, r3
 8005fc4:	d8e2      	bhi.n	8005f8c <SDMMC003_EraseBlock+0x174>
 8005fc6:	e000      	b.n	8005fca <SDMMC003_EraseBlock+0x1b2>
    {
      Status = SDMMC003_lLocalErase(StartAddr,(StartAddr + SectorsInEraseCluster), \
                                    EraseTimeoutPerCluster);
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 8005fc8:	bf00      	nop
      }
      StartAddr  = StartAddr + SectorsInEraseCluster;
      NumOfSectors = NumOfSectors - SectorsInEraseCluster;
    }
    if (NumOfSectors != 0 )
 8005fca:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8005fce:	2b00      	cmp	r3, #0
 8005fd0:	d00d      	beq.n	8005fee <SDMMC003_EraseBlock+0x1d6>
    {
      Status = SDMMC003_lLocalErase(StartAddr,EndAddr,EraseTimeoutPerCluster);
 8005fd2:	6878      	ldr	r0, [r7, #4]
 8005fd4:	6839      	ldr	r1, [r7, #0]
 8005fd6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8005fd8:	f002 fbda 	bl	8008790 <SDMMC003_lLocalErase>
 8005fdc:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 8005fe0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8005fe4:	2b00      	cmp	r3, #0
 8005fe6:	e002      	b.n	8005fee <SDMMC003_EraseBlock+0x1d6>
/* <<<DD_SDMMC_API_7_2>>> */    
    /* Check Sector number is not out of bound */
    Status = SDMMC003_lCheckSectorBound(StartAddr,NumOfSectors);
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8005fe8:	bf00      	nop
 8005fea:	e000      	b.n	8005fee <SDMMC003_EraseBlock+0x1d6>
/* Get SD Status */
    Status  = SDMMC003_GetSdStatus((void*)&(SdStatus[0]));
/* <<<DD_SDMMC_API_7_3>>> */
    if (Status != DAVEApp_SUCCESS)
    {
      break;
 8005fec:	bf00      	nop
    }
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8005fee:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
}
 8005ff2:	4618      	mov	r0, r3
 8005ff4:	f107 0790 	add.w	r7, r7, #144	; 0x90
 8005ff8:	46bd      	mov	sp, r7
 8005ffa:	bdb0      	pop	{r4, r5, r7, pc}

08005ffc <SDMMC003_LockUnlockCard>:
status_t  SDMMC003_LockUnlockCard
(
  SDMMC003_LocalLockStructType  *LockPtr,
  SDMMC003_CardLockMode OperationMode
)
{
 8005ffc:	b580      	push	{r7, lr}
 8005ffe:	b086      	sub	sp, #24
 8006000:	af02      	add	r7, sp, #8
 8006002:	6078      	str	r0, [r7, #4]
 8006004:	460b      	mov	r3, r1
 8006006:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8006008:	f04f 0301 	mov.w	r3, #1
 800600c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /*  Select the Card before proceeding */
    Status = SDMMC003_lSwitchToTransferState();
 800600e:	f002 f8d7 	bl	80081c0 <SDMMC003_lSwitchToTransferState>
 8006012:	60f8      	str	r0, [r7, #12]
/* <<< DD_SDMMC_API_8_1 >>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8006014:	68fb      	ldr	r3, [r7, #12]
 8006016:	2b00      	cmp	r3, #0
 8006018:	d12f      	bne.n	800607a <SDMMC003_LockUnlockCard+0x7e>
    {
      break;
    }/* End of "if(Status != DAVEApp_SUCCESS)" */
/*  Send Cmd42 and write the Lock data structure */
/*  Set Transfer Mode Register */
    CLR_BIT( SDMMC->TRANSFER_MODE, SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
 800601a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800601e:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006022:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8006026:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800602a:	8992      	ldrh	r2, [r2, #12]
 800602c:	b292      	uxth	r2, r2
 800602e:	f022 0210 	bic.w	r2, r2, #16
 8006032:	b292      	uxth	r2, r2
 8006034:	819a      	strh	r2, [r3, #12]
    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_COMMON_COMMAND(42)),\
 8006036:	f246 6304 	movw	r3, #26116	; 0x6604
 800603a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800603e:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8006042:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8006046:	f246 53b4 	movw	r3, #26036	; 0x65b4
 800604a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800604e:	18d3      	adds	r3, r2, r3
 8006050:	f04f 0202 	mov.w	r2, #2
 8006054:	9200      	str	r2, [sp, #0]
 8006056:	4618      	mov	r0, r3
 8006058:	f04f 0100 	mov.w	r1, #0
 800605c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006060:	687b      	ldr	r3, [r7, #4]
 8006062:	f001 fc11 	bl	8007888 <SDMMC003_lSingleBlockTransfer>
 8006066:	60f8      	str	r0, [r7, #12]
                                            SDMMC003_ARGUMENT0, 512, \
                                            (uint32_t *)LockPtr,\
                                            SDMMC003_WRITE_INTO_BUFF);
/* <<< DD_SDMMC_API_8_2 >>> */
    if(Status == (uint32_t)DAVEApp_SUCCESS)
 8006068:	68fb      	ldr	r3, [r7, #12]
 800606a:	2b00      	cmp	r3, #0
 800606c:	d106      	bne.n	800607c <SDMMC003_LockUnlockCard+0x80>
    {
      Status = SDMMC003_lCheckLockStatus(OperationMode);
 800606e:	78fb      	ldrb	r3, [r7, #3]
 8006070:	4618      	mov	r0, r3
 8006072:	f001 fc83 	bl	800797c <SDMMC003_lCheckLockStatus>
 8006076:	60f8      	str	r0, [r7, #12]
 8006078:	e000      	b.n	800607c <SDMMC003_LockUnlockCard+0x80>
    /*  Select the Card before proceeding */
    Status = SDMMC003_lSwitchToTransferState();
/* <<< DD_SDMMC_API_8_1 >>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 800607a:	bf00      	nop
    }/* End of "if(Status == DAVEApp_SUCCESS)" */
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 800607c:	68fb      	ldr	r3, [r7, #12]
}
 800607e:	4618      	mov	r0, r3
 8006080:	f107 0710 	add.w	r7, r7, #16
 8006084:	46bd      	mov	sp, r7
 8006086:	bd80      	pop	{r7, pc}

08006088 <SDMMC003_GetLockStatus>:
/* <<< DD_SDMMC_API_9 >>> */
/*
 * The function is used to get the lock status from the card.
 */
status_t  SDMMC003_GetLockStatus( uint32_t *LockStatusPtr)
{
 8006088:	b580      	push	{r7, lr}
 800608a:	b086      	sub	sp, #24
 800608c:	af00      	add	r7, sp, #0
 800608e:	6078      	str	r0, [r7, #4]
  uint32_t CardStatus = 0UL;
 8006090:	f04f 0300 	mov.w	r3, #0
 8006094:	60fb      	str	r3, [r7, #12]
  uint32_t Argument = 0;
 8006096:	f04f 0300 	mov.w	r3, #0
 800609a:	617b      	str	r3, [r7, #20]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 800609c:	f04f 0301 	mov.w	r3, #1
 80060a0:	613b      	str	r3, [r7, #16]
      SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);
      /* Disable the Command Complete Signal Interrupt */
      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
    }
#endif
    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
 80060a2:	f246 4334 	movw	r3, #25652	; 0x6434
 80060a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060aa:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 80060ac:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80060b0:	697a      	ldr	r2, [r7, #20]
 80060b2:	4313      	orrs	r3, r2
 80060b4:	617b      	str	r3, [r7, #20]
    /* Send Cmd13 to read card status  */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)), Argument, \
 80060b6:	f246 6304 	movw	r3, #26116	; 0x6604
 80060ba:	f6c0 0302 	movt	r3, #2050	; 0x802
 80060be:	7b5b      	ldrb	r3, [r3, #13]
 80060c0:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80060c4:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80060c8:	f6c0 0302 	movt	r3, #2050	; 0x802
 80060cc:	18d2      	adds	r2, r2, r3
                                    SDMMC003_RESPONSE_R1, &CardStatus);
 80060ce:	f107 030c 	add.w	r3, r7, #12
      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
    }
#endif
    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
    /* Send Cmd13 to read card status  */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)), Argument, \
 80060d2:	4610      	mov	r0, r2
 80060d4:	6979      	ldr	r1, [r7, #20]
 80060d6:	f04f 0201 	mov.w	r2, #1
 80060da:	f000 fe85 	bl	8006de8 <SDMMC003_lSendCommand>
 80060de:	6138      	str	r0, [r7, #16]
                                    SDMMC003_RESPONSE_R1, &CardStatus);
/* <<< DD_SDMMC_API_9_1 >>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 80060e0:	693b      	ldr	r3, [r7, #16]
 80060e2:	2b00      	cmp	r3, #0
 80060e4:	d10e      	bne.n	8006104 <SDMMC003_GetLockStatus+0x7c>
    {
      break;
    }
/* <<< DD_SDMMC_API_9_2 >>> */
    /* Lock/Unlock Status bit in the CSR Register */
    if ((CardStatus & SDMMC003_CSR_CARD_IS_LOCKED_BITMASK) != 0)
 80060e6:	68fb      	ldr	r3, [r7, #12]
 80060e8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80060ec:	2b00      	cmp	r3, #0
 80060ee:	d004      	beq.n	80060fa <SDMMC003_GetLockStatus+0x72>
    {
      *LockStatusPtr = (uint32_t)SDMMC003_CARD_IS_LOCKED;
 80060f0:	687b      	ldr	r3, [r7, #4]
 80060f2:	f04f 0220 	mov.w	r2, #32
 80060f6:	601a      	str	r2, [r3, #0]
 80060f8:	e005      	b.n	8006106 <SDMMC003_GetLockStatus+0x7e>
    }/* End of "if ((CardStatus & SDMMC003_CSR_CARD_IS_LOCKED_BITMASK) != 0)"*/
/* <<< DD_SDMMC_API_9_3 >>> */
    else
    {
      *LockStatusPtr = (uint32_t)SDMMC003_CARD_UNLOCKED;
 80060fa:	687b      	ldr	r3, [r7, #4]
 80060fc:	f04f 0221 	mov.w	r2, #33	; 0x21
 8006100:	601a      	str	r2, [r3, #0]
 8006102:	e000      	b.n	8006106 <SDMMC003_GetLockStatus+0x7e>
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)), Argument, \
                                    SDMMC003_RESPONSE_R1, &CardStatus);
/* <<< DD_SDMMC_API_9_1 >>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8006104:	bf00      	nop
    }
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8006106:	693b      	ldr	r3, [r7, #16]
}
 8006108:	4618      	mov	r0, r3
 800610a:	f107 0718 	add.w	r7, r7, #24
 800610e:	46bd      	mov	sp, r7
 8006110:	bd80      	pop	{r7, pc}
 8006112:	bf00      	nop

08006114 <SDMMC003_GetCurrentState>:
/* <<< DD_SDMMC_API_10 >>> */
/*
 * This function is use to  get card's current state.
 */
status_t SDMMC003_GetCurrentState()
{
 8006114:	b480      	push	{r7}
 8006116:	b083      	sub	sp, #12
 8006118:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)SDMMC003_STATE_NO_CARD;
 800611a:	f04f 0302 	mov.w	r3, #2
 800611e:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x,(uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<<DD_SDMMC_API_10_1>>> */
  if ((SDMMC003_Handle.State & SDMMC003_STATE_CARD_INITIALIZED))
 8006120:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006124:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006128:	881b      	ldrh	r3, [r3, #0]
 800612a:	b29b      	uxth	r3, r3
 800612c:	f003 0301 	and.w	r3, r3, #1
 8006130:	2b00      	cmp	r3, #0
 8006132:	d007      	beq.n	8006144 <SDMMC003_GetCurrentState+0x30>
  {
    Status &= ~(SDMMC003_STATE_NO_CARD);
 8006134:	687b      	ldr	r3, [r7, #4]
 8006136:	f023 0302 	bic.w	r3, r3, #2
 800613a:	607b      	str	r3, [r7, #4]
    Status |= SDMMC003_STATE_CARD_INITIALIZED;
 800613c:	687b      	ldr	r3, [r7, #4]
 800613e:	f043 0301 	orr.w	r3, r3, #1
 8006142:	607b      	str	r3, [r7, #4]
  }
/* <<<DD_SDMMC_API_10_2>>> */
  if ((SDMMC003_Handle.State & SDMMC003_STATE_CARD_WRITE_PROTECT) != 0)
 8006144:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006148:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800614c:	881b      	ldrh	r3, [r3, #0]
 800614e:	b29b      	uxth	r3, r3
 8006150:	f003 0310 	and.w	r3, r3, #16
 8006154:	2b00      	cmp	r3, #0
 8006156:	d003      	beq.n	8006160 <SDMMC003_GetCurrentState+0x4c>
  {
    Status |= SDMMC003_STATE_CARD_WRITE_PROTECT;
 8006158:	687b      	ldr	r3, [r7, #4]
 800615a:	f043 0310 	orr.w	r3, r3, #16
 800615e:	607b      	str	r3, [r7, #4]
  }
/* <<<DD_SDMMC_API_10_3>>> */
  if ((SDMMC003_Handle.State & SDMMC003_STATE_CARD_LOCKED) != 0)
 8006160:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006164:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006168:	881b      	ldrh	r3, [r3, #0]
 800616a:	b29b      	uxth	r3, r3
 800616c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006170:	2b00      	cmp	r3, #0
 8006172:	d003      	beq.n	800617c <SDMMC003_GetCurrentState+0x68>
  {
    Status |= SDMMC003_STATE_CARD_LOCKED;
 8006174:	687b      	ldr	r3, [r7, #4]
 8006176:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800617a:	607b      	str	r3, [r7, #4]
  }
/* <<<DD_SDMMC_API_10_4>>> */
  if ((SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) != 0)
 800617c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006180:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006184:	881b      	ldrh	r3, [r3, #0]
 8006186:	b29b      	uxth	r3, r3
 8006188:	f003 0320 	and.w	r3, r3, #32
 800618c:	2b00      	cmp	r3, #0
 800618e:	d003      	beq.n	8006198 <SDMMC003_GetCurrentState+0x84>
  {
    Status |= SDMMC003_STATE_HC_INITIALIZED;
 8006190:	687b      	ldr	r3, [r7, #4]
 8006192:	f043 0320 	orr.w	r3, r3, #32
 8006196:	607b      	str	r3, [r7, #4]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8006198:	687b      	ldr	r3, [r7, #4]
}
 800619a:	4618      	mov	r0, r3
 800619c:	f107 070c 	add.w	r7, r7, #12
 80061a0:	46bd      	mov	sp, r7
 80061a2:	bc80      	pop	{r7}
 80061a4:	4770      	bx	lr
 80061a6:	bf00      	nop

080061a8 <SDMMC003_GetCardType>:
/* <<< DD_SDMMC_API_11 >>> */
/*
 * This function is use to  get card type information
 */
status_t SDMMC003_GetCardType(uint32_t* CardTypePtr)
{
 80061a8:	b480      	push	{r7}
 80061aa:	b085      	sub	sp, #20
 80061ac:	af00      	add	r7, sp, #0
 80061ae:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 80061b0:	f04f 0300 	mov.w	r3, #0
 80061b4:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<< DD_SDMMC_API_11_1 >>> */  
  /*Check Whether Initialization Process is successful */
  if (SDMMC003_Handle.InitializeFlag != 1 )
 80061b6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80061ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061be:	7a1b      	ldrb	r3, [r3, #8]
 80061c0:	b2db      	uxtb	r3, r3
 80061c2:	2b01      	cmp	r3, #1
 80061c4:	d003      	beq.n	80061ce <SDMMC003_GetCardType+0x26>
  {
    Status = (uint32_t)SDMMC003_INIT_FAIL;
 80061c6:	f04f 032a 	mov.w	r3, #42	; 0x2a
 80061ca:	60fb      	str	r3, [r7, #12]
 80061cc:	e008      	b.n	80061e0 <SDMMC003_GetCardType+0x38>
  }
/* <<< DD_SDMMC_API_11_2 >>> */  
  else
  {
    *CardTypePtr = SDMMC003_Handle.CardType;
 80061ce:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80061d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061d6:	789b      	ldrb	r3, [r3, #2]
 80061d8:	b2db      	uxtb	r3, r3
 80061da:	461a      	mov	r2, r3
 80061dc:	687b      	ldr	r3, [r7, #4]
 80061de:	601a      	str	r2, [r3, #0]
  } 
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80061e0:	68fb      	ldr	r3, [r7, #12]
}
 80061e2:	4618      	mov	r0, r3
 80061e4:	f107 0714 	add.w	r7, r7, #20
 80061e8:	46bd      	mov	sp, r7
 80061ea:	bc80      	pop	{r7}
 80061ec:	4770      	bx	lr
 80061ee:	bf00      	nop

080061f0 <SDMMC003_GetCid>:

/* <<< DD_SDMMC_API_12 >>> */
/* This function is use to Get CID register information of card */
status_t SDMMC003_GetCid (void *Buffer)
{
 80061f0:	b480      	push	{r7}
 80061f2:	b085      	sub	sp, #20
 80061f4:	af00      	add	r7, sp, #0
 80061f6:	6078      	str	r0, [r7, #4]
  SDMMC003_SDCIDType* Tmp = (SDMMC003_SDCIDType*)Buffer;
 80061f8:	687b      	ldr	r3, [r7, #4]
 80061fa:	60bb      	str	r3, [r7, #8]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 80061fc:	f04f 0300 	mov.w	r3, #0
 8006200:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<< DD_SDMMC_API_12_1 >>> */
  /*Check Whether Initialization Process is successful */
  if (SDMMC003_Handle.InitializeFlag != 1 )
 8006202:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006206:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800620a:	7a1b      	ldrb	r3, [r3, #8]
 800620c:	b2db      	uxtb	r3, r3
 800620e:	2b01      	cmp	r3, #1
 8006210:	d003      	beq.n	800621a <SDMMC003_GetCid+0x2a>
  {
    Status = (uint32_t)SDMMC003_INIT_FAIL;
 8006212:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8006216:	60fb      	str	r3, [r7, #12]
 8006218:	e073      	b.n	8006302 <SDMMC003_GetCid+0x112>
  }
/* <<< DD_SDMMC_API_12_2 >>> */  
  else
  {
    Tmp->ManufacturingDate = (SDMMC003_CardInfo.CidArray[0])&0xFFF;
 800621a:	f246 4334 	movw	r3, #25652	; 0x6434
 800621e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006222:	685b      	ldr	r3, [r3, #4]
 8006224:	b29b      	uxth	r3, r3
 8006226:	ea4f 5303 	mov.w	r3, r3, lsl #20
 800622a:	ea4f 5313 	mov.w	r3, r3, lsr #20
 800622e:	b29a      	uxth	r2, r3
 8006230:	68bb      	ldr	r3, [r7, #8]
 8006232:	801a      	strh	r2, [r3, #0]
    Tmp->ProductSerialNum =  (SDMMC003_CardInfo.CidArray[1]<<16)| \
 8006234:	f246 4334 	movw	r3, #25652	; 0x6434
 8006238:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800623c:	689b      	ldr	r3, [r3, #8]
 800623e:	ea4f 4203 	mov.w	r2, r3, lsl #16
                             (SDMMC003_CardInfo.CidArray[0]>>16);
 8006242:	f246 4334 	movw	r3, #25652	; 0x6434
 8006246:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800624a:	685b      	ldr	r3, [r3, #4]
 800624c:	ea4f 4313 	mov.w	r3, r3, lsr #16
  }
/* <<< DD_SDMMC_API_12_2 >>> */  
  else
  {
    Tmp->ManufacturingDate = (SDMMC003_CardInfo.CidArray[0])&0xFFF;
    Tmp->ProductSerialNum =  (SDMMC003_CardInfo.CidArray[1]<<16)| \
 8006250:	431a      	orrs	r2, r3
 8006252:	68bb      	ldr	r3, [r7, #8]
 8006254:	605a      	str	r2, [r3, #4]
                             (SDMMC003_CardInfo.CidArray[0]>>16);
    Tmp->ProductRev =  (SDMMC003_CardInfo.CidArray[1]>>16)&0xff;
 8006256:	f246 4334 	movw	r3, #25652	; 0x6434
 800625a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800625e:	689b      	ldr	r3, [r3, #8]
 8006260:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8006264:	b2da      	uxtb	r2, r3
 8006266:	68bb      	ldr	r3, [r7, #8]
 8006268:	721a      	strb	r2, [r3, #8]
    Tmp->ProductName[0] =  (SDMMC003_CardInfo.CidArray[2]>>24)&0xff;
 800626a:	f246 4334 	movw	r3, #25652	; 0x6434
 800626e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006272:	68db      	ldr	r3, [r3, #12]
 8006274:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8006278:	b2da      	uxtb	r2, r3
 800627a:	68bb      	ldr	r3, [r7, #8]
 800627c:	725a      	strb	r2, [r3, #9]
    Tmp->ProductName[1] =  (SDMMC003_CardInfo.CidArray[2]>>16)&0xff;
 800627e:	f246 4334 	movw	r3, #25652	; 0x6434
 8006282:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006286:	68db      	ldr	r3, [r3, #12]
 8006288:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800628c:	b2da      	uxtb	r2, r3
 800628e:	68bb      	ldr	r3, [r7, #8]
 8006290:	729a      	strb	r2, [r3, #10]
    Tmp->ProductName[2] =  (SDMMC003_CardInfo.CidArray[2]>>8)&0xff;
 8006292:	f246 4334 	movw	r3, #25652	; 0x6434
 8006296:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800629a:	68db      	ldr	r3, [r3, #12]
 800629c:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80062a0:	b2da      	uxtb	r2, r3
 80062a2:	68bb      	ldr	r3, [r7, #8]
 80062a4:	72da      	strb	r2, [r3, #11]
    Tmp->ProductName[3] =  (SDMMC003_CardInfo.CidArray[2]>>0)&0xff;
 80062a6:	f246 4334 	movw	r3, #25652	; 0x6434
 80062aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062ae:	68db      	ldr	r3, [r3, #12]
 80062b0:	b2da      	uxtb	r2, r3
 80062b2:	68bb      	ldr	r3, [r7, #8]
 80062b4:	731a      	strb	r2, [r3, #12]
    Tmp->ProductName[4] =  (SDMMC003_CardInfo.CidArray[1]>>24)&0xff;
 80062b6:	f246 4334 	movw	r3, #25652	; 0x6434
 80062ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062be:	689b      	ldr	r3, [r3, #8]
 80062c0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80062c4:	b2da      	uxtb	r2, r3
 80062c6:	68bb      	ldr	r3, [r7, #8]
 80062c8:	735a      	strb	r2, [r3, #13]
    Tmp->AppOEMId[0] = (SDMMC003_CardInfo.CidArray[3]>>8)&0xff;
 80062ca:	f246 4334 	movw	r3, #25652	; 0x6434
 80062ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062d2:	691b      	ldr	r3, [r3, #16]
 80062d4:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80062d8:	b2da      	uxtb	r2, r3
 80062da:	68bb      	ldr	r3, [r7, #8]
 80062dc:	739a      	strb	r2, [r3, #14]
    Tmp->AppOEMId[1] = (SDMMC003_CardInfo.CidArray[3])&0xff;
 80062de:	f246 4334 	movw	r3, #25652	; 0x6434
 80062e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062e6:	691b      	ldr	r3, [r3, #16]
 80062e8:	b2da      	uxtb	r2, r3
 80062ea:	68bb      	ldr	r3, [r7, #8]
 80062ec:	73da      	strb	r2, [r3, #15]
    Tmp->ManufacturerId = (SDMMC003_CardInfo.CidArray[3]>>16)&0xff;
 80062ee:	f246 4334 	movw	r3, #25652	; 0x6434
 80062f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80062f6:	691b      	ldr	r3, [r3, #16]
 80062f8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80062fc:	b2da      	uxtb	r2, r3
 80062fe:	68bb      	ldr	r3, [r7, #8]
 8006300:	741a      	strb	r2, [r3, #16]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8006302:	68fb      	ldr	r3, [r7, #12]
}
 8006304:	4618      	mov	r0, r3
 8006306:	f107 0714 	add.w	r7, r7, #20
 800630a:	46bd      	mov	sp, r7
 800630c:	bc80      	pop	{r7}
 800630e:	4770      	bx	lr

08006310 <SDMMC003_GetOcr>:
/* <<< DD_SDMMC_API_13>>> */
/*
 * This function is use to  Get OCR information on the card
 */
status_t SDMMC003_GetOcr (void *Buffer)
{
 8006310:	b480      	push	{r7}
 8006312:	b085      	sub	sp, #20
 8006314:	af00      	add	r7, sp, #0
 8006316:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8006318:	f04f 0300 	mov.w	r3, #0
 800631c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<< DD_SDMMC_API_13_1>>> */  
  /*Check Whether Initialization Process is successful */
  if (SDMMC003_Handle.InitializeFlag != 1 )
 800631e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006322:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006326:	7a1b      	ldrb	r3, [r3, #8]
 8006328:	b2db      	uxtb	r3, r3
 800632a:	2b01      	cmp	r3, #1
 800632c:	d003      	beq.n	8006336 <SDMMC003_GetOcr+0x26>
  {
    Status = (uint32_t)SDMMC003_INIT_FAIL;
 800632e:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8006332:	60fb      	str	r3, [r7, #12]
 8006334:	e006      	b.n	8006344 <SDMMC003_GetOcr+0x34>
  }
/* <<< DD_SDMMC_API_13_2>>> */  
  else
  {
    *(uint32_t *)Buffer = SDMMC003_CardInfo.Ocr;
 8006336:	f246 4334 	movw	r3, #25652	; 0x6434
 800633a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800633e:	681a      	ldr	r2, [r3, #0]
 8006340:	687b      	ldr	r3, [r7, #4]
 8006342:	601a      	str	r2, [r3, #0]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8006344:	68fb      	ldr	r3, [r7, #12]
}
 8006346:	4618      	mov	r0, r3
 8006348:	f107 0714 	add.w	r7, r7, #20
 800634c:	46bd      	mov	sp, r7
 800634e:	bc80      	pop	{r7}
 8006350:	4770      	bx	lr
 8006352:	bf00      	nop

08006354 <SDMMC003_GetCsd>:

/* <<< DD_SDMMC_API_14>>> */
/* This function is use to get CSD information on the card */
status_t SDMMC003_GetCsd (void *Buffer)
{
 8006354:	b580      	push	{r7, lr}
 8006356:	b084      	sub	sp, #16
 8006358:	af00      	add	r7, sp, #0
 800635a:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 800635c:	f04f 0300 	mov.w	r3, #0
 8006360:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /*Check Whether Initialization Process is successful */
/* <<< DD_SDMMC_API_14_1>>> */    
  if (SDMMC003_Handle.InitializeFlag != 1 )
 8006362:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006366:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800636a:	7a1b      	ldrb	r3, [r3, #8]
 800636c:	b2db      	uxtb	r3, r3
 800636e:	2b01      	cmp	r3, #1
 8006370:	d003      	beq.n	800637a <SDMMC003_GetCsd+0x26>
  {
    Status = (uint32_t)SDMMC003_INIT_FAIL;
 8006372:	f04f 032a 	mov.w	r3, #42	; 0x2a
 8006376:	60fb      	str	r3, [r7, #12]
 8006378:	e008      	b.n	800638c <SDMMC003_GetCsd+0x38>
/* <<< DD_SDMMC_API_14_2>>> */    
  else
  {
    /* Csd Structure includes 7-bit CRC  1-bit fixed bit which is not sent by the card.
     So while copying skip one byte and copy in the structure*/
    memcpy(((uint8_t *)Buffer + 1),(void *)SDMMC003_CardInfo.CsdArray,15);
 800637a:	687b      	ldr	r3, [r7, #4]
 800637c:	f103 0301 	add.w	r3, r3, #1
 8006380:	4618      	mov	r0, r3
 8006382:	4905      	ldr	r1, [pc, #20]	; (8006398 <SDMMC003_GetCsd+0x44>)
 8006384:	f04f 020f 	mov.w	r2, #15
 8006388:	f01d f944 	bl	8023614 <memcpy>
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 800638c:	68fb      	ldr	r3, [r7, #12]
}
 800638e:	4618      	mov	r0, r3
 8006390:	f107 0710 	add.w	r7, r7, #16
 8006394:	46bd      	mov	sp, r7
 8006396:	bd80      	pop	{r7, pc}
 8006398:	20006448 	.word	0x20006448

0800639c <SDMMC003_GetSectorCount>:
/* <<< DD_SDMMC_API_15 >>> */
/*
 * This function is use to get number of sectors present on the card.
 */
status_t SDMMC003_GetSectorCount( void *Buffer )
{
 800639c:	b580      	push	{r7, lr}
 800639e:	b08c      	sub	sp, #48	; 0x30
 80063a0:	af00      	add	r7, sp, #0
 80063a2:	6078      	str	r0, [r7, #4]
  uint32_t Mult = 0;
 80063a4:	f04f 0300 	mov.w	r3, #0
 80063a8:	62bb      	str	r3, [r7, #40]	; 0x28

  do
  {
/*<<<DD_SDMMC_API_15_1>>> */    
    /*Check Whether Initialization Process is successful */
    if (SDMMC003_Handle.InitializeFlag != 1 )
 80063aa:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80063ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063b2:	7a1b      	ldrb	r3, [r3, #8]
 80063b4:	b2db      	uxtb	r3, r3
 80063b6:	2b01      	cmp	r3, #1
 80063b8:	d003      	beq.n	80063c2 <SDMMC003_GetSectorCount+0x26>
    {
      Status = (uint32_t)SDMMC003_INIT_FAIL;
 80063ba:	f04f 032a 	mov.w	r3, #42	; 0x2a
 80063be:	62fb      	str	r3, [r7, #44]	; 0x2c
      break;
 80063c0:	e078      	b.n	80064b4 <SDMMC003_GetSectorCount+0x118>
    }
/* <<< DD_SDMMC_API_15_2 >>> */
    if ((SDMMC003_Handle.CardType & SDMMC003_SD_HIGH_CAPACITY)!= 0)
 80063c2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80063c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80063ca:	789b      	ldrb	r3, [r3, #2]
 80063cc:	b2db      	uxtb	r3, r3
 80063ce:	f003 0304 	and.w	r3, r3, #4
 80063d2:	2b00      	cmp	r3, #0
 80063d4:	d02f      	beq.n	8006436 <SDMMC003_GetSectorCount+0x9a>
    {
      SDMMC003_CSDV2Type TmpCsdV2 = {0};
 80063d6:	f107 0318 	add.w	r3, r7, #24
 80063da:	f04f 0200 	mov.w	r2, #0
 80063de:	601a      	str	r2, [r3, #0]
 80063e0:	f103 0304 	add.w	r3, r3, #4
 80063e4:	f04f 0200 	mov.w	r2, #0
 80063e8:	601a      	str	r2, [r3, #0]
 80063ea:	f103 0304 	add.w	r3, r3, #4
 80063ee:	f04f 0200 	mov.w	r2, #0
 80063f2:	601a      	str	r2, [r3, #0]
 80063f4:	f103 0304 	add.w	r3, r3, #4
 80063f8:	f04f 0200 	mov.w	r2, #0
 80063fc:	601a      	str	r2, [r3, #0]
 80063fe:	f103 0304 	add.w	r3, r3, #4
      /*Get CSD function */
      Status = SDMMC003_GetCsd((void *)&TmpCsdV2);
 8006402:	f107 0318 	add.w	r3, r7, #24
 8006406:	4618      	mov	r0, r3
 8006408:	f7ff ffa4 	bl	8006354 <SDMMC003_GetCsd>
 800640c:	62f8      	str	r0, [r7, #44]	; 0x2c
/* <<< DD_SDMMC_API_15_3 >>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS)
 800640e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006410:	2b00      	cmp	r3, #0
 8006412:	d14f      	bne.n	80064b4 <SDMMC003_GetSectorCount+0x118>
      {
        break;
      } /* End of "if( Status != DAVEApp_SUCCESS)" */
      /* For High Capacity SD card, (C_SIZE field value + 1) * 1024
        gives the sector count*/
      *(uint32_t *)Buffer = (((TmpCsdV2.DeviceSizeHigh << 16UL) |   \
 8006414:	f897 3020 	ldrb.w	r3, [r7, #32]
 8006418:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800641c:	b2db      	uxtb	r3, r3
 800641e:	ea4f 4203 	mov.w	r2, r3, lsl #16
                               (TmpCsdV2.DeviceSizeLower ) )+ 1 ) << 10;
 8006422:	8bfb      	ldrh	r3, [r7, #30]
      {
        break;
      } /* End of "if( Status != DAVEApp_SUCCESS)" */
      /* For High Capacity SD card, (C_SIZE field value + 1) * 1024
        gives the sector count*/
      *(uint32_t *)Buffer = (((TmpCsdV2.DeviceSizeHigh << 16UL) |   \
 8006424:	4313      	orrs	r3, r2
                               (TmpCsdV2.DeviceSizeLower ) )+ 1 ) << 10;
 8006426:	f103 0301 	add.w	r3, r3, #1
 800642a:	ea4f 2383 	mov.w	r3, r3, lsl #10
      {
        break;
      } /* End of "if( Status != DAVEApp_SUCCESS)" */
      /* For High Capacity SD card, (C_SIZE field value + 1) * 1024
        gives the sector count*/
      *(uint32_t *)Buffer = (((TmpCsdV2.DeviceSizeHigh << 16UL) |   \
 800642e:	461a      	mov	r2, r3
 8006430:	687b      	ldr	r3, [r7, #4]
 8006432:	601a      	str	r2, [r3, #0]
 8006434:	e03e      	b.n	80064b4 <SDMMC003_GetSectorCount+0x118>
#endif
    /* Standard SD card */
/* <<< DD_SDMMC_API_15_6 >>> */
    else
    {
      SDMMC003_CSDV1Type TmpCsdV1 = {0};
 8006436:	f107 0308 	add.w	r3, r7, #8
 800643a:	f04f 0200 	mov.w	r2, #0
 800643e:	601a      	str	r2, [r3, #0]
 8006440:	f103 0304 	add.w	r3, r3, #4
 8006444:	f04f 0200 	mov.w	r2, #0
 8006448:	601a      	str	r2, [r3, #0]
 800644a:	f103 0304 	add.w	r3, r3, #4
 800644e:	f04f 0200 	mov.w	r2, #0
 8006452:	601a      	str	r2, [r3, #0]
 8006454:	f103 0304 	add.w	r3, r3, #4
 8006458:	f04f 0200 	mov.w	r2, #0
 800645c:	601a      	str	r2, [r3, #0]
 800645e:	f103 0304 	add.w	r3, r3, #4
      /*Get csd function */
      Status = SDMMC003_GetCsd((void *)&TmpCsdV1);
 8006462:	f107 0308 	add.w	r3, r7, #8
 8006466:	4618      	mov	r0, r3
 8006468:	f7ff ff74 	bl	8006354 <SDMMC003_GetCsd>
 800646c:	62f8      	str	r0, [r7, #44]	; 0x2c
/* <<< DD_SDMMC_API_15_7 >>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS)
 800646e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006470:	2b00      	cmp	r3, #0
 8006472:	d11f      	bne.n	80064b4 <SDMMC003_GetSectorCount+0x118>
      {
        break;
      }
      /* Left Shift evaluates 1* 2^(TmpMmcCsd.DeviceSizeMult + 2)*/
      Mult = (TmpCsdV1.DeviceSizeMult + TmpCsdV1.ReadBlkLen - 7);
 8006474:	68fb      	ldr	r3, [r7, #12]
 8006476:	f3c3 33c2 	ubfx	r3, r3, #15, #3
 800647a:	b2db      	uxtb	r3, r3
 800647c:	461a      	mov	r2, r3
 800647e:	7cbb      	ldrb	r3, [r7, #18]
 8006480:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8006484:	b2db      	uxtb	r3, r3
 8006486:	18d3      	adds	r3, r2, r3
 8006488:	f1a3 0307 	sub.w	r3, r3, #7
 800648c:	62bb      	str	r3, [r7, #40]	; 0x28
      /* Sector Count = Device_size * Mult.*/
      *(uint32_t *)Buffer = (((TmpCsdV1.DeviceSizeHigh << 2) |   \
 800648e:	8a3b      	ldrh	r3, [r7, #16]
 8006490:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8006494:	b29b      	uxth	r3, r3
 8006496:	ea4f 0283 	mov.w	r2, r3, lsl #2
                                  (TmpCsdV1.DeviceSizeLower ))+ 1) <<  Mult;
 800649a:	7bfb      	ldrb	r3, [r7, #15]
 800649c:	f3c3 1381 	ubfx	r3, r3, #6, #2
 80064a0:	b2db      	uxtb	r3, r3
        break;
      }
      /* Left Shift evaluates 1* 2^(TmpMmcCsd.DeviceSizeMult + 2)*/
      Mult = (TmpCsdV1.DeviceSizeMult + TmpCsdV1.ReadBlkLen - 7);
      /* Sector Count = Device_size * Mult.*/
      *(uint32_t *)Buffer = (((TmpCsdV1.DeviceSizeHigh << 2) |   \
 80064a2:	4313      	orrs	r3, r2
                                  (TmpCsdV1.DeviceSizeLower ))+ 1) <<  Mult;
 80064a4:	f103 0201 	add.w	r2, r3, #1
 80064a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064aa:	fa02 f303 	lsl.w	r3, r2, r3
        break;
      }
      /* Left Shift evaluates 1* 2^(TmpMmcCsd.DeviceSizeMult + 2)*/
      Mult = (TmpCsdV1.DeviceSizeMult + TmpCsdV1.ReadBlkLen - 7);
      /* Sector Count = Device_size * Mult.*/
      *(uint32_t *)Buffer = (((TmpCsdV1.DeviceSizeHigh << 2) |   \
 80064ae:	461a      	mov	r2, r3
 80064b0:	687b      	ldr	r3, [r7, #4]
 80064b2:	601a      	str	r2, [r3, #0]
    } /* End of "Else SD card " */
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80064b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 80064b6:	4618      	mov	r0, r3
 80064b8:	f107 0730 	add.w	r7, r7, #48	; 0x30
 80064bc:	46bd      	mov	sp, r7
 80064be:	bd80      	pop	{r7, pc}

080064c0 <SDMMC003_GetSectorSize>:
/* <<< DD_SDMMC_API_16 >>> */
/*
 * This function is use to get Sector Size info from the card
 */
status_t SDMMC003_GetSectorSize(void *Buffer)
{
 80064c0:	b480      	push	{r7}
 80064c2:	b085      	sub	sp, #20
 80064c4:	af00      	add	r7, sp, #0
 80064c6:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t) DAVEApp_SUCCESS;
 80064c8:	f04f 0300 	mov.w	r3, #0
 80064cc:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<< DD_SDMMC_API_16_1 >>> */  
  /*Check Whether Initialization Process is successfull */
  if (SDMMC003_Handle.InitializeFlag != 1 )
 80064ce:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80064d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80064d6:	7a1b      	ldrb	r3, [r3, #8]
 80064d8:	b2db      	uxtb	r3, r3
 80064da:	2b01      	cmp	r3, #1
 80064dc:	d003      	beq.n	80064e6 <SDMMC003_GetSectorSize+0x26>
  {
    Status = (uint32_t)SDMMC003_INIT_FAIL;
 80064de:	f04f 032a 	mov.w	r3, #42	; 0x2a
 80064e2:	60fb      	str	r3, [r7, #12]
 80064e4:	e003      	b.n	80064ee <SDMMC003_GetSectorSize+0x2e>
  }
/* <<< DD_SDMMC_API_16_2 >>> */  
  else
  {
    /* Sector Size is fixed to 512bytes.*/
    *(uint16_t *)Buffer = 512UL;
 80064e6:	687b      	ldr	r3, [r7, #4]
 80064e8:	f44f 7200 	mov.w	r2, #512	; 0x200
 80064ec:	801a      	strh	r2, [r3, #0]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80064ee:	68fb      	ldr	r3, [r7, #12]
}
 80064f0:	4618      	mov	r0, r3
 80064f2:	f107 0714 	add.w	r7, r7, #20
 80064f6:	46bd      	mov	sp, r7
 80064f8:	bc80      	pop	{r7}
 80064fa:	4770      	bx	lr

080064fc <SDMMC003_GetBlockSize>:
 *  This function returns erase block size of the card in unit of sector into
 *  the DWORD variable pointed by Buffer
 */

status_t SDMMC003_GetBlockSize(void *Buffer)
{
 80064fc:	b580      	push	{r7, lr}
 80064fe:	b08c      	sub	sp, #48	; 0x30
 8006500:	af00      	add	r7, sp, #0
 8006502:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8006504:	f04f 0300 	mov.w	r3, #0
 8006508:	62fb      	str	r3, [r7, #44]	; 0x2c
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<< DD_SDMMC_API_17_1 >>> */  
  /*Check Whether Initialization Process is successful */
  if (SDMMC003_Handle.InitializeFlag != 1 )
 800650a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800650e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006512:	7a1b      	ldrb	r3, [r3, #8]
 8006514:	b2db      	uxtb	r3, r3
 8006516:	2b01      	cmp	r3, #1
 8006518:	d003      	beq.n	8006522 <SDMMC003_GetBlockSize+0x26>
  {
    Status = (uint32_t)SDMMC003_INIT_FAIL;
 800651a:	f04f 032a 	mov.w	r3, #42	; 0x2a
 800651e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8006520:	e054      	b.n	80065cc <SDMMC003_GetBlockSize+0xd0>
  }
  /* SD High capacity card i.e. CSD V2*/
/* <<< DD_SDMMC_API_17_2 >>> */
  else if ((SDMMC003_Handle.CardType & SDMMC003_SD_HIGH_CAPACITY) != 0)
 8006522:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006526:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800652a:	789b      	ldrb	r3, [r3, #2]
 800652c:	b2db      	uxtb	r3, r3
 800652e:	f003 0304 	and.w	r3, r3, #4
 8006532:	2b00      	cmp	r3, #0
 8006534:	d025      	beq.n	8006582 <SDMMC003_GetBlockSize+0x86>
  {
    SDMMC003_CSDV2Type TmpCsdV2 = {0};
 8006536:	f107 031c 	add.w	r3, r7, #28
 800653a:	f04f 0200 	mov.w	r2, #0
 800653e:	601a      	str	r2, [r3, #0]
 8006540:	f103 0304 	add.w	r3, r3, #4
 8006544:	f04f 0200 	mov.w	r2, #0
 8006548:	601a      	str	r2, [r3, #0]
 800654a:	f103 0304 	add.w	r3, r3, #4
 800654e:	f04f 0200 	mov.w	r2, #0
 8006552:	601a      	str	r2, [r3, #0]
 8006554:	f103 0304 	add.w	r3, r3, #4
 8006558:	f04f 0200 	mov.w	r2, #0
 800655c:	601a      	str	r2, [r3, #0]
 800655e:	f103 0304 	add.w	r3, r3, #4
    /*Get CSD function */
    Status = SDMMC003_GetCsd((void *)&TmpCsdV2);
 8006562:	f107 031c 	add.w	r3, r7, #28
 8006566:	4618      	mov	r0, r3
 8006568:	f7ff fef4 	bl	8006354 <SDMMC003_GetCsd>
 800656c:	62f8      	str	r0, [r7, #44]	; 0x2c
    *(uint32_t *)Buffer = TmpCsdV2.EraseSectorSize + 1;
 800656e:	8c3b      	ldrh	r3, [r7, #32]
 8006570:	f3c3 13c6 	ubfx	r3, r3, #7, #7
 8006574:	b2db      	uxtb	r3, r3
 8006576:	f103 0301 	add.w	r3, r3, #1
 800657a:	461a      	mov	r2, r3
 800657c:	687b      	ldr	r3, [r7, #4]
 800657e:	601a      	str	r2, [r3, #0]
 8006580:	e024      	b.n	80065cc <SDMMC003_GetBlockSize+0xd0>
#endif
  /* SD standard capacity card i.e. CSD V1*/
/* <<< DD_SDMMC_API_17_4 >>> */
  else
  {
    SDMMC003_CSDV1Type TmpCsdV1  = {0};
 8006582:	f107 030c 	add.w	r3, r7, #12
 8006586:	f04f 0200 	mov.w	r2, #0
 800658a:	601a      	str	r2, [r3, #0]
 800658c:	f103 0304 	add.w	r3, r3, #4
 8006590:	f04f 0200 	mov.w	r2, #0
 8006594:	601a      	str	r2, [r3, #0]
 8006596:	f103 0304 	add.w	r3, r3, #4
 800659a:	f04f 0200 	mov.w	r2, #0
 800659e:	601a      	str	r2, [r3, #0]
 80065a0:	f103 0304 	add.w	r3, r3, #4
 80065a4:	f04f 0200 	mov.w	r2, #0
 80065a8:	601a      	str	r2, [r3, #0]
 80065aa:	f103 0304 	add.w	r3, r3, #4
    /*Get csd function */
    Status = SDMMC003_GetCsd((void *)&TmpCsdV1);
 80065ae:	f107 030c 	add.w	r3, r7, #12
 80065b2:	4618      	mov	r0, r3
 80065b4:	f7ff fece 	bl	8006354 <SDMMC003_GetCsd>
 80065b8:	62f8      	str	r0, [r7, #44]	; 0x2c
    *(uint32_t *)Buffer = TmpCsdV1.EraseSectorSize + 1;
 80065ba:	8a3b      	ldrh	r3, [r7, #16]
 80065bc:	f3c3 13c6 	ubfx	r3, r3, #7, #7
 80065c0:	b2db      	uxtb	r3, r3
 80065c2:	f103 0301 	add.w	r3, r3, #1
 80065c6:	461a      	mov	r2, r3
 80065c8:	687b      	ldr	r3, [r7, #4]
 80065ca:	601a      	str	r2, [r3, #0]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
 return  Status;
 80065cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 80065ce:	4618      	mov	r0, r3
 80065d0:	f107 0730 	add.w	r7, r7, #48	; 0x30
 80065d4:	46bd      	mov	sp, r7
 80065d6:	bd80      	pop	{r7, pc}

080065d8 <SDMMC003_FlushDiskWriteCache>:
/* <<< DD_SDMMC_API_18 >>> */
/*
 *  This function Flushes Disk Cache from the card
 */
status_t SDMMC003_FlushDiskWriteCache()
{
 80065d8:	b480      	push	{r7}
 80065da:	b083      	sub	sp, #12
 80065dc:	af00      	add	r7, sp, #0
  status_t Status  = (uint32_t)DAVEApp_SUCCESS;
 80065de:	f04f 0300 	mov.w	r3, #0
 80065e2:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<< DD_SDMMC_API_18_1 >>> */  
  /*Check Whether Initialization Process is successful */
  if (SDMMC003_Handle.InitializeFlag != 1 )
 80065e4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80065e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065ec:	7a1b      	ldrb	r3, [r3, #8]
 80065ee:	b2db      	uxtb	r3, r3
 80065f0:	2b01      	cmp	r3, #1
 80065f2:	d002      	beq.n	80065fa <SDMMC003_FlushDiskWriteCache+0x22>
  {
    Status = (uint32_t)SDMMC003_INIT_FAIL;
 80065f4:	f04f 032a 	mov.w	r3, #42	; 0x2a
 80065f8:	607b      	str	r3, [r7, #4]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80065fa:	687b      	ldr	r3, [r7, #4]
}
 80065fc:	4618      	mov	r0, r3
 80065fe:	f107 070c 	add.w	r7, r7, #12
 8006602:	46bd      	mov	sp, r7
 8006604:	bc80      	pop	{r7}
 8006606:	4770      	bx	lr

08006608 <SDMMC003_GetSdStatus>:
/* <<<DD_SDMMC_API_19>>> */
/*
 * This function is use to Get SD Status Information
 */
status_t SDMMC003_GetSdStatus(void *Buffer)
{
 8006608:	b580      	push	{r7, lr}
 800660a:	b088      	sub	sp, #32
 800660c:	af02      	add	r7, sp, #8
 800660e:	6078      	str	r0, [r7, #4]
  uint32_t Argument = 0;
 8006610:	f04f 0300 	mov.w	r3, #0
 8006614:	613b      	str	r3, [r7, #16]
  uint32_t CardStatus = 0;
 8006616:	f04f 0300 	mov.w	r3, #0
 800661a:	60fb      	str	r3, [r7, #12]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 800661c:	f04f 0301 	mov.w	r3, #1
 8006620:	617b      	str	r3, [r7, #20]
      /* Disable the Command Complete Signal Interrupt */
      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
    }
#endif
    /* Select the card ie.cmd7 */
    Status = SDMMC003_lSwitchToTransferState();
 8006622:	f001 fdcd 	bl	80081c0 <SDMMC003_lSwitchToTransferState>
 8006626:	6178      	str	r0, [r7, #20]
/* <<<DD_SDMMC_API_19_1>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS)
 8006628:	697b      	ldr	r3, [r7, #20]
 800662a:	2b00      	cmp	r3, #0
 800662c:	d14a      	bne.n	80066c4 <SDMMC003_GetSdStatus+0xbc>
      SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);
      /* Disable the Command Complete Signal Interrupt */
      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
    }
#endif
    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
 800662e:	f246 4334 	movw	r3, #25652	; 0x6434
 8006632:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006636:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8006638:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800663c:	693a      	ldr	r2, [r7, #16]
 800663e:	4313      	orrs	r3, r2
 8006640:	613b      	str	r3, [r7, #16]
    Status = SDMMC003_lSendCommand(&(SDMMC003_COMMON_COMMAND(55)),Argument, \
 8006642:	f246 6304 	movw	r3, #26116	; 0x6604
 8006646:	f6c0 0302 	movt	r3, #2050	; 0x802
 800664a:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 800664e:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8006652:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8006656:	f6c0 0302 	movt	r3, #2050	; 0x802
 800665a:	18d2      	adds	r2, r2, r3
                                    SDMMC003_RESPONSE_R1,&CardStatus);
 800665c:	f107 030c 	add.w	r3, r7, #12
      /* Disable the Command Complete Signal Interrupt */
      SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
    }
#endif
    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
    Status = SDMMC003_lSendCommand(&(SDMMC003_COMMON_COMMAND(55)),Argument, \
 8006660:	4610      	mov	r0, r2
 8006662:	6939      	ldr	r1, [r7, #16]
 8006664:	f04f 0201 	mov.w	r2, #1
 8006668:	f000 fbbe 	bl	8006de8 <SDMMC003_lSendCommand>
 800666c:	6178      	str	r0, [r7, #20]
                                    SDMMC003_RESPONSE_R1,&CardStatus);
/* <<<DD_SDMMC_API_19_2>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS)
 800666e:	697b      	ldr	r3, [r7, #20]
 8006670:	2b00      	cmp	r3, #0
 8006672:	d129      	bne.n	80066c8 <SDMMC003_GetSdStatus+0xc0>
    {
      break;
    }
    /*  Set Transfer Mode Register */
    SET_BIT( SDMMC->TRANSFER_MODE, SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
 8006674:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006678:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800667c:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8006680:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8006684:	8992      	ldrh	r2, [r2, #12]
 8006686:	b292      	uxth	r2, r2
 8006688:	f042 0210 	orr.w	r2, r2, #16
 800668c:	b292      	uxth	r2, r2
 800668e:	819a      	strh	r2, [r3, #12]
    /* Read the SD status from the data line */
/* <<<DD_SDMMC_API_19_3>>> */
    Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(59)),\
 8006690:	f246 6304 	movw	r3, #26116	; 0x6604
 8006694:	f6c0 0302 	movt	r3, #2050	; 0x802
 8006698:	f893 303b 	ldrb.w	r3, [r3, #59]	; 0x3b
 800669c:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80066a0:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80066a4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80066a8:	18d3      	adds	r3, r2, r3
 80066aa:	f04f 0201 	mov.w	r2, #1
 80066ae:	9200      	str	r2, [sp, #0]
 80066b0:	4618      	mov	r0, r3
 80066b2:	f04f 0100 	mov.w	r1, #0
 80066b6:	f04f 0240 	mov.w	r2, #64	; 0x40
 80066ba:	687b      	ldr	r3, [r7, #4]
 80066bc:	f001 f8e4 	bl	8007888 <SDMMC003_lSingleBlockTransfer>
 80066c0:	6178      	str	r0, [r7, #20]
 80066c2:	e002      	b.n	80066ca <SDMMC003_GetSdStatus+0xc2>
    /* Select the card ie.cmd7 */
    Status = SDMMC003_lSwitchToTransferState();
/* <<<DD_SDMMC_API_19_1>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 80066c4:	bf00      	nop
 80066c6:	e000      	b.n	80066ca <SDMMC003_GetSdStatus+0xc2>
    Status = SDMMC003_lSendCommand(&(SDMMC003_COMMON_COMMAND(55)),Argument, \
                                    SDMMC003_RESPONSE_R1,&CardStatus);
/* <<<DD_SDMMC_API_19_2>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 80066c8:	bf00      	nop
                                            SDMMC003_READ_FROM_BUFF);
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80066ca:	697b      	ldr	r3, [r7, #20]
}
 80066cc:	4618      	mov	r0, r3
 80066ce:	f107 0718 	add.w	r7, r7, #24
 80066d2:	46bd      	mov	sp, r7
 80066d4:	bd80      	pop	{r7, pc}
 80066d6:	bf00      	nop

080066d8 <SDMMC003_EjectCard>:
/* <<< DD_SDMMC_API_20 >>> */
/*
 * This function is use to  de-activate the  Card
 */
status_t SDMMC003_EjectCard()
{
 80066d8:	b580      	push	{r7, lr}
 80066da:	b082      	sub	sp, #8
 80066dc:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)SDMMC003_ERROR;
 80066de:	f04f 0301 	mov.w	r3, #1
 80066e2:	607b      	str	r3, [r7, #4]
  uint32_t Argument = 0;
 80066e4:	f04f 0300 	mov.w	r3, #0
 80066e8:	603b      	str	r3, [r7, #0]
  do
  {
/* <<< DD_SDMMC_API_20_1 >>> */
    if (SDMMC003_Handle.State & SDMMC003_STATE_NO_CARD )
 80066ea:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80066ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80066f2:	881b      	ldrh	r3, [r3, #0]
 80066f4:	b29b      	uxth	r3, r3
 80066f6:	f003 0302 	and.w	r3, r3, #2
 80066fa:	2b00      	cmp	r3, #0
 80066fc:	d12b      	bne.n	8006756 <SDMMC003_EjectCard+0x7e>
    {
      break;
    }/* End of "if ((SDMMC003_Handle.State & SDMMC003_STATE_NO_CARD )!= 1)" */
    /* Send Command 15 to de-activate the card */
    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
 80066fe:	f246 4334 	movw	r3, #25652	; 0x6434
 8006702:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006706:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8006708:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800670c:	683a      	ldr	r2, [r7, #0]
 800670e:	4313      	orrs	r3, r2
 8006710:	603b      	str	r3, [r7, #0]
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(15)), Argument, \
 8006712:	f246 6304 	movw	r3, #26116	; 0x6604
 8006716:	f6c0 0302 	movt	r3, #2050	; 0x802
 800671a:	7bdb      	ldrb	r3, [r3, #15]
 800671c:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8006720:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8006724:	f6c0 0302 	movt	r3, #2050	; 0x802
 8006728:	18d3      	adds	r3, r2, r3
 800672a:	4618      	mov	r0, r3
 800672c:	6839      	ldr	r1, [r7, #0]
 800672e:	f04f 0200 	mov.w	r2, #0
 8006732:	f04f 0300 	mov.w	r3, #0
 8006736:	f000 fb57 	bl	8006de8 <SDMMC003_lSendCommand>
 800673a:	6078      	str	r0, [r7, #4]
                                    SDMMC003_NO_RESPONSE,  NULL);
/* <<< DD_SDMMC_API_20_2 >>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 800673c:	687b      	ldr	r3, [r7, #4]
 800673e:	2b00      	cmp	r3, #0
 8006740:	d10b      	bne.n	800675a <SDMMC003_EjectCard+0x82>
    {
      break;
    }
    /* Card Cleanup */
    SDMMC003_lCardCleanUp();
 8006742:	f000 f8a9 	bl	8006898 <SDMMC003_lCardCleanUp>
    SDMMC003_Handle.InitializeFlag = 0;
 8006746:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800674a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800674e:	f04f 0200 	mov.w	r2, #0
 8006752:	721a      	strb	r2, [r3, #8]
 8006754:	e002      	b.n	800675c <SDMMC003_EjectCard+0x84>
  do
  {
/* <<< DD_SDMMC_API_20_1 >>> */
    if (SDMMC003_Handle.State & SDMMC003_STATE_NO_CARD )
    {
      break;
 8006756:	bf00      	nop
 8006758:	e000      	b.n	800675c <SDMMC003_EjectCard+0x84>
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(15)), Argument, \
                                    SDMMC003_NO_RESPONSE,  NULL);
/* <<< DD_SDMMC_API_20_2 >>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 800675a:	bf00      	nop
    SDMMC003_lCardCleanUp();
    SDMMC003_Handle.InitializeFlag = 0;
  } while(0);
  /* Debug Log message .*/
  INFO(GID_SDMMC00x,Status,0,0);
  return Status; 
 800675c:	687b      	ldr	r3, [r7, #4]
}
 800675e:	4618      	mov	r0, r3
 8006760:	f107 0708 	add.w	r7, r7, #8
 8006764:	46bd      	mov	sp, r7
 8006766:	bd80      	pop	{r7, pc}

08006768 <SDMMC003_Init>:
/* <<< DD_SDMMC_API_22 >>> */
/*
 * This function brings the SDMMC peripheral out of reset.
 */
void SDMMC003_Init()
{
 8006768:	b580      	push	{r7, lr}
 800676a:	af00      	add	r7, sp, #0
  RESET001_DeassertReset(PER1_MMC);
 800676c:	f04f 0040 	mov.w	r0, #64	; 0x40
 8006770:	f2c1 0000 	movt	r0, #4096	; 0x1000
 8006774:	f003 f91e 	bl	80099b4 <RESET001_DeassertReset>
}
 8006778:	bd80      	pop	{r7, pc}
 800677a:	bf00      	nop

0800677c <SDMMC003_Start>:
/*
 * This function performs the SDMMC LLD App Initialization which includes Host Controller Initialization,
 * Card Initialization and Reading Card Registers.
 */
status_t SDMMC003_Start()
{
 800677c:	b580      	push	{r7, lr}
 800677e:	b082      	sub	sp, #8
 8006780:	af00      	add	r7, sp, #0
  status_t Status =  (uint32_t)SDMMC003_HOST_CONTROLLER_INITIALIZED;
 8006782:	f04f 032c 	mov.w	r3, #44	; 0x2c
 8006786:	607b      	str	r3, [r7, #4]
/* <<< DD_SDMMC_API_23_1 >>> */  
  /* Check If Host controller is already Initialized */
  if ( (SDMMC003_Handle.State & SDMMC003_STATE_HC_INITIALIZED) == 0)
 8006788:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800678c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006790:	881b      	ldrh	r3, [r3, #0]
 8006792:	b29b      	uxth	r3, r3
 8006794:	f003 0320 	and.w	r3, r3, #32
 8006798:	2b00      	cmp	r3, #0
 800679a:	d11a      	bne.n	80067d2 <SDMMC003_Start+0x56>
  {
    /* Enable Interrupt */
    NVIC_SetPriority(SDMMC0_0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), \
 800679c:	f7ff f86a 	bl	8005874 <NVIC_GetPriorityGrouping>
 80067a0:	4603      	mov	r3, r0
 80067a2:	4618      	mov	r0, r3
 80067a4:	f04f 0128 	mov.w	r1, #40	; 0x28
 80067a8:	f04f 0200 	mov.w	r2, #0
 80067ac:	f7ff f8da 	bl	8005964 <NVIC_EncodePriority>
 80067b0:	4603      	mov	r3, r0
 80067b2:	f04f 006a 	mov.w	r0, #106	; 0x6a
 80067b6:	4619      	mov	r1, r3
 80067b8:	f7ff f8a6 	bl	8005908 <NVIC_SetPriority>
                                                        SDMMC_PREEMPTION_PRIORITY,\
                                                        SDMMC_SUB_PRIORITY));
    NVIC_ClearPendingIRQ(SDMMC0_0_IRQn);
 80067bc:	f04f 006a 	mov.w	r0, #106	; 0x6a
 80067c0:	f7ff f884 	bl	80058cc <NVIC_ClearPendingIRQ>
    NVIC_EnableIRQ(SDMMC0_0_IRQn);
 80067c4:	f04f 006a 	mov.w	r0, #106	; 0x6a
 80067c8:	f7ff f864 	bl	8005894 <NVIC_EnableIRQ>
/* <<< DD_SDMMC_API_23_1 >>> */
    /* Host Controller Initialize */
    Status = SDMMC003_HostControllerInit();
 80067cc:	f7ff f906 	bl	80059dc <SDMMC003_HostControllerInit>
 80067d0:	6078      	str	r0, [r7, #4]
  }
  return Status;
 80067d2:	687b      	ldr	r3, [r7, #4]
}
 80067d4:	4618      	mov	r0, r3
 80067d6:	f107 0708 	add.w	r7, r7, #8
 80067da:	46bd      	mov	sp, r7
 80067dc:	bd80      	pop	{r7, pc}
 80067de:	bf00      	nop

080067e0 <SDMMC003_CardDetectionSupport>:
/*
 * This function performs the SDMMC LLD App Initialization which includes Host Controller Initialization,
 * Card Initialization and Reading Card Registers.
 */
status_t SDMMC003_CardDetectionSupport()
{
 80067e0:	b580      	push	{r7, lr}
 80067e2:	b082      	sub	sp, #8
 80067e4:	af00      	add	r7, sp, #0
  status_t Status;
/* <<< DD_SDMMC_API_24_1 >>> */
  Status = SDMMC003_lCardIdentificationProcess();
 80067e6:	f001 fef9 	bl	80085dc <SDMMC003_lCardIdentificationProcess>
 80067ea:	6078      	str	r0, [r7, #4]
  if (Status == (uint32_t)DAVEApp_SUCCESS)
 80067ec:	687b      	ldr	r3, [r7, #4]
 80067ee:	2b00      	cmp	r3, #0
 80067f0:	d106      	bne.n	8006800 <SDMMC003_CardDetectionSupport+0x20>
  {
    SDMMC003_Handle.InitializeFlag = 1;  
 80067f2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80067f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067fa:	f04f 0201 	mov.w	r2, #1
 80067fe:	721a      	strb	r2, [r3, #8]
  }
  return Status;
 8006800:	687b      	ldr	r3, [r7, #4]
}
 8006802:	4618      	mov	r0, r3
 8006804:	f107 0708 	add.w	r7, r7, #8
 8006808:	46bd      	mov	sp, r7
 800680a:	bd80      	pop	{r7, pc}

0800680c <SDMMC003_lReset>:
/*
 * This function resets the Host Controller's register depending on the
 * parameter passed.
 */
status_t SDMMC003_lReset( uint8_t Reset )
{
 800680c:	b580      	push	{r7, lr}
 800680e:	b084      	sub	sp, #16
 8006810:	af00      	add	r7, sp, #0
 8006812:	4603      	mov	r3, r0
 8006814:	71fb      	strb	r3, [r7, #7]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8006816:	f04f 0300 	mov.w	r3, #0
 800681a:	60fb      	str	r3, [r7, #12]
  handle_t TimerId;
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  SDMMC->SW_RESET =  (SDMMC->SW_RESET | Reset);
 800681c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006820:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006824:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8006828:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800682c:	f892 202f 	ldrb.w	r2, [r2, #47]	; 0x2f
 8006830:	b2d1      	uxtb	r1, r2
 8006832:	79fa      	ldrb	r2, [r7, #7]
 8006834:	430a      	orrs	r2, r1
 8006836:	b2d2      	uxtb	r2, r2
 8006838:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  /* The Host Controller takes some time to complete software reset*/
  /* Wait till host controller clears each bit */
/* <<<DD_SDMMC_nonAPI_1_1>>>*/
  TimerId = SDMMC003_lStartTimer(SDMMC003_RESET_DELAY);
 800683c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8006840:	f001 ff38 	bl	80086b4 <SDMMC003_lStartTimer>
 8006844:	60b8      	str	r0, [r7, #8]
  if(0 == TimerId)
 8006846:	68bb      	ldr	r3, [r7, #8]
 8006848:	2b00      	cmp	r3, #0
 800684a:	d103      	bne.n	8006854 <SDMMC003_lReset+0x48>
  {
    Status = (uint32_t) SDMMC003_START_TIMER_FAILED;
 800684c:	f04f 032f 	mov.w	r3, #47	; 0x2f
 8006850:	60fb      	str	r3, [r7, #12]
 8006852:	e01a      	b.n	800688a <SDMMC003_lReset+0x7e>
  }
  else
  {
    do
    {
      if (SDMMC003_Handle.TimerExpire == 0)
 8006854:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006858:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800685c:	7a9b      	ldrb	r3, [r3, #10]
 800685e:	b2db      	uxtb	r3, r3
 8006860:	2b00      	cmp	r3, #0
 8006862:	d103      	bne.n	800686c <SDMMC003_lReset+0x60>
      {
        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;
 8006864:	f04f 032e 	mov.w	r3, #46	; 0x2e
 8006868:	60fb      	str	r3, [r7, #12]
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 800686a:	e00b      	b.n	8006884 <SDMMC003_lReset+0x78>
      }
    } while (SDMMC->SW_RESET & Reset);
 800686c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006870:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006874:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 8006878:	b2da      	uxtb	r2, r3
 800687a:	79fb      	ldrb	r3, [r7, #7]
 800687c:	4013      	ands	r3, r2
 800687e:	b2db      	uxtb	r3, r3
 8006880:	2b00      	cmp	r3, #0
 8006882:	d1e7      	bne.n	8006854 <SDMMC003_lReset+0x48>
    SDMMC003_lStopTimer(TimerId);
 8006884:	68b8      	ldr	r0, [r7, #8]
 8006886:	f001 ff49 	bl	800871c <SDMMC003_lStopTimer>
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 800688a:	68fb      	ldr	r3, [r7, #12]
}
 800688c:	4618      	mov	r0, r3
 800688e:	f107 0710 	add.w	r7, r7, #16
 8006892:	46bd      	mov	sp, r7
 8006894:	bd80      	pop	{r7, pc}
 8006896:	bf00      	nop

08006898 <SDMMC003_lCardCleanUp>:
/* <<<DD_SDMMC_nonAPI_2>>> */
/*
 * This function clears the card related structures and stops the SD clock.
 */
void SDMMC003_lCardCleanUp()
{
 8006898:	b580      	push	{r7, lr}
 800689a:	af00      	add	r7, sp, #0
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  memset((void*)&SDMMC003_CardInfo,0,sizeof(SDMMC003_CardInfo));
 800689c:	f246 4034 	movw	r0, #25652	; 0x6434
 80068a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80068a4:	f04f 0100 	mov.w	r1, #0
 80068a8:	f04f 0230 	mov.w	r2, #48	; 0x30
 80068ac:	f01d f820 	bl	80238f0 <memset>
  SDMMC003_Handle.CardType = 0;
 80068b0:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80068b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068b8:	f04f 0200 	mov.w	r2, #0
 80068bc:	709a      	strb	r2, [r3, #2]
  SDMMC003_Handle.f8 = 0;
 80068be:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80068c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068c6:	f04f 0200 	mov.w	r2, #0
 80068ca:	725a      	strb	r2, [r3, #9]
  SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;
 80068cc:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80068d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068d4:	f04f 0201 	mov.w	r2, #1
 80068d8:	711a      	strb	r2, [r3, #4]
  SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;
 80068da:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80068de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068e2:	f04f 0201 	mov.w	r2, #1
 80068e6:	70da      	strb	r2, [r3, #3]
  SDMMC003_Handle.ErrorRecoveryStatus = SDMMC003_ERROR;
 80068e8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80068ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068f0:	f04f 0201 	mov.w	r2, #1
 80068f4:	71da      	strb	r2, [r3, #7]
  SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;
 80068f6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80068fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068fe:	f04f 0201 	mov.w	r2, #1
 8006902:	715a      	strb	r2, [r3, #5]
  SDMMC003_Handle.State  = 0;
 8006904:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006908:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800690c:	f04f 0200 	mov.w	r2, #0
 8006910:	801a      	strh	r2, [r3, #0]
  /* Stop the SD Clock Enable */
  CLR_BIT( SDMMC->CLOCK_CTRL,SDMMC_CLOCK_CTRL_SDCLOCK_EN_Pos  );
 8006912:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006916:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800691a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800691e:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8006922:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
 8006924:	b292      	uxth	r2, r2
 8006926:	f022 0204 	bic.w	r2, r2, #4
 800692a:	b292      	uxth	r2, r2
 800692c:	859a      	strh	r2, [r3, #44]	; 0x2c
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
}
 800692e:	bd80      	pop	{r7, pc}

08006930 <SDMMC003_lCheckDatCmdline>:
/*
 * This function checks whether the CMD and DATA lines are free before issuing
 * any command.
 */
status_t SDMMC003_lCheckDatCmdline(const SDMMC003_CommandType *CommandPtr)
{
 8006930:	b480      	push	{r7}
 8006932:	b085      	sub	sp, #20
 8006934:	af00      	add	r7, sp, #0
 8006936:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8006938:	f04f 0300 	mov.w	r3, #0
 800693c:	60fb      	str	r3, [r7, #12]
      break;
    }
#endif
/* Read from Present state register to Check Cmd line is free */
/* <<<DD_SDMMC_nonAPI_3_1>>> */
    if ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_CMD_Msk)
 800693e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006942:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006946:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006948:	f003 0301 	and.w	r3, r3, #1
 800694c:	2b00      	cmp	r3, #0
 800694e:	d003      	beq.n	8006958 <SDMMC003_lCheckDatCmdline+0x28>
    {
      Status = (uint32_t)SDMMC003_CMD_LINE_BUSY;
 8006950:	f04f 031a 	mov.w	r3, #26
 8006954:	60fb      	str	r3, [r7, #12]
      break;
 8006956:	e04b      	b.n	80069f0 <SDMMC003_lCheckDatCmdline+0xc0>
    }
/* Check for  data line for Send Status command  and all those commands using  
   data line */
/* <<<DD_SDMMC_nonAPI_3_2>>> */
    if (( 1UL == CommandPtr->DataPresentSelect) ||  \
 8006958:	687b      	ldr	r3, [r7, #4]
 800695a:	781b      	ldrb	r3, [r3, #0]
 800695c:	f003 0320 	and.w	r3, r3, #32
 8006960:	b2db      	uxtb	r3, r3
 8006962:	2b00      	cmp	r3, #0
 8006964:	d10d      	bne.n	8006982 <SDMMC003_lCheckDatCmdline+0x52>
        ( (SDMMC003_SEND_STATUS == CommandPtr->CommandIndex) || \
 8006966:	687b      	ldr	r3, [r7, #4]
 8006968:	785b      	ldrb	r3, [r3, #1]
 800696a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800696e:	b2db      	uxtb	r3, r3
      break;
    }
/* Check for  data line for Send Status command  and all those commands using  
   data line */
/* <<<DD_SDMMC_nonAPI_3_2>>> */
    if (( 1UL == CommandPtr->DataPresentSelect) ||  \
 8006970:	2b0d      	cmp	r3, #13
 8006972:	d006      	beq.n	8006982 <SDMMC003_lCheckDatCmdline+0x52>
        ( (SDMMC003_SEND_STATUS == CommandPtr->CommandIndex) || \
          (3UL == CommandPtr->ResponseTypeSelect) )
 8006974:	687b      	ldr	r3, [r7, #4]
 8006976:	781b      	ldrb	r3, [r3, #0]
 8006978:	f003 0303 	and.w	r3, r3, #3
 800697c:	b2db      	uxtb	r3, r3
    }
/* Check for  data line for Send Status command  and all those commands using  
   data line */
/* <<<DD_SDMMC_nonAPI_3_2>>> */
    if (( 1UL == CommandPtr->DataPresentSelect) ||  \
        ( (SDMMC003_SEND_STATUS == CommandPtr->CommandIndex) || \
 800697e:	2b03      	cmp	r3, #3
 8006980:	d128      	bne.n	80069d4 <SDMMC003_lCheckDatCmdline+0xa4>
          (3UL == CommandPtr->ResponseTypeSelect) )
       )
    {
/* <<<DD_SDMMC_nonAPI_3_3>>> */
      /* Read from Present state register to Check data line is free */
      if ( (SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_DAT_Msk )!= 0)
 8006982:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006986:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800698a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800698c:	f003 0302 	and.w	r3, r3, #2
 8006990:	2b00      	cmp	r3, #0
 8006992:	d003      	beq.n	800699c <SDMMC003_lCheckDatCmdline+0x6c>
      {
        Status = (uint32_t)SDMMC003_DATA_LINE_BUSY;
 8006994:	f04f 031b 	mov.w	r3, #27
 8006998:	60fb      	str	r3, [r7, #12]
        break;
 800699a:	e029      	b.n	80069f0 <SDMMC003_lCheckDatCmdline+0xc0>
      }
/* <<<DD_SDMMC_nonAPI_3_4>>> */
      else
      {
        /* Update the data line state to active */
        if( (1UL == CommandPtr->DataPresentSelect) || \
 800699c:	687b      	ldr	r3, [r7, #4]
 800699e:	781b      	ldrb	r3, [r3, #0]
 80069a0:	f003 0320 	and.w	r3, r3, #32
 80069a4:	b2db      	uxtb	r3, r3
 80069a6:	2b00      	cmp	r3, #0
 80069a8:	d106      	bne.n	80069b8 <SDMMC003_lCheckDatCmdline+0x88>
            (3UL == CommandPtr->ResponseTypeSelect) )
 80069aa:	687b      	ldr	r3, [r7, #4]
 80069ac:	781b      	ldrb	r3, [r3, #0]
 80069ae:	f003 0303 	and.w	r3, r3, #3
 80069b2:	b2db      	uxtb	r3, r3
      }
/* <<<DD_SDMMC_nonAPI_3_4>>> */
      else
      {
        /* Update the data line state to active */
        if( (1UL == CommandPtr->DataPresentSelect) || \
 80069b4:	2b03      	cmp	r3, #3
 80069b6:	d10d      	bne.n	80069d4 <SDMMC003_lCheckDatCmdline+0xa4>
            (3UL == CommandPtr->ResponseTypeSelect) )
        {
          SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_DATA_ACTIVE;
 80069b8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80069bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80069c0:	881b      	ldrh	r3, [r3, #0]
 80069c2:	b29b      	uxth	r3, r3
 80069c4:	f043 0308 	orr.w	r3, r3, #8
 80069c8:	b29a      	uxth	r2, r3
 80069ca:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80069ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80069d2:	801a      	strh	r2, [r3, #0]
        }
      }
    }
    /* Update the Command line state to active */
    SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_CMD_ACTIVE;
 80069d4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80069d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80069dc:	881b      	ldrh	r3, [r3, #0]
 80069de:	b29b      	uxth	r3, r3
 80069e0:	f043 0304 	orr.w	r3, r3, #4
 80069e4:	b29a      	uxth	r2, r3
 80069e6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80069ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80069ee:	801a      	strh	r2, [r3, #0]
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80069f0:	68fb      	ldr	r3, [r7, #12]
}
 80069f2:	4618      	mov	r0, r3
 80069f4:	f107 0714 	add.w	r7, r7, #20
 80069f8:	46bd      	mov	sp, r7
 80069fa:	bc80      	pop	{r7}
 80069fc:	4770      	bx	lr
 80069fe:	bf00      	nop

08006a00 <SDMMC003_lCheckArgumentError>:
void SDMMC003_lCheckArgumentError
(
  const uint32_t  *CardStatusPtr,
  uint8_t *ErrorPtr
)
{
 8006a00:	b480      	push	{r7}
 8006a02:	b083      	sub	sp, #12
 8006a04:	af00      	add	r7, sp, #0
 8006a06:	6078      	str	r0, [r7, #4]
 8006a08:	6039      	str	r1, [r7, #0]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* The command's argument was out of the allowed range for this card.*/
/* <<<DD_SDMMC_nonAPI_4_1>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_OUT_OF_RANGE_BITMASK ) != 0)
 8006a0a:	687b      	ldr	r3, [r7, #4]
 8006a0c:	681b      	ldr	r3, [r3, #0]
 8006a0e:	2b00      	cmp	r3, #0
 8006a10:	da03      	bge.n	8006a1a <SDMMC003_lCheckArgumentError+0x1a>
  {
    *ErrorPtr = 1UL;
 8006a12:	683b      	ldr	r3, [r7, #0]
 8006a14:	f04f 0201 	mov.w	r2, #1
 8006a18:	701a      	strb	r2, [r3, #0]
  } /*End of "if( *CardStatusPtr & CSR_OUT_OF_RANGE_BITMASK ) "*/

  /* A mis-aligned address which did not match the block length was used in
   * the command.*/
/* <<<DD_SDMMC_nonAPI_4_2>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_ADDRESS_ERROR_BITMASK) != 0)
 8006a1a:	687b      	ldr	r3, [r7, #4]
 8006a1c:	681b      	ldr	r3, [r3, #0]
 8006a1e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8006a22:	2b00      	cmp	r3, #0
 8006a24:	d003      	beq.n	8006a2e <SDMMC003_lCheckArgumentError+0x2e>
  {
    *ErrorPtr = 1UL;
 8006a26:	683b      	ldr	r3, [r7, #0]
 8006a28:	f04f 0201 	mov.w	r2, #1
 8006a2c:	701a      	strb	r2, [r3, #0]
  } /*End of " if ( *CardStatusPtr & CSR_ADDRESS_ERROR_BITMASK) "*/

  /* The transferred block length is not allowed for this card, or the number
   * of transferred bytes does not match the block length.*/
/* <<<DD_SDMMC_nonAPI_4_3>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_BLOCK_LEN_ERROR_BITMASK) != 0)
 8006a2e:	687b      	ldr	r3, [r7, #4]
 8006a30:	681b      	ldr	r3, [r3, #0]
 8006a32:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8006a36:	2b00      	cmp	r3, #0
 8006a38:	d003      	beq.n	8006a42 <SDMMC003_lCheckArgumentError+0x42>
  {
    *ErrorPtr = 1UL;
 8006a3a:	683b      	ldr	r3, [r7, #0]
 8006a3c:	f04f 0201 	mov.w	r2, #1
 8006a40:	701a      	strb	r2, [r3, #0]
  }/*End of " if (*CardStatusPtr & CSR_BLOCK_LEN_ERROR_BITMASK) "*/

  /* Set when the host attempts to write to a protected block or to the
     temporary or permanent write protected card.*/
/* <<<DD_SDMMC_nonAPI_4_4>>> */
  if (( *CardStatusPtr & SDMMC003_CSR_WP_VIOLATION_BITMASK ) != 0)
 8006a42:	687b      	ldr	r3, [r7, #4]
 8006a44:	681b      	ldr	r3, [r3, #0]
 8006a46:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8006a4a:	2b00      	cmp	r3, #0
 8006a4c:	d003      	beq.n	8006a56 <SDMMC003_lCheckArgumentError+0x56>
  {
    *ErrorPtr = 1UL;
 8006a4e:	683b      	ldr	r3, [r7, #0]
 8006a50:	f04f 0201 	mov.w	r2, #1
 8006a54:	701a      	strb	r2, [r3, #0]
    ERROR(GID_SDMMC00x,SDMMC003_WP_VIOLATION_ERROR,0,NULL);
  }/*End of "if ( *CardStatusPtr & CSR_WP_VIOLATION_BITMASK ) "*/
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
}
 8006a56:	f107 070c 	add.w	r7, r7, #12
 8006a5a:	46bd      	mov	sp, r7
 8006a5c:	bc80      	pop	{r7}
 8006a5e:	4770      	bx	lr

08006a60 <SDMMC003_lCheckEraseError>:
void SDMMC003_lCheckEraseError
(
  const uint32_t *CardStatusPtr,
  uint8_t *ErrorPtr
)
{
 8006a60:	b480      	push	{r7}
 8006a62:	b083      	sub	sp, #12
 8006a64:	af00      	add	r7, sp, #0
 8006a66:	6078      	str	r0, [r7, #4]
 8006a68:	6039      	str	r1, [r7, #0]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /* An error in the sequence of erase commands occurred.*/
/* <<<DD_SDMMC_nonAPI_5_1>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_ERASE_SEQ_ERROR_BITMASK) != 0)
 8006a6a:	687b      	ldr	r3, [r7, #4]
 8006a6c:	681b      	ldr	r3, [r3, #0]
 8006a6e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8006a72:	2b00      	cmp	r3, #0
 8006a74:	d003      	beq.n	8006a7e <SDMMC003_lCheckEraseError+0x1e>
  {
    *ErrorPtr = 1UL;
 8006a76:	683b      	ldr	r3, [r7, #0]
 8006a78:	f04f 0201 	mov.w	r2, #1
 8006a7c:	701a      	strb	r2, [r3, #0]
    ERROR(GID_SDMMC00x,SDMMC003_ERASE_SEQ_ERROR,0,NULL);
  }
  /* An invalid selection of write-blocks for erase occurred.*/
/* <<<DD_SDMMC_nonAPI_5_2>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_ERASE_PARAM_BITMASK) != 0)
 8006a7e:	687b      	ldr	r3, [r7, #4]
 8006a80:	681b      	ldr	r3, [r3, #0]
 8006a82:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8006a86:	2b00      	cmp	r3, #0
 8006a88:	d003      	beq.n	8006a92 <SDMMC003_lCheckEraseError+0x32>
  {
    *ErrorPtr = 1UL;
 8006a8a:	683b      	ldr	r3, [r7, #0]
 8006a8c:	f04f 0201 	mov.w	r2, #1
 8006a90:	701a      	strb	r2, [r3, #0]
  }
  /* Set when only partial address space was erased due to existing
   * write protected blocks or the temporary or permanent write protected card
   *  was erased.*/
/* <<<DD_SDMMC_nonAPI_5_3>>> */
  if (( *CardStatusPtr & SDMMC003_CSR_WP_ERASE_SKIP_BITMASK) != 0)
 8006a92:	687b      	ldr	r3, [r7, #4]
 8006a94:	681b      	ldr	r3, [r3, #0]
 8006a96:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8006a9a:	2b00      	cmp	r3, #0
 8006a9c:	d003      	beq.n	8006aa6 <SDMMC003_lCheckEraseError+0x46>
  {
    *ErrorPtr = 1UL;
 8006a9e:	683b      	ldr	r3, [r7, #0]
 8006aa0:	f04f 0201 	mov.w	r2, #1
 8006aa4:	701a      	strb	r2, [r3, #0]
    ERROR(GID_SDMMC00x,SDMMC003_WP_ERASE_SKIP_ERROR,0,NULL);
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
}
 8006aa6:	f107 070c 	add.w	r7, r7, #12
 8006aaa:	46bd      	mov	sp, r7
 8006aac:	bc80      	pop	{r7}
 8006aae:	4770      	bx	lr

08006ab0 <SDMMC003_lCheckCardError>:
void SDMMC003_lCheckCardError
(
  const uint32_t *CardStatusPtr,
  uint8_t *ErrorPtr
)
{
 8006ab0:	b480      	push	{r7}
 8006ab2:	b083      	sub	sp, #12
 8006ab4:	af00      	add	r7, sp, #0
 8006ab6:	6078      	str	r0, [r7, #4]
 8006ab8:	6039      	str	r1, [r7, #0]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* Card internal ECC was applied but failed to correct the data.*/
/* <<<DD_SDMMC_nonAPI_6_1>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_CARD_ECC_FAILED_BITMASK) != 0UL)
 8006aba:	687b      	ldr	r3, [r7, #4]
 8006abc:	681b      	ldr	r3, [r3, #0]
 8006abe:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8006ac2:	2b00      	cmp	r3, #0
 8006ac4:	d003      	beq.n	8006ace <SDMMC003_lCheckCardError+0x1e>
  {
    *ErrorPtr = 1UL;
 8006ac6:	683b      	ldr	r3, [r7, #0]
 8006ac8:	f04f 0201 	mov.w	r2, #1
 8006acc:	701a      	strb	r2, [r3, #0]
    ERROR(GID_SDMMC00x,SDMMC003_CARD_ECC_ERROR,0,NULL);
  }
  /* Internal card controller error*/
/* <<<DD_SDMMC_nonAPI_6_2>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_CC_ERROR_BITMASK) != 0UL)
 8006ace:	687b      	ldr	r3, [r7, #4]
 8006ad0:	681b      	ldr	r3, [r3, #0]
 8006ad2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8006ad6:	2b00      	cmp	r3, #0
 8006ad8:	d003      	beq.n	8006ae2 <SDMMC003_lCheckCardError+0x32>
  {
    *ErrorPtr = 1UL;
 8006ada:	683b      	ldr	r3, [r7, #0]
 8006adc:	f04f 0201 	mov.w	r2, #1
 8006ae0:	701a      	strb	r2, [r3, #0]
    ERROR(GID_SDMMC00x,SDMMC003_CC_ERROR,0,NULL);
  }
/* <<<DD_SDMMC_nonAPI_6_3>>> */
  /* A general or an unknown error occurred during the operation.*/
  if ((*CardStatusPtr & SDMMC003_CSR_ERROR_BITMASK) != 0)
 8006ae2:	687b      	ldr	r3, [r7, #4]
 8006ae4:	681b      	ldr	r3, [r3, #0]
 8006ae6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8006aea:	2b00      	cmp	r3, #0
 8006aec:	d003      	beq.n	8006af6 <SDMMC003_lCheckCardError+0x46>
  {
    *ErrorPtr = 1UL;
 8006aee:	683b      	ldr	r3, [r7, #0]
 8006af0:	f04f 0201 	mov.w	r2, #1
 8006af4:	701a      	strb	r2, [r3, #0]
    ERROR(GID_SDMMC00x,SDMMC003_UNKNOWN_ERROR,0,NULL);
  }
  /* Debug Log message .*/
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
}
 8006af6:	f107 070c 	add.w	r7, r7, #12
 8006afa:	46bd      	mov	sp, r7
 8006afc:	bc80      	pop	{r7}
 8006afe:	4770      	bx	lr

08006b00 <SDMMC003_lCheckErrorInResponse>:
/*<<<DD_SDMMC_nonAPI_7>>> */
/*
 * This function checks for any error in the command's response received.
 */
status_t SDMMC003_lCheckErrorInResponse( const uint32_t *CardStatusPtr)
{
 8006b00:	b580      	push	{r7, lr}
 8006b02:	b084      	sub	sp, #16
 8006b04:	af00      	add	r7, sp, #0
 8006b06:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8006b08:	f04f 0300 	mov.w	r3, #0
 8006b0c:	60fb      	str	r3, [r7, #12]
  uint8_t ErrorStatus = 0;      /* No Error */
 8006b0e:	f04f 0300 	mov.w	r3, #0
 8006b12:	72fb      	strb	r3, [r7, #11]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /* Argument Related Error Function */
  SDMMC003_lCheckArgumentError( CardStatusPtr, &ErrorStatus );
 8006b14:	f107 030b 	add.w	r3, r7, #11
 8006b18:	6878      	ldr	r0, [r7, #4]
 8006b1a:	4619      	mov	r1, r3
 8006b1c:	f7ff ff70 	bl	8006a00 <SDMMC003_lCheckArgumentError>

  /* Erase Related Error function  */
  SDMMC003_lCheckEraseError( CardStatusPtr, &ErrorStatus);
 8006b20:	f107 030b 	add.w	r3, r7, #11
 8006b24:	6878      	ldr	r0, [r7, #4]
 8006b26:	4619      	mov	r1, r3
 8006b28:	f7ff ff9a 	bl	8006a60 <SDMMC003_lCheckEraseError>

  /* Card Related Error function */
  SDMMC003_lCheckCardError(CardStatusPtr, &ErrorStatus);
 8006b2c:	f107 030b 	add.w	r3, r7, #11
 8006b30:	6878      	ldr	r0, [r7, #4]
 8006b32:	4619      	mov	r1, r3
 8006b34:	f7ff ffbc 	bl	8006ab0 <SDMMC003_lCheckCardError>

  /* Set when a sequence or password error has been detected in lock/unlock
   * card command.*/
/*<<<DD_SDMMC_nonAPI_7_1>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_LOCK_UNLOCK_FAILED_BITMASK) != 0)
 8006b38:	687b      	ldr	r3, [r7, #4]
 8006b3a:	681b      	ldr	r3, [r3, #0]
 8006b3c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8006b40:	2b00      	cmp	r3, #0
 8006b42:	d002      	beq.n	8006b4a <SDMMC003_lCheckErrorInResponse+0x4a>
  {
    ErrorStatus = 1UL;
 8006b44:	f04f 0301 	mov.w	r3, #1
 8006b48:	72fb      	strb	r3, [r7, #11]
  /* Can be either one of the following errors:
   * The read only section of the CSD does not match the card content.
   *  An attempt to reverse the copy  or permanent WP  bits was made.
   */
/*<<<DD_SDMMC_nonAPI_7_4>>> */
  if ((*CardStatusPtr & SDMMC003_CSR_CSD_OVERWRITE_BITMASK) != 0)
 8006b4a:	687b      	ldr	r3, [r7, #4]
 8006b4c:	681b      	ldr	r3, [r3, #0]
 8006b4e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8006b52:	2b00      	cmp	r3, #0
 8006b54:	d002      	beq.n	8006b5c <SDMMC003_lCheckErrorInResponse+0x5c>
  {
    ErrorStatus = 1UL;
 8006b56:	f04f 0301 	mov.w	r3, #1
 8006b5a:	72fb      	strb	r3, [r7, #11]
    ERROR(GID_SDMMC00x,SDMMC003_CSD_OVERWRITE,0,NULL);
  }
/*<<<DD_SDMMC_nonAPI_7_5>>> */
  /* Error in the sequence of the authentication process*/
  if ((*CardStatusPtr & SDMMC003_CSR_ASK_SEQ_ERROR_BITMASK) != 0)
 8006b5c:	687b      	ldr	r3, [r7, #4]
 8006b5e:	681b      	ldr	r3, [r3, #0]
 8006b60:	f003 0308 	and.w	r3, r3, #8
 8006b64:	2b00      	cmp	r3, #0
 8006b66:	d002      	beq.n	8006b6e <SDMMC003_lCheckErrorInResponse+0x6e>
  {
    ErrorStatus = 1UL;
 8006b68:	f04f 0301 	mov.w	r3, #1
 8006b6c:	72fb      	strb	r3, [r7, #11]
    ERROR(GID_SDMMC00x,SDMMC003_ASK_SEQ_ERROR,0,NULL);
  }
  /* Below Additional condition is because some SD cards treat CMD55 as Illegal
   * Command and gives this error in response */
/*<<<DD_SDMMC_nonAPI_7_6>>> */
  if (ErrorStatus == 1UL) 
 8006b6e:	7afb      	ldrb	r3, [r7, #11]
 8006b70:	2b01      	cmp	r3, #1
 8006b72:	d102      	bne.n	8006b7a <SDMMC003_lCheckErrorInResponse+0x7a>
  {
    Status = (uint32_t) SDMMC003_ERROR;
 8006b74:	f04f 0301 	mov.w	r3, #1
 8006b78:	60fb      	str	r3, [r7, #12]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8006b7a:	68fb      	ldr	r3, [r7, #12]
}
 8006b7c:	4618      	mov	r0, r3
 8006b7e:	f107 0710 	add.w	r7, r7, #16
 8006b82:	46bd      	mov	sp, r7
 8006b84:	bd80      	pop	{r7, pc}
 8006b86:	bf00      	nop

08006b88 <SDMMC003_lGetCardLockState>:

/*
 * This function checks for lock status of SDMMC card.
 */
void SDMMC003_lGetCardLockState(uint32_t CardStatus, uint16_t CommandIndex)
{
 8006b88:	b480      	push	{r7}
 8006b8a:	b083      	sub	sp, #12
 8006b8c:	af00      	add	r7, sp, #0
 8006b8e:	6078      	str	r0, [r7, #4]
 8006b90:	460b      	mov	r3, r1
 8006b92:	807b      	strh	r3, [r7, #2]
  if (((CardStatus & SDMMC003_CSR_CARD_IS_LOCKED_BITMASK) != 0) &&
 8006b94:	687b      	ldr	r3, [r7, #4]
 8006b96:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8006b9a:	2b00      	cmp	r3, #0
 8006b9c:	d011      	beq.n	8006bc2 <SDMMC003_lGetCardLockState+0x3a>
 8006b9e:	887b      	ldrh	r3, [r7, #2]
 8006ba0:	2b03      	cmp	r3, #3
 8006ba2:	d00e      	beq.n	8006bc2 <SDMMC003_lGetCardLockState+0x3a>
      (CommandIndex != SDMMC003_SEND_RELATIVE_ADDR ))
  {
    SDMMC003_Handle.State |= SDMMC003_STATE_CARD_LOCKED ;
 8006ba4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006ba8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bac:	881b      	ldrh	r3, [r3, #0]
 8006bae:	b29b      	uxth	r3, r3
 8006bb0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006bb4:	b29a      	uxth	r2, r3
 8006bb6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bbe:	801a      	strh	r2, [r3, #0]
 8006bc0:	e00d      	b.n	8006bde <SDMMC003_lGetCardLockState+0x56>
  }
  else
  {
    SDMMC003_Handle.State &= ~SDMMC003_STATE_CARD_LOCKED ;
 8006bc2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006bc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bca:	881b      	ldrh	r3, [r3, #0]
 8006bcc:	b29b      	uxth	r3, r3
 8006bce:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8006bd2:	b29a      	uxth	r2, r3
 8006bd4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006bd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bdc:	801a      	strh	r2, [r3, #0]
  }
}
 8006bde:	f107 070c 	add.w	r7, r7, #12
 8006be2:	46bd      	mov	sp, r7
 8006be4:	bc80      	pop	{r7}
 8006be6:	4770      	bx	lr

08006be8 <SDMMC003_lTransferDelay>:

/*
 * This function provide the delay in transfer.
 */
status_t SDMMC003_lTransferDelay(uint32_t DelayTime)
{
 8006be8:	b580      	push	{r7, lr}
 8006bea:	b084      	sub	sp, #16
 8006bec:	af00      	add	r7, sp, #0
 8006bee:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8006bf0:	f04f 0300 	mov.w	r3, #0
 8006bf4:	60fb      	str	r3, [r7, #12]
  handle_t TimerId;
  SDMMC003_Handle.TimerExpire = 1;
 8006bf6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006bfe:	f04f 0201 	mov.w	r2, #1
 8006c02:	729a      	strb	r2, [r3, #10]
  TimerId = SDMMC003_lStartTimer(DelayTime);
 8006c04:	6878      	ldr	r0, [r7, #4]
 8006c06:	f001 fd55 	bl	80086b4 <SDMMC003_lStartTimer>
 8006c0a:	60b8      	str	r0, [r7, #8]
  if(0 == TimerId)
 8006c0c:	68bb      	ldr	r3, [r7, #8]
 8006c0e:	2b00      	cmp	r3, #0
 8006c10:	d102      	bne.n	8006c18 <SDMMC003_lTransferDelay+0x30>
  {
    Status = (uint32_t) SDMMC003_START_TIMER_FAILED;
 8006c12:	f04f 032f 	mov.w	r3, #47	; 0x2f
 8006c16:	60fb      	str	r3, [r7, #12]
  }
  if(Status != (uint32_t) SDMMC003_START_TIMER_FAILED)
 8006c18:	68fb      	ldr	r3, [r7, #12]
 8006c1a:	2b2f      	cmp	r3, #47	; 0x2f
 8006c1c:	d01d      	beq.n	8006c5a <SDMMC003_lTransferDelay+0x72>
  {
    do
    {
      if (SDMMC003_Handle.TimerExpire == 0)
 8006c1e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006c22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c26:	7a9b      	ldrb	r3, [r3, #10]
 8006c28:	b2db      	uxtb	r3, r3
 8006c2a:	2b00      	cmp	r3, #0
 8006c2c:	d103      	bne.n	8006c36 <SDMMC003_lTransferDelay+0x4e>
      {
        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;
 8006c2e:	f04f 032e 	mov.w	r3, #46	; 0x2e
 8006c32:	60fb      	str	r3, [r7, #12]
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 8006c34:	e007      	b.n	8006c46 <SDMMC003_lTransferDelay+0x5e>
      }
    } while (SDMMC003_ISRContext.TransferFlag == 0);
 8006c36:	f246 432c 	movw	r3, #25644	; 0x642c
 8006c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c3e:	791b      	ldrb	r3, [r3, #4]
 8006c40:	b2db      	uxtb	r3, r3
 8006c42:	2b00      	cmp	r3, #0
 8006c44:	d0eb      	beq.n	8006c1e <SDMMC003_lTransferDelay+0x36>
    SDMMC003_ISRContext.TransferFlag = 0;
 8006c46:	f246 432c 	movw	r3, #25644	; 0x642c
 8006c4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c4e:	f04f 0200 	mov.w	r2, #0
 8006c52:	711a      	strb	r2, [r3, #4]
    SDMMC003_lStopTimer(TimerId);
 8006c54:	68b8      	ldr	r0, [r7, #8]
 8006c56:	f001 fd61 	bl	800871c <SDMMC003_lStopTimer>
  }
/* <<<DD_SDMMC_nonAPI_22_6>>> */
  if( SDMMC003_Handle.TransferInterruptError != SDMMC003_TRANSFER_COMPLETE)
 8006c5a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c62:	795b      	ldrb	r3, [r3, #5]
 8006c64:	b2db      	uxtb	r3, r3
 8006c66:	2b1f      	cmp	r3, #31
 8006c68:	d006      	beq.n	8006c78 <SDMMC003_lTransferDelay+0x90>
  {
    Status = (uint32_t)SDMMC003_Handle.DataInterruptError;
 8006c6a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006c6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c72:	78db      	ldrb	r3, [r3, #3]
 8006c74:	b2db      	uxtb	r3, r3
 8006c76:	60fb      	str	r3, [r7, #12]
  }
  return Status;
 8006c78:	68fb      	ldr	r3, [r7, #12]
}
 8006c7a:	4618      	mov	r0, r3
 8006c7c:	f107 0710 	add.w	r7, r7, #16
 8006c80:	46bd      	mov	sp, r7
 8006c82:	bd80      	pop	{r7, pc}

08006c84 <SDMMC003_lReadResponse>:
(
   const SDMMC003_CommandType *CommandPtr,
   SDMMC003_ResponseType ResponseType,
   void *ResponsePtr
)
{
 8006c84:	b580      	push	{r7, lr}
 8006c86:	b088      	sub	sp, #32
 8006c88:	af00      	add	r7, sp, #0
 8006c8a:	60f8      	str	r0, [r7, #12]
 8006c8c:	460b      	mov	r3, r1
 8006c8e:	607a      	str	r2, [r7, #4]
 8006c90:	72fb      	strb	r3, [r7, #11]
  uint32_t CardStatus = 0;
 8006c92:	f04f 0300 	mov.w	r3, #0
 8006c96:	617b      	str	r3, [r7, #20]
  uint32_t ErrorStatus = 0;
 8006c98:	f04f 0300 	mov.w	r3, #0
 8006c9c:	613b      	str	r3, [r7, #16]
  uint32_t *TmpPtr;
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8006c9e:	f04f 0300 	mov.w	r3, #0
 8006ca2:	61fb      	str	r3, [r7, #28]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /* Check for  No response type commands */
/*<<<DD_SDMMC_nonAPI_8_1>>> */
  if (CommandPtr->CommandIndex == SDMMC003_GO_IDLE_STATE || \
 8006ca4:	68fb      	ldr	r3, [r7, #12]
 8006ca6:	785b      	ldrb	r3, [r3, #1]
 8006ca8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8006cac:	b2db      	uxtb	r3, r3
 8006cae:	2b00      	cmp	r3, #0
 8006cb0:	d006      	beq.n	8006cc0 <SDMMC003_lReadResponse+0x3c>
      CommandPtr->CommandIndex == SDMMC003_GO_INACTIVE_STATE)
 8006cb2:	68fb      	ldr	r3, [r7, #12]
 8006cb4:	785b      	ldrb	r3, [r3, #1]
 8006cb6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8006cba:	b2db      	uxtb	r3, r3
  uint32_t *TmpPtr;
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /* Check for  No response type commands */
/*<<<DD_SDMMC_nonAPI_8_1>>> */
  if (CommandPtr->CommandIndex == SDMMC003_GO_IDLE_STATE || \
 8006cbc:	2b0f      	cmp	r3, #15
 8006cbe:	d103      	bne.n	8006cc8 <SDMMC003_lReadResponse+0x44>
      CommandPtr->CommandIndex == SDMMC003_GO_INACTIVE_STATE)
  {
    Status = (uint32_t)DAVEApp_SUCCESS;
 8006cc0:	f04f 0300 	mov.w	r3, #0
 8006cc4:	61fb      	str	r3, [r7, #28]
 8006cc6:	e089      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>
  }
/*<<<DD_SDMMC_nonAPI_8_2>>> */
  else
  {
    TmpPtr = (uint32_t *)ResponsePtr;
 8006cc8:	687b      	ldr	r3, [r7, #4]
 8006cca:	61bb      	str	r3, [r7, #24]
    CardStatus = SDMMC->RESPONSE0;
 8006ccc:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006cd0:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006cd4:	691b      	ldr	r3, [r3, #16]
 8006cd6:	617b      	str	r3, [r7, #20]
    /* Check Lock Status */
/*<<<DD_SDMMC_nonAPI_8_3>>> */
    SDMMC003_lGetCardLockState(CardStatus, CommandPtr->CommandIndex);
 8006cd8:	697a      	ldr	r2, [r7, #20]
 8006cda:	68fb      	ldr	r3, [r7, #12]
 8006cdc:	881b      	ldrh	r3, [r3, #0]
 8006cde:	f3c3 2305 	ubfx	r3, r3, #8, #6
 8006ce2:	b2db      	uxtb	r3, r3
 8006ce4:	4610      	mov	r0, r2
 8006ce6:	4619      	mov	r1, r3
 8006ce8:	f7ff ff4e 	bl	8006b88 <SDMMC003_lGetCardLockState>
   /* Check response type*/
    switch( ResponseType )
 8006cec:	7afb      	ldrb	r3, [r7, #11]
 8006cee:	2b06      	cmp	r3, #6
 8006cf0:	d86f      	bhi.n	8006dd2 <SDMMC003_lReadResponse+0x14e>
 8006cf2:	a201      	add	r2, pc, #4	; (adr r2, 8006cf8 <SDMMC003_lReadResponse+0x74>)
 8006cf4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006cf8:	08006dcb 	.word	0x08006dcb
 8006cfc:	08006d15 	.word	0x08006d15
 8006d00:	08006d29 	.word	0x08006d29
 8006d04:	08006d51 	.word	0x08006d51
 8006d08:	08006d9b 	.word	0x08006d9b
 8006d0c:	08006da3 	.word	0x08006da3
 8006d10:	08006d9b 	.word	0x08006d9b
    {
      /* Response R1*/
/*<<<DD_SDMMC_nonAPI_8_4>>> */
      case SDMMC003_RESPONSE_R1:
        /* check the error bits in the response */
         *TmpPtr = CardStatus;
 8006d14:	697a      	ldr	r2, [r7, #20]
 8006d16:	69bb      	ldr	r3, [r7, #24]
 8006d18:	601a      	str	r2, [r3, #0]
/*<<<DD_SDMMC_nonAPI_8_5>>> */
        Status = SDMMC003_lCheckErrorInResponse(&CardStatus);
 8006d1a:	f107 0314 	add.w	r3, r7, #20
 8006d1e:	4618      	mov	r0, r3
 8006d20:	f7ff feee 	bl	8006b00 <SDMMC003_lCheckErrorInResponse>
 8006d24:	61f8      	str	r0, [r7, #28]
        break;
 8006d26:	e059      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>
      /* Response R1b*/
/*<<<DD_SDMMC_nonAPI_8_6>>> */
      case SDMMC003_RESPONSE_R1b:
        *TmpPtr = CardStatus;
 8006d28:	697a      	ldr	r2, [r7, #20]
 8006d2a:	69bb      	ldr	r3, [r7, #24]
 8006d2c:	601a      	str	r2, [r3, #0]
        /* check the error bits in the response */
         Status = SDMMC003_lCheckErrorInResponse(&CardStatus);
 8006d2e:	f107 0314 	add.w	r3, r7, #20
 8006d32:	4618      	mov	r0, r3
 8006d34:	f7ff fee4 	bl	8006b00 <SDMMC003_lCheckErrorInResponse>
 8006d38:	61f8      	str	r0, [r7, #28]
         if (Status != (uint32_t)DAVEApp_SUCCESS)
 8006d3a:	69fb      	ldr	r3, [r7, #28]
 8006d3c:	2b00      	cmp	r3, #0
 8006d3e:	d14c      	bne.n	8006dda <SDMMC003_lReadResponse+0x156>
          SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;
        }
#endif  /* SDMMC_UVP_TEST*/
        /* Wait for transfer complete Interrupt */
/*<<<DD_SDMMC_nonAPI_8_7>>> */
        Status = SDMMC003_lTransferDelay(SDMMC003_DELAY_IN_TRANSFER);
 8006d40:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006d44:	f7ff ff50 	bl	8006be8 <SDMMC003_lTransferDelay>
 8006d48:	61f8      	str	r0, [r7, #28]
        if(Status != (uint32_t) DAVEApp_SUCCESS)
 8006d4a:	69fb      	ldr	r3, [r7, #28]
 8006d4c:	2b00      	cmp	r3, #0
        {
          ERROR(GID_SDMMC00x, Status, 0, NULL);
          break;
 8006d4e:	e045      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>
        break;
      /* Response R2*/
/*<<<DD_SDMMC_nonAPI_8_9>>> */
      case SDMMC003_RESPONSE_R2:
        /* Response register R0-R7 */
        *TmpPtr = CardStatus;
 8006d50:	697a      	ldr	r2, [r7, #20]
 8006d52:	69bb      	ldr	r3, [r7, #24]
 8006d54:	601a      	str	r2, [r3, #0]
        TmpPtr++;
 8006d56:	69bb      	ldr	r3, [r7, #24]
 8006d58:	f103 0304 	add.w	r3, r3, #4
 8006d5c:	61bb      	str	r3, [r7, #24]

        *TmpPtr = SDMMC->RESPONSE2;
 8006d5e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006d62:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006d66:	695a      	ldr	r2, [r3, #20]
 8006d68:	69bb      	ldr	r3, [r7, #24]
 8006d6a:	601a      	str	r2, [r3, #0]
        TmpPtr++;
 8006d6c:	69bb      	ldr	r3, [r7, #24]
 8006d6e:	f103 0304 	add.w	r3, r3, #4
 8006d72:	61bb      	str	r3, [r7, #24]

        *TmpPtr = SDMMC->RESPONSE4;
 8006d74:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006d78:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006d7c:	699a      	ldr	r2, [r3, #24]
 8006d7e:	69bb      	ldr	r3, [r7, #24]
 8006d80:	601a      	str	r2, [r3, #0]
        TmpPtr++;
 8006d82:	69bb      	ldr	r3, [r7, #24]
 8006d84:	f103 0304 	add.w	r3, r3, #4
 8006d88:	61bb      	str	r3, [r7, #24]

        *TmpPtr = SDMMC->RESPONSE6;
 8006d8a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006d8e:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006d92:	69da      	ldr	r2, [r3, #28]
 8006d94:	69bb      	ldr	r3, [r7, #24]
 8006d96:	601a      	str	r2, [r3, #0]
        break;
 8006d98:	e020      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>
      case SDMMC003_RESPONSE_R3:

      /* Response R7*/
/*<<<DD_SDMMC_nonAPI_8_11>>> */
      case SDMMC003_RESPONSE_R7:
        *TmpPtr = CardStatus;
 8006d9a:	697a      	ldr	r2, [r7, #20]
 8006d9c:	69bb      	ldr	r3, [r7, #24]
 8006d9e:	601a      	str	r2, [r3, #0]
         break;
 8006da0:	e01c      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>

      /* Response R6*/
/*<<<DD_SDMMC_nonAPI_8_12>>> */
      case SDMMC003_RESPONSE_R6:
        ErrorStatus  = CardStatus & SDMMC_RESPONSE0_RESPONSE0_Msk;
 8006da2:	697b      	ldr	r3, [r7, #20]
 8006da4:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8006da8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8006dac:	613b      	str	r3, [r7, #16]
        Status = SDMMC003_lCheckErrorInResponse(&ErrorStatus);
 8006dae:	f107 0310 	add.w	r3, r7, #16
 8006db2:	4618      	mov	r0, r3
 8006db4:	f7ff fea4 	bl	8006b00 <SDMMC003_lCheckErrorInResponse>
 8006db8:	61f8      	str	r0, [r7, #28]
/*<<<DD_SDMMC_nonAPI_8_13>>> */
        /* Read the 16bit RCA received in Response R1 register */
        *TmpPtr =(uint16_t)((CardStatus & SDMMC_RESPONSE0_RESPONSE1_Msk) >> \
 8006dba:	697b      	ldr	r3, [r7, #20]
 8006dbc:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8006dc0:	b29b      	uxth	r3, r3
 8006dc2:	461a      	mov	r2, r3
 8006dc4:	69bb      	ldr	r3, [r7, #24]
 8006dc6:	601a      	str	r2, [r3, #0]
                              SDMMC003_HC_RESPONSE1_BITPOS );
        break;
 8006dc8:	e008      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>

      /* No response*/
/*<<<DD_SDMMC_nonAPI_8_14>>> */
      case SDMMC003_NO_RESPONSE:
        Status = DAVEApp_SUCCESS;
 8006dca:	f04f 0300 	mov.w	r3, #0
 8006dce:	61fb      	str	r3, [r7, #28]
        break;
 8006dd0:	e004      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>

      default:
        Status = (uint32_t)SDMMC003_ERROR;
 8006dd2:	f04f 0301 	mov.w	r3, #1
 8006dd6:	61fb      	str	r3, [r7, #28]
        break;
 8006dd8:	e000      	b.n	8006ddc <SDMMC003_lReadResponse+0x158>
        *TmpPtr = CardStatus;
        /* check the error bits in the response */
         Status = SDMMC003_lCheckErrorInResponse(&CardStatus);
         if (Status != (uint32_t)DAVEApp_SUCCESS)
         {
           break;
 8006dda:	bf00      	nop
        break;
    } /* End of " switch( ResponseType )"*/
  }/* End of " if (CommandPtr->CommandIndex == SDMMC003_GO_IDLE_STATE || 
               CommandPtr->CommandIndex == SDMMC003_GO_INACTIVE_STATE)"*/
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8006ddc:	69fb      	ldr	r3, [r7, #28]
}
 8006dde:	4618      	mov	r0, r3
 8006de0:	f107 0720 	add.w	r7, r7, #32
 8006de4:	46bd      	mov	sp, r7
 8006de6:	bd80      	pop	{r7, pc}

08006de8 <SDMMC003_lSendCommand>:
  const SDMMC003_CommandType *CommandPtr,
  uint32_t Argument,
  SDMMC003_ResponseType ResponseType,
  void *ResponsePtr
)
{
 8006de8:	b580      	push	{r7, lr}
 8006dea:	b086      	sub	sp, #24
 8006dec:	af00      	add	r7, sp, #0
 8006dee:	60f8      	str	r0, [r7, #12]
 8006df0:	60b9      	str	r1, [r7, #8]
 8006df2:	603b      	str	r3, [r7, #0]
 8006df4:	4613      	mov	r3, r2
 8006df6:	71fb      	strb	r3, [r7, #7]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8006df8:	f04f 0301 	mov.w	r3, #1
 8006dfc:	617b      	str	r3, [r7, #20]
  handle_t TimerId;
  SDMMC003_Handle.IssueAbort = 0UL;  
 8006dfe:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006e02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e06:	f04f 0200 	mov.w	r2, #0
 8006e0a:	72da      	strb	r2, [r3, #11]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    SDMMC003_Handle.CommandInterruptError = SDMMC003_ERROR;
 8006e0c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006e10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e14:	f04f 0201 	mov.w	r2, #1
 8006e18:	711a      	strb	r2, [r3, #4]
    SDMMC003_Handle.DataInterruptError = SDMMC003_ERROR;
 8006e1a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006e1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e22:	f04f 0201 	mov.w	r2, #1
 8006e26:	70da      	strb	r2, [r3, #3]
    /* Data or Command line free */
/*<<<DD_SDMMC_nonAPI_9_1>>>*/
    Status = SDMMC003_lCheckDatCmdline(CommandPtr);
 8006e28:	68f8      	ldr	r0, [r7, #12]
 8006e2a:	f7ff fd81 	bl	8006930 <SDMMC003_lCheckDatCmdline>
 8006e2e:	6178      	str	r0, [r7, #20]
    if ((Status == (uint32_t)SDMMC003_DATA_LINE_BUSY) ||
 8006e30:	697b      	ldr	r3, [r7, #20]
 8006e32:	2b1b      	cmp	r3, #27
 8006e34:	d079      	beq.n	8006f2a <SDMMC003_lSendCommand+0x142>
 8006e36:	697b      	ldr	r3, [r7, #20]
 8006e38:	2b1a      	cmp	r3, #26
 8006e3a:	d076      	beq.n	8006f2a <SDMMC003_lSendCommand+0x142>
        (Status == (uint32_t)SDMMC003_CMD_LINE_BUSY))
    {
      break;
    }
      /* Set argument register */
    SDMMC->ARGUMENT1 = Argument;
 8006e3c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006e40:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006e44:	68ba      	ldr	r2, [r7, #8]
 8006e46:	609a      	str	r2, [r3, #8]
    /* Set command register */
    SDMMC->COMMAND = (uint16_t)(*(uint16_t *)CommandPtr);
 8006e48:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8006e4c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8006e50:	68fa      	ldr	r2, [r7, #12]
 8006e52:	8812      	ldrh	r2, [r2, #0]
 8006e54:	81da      	strh	r2, [r3, #14]
      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;
    }
#endif  /*SDMMC_UVP_TEST*/   
/* Blocking until any of the bit in the Interrupt Status Register gets set */
/*<<<DD_SDMMC_nonAPI_9_2>>>*/
    TimerId = SDMMC003_lStartTimer(SDMMC003_DELAY_IN_COMMAND);
 8006e56:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006e5a:	f001 fc2b 	bl	80086b4 <SDMMC003_lStartTimer>
 8006e5e:	6138      	str	r0, [r7, #16]
    if(0 == TimerId)
 8006e60:	693b      	ldr	r3, [r7, #16]
 8006e62:	2b00      	cmp	r3, #0
 8006e64:	d103      	bne.n	8006e6e <SDMMC003_lSendCommand+0x86>
    {
      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;
 8006e66:	f04f 032f 	mov.w	r3, #47	; 0x2f
 8006e6a:	617b      	str	r3, [r7, #20]
      ERROR(GID_SDMMC00x, Status, 0, NULL);    
      break;
 8006e6c:	e05d      	b.n	8006f2a <SDMMC003_lSendCommand+0x142>
    }
    do
    {
      if (SDMMC003_Handle.TimerExpire == 0)
 8006e6e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006e72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e76:	7a9b      	ldrb	r3, [r3, #10]
 8006e78:	b2db      	uxtb	r3, r3
 8006e7a:	2b00      	cmp	r3, #0
 8006e7c:	d008      	beq.n	8006e90 <SDMMC003_lSendCommand+0xa8>
      {
        ERROR(GID_SDMMC00x, SDMMC003_TIMEOUT_OCCURED, 0, NULL);
        break;
      }
    } while (SDMMC003_ISRContext.CmdFlag == 0);
 8006e7e:	f246 432c 	movw	r3, #25644	; 0x642c
 8006e82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e86:	789b      	ldrb	r3, [r3, #2]
 8006e88:	b2db      	uxtb	r3, r3
 8006e8a:	2b00      	cmp	r3, #0
 8006e8c:	d0ef      	beq.n	8006e6e <SDMMC003_lSendCommand+0x86>
 8006e8e:	e000      	b.n	8006e92 <SDMMC003_lSendCommand+0xaa>
    do
    {
      if (SDMMC003_Handle.TimerExpire == 0)
      {
        ERROR(GID_SDMMC00x, SDMMC003_TIMEOUT_OCCURED, 0, NULL);
        break;
 8006e90:	bf00      	nop
      }
    } while (SDMMC003_ISRContext.CmdFlag == 0);
    SDMMC003_ISRContext.CmdFlag = 0;
 8006e92:	f246 432c 	movw	r3, #25644	; 0x642c
 8006e96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e9a:	f04f 0200 	mov.w	r2, #0
 8006e9e:	709a      	strb	r2, [r3, #2]
    SDMMC003_lStopTimer(TimerId);
 8006ea0:	6938      	ldr	r0, [r7, #16]
 8006ea2:	f001 fc3b 	bl	800871c <SDMMC003_lStopTimer>
   /* Check for any errors */
/*<<<DD_SDMMC_nonAPI_9_3>>> */
    if( SDMMC003_Handle.CommandInterruptError == SDMMC003_COMMAND_COMPLETE )
 8006ea6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006eaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006eae:	791b      	ldrb	r3, [r3, #4]
 8006eb0:	b2db      	uxtb	r3, r3
 8006eb2:	2b1c      	cmp	r3, #28
 8006eb4:	d107      	bne.n	8006ec6 <SDMMC003_lSendCommand+0xde>
        break;
      }
#endif
      /* Read response received. */
/*<<<DD_SDMMC_nonAPI_9_4>>>*/
      Status = SDMMC003_lReadResponse(CommandPtr,ResponseType,ResponsePtr);
 8006eb6:	79fb      	ldrb	r3, [r7, #7]
 8006eb8:	68f8      	ldr	r0, [r7, #12]
 8006eba:	4619      	mov	r1, r3
 8006ebc:	683a      	ldr	r2, [r7, #0]
 8006ebe:	f7ff fee1 	bl	8006c84 <SDMMC003_lReadResponse>
 8006ec2:	6178      	str	r0, [r7, #20]
      break;
 8006ec4:	e031      	b.n	8006f2a <SDMMC003_lSendCommand+0x142>
    }
/*<<<DD_SDMMC_nonAPI_9_5>>>*/
    /* For Cmd8, check for  Command Timeout Interrupt */
    else if ((CommandPtr->CommandIndex == SDMMC003_SD_SEND_IF_COND) &&
 8006ec6:	68fb      	ldr	r3, [r7, #12]
 8006ec8:	785b      	ldrb	r3, [r3, #1]
 8006eca:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8006ece:	b2db      	uxtb	r3, r3
 8006ed0:	2b08      	cmp	r3, #8
 8006ed2:	d10b      	bne.n	8006eec <SDMMC003_lSendCommand+0x104>
             (SDMMC003_Handle.CommandInterruptError == \
 8006ed4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006edc:	791b      	ldrb	r3, [r3, #4]
 8006ede:	b2db      	uxtb	r3, r3
      Status = SDMMC003_lReadResponse(CommandPtr,ResponseType,ResponsePtr);
      break;
    }
/*<<<DD_SDMMC_nonAPI_9_5>>>*/
    /* For Cmd8, check for  Command Timeout Interrupt */
    else if ((CommandPtr->CommandIndex == SDMMC003_SD_SEND_IF_COND) &&
 8006ee0:	2b02      	cmp	r3, #2
 8006ee2:	d103      	bne.n	8006eec <SDMMC003_lSendCommand+0x104>
             (SDMMC003_Handle.CommandInterruptError == \
                                             SDMMC003_COMMAND_TIMEOUT_ERROR))
    {
      Status = (uint32_t)SDMMC003_COMMAND_TIMEOUT_ERROR;
 8006ee4:	f04f 0302 	mov.w	r3, #2
 8006ee8:	617b      	str	r3, [r7, #20]
      break;
 8006eea:	e01e      	b.n	8006f2a <SDMMC003_lSendCommand+0x142>
    {
      Test_TriggerInterrupt.Trigger_CommandErrorInterrupt = FALSE;
    }
#endif /* SDMMC_UVP_TEST  */
/*<<<DD_SDMMC_nonAPI_9_6>>>*/
    if (CommandPtr->DataPresentSelect == 1)
 8006eec:	68fb      	ldr	r3, [r7, #12]
 8006eee:	781b      	ldrb	r3, [r3, #0]
 8006ef0:	f003 0320 	and.w	r3, r3, #32
 8006ef4:	b2db      	uxtb	r3, r3
 8006ef6:	2b00      	cmp	r3, #0
 8006ef8:	d006      	beq.n	8006f08 <SDMMC003_lSendCommand+0x120>
    {
      SDMMC003_Handle.IssueAbort = 1UL;
 8006efa:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006efe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f02:	f04f 0201 	mov.w	r2, #1
 8006f06:	72da      	strb	r2, [r3, #11]
    }    
    /* Error Recovery for the failed command  */
    Status = SDMMC003_lErrorInterruptRecovery( \
 8006f08:	f246 432c 	movw	r3, #25644	; 0x642c
 8006f0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f10:	881b      	ldrh	r3, [r3, #0]
 8006f12:	b29a      	uxth	r2, r3
 8006f14:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006f18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f1c:	7adb      	ldrb	r3, [r3, #11]
 8006f1e:	b2db      	uxtb	r3, r3
 8006f20:	4610      	mov	r0, r2
 8006f22:	4619      	mov	r1, r3
 8006f24:	f000 fe9e 	bl	8007c64 <SDMMC003_lErrorInterruptRecovery>
 8006f28:	6178      	str	r0, [r7, #20]
                                   SDMMC003_ISRContext.InterruptStatusShadow, \
                                   SDMMC003_Handle.IssueAbort);
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8006f2a:	697b      	ldr	r3, [r7, #20]
}
 8006f2c:	4618      	mov	r0, r3
 8006f2e:	f107 0718 	add.w	r7, r7, #24
 8006f32:	46bd      	mov	sp, r7
 8006f34:	bd80      	pop	{r7, pc}
 8006f36:	bf00      	nop

08006f38 <SDMMC003_lSetVoltageWindow>:
/*<<<DD_SDMMC_nonAPI_10>>> */
/*
 * This function sets the voltage window in OCR register
 */
status_t  SDMMC003_lSetVoltageWindow()
{
 8006f38:	b580      	push	{r7, lr}
 8006f3a:	b084      	sub	sp, #16
 8006f3c:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8006f3e:	f04f 0301 	mov.w	r3, #1
 8006f42:	60fb      	str	r3, [r7, #12]
  uint32_t CardStatus = 0;
 8006f44:	f04f 0300 	mov.w	r3, #0
 8006f48:	603b      	str	r3, [r7, #0]
  uint32_t Argument = 0;
 8006f4a:	f04f 0300 	mov.w	r3, #0
 8006f4e:	60bb      	str	r3, [r7, #8]
  uint32_t LoopCount= 0;
 8006f50:	f04f 0300 	mov.w	r3, #0
 8006f54:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
/* <<<DD_SDMMC_nonAPI_10_1>>> */
  /* For Standard Capacity Card  */
  if (SDMMC003_Handle.f8 == 0)
 8006f56:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8006f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f5e:	7a5b      	ldrb	r3, [r3, #9]
 8006f60:	b2db      	uxtb	r3, r3
 8006f62:	2b00      	cmp	r3, #0
 8006f64:	d103      	bne.n	8006f6e <SDMMC003_lSetVoltageWindow+0x36>
  {
    /* Set HCS = 0  */
    Argument = SDMMC003_SD_ACMD41_F80_ARG;
 8006f66:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006f6a:	60bb      	str	r3, [r7, #8]
 8006f6c:	e004      	b.n	8006f78 <SDMMC003_lSetVoltageWindow+0x40>
/* <<<DD_SDMMC_nonAPI_10_2>>> */
  /* For High Capacity Card */
  else
  {
    /* Set  HCS = 1 */
    Argument = SDMMC003_SD_ACMD41_F81_ARG;
 8006f6e:	f04f 0300 	mov.w	r3, #0
 8006f72:	f2c4 0310 	movt	r3, #16400	; 0x4010
 8006f76:	60bb      	str	r3, [r7, #8]
  }
  do
  {
    /*Send Command55 for Application Specific Command with default RCA as 0*/
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), \
 8006f78:	f246 6304 	movw	r3, #26116	; 0x6604
 8006f7c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8006f80:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 8006f84:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8006f88:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8006f8c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8006f90:	18d2      	adds	r2, r2, r3
                                     SDMMC003_ARGUMENT0, SDMMC003_RESPONSE_R1,\
                                     &CardStatus);
 8006f92:	463b      	mov	r3, r7
    Argument = SDMMC003_SD_ACMD41_F81_ARG;
  }
  do
  {
    /*Send Command55 for Application Specific Command with default RCA as 0*/
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), \
 8006f94:	4610      	mov	r0, r2
 8006f96:	f04f 0100 	mov.w	r1, #0
 8006f9a:	f04f 0201 	mov.w	r2, #1
 8006f9e:	f7ff ff23 	bl	8006de8 <SDMMC003_lSendCommand>
 8006fa2:	60f8      	str	r0, [r7, #12]
                                     SDMMC003_ARGUMENT0, SDMMC003_RESPONSE_R1,\
                                     &CardStatus);
/* <<<DD_SDMMC_nonAPI_10_3>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8006fa4:	68fb      	ldr	r3, [r7, #12]
 8006fa6:	2b00      	cmp	r3, #0
 8006fa8:	d138      	bne.n	800701c <SDMMC003_lSetVoltageWindow+0xe4>
    {
      break;
    }
/* Send ACMD41 to Set the card's voltage window */
    Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(62)), Argument,\
 8006faa:	f246 6304 	movw	r3, #26116	; 0x6604
 8006fae:	f6c0 0302 	movt	r3, #2050	; 0x802
 8006fb2:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8006fb6:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8006fba:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8006fbe:	f6c0 0302 	movt	r3, #2050	; 0x802
 8006fc2:	18d3      	adds	r3, r2, r3
 8006fc4:	4618      	mov	r0, r3
 8006fc6:	68b9      	ldr	r1, [r7, #8]
 8006fc8:	f04f 0204 	mov.w	r2, #4
 8006fcc:	f246 4334 	movw	r3, #25652	; 0x6434
 8006fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006fd4:	f7ff ff08 	bl	8006de8 <SDMMC003_lSendCommand>
 8006fd8:	60f8      	str	r0, [r7, #12]
                                  SDMMC003_RESPONSE_R3,&(SDMMC003_CardInfo.Ocr));
/* <<<DD_SDMMC_nonAPI_10_4>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS && \
 8006fda:	68fb      	ldr	r3, [r7, #12]
 8006fdc:	2b00      	cmp	r3, #0
 8006fde:	d002      	beq.n	8006fe6 <SDMMC003_lSetVoltageWindow+0xae>
 8006fe0:	68fb      	ldr	r3, [r7, #12]
 8006fe2:	2b12      	cmp	r3, #18
 8006fe4:	d11c      	bne.n	8007020 <SDMMC003_lSetVoltageWindow+0xe8>
       (Status != (uint32_t)SDMMC003_ILLEGAL_COMMAND_ERROR))
    {
      break;
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
 8006fe6:	f04f 0300 	mov.w	r3, #0
 8006fea:	60fb      	str	r3, [r7, #12]
    /* Cards takes some time to set power status bit. Card must repsond 
    within 1 sec. */
    /* Timeout of 10ms.*/
    SDMMC003_lDelay(SDMMC003_CARD_POWER_DELAY);
 8006fec:	f04f 0014 	mov.w	r0, #20
 8006ff0:	f001 fa6e 	bl	80084d0 <SDMMC003_lDelay>
/* Check for busy bit in the OCR content i.e response */
  } while(!(SDMMC003_CardInfo.Ocr & SDMMC003_OCR_POWER_STATUS_BITMASK) &&\
 8006ff4:	f246 4334 	movw	r3, #25652	; 0x6434
 8006ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006ffc:	681b      	ldr	r3, [r3, #0]
 8006ffe:	2b00      	cmp	r3, #0
 8007000:	db0f      	blt.n	8007022 <SDMMC003_lSetVoltageWindow+0xea>
           ( (LoopCount++)<50 ) );
 8007002:	687b      	ldr	r3, [r7, #4]
 8007004:	2b31      	cmp	r3, #49	; 0x31
 8007006:	bf8c      	ite	hi
 8007008:	2300      	movhi	r3, #0
 800700a:	2301      	movls	r3, #1
 800700c:	b2db      	uxtb	r3, r3
 800700e:	687a      	ldr	r2, [r7, #4]
 8007010:	f102 0201 	add.w	r2, r2, #1
 8007014:	607a      	str	r2, [r7, #4]
    /* Cards takes some time to set power status bit. Card must repsond 
    within 1 sec. */
    /* Timeout of 10ms.*/
    SDMMC003_lDelay(SDMMC003_CARD_POWER_DELAY);
/* Check for busy bit in the OCR content i.e response */
  } while(!(SDMMC003_CardInfo.Ocr & SDMMC003_OCR_POWER_STATUS_BITMASK) &&\
 8007016:	2b00      	cmp	r3, #0
 8007018:	d1ae      	bne.n	8006f78 <SDMMC003_lSetVoltageWindow+0x40>
 800701a:	e002      	b.n	8007022 <SDMMC003_lSetVoltageWindow+0xea>
                                     SDMMC003_ARGUMENT0, SDMMC003_RESPONSE_R1,\
                                     &CardStatus);
/* <<<DD_SDMMC_nonAPI_10_3>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 800701c:	bf00      	nop
 800701e:	e000      	b.n	8007022 <SDMMC003_lSetVoltageWindow+0xea>
                                  SDMMC003_RESPONSE_R3,&(SDMMC003_CardInfo.Ocr));
/* <<<DD_SDMMC_nonAPI_10_4>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS && \
       (Status != (uint32_t)SDMMC003_ILLEGAL_COMMAND_ERROR))
    {
      break;
 8007020:	bf00      	nop
    SDMMC003_lDelay(SDMMC003_CARD_POWER_DELAY);
/* Check for busy bit in the OCR content i.e response */
  } while(!(SDMMC003_CardInfo.Ocr & SDMMC003_OCR_POWER_STATUS_BITMASK) &&\
           ( (LoopCount++)<50 ) );
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8007022:	68fb      	ldr	r3, [r7, #12]
}
 8007024:	4618      	mov	r0, r3
 8007026:	f107 0710 	add.w	r7, r7, #16
 800702a:	46bd      	mov	sp, r7
 800702c:	bd80      	pop	{r7, pc}
 800702e:	bf00      	nop

08007030 <SDMMC003_lQueryOperatingCond>:
/*<<<DD_SDMMC_nonAPI_11>>> */
/*
 * This function queries Voltage operating condition of the card.
 */
status_t SDMMC003_lQueryOperatingCond()
{
 8007030:	b580      	push	{r7, lr}
 8007032:	b082      	sub	sp, #8
 8007034:	af00      	add	r7, sp, #0
  uint32_t ResponseData = 0;
 8007036:	f04f 0300 	mov.w	r3, #0
 800703a:	603b      	str	r3, [r7, #0]
  status_t Status;
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /*Query voltage operating condition i.e. cmd8 */
  Status = SDMMC003_lSendCommand(&(SDMMC003_SD_COMMAND(8)),SDMMC003_SD_CMD8_ARG,\
 800703c:	f246 6304 	movw	r3, #26116	; 0x6604
 8007040:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007044:	7a1b      	ldrb	r3, [r3, #8]
 8007046:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800704a:	f246 53b4 	movw	r3, #26036	; 0x65b4
 800704e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007052:	18d2      	adds	r2, r2, r3
                                  SDMMC003_RESPONSE_R7, &ResponseData );
 8007054:	463b      	mov	r3, r7
{
  uint32_t ResponseData = 0;
  status_t Status;
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /*Query voltage operating condition i.e. cmd8 */
  Status = SDMMC003_lSendCommand(&(SDMMC003_SD_COMMAND(8)),SDMMC003_SD_CMD8_ARG,\
 8007056:	4610      	mov	r0, r2
 8007058:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 800705c:	f04f 0206 	mov.w	r2, #6
 8007060:	f7ff fec2 	bl	8006de8 <SDMMC003_lSendCommand>
 8007064:	6078      	str	r0, [r7, #4]
                                  SDMMC003_RESPONSE_R7, &ResponseData );
  do
  {
/*<<<DD_SDMMC_nonAPI_11_1>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS )
 8007066:	687b      	ldr	r3, [r7, #4]
 8007068:	2b00      	cmp	r3, #0
 800706a:	d012      	beq.n	8007092 <SDMMC003_lQueryOperatingCond+0x62>
    {
/*<<<DD_SDMMC_nonAPI_11_2>>> */
      /*  No response is received for Standard Capacity SD cards or MMC card. */
      if (SDMMC003_Handle.CommandInterruptError ==SDMMC003_COMMAND_TIMEOUT_ERROR)
 800706c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007070:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007074:	791b      	ldrb	r3, [r3, #4]
 8007076:	b2db      	uxtb	r3, r3
 8007078:	2b02      	cmp	r3, #2
 800707a:	d126      	bne.n	80070ca <SDMMC003_lQueryOperatingCond+0x9a>
      {
        SDMMC003_Handle.f8 = 0;
 800707c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007080:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007084:	f04f 0200 	mov.w	r2, #0
 8007088:	725a      	strb	r2, [r3, #9]
        Status = (uint32_t)DAVEApp_SUCCESS;
 800708a:	f04f 0300 	mov.w	r3, #0
 800708e:	607b      	str	r3, [r7, #4]
 8007090:	e01c      	b.n	80070cc <SDMMC003_lQueryOperatingCond+0x9c>
/*<<<DD_SDMMC_nonAPI_11_4>>> */
    else
    {
/*<<<DD_SDMMC_nonAPI_11_5>>> */
      /* Check whether Check pattern matches in the Argument and Response */
      if (((ResponseData >> SDMMC003_SD_CMD8_CHECK_PATTERN_BITPOS) &\
 8007092:	683b      	ldr	r3, [r7, #0]
 8007094:	b2db      	uxtb	r3, r3
 8007096:	2baa      	cmp	r3, #170	; 0xaa
 8007098:	d003      	beq.n	80070a2 <SDMMC003_lQueryOperatingCond+0x72>
             SDMMC003_SD_CMD8_CHECK_PATTERN_BITMASK) != \
            (SDMMC003_SD_CMD8_CHECK_PATTERN_VALUE)
         )
      {
        Status  = (uint32_t)SDMMC003_BAD_RESPONSE;
 800709a:	f04f 0319 	mov.w	r3, #25
 800709e:	607b      	str	r3, [r7, #4]
        break;
 80070a0:	e014      	b.n	80070cc <SDMMC003_lQueryOperatingCond+0x9c>
      }
/*<<<DD_SDMMC_nonAPI_11_6>>> */
      /* Check the Voltage Supplied is Accepted by the card in the response  */
      if( ((uint8_t)( ResponseData >> SDMMC003_SD_CMD8_VHS_BITPOS) &\
 80070a2:	683b      	ldr	r3, [r7, #0]
 80070a4:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80070a8:	b2db      	uxtb	r3, r3
 80070aa:	f003 030f 	and.w	r3, r3, #15
 80070ae:	2b01      	cmp	r3, #1
 80070b0:	d003      	beq.n	80070ba <SDMMC003_lQueryOperatingCond+0x8a>
                     SDMMC003_SD_CMD8_VHS_BITMASK)!=  \
                     ( SDMMC003_SD_VHS_PATTERN_2_7_3_6_VALUE ) )
      {
        Status = (uint32_t)SDMMC003_BAD_RESPONSE;
 80070b2:	f04f 0319 	mov.w	r3, #25
 80070b6:	607b      	str	r3, [r7, #4]
        break;
 80070b8:	e008      	b.n	80070cc <SDMMC003_lQueryOperatingCond+0x9c>
      }
      /* Set Flag f8 */
      SDMMC003_Handle.f8 = 1;
 80070ba:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80070be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80070c2:	f04f 0201 	mov.w	r2, #1
 80070c6:	725a      	strb	r2, [r3, #9]
 80070c8:	e000      	b.n	80070cc <SDMMC003_lQueryOperatingCond+0x9c>
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
      /*<<<DD_SDMMC_nonAPI_11_3>>> */
      else
      {
        break;
 80070ca:	bf00      	nop
      /* Set Flag f8 */
      SDMMC003_Handle.f8 = 1;
    }
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80070cc:	687b      	ldr	r3, [r7, #4]
}
 80070ce:	4618      	mov	r0, r3
 80070d0:	f107 0708 	add.w	r7, r7, #8
 80070d4:	46bd      	mov	sp, r7
 80070d6:	bd80      	pop	{r7, pc}

080070d8 <SDMMC003_lQueryVoltage>:
/*<<<DD_SDMMC_nonAPI_12>>> */
/*
 * This function queries voltage supported from the card.
 */
status_t SDMMC003_lQueryVoltage (uint32_t Argument)
{
 80070d8:	b580      	push	{r7, lr}
 80070da:	b084      	sub	sp, #16
 80070dc:	af00      	add	r7, sp, #0
 80070de:	6078      	str	r0, [r7, #4]
  uint32_t CardStatus = 0;
 80070e0:	f04f 0300 	mov.w	r3, #0
 80070e4:	60bb      	str	r3, [r7, #8]
  status_t Status;
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /* Send Command55 for Application Specific Command with default RCA as 0*/
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), Argument,\
 80070e6:	f246 6304 	movw	r3, #26116	; 0x6604
 80070ea:	f6c0 0302 	movt	r3, #2050	; 0x802
 80070ee:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 80070f2:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80070f6:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80070fa:	f6c0 0302 	movt	r3, #2050	; 0x802
 80070fe:	18d2      	adds	r2, r2, r3
                                    SDMMC003_RESPONSE_R1, &CardStatus);
 8007100:	f107 0308 	add.w	r3, r7, #8
  status_t Status;
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /* Send Command55 for Application Specific Command with default RCA as 0*/
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), Argument,\
 8007104:	4610      	mov	r0, r2
 8007106:	6879      	ldr	r1, [r7, #4]
 8007108:	f04f 0201 	mov.w	r2, #1
 800710c:	f7ff fe6c 	bl	8006de8 <SDMMC003_lSendCommand>
 8007110:	60f8      	str	r0, [r7, #12]
                                    SDMMC003_RESPONSE_R1, &CardStatus);
/* <<<DD_SDMMC_nonAPI_12_1>>> */
    if (Status != DAVEApp_SUCCESS )
 8007112:	68fb      	ldr	r3, [r7, #12]
 8007114:	2b00      	cmp	r3, #0
 8007116:	d00a      	beq.n	800712e <SDMMC003_lQueryVoltage+0x56>
    {
      /* Some SD cards which doesn't supports CMD8 treat cmd55 as illegal so
       * ignore this error */
/*<<<DD_SDMMC_nonAPI_12_2>>> */
      if (!( (Status == (uint32_t)SDMMC003_ILLEGAL_COMMAND_ERROR) && \
 8007118:	68fb      	ldr	r3, [r7, #12]
 800711a:	2b12      	cmp	r3, #18
 800711c:	d131      	bne.n	8007182 <SDMMC003_lQueryVoltage+0xaa>
             (SDMMC003_Handle.f8 == 0) ))
 800711e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007122:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007126:	7a5b      	ldrb	r3, [r3, #9]
 8007128:	b2db      	uxtb	r3, r3
    if (Status != DAVEApp_SUCCESS )
    {
      /* Some SD cards which doesn't supports CMD8 treat cmd55 as illegal so
       * ignore this error */
/*<<<DD_SDMMC_nonAPI_12_2>>> */
      if (!( (Status == (uint32_t)SDMMC003_ILLEGAL_COMMAND_ERROR) && \
 800712a:	2b00      	cmp	r3, #0
 800712c:	d129      	bne.n	8007182 <SDMMC003_lQueryVoltage+0xaa>
      {
        break;
      }
    }
    /* Send ACMD41 to query the card's voltage window */
    Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(62)), Argument,\
 800712e:	f246 6304 	movw	r3, #26116	; 0x6604
 8007132:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007136:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 800713a:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800713e:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8007142:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007146:	18d3      	adds	r3, r2, r3
 8007148:	4618      	mov	r0, r3
 800714a:	6879      	ldr	r1, [r7, #4]
 800714c:	f04f 0204 	mov.w	r2, #4
 8007150:	f246 4334 	movw	r3, #25652	; 0x6434
 8007154:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007158:	f7ff fe46 	bl	8006de8 <SDMMC003_lSendCommand>
 800715c:	60f8      	str	r0, [r7, #12]
                                   SDMMC003_RESPONSE_R3,&(SDMMC003_CardInfo.Ocr));
/*<<<DD_SDMMC_nonAPI_12_3>>> */
    if ( (Status != (uint32_t)DAVEApp_SUCCESS) &&\
 800715e:	68fb      	ldr	r3, [r7, #12]
 8007160:	2b00      	cmp	r3, #0
 8007162:	d002      	beq.n	800716a <SDMMC003_lQueryVoltage+0x92>
 8007164:	68fb      	ldr	r3, [r7, #12]
 8007166:	2b12      	cmp	r3, #18
 8007168:	d108      	bne.n	800717c <SDMMC003_lQueryVoltage+0xa4>
        break;
      }
    }
    /* Send ACMD41 with voltage window argument set */
/*<<<DD_SDMMC_nonAPI_12_5>>> */
    Status = SDMMC003_lSetVoltageWindow();
 800716a:	f7ff fee5 	bl	8006f38 <SDMMC003_lSetVoltageWindow>
 800716e:	60f8      	str	r0, [r7, #12]
    if( Status != (uint32_t)DAVEApp_SUCCESS)
 8007170:	68fb      	ldr	r3, [r7, #12]
 8007172:	2b00      	cmp	r3, #0
 8007174:	d104      	bne.n	8007180 <SDMMC003_lQueryVoltage+0xa8>
    {
      break;
    }
    /* SD Card Type */
/*<<<DD_SDMMC_nonAPI_12_6>>> */
    SDMMC003_lWriteCardType();
 8007176:	f000 f8f5 	bl	8007364 <SDMMC003_lWriteCardType>
 800717a:	e002      	b.n	8007182 <SDMMC003_lQueryVoltage+0xaa>
        break;
      }
      else
#endif /* SDMMC_SUPPORT_MMC_CARD */
      {
        break;
 800717c:	bf00      	nop
 800717e:	e000      	b.n	8007182 <SDMMC003_lQueryVoltage+0xaa>
    /* Send ACMD41 with voltage window argument set */
/*<<<DD_SDMMC_nonAPI_12_5>>> */
    Status = SDMMC003_lSetVoltageWindow();
    if( Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8007180:	bf00      	nop
    /* SD Card Type */
/*<<<DD_SDMMC_nonAPI_12_6>>> */
    SDMMC003_lWriteCardType();
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8007182:	68fb      	ldr	r3, [r7, #12]
}
 8007184:	4618      	mov	r0, r3
 8007186:	f107 0710 	add.w	r7, r7, #16
 800718a:	46bd      	mov	sp, r7
 800718c:	bd80      	pop	{r7, pc}
 800718e:	bf00      	nop

08007190 <SDMMC003_lAfterCardInitialize>:
/*<<<DD_SDMMC_nonAPI_13>>> */
/*
 * This function reads the card registers after the card is initialized.
 */
status_t SDMMC003_lAfterCardInitialize()
{
 8007190:	b580      	push	{r7, lr}
 8007192:	b082      	sub	sp, #8
 8007194:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8007196:	f04f 0301 	mov.w	r3, #1
 800719a:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
   /* Read CSD & SCR Register & Card Write Protection Flags. */
    Status = SDMMC003_lReadCardRegisters();
 800719c:	f000 f984 	bl	80074a8 <SDMMC003_lReadCardRegisters>
 80071a0:	6078      	str	r0, [r7, #4]
/*<<<DD_SDMMC_nonAPI_13_1>>> */
    if(Status != (uint32_t)DAVEApp_SUCCESS)
 80071a2:	687b      	ldr	r3, [r7, #4]
 80071a4:	2b00      	cmp	r3, #0
 80071a6:	d12f      	bne.n	8007208 <SDMMC003_lAfterCardInitialize+0x78>
    {
      break;
    }
#if SDMMC_SUPPORT_4_BUS_WIDTH
    /* Switch  to 4-bit bus width if supported */
    Status = SDMMC003_lSwitchBusWidth();
 80071a8:	f000 fc16 	bl	80079d8 <SDMMC003_lSwitchBusWidth>
 80071ac:	6078      	str	r0, [r7, #4]
/*<<<DD_SDMMC_nonAPI_13_2>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS )
 80071ae:	687b      	ldr	r3, [r7, #4]
 80071b0:	2b00      	cmp	r3, #0
 80071b2:	d00f      	beq.n	80071d4 <SDMMC003_lAfterCardInitialize+0x44>
    {
      /* Change bus width to default in the Host Controller */
      CLR_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_DATA_TX_WIDTH_Pos);
 80071b4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80071b8:	f6c4 0301 	movt	r3, #18433	; 0x4801
 80071bc:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 80071c0:	f6c4 0201 	movt	r2, #18433	; 0x4801
 80071c4:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 80071c8:	b2d2      	uxtb	r2, r2
 80071ca:	f022 0202 	bic.w	r2, r2, #2
 80071ce:	b2d2      	uxtb	r2, r2
 80071d0:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    }
    /* Switch  to High Speed Mode */
    Status = SDMMC003_lSwitchSpeed();
 80071d4:	f000 fc88 	bl	8007ae8 <SDMMC003_lSwitchSpeed>
 80071d8:	6078      	str	r0, [r7, #4]
/*<<<DD_SDMMC_nonAPI_13_3>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS )
 80071da:	687b      	ldr	r3, [r7, #4]
 80071dc:	2b00      	cmp	r3, #0
 80071de:	d014      	beq.n	800720a <SDMMC003_lAfterCardInitialize+0x7a>
    {
      /* Change Speed mode to default in the Host Controller */
      CLR_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_HIGH_SPEED_EN_Pos );
 80071e0:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80071e4:	f6c4 0301 	movt	r3, #18433	; 0x4801
 80071e8:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 80071ec:	f6c4 0201 	movt	r2, #18433	; 0x4801
 80071f0:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 80071f4:	b2d2      	uxtb	r2, r2
 80071f6:	f022 0204 	bic.w	r2, r2, #4
 80071fa:	b2d2      	uxtb	r2, r2
 80071fc:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
      Status = (uint32_t)DAVEApp_SUCCESS;
 8007200:	f04f 0300 	mov.w	r3, #0
 8007204:	607b      	str	r3, [r7, #4]
 8007206:	e000      	b.n	800720a <SDMMC003_lAfterCardInitialize+0x7a>
   /* Read CSD & SCR Register & Card Write Protection Flags. */
    Status = SDMMC003_lReadCardRegisters();
/*<<<DD_SDMMC_nonAPI_13_1>>> */
    if(Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8007208:	bf00      	nop
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
#endif
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 800720a:	687b      	ldr	r3, [r7, #4]
}
 800720c:	4618      	mov	r0, r3
 800720e:	f107 0708 	add.w	r7, r7, #8
 8007212:	46bd      	mov	sp, r7
 8007214:	bd80      	pop	{r7, pc}
 8007216:	bf00      	nop

08007218 <SDMMC003_lInitializeCard>:
/* <<<DD_SDMMC_nonAPI_14>>> */
/*
 * This function initializes the SD card.
 */
status_t SDMMC003_lInitializeCard()
{
 8007218:	b580      	push	{r7, lr}
 800721a:	b084      	sub	sp, #16
 800721c:	af00      	add	r7, sp, #0
  status_t Status;
  uint32_t LockStatus ;
  uint8_t Count= 0;
 800721e:	f04f 0300 	mov.w	r3, #0
 8007222:	72fb      	strb	r3, [r7, #11]
/* <<<DD_SDMMC_nonAPI_14_1>>> */
    /* Repeat the below steps 2 times if bad response is received.    */
    do
    {
      /* Reset the card. i.e cmd0 */
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(0)), \
 8007224:	f246 6304 	movw	r3, #26116	; 0x6604
 8007228:	f6c0 0302 	movt	r3, #2050	; 0x802
 800722c:	781b      	ldrb	r3, [r3, #0]
 800722e:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8007232:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8007236:	f6c0 0302 	movt	r3, #2050	; 0x802
 800723a:	18d3      	adds	r3, r2, r3
 800723c:	4618      	mov	r0, r3
 800723e:	f04f 0100 	mov.w	r1, #0
 8007242:	f04f 0200 	mov.w	r2, #0
 8007246:	f04f 0300 	mov.w	r3, #0
 800724a:	f7ff fdcd 	bl	8006de8 <SDMMC003_lSendCommand>
 800724e:	60f8      	str	r0, [r7, #12]
                                        SDMMC003_ARGUMENT0, \
                                        SDMMC003_NO_RESPONSE, \
                                        NULL);
/* <<<DD_SDMMC_nonAPI_14_2>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 8007250:	68fb      	ldr	r3, [r7, #12]
 8007252:	2b00      	cmp	r3, #0
 8007254:	d10d      	bne.n	8007272 <SDMMC003_lInitializeCard+0x5a>
      {
        break;
      }/* End of "if(Status != DAVEApp_SUCCESS )" */
      /* Query the Operation Condition Info from the card.*/
/* <<<DD_SDMMC_nonAPI_14_3>>> */
      Status = SDMMC003_lQueryOperatingCond();
 8007256:	f7ff feeb 	bl	8007030 <SDMMC003_lQueryOperatingCond>
 800725a:	60f8      	str	r0, [r7, #12]
      Count++;
 800725c:	7afb      	ldrb	r3, [r7, #11]
 800725e:	f103 0301 	add.w	r3, r3, #1
 8007262:	72fb      	strb	r3, [r7, #11]
    } while(( Count < SDMMC003_NUM_CARD_RESET_RETRIES) && \
 8007264:	7afb      	ldrb	r3, [r7, #11]
 8007266:	2b01      	cmp	r3, #1
 8007268:	d804      	bhi.n	8007274 <SDMMC003_lInitializeCard+0x5c>
 800726a:	68fb      	ldr	r3, [r7, #12]
 800726c:	2b19      	cmp	r3, #25
 800726e:	d0d9      	beq.n	8007224 <SDMMC003_lInitializeCard+0xc>
 8007270:	e000      	b.n	8007274 <SDMMC003_lInitializeCard+0x5c>
                                        SDMMC003_NO_RESPONSE, \
                                        NULL);
/* <<<DD_SDMMC_nonAPI_14_2>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 8007272:	bf00      	nop
      Status = SDMMC003_lQueryOperatingCond();
      Count++;
    } while(( Count < SDMMC003_NUM_CARD_RESET_RETRIES) && \
            ( Status == (uint32_t)SDMMC003_BAD_RESPONSE));
/* <<<DD_SDMMC_nonAPI_14_4>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8007274:	68fb      	ldr	r3, [r7, #12]
 8007276:	2b00      	cmp	r3, #0
 8007278:	d163      	bne.n	8007342 <SDMMC003_lInitializeCard+0x12a>
    {
      break;
    }/* End of "if(Status != DAVEApp_SUCCESS )" */
    /* Query & Set voltage window  */

    Status = SDMMC003_lQueryVoltage(SDMMC003_CardInfo.Rca);
 800727a:	f246 4334 	movw	r3, #25652	; 0x6434
 800727e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007282:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8007284:	4618      	mov	r0, r3
 8007286:	f7ff ff27 	bl	80070d8 <SDMMC003_lQueryVoltage>
 800728a:	60f8      	str	r0, [r7, #12]
/* <<<DD_SDMMC_nonAPI_14_5>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 800728c:	68fb      	ldr	r3, [r7, #12]
 800728e:	2b00      	cmp	r3, #0
 8007290:	d159      	bne.n	8007346 <SDMMC003_lInitializeCard+0x12e>
    {
      break;
    }
    /* Read CID */
    Status = SDMMC003_lSendCommand(&(SDMMC003_COMMON_COMMAND(2)), \
 8007292:	f246 6304 	movw	r3, #26116	; 0x6604
 8007296:	f6c0 0302 	movt	r3, #2050	; 0x802
 800729a:	789b      	ldrb	r3, [r3, #2]
 800729c:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80072a0:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80072a4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80072a8:	18d3      	adds	r3, r2, r3
 80072aa:	4618      	mov	r0, r3
 80072ac:	f04f 0100 	mov.w	r1, #0
 80072b0:	f04f 0203 	mov.w	r2, #3
 80072b4:	4b2a      	ldr	r3, [pc, #168]	; (8007360 <SDMMC003_lInitializeCard+0x148>)
 80072b6:	f7ff fd97 	bl	8006de8 <SDMMC003_lSendCommand>
 80072ba:	60f8      	str	r0, [r7, #12]
                                     SDMMC003_ARGUMENT0,SDMMC003_RESPONSE_R2, \
                                     (void *)SDMMC003_CardInfo.CidArray);
/* <<<DD_SDMMC_nonAPI_14_6>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 80072bc:	68fb      	ldr	r3, [r7, #12]
 80072be:	2b00      	cmp	r3, #0
 80072c0:	d143      	bne.n	800734a <SDMMC003_lInitializeCard+0x132>
    {
      break;
    }
    /* Read RCA */
    Status = SDMMC003_lReadRca();
 80072c2:	f000 f8d1 	bl	8007468 <SDMMC003_lReadRca>
 80072c6:	60f8      	str	r0, [r7, #12]
/* <<<DD_SDMMC_nonAPI_14_7>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 80072c8:	68fb      	ldr	r3, [r7, #12]
 80072ca:	2b00      	cmp	r3, #0
 80072cc:	d13f      	bne.n	800734e <SDMMC003_lInitializeCard+0x136>
    {
      break;
    } 
    /* Check the card Lock/ Unlock Status */
    Status = SDMMC003_GetLockStatus(&LockStatus);
 80072ce:	f107 0304 	add.w	r3, r7, #4
 80072d2:	4618      	mov	r0, r3
 80072d4:	f7fe fed8 	bl	8006088 <SDMMC003_GetLockStatus>
 80072d8:	60f8      	str	r0, [r7, #12]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 80072da:	68fb      	ldr	r3, [r7, #12]
 80072dc:	2b00      	cmp	r3, #0
 80072de:	d138      	bne.n	8007352 <SDMMC003_lInitializeCard+0x13a>
    {
      break;
    }
/* <<<DD_SDMMC_nonAPI_14_8>> */
    if (LockStatus == (uint32_t)SDMMC003_CARD_IS_LOCKED)
 80072e0:	687b      	ldr	r3, [r7, #4]
 80072e2:	2b20      	cmp	r3, #32
 80072e4:	d110      	bne.n	8007308 <SDMMC003_lInitializeCard+0xf0>
    {
      SDMMC003_Handle.State |= SDMMC003_STATE_CARD_LOCKED ;
 80072e6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80072ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80072ee:	881b      	ldrh	r3, [r3, #0]
 80072f0:	b29b      	uxth	r3, r3
 80072f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80072f6:	b29a      	uxth	r2, r3
 80072f8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80072fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007300:	801a      	strh	r2, [r3, #0]
      Status = (uint32_t)SDMMC003_INITIALIZED_BUT_LOCKED;     
 8007302:	f04f 032b 	mov.w	r3, #43	; 0x2b
 8007306:	60fb      	str	r3, [r7, #12]
    }
    /* Update card initialization Status */
    SDMMC003_Handle.State |= SDMMC003_STATE_CARD_INITIALIZED;
 8007308:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800730c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007310:	881b      	ldrh	r3, [r3, #0]
 8007312:	b29b      	uxth	r3, r3
 8007314:	f043 0301 	orr.w	r3, r3, #1
 8007318:	b29a      	uxth	r2, r3
 800731a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800731e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007322:	801a      	strh	r2, [r3, #0]
    SDMMC003_Handle.State &=  ~(SDMMC003_STATE_NO_CARD);
 8007324:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007328:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800732c:	881b      	ldrh	r3, [r3, #0]
 800732e:	b29b      	uxth	r3, r3
 8007330:	f023 0302 	bic.w	r3, r3, #2
 8007334:	b29a      	uxth	r2, r3
 8007336:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800733a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800733e:	801a      	strh	r2, [r3, #0]
 8007340:	e008      	b.n	8007354 <SDMMC003_lInitializeCard+0x13c>
    } while(( Count < SDMMC003_NUM_CARD_RESET_RETRIES) && \
            ( Status == (uint32_t)SDMMC003_BAD_RESPONSE));
/* <<<DD_SDMMC_nonAPI_14_4>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8007342:	bf00      	nop
 8007344:	e006      	b.n	8007354 <SDMMC003_lInitializeCard+0x13c>

    Status = SDMMC003_lQueryVoltage(SDMMC003_CardInfo.Rca);
/* <<<DD_SDMMC_nonAPI_14_5>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8007346:	bf00      	nop
 8007348:	e004      	b.n	8007354 <SDMMC003_lInitializeCard+0x13c>
                                     SDMMC003_ARGUMENT0,SDMMC003_RESPONSE_R2, \
                                     (void *)SDMMC003_CardInfo.CidArray);
/* <<<DD_SDMMC_nonAPI_14_6>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 800734a:	bf00      	nop
 800734c:	e002      	b.n	8007354 <SDMMC003_lInitializeCard+0x13c>
    /* Read RCA */
    Status = SDMMC003_lReadRca();
/* <<<DD_SDMMC_nonAPI_14_7>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 800734e:	bf00      	nop
 8007350:	e000      	b.n	8007354 <SDMMC003_lInitializeCard+0x13c>
    } 
    /* Check the card Lock/ Unlock Status */
    Status = SDMMC003_GetLockStatus(&LockStatus);
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8007352:	bf00      	nop
    /* Update card initialization Status */
    SDMMC003_Handle.State |= SDMMC003_STATE_CARD_INITIALIZED;
    SDMMC003_Handle.State &=  ~(SDMMC003_STATE_NO_CARD);
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8007354:	68fb      	ldr	r3, [r7, #12]
}
 8007356:	4618      	mov	r0, r3
 8007358:	f107 0710 	add.w	r7, r7, #16
 800735c:	46bd      	mov	sp, r7
 800735e:	bd80      	pop	{r7, pc}
 8007360:	20006438 	.word	0x20006438

08007364 <SDMMC003_lWriteCardType>:
/* <<<DD_SDMMC_nonAPI_15>>> */
/*
 * This function finds out the card Type information.
 */
void SDMMC003_lWriteCardType()
{
 8007364:	b480      	push	{r7}
 8007366:	af00      	add	r7, sp, #0
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /* If F8 =0 , Standard Capacity V1 Card */
/* <<<DD_SDMMC_nonAPI_15_1>>> */
  if ( SDMMC003_Handle.f8 == 0)
 8007368:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800736c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007370:	7a5b      	ldrb	r3, [r3, #9]
 8007372:	b2db      	uxtb	r3, r3
 8007374:	2b00      	cmp	r3, #0
 8007376:	d10e      	bne.n	8007396 <SDMMC003_lWriteCardType+0x32>
  {
    SDMMC003_Handle.CardType |= SDMMC003_SD_STANDARD_CAPACITY_V1x;
 8007378:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800737c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007380:	789b      	ldrb	r3, [r3, #2]
 8007382:	b2db      	uxtb	r3, r3
 8007384:	f043 0302 	orr.w	r3, r3, #2
 8007388:	b2da      	uxtb	r2, r3
 800738a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800738e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007392:	709a      	strb	r2, [r3, #2]
 8007394:	e025      	b.n	80073e2 <SDMMC003_lWriteCardType+0x7e>
/* <<<DD_SDMMC_nonAPI_15_2>>> */
  else
  {
    /* Check CCS bit in the OCR register, CCS=1 means High Capacity  card*/
/* <<<DD_SDMMC_nonAPI_15_3>>> */
    if ((SDMMC003_CardInfo.Ocr & SDMMC003_OCR_CCS_BITMASK ) != 0)
 8007396:	f246 4334 	movw	r3, #25652	; 0x6434
 800739a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800739e:	681b      	ldr	r3, [r3, #0]
 80073a0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80073a4:	2b00      	cmp	r3, #0
 80073a6:	d00e      	beq.n	80073c6 <SDMMC003_lWriteCardType+0x62>
    {
      SDMMC003_Handle.CardType |= SDMMC003_SD_HIGH_CAPACITY | \
 80073a8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80073ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80073b0:	789b      	ldrb	r3, [r3, #2]
 80073b2:	b2db      	uxtb	r3, r3
 80073b4:	f043 030c 	orr.w	r3, r3, #12
 80073b8:	b2da      	uxtb	r2, r3
 80073ba:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80073be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80073c2:	709a      	strb	r2, [r3, #2]
 80073c4:	e00d      	b.n	80073e2 <SDMMC003_lWriteCardType+0x7e>
    }
/* <<<DD_SDMMC_nonAPI_15_4>>> */
    /* CCS=0 means Standard Capacity Version2*/
    else
    {
      SDMMC003_Handle.CardType |= SDMMC003_SD_STANDARD_CAPACITY_V2;
 80073c6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80073ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80073ce:	789b      	ldrb	r3, [r3, #2]
 80073d0:	b2db      	uxtb	r3, r3
 80073d2:	f043 0301 	orr.w	r3, r3, #1
 80073d6:	b2da      	uxtb	r2, r3
 80073d8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80073dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80073e0:	709a      	strb	r2, [r3, #2]
    }
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
}
 80073e2:	46bd      	mov	sp, r7
 80073e4:	bc80      	pop	{r7}
 80073e6:	4770      	bx	lr

080073e8 <SDMMC003_lSetWriteProtect>:
/* <<<DD_SDMMC_nonAPI_16>>> */
/*
 * This function finds out the Write protection status of the card.
 */
status_t SDMMC003_lSetWriteProtect (void)
{
 80073e8:	b580      	push	{r7, lr}
 80073ea:	b092      	sub	sp, #72	; 0x48
 80073ec:	af00      	add	r7, sp, #0
  uint32_t SdStatus[16] = {0};
 80073ee:	463a      	mov	r2, r7
 80073f0:	f04f 0340 	mov.w	r3, #64	; 0x40
 80073f4:	4610      	mov	r0, r2
 80073f6:	f04f 0100 	mov.w	r1, #0
 80073fa:	461a      	mov	r2, r3
 80073fc:	f01c fa78 	bl	80238f0 <memset>
  uint32_t WriteProtect;
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8007400:	f04f 0301 	mov.w	r3, #1
 8007404:	647b      	str	r3, [r7, #68]	; 0x44
    }
    else
#endif
    {
      /* SD Card Write Protection.  */
      Status  = SDMMC003_GetSdStatus((void*)&(SdStatus[0]));
 8007406:	463b      	mov	r3, r7
 8007408:	4618      	mov	r0, r3
 800740a:	f7ff f8fd 	bl	8006608 <SDMMC003_GetSdStatus>
 800740e:	6478      	str	r0, [r7, #68]	; 0x44
/* <<<DD_SDMMC_nonAPI_16_3>>> */
      if (Status != DAVEApp_SUCCESS)
 8007410:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007412:	2b00      	cmp	r3, #0
 8007414:	d121      	bne.n	800745a <SDMMC003_lSetWriteProtect+0x72>
      {
        break;
      }
/* <<<DD_SDMMC_nonAPI_16_4>>> */
      /* Bits 480:495 in the SD status gives the Write Protection Information */
      WriteProtect = ((SdStatus[0] & 0xFF000000) >> 24 ) | 
 8007416:	683b      	ldr	r3, [r7, #0]
 8007418:	ea4f 6213 	mov.w	r2, r3, lsr #24
                     (((SdStatus[0] & 0x00FF0000) >> 16 ) << 8) ;
 800741c:	683b      	ldr	r3, [r7, #0]
 800741e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8007422:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8007426:	ea4f 2303 	mov.w	r3, r3, lsl #8
      {
        break;
      }
/* <<<DD_SDMMC_nonAPI_16_4>>> */
      /* Bits 480:495 in the SD status gives the Write Protection Information */
      WriteProtect = ((SdStatus[0] & 0xFF000000) >> 24 ) | 
 800742a:	4313      	orrs	r3, r2
 800742c:	643b      	str	r3, [r7, #64]	; 0x40
                     (((SdStatus[0] & 0x00FF0000) >> 16 ) << 8) ;
      if ( (WriteProtect & SDMMC003_SD_CARD_TYPE_BITMASK) != 0 )
 800742e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8007430:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8007434:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8007438:	2b00      	cmp	r3, #0
 800743a:	d00f      	beq.n	800745c <SDMMC003_lSetWriteProtect+0x74>
      {
        SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_CARD_WRITE_PROTECT;
 800743c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007440:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007444:	881b      	ldrh	r3, [r3, #0]
 8007446:	b29b      	uxth	r3, r3
 8007448:	f043 0310 	orr.w	r3, r3, #16
 800744c:	b29a      	uxth	r2, r3
 800744e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007452:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007456:	801a      	strh	r2, [r3, #0]
 8007458:	e000      	b.n	800745c <SDMMC003_lSetWriteProtect+0x74>
      /* SD Card Write Protection.  */
      Status  = SDMMC003_GetSdStatus((void*)&(SdStatus[0]));
/* <<<DD_SDMMC_nonAPI_16_3>>> */
      if (Status != DAVEApp_SUCCESS)
      {
        break;
 800745a:	bf00      	nop
        SDMMC003_Handle.State |=(uint32_t)SDMMC003_STATE_CARD_WRITE_PROTECT;
      }
    }
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 800745c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800745e:	4618      	mov	r0, r3
 8007460:	f107 0748 	add.w	r7, r7, #72	; 0x48
 8007464:	46bd      	mov	sp, r7
 8007466:	bd80      	pop	{r7, pc}

08007468 <SDMMC003_lReadRca>:
/* <<<DD_SDMMC_nonAPI_17>>> */
/*
 * This function reads the  Relative card address of the card.
 */
status_t SDMMC003_lReadRca()
{
 8007468:	b580      	push	{r7, lr}
 800746a:	b082      	sub	sp, #8
 800746c:	af00      	add	r7, sp, #0
  /*  Read RCA for SD  */
  else
#endif
  {
/* <<<DD_SDMMC_nonAPI_17_2>>> */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(3)), \
 800746e:	f246 6304 	movw	r3, #26116	; 0x6604
 8007472:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007476:	78db      	ldrb	r3, [r3, #3]
 8007478:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800747c:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8007480:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007484:	18d3      	adds	r3, r2, r3
 8007486:	4618      	mov	r0, r3
 8007488:	f04f 0100 	mov.w	r1, #0
 800748c:	f04f 0205 	mov.w	r2, #5
 8007490:	4b04      	ldr	r3, [pc, #16]	; (80074a4 <SDMMC003_lReadRca+0x3c>)
 8007492:	f7ff fca9 	bl	8006de8 <SDMMC003_lSendCommand>
 8007496:	6078      	str	r0, [r7, #4]
                                    SDMMC003_ARGUMENT0, \
                                    SDMMC003_RESPONSE_R6, \
                                    &(SDMMC003_CardInfo.Rca));
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8007498:	687b      	ldr	r3, [r7, #4]
}
 800749a:	4618      	mov	r0, r3
 800749c:	f107 0708 	add.w	r7, r7, #8
 80074a0:	46bd      	mov	sp, r7
 80074a2:	bd80      	pop	{r7, pc}
 80074a4:	20006460 	.word	0x20006460

080074a8 <SDMMC003_lReadCardRegisters>:
/* <<<DD_SDMMC_nonAPI_19>>> */
/*
 * This function reads the CSD, SCR and Write protection status of the card.
 */
status_t SDMMC003_lReadCardRegisters (void)
{
 80074a8:	b580      	push	{r7, lr}
 80074aa:	b088      	sub	sp, #32
 80074ac:	af02      	add	r7, sp, #8
  uint32_t Argument = 0;
 80074ae:	f04f 0300 	mov.w	r3, #0
 80074b2:	613b      	str	r3, [r7, #16]
  uint32_t CardStatus = 0;
 80074b4:	f04f 0300 	mov.w	r3, #0
 80074b8:	60fb      	str	r3, [r7, #12]
  status_t Status;
  SDMMC003_SCRType ScrContent = {0};
 80074ba:	f04f 0300 	mov.w	r3, #0
 80074be:	607b      	str	r3, [r7, #4]
 80074c0:	f04f 0300 	mov.w	r3, #0
 80074c4:	60bb      	str	r3, [r7, #8]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /* Read CSD Register  */
    Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
 80074c6:	f246 4334 	movw	r3, #25652	; 0x6434
 80074ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80074ce:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 80074d0:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80074d4:	693a      	ldr	r2, [r7, #16]
 80074d6:	4313      	orrs	r3, r2
 80074d8:	613b      	str	r3, [r7, #16]
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(9)),Argument, \
 80074da:	f246 6304 	movw	r3, #26116	; 0x6604
 80074de:	f6c0 0302 	movt	r3, #2050	; 0x802
 80074e2:	7a5b      	ldrb	r3, [r3, #9]
 80074e4:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80074e8:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80074ec:	f6c0 0302 	movt	r3, #2050	; 0x802
 80074f0:	18d3      	adds	r3, r2, r3
 80074f2:	4618      	mov	r0, r3
 80074f4:	6939      	ldr	r1, [r7, #16]
 80074f6:	f04f 0203 	mov.w	r2, #3
 80074fa:	4b42      	ldr	r3, [pc, #264]	; (8007604 <SDMMC003_lReadCardRegisters+0x15c>)
 80074fc:	f7ff fc74 	bl	8006de8 <SDMMC003_lSendCommand>
 8007500:	6178      	str	r0, [r7, #20]
                                     SDMMC003_RESPONSE_R2, \
                                     (void *)SDMMC003_CardInfo.CsdArray);
/* <<<DD_SDMMC_nonAPI_19_1>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS )
 8007502:	697b      	ldr	r3, [r7, #20]
 8007504:	2b00      	cmp	r3, #0
 8007506:	d16f      	bne.n	80075e8 <SDMMC003_lReadCardRegisters+0x140>
    {
      break;
    }
    /* Set Write protection flags */
    Status = SDMMC003_lSetWriteProtect();
 8007508:	f7ff ff6e 	bl	80073e8 <SDMMC003_lSetWriteProtect>
 800750c:	6178      	str	r0, [r7, #20]
/* <<<DD_SDMMC_nonAPI_19_2>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 800750e:	697b      	ldr	r3, [r7, #20]
 8007510:	2b00      	cmp	r3, #0
 8007512:	d16b      	bne.n	80075ec <SDMMC003_lReadCardRegisters+0x144>
    {
      break;
    }
/* <<<DD_SDMMC_nonAPI_19_3>>> */
    /* Read SCR register for SD card */
    if ((SDMMC003_Handle.CardType & SDMMC003_MMC) == 0)
 8007514:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007518:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800751c:	789b      	ldrb	r3, [r3, #2]
 800751e:	b2db      	uxtb	r3, r3
 8007520:	f003 0310 	and.w	r3, r3, #16
 8007524:	2b00      	cmp	r3, #0
 8007526:	d166      	bne.n	80075f6 <SDMMC003_lReadCardRegisters+0x14e>
    {
      /* Switch to Transferring State. */
      Status = SDMMC003_lSwitchToTransferState();
 8007528:	f000 fe4a 	bl	80081c0 <SDMMC003_lSwitchToTransferState>
 800752c:	6178      	str	r0, [r7, #20]
/* <<<DD_SDMMC_nonAPI_19_4>>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS)
 800752e:	697b      	ldr	r3, [r7, #20]
 8007530:	2b00      	cmp	r3, #0
 8007532:	d15d      	bne.n	80075f0 <SDMMC003_lReadCardRegisters+0x148>
      {
        break;
      }   
      /*Send the Application Specific Command i.e. Command 55.*/
      Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
 8007534:	f246 4334 	movw	r3, #25652	; 0x6434
 8007538:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800753c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800753e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8007542:	693a      	ldr	r2, [r7, #16]
 8007544:	4313      	orrs	r3, r2
 8007546:	613b      	str	r3, [r7, #16]
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)),Argument, \
 8007548:	f246 6304 	movw	r3, #26116	; 0x6604
 800754c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007550:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 8007554:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8007558:	f246 53b4 	movw	r3, #26036	; 0x65b4
 800755c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007560:	18d2      	adds	r2, r2, r3
                                      SDMMC003_RESPONSE_R1, &CardStatus );
 8007562:	f107 030c 	add.w	r3, r7, #12
      {
        break;
      }   
      /*Send the Application Specific Command i.e. Command 55.*/
      Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)),Argument, \
 8007566:	4610      	mov	r0, r2
 8007568:	6939      	ldr	r1, [r7, #16]
 800756a:	f04f 0201 	mov.w	r2, #1
 800756e:	f7ff fc3b 	bl	8006de8 <SDMMC003_lSendCommand>
 8007572:	6178      	str	r0, [r7, #20]
                                      SDMMC003_RESPONSE_R1, &CardStatus );
/* <<<DD_SDMMC_nonAPI_19_5>>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS)
 8007574:	697b      	ldr	r3, [r7, #20]
 8007576:	2b00      	cmp	r3, #0
 8007578:	d13c      	bne.n	80075f4 <SDMMC003_lReadCardRegisters+0x14c>
      {
        break;
      }
      /* Set Direction Select bit in the Transfer Mode register */
      SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
 800757a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800757e:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007582:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007586:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800758a:	8992      	ldrh	r2, [r2, #12]
 800758c:	b292      	uxth	r2, r2
 800758e:	f042 0210 	orr.w	r2, r2, #16
 8007592:	b292      	uxth	r2, r2
 8007594:	819a      	strh	r2, [r3, #12]
      /* Read the transferred SCR data*/
      Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(64)), \
 8007596:	f246 6304 	movw	r3, #26116	; 0x6604
 800759a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800759e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80075a2:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80075a6:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80075aa:	f6c0 0302 	movt	r3, #2050	; 0x802
 80075ae:	18d2      	adds	r2, r2, r3
                                              SDMMC003_ARGUMENT0,8, \
                                              (uint32_t *)&ScrContent, \
 80075b0:	f107 0304 	add.w	r3, r7, #4
        break;
      }
      /* Set Direction Select bit in the Transfer Mode register */
      SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_TX_DIR_SELECT_Pos);
      /* Read the transferred SCR data*/
      Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(64)), \
 80075b4:	f04f 0101 	mov.w	r1, #1
 80075b8:	9100      	str	r1, [sp, #0]
 80075ba:	4610      	mov	r0, r2
 80075bc:	f04f 0100 	mov.w	r1, #0
 80075c0:	f04f 0208 	mov.w	r2, #8
 80075c4:	f000 f960 	bl	8007888 <SDMMC003_lSingleBlockTransfer>
 80075c8:	6178      	str	r0, [r7, #20]
                                              SDMMC003_ARGUMENT0,8, \
                                              (uint32_t *)&ScrContent, \
                                              SDMMC003_READ_FROM_BUFF);
      SDMMC003_CardInfo.Scr  =   ScrContent;
 80075ca:	f246 4334 	movw	r3, #25652	; 0x6434
 80075ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80075d2:	f103 0324 	add.w	r3, r3, #36	; 0x24
 80075d6:	f107 0204 	add.w	r2, r7, #4
 80075da:	e892 0003 	ldmia.w	r2, {r0, r1}
 80075de:	e883 0003 	stmia.w	r3, {r0, r1}
/* <<<DD_SDMMC_nonAPI_19_6>>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS)
 80075e2:	697b      	ldr	r3, [r7, #20]
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	e006      	b.n	80075f6 <SDMMC003_lReadCardRegisters+0x14e>
                                     SDMMC003_RESPONSE_R2, \
                                     (void *)SDMMC003_CardInfo.CsdArray);
/* <<<DD_SDMMC_nonAPI_19_1>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS )
    {
      break;
 80075e8:	bf00      	nop
 80075ea:	e004      	b.n	80075f6 <SDMMC003_lReadCardRegisters+0x14e>
    /* Set Write protection flags */
    Status = SDMMC003_lSetWriteProtect();
/* <<<DD_SDMMC_nonAPI_19_2>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 80075ec:	bf00      	nop
 80075ee:	e002      	b.n	80075f6 <SDMMC003_lReadCardRegisters+0x14e>
      /* Switch to Transferring State. */
      Status = SDMMC003_lSwitchToTransferState();
/* <<<DD_SDMMC_nonAPI_19_4>>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 80075f0:	bf00      	nop
 80075f2:	e000      	b.n	80075f6 <SDMMC003_lReadCardRegisters+0x14e>
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)),Argument, \
                                      SDMMC003_RESPONSE_R1, &CardStatus );
/* <<<DD_SDMMC_nonAPI_19_5>>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 80075f4:	bf00      	nop
        break;
      } 
    } /* End of " if ((SDMMC003_Handle.CardType & SDMMC003_MMC) == 0)"*/
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80075f6:	697b      	ldr	r3, [r7, #20]
}
 80075f8:	4618      	mov	r0, r3
 80075fa:	f107 0718 	add.w	r7, r7, #24
 80075fe:	46bd      	mov	sp, r7
 8007600:	bd80      	pop	{r7, pc}
 8007602:	bf00      	nop
 8007604:	20006448 	.word	0x20006448

08007608 <SDMMC003_lConfigureForSingleTransfer>:
(
  const SDMMC003_CommandType *CommandPtr,
  uint32_t Argument,
  uint16_t BlockSize
)
{
 8007608:	b580      	push	{r7, lr}
 800760a:	b086      	sub	sp, #24
 800760c:	af00      	add	r7, sp, #0
 800760e:	60f8      	str	r0, [r7, #12]
 8007610:	60b9      	str	r1, [r7, #8]
 8007612:	4613      	mov	r3, r2
 8007614:	80fb      	strh	r3, [r7, #6]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8007616:	f04f 0301 	mov.w	r3, #1
 800761a:	617b      	str	r3, [r7, #20]
  uint32_t CardStatus = 0;
 800761c:	f04f 0300 	mov.w	r3, #0
 8007620:	613b      	str	r3, [r7, #16]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /* Set Block Size Register */
    WR_REG( SDMMC->BLOCK_SIZE,SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Msk , \
 8007622:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007626:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800762a:	88fa      	ldrh	r2, [r7, #6]
 800762c:	ea4f 5202 	mov.w	r2, r2, lsl #20
 8007630:	ea4f 5212 	mov.w	r2, r2, lsr #20
 8007634:	b291      	uxth	r1, r2
 8007636:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800763a:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800763e:	8892      	ldrh	r2, [r2, #4]
 8007640:	b292      	uxth	r2, r2
 8007642:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 8007646:	f022 020f 	bic.w	r2, r2, #15
 800764a:	b292      	uxth	r2, r2
 800764c:	430a      	orrs	r2, r1
 800764e:	b292      	uxth	r2, r2
 8007650:	809a      	strh	r2, [r3, #4]
            SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Pos,BlockSize );
    /* Clear the Multi Block Select bit */
    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_MULTI_BLOCK_SELECT_Pos);
 8007652:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007656:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800765a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800765e:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8007662:	8992      	ldrh	r2, [r2, #12]
 8007664:	b292      	uxth	r2, r2
 8007666:	f022 0220 	bic.w	r2, r2, #32
 800766a:	b292      	uxth	r2, r2
 800766c:	819a      	strh	r2, [r3, #12]
    /* Clear the ACMD Enable bit*/
    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_ACMD_EN_Pos);
 800766e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007672:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007676:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800767a:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800767e:	8992      	ldrh	r2, [r2, #12]
 8007680:	b292      	uxth	r2, r2
 8007682:	f022 0204 	bic.w	r2, r2, #4
 8007686:	b292      	uxth	r2, r2
 8007688:	819a      	strh	r2, [r3, #12]
    /* Clear the Block Count Enable bit*/
    CLR_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_BLOCK_COUNT_EN_Pos);
 800768a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800768e:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007692:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007696:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800769a:	8992      	ldrh	r2, [r2, #12]
 800769c:	b292      	uxth	r2, r2
 800769e:	f022 0202 	bic.w	r2, r2, #2
 80076a2:	b292      	uxth	r2, r2
 80076a4:	819a      	strh	r2, [r3, #12]
      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);
    }
#endif
    /* Send Single Block Transfer Command */
    Status = (uint32_t)SDMMC003_lSendCommand( CommandPtr, Argument, \
                                              SDMMC003_RESPONSE_R1, &CardStatus);
 80076a6:	f107 0310 	add.w	r3, r7, #16
      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);
      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);
    }
#endif
    /* Send Single Block Transfer Command */
    Status = (uint32_t)SDMMC003_lSendCommand( CommandPtr, Argument, \
 80076aa:	68f8      	ldr	r0, [r7, #12]
 80076ac:	68b9      	ldr	r1, [r7, #8]
 80076ae:	f04f 0201 	mov.w	r2, #1
 80076b2:	f7ff fb99 	bl	8006de8 <SDMMC003_lSendCommand>
 80076b6:	6178      	str	r0, [r7, #20]
                                              SDMMC003_RESPONSE_R1, &CardStatus);
/* <<<DD_SDMMC_nonAPI_20_1>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 80076b8:	697b      	ldr	r3, [r7, #20]
 80076ba:	2b00      	cmp	r3, #0
    {
      break;
    }
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80076bc:	697b      	ldr	r3, [r7, #20]
}
 80076be:	4618      	mov	r0, r3
 80076c0:	f107 0718 	add.w	r7, r7, #24
 80076c4:	46bd      	mov	sp, r7
 80076c6:	bd80      	pop	{r7, pc}

080076c8 <SDMMC003_lConfigureRegForMultiTransfer>:
(
  uint32_t *TmpAddrPtr,
  uint32_t NumberOfBlocks,
  const SDMMC003_CommandType *CommandPtr
)
{
 80076c8:	b580      	push	{r7, lr}
 80076ca:	b086      	sub	sp, #24
 80076cc:	af00      	add	r7, sp, #0
 80076ce:	60f8      	str	r0, [r7, #12]
 80076d0:	60b9      	str	r1, [r7, #8]
 80076d2:	607a      	str	r2, [r7, #4]
  status_t Status;
  uint32_t CardStatus = 0;
 80076d4:	f04f 0300 	mov.w	r3, #0
 80076d8:	613b      	str	r3, [r7, #16]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /* Block Addressing */
    /* <<<DD_SDMMC_nonAPI_21_1>>> */
    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)
 80076da:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80076de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80076e2:	789b      	ldrb	r3, [r3, #2]
 80076e4:	b2db      	uxtb	r3, r3
 80076e6:	f003 0308 	and.w	r3, r3, #8
 80076ea:	2b00      	cmp	r3, #0
 80076ec:	d105      	bne.n	80076fa <SDMMC003_lConfigureRegForMultiTransfer+0x32>
    {
      *TmpAddrPtr *= 512UL;
 80076ee:	68fb      	ldr	r3, [r7, #12]
 80076f0:	681b      	ldr	r3, [r3, #0]
 80076f2:	ea4f 2243 	mov.w	r2, r3, lsl #9
 80076f6:	68fb      	ldr	r3, [r7, #12]
 80076f8:	601a      	str	r2, [r3, #0]
    }
    /* Set Block Size Register */
    WR_REG( SDMMC->BLOCK_SIZE,SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Msk , \
 80076fa:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80076fe:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007702:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007706:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800770a:	8892      	ldrh	r2, [r2, #4]
 800770c:	b292      	uxth	r2, r2
 800770e:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 8007712:	f022 020f 	bic.w	r2, r2, #15
 8007716:	b292      	uxth	r2, r2
 8007718:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800771c:	b292      	uxth	r2, r2
 800771e:	809a      	strh	r2, [r3, #4]
            SDMMC_BLOCK_SIZE_TX_BLOCK_SIZE_Pos,SDMMC003_TX_BLOCK_SIZE_VALUE);
    /* Set Transfer Mode Register */
    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_MULTI_BLOCK_SELECT_Pos);
 8007720:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007724:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007728:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800772c:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8007730:	8992      	ldrh	r2, [r2, #12]
 8007732:	b292      	uxth	r2, r2
 8007734:	f042 0220 	orr.w	r2, r2, #32
 8007738:	b292      	uxth	r2, r2
 800773a:	819a      	strh	r2, [r3, #12]
    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_ACMD_EN_Pos);
 800773c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007740:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007744:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007748:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800774c:	8992      	ldrh	r2, [r2, #12]
 800774e:	b292      	uxth	r2, r2
 8007750:	f042 0204 	orr.w	r2, r2, #4
 8007754:	b292      	uxth	r2, r2
 8007756:	819a      	strh	r2, [r3, #12]
    SET_BIT( SDMMC->TRANSFER_MODE,SDMMC_TRANSFER_MODE_BLOCK_COUNT_EN_Pos);
 8007758:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800775c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007760:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007764:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8007768:	8992      	ldrh	r2, [r2, #12]
 800776a:	b292      	uxth	r2, r2
 800776c:	f042 0202 	orr.w	r2, r2, #2
 8007770:	b292      	uxth	r2, r2
 8007772:	819a      	strh	r2, [r3, #12]

    /* Set Block Count Register */
    WR_REG( SDMMC->BLOCK_COUNT, SDMMC_BLOCK_COUNT_BLOCK_COUNT_Msk ,   \
 8007774:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007778:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800777c:	88db      	ldrh	r3, [r3, #6]
 800777e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007782:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007786:	68ba      	ldr	r2, [r7, #8]
 8007788:	b292      	uxth	r2, r2
 800778a:	80da      	strh	r2, [r3, #6]
            SDMMC_BLOCK_COUNT_BLOCK_COUNT_Pos, NumberOfBlocks);

    /* Enable ACMD 12 Interrupt Signal  */
    SDMMC->EN_INT_SIGNAL_ERR &= ~SDMMC_EN_INT_SIGNAL_ERR_ACMD_ERR_EN_Msk;
 800778c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007790:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007794:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007798:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800779c:	8f52      	ldrh	r2, [r2, #58]	; 0x3a
 800779e:	b292      	uxth	r2, r2
 80077a0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80077a4:	b292      	uxth	r2, r2
 80077a6:	875a      	strh	r2, [r3, #58]	; 0x3a
    SDMMC->EN_INT_SIGNAL_ERR |= SDMMC_EN_INT_SIGNAL_ERR_ACMD_ERR_EN_Msk;
 80077a8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80077ac:	f6c4 0301 	movt	r3, #18433	; 0x4801
 80077b0:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 80077b4:	f6c4 0201 	movt	r2, #18433	; 0x4801
 80077b8:	8f52      	ldrh	r2, [r2, #58]	; 0x3a
 80077ba:	b292      	uxth	r2, r2
 80077bc:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80077c0:	b292      	uxth	r2, r2
 80077c2:	875a      	strh	r2, [r3, #58]	; 0x3a
      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);
      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);
    }
#endif
   /* Send Multiple Block  Transfer Command */
    Status = SDMMC003_lSendCommand( CommandPtr,  *TmpAddrPtr, \
 80077c4:	68fb      	ldr	r3, [r7, #12]
 80077c6:	681a      	ldr	r2, [r3, #0]
                                    SDMMC003_RESPONSE_R1, &CardStatus );
 80077c8:	f107 0310 	add.w	r3, r7, #16
      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);
      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk);
    }
#endif
   /* Send Multiple Block  Transfer Command */
    Status = SDMMC003_lSendCommand( CommandPtr,  *TmpAddrPtr, \
 80077cc:	6878      	ldr	r0, [r7, #4]
 80077ce:	4611      	mov	r1, r2
 80077d0:	f04f 0201 	mov.w	r2, #1
 80077d4:	f7ff fb08 	bl	8006de8 <SDMMC003_lSendCommand>
 80077d8:	6178      	str	r0, [r7, #20]
                                    SDMMC003_RESPONSE_R1, &CardStatus );
/* <<<DD_SDMMC_nonAPI_21_2>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 80077da:	697b      	ldr	r3, [r7, #20]
 80077dc:	2b00      	cmp	r3, #0
    {
      break;
    }
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80077de:	697b      	ldr	r3, [r7, #20]
}
 80077e0:	4618      	mov	r0, r3
 80077e2:	f107 0718 	add.w	r7, r7, #24
 80077e6:	46bd      	mov	sp, r7
 80077e8:	bd80      	pop	{r7, pc}
 80077ea:	bf00      	nop

080077ec <SDMMC003_lMultiBlockTransfer>:
status_t SDMMC003_lMultiBlockTransfer( uint32_t *AddrPtr,uint32_t NumberOfBlocks,\
                                       const SDMMC003_CommandType *CommandPtr, \
                                       uint32_t *BufferPtr, \
                                       SDMMC003_DataTrasferType TransferMode
                                     )
{
 80077ec:	b580      	push	{r7, lr}
 80077ee:	b086      	sub	sp, #24
 80077f0:	af00      	add	r7, sp, #0
 80077f2:	60f8      	str	r0, [r7, #12]
 80077f4:	60b9      	str	r1, [r7, #8]
 80077f6:	607a      	str	r2, [r7, #4]
 80077f8:	603b      	str	r3, [r7, #0]
  status_t Status ;
  SDMMC003_Handle.TransferInterruptError = SDMMC003_ERROR;
 80077fa:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80077fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007802:	f04f 0201 	mov.w	r2, #1
 8007806:	715a      	strb	r2, [r3, #5]
  do
  {
    /* Configure Registers for Multi block transfer*/
    Status = SDMMC003_lConfigureRegForMultiTransfer( AddrPtr, \
 8007808:	68f8      	ldr	r0, [r7, #12]
 800780a:	68b9      	ldr	r1, [r7, #8]
 800780c:	687a      	ldr	r2, [r7, #4]
 800780e:	f7ff ff5b 	bl	80076c8 <SDMMC003_lConfigureRegForMultiTransfer>
 8007812:	6178      	str	r0, [r7, #20]
                                                    NumberOfBlocks,CommandPtr );
/* <<<DD_SDMMC_nonAPI_22_1>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8007814:	697b      	ldr	r3, [r7, #20]
 8007816:	2b00      	cmp	r3, #0
 8007818:	d014      	beq.n	8007844 <SDMMC003_lMultiBlockTransfer+0x58>
    {
       break;
 800781a:	e02f      	b.n	800787c <SDMMC003_lMultiBlockTransfer+0x90>
 /* Read/Write  Block Data  */
/* <<<DD_SDMMC_nonAPI_22_2>>> */
    while( NumberOfBlocks > 0 )
    {
      /* Perform Transfer */
      Status = SDMMC003_lDataTransfer( BufferPtr, TransferMode,  \
 800781c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007820:	6838      	ldr	r0, [r7, #0]
 8007822:	4619      	mov	r1, r3
 8007824:	f04f 0280 	mov.w	r2, #128	; 0x80
 8007828:	f000 fd20 	bl	800826c <SDMMC003_lDataTransfer>
 800782c:	6178      	str	r0, [r7, #20]
                                       SDMMC003_NUM_QUADLETS_IN_BLOCK);
/* <<<DD_SDMMC_nonAPI_22_3>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 800782e:	697b      	ldr	r3, [r7, #20]
 8007830:	2b00      	cmp	r3, #0
 8007832:	d10b      	bne.n	800784c <SDMMC003_lMultiBlockTransfer+0x60>
      {
        break;
      }
      /* Decrement Number of blocks Variable */
      NumberOfBlocks--;
 8007834:	68bb      	ldr	r3, [r7, #8]
 8007836:	f103 33ff 	add.w	r3, r3, #4294967295
 800783a:	60bb      	str	r3, [r7, #8]
      /* Pointer pointing to the next Block Pointer*/
      BufferPtr += SDMMC003_NUM_QUADLETS_IN_BLOCK;
 800783c:	683b      	ldr	r3, [r7, #0]
 800783e:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8007842:	603b      	str	r3, [r7, #0]
      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0020 ;
    }
#endif
 /* Read/Write  Block Data  */
/* <<<DD_SDMMC_nonAPI_22_2>>> */
    while( NumberOfBlocks > 0 )
 8007844:	68bb      	ldr	r3, [r7, #8]
 8007846:	2b00      	cmp	r3, #0
 8007848:	d1e8      	bne.n	800781c <SDMMC003_lMultiBlockTransfer+0x30>
 800784a:	e000      	b.n	800784e <SDMMC003_lMultiBlockTransfer+0x62>
      Status = SDMMC003_lDataTransfer( BufferPtr, TransferMode,  \
                                       SDMMC003_NUM_QUADLETS_IN_BLOCK);
/* <<<DD_SDMMC_nonAPI_22_3>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 800784c:	bf00      	nop
      NumberOfBlocks--;
      /* Pointer pointing to the next Block Pointer*/
      BufferPtr += SDMMC003_NUM_QUADLETS_IN_BLOCK;
    }/* End of " while( NumberOfBlocks > 0 )"*/
/* <<<DD_SDMMC_nonAPI_22_4>>> */
    if ( Status == (uint32_t)DAVEApp_SUCCESS)
 800784e:	697b      	ldr	r3, [r7, #20]
 8007850:	2b00      	cmp	r3, #0
 8007852:	d107      	bne.n	8007864 <SDMMC003_lMultiBlockTransfer+0x78>
    {
     /* Block on Transfer Complete Interrupt */
/* <<<DD_SDMMC_nonAPI_22_5>>> */      
      /* Timeout of 5ms.*/
      Status = SDMMC003_lTransferDelay(SDMMC003_DELAY_IN_TRANSFER);
 8007854:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007858:	f7ff f9c6 	bl	8006be8 <SDMMC003_lTransferDelay>
 800785c:	6178      	str	r0, [r7, #20]
      if(Status != (uint32_t) DAVEApp_SUCCESS)
 800785e:	697b      	ldr	r3, [r7, #20]
 8007860:	2b00      	cmp	r3, #0
 8007862:	d10a      	bne.n	800787a <SDMMC003_lMultiBlockTransfer+0x8e>
/* <<<DD_SDMMC_nonAPI_22_6>>> */
    }/* End of " if ( Status == (uint32_t)DAVEApp_SUCCESS)"*/
    /* Check Transfer Completed Successfully */
/* Check ACMD status*/
/* <<<DD_SDMMC_nonAPI_22_7>>> */
    if(SDMMC003_Handle.AcmdInterruptError == SDMMC003_ACMD12_ERROR)
 8007864:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007868:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800786c:	799b      	ldrb	r3, [r3, #6]
 800786e:	b2db      	uxtb	r3, r3
 8007870:	2b09      	cmp	r3, #9
 8007872:	d103      	bne.n	800787c <SDMMC003_lMultiBlockTransfer+0x90>
    {
      /* Call ACMD12 Error Recovery */
      SDMMC003_lAcmdErrorRecovery();
 8007874:	f000 fd90 	bl	8008398 <SDMMC003_lAcmdErrorRecovery>
 8007878:	e000      	b.n	800787c <SDMMC003_lMultiBlockTransfer+0x90>
      /* Timeout of 5ms.*/
      Status = SDMMC003_lTransferDelay(SDMMC003_DELAY_IN_TRANSFER);
      if(Status != (uint32_t) DAVEApp_SUCCESS)
      {
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 800787a:	bf00      	nop
    {
      /* Call ACMD12 Error Recovery */
      SDMMC003_lAcmdErrorRecovery();
    }
  } while(0);
  return Status;
 800787c:	697b      	ldr	r3, [r7, #20]
}
 800787e:	4618      	mov	r0, r3
 8007880:	f107 0718 	add.w	r7, r7, #24
 8007884:	46bd      	mov	sp, r7
 8007886:	bd80      	pop	{r7, pc}

08007888 <SDMMC003_lSingleBlockTransfer>:
  uint32_t Argument,
  uint16_t BlockSize,
  uint32_t *BufferPtr,
  SDMMC003_DataTrasferType TransferMode
)
{
 8007888:	b580      	push	{r7, lr}
 800788a:	b086      	sub	sp, #24
 800788c:	af00      	add	r7, sp, #0
 800788e:	60f8      	str	r0, [r7, #12]
 8007890:	60b9      	str	r1, [r7, #8]
 8007892:	603b      	str	r3, [r7, #0]
 8007894:	4613      	mov	r3, r2
 8007896:	80fb      	strh	r3, [r7, #6]
  status_t Status;
  handle_t TimerId;
  do
  {
    /* Configure Register  for Single Block Transfer */
    Status = SDMMC003_lConfigureForSingleTransfer(CommandPtr,Argument,BlockSize);
 8007898:	88fb      	ldrh	r3, [r7, #6]
 800789a:	68f8      	ldr	r0, [r7, #12]
 800789c:	68b9      	ldr	r1, [r7, #8]
 800789e:	461a      	mov	r2, r3
 80078a0:	f7ff feb2 	bl	8007608 <SDMMC003_lConfigureForSingleTransfer>
 80078a4:	6178      	str	r0, [r7, #20]
/* <<<DD_SDMMC_nonAPI_23_1>>> */
    if ((uint32_t)DAVEApp_SUCCESS != Status)
 80078a6:	697b      	ldr	r3, [r7, #20]
 80078a8:	2b00      	cmp	r3, #0
 80078aa:	d15d      	bne.n	8007968 <SDMMC003_lSingleBlockTransfer+0xe0>
      /* Forcefully trigger the Data Crc Error Interrupt */
      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0020 ;
    }
#endif
    /* Perform Data Transfer */
    Status = SDMMC003_lDataTransfer(BufferPtr,TransferMode,(BlockSize/4));
 80078ac:	88fb      	ldrh	r3, [r7, #6]
 80078ae:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80078b2:	b29b      	uxth	r3, r3
 80078b4:	f897 2020 	ldrb.w	r2, [r7, #32]
 80078b8:	6838      	ldr	r0, [r7, #0]
 80078ba:	4611      	mov	r1, r2
 80078bc:	461a      	mov	r2, r3
 80078be:	f000 fcd5 	bl	800826c <SDMMC003_lDataTransfer>
 80078c2:	6178      	str	r0, [r7, #20]
/* <<<DD_SDMMC_nonAPI_23_2>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 80078c4:	697b      	ldr	r3, [r7, #20]
 80078c6:	2b00      	cmp	r3, #0
 80078c8:	d150      	bne.n	800796c <SDMMC003_lSingleBlockTransfer+0xe4>
    {
      break;
    }
/* Block on Transfer Complete Interrupt */
    /* Timeout of 5ms.*/
    TimerId = SDMMC003_lStartTimer (SDMMC003_DELAY_IN_TRANSFER);
 80078ca:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80078ce:	f000 fef1 	bl	80086b4 <SDMMC003_lStartTimer>
 80078d2:	6138      	str	r0, [r7, #16]
    if(0 == TimerId)
 80078d4:	693b      	ldr	r3, [r7, #16]
 80078d6:	2b00      	cmp	r3, #0
 80078d8:	d103      	bne.n	80078e2 <SDMMC003_lSingleBlockTransfer+0x5a>
    {
      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;
 80078da:	f04f 032f 	mov.w	r3, #47	; 0x2f
 80078de:	617b      	str	r3, [r7, #20]
      ERROR(GID_SDMMC00x, Status, 0, NULL);   
      break; 
 80078e0:	e045      	b.n	800796e <SDMMC003_lSingleBlockTransfer+0xe6>
    }
    do
    {
      if (SDMMC003_Handle.TimerExpire == 0)
 80078e2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80078e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80078ea:	7a9b      	ldrb	r3, [r3, #10]
 80078ec:	b2db      	uxtb	r3, r3
 80078ee:	2b00      	cmp	r3, #0
 80078f0:	d103      	bne.n	80078fa <SDMMC003_lSingleBlockTransfer+0x72>
      {
        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;
 80078f2:	f04f 032e 	mov.w	r3, #46	; 0x2e
 80078f6:	617b      	str	r3, [r7, #20]
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 80078f8:	e007      	b.n	800790a <SDMMC003_lSingleBlockTransfer+0x82>
      }
    } while (SDMMC003_ISRContext.TransferFlag == 0);
 80078fa:	f246 432c 	movw	r3, #25644	; 0x642c
 80078fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007902:	791b      	ldrb	r3, [r3, #4]
 8007904:	b2db      	uxtb	r3, r3
 8007906:	2b00      	cmp	r3, #0
 8007908:	d0eb      	beq.n	80078e2 <SDMMC003_lSingleBlockTransfer+0x5a>
    SDMMC003_lStopTimer(TimerId);
 800790a:	6938      	ldr	r0, [r7, #16]
 800790c:	f000 ff06 	bl	800871c <SDMMC003_lStopTimer>
    SDMMC003_ISRContext.TransferFlag = 0;
 8007910:	f246 432c 	movw	r3, #25644	; 0x642c
 8007914:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007918:	f04f 0200 	mov.w	r2, #0
 800791c:	711a      	strb	r2, [r3, #4]
    /* Check Transfer Complete Status */
/* <<<DD_SDMMC_nonAPI_23_4>>> */
    if (SDMMC003_Handle.TransferInterruptError == SDMMC003_TRANSFER_COMPLETE )
 800791e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007922:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007926:	795b      	ldrb	r3, [r3, #5]
 8007928:	b2db      	uxtb	r3, r3
 800792a:	2b1f      	cmp	r3, #31
 800792c:	d103      	bne.n	8007936 <SDMMC003_lSingleBlockTransfer+0xae>
    {
      Status = (uint32_t)DAVEApp_SUCCESS;
 800792e:	f04f 0300 	mov.w	r3, #0
 8007932:	617b      	str	r3, [r7, #20]
 8007934:	e01b      	b.n	800796e <SDMMC003_lSingleBlockTransfer+0xe6>
    }
/* <<<DD_SDMMC_nonAPI_23_5>>> */
    else
    {
      SDMMC003_Handle.IssueAbort = 1;
 8007936:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800793a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800793e:	f04f 0201 	mov.w	r2, #1
 8007942:	72da      	strb	r2, [r3, #11]
      Status = SDMMC003_lErrorInterruptRecovery(\
 8007944:	f246 432c 	movw	r3, #25644	; 0x642c
 8007948:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800794c:	881b      	ldrh	r3, [r3, #0]
 800794e:	b29a      	uxth	r2, r3
 8007950:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007954:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007958:	7adb      	ldrb	r3, [r3, #11]
 800795a:	b2db      	uxtb	r3, r3
 800795c:	4610      	mov	r0, r2
 800795e:	4619      	mov	r1, r3
 8007960:	f000 f980 	bl	8007c64 <SDMMC003_lErrorInterruptRecovery>
 8007964:	6178      	str	r0, [r7, #20]
                                    SDMMC003_ISRContext.InterruptStatusShadow, \
                                    SDMMC003_Handle.IssueAbort);
      break;
 8007966:	e002      	b.n	800796e <SDMMC003_lSingleBlockTransfer+0xe6>
    /* Configure Register  for Single Block Transfer */
    Status = SDMMC003_lConfigureForSingleTransfer(CommandPtr,Argument,BlockSize);
/* <<<DD_SDMMC_nonAPI_23_1>>> */
    if ((uint32_t)DAVEApp_SUCCESS != Status)
    {
      break;
 8007968:	bf00      	nop
 800796a:	e000      	b.n	800796e <SDMMC003_lSingleBlockTransfer+0xe6>
    /* Perform Data Transfer */
    Status = SDMMC003_lDataTransfer(BufferPtr,TransferMode,(BlockSize/4));
/* <<<DD_SDMMC_nonAPI_23_2>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 800796c:	bf00      	nop
                                    SDMMC003_ISRContext.InterruptStatusShadow, \
                                    SDMMC003_Handle.IssueAbort);
      break;
    }
  } while(0);
  return Status;
 800796e:	697b      	ldr	r3, [r7, #20]
}
 8007970:	4618      	mov	r0, r3
 8007972:	f107 0718 	add.w	r7, r7, #24
 8007976:	46bd      	mov	sp, r7
 8007978:	bd80      	pop	{r7, pc}
 800797a:	bf00      	nop

0800797c <SDMMC003_lCheckLockStatus>:
/* <<<DD_SDMMC_nonAPI_24>>> */
/*
 * This function checks the Lock Status .
 */
status_t SDMMC003_lCheckLockStatus( SDMMC003_CardLockMode OperationMode )
{
 800797c:	b580      	push	{r7, lr}
 800797e:	b084      	sub	sp, #16
 8007980:	af00      	add	r7, sp, #0
 8007982:	4603      	mov	r3, r0
 8007984:	71fb      	strb	r3, [r7, #7]
  status_t Status ;
  uint32_t LockStatus = 0;
 8007986:	f04f 0300 	mov.w	r3, #0
 800798a:	60bb      	str	r3, [r7, #8]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  Status =  SDMMC003_GetLockStatus(&LockStatus);
 800798c:	f107 0308 	add.w	r3, r7, #8
 8007990:	4618      	mov	r0, r3
 8007992:	f7fe fb79 	bl	8006088 <SDMMC003_GetLockStatus>
 8007996:	60f8      	str	r0, [r7, #12]
  /* For Lock, Card State must be locked */
/* <<<DD_SDMMC_nonAPI_24_1>>> */
  if (Status == (uint32_t)DAVEApp_SUCCESS)
 8007998:	68fb      	ldr	r3, [r7, #12]
 800799a:	2b00      	cmp	r3, #0
 800799c:	d116      	bne.n	80079cc <SDMMC003_lCheckLockStatus+0x50>
  {
    if ((LockStatus == (uint32_t)SDMMC003_CARD_IS_LOCKED) && \
 800799e:	68bb      	ldr	r3, [r7, #8]
 80079a0:	2b20      	cmp	r3, #32
 80079a2:	d106      	bne.n	80079b2 <SDMMC003_lCheckLockStatus+0x36>
 80079a4:	79fb      	ldrb	r3, [r7, #7]
 80079a6:	2b00      	cmp	r3, #0
 80079a8:	d103      	bne.n	80079b2 <SDMMC003_lCheckLockStatus+0x36>
                        (OperationMode == SDMMC003_LOCK) )
    {
      Status = (uint32_t)DAVEApp_SUCCESS;
 80079aa:	f04f 0300 	mov.w	r3, #0
 80079ae:	60fb      	str	r3, [r7, #12]
 80079b0:	e00c      	b.n	80079cc <SDMMC003_lCheckLockStatus+0x50>
    }
/* <<<DD_SDMMC_nonAPI_24_2>>> */
    /* For UnLock, Card State must be unlock */
    else if( (LockStatus == (uint32_t)SDMMC003_CARD_UNLOCKED) && \
 80079b2:	68bb      	ldr	r3, [r7, #8]
 80079b4:	2b21      	cmp	r3, #33	; 0x21
 80079b6:	d106      	bne.n	80079c6 <SDMMC003_lCheckLockStatus+0x4a>
 80079b8:	79fb      	ldrb	r3, [r7, #7]
 80079ba:	2b01      	cmp	r3, #1
 80079bc:	d103      	bne.n	80079c6 <SDMMC003_lCheckLockStatus+0x4a>
             (OperationMode == SDMMC003_UNLOCK) )
    {
      Status = (uint32_t)DAVEApp_SUCCESS;
 80079be:	f04f 0300 	mov.w	r3, #0
 80079c2:	60fb      	str	r3, [r7, #12]
 80079c4:	e002      	b.n	80079cc <SDMMC003_lCheckLockStatus+0x50>
    }
    /* Some Error */
    else
    {
      Status = (uint32_t)SDMMC003_LOCK_UNLOCK_ERROR;
 80079c6:	f04f 0310 	mov.w	r3, #16
 80079ca:	60fb      	str	r3, [r7, #12]
    }
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80079cc:	68fb      	ldr	r3, [r7, #12]
}
 80079ce:	4618      	mov	r0, r3
 80079d0:	f107 0710 	add.w	r7, r7, #16
 80079d4:	46bd      	mov	sp, r7
 80079d6:	bd80      	pop	{r7, pc}

080079d8 <SDMMC003_lSwitchBusWidth>:
/* <<<DD_SDMMC_nonAPI_25>>> */
/*
 * This function switches the bus width to 4-bit if is supported.
 */
status_t SDMMC003_lSwitchBusWidth(void)
{
 80079d8:	b580      	push	{r7, lr}
 80079da:	b084      	sub	sp, #16
 80079dc:	af00      	add	r7, sp, #0
  uint32_t Argument = 0;
 80079de:	f04f 0300 	mov.w	r3, #0
 80079e2:	60bb      	str	r3, [r7, #8]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 80079e4:	f04f 0301 	mov.w	r3, #1
 80079e8:	60fb      	str	r3, [r7, #12]
  uint32_t CardStatus = 0;
 80079ea:	f04f 0300 	mov.w	r3, #0
 80079ee:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /* Switch to transfer state i.e. CMD7 */
    Status = SDMMC003_lSwitchToTransferState();
 80079f0:	f000 fbe6 	bl	80081c0 <SDMMC003_lSwitchToTransferState>
 80079f4:	60f8      	str	r0, [r7, #12]
/* <<<DD_SDMMC_nonAPI_25_1>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS )
 80079f6:	68fb      	ldr	r3, [r7, #12]
 80079f8:	2b00      	cmp	r3, #0
 80079fa:	d168      	bne.n	8007ace <SDMMC003_lSwitchBusWidth+0xf6>
    {
      break;
    }
    /* Disable Card Interrupt */
    CLR_BIT( SDMMC->EN_INT_SIGNAL_NORM, SDMMC_EN_INT_STATUS_NORM_CARD_INS_EN_Pos );
 80079fc:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007a00:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007a04:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007a08:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8007a0c:	8f12      	ldrh	r2, [r2, #56]	; 0x38
 8007a0e:	b292      	uxth	r2, r2
 8007a10:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8007a14:	b292      	uxth	r2, r2
 8007a16:	871a      	strh	r2, [r3, #56]	; 0x38
    else
#endif /* SDMMC_SUPPORT_MMC_CARD*/
    {
/* <<<DD_SDMMC_nonAPI_25_4>>> */
      /* Check the Data Transfer width supported in SCR Register */
      if( !(SDMMC003_CardInfo.Scr.SdBusWidth & SDMMC003_SCR_BUS_WIDTH4_BITMASK))
 8007a18:	f246 4334 	movw	r3, #25652	; 0x6434
 8007a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007a20:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8007a24:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8007a28:	b2db      	uxtb	r3, r3
 8007a2a:	f003 0304 	and.w	r3, r3, #4
 8007a2e:	2b00      	cmp	r3, #0
 8007a30:	d04f      	beq.n	8007ad2 <SDMMC003_lSwitchBusWidth+0xfa>
      {
        break;
      }
      /* Set the Argument.*/
      Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
 8007a32:	f246 4334 	movw	r3, #25652	; 0x6434
 8007a36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007a3a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8007a3c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8007a40:	68ba      	ldr	r2, [r7, #8]
 8007a42:	4313      	orrs	r3, r2
 8007a44:	60bb      	str	r3, [r7, #8]
      /* Send Application Specific Command */
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), \
 8007a46:	f246 6304 	movw	r3, #26116	; 0x6604
 8007a4a:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007a4e:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 8007a52:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8007a56:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8007a5a:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007a5e:	18d2      	adds	r2, r2, r3
                                      Argument, SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
 8007a60:	f107 0304 	add.w	r3, r7, #4
        break;
      }
      /* Set the Argument.*/
      Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
      /* Send Application Specific Command */
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(55)), \
 8007a64:	4610      	mov	r0, r2
 8007a66:	68b9      	ldr	r1, [r7, #8]
 8007a68:	f04f 0201 	mov.w	r2, #1
 8007a6c:	f7ff f9bc 	bl	8006de8 <SDMMC003_lSendCommand>
 8007a70:	60f8      	str	r0, [r7, #12]
                                      Argument, SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
/* <<<DD_SDMMC_nonAPI_25_5>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 8007a72:	68fb      	ldr	r3, [r7, #12]
 8007a74:	2b00      	cmp	r3, #0
 8007a76:	d12e      	bne.n	8007ad6 <SDMMC003_lSwitchBusWidth+0xfe>
      {
        break;
      }
      /* Send ACMD6 to switch the bus width. */
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(58)), \
 8007a78:	f246 6304 	movw	r3, #26116	; 0x6604
 8007a7c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007a80:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8007a84:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8007a88:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8007a8c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007a90:	18d2      	adds	r2, r2, r3
                                      SDMMC003_SD_4BUS_WIDTH_ARG, \
                                      SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
 8007a92:	f107 0304 	add.w	r3, r7, #4
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
      }
      /* Send ACMD6 to switch the bus width. */
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(58)), \
 8007a96:	4610      	mov	r0, r2
 8007a98:	f04f 0102 	mov.w	r1, #2
 8007a9c:	f04f 0201 	mov.w	r2, #1
 8007aa0:	f7ff f9a2 	bl	8006de8 <SDMMC003_lSendCommand>
 8007aa4:	60f8      	str	r0, [r7, #12]
                                      SDMMC003_SD_4BUS_WIDTH_ARG, \
                                      SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
/* <<<DD_SDMMC_nonAPI_25_6>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 8007aa6:	68fb      	ldr	r3, [r7, #12]
 8007aa8:	2b00      	cmp	r3, #0
 8007aaa:	d116      	bne.n	8007ada <SDMMC003_lSwitchBusWidth+0x102>
      {
        break;
      }
    }
    /* Set Data Transfer Width  in Host Control Register. */
    SET_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_DATA_TX_WIDTH_Pos);
 8007aac:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007ab0:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007ab4:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007ab8:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8007abc:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 8007ac0:	b2d2      	uxtb	r2, r2
 8007ac2:	f042 0202 	orr.w	r2, r2, #2
 8007ac6:	b2d2      	uxtb	r2, r2
 8007ac8:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8007acc:	e006      	b.n	8007adc <SDMMC003_lSwitchBusWidth+0x104>
    /* Switch to transfer state i.e. CMD7 */
    Status = SDMMC003_lSwitchToTransferState();
/* <<<DD_SDMMC_nonAPI_25_1>>> */
    if( Status != (uint32_t)DAVEApp_SUCCESS )
    {
      break;
 8007ace:	bf00      	nop
 8007ad0:	e004      	b.n	8007adc <SDMMC003_lSwitchBusWidth+0x104>
    {
/* <<<DD_SDMMC_nonAPI_25_4>>> */
      /* Check the Data Transfer width supported in SCR Register */
      if( !(SDMMC003_CardInfo.Scr.SdBusWidth & SDMMC003_SCR_BUS_WIDTH4_BITMASK))
      {
        break;
 8007ad2:	bf00      	nop
 8007ad4:	e002      	b.n	8007adc <SDMMC003_lSwitchBusWidth+0x104>
                                      Argument, SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
/* <<<DD_SDMMC_nonAPI_25_5>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 8007ad6:	bf00      	nop
 8007ad8:	e000      	b.n	8007adc <SDMMC003_lSwitchBusWidth+0x104>
                                      SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
/* <<<DD_SDMMC_nonAPI_25_6>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 8007ada:	bf00      	nop
    }
    /* Set Data Transfer Width  in Host Control Register. */
    SET_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_DATA_TX_WIDTH_Pos);
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8007adc:	68fb      	ldr	r3, [r7, #12]
}
 8007ade:	4618      	mov	r0, r3
 8007ae0:	f107 0710 	add.w	r7, r7, #16
 8007ae4:	46bd      	mov	sp, r7
 8007ae6:	bd80      	pop	{r7, pc}

08007ae8 <SDMMC003_lSwitchSpeed>:
/* <<<DD_SDMMC_nonAPI_26>>> */
/*
 * This function switches the card speed to high speed if is supported.
 */
status_t  SDMMC003_lSwitchSpeed( void)
{
 8007ae8:	b580      	push	{r7, lr}
 8007aea:	b094      	sub	sp, #80	; 0x50
 8007aec:	af02      	add	r7, sp, #8
#if SDMMC_SUPPORT_MMC_CARD
uint32_t CardStatus;
#endif
  uint32_t SwitchStatus[16] = {0 };
 8007aee:	f107 0204 	add.w	r2, r7, #4
 8007af2:	f04f 0340 	mov.w	r3, #64	; 0x40
 8007af6:	4610      	mov	r0, r2
 8007af8:	f04f 0100 	mov.w	r1, #0
 8007afc:	461a      	mov	r2, r3
 8007afe:	f01b fef7 	bl	80238f0 <memset>
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8007b02:	f04f 0301 	mov.w	r3, #1
 8007b06:	647b      	str	r3, [r7, #68]	; 0x44
    else
#endif /* SDMMC_SUPPORT_MMC_CARD */
    {
/* <<<DD_SDMMC_nonAPI_26_2>>> */
      /* Check CMD6 support in SCR register*/
      if ( SDMMC003_CardInfo.Scr.SdSpec == 0 )
 8007b08:	f246 4334 	movw	r3, #25652	; 0x6434
 8007b0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007b10:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8007b14:	f003 030f 	and.w	r3, r3, #15
 8007b18:	b2db      	uxtb	r3, r3
 8007b1a:	2b00      	cmp	r3, #0
 8007b1c:	d03d      	beq.n	8007b9a <SDMMC003_lSwitchSpeed+0xb2>
      {
        break;
      }
      /* Switch to transfer state i.e. CMD7 */
      Status = SDMMC003_lSwitchToTransferState();
 8007b1e:	f000 fb4f 	bl	80081c0 <SDMMC003_lSwitchToTransferState>
 8007b22:	6478      	str	r0, [r7, #68]	; 0x44
/* <<<DD_SDMMC_nonAPI_26_3>>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS )
 8007b24:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007b26:	2b00      	cmp	r3, #0
 8007b28:	d139      	bne.n	8007b9e <SDMMC003_lSwitchSpeed+0xb6>
      {
        break;
      }
      /* Send the Switch function  command and read the transferred block of
       * data from the card */
      Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(6)), \
 8007b2a:	f246 6304 	movw	r3, #26116	; 0x6604
 8007b2e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007b32:	799b      	ldrb	r3, [r3, #6]
 8007b34:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8007b38:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8007b3c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8007b40:	18d2      	adds	r2, r2, r3
                                               SDMMC003_SD_HIGH_SPEED_ARG,64, \
                                               (uint32_t*)SwitchStatus, \
 8007b42:	f107 0304 	add.w	r3, r7, #4
      {
        break;
      }
      /* Send the Switch function  command and read the transferred block of
       * data from the card */
      Status = SDMMC003_lSingleBlockTransfer( &(SDMMC003_SD_COMMAND(6)), \
 8007b46:	f04f 0101 	mov.w	r1, #1
 8007b4a:	9100      	str	r1, [sp, #0]
 8007b4c:	4610      	mov	r0, r2
 8007b4e:	f04f 0101 	mov.w	r1, #1
 8007b52:	f2c8 0100 	movt	r1, #32768	; 0x8000
 8007b56:	f04f 0240 	mov.w	r2, #64	; 0x40
 8007b5a:	f7ff fe95 	bl	8007888 <SDMMC003_lSingleBlockTransfer>
 8007b5e:	6478      	str	r0, [r7, #68]	; 0x44
                                               SDMMC003_SD_HIGH_SPEED_ARG,64, \
                                               (uint32_t*)SwitchStatus, \
                                               SDMMC003_READ_FROM_BUFF
                                            );
/* <<<DD_SDMMC_nonAPI_26_4>>> */
      if ( Status != (uint32_t)DAVEApp_SUCCESS)
 8007b60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8007b62:	2b00      	cmp	r3, #0
 8007b64:	d11d      	bne.n	8007ba2 <SDMMC003_lSwitchSpeed+0xba>
      {
        break;
      }
/* <<<DD_SDMMC_nonAPI_26_5>>> */
      if ( ((SwitchStatus[4] & SDMMC003_SWITCH_FUNC_GRP1_STATUS_BITMASK)>>
 8007b66:	697b      	ldr	r3, [r7, #20]
 8007b68:	f003 030f 	and.w	r3, r3, #15
 8007b6c:	2b01      	cmp	r3, #1
 8007b6e:	d003      	beq.n	8007b78 <SDMMC003_lSwitchSpeed+0x90>
            SDMMC003_SWITCH_FUNC_GRP1_STATUS_BITPOS) != 1UL )
      {
        Status = (uint32_t)SDMMC003_ERROR;
 8007b70:	f04f 0301 	mov.w	r3, #1
 8007b74:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 8007b76:	e015      	b.n	8007ba4 <SDMMC003_lSwitchSpeed+0xbc>
      }
      /* Change Speed mode in the Host Controller */
      SET_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_HIGH_SPEED_EN_Pos );
 8007b78:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007b7c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007b80:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007b84:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8007b88:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 8007b8c:	b2d2      	uxtb	r2, r2
 8007b8e:	f042 0204 	orr.w	r2, r2, #4
 8007b92:	b2d2      	uxtb	r2, r2
 8007b94:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8007b98:	e004      	b.n	8007ba4 <SDMMC003_lSwitchSpeed+0xbc>
    {
/* <<<DD_SDMMC_nonAPI_26_2>>> */
      /* Check CMD6 support in SCR register*/
      if ( SDMMC003_CardInfo.Scr.SdSpec == 0 )
      {
        break;
 8007b9a:	bf00      	nop
 8007b9c:	e002      	b.n	8007ba4 <SDMMC003_lSwitchSpeed+0xbc>
      /* Switch to transfer state i.e. CMD7 */
      Status = SDMMC003_lSwitchToTransferState();
/* <<<DD_SDMMC_nonAPI_26_3>>> */
      if( Status != (uint32_t)DAVEApp_SUCCESS )
      {
        break;
 8007b9e:	bf00      	nop
 8007ba0:	e000      	b.n	8007ba4 <SDMMC003_lSwitchSpeed+0xbc>
                                               SDMMC003_READ_FROM_BUFF
                                            );
/* <<<DD_SDMMC_nonAPI_26_4>>> */
      if ( Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 8007ba2:	bf00      	nop
      /* Change Speed mode in the Host Controller */
      SET_BIT( SDMMC->HOST_CTRL,SDMMC_HOST_CTRL_HIGH_SPEED_EN_Pos );
    }
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8007ba4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 8007ba6:	4618      	mov	r0, r3
 8007ba8:	f107 0748 	add.w	r7, r7, #72	; 0x48
 8007bac:	46bd      	mov	sp, r7
 8007bae:	bd80      	pop	{r7, pc}

08007bb0 <SDMMC003_lCommandDelay>:

/*
 * This function provides delay in command execution.
 */
status_t SDMMC003_lCommandDelay(uint32_t DelayTime)
{
 8007bb0:	b580      	push	{r7, lr}
 8007bb2:	b084      	sub	sp, #16
 8007bb4:	af00      	add	r7, sp, #0
 8007bb6:	6078      	str	r0, [r7, #4]
  handle_t TimerId;
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8007bb8:	f04f 0300 	mov.w	r3, #0
 8007bbc:	60fb      	str	r3, [r7, #12]
  SDMMC003_Handle.TimerExpire = 1;
 8007bbe:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007bc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007bc6:	f04f 0201 	mov.w	r2, #1
 8007bca:	729a      	strb	r2, [r3, #10]
  TimerId = SDMMC003_lStartTimer(DelayTime);
 8007bcc:	6878      	ldr	r0, [r7, #4]
 8007bce:	f000 fd71 	bl	80086b4 <SDMMC003_lStartTimer>
 8007bd2:	60b8      	str	r0, [r7, #8]
  if(0 == TimerId)
 8007bd4:	68bb      	ldr	r3, [r7, #8]
 8007bd6:	2b00      	cmp	r3, #0
 8007bd8:	d102      	bne.n	8007be0 <SDMMC003_lCommandDelay+0x30>
  {
    Status = (uint32_t) SDMMC003_START_TIMER_FAILED;
 8007bda:	f04f 032f 	mov.w	r3, #47	; 0x2f
 8007bde:	60fb      	str	r3, [r7, #12]
  }
  if(Status != (uint32_t) SDMMC003_START_TIMER_FAILED)
 8007be0:	68fb      	ldr	r3, [r7, #12]
 8007be2:	2b2f      	cmp	r3, #47	; 0x2f
 8007be4:	d027      	beq.n	8007c36 <SDMMC003_lCommandDelay+0x86>
  {
    do
    {
      /* If any error interrupt bit is set, then break*/
      if (SDMMC->INT_STATUS_NORM &  SDMMC_INT_STATUS_NORM_ERR_INT_Msk )
 8007be6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007bea:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007bee:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8007bf0:	b29b      	uxth	r3, r3
 8007bf2:	b29b      	uxth	r3, r3
 8007bf4:	b21b      	sxth	r3, r3
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	db1c      	blt.n	8007c34 <SDMMC003_lCommandDelay+0x84>
      {
        break;
      }
      if (SDMMC003_Handle.TimerExpire == 0)
 8007bfa:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007bfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007c02:	7a9b      	ldrb	r3, [r3, #10]
 8007c04:	b2db      	uxtb	r3, r3
 8007c06:	2b00      	cmp	r3, #0
 8007c08:	d103      	bne.n	8007c12 <SDMMC003_lCommandDelay+0x62>
      {
        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;
 8007c0a:	f04f 032e 	mov.w	r3, #46	; 0x2e
 8007c0e:	60fb      	str	r3, [r7, #12]
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 8007c10:	e011      	b.n	8007c36 <SDMMC003_lCommandDelay+0x86>
      }
    } while (!(SDMMC003_ISRContext.CmdFlag  || \
 8007c12:	f246 432c 	movw	r3, #25644	; 0x642c
 8007c16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007c1a:	789b      	ldrb	r3, [r3, #2]
 8007c1c:	b2db      	uxtb	r3, r3
 8007c1e:	2b00      	cmp	r3, #0
 8007c20:	d109      	bne.n	8007c36 <SDMMC003_lCommandDelay+0x86>
             SDMMC003_ISRContext.DataFlag ));
 8007c22:	f246 432c 	movw	r3, #25644	; 0x642c
 8007c26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007c2a:	78db      	ldrb	r3, [r3, #3]
 8007c2c:	b2db      	uxtb	r3, r3
      {
        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
      }
    } while (!(SDMMC003_ISRContext.CmdFlag  || \
 8007c2e:	2b00      	cmp	r3, #0
 8007c30:	d0d9      	beq.n	8007be6 <SDMMC003_lCommandDelay+0x36>
 8007c32:	e000      	b.n	8007c36 <SDMMC003_lCommandDelay+0x86>
    do
    {
      /* If any error interrupt bit is set, then break*/
      if (SDMMC->INT_STATUS_NORM &  SDMMC_INT_STATUS_NORM_ERR_INT_Msk )
      {
        break;
 8007c34:	bf00      	nop
        break;
      }
    } while (!(SDMMC003_ISRContext.CmdFlag  || \
             SDMMC003_ISRContext.DataFlag ));
  }
  SDMMC003_lStopTimer(TimerId);
 8007c36:	68b8      	ldr	r0, [r7, #8]
 8007c38:	f000 fd70 	bl	800871c <SDMMC003_lStopTimer>
  SDMMC003_ISRContext.CmdFlag = 0;
 8007c3c:	f246 432c 	movw	r3, #25644	; 0x642c
 8007c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007c44:	f04f 0200 	mov.w	r2, #0
 8007c48:	709a      	strb	r2, [r3, #2]
  SDMMC003_ISRContext.DataFlag = 0;
 8007c4a:	f246 432c 	movw	r3, #25644	; 0x642c
 8007c4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007c52:	f04f 0200 	mov.w	r2, #0
 8007c56:	70da      	strb	r2, [r3, #3]
  return Status;
 8007c58:	68fb      	ldr	r3, [r7, #12]
}
 8007c5a:	4618      	mov	r0, r3
 8007c5c:	f107 0710 	add.w	r7, r7, #16
 8007c60:	46bd      	mov	sp, r7
 8007c62:	bd80      	pop	{r7, pc}

08007c64 <SDMMC003_lErrorInterruptRecovery>:
/*
 * This function performs the recovery task if any error interrupt occurs.
 */
status_t SDMMC003_lErrorInterruptRecovery(uint16_t InterruptStatus,
                                                    uint8_t IssueAbort)
{
 8007c64:	b580      	push	{r7, lr}
 8007c66:	b084      	sub	sp, #16
 8007c68:	af00      	add	r7, sp, #0
 8007c6a:	4602      	mov	r2, r0
 8007c6c:	460b      	mov	r3, r1
 8007c6e:	80fa      	strh	r2, [r7, #6]
 8007c70:	717b      	strb	r3, [r7, #5]
  status_t Status =  (uint32_t)SDMMC003_NONRECOVERABLE_ERROR;
 8007c72:	f04f 0325 	mov.w	r3, #37	; 0x25
 8007c76:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
    /* Disable the Error Interrupt Signal  */
    SDMMC->EN_INT_SIGNAL_ERR = 0;
 8007c78:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007c7c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007c80:	f04f 0200 	mov.w	r2, #0
 8007c84:	875a      	strh	r2, [r3, #58]	; 0x3a
    /* Check Error Interrupt Status bits D0-D3 for CMD line errors */
/* <<<DD_SDMMC_nonAPI_27_1>>> */
    if ( ((InterruptStatus & SDMMC003_ERROR_CMD_STATUS_BITMASK) != 0 ) ||  \
 8007c86:	88fb      	ldrh	r3, [r7, #6]
 8007c88:	f003 030f 	and.w	r3, r3, #15
 8007c8c:	2b00      	cmp	r3, #0
 8007c8e:	d108      	bne.n	8007ca2 <SDMMC003_lErrorInterruptRecovery+0x3e>
         ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_CMD_Msk ))
 8007c90:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007c94:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007c98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007c9a:	f003 0301 	and.w	r3, r3, #1
  {
    /* Disable the Error Interrupt Signal  */
    SDMMC->EN_INT_SIGNAL_ERR = 0;
    /* Check Error Interrupt Status bits D0-D3 for CMD line errors */
/* <<<DD_SDMMC_nonAPI_27_1>>> */
    if ( ((InterruptStatus & SDMMC003_ERROR_CMD_STATUS_BITMASK) != 0 ) ||  \
 8007c9e:	2b00      	cmp	r3, #0
 8007ca0:	d004      	beq.n	8007cac <SDMMC003_lErrorInterruptRecovery+0x48>
         ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_CMD_Msk ))
    {
      /* Set Software Reset for CMD Line  */
      Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk);
 8007ca2:	f04f 0002 	mov.w	r0, #2
 8007ca6:	f7fe fdb1 	bl	800680c <SDMMC003_lReset>
 8007caa:	60f8      	str	r0, [r7, #12]
    }
/* <<<DD_SDMMC_nonAPI_27_2>>> */
    /* Check Error Interrupt Status bits D4-D6 for Data line errors */
    if ( ((InterruptStatus & SDMMC003_ERROR_DATA_STATUS_BITMASK) != 0 ) ||   \
 8007cac:	88fb      	ldrh	r3, [r7, #6]
 8007cae:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8007cb2:	2b00      	cmp	r3, #0
 8007cb4:	d108      	bne.n	8007cc8 <SDMMC003_lErrorInterruptRecovery+0x64>
         ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_DAT_Msk ))
 8007cb6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007cba:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007cbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007cc0:	f003 0302 	and.w	r3, r3, #2
      /* Set Software Reset for CMD Line  */
      Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk);
    }
/* <<<DD_SDMMC_nonAPI_27_2>>> */
    /* Check Error Interrupt Status bits D4-D6 for Data line errors */
    if ( ((InterruptStatus & SDMMC003_ERROR_DATA_STATUS_BITMASK) != 0 ) ||   \
 8007cc4:	2b00      	cmp	r3, #0
 8007cc6:	d004      	beq.n	8007cd2 <SDMMC003_lErrorInterruptRecovery+0x6e>
         ( SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_COMMAND_INHIBIT_DAT_Msk ))
    {
      /*  Set Software Reset for Data Line */
/* <<<DD_SDMMC_nonAPI_27_3>>> */
      Status = SDMMC003_lReset( SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk);
 8007cc8:	f04f 0004 	mov.w	r0, #4
 8007ccc:	f7fe fd9e 	bl	800680c <SDMMC003_lReset>
 8007cd0:	60f8      	str	r0, [r7, #12]
    }
    /*  Clear previous error status  */
    SDMMC->INT_STATUS_ERR = SDMMC003_ALL_ERROR_STATUS_BITMASK ;
 8007cd2:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007cd6:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007cda:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007cde:	865a      	strh	r2, [r3, #50]	; 0x32
    if (IssueAbort == 1)
 8007ce0:	797b      	ldrb	r3, [r7, #5]
 8007ce2:	2b01      	cmp	r3, #1
 8007ce4:	d144      	bne.n	8007d70 <SDMMC003_lErrorInterruptRecovery+0x10c>
    {   
      /*  Issue Abort Command.  */
      /*  Set argument register */
      SDMMC->ARGUMENT1 = SDMMC003_ARGUMENT0;
 8007ce6:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007cea:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007cee:	f04f 0200 	mov.w	r2, #0
 8007cf2:	609a      	str	r2, [r3, #8]
      SDMMC->COMMAND = (uint16_t)(*(uint16_t*)&(SDMMC003_COMMON_COMMAND(12)));  
 8007cf4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007cf8:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007cfc:	f246 6204 	movw	r2, #26116	; 0x6604
 8007d00:	f6c0 0202 	movt	r2, #2050	; 0x802
 8007d04:	7b12      	ldrb	r2, [r2, #12]
 8007d06:	ea4f 0142 	mov.w	r1, r2, lsl #1
 8007d0a:	f246 52b4 	movw	r2, #26036	; 0x65b4
 8007d0e:	f6c0 0202 	movt	r2, #2050	; 0x802
 8007d12:	188a      	adds	r2, r1, r2
 8007d14:	8812      	ldrh	r2, [r2, #0]
 8007d16:	81da      	strh	r2, [r3, #14]
/* Wait for any Interrupt status  bit to set */
/* <<<DD_SDMMC_nonAPI_27_4>>> */    
    /* Timeout of 5ms.*/
      Status =SDMMC003_lCommandDelay(SDMMC003_DELAY_IN_COMMAND);
 8007d18:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007d1c:	f7ff ff48 	bl	8007bb0 <SDMMC003_lCommandDelay>
 8007d20:	60f8      	str	r0, [r7, #12]
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 8007d22:	68fb      	ldr	r3, [r7, #12]
 8007d24:	2b00      	cmp	r3, #0
 8007d26:	d136      	bne.n	8007d96 <SDMMC003_lErrorInterruptRecovery+0x132>
      {
        break;
      }
    /* If error status bit is set in the Status register */
/* <<<DD_SDMMC_nonAPI_27_5>>> */
      if (SDMMC->INT_STATUS_ERR )
 8007d28:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007d2c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007d30:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8007d32:	b29b      	uxth	r3, r3
 8007d34:	2b00      	cmp	r3, #0
 8007d36:	d01b      	beq.n	8007d70 <SDMMC003_lErrorInterruptRecovery+0x10c>
      {
        Status = (uint32_t)SDMMC003_NONRECOVERABLE_ERROR;
 8007d38:	f04f 0325 	mov.w	r3, #37	; 0x25
 8007d3c:	60fb      	str	r3, [r7, #12]
        SDMMC->INT_STATUS_ERR = SDMMC003_ALL_ERROR_STATUS_BITMASK ;
 8007d3e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007d42:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007d46:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007d4a:	865a      	strh	r2, [r3, #50]	; 0x32
        SDMMC->INT_STATUS_NORM = SDMMC003_ALL_ERROR_STATUS_BITMASK ;
 8007d4c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007d50:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007d54:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8007d58:	861a      	strh	r2, [r3, #48]	; 0x30
         /* Set Software Reset for CMD Line and Data Line  */
        SDMMC003_ReturnStatus = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk | \
 8007d5a:	f04f 0006 	mov.w	r0, #6
 8007d5e:	f7fe fd55 	bl	800680c <SDMMC003_lReset>
 8007d62:	4602      	mov	r2, r0
 8007d64:	f246 4328 	movw	r3, #25640	; 0x6428
 8007d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007d6c:	601a      	str	r2, [r3, #0]
                                SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk );
        break;
 8007d6e:	e013      	b.n	8007d98 <SDMMC003_lErrorInterruptRecovery+0x134>
      }
    }
    /* Check Data lines status in present status register  */
/* <<<DD_SDMMC_nonAPI_27_6>>> */
    if (( (SDMMC->PRESENT_STATE  & SDMMC_PRESENT_STATE_DAT_3_0_PIN_LEVEL_Msk) >> \
 8007d70:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007d74:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007d78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007d7a:	f403 0370 	and.w	r3, r3, #15728640	; 0xf00000
 8007d7e:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8007d82:	2b0f      	cmp	r3, #15
 8007d84:	d103      	bne.n	8007d8e <SDMMC003_lErrorInterruptRecovery+0x12a>
           SDMMC_PRESENT_STATE_DAT_3_0_PIN_LEVEL_Pos) == SDMMC003_ALL_DATA_LINES_HIGH)
    {
      Status = (uint32_t)SDMMC003_RECOVERABLE_ERROR;
 8007d86:	f04f 0324 	mov.w	r3, #36	; 0x24
 8007d8a:	60fb      	str	r3, [r7, #12]
 8007d8c:	e004      	b.n	8007d98 <SDMMC003_lErrorInterruptRecovery+0x134>
    }
    else
    {
      Status =  (uint32_t)SDMMC003_NONRECOVERABLE_ERROR;
 8007d8e:	f04f 0325 	mov.w	r3, #37	; 0x25
 8007d92:	60fb      	str	r3, [r7, #12]
 8007d94:	e000      	b.n	8007d98 <SDMMC003_lErrorInterruptRecovery+0x134>
/* <<<DD_SDMMC_nonAPI_27_4>>> */    
    /* Timeout of 5ms.*/
      Status =SDMMC003_lCommandDelay(SDMMC003_DELAY_IN_COMMAND);
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
        break;
 8007d96:	bf00      	nop
    {
      Status =  (uint32_t)SDMMC003_NONRECOVERABLE_ERROR;
    }
  } while(0);
  /* Enable the Error Interrupt signal */
  SDMMC->EN_INT_SIGNAL_ERR |= SDMMC003_ERROR_INT_SIGNAL_ENABLE;
 8007d98:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007d9c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007da0:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8007da4:	f6c4 0201 	movt	r2, #18433	; 0x4801
 8007da8:	8f52      	ldrh	r2, [r2, #58]	; 0x3a
 8007daa:	b292      	uxth	r2, r2
 8007dac:	f462 52f8 	orn	r2, r2, #7936	; 0x1f00
 8007db0:	b292      	uxth	r2, r2
 8007db2:	875a      	strh	r2, [r3, #58]	; 0x3a

  /* Global Error Recovery Variable */
  SDMMC003_Handle.ErrorRecoveryStatus = (SDMMC003_ErrorCodesType)Status;
 8007db4:	68fb      	ldr	r3, [r7, #12]
 8007db6:	b2da      	uxtb	r2, r3
 8007db8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007dc0:	71da      	strb	r2, [r3, #7]
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8007dc2:	68fb      	ldr	r3, [r7, #12]
}
 8007dc4:	4618      	mov	r0, r3
 8007dc6:	f107 0710 	add.w	r7, r7, #16
 8007dca:	46bd      	mov	sp, r7
 8007dcc:	bd80      	pop	{r7, pc}
 8007dce:	bf00      	nop

08007dd0 <SDMMC003_lNormalInterruptHandler>:
/* <<<DD_SDMMC_nonAPI_28>>> */
/*
 * This function handles the Interrupt in Normal Interrupt Status Register.
 */
status_t SDMMC003_lNormalInterruptHandler (uint16_t IntStatus)
{
 8007dd0:	b480      	push	{r7}
 8007dd2:	b085      	sub	sp, #20
 8007dd4:	af00      	add	r7, sp, #0
 8007dd6:	4603      	mov	r3, r0
 8007dd8:	80fb      	strh	r3, [r7, #6]
  status_t Status = (uint32_t)DAVEApp_SUCCESS;
 8007dda:	f04f 0300 	mov.w	r3, #0
 8007dde:	60fb      	str	r3, [r7, #12]
    }
  }
#endif
/* <<<DD_SDMMC_nonAPI_28_3>>> */
  /* BUFFER READ READY INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_NORM_BUFF_READ_READY_Msk) != 0)
 8007de0:	88fb      	ldrh	r3, [r7, #6]
 8007de2:	f003 0320 	and.w	r3, r3, #32
 8007de6:	2b00      	cmp	r3, #0
 8007de8:	d014      	beq.n	8007e14 <SDMMC003_lNormalInterruptHandler+0x44>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.DataInterruptError = SDMMC003_BUFFER_READY;
 8007dea:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007dee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007df2:	f04f 021e 	mov.w	r2, #30
 8007df6:	70da      	strb	r2, [r3, #3]
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_BUFF_READ_READY_Msk;
 8007df8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007dfc:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007e00:	f04f 0220 	mov.w	r2, #32
 8007e04:	861a      	strh	r2, [r3, #48]	; 0x30
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.DataFlag = 1;
 8007e06:	f246 432c 	movw	r3, #25644	; 0x642c
 8007e0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007e0e:	f04f 0201 	mov.w	r2, #1
 8007e12:	70da      	strb	r2, [r3, #3]
  }

/* <<<DD_SDMMC_nonAPI_28_4>>> */
  /* BUFFER WRITE READY INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_NORM_BUFF_WRITE_READY_Msk) != 0)
 8007e14:	88fb      	ldrh	r3, [r7, #6]
 8007e16:	f003 0310 	and.w	r3, r3, #16
 8007e1a:	2b00      	cmp	r3, #0
 8007e1c:	d014      	beq.n	8007e48 <SDMMC003_lNormalInterruptHandler+0x78>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.DataInterruptError = SDMMC003_BUFFER_READY;
 8007e1e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007e22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007e26:	f04f 021e 	mov.w	r2, #30
 8007e2a:	70da      	strb	r2, [r3, #3]
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_BUFF_WRITE_READY_Msk;
 8007e2c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007e30:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007e34:	f04f 0210 	mov.w	r2, #16
 8007e38:	861a      	strh	r2, [r3, #48]	; 0x30
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.DataFlag = 1;
 8007e3a:	f246 432c 	movw	r3, #25644	; 0x642c
 8007e3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007e42:	f04f 0201 	mov.w	r2, #1
 8007e46:	70da      	strb	r2, [r3, #3]
  }
/* <<<DD_SDMMC_nonAPI_28_5>>> */
  /* TRANSFER COMPLETE INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_NORM_TX_COMPLETE_Msk ) != 0)
 8007e48:	88fb      	ldrh	r3, [r7, #6]
 8007e4a:	f003 0302 	and.w	r3, r3, #2
 8007e4e:	2b00      	cmp	r3, #0
 8007e50:	d022      	beq.n	8007e98 <SDMMC003_lNormalInterruptHandler+0xc8>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.TransferInterruptError = SDMMC003_TRANSFER_COMPLETE;
 8007e52:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007e56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007e5a:	f04f 021f 	mov.w	r2, #31
 8007e5e:	715a      	strb	r2, [r3, #5]
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_TX_COMPLETE_Msk;
 8007e60:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007e64:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007e68:	f04f 0202 	mov.w	r2, #2
 8007e6c:	861a      	strh	r2, [r3, #48]	; 0x30
    /* Change the data line Status  to be free */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;
 8007e6e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007e72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007e76:	881b      	ldrh	r3, [r3, #0]
 8007e78:	b29b      	uxth	r3, r3
 8007e7a:	f023 0308 	bic.w	r3, r3, #8
 8007e7e:	b29a      	uxth	r2, r3
 8007e80:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007e84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007e88:	801a      	strh	r2, [r3, #0]
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.TransferFlag = 1;
 8007e8a:	f246 432c 	movw	r3, #25644	; 0x642c
 8007e8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007e92:	f04f 0201 	mov.w	r2, #1
 8007e96:	711a      	strb	r2, [r3, #4]
  }
  
/* <<<DD_SDMMC_nonAPI_28_6>>> */
  /* COMMAND COMPLETE INTERRUPT */
  if ((IntStatus &  SDMMC_INT_STATUS_NORM_CMD_COMPLETE_Msk) != 0)
 8007e98:	88fb      	ldrh	r3, [r7, #6]
 8007e9a:	f003 0301 	and.w	r3, r3, #1
 8007e9e:	2b00      	cmp	r3, #0
 8007ea0:	d022      	beq.n	8007ee8 <SDMMC003_lNormalInterruptHandler+0x118>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_COMPLETE;
 8007ea2:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007ea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007eaa:	f04f 021c 	mov.w	r2, #28
 8007eae:	711a      	strb	r2, [r3, #4]
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_NORM = SDMMC_INT_STATUS_NORM_CMD_COMPLETE_Msk;
 8007eb0:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007eb4:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007eb8:	f04f 0201 	mov.w	r2, #1
 8007ebc:	861a      	strh	r2, [r3, #48]	; 0x30
    /* Change the Command Line Status to free */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;
 8007ebe:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007ec2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007ec6:	881b      	ldrh	r3, [r3, #0]
 8007ec8:	b29b      	uxth	r3, r3
 8007eca:	f023 0304 	bic.w	r3, r3, #4
 8007ece:	b29a      	uxth	r2, r3
 8007ed0:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007ed4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007ed8:	801a      	strh	r2, [r3, #0]
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.CmdFlag = 1;
 8007eda:	f246 432c 	movw	r3, #25644	; 0x642c
 8007ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007ee2:	f04f 0201 	mov.w	r2, #1
 8007ee6:	709a      	strb	r2, [r3, #2]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return (uint32_t)Status;
 8007ee8:	68fb      	ldr	r3, [r7, #12]
}
 8007eea:	4618      	mov	r0, r3
 8007eec:	f107 0714 	add.w	r7, r7, #20
 8007ef0:	46bd      	mov	sp, r7
 8007ef2:	bc80      	pop	{r7}
 8007ef4:	4770      	bx	lr
 8007ef6:	bf00      	nop

08007ef8 <SDMMC003_lErrorInterruptHandler>:
/*
 * This function handles the Interrupt in Error Interrupt Status Register.
 */

status_t SDMMC003_lErrorInterruptHandler(uint16_t IntStatus)
{
 8007ef8:	b480      	push	{r7}
 8007efa:	b085      	sub	sp, #20
 8007efc:	af00      	add	r7, sp, #0
 8007efe:	4603      	mov	r3, r0
 8007f00:	80fb      	strh	r3, [r7, #6]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 8007f02:	f04f 0301 	mov.w	r3, #1
 8007f06:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  SDMMC003_ISRContext.InterruptStatusShadow = IntStatus;
 8007f08:	f246 432c 	movw	r3, #25644	; 0x642c
 8007f0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f10:	88fa      	ldrh	r2, [r7, #6]
 8007f12:	801a      	strh	r2, [r3, #0]
/* <<<DD_SDMMC_nonAPI_29_1>>> */
  /* COMMAND TIMEOUT ERROR INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_TIMEOUT_ERR_Msk)!= 0)
 8007f14:	88fb      	ldrh	r3, [r7, #6]
 8007f16:	f003 0301 	and.w	r3, r3, #1
 8007f1a:	2b00      	cmp	r3, #0
 8007f1c:	d022      	beq.n	8007f64 <SDMMC003_lErrorInterruptHandler+0x6c>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_TIMEOUT_ERROR;
 8007f1e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007f22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f26:	f04f 0202 	mov.w	r2, #2
 8007f2a:	711a      	strb	r2, [r3, #4]
    /* Change the Command Line Status to free */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;
 8007f2c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007f30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f34:	881b      	ldrh	r3, [r3, #0]
 8007f36:	b29b      	uxth	r3, r3
 8007f38:	f023 0304 	bic.w	r3, r3, #4
 8007f3c:	b29a      	uxth	r2, r3
 8007f3e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f46:	801a      	strh	r2, [r3, #0]
     /* Forcefully disable the Command Timeout Error Interrupt */
      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;
    }
#endif  /*SDMMC_UVP_TEST*/
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_ERR =  SDMMC_INT_STATUS_ERR_CMD_TIMEOUT_ERR_Msk;
 8007f48:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007f4c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007f50:	f04f 0201 	mov.w	r2, #1
 8007f54:	865a      	strh	r2, [r3, #50]	; 0x32
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.CmdFlag = 1;
 8007f56:	f246 432c 	movw	r3, #25644	; 0x642c
 8007f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f5e:	f04f 0201 	mov.w	r2, #1
 8007f62:	709a      	strb	r2, [r3, #2]
  }
/* <<<DD_SDMMC_nonAPI_29_2>>> */
/* COMMAND CRC ERROR INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_CRC_ERR_Msk ) != 0)
 8007f64:	88fb      	ldrh	r3, [r7, #6]
 8007f66:	f003 0302 	and.w	r3, r3, #2
 8007f6a:	2b00      	cmp	r3, #0
 8007f6c:	d022      	beq.n	8007fb4 <SDMMC003_lErrorInterruptHandler+0xbc>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_CRC_ERROR;
 8007f6e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f76:	f04f 0203 	mov.w	r2, #3
 8007f7a:	711a      	strb	r2, [r3, #4]
   /* Change the Command Line Status to free */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;
 8007f7c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007f80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f84:	881b      	ldrh	r3, [r3, #0]
 8007f86:	b29b      	uxth	r3, r3
 8007f88:	f023 0304 	bic.w	r3, r3, #4
 8007f8c:	b29a      	uxth	r2, r3
 8007f8e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007f92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007f96:	801a      	strh	r2, [r3, #0]
   /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_CMD_CRC_ERR_Msk;
 8007f98:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007f9c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007fa0:	f04f 0202 	mov.w	r2, #2
 8007fa4:	865a      	strh	r2, [r3, #50]	; 0x32
   /* Update the Interrupt variable */
    SDMMC003_ISRContext.CmdFlag = 1;
 8007fa6:	f246 432c 	movw	r3, #25644	; 0x642c
 8007faa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007fae:	f04f 0201 	mov.w	r2, #1
 8007fb2:	709a      	strb	r2, [r3, #2]
  }
/* <<<DD_SDMMC_nonAPI_29_3>>> */
  /* COMMAND END BIT ERROR INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_END_BIT_ERR_Msk ) != 0)
 8007fb4:	88fb      	ldrh	r3, [r7, #6]
 8007fb6:	f003 0304 	and.w	r3, r3, #4
 8007fba:	2b00      	cmp	r3, #0
 8007fbc:	d022      	beq.n	8008004 <SDMMC003_lErrorInterruptHandler+0x10c>
  {
   /* Update the Global Variable */
    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_ENDBIT_ERROR;
 8007fbe:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007fc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007fc6:	f04f 0204 	mov.w	r2, #4
 8007fca:	711a      	strb	r2, [r3, #4]
   /* Change the Command Line Status to free */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;
 8007fcc:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007fd4:	881b      	ldrh	r3, [r3, #0]
 8007fd6:	b29b      	uxth	r3, r3
 8007fd8:	f023 0304 	bic.w	r3, r3, #4
 8007fdc:	b29a      	uxth	r2, r3
 8007fde:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8007fe2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007fe6:	801a      	strh	r2, [r3, #0]
   /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_CMD_END_BIT_ERR_Msk;
 8007fe8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8007fec:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8007ff0:	f04f 0204 	mov.w	r2, #4
 8007ff4:	865a      	strh	r2, [r3, #50]	; 0x32
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.CmdFlag = 1;
 8007ff6:	f246 432c 	movw	r3, #25644	; 0x642c
 8007ffa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007ffe:	f04f 0201 	mov.w	r2, #1
 8008002:	709a      	strb	r2, [r3, #2]
  }
/* <<<DD_SDMMC_nonAPI_29_4>>> */
  /* COMMAND INDEX ERROR INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_CMD_IND_ERR_Msk ) != 0)
 8008004:	88fb      	ldrh	r3, [r7, #6]
 8008006:	f003 0308 	and.w	r3, r3, #8
 800800a:	2b00      	cmp	r3, #0
 800800c:	d022      	beq.n	8008054 <SDMMC003_lErrorInterruptHandler+0x15c>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.CommandInterruptError = SDMMC003_COMMAND_INDEX_ERROR;
 800800e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008012:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008016:	f04f 0205 	mov.w	r2, #5
 800801a:	711a      	strb	r2, [r3, #4]
    /* Change the Command Line Status to free */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;
 800801c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008020:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008024:	881b      	ldrh	r3, [r3, #0]
 8008026:	b29b      	uxth	r3, r3
 8008028:	f023 0304 	bic.w	r3, r3, #4
 800802c:	b29a      	uxth	r2, r3
 800802e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008032:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008036:	801a      	strh	r2, [r3, #0]
      /* Forcefully disable the Command Index Error Interrupt */
      SDMMC->FORCE_EVENT_ERR_STATUS = 0x0000 ;
    }
#endif  /*SDMMC_UVP_TEST*/
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_CMD_IND_ERR_Msk;
 8008038:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800803c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008040:	f04f 0208 	mov.w	r2, #8
 8008044:	865a      	strh	r2, [r3, #50]	; 0x32
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.CmdFlag = 1;
 8008046:	f246 432c 	movw	r3, #25644	; 0x642c
 800804a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800804e:	f04f 0201 	mov.w	r2, #1
 8008052:	709a      	strb	r2, [r3, #2]
  }
/* <<<DD_SDMMC_nonAPI_29_5>>> */
  /* DATA TIMEOUT ERROR INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_DATA_TIMEOUT_ERR_Msk) != 0)
 8008054:	88fb      	ldrh	r3, [r7, #6]
 8008056:	f003 0310 	and.w	r3, r3, #16
 800805a:	2b00      	cmp	r3, #0
 800805c:	d022      	beq.n	80080a4 <SDMMC003_lErrorInterruptHandler+0x1ac>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.DataInterruptError = SDMMC003_DATA_TIMEOUT_ERROR;
 800805e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008062:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008066:	f04f 0206 	mov.w	r2, #6
 800806a:	70da      	strb	r2, [r3, #3]
    /* Change the Data line to free  */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;
 800806c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008070:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008074:	881b      	ldrh	r3, [r3, #0]
 8008076:	b29b      	uxth	r3, r3
 8008078:	f023 0308 	bic.w	r3, r3, #8
 800807c:	b29a      	uxth	r2, r3
 800807e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008082:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008086:	801a      	strh	r2, [r3, #0]
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_DATA_TIMEOUT_ERR_Msk;
 8008088:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800808c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008090:	f04f 0210 	mov.w	r2, #16
 8008094:	865a      	strh	r2, [r3, #50]	; 0x32
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.DataFlag = 1;
 8008096:	f246 432c 	movw	r3, #25644	; 0x642c
 800809a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800809e:	f04f 0201 	mov.w	r2, #1
 80080a2:	70da      	strb	r2, [r3, #3]
  }
/* <<<DD_SDMMC_nonAPI_29_6>>> */
  /* DATA CRC ERROR INTERRUPT  */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_DATA_CRC_ERR_Msk) != 0)
 80080a4:	88fb      	ldrh	r3, [r7, #6]
 80080a6:	f003 0320 	and.w	r3, r3, #32
 80080aa:	2b00      	cmp	r3, #0
 80080ac:	d022      	beq.n	80080f4 <SDMMC003_lErrorInterruptHandler+0x1fc>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.DataInterruptError = SDMMC003_DATA_CRC_ERROR;
 80080ae:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80080b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80080b6:	f04f 0207 	mov.w	r2, #7
 80080ba:	70da      	strb	r2, [r3, #3]
    /* Change the Data line to free  */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;
 80080bc:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80080c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80080c4:	881b      	ldrh	r3, [r3, #0]
 80080c6:	b29b      	uxth	r3, r3
 80080c8:	f023 0308 	bic.w	r3, r3, #8
 80080cc:	b29a      	uxth	r2, r3
 80080ce:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80080d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80080d6:	801a      	strh	r2, [r3, #0]
      SDMMC->EN_INT_STATUS_NORM |= SDMMC_EN_INT_STATUS_NORM_BUFF_WRITE_READY_EN_Msk;
      SDMMC->EN_INT_SIGNAL_NORM |= SDMMC_EN_INT_SIGNAL_NORM_BUFF_WRITE_READY_EN_Msk;
    }
#endif
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_DATA_CRC_ERR_Msk;
 80080d8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80080dc:	f6c4 0301 	movt	r3, #18433	; 0x4801
 80080e0:	f04f 0220 	mov.w	r2, #32
 80080e4:	865a      	strh	r2, [r3, #50]	; 0x32
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.DataFlag = 1;
 80080e6:	f246 432c 	movw	r3, #25644	; 0x642c
 80080ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80080ee:	f04f 0201 	mov.w	r2, #1
 80080f2:	70da      	strb	r2, [r3, #3]
  }
/* <<<DD_SDMMC_nonAPI_29_7>>> */
  /*DATA END BIT ERROR INTERRUPT */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_DATA_END_BIT_ERR_Msk) != 0)
 80080f4:	88fb      	ldrh	r3, [r7, #6]
 80080f6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80080fa:	2b00      	cmp	r3, #0
 80080fc:	d022      	beq.n	8008144 <SDMMC003_lErrorInterruptHandler+0x24c>
  {
   /* Update the Global Variable */
   SDMMC003_Handle.DataInterruptError = SDMMC003_DATA_ENDBIT_ERROR;
 80080fe:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008102:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008106:	f04f 0208 	mov.w	r2, #8
 800810a:	70da      	strb	r2, [r3, #3]
   /* Change the Data line to free  */
   SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;
 800810c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008110:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008114:	881b      	ldrh	r3, [r3, #0]
 8008116:	b29b      	uxth	r3, r3
 8008118:	f023 0308 	bic.w	r3, r3, #8
 800811c:	b29a      	uxth	r2, r3
 800811e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008122:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008126:	801a      	strh	r2, [r3, #0]
   /* Clear the Interrupt Status Bit */
   SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_DATA_END_BIT_ERR_Msk;
 8008128:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800812c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008130:	f04f 0240 	mov.w	r2, #64	; 0x40
 8008134:	865a      	strh	r2, [r3, #50]	; 0x32
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.DataFlag = 1;
 8008136:	f246 432c 	movw	r3, #25644	; 0x642c
 800813a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800813e:	f04f 0201 	mov.w	r2, #1
 8008142:	70da      	strb	r2, [r3, #3]
  }
/* <<<DD_SDMMC_nonAPI_29_8>>> */
  /* ACMD12 ERROR INTERUPT */
  if ((IntStatus & SDMMC_INT_STATUS_ERR_ACMD_ERR_Msk) != 0)
 8008144:	88fb      	ldrh	r3, [r7, #6]
 8008146:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800814a:	2b00      	cmp	r3, #0
 800814c:	d030      	beq.n	80081b0 <SDMMC003_lErrorInterruptHandler+0x2b8>
  {
    /* Update the Global Variable */
    SDMMC003_Handle.AcmdInterruptError = SDMMC003_ACMD12_ERROR;
 800814e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008152:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008156:	f04f 0209 	mov.w	r2, #9
 800815a:	719a      	strb	r2, [r3, #6]
    /* Change the Cmd line to free  */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_CMD_ACTIVE;
 800815c:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008160:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008164:	881b      	ldrh	r3, [r3, #0]
 8008166:	b29b      	uxth	r3, r3
 8008168:	f023 0304 	bic.w	r3, r3, #4
 800816c:	b29a      	uxth	r2, r3
 800816e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008172:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008176:	801a      	strh	r2, [r3, #0]
    /* Change the Data line to free  */
    SDMMC003_Handle.State &= ~SDMMC003_STATE_DATA_ACTIVE;
 8008178:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800817c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008180:	881b      	ldrh	r3, [r3, #0]
 8008182:	b29b      	uxth	r3, r3
 8008184:	f023 0308 	bic.w	r3, r3, #8
 8008188:	b29a      	uxth	r2, r3
 800818a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800818e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008192:	801a      	strh	r2, [r3, #0]
    /* Clear the Interrupt Status Bit */
    SDMMC->INT_STATUS_ERR = SDMMC_INT_STATUS_ERR_ACMD_ERR_Msk;
 8008194:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008198:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800819c:	f44f 7280 	mov.w	r2, #256	; 0x100
 80081a0:	865a      	strh	r2, [r3, #50]	; 0x32
    /* Update the Interrupt variable */
    SDMMC003_ISRContext.CmdFlag = 1;
 80081a2:	f246 432c 	movw	r3, #25644	; 0x642c
 80081a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80081aa:	f04f 0201 	mov.w	r2, #1
 80081ae:	709a      	strb	r2, [r3, #2]
  }
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 80081b0:	68fb      	ldr	r3, [r7, #12]
}
 80081b2:	4618      	mov	r0, r3
 80081b4:	f107 0714 	add.w	r7, r7, #20
 80081b8:	46bd      	mov	sp, r7
 80081ba:	bc80      	pop	{r7}
 80081bc:	4770      	bx	lr
 80081be:	bf00      	nop

080081c0 <SDMMC003_lSwitchToTransferState>:
 * This function is use to switch the card state to transferring state if the
 * card is not in the transferring state.
 */

status_t SDMMC003_lSwitchToTransferState()
{
 80081c0:	b580      	push	{r7, lr}
 80081c2:	b084      	sub	sp, #16
 80081c4:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)SDMMC003_ERROR;
 80081c6:	f04f 0301 	mov.w	r3, #1
 80081ca:	60fb      	str	r3, [r7, #12]
  uint32_t Argument = 0;
 80081cc:	f04f 0300 	mov.w	r3, #0
 80081d0:	60bb      	str	r3, [r7, #8]
  uint32_t CardStatus = 0UL;
 80081d2:	f04f 0300 	mov.w	r3, #0
 80081d6:	607b      	str	r3, [r7, #4]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  /* Check the current state of the card */
  do
  { 
     Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
 80081d8:	f246 4334 	movw	r3, #25652	; 0x6434
 80081dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80081e0:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 80081e2:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80081e6:	68ba      	ldr	r2, [r7, #8]
 80081e8:	4313      	orrs	r3, r2
 80081ea:	60bb      	str	r3, [r7, #8]
    /* Send Cmd13 to read card status  */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)),Argument, \
 80081ec:	f246 6304 	movw	r3, #26116	; 0x6604
 80081f0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80081f4:	7b5b      	ldrb	r3, [r3, #13]
 80081f6:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80081fa:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80081fe:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008202:	18d2      	adds	r2, r2, r3
                                      SDMMC003_RESPONSE_R1,&CardStatus);
 8008204:	f107 0304 	add.w	r3, r7, #4
  /* Check the current state of the card */
  do
  { 
     Argument |= SDMMC003_CardInfo.Rca << SDMMC003_ARG_RCA_BITPOS;
    /* Send Cmd13 to read card status  */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)),Argument, \
 8008208:	4610      	mov	r0, r2
 800820a:	68b9      	ldr	r1, [r7, #8]
 800820c:	f04f 0201 	mov.w	r2, #1
 8008210:	f7fe fdea 	bl	8006de8 <SDMMC003_lSendCommand>
 8008214:	60f8      	str	r0, [r7, #12]
                                      SDMMC003_RESPONSE_R1,&CardStatus);
/* <<<DD_SDMMC_nonAPI_30_1>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8008216:	68fb      	ldr	r3, [r7, #12]
 8008218:	2b00      	cmp	r3, #0
 800821a:	d120      	bne.n	800825e <SDMMC003_lSwitchToTransferState+0x9e>
    {
      break;
    }
/* <<<DD_SDMMC_nonAPI_30_2>>> */
    /* Check if it is in transferring state */
    if( (( CardStatus & SDMMC003_CSR_CURRENT_STATE_BITMASK) >>\
 800821c:	687b      	ldr	r3, [r7, #4]
 800821e:	f403 53e8 	and.w	r3, r3, #7424	; 0x1d00
 8008222:	ea4f 2353 	mov.w	r3, r3, lsr #9
 8008226:	2b04      	cmp	r3, #4
 8008228:	d103      	bne.n	8008232 <SDMMC003_lSwitchToTransferState+0x72>
        Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(7)),Argument, \
                                        SDMMC003_RESPONSE_R1b, &CardStatus);
        break;
      }
#endif
      Status = (uint32_t)DAVEApp_SUCCESS;
 800822a:	f04f 0300 	mov.w	r3, #0
 800822e:	60fb      	str	r3, [r7, #12]
      break;
 8008230:	e016      	b.n	8008260 <SDMMC003_lSwitchToTransferState+0xa0>
    }
    /* Switch to transfer state i.e. CMD7 */
/* <<<DD_SDMMC_nonAPI_30_3>>> */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(7)),Argument, \
 8008232:	f246 6304 	movw	r3, #26116	; 0x6604
 8008236:	f6c0 0302 	movt	r3, #2050	; 0x802
 800823a:	79db      	ldrb	r3, [r3, #7]
 800823c:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8008240:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8008244:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008248:	18d2      	adds	r2, r2, r3
                                   SDMMC003_RESPONSE_R1b, &CardStatus);
 800824a:	f107 0304 	add.w	r3, r7, #4
      Status = (uint32_t)DAVEApp_SUCCESS;
      break;
    }
    /* Switch to transfer state i.e. CMD7 */
/* <<<DD_SDMMC_nonAPI_30_3>>> */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(7)),Argument, \
 800824e:	4610      	mov	r0, r2
 8008250:	68b9      	ldr	r1, [r7, #8]
 8008252:	f04f 0202 	mov.w	r2, #2
 8008256:	f7fe fdc7 	bl	8006de8 <SDMMC003_lSendCommand>
 800825a:	60f8      	str	r0, [r7, #12]
 800825c:	e000      	b.n	8008260 <SDMMC003_lSwitchToTransferState+0xa0>
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(13)),Argument, \
                                      SDMMC003_RESPONSE_R1,&CardStatus);
/* <<<DD_SDMMC_nonAPI_30_1>>> */
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 800825e:	bf00      	nop
/* <<<DD_SDMMC_nonAPI_30_3>>> */
    Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(7)),Argument, \
                                   SDMMC003_RESPONSE_R1b, &CardStatus);
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 8008260:	68fb      	ldr	r3, [r7, #12]
}
 8008262:	4618      	mov	r0, r3
 8008264:	f107 0710 	add.w	r7, r7, #16
 8008268:	46bd      	mov	sp, r7
 800826a:	bd80      	pop	{r7, pc}

0800826c <SDMMC003_lDataTransfer>:
 * This function performs the data transfer to/from the card .
 */
status_t SDMMC003_lDataTransfer( uint32_t *BufferPtr, \
                              SDMMC003_DataTrasferType TransferMode, \
                              uint32_t QuadBytes)
{
 800826c:	b580      	push	{r7, lr}
 800826e:	b088      	sub	sp, #32
 8008270:	af00      	add	r7, sp, #0
 8008272:	60f8      	str	r0, [r7, #12]
 8008274:	460b      	mov	r3, r1
 8008276:	607a      	str	r2, [r7, #4]
 8008278:	72fb      	strb	r3, [r7, #11]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 800827a:	f04f 0301 	mov.w	r3, #1
 800827e:	61fb      	str	r3, [r7, #28]
  handle_t TimerId;
  uint32_t Count = 0;
 8008280:	f04f 0300 	mov.w	r3, #0
 8008284:	61bb      	str	r3, [r7, #24]
  FUNCTION_ENTRY(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_ENTRY);
  do
  {
/* Block on Buffer Read/Write Ready Interrupt */
/* <<<DD_SDMMC_nonAPI_31_1>>> */
    TimerId = SDMMC003_lStartTimer(SDMMC003_RESET_In_DATA_TRANSFER);
 8008286:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800828a:	f000 fa13 	bl	80086b4 <SDMMC003_lStartTimer>
 800828e:	6178      	str	r0, [r7, #20]
    if(0 == TimerId)
 8008290:	697b      	ldr	r3, [r7, #20]
 8008292:	2b00      	cmp	r3, #0
 8008294:	d103      	bne.n	800829e <SDMMC003_lDataTransfer+0x32>
    {
      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;
 8008296:	f04f 032f 	mov.w	r3, #47	; 0x2f
 800829a:	61fb      	str	r3, [r7, #28]
      ERROR(GID_SDMMC00x, Status, 0, NULL);  
      break;  
 800829c:	e065      	b.n	800836a <SDMMC003_lDataTransfer+0xfe>
    }
    do
    {
      if (SDMMC003_Handle.TimerExpire == 0)
 800829e:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80082a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80082a6:	7a9b      	ldrb	r3, [r3, #10]
 80082a8:	b2db      	uxtb	r3, r3
 80082aa:	2b00      	cmp	r3, #0
 80082ac:	d103      	bne.n	80082b6 <SDMMC003_lDataTransfer+0x4a>
      {
        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;
 80082ae:	f04f 032e 	mov.w	r3, #46	; 0x2e
 80082b2:	61fb      	str	r3, [r7, #28]
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 80082b4:	e007      	b.n	80082c6 <SDMMC003_lDataTransfer+0x5a>
      }
    } while( SDMMC003_ISRContext.DataFlag == 0);
 80082b6:	f246 432c 	movw	r3, #25644	; 0x642c
 80082ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80082be:	78db      	ldrb	r3, [r3, #3]
 80082c0:	b2db      	uxtb	r3, r3
 80082c2:	2b00      	cmp	r3, #0
 80082c4:	d0eb      	beq.n	800829e <SDMMC003_lDataTransfer+0x32>
    SDMMC003_lStopTimer(TimerId);
 80082c6:	6978      	ldr	r0, [r7, #20]
 80082c8:	f000 fa28 	bl	800871c <SDMMC003_lStopTimer>
    SDMMC003_ISRContext.DataFlag = 0;
 80082cc:	f246 432c 	movw	r3, #25644	; 0x642c
 80082d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80082d4:	f04f 0200 	mov.w	r2, #0
 80082d8:	70da      	strb	r2, [r3, #3]
    /* Check Buffer is ready */
/* <<<DD_SDMMC_nonAPI_31_2>>> */
    if (SDMMC003_Handle.DataInterruptError == SDMMC003_BUFFER_READY)
 80082da:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80082de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80082e2:	78db      	ldrb	r3, [r3, #3]
 80082e4:	b2db      	uxtb	r3, r3
 80082e6:	2b1e      	cmp	r3, #30
 80082e8:	d127      	bne.n	800833a <SDMMC003_lDataTransfer+0xce>
    {
     /* Non-DMA transfer */
/*<<<DD_SDMMC_nonAPI_31_7>>> */
      /* Data transfer 4bytes in each iteration  */
      for (Count=0; Count<QuadBytes; Count++)
 80082ea:	f04f 0300 	mov.w	r3, #0
 80082ee:	61bb      	str	r3, [r7, #24]
 80082f0:	e01b      	b.n	800832a <SDMMC003_lDataTransfer+0xbe>
      {
/*<<<DD_SDMMC_nonAPI_31_8>>> */
        if (TransferMode == SDMMC003_READ_FROM_BUFF)
 80082f2:	7afb      	ldrb	r3, [r7, #11]
 80082f4:	2b01      	cmp	r3, #1
 80082f6:	d106      	bne.n	8008306 <SDMMC003_lDataTransfer+0x9a>
        {
          *BufferPtr  = SDMMC->DATA_BUFFER;
 80082f8:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80082fc:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008300:	6a1a      	ldr	r2, [r3, #32]
 8008302:	68fb      	ldr	r3, [r7, #12]
 8008304:	601a      	str	r2, [r3, #0]
        }
/*<<<DD_SDMMC_nonAPI_31_9>>> */
        if(TransferMode == SDMMC003_WRITE_INTO_BUFF)
 8008306:	7afb      	ldrb	r3, [r7, #11]
 8008308:	2b02      	cmp	r3, #2
 800830a:	d106      	bne.n	800831a <SDMMC003_lDataTransfer+0xae>
        {
          SDMMC->DATA_BUFFER = *BufferPtr;
 800830c:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008310:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008314:	68fa      	ldr	r2, [r7, #12]
 8008316:	6812      	ldr	r2, [r2, #0]
 8008318:	621a      	str	r2, [r3, #32]
        }
        BufferPtr++;
 800831a:	68fb      	ldr	r3, [r7, #12]
 800831c:	f103 0304 	add.w	r3, r3, #4
 8008320:	60fb      	str	r3, [r7, #12]
    if (SDMMC003_Handle.DataInterruptError == SDMMC003_BUFFER_READY)
    {
     /* Non-DMA transfer */
/*<<<DD_SDMMC_nonAPI_31_7>>> */
      /* Data transfer 4bytes in each iteration  */
      for (Count=0; Count<QuadBytes; Count++)
 8008322:	69bb      	ldr	r3, [r7, #24]
 8008324:	f103 0301 	add.w	r3, r3, #1
 8008328:	61bb      	str	r3, [r7, #24]
 800832a:	69ba      	ldr	r2, [r7, #24]
 800832c:	687b      	ldr	r3, [r7, #4]
 800832e:	429a      	cmp	r2, r3
 8008330:	d3df      	bcc.n	80082f2 <SDMMC003_lDataTransfer+0x86>
        {
          SDMMC->DATA_BUFFER = *BufferPtr;
        }
        BufferPtr++;
      }
      Status = (uint32_t)DAVEApp_SUCCESS;
 8008332:	f04f 0300 	mov.w	r3, #0
 8008336:	61fb      	str	r3, [r7, #28]
 8008338:	e017      	b.n	800836a <SDMMC003_lDataTransfer+0xfe>
    }/* End of "if (SDMMC_Handle.DataInterruptError == SDMMC003_BUFFER_READY)" */
/*<<<DD_SDMMC_nonAPI_31_10>>> */
    else
    {
      SDMMC003_Handle.IssueAbort = 1;
 800833a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800833e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008342:	f04f 0201 	mov.w	r2, #1
 8008346:	72da      	strb	r2, [r3, #11]
      Status = SDMMC003_lErrorInterruptRecovery(\
 8008348:	f246 432c 	movw	r3, #25644	; 0x642c
 800834c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008350:	881b      	ldrh	r3, [r3, #0]
 8008352:	b29a      	uxth	r2, r3
 8008354:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008358:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800835c:	7adb      	ldrb	r3, [r3, #11]
 800835e:	b2db      	uxtb	r3, r3
 8008360:	4610      	mov	r0, r2
 8008362:	4619      	mov	r1, r3
 8008364:	f7ff fc7e 	bl	8007c64 <SDMMC003_lErrorInterruptRecovery>
 8008368:	61f8      	str	r0, [r7, #28]
                              SDMMC003_ISRContext.InterruptStatusShadow, \
                              SDMMC003_Handle.IssueAbort);
    }
  } while(0);
  FUNCTION_EXIT(GID_SDMMC00x, (uint32_t)SDMMC003_FUNCTION_EXIT);
  return Status;
 800836a:	69fb      	ldr	r3, [r7, #28]
}
 800836c:	4618      	mov	r0, r3
 800836e:	f107 0720 	add.w	r7, r7, #32
 8008372:	46bd      	mov	sp, r7
 8008374:	bd80      	pop	{r7, pc}
 8008376:	bf00      	nop

08008378 <SDMMC003_CheckPCMDFlag>:

/*
 * This function checks the PCMD flag.
 */
void SDMMC003_CheckPCMDFlag(status_t PCMDFlag)
{
 8008378:	b480      	push	{r7}
 800837a:	b083      	sub	sp, #12
 800837c:	af00      	add	r7, sp, #0
 800837e:	6078      	str	r0, [r7, #4]
  SDMMC003_ReturnStatus  = 1UL;
 8008380:	f246 4328 	movw	r3, #25640	; 0x6428
 8008384:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008388:	f04f 0201 	mov.w	r2, #1
 800838c:	601a      	str	r2, [r3, #0]
  }
  else
  {
    ERROR(GID_SDMMC00x, SDMMC003_ACMD_SD_TRANSFER_ERROR,0,0);
  }
}
 800838e:	f107 070c 	add.w	r7, r7, #12
 8008392:	46bd      	mov	sp, r7
 8008394:	bc80      	pop	{r7}
 8008396:	4770      	bx	lr

08008398 <SDMMC003_lAcmdErrorRecovery>:
/* <<<DD_SDMMC_nonAPI_32>>> */
/*
 * This function performs the ACMD error Recovery.
 */
void SDMMC003_lAcmdErrorRecovery()
{
 8008398:	b580      	push	{r7, lr}
 800839a:	b084      	sub	sp, #16
 800839c:	af00      	add	r7, sp, #0
  status_t Status;
  status_t PCMDFlag = 0;
 800839e:	f04f 0300 	mov.w	r3, #0
 80083a2:	60fb      	str	r3, [r7, #12]
  uint32_t CardStatus = 0;
 80083a4:	f04f 0300 	mov.w	r3, #0
 80083a8:	607b      	str	r3, [r7, #4]
  do
  {
/* <<<DD_SDMMC_nonAPI_32_1>>> */
    /** Check Auto CMD12 Not Executed Err in Auto CMd12 Error Status Register */
    if ( ((SDMMC->ACMD_ERR_STATUS & SDMMC_ACMD_ERR_STATUS_ACMD12_NOT_EXEC_ERR_Msk) >> \
 80083aa:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 80083ae:	f6c4 0301 	movt	r3, #18433	; 0x4801
 80083b2:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 80083b4:	b29b      	uxth	r3, r3
 80083b6:	f003 0301 	and.w	r3, r3, #1
 80083ba:	2b00      	cmp	r3, #0
 80083bc:	d027      	beq.n	800840e <SDMMC003_lAcmdErrorRecovery+0x76>
            SDMMC_ACMD_ERR_STATUS_ACMD12_NOT_EXEC_ERR_Pos)  == 1)
    {
      /* Set PCMDFlag to 1*/
      PCMDFlag = 1;
 80083be:	f04f 0301 	mov.w	r3, #1
 80083c2:	60fb      	str	r3, [r7, #12]
      /* Check Return Status of Recovery function of CMD_wo_DAT command */
/* <<<DD_SDMMC_nonAPI_32_2>>> */
      if (SDMMC003_Handle.ErrorRecoveryStatus != SDMMC003_RECOVERABLE_ERROR)
 80083c4:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80083c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80083cc:	79db      	ldrb	r3, [r3, #7]
 80083ce:	b2db      	uxtb	r3, r3
 80083d0:	2b24      	cmp	r3, #36	; 0x24
 80083d2:	d155      	bne.n	8008480 <SDMMC003_lAcmdErrorRecovery+0xe8>
      {
        ERROR(GID_SDMMC00x, SDMMC003_NONRECOVERABLE_ERROR,0,0);
        break;
      }
      /* For recoverable error, issue CMD12 */
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(12)), \
 80083d4:	f246 6304 	movw	r3, #26116	; 0x6604
 80083d8:	f6c0 0302 	movt	r3, #2050	; 0x802
 80083dc:	7b1b      	ldrb	r3, [r3, #12]
 80083de:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80083e2:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80083e6:	f6c0 0302 	movt	r3, #2050	; 0x802
 80083ea:	18d2      	adds	r2, r2, r3
                                      SDMMC003_ARGUMENT0, \
                                      SDMMC003_RESPONSE_R1, &CardStatus);
 80083ec:	f107 0304 	add.w	r3, r7, #4
      {
        ERROR(GID_SDMMC00x, SDMMC003_NONRECOVERABLE_ERROR,0,0);
        break;
      }
      /* For recoverable error, issue CMD12 */
      Status = SDMMC003_lSendCommand( &(SDMMC003_COMMON_COMMAND(12)), \
 80083f0:	4610      	mov	r0, r2
 80083f2:	f04f 0100 	mov.w	r1, #0
 80083f6:	f04f 0201 	mov.w	r2, #1
 80083fa:	f7fe fcf5 	bl	8006de8 <SDMMC003_lSendCommand>
 80083fe:	60b8      	str	r0, [r7, #8]
                                      SDMMC003_ARGUMENT0, \
                                      SDMMC003_RESPONSE_R1, &CardStatus);
      /* No Error */
/* <<<DD_SDMMC_nonAPI_32_3>>> */
      if (Status == (uint32_t)DAVEApp_SUCCESS)
 8008400:	68bb      	ldr	r3, [r7, #8]
 8008402:	2b00      	cmp	r3, #0
 8008404:	d03e      	beq.n	8008484 <SDMMC003_lAcmdErrorRecovery+0xec>
        ERROR(GID_SDMMC00x, SDMMC003_ACMD_CMD_wo_DAT_ERROR,0,0);
        break;
      }
/* <<<DD_SDMMC_nonAPI_32_4>>> */
      /* Non Recoverable Error */
      if (Status == (uint32_t)SDMMC003_NONRECOVERABLE_ERROR)
 8008406:	68bb      	ldr	r3, [r7, #8]
 8008408:	2b25      	cmp	r3, #37	; 0x25
 800840a:	d121      	bne.n	8008450 <SDMMC003_lAcmdErrorRecovery+0xb8>
      {
        ERROR(GID_SDMMC00x, Status,0,0);
        break;
 800840c:	e041      	b.n	8008492 <SDMMC003_lAcmdErrorRecovery+0xfa>
    }
/* <<<DD_SDMMC_nonAPI_32_5>>> */
    else
    {
      /* Set software reset for CMD line */
      Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk);
 800840e:	f04f 0002 	mov.w	r0, #2
 8008412:	f7fe f9fb 	bl	800680c <SDMMC003_lReset>
 8008416:	60b8      	str	r0, [r7, #8]
      if ( Status !=(uint32_t)DAVEApp_SUCCESS)
 8008418:	68bb      	ldr	r3, [r7, #8]
 800841a:	2b00      	cmp	r3, #0
 800841c:	d134      	bne.n	8008488 <SDMMC003_lAcmdErrorRecovery+0xf0>
      {
        break;
      }
      /* Issue Cmd 12*/
/* <<<DD_SDMMC_nonAPI_32_6>>> */
      Status = SDMMC003_lSendCommand(  &(SDMMC003_COMMON_COMMAND(12)), \
 800841e:	f246 6304 	movw	r3, #26116	; 0x6604
 8008422:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008426:	7b1b      	ldrb	r3, [r3, #12]
 8008428:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800842c:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8008430:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008434:	18d2      	adds	r2, r2, r3
                                      SDMMC003_ARGUMENT0, \
                                      SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
 8008436:	f107 0304 	add.w	r3, r7, #4
      {
        break;
      }
      /* Issue Cmd 12*/
/* <<<DD_SDMMC_nonAPI_32_6>>> */
      Status = SDMMC003_lSendCommand(  &(SDMMC003_COMMON_COMMAND(12)), \
 800843a:	4610      	mov	r0, r2
 800843c:	f04f 0100 	mov.w	r1, #0
 8008440:	f04f 0201 	mov.w	r2, #1
 8008444:	f7fe fcd0 	bl	8006de8 <SDMMC003_lSendCommand>
 8008448:	60b8      	str	r0, [r7, #8]
                                      SDMMC003_ARGUMENT0, \
                                      SDMMC003_RESPONSE_R1, \
                                      &CardStatus);
      /* Non Recoverable Error */
/* <<<DD_SDMMC_nonAPI_32_7>>> */
      if (Status == (uint32_t)SDMMC003_NONRECOVERABLE_ERROR)
 800844a:	68bb      	ldr	r3, [r7, #8]
 800844c:	2b25      	cmp	r3, #37	; 0x25
 800844e:	d01d      	beq.n	800848c <SDMMC003_lAcmdErrorRecovery+0xf4>
        ERROR(GID_SDMMC00x, Status,0,0);
        break;
      }
    }
    /*Set Software Reset for  Data line*/
    Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk);
 8008450:	f04f 0004 	mov.w	r0, #4
 8008454:	f7fe f9da 	bl	800680c <SDMMC003_lReset>
 8008458:	60b8      	str	r0, [r7, #8]
    if ( Status !=(uint32_t)DAVEApp_SUCCESS)
 800845a:	68bb      	ldr	r3, [r7, #8]
 800845c:	2b00      	cmp	r3, #0
 800845e:	d117      	bne.n	8008490 <SDMMC003_lAcmdErrorRecovery+0xf8>
    {
      break;
    }
/* <<<DD_SDMMC_nonAPI_32_8>>> */
    /*Check Command Not issued by Auto CMD12 Error */
    if (((SDMMC->ACMD_ERR_STATUS & SDMMC_ACMD_ERR_STATUS_CMD_NOT_ISSUED_BY_ACMD12_ERR_Msk) >> \
 8008460:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008464:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008468:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800846a:	b29b      	uxth	r3, r3
 800846c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008470:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 8008474:	2b01      	cmp	r3, #1
 8008476:	d00c      	beq.n	8008492 <SDMMC003_lAcmdErrorRecovery+0xfa>
/* <<<DD_SDMMC_nonAPI_32_9>>> */
    else
    {
     /* Check PCMD flag.If 1 means that An error occurred in CMD_wo_DAT,
      *  and also occurred in the SD memory transfer */
      SDMMC003_CheckPCMDFlag(PCMDFlag);
 8008478:	68f8      	ldr	r0, [r7, #12]
 800847a:	f7ff ff7d 	bl	8008378 <SDMMC003_CheckPCMDFlag>
 800847e:	e008      	b.n	8008492 <SDMMC003_lAcmdErrorRecovery+0xfa>
      /* Check Return Status of Recovery function of CMD_wo_DAT command */
/* <<<DD_SDMMC_nonAPI_32_2>>> */
      if (SDMMC003_Handle.ErrorRecoveryStatus != SDMMC003_RECOVERABLE_ERROR)
      {
        ERROR(GID_SDMMC00x, SDMMC003_NONRECOVERABLE_ERROR,0,0);
        break;
 8008480:	bf00      	nop
 8008482:	e006      	b.n	8008492 <SDMMC003_lAcmdErrorRecovery+0xfa>
      /* No Error */
/* <<<DD_SDMMC_nonAPI_32_3>>> */
      if (Status == (uint32_t)DAVEApp_SUCCESS)
      {
        ERROR(GID_SDMMC00x, SDMMC003_ACMD_CMD_wo_DAT_ERROR,0,0);
        break;
 8008484:	bf00      	nop
 8008486:	e004      	b.n	8008492 <SDMMC003_lAcmdErrorRecovery+0xfa>
    {
      /* Set software reset for CMD line */
      Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_CMD_LINE_Msk);
      if ( Status !=(uint32_t)DAVEApp_SUCCESS)
      {
        break;
 8008488:	bf00      	nop
 800848a:	e002      	b.n	8008492 <SDMMC003_lAcmdErrorRecovery+0xfa>
      /* Non Recoverable Error */
/* <<<DD_SDMMC_nonAPI_32_7>>> */
      if (Status == (uint32_t)SDMMC003_NONRECOVERABLE_ERROR)
      {
        ERROR(GID_SDMMC00x, Status,0,0);
        break;
 800848c:	bf00      	nop
 800848e:	e000      	b.n	8008492 <SDMMC003_lAcmdErrorRecovery+0xfa>
    }
    /*Set Software Reset for  Data line*/
    Status = SDMMC003_lReset(SDMMC_SW_RESET_SW_RST_DAT_LINE_Msk);
    if ( Status !=(uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8008490:	bf00      	nop
     /* Check PCMD flag.If 1 means that An error occurred in CMD_wo_DAT,
      *  and also occurred in the SD memory transfer */
      SDMMC003_CheckPCMDFlag(PCMDFlag);
    }
  } while(0);
}
 8008492:	f107 0710 	add.w	r7, r7, #16
 8008496:	46bd      	mov	sp, r7
 8008498:	bd80      	pop	{r7, pc}
 800849a:	bf00      	nop

0800849c <Timer_CallBack>:

void Timer_CallBack(void* Temp)
{
 800849c:	b480      	push	{r7}
 800849e:	b083      	sub	sp, #12
 80084a0:	af00      	add	r7, sp, #0
 80084a2:	6078      	str	r0, [r7, #4]
  if (Temp != NULL)
 80084a4:	687b      	ldr	r3, [r7, #4]
 80084a6:	2b00      	cmp	r3, #0
 80084a8:	d005      	beq.n	80084b6 <Timer_CallBack+0x1a>
  {
    SDMMC003_ReturnStatus = (status_t)Temp;
 80084aa:	687a      	ldr	r2, [r7, #4]
 80084ac:	f246 4328 	movw	r3, #25640	; 0x6428
 80084b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084b4:	601a      	str	r2, [r3, #0]
  }
  SDMMC003_Handle.TimerExpire =0;
 80084b6:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80084ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084be:	f04f 0200 	mov.w	r2, #0
 80084c2:	729a      	strb	r2, [r3, #10]
}
 80084c4:	f107 070c 	add.w	r7, r7, #12
 80084c8:	46bd      	mov	sp, r7
 80084ca:	bc80      	pop	{r7}
 80084cc:	4770      	bx	lr
 80084ce:	bf00      	nop

080084d0 <SDMMC003_lDelay>:
/* <<< DD_SDMMC_nonAPI_33 >>> */
/**
 * This function is used to some delay.
 */
void SDMMC003_lDelay(uint32_t DelayTime)
{
 80084d0:	b580      	push	{r7, lr}
 80084d2:	b084      	sub	sp, #16
 80084d4:	af00      	add	r7, sp, #0
 80084d6:	6078      	str	r0, [r7, #4]
  handle_t TimerId;
  status_t Status;
  SDMMC003_Handle.TimerExpire = 1;
 80084d8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80084dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084e0:	f04f 0201 	mov.w	r2, #1
 80084e4:	729a      	strb	r2, [r3, #10]
  TimerId = SYSTM001_CreateTimer(DelayTime,SYSTM001_ONE_SHOT,Timer_CallBack,NULL);
 80084e6:	6878      	ldr	r0, [r7, #4]
 80084e8:	f04f 0100 	mov.w	r1, #0
 80084ec:	f248 429d 	movw	r2, #33949	; 0x849d
 80084f0:	f6c0 0200 	movt	r2, #2048	; 0x800
 80084f4:	f04f 0300 	mov.w	r3, #0
 80084f8:	f7fb fef2 	bl	80042e0 <SYSTM001_CreateTimer>
 80084fc:	60f8      	str	r0, [r7, #12]
  if(TimerId != 0)
 80084fe:	68fb      	ldr	r3, [r7, #12]
 8008500:	2b00      	cmp	r3, #0
 8008502:	d01f      	beq.n	8008544 <SDMMC003_lDelay+0x74>
  {
    /* Timer is created successfully */
    Status = SYSTM001_StartTimer(TimerId);
 8008504:	68f8      	ldr	r0, [r7, #12]
 8008506:	f7fb ffbb 	bl	8004480 <SYSTM001_StartTimer>
 800850a:	60b8      	str	r0, [r7, #8]
    if(Status == DAVEApp_SUCCESS)
 800850c:	68bb      	ldr	r3, [r7, #8]
 800850e:	2b00      	cmp	r3, #0
 8008510:	d118      	bne.n	8008544 <SDMMC003_lDelay+0x74>
    {
      /* Wait in infinite loop till the timer expires */
      while(SDMMC003_Handle.TimerExpire)
 8008512:	bf00      	nop
 8008514:	f640 53c0 	movw	r3, #3520	; 0xdc0
 8008518:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800851c:	7a9b      	ldrb	r3, [r3, #10]
 800851e:	b2db      	uxtb	r3, r3
 8008520:	2b00      	cmp	r3, #0
 8008522:	d1f7      	bne.n	8008514 <SDMMC003_lDelay+0x44>
      {
      }
      /* stop the timer */
      Status = SYSTM001_StopTimer(TimerId);
 8008524:	68f8      	ldr	r0, [r7, #12]
 8008526:	f7fc f805 	bl	8004534 <SYSTM001_StopTimer>
 800852a:	60b8      	str	r0, [r7, #8]
      /* Delete the Timer*/
      if(Status == DAVEApp_SUCCESS)
 800852c:	68bb      	ldr	r3, [r7, #8]
 800852e:	2b00      	cmp	r3, #0
 8008530:	d108      	bne.n	8008544 <SDMMC003_lDelay+0x74>
      {
        SDMMC003_ReturnStatus = SYSTM001_DeleteTimer(TimerId);
 8008532:	68f8      	ldr	r0, [r7, #12]
 8008534:	f7fc f846 	bl	80045c4 <SYSTM001_DeleteTimer>
 8008538:	4602      	mov	r2, r0
 800853a:	f246 4328 	movw	r3, #25640	; 0x6428
 800853e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008542:	601a      	str	r2, [r3, #0]
      } /* End of " if(Status == DAVEApp_SUCCESS)"*/
    } /* End of " if(Status == DAVEApp_SUCCESS)"*/
  }/* End of "if(TimerId != 0)" */
}
 8008544:	f107 0710 	add.w	r7, r7, #16
 8008548:	46bd      	mov	sp, r7
 800854a:	bd80      	pop	{r7, pc}

0800854c <SDMMC0_0_IRQHandler>:

/* <<< DD_SDMMC_nonAPI_34 >>>
 *  SDMMC Interrupt Handler */
void SDMMC0_0_IRQHandler()
{
 800854c:	b580      	push	{r7, lr}
 800854e:	b082      	sub	sp, #8
 8008550:	af00      	add	r7, sp, #0
  uint32_t Status;
  NormalIntStatus = SDMMC->INT_STATUS_NORM;
 8008552:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008556:	f6c4 0301 	movt	r3, #18433	; 0x4801
 800855a:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 800855c:	b29a      	uxth	r2, r3
 800855e:	f246 4324 	movw	r3, #25636	; 0x6424
 8008562:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008566:	801a      	strh	r2, [r3, #0]
  ErrorIntStatus  = SDMMC->INT_STATUS_ERR;
 8008568:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800856c:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008570:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8008572:	b29a      	uxth	r2, r3
 8008574:	f246 4332 	movw	r3, #25650	; 0x6432
 8008578:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800857c:	801a      	strh	r2, [r3, #0]
/* <<< DD_SDMMC_nonAPI_34_1 >>> */
  if (NormalIntStatus & SDMMC_INT_STATUS_NORM_ERR_INT_Msk)
 800857e:	f246 4324 	movw	r3, #25636	; 0x6424
 8008582:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008586:	881b      	ldrh	r3, [r3, #0]
 8008588:	b29b      	uxth	r3, r3
 800858a:	b29b      	uxth	r3, r3
 800858c:	b21b      	sxth	r3, r3
 800858e:	2b00      	cmp	r3, #0
 8008590:	da09      	bge.n	80085a6 <SDMMC0_0_IRQHandler+0x5a>
  {
    Status = SDMMC003_lErrorInterruptHandler( ErrorIntStatus );
 8008592:	f246 4332 	movw	r3, #25650	; 0x6432
 8008596:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800859a:	881b      	ldrh	r3, [r3, #0]
 800859c:	b29b      	uxth	r3, r3
 800859e:	4618      	mov	r0, r3
 80085a0:	f7ff fcaa 	bl	8007ef8 <SDMMC003_lErrorInterruptHandler>
 80085a4:	6078      	str	r0, [r7, #4]
    {
      ERROR(GID_SDMMC00x, Status,0,0);
    }
  }
/* <<< DD_SDMMC_nonAPI_34_2 >>> */
  if(NormalIntStatus & SDMMC003_NORMAL_INT_STATUS_BITS)
 80085a6:	f246 4324 	movw	r3, #25636	; 0x6424
 80085aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80085ae:	881b      	ldrh	r3, [r3, #0]
 80085b0:	b29b      	uxth	r3, r3
 80085b2:	ea4f 4343 	mov.w	r3, r3, lsl #17
 80085b6:	ea4f 4353 	mov.w	r3, r3, lsr #17
 80085ba:	2b00      	cmp	r3, #0
 80085bc:	d009      	beq.n	80085d2 <SDMMC0_0_IRQHandler+0x86>
  {
    Status = SDMMC003_lNormalInterruptHandler( NormalIntStatus);
 80085be:	f246 4324 	movw	r3, #25636	; 0x6424
 80085c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80085c6:	881b      	ldrh	r3, [r3, #0]
 80085c8:	b29b      	uxth	r3, r3
 80085ca:	4618      	mov	r0, r3
 80085cc:	f7ff fc00 	bl	8007dd0 <SDMMC003_lNormalInterruptHandler>
 80085d0:	6078      	str	r0, [r7, #4]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      ERROR(GID_SDMMC00x, Status,0,0);
    }
  }
}
 80085d2:	f107 0708 	add.w	r7, r7, #8
 80085d6:	46bd      	mov	sp, r7
 80085d8:	bd80      	pop	{r7, pc}
 80085da:	bf00      	nop

080085dc <SDMMC003_lCardIdentificationProcess>:
/* <<< DD_SDMMC_nonAPI_36 >>> */
/*
 * This function performs the card initialization and identification operation.
 */
status_t SDMMC003_lCardIdentificationProcess()
{
 80085dc:	b580      	push	{r7, lr}
 80085de:	b082      	sub	sp, #8
 80085e0:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)SDMMC003_ERROR;
 80085e2:	f04f 0301 	mov.w	r3, #1
 80085e6:	607b      	str	r3, [r7, #4]
  handle_t TimerId = 0;
 80085e8:	f04f 0300 	mov.w	r3, #0
 80085ec:	603b      	str	r3, [r7, #0]
  /* Silicon Testing Added */
  do
  {
/* <<< DD_SDMMC_nonAPI_36_1 >>> */
   /* Wait till the Internal clock gets Stable.*/
    TimerId = SDMMC003_lStartTimer(SDMMC003_CLOCK_STABLE_DELAY);
 80085ee:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80085f2:	f000 f85f 	bl	80086b4 <SDMMC003_lStartTimer>
 80085f6:	6038      	str	r0, [r7, #0]
    if(0 == TimerId)
 80085f8:	683b      	ldr	r3, [r7, #0]
 80085fa:	2b00      	cmp	r3, #0
 80085fc:	d103      	bne.n	8008606 <SDMMC003_lCardIdentificationProcess+0x2a>
    {
      Status = (uint32_t) SDMMC003_START_TIMER_FAILED;
 80085fe:	f04f 032f 	mov.w	r3, #47	; 0x2f
 8008602:	607b      	str	r3, [r7, #4]
      ERROR(GID_SDMMC00x, Status, 0, NULL);  
      break; 
 8008604:	e050      	b.n	80086a8 <SDMMC003_lCardIdentificationProcess+0xcc>
    }
    do
    {
      if (SDMMC003_Handle.TimerExpire == 0)
 8008606:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800860a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800860e:	7a9b      	ldrb	r3, [r3, #10]
 8008610:	b2db      	uxtb	r3, r3
 8008612:	2b00      	cmp	r3, #0
 8008614:	d103      	bne.n	800861e <SDMMC003_lCardIdentificationProcess+0x42>
      {
        Status = (uint32_t)SDMMC003_TIMEOUT_OCCURED;
 8008616:	f04f 032e 	mov.w	r3, #46	; 0x2e
 800861a:	607b      	str	r3, [r7, #4]
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 800861c:	e009      	b.n	8008632 <SDMMC003_lCardIdentificationProcess+0x56>
      }
    } while((SDMMC->CLOCK_CTRL & SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_STABLE_Msk ) == 0);
 800861e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008622:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008626:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8008628:	b29b      	uxth	r3, r3
 800862a:	f003 0302 	and.w	r3, r3, #2
 800862e:	2b00      	cmp	r3, #0
 8008630:	d0e9      	beq.n	8008606 <SDMMC003_lCardIdentificationProcess+0x2a>
    SDMMC003_lStopTimer(TimerId);    
 8008632:	6838      	ldr	r0, [r7, #0]
 8008634:	f000 f872 	bl	800871c <SDMMC003_lStopTimer>
    if (Status == (uint32_t)SDMMC003_TIMEOUT_OCCURED )
 8008638:	687b      	ldr	r3, [r7, #4]
 800863a:	2b2e      	cmp	r3, #46	; 0x2e
 800863c:	d031      	beq.n	80086a2 <SDMMC003_lCardIdentificationProcess+0xc6>
    {
      break; 
    }
    /* Enable the SD clock */
    SDMMC->CLOCK_CTRL |= SDMMC_CLOCK_CTRL_SDCLOCK_EN_Msk;
 800863e:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008642:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008646:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800864a:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800864e:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
 8008650:	b292      	uxth	r2, r2
 8008652:	f042 0204 	orr.w	r2, r2, #4
 8008656:	b292      	uxth	r2, r2
 8008658:	859a      	strh	r2, [r3, #44]	; 0x2c
    /* Set Power Control Register */
    SET_BIT( SDMMC->POWER_CTRL, SDMMC_POWER_CTRL_SD_BUS_POWER_Pos);
 800865a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800865e:	f6c4 0301 	movt	r3, #18433	; 0x4801
 8008662:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8008666:	f6c4 0201 	movt	r2, #18433	; 0x4801
 800866a:	f892 2029 	ldrb.w	r2, [r2, #41]	; 0x29
 800866e:	b2d2      	uxtb	r2, r2
 8008670:	f042 0201 	orr.w	r2, r2, #1
 8008674:	b2d2      	uxtb	r2, r2
 8008676:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
/* <<< DD_SDMMC_nonAPI_36_2 >>> */    
    if(SDMMC003_Handle.InitializeFlag == 0)
 800867a:	f640 53c0 	movw	r3, #3520	; 0xdc0
 800867e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008682:	7a1b      	ldrb	r3, [r3, #8]
 8008684:	b2db      	uxtb	r3, r3
 8008686:	2b00      	cmp	r3, #0
 8008688:	d10e      	bne.n	80086a8 <SDMMC003_lCardIdentificationProcess+0xcc>
    {
      Status  = SDMMC003_lInitializeCard();
 800868a:	f7fe fdc5 	bl	8007218 <SDMMC003_lInitializeCard>
 800868e:	6078      	str	r0, [r7, #4]
/* <<< DD_SDMMC_nonAPI_36_3 >>> */    
      if( Status != (uint32_t)DAVEApp_SUCCESS )
 8008690:	687b      	ldr	r3, [r7, #4]
 8008692:	2b00      	cmp	r3, #0
 8008694:	d107      	bne.n	80086a6 <SDMMC003_lCardIdentificationProcess+0xca>
      {
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
      }/* End of " if( Status != DAVEApp_SUCCESS )"*/
      Status = SDMMC003_lAfterCardInitialize();
 8008696:	f7fe fd7b 	bl	8007190 <SDMMC003_lAfterCardInitialize>
 800869a:	6078      	str	r0, [r7, #4]
/* <<< DD_SDMMC_nonAPI_36_4 >>> */  
      if( Status != (uint32_t)DAVEApp_SUCCESS )
 800869c:	687b      	ldr	r3, [r7, #4]
 800869e:	2b00      	cmp	r3, #0
 80086a0:	e002      	b.n	80086a8 <SDMMC003_lCardIdentificationProcess+0xcc>
      }
    } while((SDMMC->CLOCK_CTRL & SDMMC_CLOCK_CTRL_INTERNAL_CLOCK_STABLE_Msk ) == 0);
    SDMMC003_lStopTimer(TimerId);    
    if (Status == (uint32_t)SDMMC003_TIMEOUT_OCCURED )
    {
      break; 
 80086a2:	bf00      	nop
 80086a4:	e000      	b.n	80086a8 <SDMMC003_lCardIdentificationProcess+0xcc>
      Status  = SDMMC003_lInitializeCard();
/* <<< DD_SDMMC_nonAPI_36_3 >>> */    
      if( Status != (uint32_t)DAVEApp_SUCCESS )
      {
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
 80086a6:	bf00      	nop
        ERROR(GID_SDMMC00x, Status, 0, NULL);
        break;
      }/* End of "if(Status != DAVEApp_SUCCESS )" */
    }/* End of "if((SDMMC003_Handle.State & SDMMC003_STATE_CARD_INITIALIZED)== 0 )"*/
  } while(0);
  return Status;
 80086a8:	687b      	ldr	r3, [r7, #4]
}
 80086aa:	4618      	mov	r0, r3
 80086ac:	f107 0708 	add.w	r7, r7, #8
 80086b0:	46bd      	mov	sp, r7
 80086b2:	bd80      	pop	{r7, pc}

080086b4 <SDMMC003_lStartTimer>:
/* <<< DD_SDMMC_nonAPI_37 >>> */
/**
 * This function is used to create and start timer in NON-RTOS environment.
 */
handle_t SDMMC003_lStartTimer(uint32_t DelayTime)
{
 80086b4:	b580      	push	{r7, lr}
 80086b6:	b084      	sub	sp, #16
 80086b8:	af00      	add	r7, sp, #0
 80086ba:	6078      	str	r0, [r7, #4]
  handle_t TimerId;
  status_t Status;
  SDMMC003_Handle.TimerExpire = 1;
 80086bc:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80086c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80086c4:	f04f 0201 	mov.w	r2, #1
 80086c8:	729a      	strb	r2, [r3, #10]
  TimerId = SYSTM001_CreateTimer(DelayTime,SYSTM001_ONE_SHOT,Timer_CallBack,NULL);
 80086ca:	6878      	ldr	r0, [r7, #4]
 80086cc:	f04f 0100 	mov.w	r1, #0
 80086d0:	f248 429d 	movw	r2, #33949	; 0x849d
 80086d4:	f6c0 0200 	movt	r2, #2048	; 0x800
 80086d8:	f04f 0300 	mov.w	r3, #0
 80086dc:	f7fb fe00 	bl	80042e0 <SYSTM001_CreateTimer>
 80086e0:	60f8      	str	r0, [r7, #12]
/* <<< DD_SDMMC_nonAPI_37_1 >>> */
  if(TimerId != 0)
 80086e2:	68fb      	ldr	r3, [r7, #12]
 80086e4:	2b00      	cmp	r3, #0
 80086e6:	d012      	beq.n	800870e <SDMMC003_lStartTimer+0x5a>
  {
    /* Timer is created successfully */
    Status = SYSTM001_StartTimer(TimerId);
 80086e8:	68f8      	ldr	r0, [r7, #12]
 80086ea:	f7fb fec9 	bl	8004480 <SYSTM001_StartTimer>
 80086ee:	60b8      	str	r0, [r7, #8]
/* <<< DD_SDMMC_nonAPI_37_2 >>> */
    if(DAVEApp_SUCCESS != Status)
 80086f0:	68bb      	ldr	r3, [r7, #8]
 80086f2:	2b00      	cmp	r3, #0
 80086f4:	d00b      	beq.n	800870e <SDMMC003_lStartTimer+0x5a>
    {
      /*Delete Timer*/
      SDMMC003_ReturnStatus = SYSTM001_DeleteTimer(TimerId);
 80086f6:	68f8      	ldr	r0, [r7, #12]
 80086f8:	f7fb ff64 	bl	80045c4 <SYSTM001_DeleteTimer>
 80086fc:	4602      	mov	r2, r0
 80086fe:	f246 4328 	movw	r3, #25640	; 0x6428
 8008702:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008706:	601a      	str	r2, [r3, #0]
      TimerId = 0;
 8008708:	f04f 0300 	mov.w	r3, #0
 800870c:	60fb      	str	r3, [r7, #12]
    }
  }
  return TimerId;
 800870e:	68fb      	ldr	r3, [r7, #12]
}
 8008710:	4618      	mov	r0, r3
 8008712:	f107 0710 	add.w	r7, r7, #16
 8008716:	46bd      	mov	sp, r7
 8008718:	bd80      	pop	{r7, pc}
 800871a:	bf00      	nop

0800871c <SDMMC003_lStopTimer>:
/* <<< DD_SDMMC_nonAPI_38 >>> */
/**
 * This function is used to stop timer in NON-RTOS environment.
 */
void SDMMC003_lStopTimer(handle_t TimerId)
{
 800871c:	b580      	push	{r7, lr}
 800871e:	b084      	sub	sp, #16
 8008720:	af00      	add	r7, sp, #0
 8008722:	6078      	str	r0, [r7, #4]
  status_t Status;
  /* stop the timer */
  Status = SYSTM001_StopTimer(TimerId);
 8008724:	6878      	ldr	r0, [r7, #4]
 8008726:	f7fb ff05 	bl	8004534 <SYSTM001_StopTimer>
 800872a:	60f8      	str	r0, [r7, #12]
  /* Delete the Timer*/
/* <<< DD_SDMMC_nonAPI_38_1 >>> */
  if(Status == DAVEApp_SUCCESS)
 800872c:	68fb      	ldr	r3, [r7, #12]
 800872e:	2b00      	cmp	r3, #0
 8008730:	d108      	bne.n	8008744 <SDMMC003_lStopTimer+0x28>
  {
    SDMMC003_ReturnStatus = SYSTM001_DeleteTimer(TimerId);
 8008732:	6878      	ldr	r0, [r7, #4]
 8008734:	f7fb ff46 	bl	80045c4 <SYSTM001_DeleteTimer>
 8008738:	4602      	mov	r2, r0
 800873a:	f246 4328 	movw	r3, #25640	; 0x6428
 800873e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008742:	601a      	str	r2, [r3, #0]
  }
}
 8008744:	f107 0710 	add.w	r7, r7, #16
 8008748:	46bd      	mov	sp, r7
 800874a:	bd80      	pop	{r7, pc}

0800874c <SDMMC003_lCheckSectorBound>:
/**
 * This function is used to check the sector address is out of bound or not.
 */
status_t SDMMC003_lCheckSectorBound (uint32_t SectorNumberParam, \
                                     uint32_t SectorCountParam)
{
 800874c:	b580      	push	{r7, lr}
 800874e:	b084      	sub	sp, #16
 8008750:	af00      	add	r7, sp, #0
 8008752:	6078      	str	r0, [r7, #4]
 8008754:	6039      	str	r1, [r7, #0]
  status_t Status;
  uint32_t SectorCount = 0;
 8008756:	f04f 0300 	mov.w	r3, #0
 800875a:	60bb      	str	r3, [r7, #8]
  do
  {
/* Get Sector Count function   */  
/* <<< DD_SDMMC_nonAPI_39_1 >>> */
    Status = SDMMC003_GetSectorCount((void *)&SectorCount);
 800875c:	f107 0308 	add.w	r3, r7, #8
 8008760:	4618      	mov	r0, r3
 8008762:	f7fd fe1b 	bl	800639c <SDMMC003_GetSectorCount>
 8008766:	60f8      	str	r0, [r7, #12]
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 8008768:	68fb      	ldr	r3, [r7, #12]
 800876a:	2b00      	cmp	r3, #0
 800876c:	d109      	bne.n	8008782 <SDMMC003_lCheckSectorBound+0x36>
    {
      break;
    }
/* <<< DD_SDMMC_nonAPI_39_2 >>> */
/* Check the Sector Count limit */
    if((SectorNumberParam + SectorCountParam) >= SectorCount)
 800876e:	687a      	ldr	r2, [r7, #4]
 8008770:	683b      	ldr	r3, [r7, #0]
 8008772:	18d2      	adds	r2, r2, r3
 8008774:	68bb      	ldr	r3, [r7, #8]
 8008776:	429a      	cmp	r2, r3
 8008778:	d304      	bcc.n	8008784 <SDMMC003_lCheckSectorBound+0x38>
    {
      Status = (uint32_t)SDMMC003_SECTOR_OUT_OF_BOUND;
 800877a:	f04f 0330 	mov.w	r3, #48	; 0x30
 800877e:	60fb      	str	r3, [r7, #12]
 8008780:	e000      	b.n	8008784 <SDMMC003_lCheckSectorBound+0x38>
/* Get Sector Count function   */  
/* <<< DD_SDMMC_nonAPI_39_1 >>> */
    Status = SDMMC003_GetSectorCount((void *)&SectorCount);
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      break;
 8008782:	bf00      	nop
    if((SectorNumberParam + SectorCountParam) >= SectorCount)
    {
      Status = (uint32_t)SDMMC003_SECTOR_OUT_OF_BOUND;
    }
  } while(0);
  return Status;
 8008784:	68fb      	ldr	r3, [r7, #12]
}
 8008786:	4618      	mov	r0, r3
 8008788:	f107 0710 	add.w	r7, r7, #16
 800878c:	46bd      	mov	sp, r7
 800878e:	bd80      	pop	{r7, pc}

08008790 <SDMMC003_lLocalErase>:
(
  uint32_t StartAddr,
  uint32_t EndAddr,
  uint32_t TimeoutVal
)
{
 8008790:	b580      	push	{r7, lr}
 8008792:	b086      	sub	sp, #24
 8008794:	af00      	add	r7, sp, #0
 8008796:	60f8      	str	r0, [r7, #12]
 8008798:	60b9      	str	r1, [r7, #8]
 800879a:	607a      	str	r2, [r7, #4]
  /* Stores the response received  */
  uint32_t CardStatus = 0;
 800879c:	f04f 0300 	mov.w	r3, #0
 80087a0:	613b      	str	r3, [r7, #16]
  status_t Status = (uint32_t)SDMMC003_ERROR;
 80087a2:	f04f 0301 	mov.w	r3, #1
 80087a6:	617b      	str	r3, [r7, #20]
  do
  {
  /* <<<DD_SDMMC_API_7_3>>> */
    if ((SDMMC003_Handle.CardType & SDMMC003_BLOCK_ADDRESSING) == 0UL)
 80087a8:	f640 53c0 	movw	r3, #3520	; 0xdc0
 80087ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80087b0:	789b      	ldrb	r3, [r3, #2]
 80087b2:	b2db      	uxtb	r3, r3
 80087b4:	f003 0308 	and.w	r3, r3, #8
 80087b8:	2b00      	cmp	r3, #0
 80087ba:	d107      	bne.n	80087cc <SDMMC003_lLocalErase+0x3c>
    {
      StartAddr *= 512UL;
 80087bc:	68fb      	ldr	r3, [r7, #12]
 80087be:	ea4f 2343 	mov.w	r3, r3, lsl #9
 80087c2:	60fb      	str	r3, [r7, #12]
      EndAddr *=  512UL;
 80087c4:	68bb      	ldr	r3, [r7, #8]
 80087c6:	ea4f 2343 	mov.w	r3, r3, lsl #9
 80087ca:	60bb      	str	r3, [r7, #8]
        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
      }
#endif
/* <<<DD_SDMMC_API_7_7>>> */
      /* SD Erase Start Command */
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(32)), \
 80087cc:	f246 6304 	movw	r3, #26116	; 0x6604
 80087d0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80087d4:	f893 3020 	ldrb.w	r3, [r3, #32]
 80087d8:	ea4f 0243 	mov.w	r2, r3, lsl #1
 80087dc:	f246 53b4 	movw	r3, #26036	; 0x65b4
 80087e0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80087e4:	18d2      	adds	r2, r2, r3
                                              StartAddr, SDMMC003_RESPONSE_R1, &CardStatus);
 80087e6:	f107 0310 	add.w	r3, r7, #16
        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
      }
#endif
/* <<<DD_SDMMC_API_7_7>>> */
      /* SD Erase Start Command */
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(32)), \
 80087ea:	4610      	mov	r0, r2
 80087ec:	68f9      	ldr	r1, [r7, #12]
 80087ee:	f04f 0201 	mov.w	r2, #1
 80087f2:	f7fe faf9 	bl	8006de8 <SDMMC003_lSendCommand>
 80087f6:	6178      	str	r0, [r7, #20]
                                              StartAddr, SDMMC003_RESPONSE_R1, &CardStatus);
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 80087f8:	697b      	ldr	r3, [r7, #20]
 80087fa:	2b00      	cmp	r3, #0
 80087fc:	d13b      	bne.n	8008876 <SDMMC003_lLocalErase+0xe6>
        SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);
        /* Disable the Command Complete Signal Interrupt */
        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
      }
#endif
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(33)),EndAddr, \
 80087fe:	f246 6304 	movw	r3, #26116	; 0x6604
 8008802:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008806:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800880a:	ea4f 0243 	mov.w	r2, r3, lsl #1
 800880e:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8008812:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008816:	18d2      	adds	r2, r2, r3
                                      SDMMC003_RESPONSE_R1, &CardStatus);
 8008818:	f107 0310 	add.w	r3, r7, #16
        SDMMC->EN_INT_STATUS_NORM &= ~( SDMMC_EN_INT_STATUS_NORM_CMD_COMPLETE_EN_Msk);
        /* Disable the Command Complete Signal Interrupt */
        SDMMC->EN_INT_SIGNAL_NORM &= ~( SDMMC_EN_INT_SIGNAL_NORM_CMD_COMPLETE_EN_Msk );
      }
#endif
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(33)),EndAddr, \
 800881c:	4610      	mov	r0, r2
 800881e:	68b9      	ldr	r1, [r7, #8]
 8008820:	f04f 0201 	mov.w	r2, #1
 8008824:	f7fe fae0 	bl	8006de8 <SDMMC003_lSendCommand>
 8008828:	6178      	str	r0, [r7, #20]
                                      SDMMC003_RESPONSE_R1, &CardStatus);
/* <<<DD_SDMMC_API_7_8>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
 800882a:	697b      	ldr	r3, [r7, #20]
 800882c:	2b00      	cmp	r3, #0
 800882e:	d124      	bne.n	800887a <SDMMC003_lLocalErase+0xea>
      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);
      /* Disable the Transfer Complete Signal Interrupt */
      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk  );
    }
#endif
    Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(38)),
 8008830:	f246 6304 	movw	r3, #26116	; 0x6604
 8008834:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008838:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 800883c:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8008840:	f246 53b4 	movw	r3, #26036	; 0x65b4
 8008844:	f6c0 0302 	movt	r3, #2050	; 0x802
 8008848:	18d2      	adds	r2, r2, r3
                                    SDMMC003_ARGUMENT0,
                                    SDMMC003_RESPONSE_R1b,
                                    &CardStatus);   
 800884a:	f107 0310 	add.w	r3, r7, #16
      SDMMC->EN_INT_STATUS_NORM &= ~(SDMMC_EN_INT_STATUS_NORM_TX_COMPLETE_EN_Msk);
      /* Disable the Transfer Complete Signal Interrupt */
      SDMMC->EN_INT_SIGNAL_NORM &= ~(SDMMC_EN_INT_SIGNAL_NORM_TX_COMPLETE_EN_Msk  );
    }
#endif
    Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(38)),
 800884e:	4610      	mov	r0, r2
 8008850:	f04f 0100 	mov.w	r1, #0
 8008854:	f04f 0202 	mov.w	r2, #2
 8008858:	f7fe fac6 	bl	8006de8 <SDMMC003_lSendCommand>
 800885c:	6178      	str	r0, [r7, #20]
                                    SDMMC003_ARGUMENT0,
                                    SDMMC003_RESPONSE_R1b,
                                    &CardStatus);   
    if (Status != (uint32_t)DAVEApp_SUCCESS)
 800885e:	697b      	ldr	r3, [r7, #20]
 8008860:	2b00      	cmp	r3, #0
 8008862:	d10c      	bne.n	800887e <SDMMC003_lLocalErase+0xee>
    {
       break;
    }/* End of " if (Status != (uint32_t)DAVEApp_SUCCESS)"*/
    SDMMC003_lDelay(TimeoutVal * 1000);
 8008864:	687b      	ldr	r3, [r7, #4]
 8008866:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800886a:	fb02 f303 	mul.w	r3, r2, r3
 800886e:	4618      	mov	r0, r3
 8008870:	f7ff fe2e 	bl	80084d0 <SDMMC003_lDelay>
 8008874:	e004      	b.n	8008880 <SDMMC003_lLocalErase+0xf0>
      /* SD Erase Start Command */
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(32)), \
                                              StartAddr, SDMMC003_RESPONSE_R1, &CardStatus);
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
         break;
 8008876:	bf00      	nop
 8008878:	e002      	b.n	8008880 <SDMMC003_lLocalErase+0xf0>
      Status = SDMMC003_lSendCommand( &(SDMMC003_SD_COMMAND(33)),EndAddr, \
                                      SDMMC003_RESPONSE_R1, &CardStatus);
/* <<<DD_SDMMC_API_7_8>>> */
      if (Status != (uint32_t)DAVEApp_SUCCESS)
      {
         break;
 800887a:	bf00      	nop
 800887c:	e000      	b.n	8008880 <SDMMC003_lLocalErase+0xf0>
                                    SDMMC003_ARGUMENT0,
                                    SDMMC003_RESPONSE_R1b,
                                    &CardStatus);   
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
       break;
 800887e:	bf00      	nop
    }/* End of " if (Status != (uint32_t)DAVEApp_SUCCESS)"*/
    SDMMC003_lDelay(TimeoutVal * 1000);
  } while(0);
  return Status;
 8008880:	697b      	ldr	r3, [r7, #20]
}
 8008882:	4618      	mov	r0, r3
 8008884:	f107 0718 	add.w	r7, r7, #24
 8008888:	46bd      	mov	sp, r7
 800888a:	bd80      	pop	{r7, pc}

0800888c <SDMMC001_lFindDiskStatus>:
/*******************************************************************************
**                     Private Function Definitions                           **
*******************************************************************************/
/*<<<DD_SDMMC001_nonAPI_1>>>*/
uint8_t SDMMC001_lFindDiskStatus()
{
 800888c:	b580      	push	{r7, lr}
 800888e:	b082      	sub	sp, #8
 8008890:	af00      	add	r7, sp, #0
  status_t Status;
  uint8_t DiskStatus = 0;
 8008892:	f04f 0300 	mov.w	r3, #0
 8008896:	71fb      	strb	r3, [r7, #7]
/* Get the Status Information */
  do
  {
 /* Get the Current State information . */
    Status = SDMMC003_GetCurrentState();
 8008898:	f7fd fc3c 	bl	8006114 <SDMMC003_GetCurrentState>
 800889c:	6038      	str	r0, [r7, #0]
/*<<<DD_SDMMC001_nonAPI_1_1>>>*/
    if (Status & (uint32_t)SDMMC003_STATE_NO_CARD )
 800889e:	683b      	ldr	r3, [r7, #0]
 80088a0:	f003 0302 	and.w	r3, r3, #2
 80088a4:	2b00      	cmp	r3, #0
 80088a6:	d003      	beq.n	80088b0 <SDMMC001_lFindDiskStatus+0x24>
    {
      DiskStatus = (SDMMC001_STA_NOINIT | SDMMC001_STA_NODISK);
 80088a8:	f04f 0303 	mov.w	r3, #3
 80088ac:	71fb      	strb	r3, [r7, #7]
      break;
 80088ae:	e023      	b.n	80088f8 <SDMMC001_lFindDiskStatus+0x6c>
    }/* End of "if ((Status & SDMMC003_STATE_CARD_INSERTED) == 0)"		*/
/*<<<DD_SDMMC001_nonAPI_1_2>>>*/
    if ((Status & (uint32_t)SDMMC003_STATE_CARD_INITIALIZED) == 0)
 80088b0:	683b      	ldr	r3, [r7, #0]
 80088b2:	f003 0301 	and.w	r3, r3, #1
 80088b6:	2b00      	cmp	r3, #0
 80088b8:	d104      	bne.n	80088c4 <SDMMC001_lFindDiskStatus+0x38>
    {
      DiskStatus |= SDMMC001_STA_NOINIT;
 80088ba:	79fb      	ldrb	r3, [r7, #7]
 80088bc:	f043 0301 	orr.w	r3, r3, #1
 80088c0:	71fb      	strb	r3, [r7, #7]
      break;
 80088c2:	e019      	b.n	80088f8 <SDMMC001_lFindDiskStatus+0x6c>
    }/* End of "if ((Status & SDMMC003_STATE_CARD_INITIALIZED) == 0)"	*/
    if (( Status & (uint32_t)SDMMC003_STATE_CARD_LOCKED) != 0 )
 80088c4:	683b      	ldr	r3, [r7, #0]
 80088c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80088ca:	2b00      	cmp	r3, #0
 80088cc:	d00b      	beq.n	80088e6 <SDMMC001_lFindDiskStatus+0x5a>
    {
      SDMMC001_LockFlag = 1;
 80088ce:	f640 53cd 	movw	r3, #3533	; 0xdcd
 80088d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80088d6:	f04f 0201 	mov.w	r2, #1
 80088da:	701a      	strb	r2, [r3, #0]
      DiskStatus |= SDMMC001_STA_NOINIT;
 80088dc:	79fb      	ldrb	r3, [r7, #7]
 80088de:	f043 0301 	orr.w	r3, r3, #1
 80088e2:	71fb      	strb	r3, [r7, #7]
      break;
 80088e4:	e008      	b.n	80088f8 <SDMMC001_lFindDiskStatus+0x6c>
    }/* End of "if ((Status & (uint32_t)SDMMC003_STATE_CARD_LOCKED) == 0)" */
/*<<<DD_SDMMC001_nonAPI_1_3>>>*/
    if ((Status & (uint32_t)SDMMC003_STATE_CARD_WRITE_PROTECT) != 0)
 80088e6:	683b      	ldr	r3, [r7, #0]
 80088e8:	f003 0310 	and.w	r3, r3, #16
 80088ec:	2b00      	cmp	r3, #0
 80088ee:	d003      	beq.n	80088f8 <SDMMC001_lFindDiskStatus+0x6c>
    {
      DiskStatus |= SDMMC001_STA_PROTECT;
 80088f0:	79fb      	ldrb	r3, [r7, #7]
 80088f2:	f043 0304 	orr.w	r3, r3, #4
 80088f6:	71fb      	strb	r3, [r7, #7]
    }/* End of "if ((Status & SDMMC003_STATE_CARD_WRITE_PROTECT) != 0)"	*/
  } while(0);
  return DiskStatus;
 80088f8:	79fb      	ldrb	r3, [r7, #7]
}
 80088fa:	4618      	mov	r0, r3
 80088fc:	f107 0708 	add.w	r7, r7, #8
 8008900:	46bd      	mov	sp, r7
 8008902:	bd80      	pop	{r7, pc}

08008904 <SDMMC001_Initialize>:
/*<<<DD_SDMMC001_API_1>>>*/
/*
 * The function checks and returns the initialization status of the card .
 */
uint8_t SDMMC001_Initialize(void)
{
 8008904:	b580      	push	{r7, lr}
 8008906:	b082      	sub	sp, #8
 8008908:	af00      	add	r7, sp, #0
      SDMMC001_InitializeFlag =1 ;
    }
#endif
    /* Check the device initialization status. If SDMMC device is
     * already initialized, Skip this step else initialize Sdmmc device */
    if ( SDMMC001_InitializeFlag == 0)
 800890a:	f640 53cc 	movw	r3, #3532	; 0xdcc
 800890e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008912:	781b      	ldrb	r3, [r3, #0]
 8008914:	2b00      	cmp	r3, #0
 8008916:	d124      	bne.n	8008962 <SDMMC001_Initialize+0x5e>
    {
      Status = SDMMC003_Start();
 8008918:	f7fd ff30 	bl	800677c <SDMMC003_Start>
 800891c:	6078      	str	r0, [r7, #4]
      if ( (Status != (uint32_t)DAVEApp_SUCCESS) &&  \
 800891e:	687b      	ldr	r3, [r7, #4]
 8008920:	2b00      	cmp	r3, #0
 8008922:	d002      	beq.n	800892a <SDMMC001_Initialize+0x26>
 8008924:	687b      	ldr	r3, [r7, #4]
 8008926:	2b2c      	cmp	r3, #44	; 0x2c
 8008928:	d118      	bne.n	800895c <SDMMC001_Initialize+0x58>
           (Status != (uint32_t)SDMMC003_HOST_CONTROLLER_INITIALIZED))
      {
        break;
      }
      Status = SDMMC003_CardDetectionSupport();
 800892a:	f7fd ff59 	bl	80067e0 <SDMMC003_CardDetectionSupport>
 800892e:	6078      	str	r0, [r7, #4]
      if (Status != (uint32_t)DAVEApp_SUCCESS )
 8008930:	687b      	ldr	r3, [r7, #4]
 8008932:	2b00      	cmp	r3, #0
 8008934:	d00a      	beq.n	800894c <SDMMC001_Initialize+0x48>
      {
        if (Status == (uint32_t)SDMMC003_INITIALIZED_BUT_LOCKED)
 8008936:	687b      	ldr	r3, [r7, #4]
 8008938:	2b2b      	cmp	r3, #43	; 0x2b
 800893a:	d111      	bne.n	8008960 <SDMMC001_Initialize+0x5c>
        {
          SDMMC001_LockFlag = 1;
 800893c:	f640 53cd 	movw	r3, #3533	; 0xdcd
 8008940:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008944:	f04f 0201 	mov.w	r2, #1
 8008948:	701a      	strb	r2, [r3, #0]
        }
        break;
 800894a:	e009      	b.n	8008960 <SDMMC001_Initialize+0x5c>
      }
      SDMMC001_InitializeFlag = 1; 
 800894c:	f640 53cc 	movw	r3, #3532	; 0xdcc
 8008950:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008954:	f04f 0201 	mov.w	r2, #1
 8008958:	701a      	strb	r2, [r3, #0]
 800895a:	e002      	b.n	8008962 <SDMMC001_Initialize+0x5e>
    {
      Status = SDMMC003_Start();
      if ( (Status != (uint32_t)DAVEApp_SUCCESS) &&  \
           (Status != (uint32_t)SDMMC003_HOST_CONTROLLER_INITIALIZED))
      {
        break;
 800895c:	bf00      	nop
 800895e:	e000      	b.n	8008962 <SDMMC001_Initialize+0x5e>
      {
        if (Status == (uint32_t)SDMMC003_INITIALIZED_BUT_LOCKED)
        {
          SDMMC001_LockFlag = 1;
        }
        break;
 8008960:	bf00      	nop
      }
      SDMMC001_InitializeFlag = 1; 
    }
  } while(0);
/* Debug Log Message */
  DiskStatus =  SDMMC001_lFindDiskStatus();
 8008962:	f7ff ff93 	bl	800888c <SDMMC001_lFindDiskStatus>
 8008966:	4603      	mov	r3, r0
 8008968:	70fb      	strb	r3, [r7, #3]
  ERROR(GID_SDMMC001,Status,0,0);
  FUNCTION_EXIT(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_EXIT);
  return DiskStatus;
 800896a:	78fb      	ldrb	r3, [r7, #3]
}
 800896c:	4618      	mov	r0, r3
 800896e:	f107 0708 	add.w	r7, r7, #8
 8008972:	46bd      	mov	sp, r7
 8008974:	bd80      	pop	{r7, pc}
 8008976:	bf00      	nop

08008978 <SDMMC001_GetStatus>:
/*
 * The function gets the status of the card whether the card is initialized,
 * inserted or write protected.
 */
uint8_t SDMMC001_GetStatus(void)
{
 8008978:	b580      	push	{r7, lr}
 800897a:	b082      	sub	sp, #8
 800897c:	af00      	add	r7, sp, #0
  uint8_t  DiskStatus;
  FUNCTION_ENTRY(GID_SDMMC001,(uint32_t)SDMMC001_FUNCTION_ENTRY);
  DiskStatus  = SDMMC001_Initialize();
 800897e:	f7ff ffc1 	bl	8008904 <SDMMC001_Initialize>
 8008982:	4603      	mov	r3, r0
 8008984:	71fb      	strb	r3, [r7, #7]
  FUNCTION_EXIT(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_EXIT);
  return DiskStatus;
 8008986:	79fb      	ldrb	r3, [r7, #7]
}
 8008988:	4618      	mov	r0, r3
 800898a:	f107 0708 	add.w	r7, r7, #8
 800898e:	46bd      	mov	sp, r7
 8008990:	bd80      	pop	{r7, pc}
 8008992:	bf00      	nop

08008994 <SDMMC001_ReadBlock>:
(
  uint8_t *ReadBuf,
  uint32_t SectorNumber,
  uint8_t  SectorCount
)
{
 8008994:	b580      	push	{r7, lr}
 8008996:	b088      	sub	sp, #32
 8008998:	af00      	add	r7, sp, #0
 800899a:	60f8      	str	r0, [r7, #12]
 800899c:	60b9      	str	r1, [r7, #8]
 800899e:	4613      	mov	r3, r2
 80089a0:	71fb      	strb	r3, [r7, #7]
  status_t Status;
  uint8_t DiskStatus;
  uint32_t Result;
  FUNCTION_ENTRY(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_ENTRY);
/* Check the status before reading data */
  DiskStatus = SDMMC001_GetStatus();
 80089a2:	f7ff ffe9 	bl	8008978 <SDMMC001_GetStatus>
 80089a6:	4603      	mov	r3, r0
 80089a8:	75fb      	strb	r3, [r7, #23]
/*<<<DD_SDMMC001_API_3_1>>>*/
  if ((DiskStatus & (uint8_t)SDMMC001_STA_NOINIT) != 0)
 80089aa:	7dfb      	ldrb	r3, [r7, #23]
 80089ac:	f003 0301 	and.w	r3, r3, #1
 80089b0:	2b00      	cmp	r3, #0
 80089b2:	d003      	beq.n	80089bc <SDMMC001_ReadBlock+0x28>
  {
    Result = SDMMC001_RES_NOTRDY;
 80089b4:	f04f 0303 	mov.w	r3, #3
 80089b8:	61bb      	str	r3, [r7, #24]
 80089ba:	e019      	b.n	80089f0 <SDMMC001_ReadBlock+0x5c>
  }
  else
  {
/*Check for single block read or multiple block read based on sector count */
/*<<<DD_SDMMC001_API_3_2>>>*/
    if (SectorCount == 1)
 80089bc:	79fb      	ldrb	r3, [r7, #7]
 80089be:	2b01      	cmp	r3, #1
 80089c0:	d105      	bne.n	80089ce <SDMMC001_ReadBlock+0x3a>
    {
      Status = SDMMC003_CardReadSingleBlock( (uint32_t *)ReadBuf, SectorNumber);
 80089c2:	68f8      	ldr	r0, [r7, #12]
 80089c4:	68b9      	ldr	r1, [r7, #8]
 80089c6:	f7fd f911 	bl	8005bec <SDMMC003_CardReadSingleBlock>
 80089ca:	61f8      	str	r0, [r7, #28]
 80089cc:	e006      	b.n	80089dc <SDMMC001_ReadBlock+0x48>
    }
/*<<<DD_SDMMC001_API_3_3>>>*/
    else
    {
      Status = SDMMC003_CardReadMultipleBlocks((uint32_t *)ReadBuf,SectorNumber, \
 80089ce:	79fb      	ldrb	r3, [r7, #7]
 80089d0:	68f8      	ldr	r0, [r7, #12]
 80089d2:	68b9      	ldr	r1, [r7, #8]
 80089d4:	461a      	mov	r2, r3
 80089d6:	f7fd f8a7 	bl	8005b28 <SDMMC003_CardReadMultipleBlocks>
 80089da:	61f8      	str	r0, [r7, #28]
                                                SectorCount);
    }/*End of "if (SectorCount == 1)"*/
/*<<<DD_SDMMC001_API_3_4>>>*/
    if (Status == (uint32_t)DAVEApp_SUCCESS)
 80089dc:	69fb      	ldr	r3, [r7, #28]
 80089de:	2b00      	cmp	r3, #0
 80089e0:	d103      	bne.n	80089ea <SDMMC001_ReadBlock+0x56>
    {
      Result = SDMMC001_RES_OK;
 80089e2:	f04f 0300 	mov.w	r3, #0
 80089e6:	61bb      	str	r3, [r7, #24]
 80089e8:	e002      	b.n	80089f0 <SDMMC001_ReadBlock+0x5c>
    }
/*<<<DD_SDMMC001_API_3_5>>>*/
    else
    {
      Result = SDMMC001_RES_ERROR;
 80089ea:	f04f 0301 	mov.w	r3, #1
 80089ee:	61bb      	str	r3, [r7, #24]
      ERROR(GID_SDMMC001,SDMMC001_SDMMC00x_ERROR,sizeof(int),Status);
    }/* End of "if (Status == (uint32_t)DAVEApp_SUCCESS)"*/
  }/* End of " if ((DiskStatus & (uint8_t)STA_NOINIT) != 0)"*/
  FUNCTION_EXIT(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_EXIT);
  return Result;
 80089f0:	69bb      	ldr	r3, [r7, #24]
}
 80089f2:	4618      	mov	r0, r3
 80089f4:	f107 0720 	add.w	r7, r7, #32
 80089f8:	46bd      	mov	sp, r7
 80089fa:	bd80      	pop	{r7, pc}

080089fc <SDMMC001_WriteBlock>:
(
  const uint8_t *WriteBuf,
  uint32_t SectorNumber,
  uint8_t SectorCount
)
{
 80089fc:	b580      	push	{r7, lr}
 80089fe:	b088      	sub	sp, #32
 8008a00:	af00      	add	r7, sp, #0
 8008a02:	60f8      	str	r0, [r7, #12]
 8008a04:	60b9      	str	r1, [r7, #8]
 8008a06:	4613      	mov	r3, r2
 8008a08:	71fb      	strb	r3, [r7, #7]
  uint32_t Result;
  FUNCTION_ENTRY(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_ENTRY);

  do
  {
    DiskStatus = SDMMC001_GetStatus ();
 8008a0a:	f7ff ffb5 	bl	8008978 <SDMMC001_GetStatus>
 8008a0e:	4603      	mov	r3, r0
 8008a10:	75fb      	strb	r3, [r7, #23]
/*<<<DD_SDMMC001_API_4_1>>>*/
/* If the card is not initialized */
    if ((DiskStatus & SDMMC001_STA_NOINIT) != 0)
 8008a12:	7dfb      	ldrb	r3, [r7, #23]
 8008a14:	f003 0301 	and.w	r3, r3, #1
 8008a18:	2b00      	cmp	r3, #0
 8008a1a:	d003      	beq.n	8008a24 <SDMMC001_WriteBlock+0x28>
    {
      Result = SDMMC001_RES_NOTRDY;
 8008a1c:	f04f 0303 	mov.w	r3, #3
 8008a20:	61bb      	str	r3, [r7, #24]
      ERROR(GID_SDMMC001,Result,0,0);
      break;
 8008a22:	e022      	b.n	8008a6a <SDMMC001_WriteBlock+0x6e>
    }/* End of "if ((DiskStatus & SDMMC001_STA_NOINIT) != 0)"*/
/* If the card is read only or write protected */
/*<<<DD_SDMMC001_API_4_2>>>*/
    if ((DiskStatus & SDMMC001_STA_PROTECT) != 0)
 8008a24:	7dfb      	ldrb	r3, [r7, #23]
 8008a26:	f003 0304 	and.w	r3, r3, #4
 8008a2a:	2b00      	cmp	r3, #0
 8008a2c:	d003      	beq.n	8008a36 <SDMMC001_WriteBlock+0x3a>
    {
      Result = SDMMC001_RES_WRPRT;
 8008a2e:	f04f 0302 	mov.w	r3, #2
 8008a32:	61bb      	str	r3, [r7, #24]
      ERROR(GID_SDMMC001,Result,0,0);
      break;
 8008a34:	e019      	b.n	8008a6a <SDMMC001_WriteBlock+0x6e>
    }/* End of "if ((DiskStatus & SDMMC001_STA_PROTECT) != 0)"*/
/*Check for single block write or multiple block write.*/
/*<<<DD_SDMMC001_API_4_3>>>*/
    if (SectorCount == 1)
 8008a36:	79fb      	ldrb	r3, [r7, #7]
 8008a38:	2b01      	cmp	r3, #1
 8008a3a:	d105      	bne.n	8008a48 <SDMMC001_WriteBlock+0x4c>
    {
      Status = SDMMC003_CardWriteSingleBlock((uint32_t *)WriteBuf, SectorNumber);
 8008a3c:	68f8      	ldr	r0, [r7, #12]
 8008a3e:	68b9      	ldr	r1, [r7, #8]
 8008a40:	f7fd f990 	bl	8005d64 <SDMMC003_CardWriteSingleBlock>
 8008a44:	61f8      	str	r0, [r7, #28]
 8008a46:	e006      	b.n	8008a56 <SDMMC001_WriteBlock+0x5a>
    }
/*<<<DD_SDMMC001_API_4_4>>>*/
    else
    {
      Status = SDMMC003_CardWriteMultipleBlocks((uint32_t *)WriteBuf,\
 8008a48:	79fb      	ldrb	r3, [r7, #7]
 8008a4a:	68f8      	ldr	r0, [r7, #12]
 8008a4c:	68b9      	ldr	r1, [r7, #8]
 8008a4e:	461a      	mov	r2, r3
 8008a50:	f7fd f926 	bl	8005ca0 <SDMMC003_CardWriteMultipleBlocks>
 8008a54:	61f8      	str	r0, [r7, #28]
                                                 SectorNumber, SectorCount );
    } /* End of "if (SectorCount == 1)"*/
/*<<<DD_SDMMC001_API_4_5>>>*/
    if (Status == (uint32_t)DAVEApp_SUCCESS)
 8008a56:	69fb      	ldr	r3, [r7, #28]
 8008a58:	2b00      	cmp	r3, #0
 8008a5a:	d103      	bne.n	8008a64 <SDMMC001_WriteBlock+0x68>
    {
      Result = SDMMC001_RES_OK;
 8008a5c:	f04f 0300 	mov.w	r3, #0
 8008a60:	61bb      	str	r3, [r7, #24]
 8008a62:	e002      	b.n	8008a6a <SDMMC001_WriteBlock+0x6e>
    }
/*<<<DD_SDMMC001_API_4_6>>>*/
    else
    {
      Result = SDMMC001_RES_ERROR;
 8008a64:	f04f 0301 	mov.w	r3, #1
 8008a68:	61bb      	str	r3, [r7, #24]
      ERROR(GID_SDMMC001,SDMMC001_SDMMC00x_ERROR,0,0);
    } /* End of "if (Status == (uint32_t)DAVEApp_SUCCESS)"*/
  } while(0);
  FUNCTION_EXIT(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_EXIT);
  return Result;
 8008a6a:	69bb      	ldr	r3, [r7, #24]
}
 8008a6c:	4618      	mov	r0, r3
 8008a6e:	f107 0720 	add.w	r7, r7, #32
 8008a72:	46bd      	mov	sp, r7
 8008a74:	bd80      	pop	{r7, pc}
 8008a76:	bf00      	nop

08008a78 <SDMMC001_Ioctl>:
uint32_t SDMMC001_Ioctl
(
  uint8_t Command,
  void *Buffer
)
{
 8008a78:	b580      	push	{r7, lr}
 8008a7a:	f5ad 7d08 	sub.w	sp, sp, #544	; 0x220
 8008a7e:	af00      	add	r7, sp, #0
 8008a80:	4602      	mov	r2, r0
 8008a82:	463b      	mov	r3, r7
 8008a84:	6019      	str	r1, [r3, #0]
 8008a86:	f107 0307 	add.w	r3, r7, #7
 8008a8a:	701a      	strb	r2, [r3, #0]
  status_t Status = (uint32_t)SDMMC001_ERROR;
 8008a8c:	f04f 0301 	mov.w	r3, #1
 8008a90:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
  uint8_t DiskStatus;
  uint32_t Result;
  SDMMC001_EraseAddrType *ErasePtr;
  const SDMMC001_PasswdType *PasswdPtr;
  SDMMC003_LocalLockStructType LockStruct = {0};
 8008a94:	f107 0308 	add.w	r3, r7, #8
 8008a98:	461a      	mov	r2, r3
 8008a9a:	f44f 7301 	mov.w	r3, #516	; 0x204
 8008a9e:	4610      	mov	r0, r2
 8008aa0:	f04f 0100 	mov.w	r1, #0
 8008aa4:	461a      	mov	r2, r3
 8008aa6:	f01a ff23 	bl	80238f0 <memset>
  FUNCTION_ENTRY(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_ENTRY);
  do
  {
    DiskStatus = SDMMC001_GetStatus();
 8008aaa:	f7ff ff65 	bl	8008978 <SDMMC001_GetStatus>
 8008aae:	4603      	mov	r3, r0
 8008ab0:	f887 3217 	strb.w	r3, [r7, #535]	; 0x217
/*<<<DD_SDMMC001_API_5_1>>>*/
/* If card is not initialized or inserted */
    if ((DiskStatus & (uint8_t)SDMMC001_STA_NOINIT) != 0)
 8008ab4:	f897 3217 	ldrb.w	r3, [r7, #535]	; 0x217
 8008ab8:	f003 0301 	and.w	r3, r3, #1
 8008abc:	2b00      	cmp	r3, #0
 8008abe:	d033      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
    {
      if (SDMMC001_LockFlag == 1UL)
 8008ac0:	f640 53cd 	movw	r3, #3533	; 0xdcd
 8008ac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008ac8:	781b      	ldrb	r3, [r3, #0]
 8008aca:	2b01      	cmp	r3, #1
 8008acc:	d127      	bne.n	8008b1e <SDMMC001_Ioctl+0xa6>
      {
        Status = (uint32_t)SDMMC001_DISK_LOCKED;
 8008ace:	f04f 0303 	mov.w	r3, #3
 8008ad2:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
        if ( (Command != SDMMC001_MMC_UNLOCK_CARD) &&
 8008ad6:	f107 0307 	add.w	r3, r7, #7
 8008ada:	781b      	ldrb	r3, [r3, #0]
 8008adc:	2b20      	cmp	r3, #32
 8008ade:	d023      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
 8008ae0:	f107 0307 	add.w	r3, r7, #7
 8008ae4:	781b      	ldrb	r3, [r3, #0]
 8008ae6:	2b21      	cmp	r3, #33	; 0x21
 8008ae8:	d01e      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
           (Command != SDMMC001_MMC_SET_PASSWD) &&
 8008aea:	f107 0307 	add.w	r3, r7, #7
 8008aee:	781b      	ldrb	r3, [r3, #0]
 8008af0:	2b22      	cmp	r3, #34	; 0x22
 8008af2:	d019      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
           (Command != SDMMC001_MMC_CLEAR_PASSWD) &&
 8008af4:	f107 0307 	add.w	r3, r7, #7
 8008af8:	781b      	ldrb	r3, [r3, #0]
 8008afa:	2b23      	cmp	r3, #35	; 0x23
 8008afc:	d014      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
           (Command != SDMMC001_MMC_SET_LOCK) &&
 8008afe:	f107 0307 	add.w	r3, r7, #7
 8008b02:	781b      	ldrb	r3, [r3, #0]
 8008b04:	2b24      	cmp	r3, #36	; 0x24
 8008b06:	d00f      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
           (Command != SDMMC001_MMC_READ_LOCK_STATUS) &&
 8008b08:	f107 0307 	add.w	r3, r7, #7
 8008b0c:	781b      	ldrb	r3, [r3, #0]
 8008b0e:	2b25      	cmp	r3, #37	; 0x25
 8008b10:	d00a      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
           (Command != SDMMC001_MMC_FORCE_ERASE) &&
 8008b12:	f107 0307 	add.w	r3, r7, #7
 8008b16:	781b      	ldrb	r3, [r3, #0]
 8008b18:	2b07      	cmp	r3, #7
 8008b1a:	d005      	beq.n	8008b28 <SDMMC001_Ioctl+0xb0>
           (Command != SDMMC001_CTRL_EJECT) )
        {
          ERROR(GID_SDMMC001,Status,0,0);
          break;
 8008b1c:	e1fa      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>
        }
      }
      else
      {
        Status = (uint32_t)SDMMC001_RES_NOTRDY;
 8008b1e:	f04f 0303 	mov.w	r3, #3
 8008b22:	f8c7 321c 	str.w	r3, [r7, #540]	; 0x21c
        ERROR(GID_SDMMC001,Status,0,0);
        break;
 8008b26:	e1f5      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>
      }
    }
/* Switch to the respective IOCTL command */
    switch (Command)
 8008b28:	f107 0307 	add.w	r3, r7, #7
 8008b2c:	781b      	ldrb	r3, [r3, #0]
 8008b2e:	2b25      	cmp	r3, #37	; 0x25
 8008b30:	f200 81e4 	bhi.w	8008efc <SDMMC001_Ioctl+0x484>
 8008b34:	a201      	add	r2, pc, #4	; (adr r2, 8008b3c <SDMMC001_Ioctl+0xc4>)
 8008b36:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008b3a:	bf00      	nop
 8008b3c:	08008bd5 	.word	0x08008bd5
 8008b40:	08008bed 	.word	0x08008bed
 8008b44:	08008bdf 	.word	0x08008bdf
 8008b48:	08008c1d 	.word	0x08008c1d
 8008b4c:	08008bfb 	.word	0x08008bfb
 8008b50:	08008efd 	.word	0x08008efd
 8008b54:	08008efd 	.word	0x08008efd
 8008b58:	08008ef3 	.word	0x08008ef3
 8008b5c:	08008efd 	.word	0x08008efd
 8008b60:	08008efd 	.word	0x08008efd
 8008b64:	08008c2b 	.word	0x08008c2b
 8008b68:	08008c39 	.word	0x08008c39
 8008b6c:	08008c47 	.word	0x08008c47
 8008b70:	08008c55 	.word	0x08008c55
 8008b74:	08008c63 	.word	0x08008c63
 8008b78:	08008efd 	.word	0x08008efd
 8008b7c:	08008efd 	.word	0x08008efd
 8008b80:	08008efd 	.word	0x08008efd
 8008b84:	08008efd 	.word	0x08008efd
 8008b88:	08008efd 	.word	0x08008efd
 8008b8c:	08008efd 	.word	0x08008efd
 8008b90:	08008efd 	.word	0x08008efd
 8008b94:	08008efd 	.word	0x08008efd
 8008b98:	08008efd 	.word	0x08008efd
 8008b9c:	08008efd 	.word	0x08008efd
 8008ba0:	08008efd 	.word	0x08008efd
 8008ba4:	08008efd 	.word	0x08008efd
 8008ba8:	08008efd 	.word	0x08008efd
 8008bac:	08008efd 	.word	0x08008efd
 8008bb0:	08008efd 	.word	0x08008efd
 8008bb4:	08008efd 	.word	0x08008efd
 8008bb8:	08008c71 	.word	0x08008c71
 8008bbc:	08008ccf 	.word	0x08008ccf
 8008bc0:	08008d2d 	.word	0x08008d2d
 8008bc4:	08008dd3 	.word	0x08008dd3
 8008bc8:	08008e31 	.word	0x08008e31
 8008bcc:	08008ec7 	.word	0x08008ec7
 8008bd0:	08008ed5 	.word	0x08008ed5
    {
/*<<<DD_SDMMC001_API_5_2>>>*/
      case SDMMC001_CTRL_SYNC:
        Status = SDMMC003_FlushDiskWriteCache();
 8008bd4:	f7fd fd00 	bl	80065d8 <SDMMC003_FlushDiskWriteCache>
 8008bd8:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008bdc:	e19a      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

      case SDMMC001_GET_SECTOR_SIZE:
        Status = SDMMC003_GetSectorSize(Buffer);
 8008bde:	463b      	mov	r3, r7
 8008be0:	6818      	ldr	r0, [r3, #0]
 8008be2:	f7fd fc6d 	bl	80064c0 <SDMMC003_GetSectorSize>
 8008be6:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
		break;
 8008bea:	e193      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>
		 
/*<<<DD_SDMMC001_API_5_3>>>*/
      case SDMMC001_GET_SECTOR_COUNT:
        Status = SDMMC003_GetSectorCount( Buffer );
 8008bec:	463b      	mov	r3, r7
 8008bee:	6818      	ldr	r0, [r3, #0]
 8008bf0:	f7fd fbd4 	bl	800639c <SDMMC003_GetSectorCount>
 8008bf4:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008bf8:	e18c      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_4>>>*/
      case SDMMC001_CTRL_ERASE_SECTOR:
        ErasePtr = (SDMMC001_EraseAddrType *) Buffer;
 8008bfa:	463b      	mov	r3, r7
 8008bfc:	681b      	ldr	r3, [r3, #0]
 8008bfe:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
        Status = SDMMC003_EraseBlock( (ErasePtr->StartAddress),
 8008c02:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 8008c06:	681a      	ldr	r2, [r3, #0]
                                      (ErasePtr->EndAddress));
 8008c08:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
        break;

/*<<<DD_SDMMC001_API_5_4>>>*/
      case SDMMC001_CTRL_ERASE_SECTOR:
        ErasePtr = (SDMMC001_EraseAddrType *) Buffer;
        Status = SDMMC003_EraseBlock( (ErasePtr->StartAddress),
 8008c0c:	685b      	ldr	r3, [r3, #4]
 8008c0e:	4610      	mov	r0, r2
 8008c10:	4619      	mov	r1, r3
 8008c12:	f7fd f901 	bl	8005e18 <SDMMC003_EraseBlock>
 8008c16:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
                                      (ErasePtr->EndAddress));
        break;
 8008c1a:	e17b      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_5>>>*/
      case SDMMC001_GET_BLOCK_SIZE:
        Status = SDMMC003_GetBlockSize(Buffer);
 8008c1c:	463b      	mov	r3, r7
 8008c1e:	6818      	ldr	r0, [r3, #0]
 8008c20:	f7fd fc6c 	bl	80064fc <SDMMC003_GetBlockSize>
 8008c24:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008c28:	e174      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_6>>>*/
      case SDMMC001_MMC_GET_TYPE:
        Status = SDMMC003_GetCardType(Buffer);
 8008c2a:	463b      	mov	r3, r7
 8008c2c:	6818      	ldr	r0, [r3, #0]
 8008c2e:	f7fd fabb 	bl	80061a8 <SDMMC003_GetCardType>
 8008c32:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008c36:	e16d      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_7>>>*/
      case SDMMC001_MMC_GET_CSD:
        Status = SDMMC003_GetCsd(Buffer);
 8008c38:	463b      	mov	r3, r7
 8008c3a:	6818      	ldr	r0, [r3, #0]
 8008c3c:	f7fd fb8a 	bl	8006354 <SDMMC003_GetCsd>
 8008c40:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008c44:	e166      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_8>>>*/
      case SDMMC001_MMC_GET_CID:
        Status = SDMMC003_GetCid(Buffer);
 8008c46:	463b      	mov	r3, r7
 8008c48:	6818      	ldr	r0, [r3, #0]
 8008c4a:	f7fd fad1 	bl	80061f0 <SDMMC003_GetCid>
 8008c4e:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008c52:	e15f      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_8>>>*/
      case SDMMC001_MMC_GET_OCR:
        Status = SDMMC003_GetOcr(Buffer);
 8008c54:	463b      	mov	r3, r7
 8008c56:	6818      	ldr	r0, [r3, #0]
 8008c58:	f7fd fb5a 	bl	8006310 <SDMMC003_GetOcr>
 8008c5c:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008c60:	e158      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_10>>>*/
      case SDMMC001_MMC_GET_SDSTAT:
        Status = SDMMC003_GetSdStatus(Buffer);
 8008c62:	463b      	mov	r3, r7
 8008c64:	6818      	ldr	r0, [r3, #0]
 8008c66:	f7fd fccf 	bl	8006608 <SDMMC003_GetSdStatus>
 8008c6a:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008c6e:	e151      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_11>>>*/
      case SDMMC001_MMC_LOCK_CARD:
        LockStruct.Mode = 0x04UL;
 8008c70:	f107 0308 	add.w	r3, r7, #8
 8008c74:	f04f 0204 	mov.w	r2, #4
 8008c78:	701a      	strb	r2, [r3, #0]
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
 8008c7a:	463b      	mov	r3, r7
 8008c7c:	681b      	ldr	r3, [r3, #0]
 8008c7e:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_11_1>>>*/
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
 8008c82:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008c86:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008c8a:	2b10      	cmp	r3, #16
 8008c8c:	f200 813b 	bhi.w	8008f06 <SDMMC001_Ioctl+0x48e>
        {
          break;
        }
        LockStruct.PwdLen = PasswdPtr->OldPwdLength;
 8008c90:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008c94:	f893 2020 	ldrb.w	r2, [r3, #32]
 8008c98:	f107 0308 	add.w	r3, r7, #8
 8008c9c:	705a      	strb	r2, [r3, #1]
        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword, \
 8008c9e:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
               (uint32_t)LockStruct.PwdLen);
 8008ca2:	f107 0308 	add.w	r3, r7, #8
 8008ca6:	785b      	ldrb	r3, [r3, #1]
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
        {
          break;
        }
        LockStruct.PwdLen = PasswdPtr->OldPwdLength;
        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword, \
 8008ca8:	f107 0108 	add.w	r1, r7, #8
 8008cac:	f101 0102 	add.w	r1, r1, #2
 8008cb0:	4608      	mov	r0, r1
 8008cb2:	4611      	mov	r1, r2
 8008cb4:	461a      	mov	r2, r3
 8008cb6:	f01a fcad 	bl	8023614 <memcpy>
               (uint32_t)LockStruct.PwdLen);
        Status = SDMMC003_LockUnlockCard(&LockStruct, SDMMC003_LOCK);
 8008cba:	f107 0308 	add.w	r3, r7, #8
 8008cbe:	4618      	mov	r0, r3
 8008cc0:	f04f 0100 	mov.w	r1, #0
 8008cc4:	f7fd f99a 	bl	8005ffc <SDMMC003_LockUnlockCard>
 8008cc8:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008ccc:	e122      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_12>>>*/
      case SDMMC001_MMC_UNLOCK_CARD:
        LockStruct.Mode = 0x00UL;
 8008cce:	f107 0308 	add.w	r3, r7, #8
 8008cd2:	f04f 0200 	mov.w	r2, #0
 8008cd6:	701a      	strb	r2, [r3, #0]
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
 8008cd8:	463b      	mov	r3, r7
 8008cda:	681b      	ldr	r3, [r3, #0]
 8008cdc:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_12_1>>>*/
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
 8008ce0:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008ce4:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008ce8:	2b10      	cmp	r3, #16
 8008cea:	f200 810e 	bhi.w	8008f0a <SDMMC001_Ioctl+0x492>
        {
          break;
        }
        LockStruct.PwdLen = PasswdPtr->OldPwdLength;
 8008cee:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008cf2:	f893 2020 	ldrb.w	r2, [r3, #32]
 8008cf6:	f107 0308 	add.w	r3, r7, #8
 8008cfa:	705a      	strb	r2, [r3, #1]
        memcpy(LockStruct.PwdData,PasswdPtr->OldPassword, LockStruct.PwdLen);
 8008cfc:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 8008d00:	f107 0308 	add.w	r3, r7, #8
 8008d04:	785b      	ldrb	r3, [r3, #1]
 8008d06:	f107 0108 	add.w	r1, r7, #8
 8008d0a:	f101 0102 	add.w	r1, r1, #2
 8008d0e:	4608      	mov	r0, r1
 8008d10:	4611      	mov	r1, r2
 8008d12:	461a      	mov	r2, r3
 8008d14:	f01a fc7e 	bl	8023614 <memcpy>
        Status  = SDMMC003_LockUnlockCard(&LockStruct,  \
 8008d18:	f107 0308 	add.w	r3, r7, #8
 8008d1c:	4618      	mov	r0, r3
 8008d1e:	f04f 0101 	mov.w	r1, #1
 8008d22:	f7fd f96b 	bl	8005ffc <SDMMC003_LockUnlockCard>
 8008d26:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
                                          SDMMC003_UNLOCK);
        break;
 8008d2a:	e0f3      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_13>>>*/
      case SDMMC001_MMC_SET_PASSWD:
/*Fill the local lock structure with the information provided*/
        LockStruct.Mode  = 0x01UL;
 8008d2c:	f107 0308 	add.w	r3, r7, #8
 8008d30:	f04f 0201 	mov.w	r2, #1
 8008d34:	701a      	strb	r2, [r3, #0]
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
 8008d36:	463b      	mov	r3, r7
 8008d38:	681b      	ldr	r3, [r3, #0]
 8008d3a:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_13_1>>>*/
        if( (PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN) ||
 8008d3e:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008d42:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008d46:	2b10      	cmp	r3, #16
 8008d48:	f200 80e4 	bhi.w	8008f14 <SDMMC001_Ioctl+0x49c>
            (PasswdPtr->NewPwdLength > SDMMC001_MAX_PASSWD_LEN ))
 8008d4c:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008d50:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
/*Fill the local lock structure with the information provided*/
        LockStruct.Mode  = 0x01UL;
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_13_1>>>*/
        if( (PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN) ||
 8008d54:	2b10      	cmp	r3, #16
 8008d56:	f200 80dd 	bhi.w	8008f14 <SDMMC001_Ioctl+0x49c>
            (PasswdPtr->NewPwdLength > SDMMC001_MAX_PASSWD_LEN ))
        {
          break;
        }
        LockStruct.PwdLen = PasswdPtr->OldPwdLength + PasswdPtr->NewPwdLength;
 8008d5a:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008d5e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8008d62:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008d66:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8008d6a:	18d3      	adds	r3, r2, r3
 8008d6c:	b2da      	uxtb	r2, r3
 8008d6e:	f107 0308 	add.w	r3, r7, #8
 8008d72:	705a      	strb	r2, [r3, #1]

        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword, \
 8008d74:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
                PasswdPtr->OldPwdLength );
 8008d78:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008d7c:	f893 3020 	ldrb.w	r3, [r3, #32]
        {
          break;
        }
        LockStruct.PwdLen = PasswdPtr->OldPwdLength + PasswdPtr->NewPwdLength;

        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword, \
 8008d80:	f107 0108 	add.w	r1, r7, #8
 8008d84:	f101 0102 	add.w	r1, r1, #2
 8008d88:	4608      	mov	r0, r1
 8008d8a:	4611      	mov	r1, r2
 8008d8c:	461a      	mov	r2, r3
 8008d8e:	f01a fc41 	bl	8023614 <memcpy>
                PasswdPtr->OldPwdLength );
        memcpy(LockStruct.PwdData + PasswdPtr->OldPwdLength, \
 8008d92:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008d96:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008d9a:	f107 0208 	add.w	r2, r7, #8
 8008d9e:	18d3      	adds	r3, r2, r3
 8008da0:	f103 0102 	add.w	r1, r3, #2
               PasswdPtr->NewPassword, PasswdPtr->NewPwdLength );
 8008da4:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008da8:	f103 0210 	add.w	r2, r3, #16
 8008dac:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008db0:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
        }
        LockStruct.PwdLen = PasswdPtr->OldPwdLength + PasswdPtr->NewPwdLength;

        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword, \
                PasswdPtr->OldPwdLength );
        memcpy(LockStruct.PwdData + PasswdPtr->OldPwdLength, \
 8008db4:	4608      	mov	r0, r1
 8008db6:	4611      	mov	r1, r2
 8008db8:	461a      	mov	r2, r3
 8008dba:	f01a fc2b 	bl	8023614 <memcpy>
               PasswdPtr->NewPassword, PasswdPtr->NewPwdLength );

        Status = SDMMC003_LockUnlockCard(&LockStruct, \
 8008dbe:	f107 0308 	add.w	r3, r7, #8
 8008dc2:	4618      	mov	r0, r3
 8008dc4:	f04f 0101 	mov.w	r1, #1
 8008dc8:	f7fd f918 	bl	8005ffc <SDMMC003_LockUnlockCard>
 8008dcc:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
                                          SDMMC003_UNLOCK);
        break;
 8008dd0:	e0a0      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_14>>>*/
      case SDMMC001_MMC_CLEAR_PASSWD:
        LockStruct.Mode  = 0x02UL;
 8008dd2:	f107 0308 	add.w	r3, r7, #8
 8008dd6:	f04f 0202 	mov.w	r2, #2
 8008dda:	701a      	strb	r2, [r3, #0]
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
 8008ddc:	463b      	mov	r3, r7
 8008dde:	681b      	ldr	r3, [r3, #0]
 8008de0:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_14_1>>>*/
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
 8008de4:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008de8:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008dec:	2b10      	cmp	r3, #16
 8008dee:	f200 808e 	bhi.w	8008f0e <SDMMC001_Ioctl+0x496>
        {
          break;
        }
        LockStruct.PwdLen =  PasswdPtr->OldPwdLength;
 8008df2:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008df6:	f893 2020 	ldrb.w	r2, [r3, #32]
 8008dfa:	f107 0308 	add.w	r3, r7, #8
 8008dfe:	705a      	strb	r2, [r3, #1]
        memcpy(LockStruct.PwdData, PasswdPtr ->OldPassword, \
 8008e00:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
               LockStruct.PwdLen);
 8008e04:	f107 0308 	add.w	r3, r7, #8
 8008e08:	785b      	ldrb	r3, [r3, #1]
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
        {
          break;
        }
        LockStruct.PwdLen =  PasswdPtr->OldPwdLength;
        memcpy(LockStruct.PwdData, PasswdPtr ->OldPassword, \
 8008e0a:	f107 0108 	add.w	r1, r7, #8
 8008e0e:	f101 0102 	add.w	r1, r1, #2
 8008e12:	4608      	mov	r0, r1
 8008e14:	4611      	mov	r1, r2
 8008e16:	461a      	mov	r2, r3
 8008e18:	f01a fbfc 	bl	8023614 <memcpy>
               LockStruct.PwdLen);
        Status = SDMMC003_LockUnlockCard(&LockStruct,SDMMC003_UNLOCK);
 8008e1c:	f107 0308 	add.w	r3, r7, #8
 8008e20:	4618      	mov	r0, r3
 8008e22:	f04f 0101 	mov.w	r1, #1
 8008e26:	f7fd f8e9 	bl	8005ffc <SDMMC003_LockUnlockCard>
 8008e2a:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008e2e:	e071      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_15>>>*/
      case SDMMC001_MMC_SET_LOCK:
        LockStruct.Mode  = 0x05UL;
 8008e30:	f107 0308 	add.w	r3, r7, #8
 8008e34:	f04f 0205 	mov.w	r2, #5
 8008e38:	701a      	strb	r2, [r3, #0]
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
 8008e3a:	463b      	mov	r3, r7
 8008e3c:	681b      	ldr	r3, [r3, #0]
 8008e3e:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
        /*<<<DD_SDMMC001_API_5_15_1>>>*/
        /* Check password length doesn't exceeds the permitted length */
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
 8008e42:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008e46:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008e4a:	2b10      	cmp	r3, #16
 8008e4c:	d861      	bhi.n	8008f12 <SDMMC001_Ioctl+0x49a>
        {
          break;
        }
        LockStruct.PwdLen =  PasswdPtr->OldPwdLength + PasswdPtr->NewPwdLength;
 8008e4e:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008e52:	f893 2020 	ldrb.w	r2, [r3, #32]
 8008e56:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008e5a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8008e5e:	18d3      	adds	r3, r2, r3
 8008e60:	b2da      	uxtb	r2, r3
 8008e62:	f107 0308 	add.w	r3, r7, #8
 8008e66:	705a      	strb	r2, [r3, #1]
        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword,PasswdPtr->OldPwdLength );
 8008e68:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 8008e6c:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008e70:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008e74:	f107 0108 	add.w	r1, r7, #8
 8008e78:	f101 0102 	add.w	r1, r1, #2
 8008e7c:	4608      	mov	r0, r1
 8008e7e:	4611      	mov	r1, r2
 8008e80:	461a      	mov	r2, r3
 8008e82:	f01a fbc7 	bl	8023614 <memcpy>
        memcpy(LockStruct.PwdData + PasswdPtr->OldPwdLength, \
 8008e86:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008e8a:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008e8e:	f107 0208 	add.w	r2, r7, #8
 8008e92:	18d3      	adds	r3, r2, r3
 8008e94:	f103 0102 	add.w	r1, r3, #2
                       PasswdPtr->NewPassword, PasswdPtr->NewPwdLength );
 8008e98:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008e9c:	f103 0210 	add.w	r2, r3, #16
 8008ea0:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 8008ea4:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
        {
          break;
        }
        LockStruct.PwdLen =  PasswdPtr->OldPwdLength + PasswdPtr->NewPwdLength;
        memcpy(LockStruct.PwdData, PasswdPtr->OldPassword,PasswdPtr->OldPwdLength );
        memcpy(LockStruct.PwdData + PasswdPtr->OldPwdLength, \
 8008ea8:	4608      	mov	r0, r1
 8008eaa:	4611      	mov	r1, r2
 8008eac:	461a      	mov	r2, r3
 8008eae:	f01a fbb1 	bl	8023614 <memcpy>
                       PasswdPtr->NewPassword, PasswdPtr->NewPwdLength );
        Status  = SDMMC003_LockUnlockCard(&LockStruct, SDMMC003_LOCK);
 8008eb2:	f107 0308 	add.w	r3, r7, #8
 8008eb6:	4618      	mov	r0, r3
 8008eb8:	f04f 0100 	mov.w	r1, #0
 8008ebc:	f7fd f89e 	bl	8005ffc <SDMMC003_LockUnlockCard>
 8008ec0:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008ec4:	e026      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_16>>>*/
      case SDMMC001_MMC_READ_LOCK_STATUS:
        Status = SDMMC003_GetLockStatus((uint32_t *)Buffer);
 8008ec6:	463b      	mov	r3, r7
 8008ec8:	6818      	ldr	r0, [r3, #0]
 8008eca:	f7fd f8dd 	bl	8006088 <SDMMC003_GetLockStatus>
 8008ece:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008ed2:	e01f      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_17>>>*/
      case SDMMC001_MMC_FORCE_ERASE:
        LockStruct.Mode = 0x08UL;
 8008ed4:	f107 0308 	add.w	r3, r7, #8
 8008ed8:	f04f 0208 	mov.w	r2, #8
 8008edc:	701a      	strb	r2, [r3, #0]
        Status = SDMMC003_LockUnlockCard(&LockStruct, SDMMC003_UNLOCK);
 8008ede:	f107 0308 	add.w	r3, r7, #8
 8008ee2:	4618      	mov	r0, r3
 8008ee4:	f04f 0101 	mov.w	r1, #1
 8008ee8:	f7fd f888 	bl	8005ffc <SDMMC003_LockUnlockCard>
 8008eec:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008ef0:	e010      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

/*<<<DD_SDMMC001_API_5_18>>>*/
      case SDMMC001_CTRL_EJECT:
        Status = SDMMC003_EjectCard();
 8008ef2:	f7fd fbf1 	bl	80066d8 <SDMMC003_EjectCard>
 8008ef6:	f8c7 021c 	str.w	r0, [r7, #540]	; 0x21c
        break;
 8008efa:	e00b      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>

      default:
        Result = SDMMC001_RES_PARERR;
 8008efc:	f04f 0304 	mov.w	r3, #4
 8008f00:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
        break;
 8008f04:	e006      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_11_1>>>*/
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
        {
          break;
 8008f06:	bf00      	nop
 8008f08:	e004      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_12_1>>>*/
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
        {
          break;
 8008f0a:	bf00      	nop
 8008f0c:	e002      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
        /* Check password length doesn't exceeds the permitted length */
        /*<<<DD_SDMMC001_API_5_14_1>>>*/
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
        {
          break;
 8008f0e:	bf00      	nop
 8008f10:	e000      	b.n	8008f14 <SDMMC001_Ioctl+0x49c>
        PasswdPtr = (const SDMMC001_PasswdType *)Buffer;
        /*<<<DD_SDMMC001_API_5_15_1>>>*/
        /* Check password length doesn't exceeds the permitted length */
        if( PasswdPtr->OldPwdLength > SDMMC001_MAX_PASSWD_LEN )
        {
          break;
 8008f12:	bf00      	nop
        break;
     }
  } while (0);

/*<<<DD_SDMMC001_API_5_18>>>*/
  if (Status == (uint32_t)DAVEApp_SUCCESS)
 8008f14:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
 8008f18:	2b00      	cmp	r3, #0
 8008f1a:	d104      	bne.n	8008f26 <SDMMC001_Ioctl+0x4ae>
  {
    Result = SDMMC001_RES_OK;
 8008f1c:	f04f 0300 	mov.w	r3, #0
 8008f20:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
 8008f24:	e003      	b.n	8008f2e <SDMMC001_Ioctl+0x4b6>
  }
/*<<<DD_SDMMC001_API_5_19>>>*/
  else
  {
    Result = SDMMC001_RES_ERROR;
 8008f26:	f04f 0301 	mov.w	r3, #1
 8008f2a:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    ERROR(GID_SDMMC001,SDMMC001_SDMMC00x_ERROR,sizeof(int),Status);
  }
  FUNCTION_EXIT(GID_SDMMC001, (uint32_t)SDMMC001_FUNCTION_EXIT);
  return Result;
 8008f2e:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
}
 8008f32:	4618      	mov	r0, r3
 8008f34:	f507 7708 	add.w	r7, r7, #544	; 0x220
 8008f38:	46bd      	mov	sp, r7
 8008f3a:	bd80      	pop	{r7, pc}

08008f3c <RTC001_lInit>:
 *  Initialization function for the app. Configures the registers
 *  based on options selected in UI.
 */ 

static void  RTC001_lInit(const RTC001_HandleType* Handle)
{
 8008f3c:	b580      	push	{r7, lr}
 8008f3e:	b084      	sub	sp, #16
 8008f40:	af00      	add	r7, sp, #0
 8008f42:	6078      	str	r0, [r7, #4]

  status_t status = (uint32_t) DAVEApp_SUCCESS;  	  
 8008f44:	f04f 0300 	mov.w	r3, #0
 8008f48:	60fb      	str	r3, [r7, #12]
   /* <<<DD_RTC001_API_1>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY); 
   	  

  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR = \
 8008f4a:	f244 0374 	movw	r3, #16500	; 0x4074
 8008f4e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8008f52:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
 8008f56:	60da      	str	r2, [r3, #12]
      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  		SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  		SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  
  if ((((RTC->CTR & RTC_CTR_ENB_Msk) >> RTC_CTR_ENB_Pos) == 0U ) ||\
 8008f58:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8008f5c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8008f60:	685b      	ldr	r3, [r3, #4]
 8008f62:	f003 0301 	and.w	r3, r3, #1
 8008f66:	2b00      	cmp	r3, #0
 8008f68:	d003      	beq.n	8008f72 <RTC001_lInit+0x36>
    (Handle->RTCInitOnce != 1U))
 8008f6a:	687b      	ldr	r3, [r7, #4]
 8008f6c:	781b      	ldrb	r3, [r3, #0]
  SCU_INTERRUPT->SRCLR = \
      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  		SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  		SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  
  if ((((RTC->CTR & RTC_CTR_ENB_Msk) >> RTC_CTR_ENB_Pos) == 0U ) ||\
 8008f6e:	2b01      	cmp	r3, #1
 8008f70:	d00c      	beq.n	8008f8c <RTC001_lInit+0x50>
    (Handle->RTCInitOnce != 1U))
  {
     /* RTC disabled to set the time */
     status = RTC001_Disable();
 8008f72:	f000 f8b7 	bl	80090e4 <RTC001_Disable>
 8008f76:	60f8      	str	r0, [r7, #12]
     /*assert status = DAVEApp_SUCCESS*/
     DBG002_I (status = DAVEApp_SUCCESS);
     /* Calendar time and date set in RTC registers */
     status |= RTC001_Clock_SetTime(&timeptr1);
 8008f78:	f246 60c4 	movw	r0, #26308	; 0x66c4
 8008f7c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8008f80:	f000 fa4c 	bl	800941c <RTC001_Clock_SetTime>
 8008f84:	4603      	mov	r3, r0
 8008f86:	68fa      	ldr	r2, [r7, #12]
 8008f88:	4313      	orrs	r3, r2
 8008f8a:	60fb      	str	r3, [r7, #12]
     DBG002_I (status = DAVEApp_SUCCESS);

  }
  
  /* Enable the RTC module */
  RTC->CTR |= ((uint32_t)(RTC_CTR_ENB_Msk));
 8008f8c:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8008f90:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8008f94:	f44f 4294 	mov.w	r2, #18944	; 0x4a00
 8008f98:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8008f9c:	6852      	ldr	r2, [r2, #4]
 8008f9e:	f042 0201 	orr.w	r2, r2, #1
 8008fa2:	605a      	str	r2, [r3, #4]
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
 8008fa4:	bf00      	nop
 8008fa6:	f244 0374 	movw	r3, #16500	; 0x4074
 8008faa:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8008fae:	685b      	ldr	r3, [r3, #4]
 8008fb0:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8008fb4:	2b00      	cmp	r3, #0
 8008fb6:	d0f6      	beq.n	8008fa6 <RTC001_lInit+0x6a>
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;	
 8008fb8:	f244 0374 	movw	r3, #16500	; 0x4074
 8008fbc:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8008fc0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8008fc4:	60da      	str	r2, [r3, #12]
  
		
	  
      
  /* Enable RTC alarm interrupt in SCU */
  SCU_INTERRUPT->SRMSK |= SCU_INTERRUPT_SRMSK_AI_Msk; 
 8008fc6:	f244 0374 	movw	r3, #16500	; 0x4074
 8008fca:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8008fce:	f244 0274 	movw	r2, #16500	; 0x4074
 8008fd2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8008fd6:	6892      	ldr	r2, [r2, #8]
 8008fd8:	f042 0204 	orr.w	r2, r2, #4
 8008fdc:	609a      	str	r2, [r3, #8]
     	
	
  /*configure RTC prescaler*/
  WR_REGHIB(RTC->CTR, RTC_CTR_DIV_Msk, RTC_CTR_DIV_Pos, \
 8008fde:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8008fe2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8008fe6:	687a      	ldr	r2, [r7, #4]
 8008fe8:	8852      	ldrh	r2, [r2, #2]
 8008fea:	ea4f 4102 	mov.w	r1, r2, lsl #16
 8008fee:	f44f 4294 	mov.w	r2, #18944	; 0x4a00
 8008ff2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8008ff6:	6852      	ldr	r2, [r2, #4]
 8008ff8:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8008ffc:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8009000:	430a      	orrs	r2, r1
 8009002:	605a      	str	r2, [r3, #4]
 8009004:	f244 0374 	movw	r3, #16500	; 0x4074
 8009008:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800900c:	685b      	ldr	r3, [r3, #4]
 800900e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8009012:	2b00      	cmp	r3, #0
 8009014:	d0f6      	beq.n	8009004 <RTC001_lInit+0xc8>
 8009016:	f244 0374 	movw	r3, #16500	; 0x4074
 800901a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800901e:	f244 0274 	movw	r2, #16500	; 0x4074
 8009022:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009026:	68d2      	ldr	r2, [r2, #12]
 8009028:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800902c:	60da      	str	r2, [r3, #12]
           (uint32_t)Handle->DividerValue, SCU_INTERRUPT_SRRAW_RTC_CTR_Msk);	    	     
 	 
  /* Enable RTC periodic interrupt in SCU */
  SCU_INTERRUPT->SRMSK |= (uint32_t)SCU_INTERRUPT_SRMSK_PI_Msk;     
 800902e:	f244 0374 	movw	r3, #16500	; 0x4074
 8009032:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009036:	f244 0274 	movw	r2, #16500	; 0x4074
 800903a:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800903e:	6892      	ldr	r2, [r2, #8]
 8009040:	f042 0202 	orr.w	r2, r2, #2
 8009044:	609a      	str	r2, [r3, #8]
  if (status != (uint32_t)DAVEApp_SUCCESS)
  {
    DBG002_ERROR(APP_GID,status, 0, NULL);
  }
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
}
 8009046:	f107 0710 	add.w	r7, r7, #16
 800904a:	46bd      	mov	sp, r7
 800904c:	bd80      	pop	{r7, pc}
 800904e:	bf00      	nop

08009050 <RTC001_Init>:
/*
 *  Initialization function for the app. Configures the registers
 *  based on options selected in UI.
 */
void RTC001_Init()
{
 8009050:	b580      	push	{r7, lr}
 8009052:	af00      	add	r7, sp, #0
	RTC001_lInit(&RTC001_Handle);
 8009054:	f246 608c 	movw	r0, #26252	; 0x668c
 8009058:	f6c0 0002 	movt	r0, #2050	; 0x802
 800905c:	f7ff ff6e 	bl	8008f3c <RTC001_lInit>

}
 8009060:	bd80      	pop	{r7, pc}
 8009062:	bf00      	nop

08009064 <RTC001_DeInit>:
/*
 *  Deinitialization function which initializes the App internal data
 *  structures to default values. 
 */
void  RTC001_DeInit(void)
{
 8009064:	b480      	push	{r7}
 8009066:	af00      	add	r7, sp, #0
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_2>>> */
	
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
}
 8009068:	46bd      	mov	sp, r7
 800906a:	bc80      	pop	{r7}
 800906c:	4770      	bx	lr
 800906e:	bf00      	nop

08009070 <RTC001_Enable>:

/*
 *  The function enables the RTC module.
 */
status_t  RTC001_Enable(void)
{
 8009070:	b480      	push	{r7}
 8009072:	b083      	sub	sp, #12
 8009074:	af00      	add	r7, sp, #0
  status_t status = (uint32_t) RTC001_ERROR;
 8009076:	f04f 0302 	mov.w	r3, #2
 800907a:	607b      	str	r3, [r7, #4]
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_3>>> */
 
  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR |= (uint32_t)\
 800907c:	f244 0374 	movw	r3, #16500	; 0x4074
 8009080:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009084:	f244 0274 	movw	r2, #16500	; 0x4074
 8009088:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800908c:	68d2      	ldr	r2, [r2, #12]
 800908e:	f042 52f8 	orr.w	r2, r2, #520093696	; 0x1f000000
 8009092:	60da      	str	r2, [r3, #12]
    (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk |\
  	SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  								SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
  /* Enable RTC module */
  RTC->CTR |= (uint32_t)(RTC_CTR_ENB_Msk);
 8009094:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8009098:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800909c:	f44f 4294 	mov.w	r2, #18944	; 0x4a00
 80090a0:	f2c5 0200 	movt	r2, #20480	; 0x5000
 80090a4:	6852      	ldr	r2, [r2, #4]
 80090a6:	f042 0201 	orr.w	r2, r2, #1
 80090aa:	605a      	str	r2, [r3, #4]
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
 80090ac:	bf00      	nop
 80090ae:	f244 0374 	movw	r3, #16500	; 0x4074
 80090b2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80090b6:	685b      	ldr	r3, [r3, #4]
 80090b8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80090bc:	2b00      	cmp	r3, #0
 80090be:	d0f6      	beq.n	80090ae <RTC001_Enable+0x3e>
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;	
 80090c0:	f244 0374 	movw	r3, #16500	; 0x4074
 80090c4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80090c8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80090cc:	60da      	str	r2, [r3, #12]
  
  status = (uint32_t) DAVEApp_SUCCESS;	
 80090ce:	f04f 0300 	mov.w	r3, #0
 80090d2:	607b      	str	r3, [r7, #4]
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
 80090d4:	687b      	ldr	r3, [r7, #4]
}
 80090d6:	4618      	mov	r0, r3
 80090d8:	f107 070c 	add.w	r7, r7, #12
 80090dc:	46bd      	mov	sp, r7
 80090de:	bc80      	pop	{r7}
 80090e0:	4770      	bx	lr
 80090e2:	bf00      	nop

080090e4 <RTC001_Disable>:
/*
 *  The function disables the RTC module.
 */
 
status_t  RTC001_Disable(void)	
{
 80090e4:	b480      	push	{r7}
 80090e6:	b083      	sub	sp, #12
 80090e8:	af00      	add	r7, sp, #0
  status_t status = (uint32_t) RTC001_ERROR;
 80090ea:	f04f 0302 	mov.w	r3, #2
 80090ee:	607b      	str	r3, [r7, #4]
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_4>>> */

  /* Disable the RTC module*/
  RTC->CTR &= (uint32_t) (~(RTC_CTR_ENB_Msk));
 80090f0:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80090f4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80090f8:	f44f 4294 	mov.w	r2, #18944	; 0x4a00
 80090fc:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009100:	6852      	ldr	r2, [r2, #4]
 8009102:	f022 0201 	bic.w	r2, r2, #1
 8009106:	605a      	str	r2, [r3, #4]
  /* Wait for Mirror register update and clear the update indication */
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_RTC_CTR_Msk) == 0U) 
 8009108:	bf00      	nop
 800910a:	f244 0374 	movw	r3, #16500	; 0x4074
 800910e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009112:	685b      	ldr	r3, [r3, #4]
 8009114:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8009118:	2b00      	cmp	r3, #0
 800911a:	d0f6      	beq.n	800910a <RTC001_Disable+0x26>
  {}
  SCU_INTERRUPT->SRCLR = SCU_INTERRUPT_SRRAW_RTC_CTR_Msk;	
 800911c:	f244 0374 	movw	r3, #16500	; 0x4074
 8009120:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009124:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8009128:	60da      	str	r2, [r3, #12]

  /* Clear the RTC Time registers */  
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
 800912a:	bf00      	nop
 800912c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8009130:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009134:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8009138:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800913c:	2b00      	cmp	r3, #0
 800913e:	d1f5      	bne.n	800912c <RTC001_Disable+0x48>
  {}
  RTC->TIM0 = 0x00000000U;
 8009140:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8009144:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009148:	f04f 0200 	mov.w	r2, #0
 800914c:	621a      	str	r2, [r3, #32]
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)
 800914e:	bf00      	nop
 8009150:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8009154:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009158:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 800915c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8009160:	2b00      	cmp	r3, #0
 8009162:	d1f5      	bne.n	8009150 <RTC001_Disable+0x6c>
  {}
  RTC->TIM1 = 0x00000000U;  
 8009164:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8009168:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800916c:	f04f 0200 	mov.w	r2, #0
 8009170:	625a      	str	r2, [r3, #36]	; 0x24
  /* Clear the Alarm registers */
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)
 8009172:	bf00      	nop
 8009174:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8009178:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800917c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8009180:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8009184:	2b00      	cmp	r3, #0
 8009186:	d1f5      	bne.n	8009174 <RTC001_Disable+0x90>
  {}
  RTC->ATIM0 = 0x00000000U;
 8009188:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 800918c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009190:	f04f 0200 	mov.w	r2, #0
 8009194:	619a      	str	r2, [r3, #24]
  while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk)!= 0x0U)
 8009196:	bf00      	nop
 8009198:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800919c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80091a0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80091a4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80091a8:	2b00      	cmp	r3, #0
 80091aa:	d1f5      	bne.n	8009198 <RTC001_Disable+0xb4>
  {}
  RTC->ATIM1 = 0x00000000U; 	
 80091ac:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80091b0:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80091b4:	f04f 0200 	mov.w	r2, #0
 80091b8:	61da      	str	r2, [r3, #28]
  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR |= (uint32_t)\
 80091ba:	f244 0374 	movw	r3, #16500	; 0x4074
 80091be:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80091c2:	f244 0274 	movw	r2, #16500	; 0x4074
 80091c6:	f2c5 0200 	movt	r2, #20480	; 0x5000
 80091ca:	68d2      	ldr	r2, [r2, #12]
 80091cc:	f042 52f8 	orr.w	r2, r2, #520093696	; 0x1f000000
 80091d0:	60da      	str	r2, [r3, #12]
    (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk |\
  	SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  	SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);    
  							
  status = (uint32_t)DAVEApp_SUCCESS;
 80091d2:	f04f 0300 	mov.w	r3, #0
 80091d6:	607b      	str	r3, [r7, #4]
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
 80091d8:	687b      	ldr	r3, [r7, #4]
}
 80091da:	4618      	mov	r0, r3
 80091dc:	f107 070c 	add.w	r7, r7, #12
 80091e0:	46bd      	mov	sp, r7
 80091e2:	bc80      	pop	{r7}
 80091e4:	4770      	bx	lr
 80091e6:	bf00      	nop

080091e8 <RTC001_GetFlagStatus>:

/*
 *  The function gets RTC status flag for Alarm and Periodic Timer Events.
 */	
status_t  RTC001_GetFlagStatus(RTC001_FlagType Flag)
{
 80091e8:	b480      	push	{r7}
 80091ea:	b085      	sub	sp, #20
 80091ec:	af00      	add	r7, sp, #0
 80091ee:	4603      	mov	r3, r0
 80091f0:	80fb      	strh	r3, [r7, #6]
  status_t status = (uint32_t) RTC001_RESET;
 80091f2:	f04f 0304 	mov.w	r3, #4
 80091f6:	60fb      	str	r3, [r7, #12]
  uint32_t TempValue = 0U;
 80091f8:	f04f 0300 	mov.w	r3, #0
 80091fc:	60bb      	str	r3, [r7, #8]
  /* <<<DD_RTC001_API_6>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);

  /*read the Status Service Request Register*/
  TempValue = RTC->STSSR;
 80091fe:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8009202:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009206:	68db      	ldr	r3, [r3, #12]
 8009208:	60bb      	str	r3, [r7, #8]
  
  /*check the given flag*/
	if((TempValue & (uint32_t) Flag) != 0U)
 800920a:	88fa      	ldrh	r2, [r7, #6]
 800920c:	68bb      	ldr	r3, [r7, #8]
 800920e:	4013      	ands	r3, r2
 8009210:	2b00      	cmp	r3, #0
 8009212:	d002      	beq.n	800921a <RTC001_GetFlagStatus+0x32>
	{
	  status = (uint32_t) RTC001_SET;
 8009214:	f04f 0303 	mov.w	r3, #3
 8009218:	60fb      	str	r3, [r7, #12]
	}

	DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
	return status;
 800921a:	68fb      	ldr	r3, [r7, #12]
}
 800921c:	4618      	mov	r0, r3
 800921e:	f107 0714 	add.w	r7, r7, #20
 8009222:	46bd      	mov	sp, r7
 8009224:	bc80      	pop	{r7}
 8009226:	4770      	bx	lr

08009228 <RTC001_ClearFlagStatus>:

/*
 *  The function clears RTC status flag for Alarm and Periodic Timer Events.
 */
void  RTC001_ClearFlagStatus(RTC001_FlagType Flag)
{
 8009228:	b480      	push	{r7}
 800922a:	b083      	sub	sp, #12
 800922c:	af00      	add	r7, sp, #0
 800922e:	4603      	mov	r3, r0
 8009230:	80fb      	strh	r3, [r7, #6]
  /* <<<DD_RTC001_API_5>>> */
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  
  /*write to the Clear Service Request Register*/
  RTC->CLRSR |= (uint32_t)Flag;
 8009232:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8009236:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800923a:	f44f 4294 	mov.w	r2, #18944	; 0x4a00
 800923e:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009242:	6951      	ldr	r1, [r2, #20]
 8009244:	88fa      	ldrh	r2, [r7, #6]
 8009246:	430a      	orrs	r2, r1
 8009248:	615a      	str	r2, [r3, #20]

	DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
}
 800924a:	f107 070c 	add.w	r7, r7, #12
 800924e:	46bd      	mov	sp, r7
 8009250:	bc80      	pop	{r7}
 8009252:	4770      	bx	lr

08009254 <RTC001_ConfigAlarm>:
 *  Interface to configure the RTC alarm.
 */

status_t RTC001_ConfigAlarm (const RTC001_HandleType* Handle, 
    RTC001_TimeHandle* timeptr, AlarmCallBackPtr CallBack,uint32_t CbArg)
{
 8009254:	b580      	push	{r7, lr}
 8009256:	b088      	sub	sp, #32
 8009258:	af00      	add	r7, sp, #0
 800925a:	60f8      	str	r0, [r7, #12]
 800925c:	60b9      	str	r1, [r7, #8]
 800925e:	607a      	str	r2, [r7, #4]
 8009260:	603b      	str	r3, [r7, #0]
  uint16_t m1 = 0U,y1 = 0U,d1 = 0U;
 8009262:	f04f 0300 	mov.w	r3, #0
 8009266:	837b      	strh	r3, [r7, #26]
 8009268:	f04f 0300 	mov.w	r3, #0
 800926c:	833b      	strh	r3, [r7, #24]
 800926e:	f04f 0300 	mov.w	r3, #0
 8009272:	82fb      	strh	r3, [r7, #22]
  status_t status = (uint32_t)RTC001_ERROR;
 8009274:	f04f 0302 	mov.w	r3, #2
 8009278:	61fb      	str	r3, [r7, #28]
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
  do
  {
    /* <<<DD_RTC001 _API_4>>> */
    /* Clear Mirror register update status of RTC registers in SCU*/
    SCU_INTERRUPT->SRCLR = (uint32_t)\
 800927a:	f244 0374 	movw	r3, #16500	; 0x4074
 800927e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009282:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
 8009286:	60da      	str	r2, [r3, #12]
      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  		SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  		SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);  	

    /* Register the call back function with NVIC_SCU001 */		
    if(CallBack != NULL)
 8009288:	687b      	ldr	r3, [r7, #4]
 800928a:	2b00      	cmp	r3, #0
 800928c:	d005      	beq.n	800929a <RTC001_ConfigAlarm+0x46>
    {    
	    
	    NVIC_SCU001_RegisterCallback(NVIC_SCU001_AI,CallBack,CbArg);
 800928e:	f04f 0002 	mov.w	r0, #2
 8009292:	6879      	ldr	r1, [r7, #4]
 8009294:	683a      	ldr	r2, [r7, #0]
 8009296:	f000 fcb5 	bl	8009c04 <NVIC_SCU001_RegisterCallback>
	    
	  } 
    /*   Write values into ATIM0 and ATIM1 registers  */
    m1 = timeptr->Month;
 800929a:	68bb      	ldr	r3, [r7, #8]
 800929c:	795b      	ldrb	r3, [r3, #5]
 800929e:	837b      	strh	r3, [r7, #26]
    y1 = timeptr->Year;
 80092a0:	68bb      	ldr	r3, [r7, #8]
 80092a2:	88db      	ldrh	r3, [r3, #6]
 80092a4:	833b      	strh	r3, [r7, #24]
    d1 = timeptr->Days;
 80092a6:	68bb      	ldr	r3, [r7, #8]
 80092a8:	78db      	ldrb	r3, [r3, #3]
 80092aa:	82fb      	strh	r3, [r7, #22]
    /* Check whether the date entered is valid */
    if (RTC001_ldatevalid(m1,d1,y1))
 80092ac:	8b79      	ldrh	r1, [r7, #26]
 80092ae:	8afa      	ldrh	r2, [r7, #22]
 80092b0:	8b3b      	ldrh	r3, [r7, #24]
 80092b2:	4608      	mov	r0, r1
 80092b4:	4611      	mov	r1, r2
 80092b6:	461a      	mov	r2, r3
 80092b8:	f000 fa74 	bl	80097a4 <RTC001_ldatevalid>
 80092bc:	4603      	mov	r3, r0
 80092be:	2b00      	cmp	r3, #0
 80092c0:	d04b      	beq.n	800935a <RTC001_ConfigAlarm+0x106>
    { 
      /*Wait until any transfer over serial interface to ATIM0 is completed*/   
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)
 80092c2:	bf00      	nop
 80092c4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80092c8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80092cc:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80092d0:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80092d4:	2b00      	cmp	r3, #0
 80092d6:	d1f5      	bne.n	80092c4 <RTC001_ConfigAlarm+0x70>
      {}   
      /*Configure the Alarm Time Register 0 */
      RTC->ATIM0 = (uint32_t)\
 80092d8:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80092dc:	f2c5 0300 	movt	r3, #20480	; 0x5000
               (((timeptr->Sec) & (uint32_t)RTC_ATIM0_ASE_Msk) | \
 80092e0:	68ba      	ldr	r2, [r7, #8]
 80092e2:	7812      	ldrb	r2, [r2, #0]
 80092e4:	f002 013f 	and.w	r1, r2, #63	; 0x3f
              ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & \
 80092e8:	68ba      	ldr	r2, [r7, #8]
 80092ea:	7852      	ldrb	r2, [r2, #1]
 80092ec:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80092f0:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
      /*Wait until any transfer over serial interface to ATIM0 is completed*/   
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)
      {}   
      /*Configure the Alarm Time Register 0 */
      RTC->ATIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_ATIM0_ASE_Msk) | \
 80092f4:	4311      	orrs	r1, r2
              ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & \
                                  (uint32_t)RTC_ATIM0_AMI_Msk) | \
            ((((uint32_t)timeptr->Hours) << RTC_ATIM0_AHO_Pos) & \
 80092f6:	68ba      	ldr	r2, [r7, #8]
 80092f8:	7892      	ldrb	r2, [r2, #2]
 80092fa:	ea4f 4202 	mov.w	r2, r2, lsl #16
 80092fe:	f402 12f8 	and.w	r2, r2, #2031616	; 0x1f0000
      {}   
      /*Configure the Alarm Time Register 0 */
      RTC->ATIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_ATIM0_ASE_Msk) | \
              ((((uint32_t)timeptr->Min) << RTC_ATIM0_AMI_Pos) & \
                                  (uint32_t)RTC_ATIM0_AMI_Msk) | \
 8009302:	4311      	orrs	r1, r2
            ((((uint32_t)timeptr->Hours) << RTC_ATIM0_AHO_Pos) & \
                                  (uint32_t)RTC_ATIM0_AHO_Msk) | \
        (((((uint32_t)timeptr->Days)-1U) << RTC_ATIM0_ADA_Pos) & \
 8009304:	68ba      	ldr	r2, [r7, #8]
 8009306:	78d2      	ldrb	r2, [r2, #3]
 8009308:	f102 32ff 	add.w	r2, r2, #4294967295
 800930c:	ea4f 6202 	mov.w	r2, r2, lsl #24
 8009310:	f002 52f8 	and.w	r2, r2, #520093696	; 0x1f000000
    { 
      /*Wait until any transfer over serial interface to ATIM0 is completed*/   
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM0_Msk)!= 0x0U)
      {}   
      /*Configure the Alarm Time Register 0 */
      RTC->ATIM0 = (uint32_t)\
 8009314:	430a      	orrs	r2, r1
 8009316:	619a      	str	r2, [r3, #24]
                                  (uint32_t)RTC_ATIM0_AHO_Msk) | \
        (((((uint32_t)timeptr->Days)-1U) << RTC_ATIM0_ADA_Pos) & \
                                  (uint32_t)RTC_ATIM0_ADA_Msk));

      /*Wait until any transfer over serial interface to ATIM1 is completed*/        
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk)!= 0x0U)
 8009318:	bf00      	nop
 800931a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800931e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009322:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8009326:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800932a:	2b00      	cmp	r3, #0
 800932c:	d1f5      	bne.n	800931a <RTC001_ConfigAlarm+0xc6>
      {}   
      /*Configure the Alarm Time Register 1 */
      RTC->ATIM1 = (uint32_t)\
 800932e:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8009332:	f2c5 0300 	movt	r3, #20480	; 0x5000
           ((((((uint32_t)timeptr->Month)-1U) << RTC_ATIM1_AMO_Pos) & \
 8009336:	68ba      	ldr	r2, [r7, #8]
 8009338:	7952      	ldrb	r2, [r2, #5]
 800933a:	f102 32ff 	add.w	r2, r2, #4294967295
 800933e:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8009342:	f402 6170 	and.w	r1, r2, #3840	; 0xf00
                                       (uint32_t)RTC_ATIM1_AMO_Msk) | \
        ((uint32_t)(((uint32_t)timeptr->Year) << RTC_ATIM1_AYE_Pos) & \
 8009346:	68ba      	ldr	r2, [r7, #8]
 8009348:	88d2      	ldrh	r2, [r2, #6]
 800934a:	ea4f 4202 	mov.w	r2, r2, lsl #16

      /*Wait until any transfer over serial interface to ATIM1 is completed*/        
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_ATIM1_Msk)!= 0x0U)
      {}   
      /*Configure the Alarm Time Register 1 */
      RTC->ATIM1 = (uint32_t)\
 800934e:	430a      	orrs	r2, r1
 8009350:	61da      	str	r2, [r3, #28]
           ((((((uint32_t)timeptr->Month)-1U) << RTC_ATIM1_AMO_Pos) & \
                                       (uint32_t)RTC_ATIM1_AMO_Msk) | \
        ((uint32_t)(((uint32_t)timeptr->Year) << RTC_ATIM1_AYE_Pos) & \
                                       (uint32_t)RTC_ATIM1_AYE_Msk)); 				       
      status = (uint32_t)DAVEApp_SUCCESS;   
 8009352:	f04f 0300 	mov.w	r3, #0
 8009356:	61fb      	str	r3, [r7, #28]
 8009358:	e002      	b.n	8009360 <RTC001_ConfigAlarm+0x10c>
    }  
    else /*date is not valid*/
    {
      status = (uint32_t)RTC001_INVALID_HANDLE;
 800935a:	f04f 0301 	mov.w	r3, #1
 800935e:	61fb      	str	r3, [r7, #28]
      DBG002_ERROR(APP_GID,status, 0, NULL);
    }
 
  }while(0);
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
 8009360:	69fb      	ldr	r3, [r7, #28]
}
 8009362:	4618      	mov	r0, r3
 8009364:	f107 0720 	add.w	r7, r7, #32
 8009368:	46bd      	mov	sp, r7
 800936a:	bd80      	pop	{r7, pc}

0800936c <RTC001_Clock_GetTime>:
/*
 *  Function to read the current RTC time
 */
 
status_t RTC001_Clock_GetTime (RTC001_TimeHandle* timeptr)
{
 800936c:	b480      	push	{r7}
 800936e:	b087      	sub	sp, #28
 8009370:	af00      	add	r7, sp, #0
 8009372:	6078      	str	r0, [r7, #4]
  status_t status = (uint32_t)RTC001_ERROR;
 8009374:	f04f 0302 	mov.w	r3, #2
 8009378:	617b      	str	r3, [r7, #20]
  uint32_t temp0,temp1;
  temp0 = RTC->TIM0;
 800937a:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 800937e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009382:	6a1b      	ldr	r3, [r3, #32]
 8009384:	613b      	str	r3, [r7, #16]
  temp1 = RTC->TIM1;
 8009386:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 800938a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800938e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009390:	60fb      	str	r3, [r7, #12]
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_12>>> */

  /*   Read values from TIM0 and TIM1 registers  */
  /*   Days of Week value  */
	timeptr->DaWe = (uint8_t)(temp1 & RTC_TIM1_DAWE_Msk);
 8009392:	68fb      	ldr	r3, [r7, #12]
 8009394:	b2db      	uxtb	r3, r3
 8009396:	f003 0307 	and.w	r3, r3, #7
 800939a:	b2da      	uxtb	r2, r3
 800939c:	687b      	ldr	r3, [r7, #4]
 800939e:	711a      	strb	r2, [r3, #4]
  /*   Month value  */
	timeptr->Month = \
          (uint8_t)(((temp1 & RTC_TIM1_MO_Msk) >> RTC_TIM1_MO_Pos) + 1U);
 80093a0:	68fb      	ldr	r3, [r7, #12]
 80093a2:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 80093a6:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80093aa:	b2db      	uxtb	r3, r3
 80093ac:	f103 0301 	add.w	r3, r3, #1
 80093b0:	b2da      	uxtb	r2, r3

  /*   Read values from TIM0 and TIM1 registers  */
  /*   Days of Week value  */
	timeptr->DaWe = (uint8_t)(temp1 & RTC_TIM1_DAWE_Msk);
  /*   Month value  */
	timeptr->Month = \
 80093b2:	687b      	ldr	r3, [r7, #4]
 80093b4:	715a      	strb	r2, [r3, #5]
          (uint8_t)(((temp1 & RTC_TIM1_MO_Msk) >> RTC_TIM1_MO_Pos) + 1U);
  /*   Year value  */
	timeptr->Year = (uint16_t)((temp1 & RTC_TIM1_YE_Msk) >> RTC_TIM1_YE_Pos);
 80093b6:	68fb      	ldr	r3, [r7, #12]
 80093b8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80093bc:	b29a      	uxth	r2, r3
 80093be:	687b      	ldr	r3, [r7, #4]
 80093c0:	80da      	strh	r2, [r3, #6]

  /*   Seconds value  */
	timeptr->Sec =  (uint8_t)((temp0 & RTC_TIM0_SE_Msk));
 80093c2:	693b      	ldr	r3, [r7, #16]
 80093c4:	b2db      	uxtb	r3, r3
 80093c6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80093ca:	b2da      	uxtb	r2, r3
 80093cc:	687b      	ldr	r3, [r7, #4]
 80093ce:	701a      	strb	r2, [r3, #0]
  /*   Minutes value  */
	timeptr->Min = (uint8_t)(((temp0 & RTC_TIM0_MI_Msk) >> RTC_TIM0_MI_Pos));
 80093d0:	693b      	ldr	r3, [r7, #16]
 80093d2:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
 80093d6:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80093da:	b2da      	uxtb	r2, r3
 80093dc:	687b      	ldr	r3, [r7, #4]
 80093de:	705a      	strb	r2, [r3, #1]
  /*   Hours value  */
	timeptr->Hours = (uint8_t)(((temp0 & RTC_TIM0_HO_Msk) >> RTC_TIM0_HO_Pos));
 80093e0:	693b      	ldr	r3, [r7, #16]
 80093e2:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
 80093e6:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80093ea:	b2da      	uxtb	r2, r3
 80093ec:	687b      	ldr	r3, [r7, #4]
 80093ee:	709a      	strb	r2, [r3, #2]
  /*   Days value starting from the 1st day of the month */
	timeptr->Days = \
          (uint8_t)(((temp0 & RTC_TIM0_DA_Msk) >> RTC_TIM0_DA_Pos) + 1U);
 80093f0:	693b      	ldr	r3, [r7, #16]
 80093f2:	f003 53f8 	and.w	r3, r3, #520093696	; 0x1f000000
 80093f6:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80093fa:	b2db      	uxtb	r3, r3
 80093fc:	f103 0301 	add.w	r3, r3, #1
 8009400:	b2da      	uxtb	r2, r3
  /*   Minutes value  */
	timeptr->Min = (uint8_t)(((temp0 & RTC_TIM0_MI_Msk) >> RTC_TIM0_MI_Pos));
  /*   Hours value  */
	timeptr->Hours = (uint8_t)(((temp0 & RTC_TIM0_HO_Msk) >> RTC_TIM0_HO_Pos));
  /*   Days value starting from the 1st day of the month */
	timeptr->Days = \
 8009402:	687b      	ldr	r3, [r7, #4]
 8009404:	70da      	strb	r2, [r3, #3]
          (uint8_t)(((temp0 & RTC_TIM0_DA_Msk) >> RTC_TIM0_DA_Pos) + 1U);
	status = (uint32_t)DAVEApp_SUCCESS;
 8009406:	f04f 0300 	mov.w	r3, #0
 800940a:	617b      	str	r3, [r7, #20]
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
 800940c:	697b      	ldr	r3, [r7, #20]
}
 800940e:	4618      	mov	r0, r3
 8009410:	f107 071c 	add.w	r7, r7, #28
 8009414:	46bd      	mov	sp, r7
 8009416:	bc80      	pop	{r7}
 8009418:	4770      	bx	lr
 800941a:	bf00      	nop

0800941c <RTC001_Clock_SetTime>:

/*
 *  This function is to set the time.
 */
status_t RTC001_Clock_SetTime(RTC001_TimeHandle* timeptr)
{
 800941c:	b580      	push	{r7, lr}
 800941e:	b086      	sub	sp, #24
 8009420:	af00      	add	r7, sp, #0
 8009422:	6078      	str	r0, [r7, #4]
  uint16_t m1 = 0U,y1 = 0U,d1 = 0U;
 8009424:	f04f 0300 	mov.w	r3, #0
 8009428:	81fb      	strh	r3, [r7, #14]
 800942a:	f04f 0300 	mov.w	r3, #0
 800942e:	81bb      	strh	r3, [r7, #12]
 8009430:	f04f 0300 	mov.w	r3, #0
 8009434:	817b      	strh	r3, [r7, #10]
  uint32_t weekDay = 0U;
 8009436:	f04f 0300 	mov.w	r3, #0
 800943a:	617b      	str	r3, [r7, #20]
  status_t status = (uint32_t)RTC001_ERROR;
 800943c:	f04f 0302 	mov.w	r3, #2
 8009440:	613b      	str	r3, [r7, #16]
   /* <<<DD_RTC001_API_13>>> */
  


  /* Clear Mirror register update status of RTC registers in SCU*/
  SCU_INTERRUPT->SRCLR = \
 8009442:	f244 0374 	movw	r3, #16500	; 0x4074
 8009446:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800944a:	f04f 52f8 	mov.w	r2, #520093696	; 0x1f000000
 800944e:	60da      	str	r2, [r3, #12]
      (SCU_INTERRUPT_SRCLR_RTC_CTR_Msk | SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk | \
  		SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk | SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk |\
  		SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk);
 
  /*   Days of Week value  */
  m1 = timeptr->Month;
 8009450:	687b      	ldr	r3, [r7, #4]
 8009452:	795b      	ldrb	r3, [r3, #5]
 8009454:	81fb      	strh	r3, [r7, #14]
  y1 = timeptr->Year;
 8009456:	687b      	ldr	r3, [r7, #4]
 8009458:	88db      	ldrh	r3, [r3, #6]
 800945a:	81bb      	strh	r3, [r7, #12]
  d1 = timeptr->Days;
 800945c:	687b      	ldr	r3, [r7, #4]
 800945e:	78db      	ldrb	r3, [r3, #3]
 8009460:	817b      	strh	r3, [r7, #10]
  
  do
  {    
    if (RTC001_ldatevalid(m1,d1,y1))
 8009462:	89f9      	ldrh	r1, [r7, #14]
 8009464:	897a      	ldrh	r2, [r7, #10]
 8009466:	89bb      	ldrh	r3, [r7, #12]
 8009468:	4608      	mov	r0, r1
 800946a:	4611      	mov	r1, r2
 800946c:	461a      	mov	r2, r3
 800946e:	f000 f999 	bl	80097a4 <RTC001_ldatevalid>
 8009472:	4603      	mov	r3, r0
 8009474:	2b00      	cmp	r3, #0
 8009476:	d068      	beq.n	800954a <RTC001_Clock_SetTime+0x12e>
    { 
      weekDay = ((uint32_t)(RTC001_lweekday(m1,d1,y1)));
 8009478:	89f9      	ldrh	r1, [r7, #14]
 800947a:	897a      	ldrh	r2, [r7, #10]
 800947c:	89bb      	ldrh	r3, [r7, #12]
 800947e:	4608      	mov	r0, r1
 8009480:	4611      	mov	r1, r2
 8009482:	461a      	mov	r2, r3
 8009484:	f000 f9ee 	bl	8009864 <RTC001_lweekday>
 8009488:	6178      	str	r0, [r7, #20]
      if(weekDay < 6U)
 800948a:	697b      	ldr	r3, [r7, #20]
 800948c:	2b05      	cmp	r3, #5
 800948e:	d804      	bhi.n	800949a <RTC001_Clock_SetTime+0x7e>
      {
        weekDay += 1U;
 8009490:	697b      	ldr	r3, [r7, #20]
 8009492:	f103 0301 	add.w	r3, r3, #1
 8009496:	617b      	str	r3, [r7, #20]
        DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);
        break;
      }
      /*Write values into TIM0 and TIM1 registers  */
      /*wait until any serial transaction is completed*/      
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
 8009498:	e00a      	b.n	80094b0 <RTC001_Clock_SetTime+0x94>
      weekDay = ((uint32_t)(RTC001_lweekday(m1,d1,y1)));
      if(weekDay < 6U)
      {
        weekDay += 1U;
      }
      else if(weekDay == 6U)
 800949a:	697b      	ldr	r3, [r7, #20]
 800949c:	2b06      	cmp	r3, #6
 800949e:	d103      	bne.n	80094a8 <RTC001_Clock_SetTime+0x8c>
      {
        weekDay = 0U;
 80094a0:	f04f 0300 	mov.w	r3, #0
 80094a4:	617b      	str	r3, [r7, #20]
        DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);
        break;
      }
      /*Write values into TIM0 and TIM1 registers  */
      /*wait until any serial transaction is completed*/      
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
 80094a6:	e003      	b.n	80094b0 <RTC001_Clock_SetTime+0x94>
      {
        weekDay = 0U;
      }
      else
      {
        status = (uint32_t)RTC001_INVALID_HANDLE;
 80094a8:	f04f 0301 	mov.w	r3, #1
 80094ac:	613b      	str	r3, [r7, #16]
        DBG002_ERROR(APP_GID,RTC001_INVALID_HANDLE, 0, NULL);
        break;
 80094ae:	e04f      	b.n	8009550 <RTC001_Clock_SetTime+0x134>
      }
      /*Write values into TIM0 and TIM1 registers  */
      /*wait until any serial transaction is completed*/      
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
 80094b0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80094b4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80094b8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 80094bc:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80094c0:	2b00      	cmp	r3, #0
 80094c2:	d1f5      	bne.n	80094b0 <RTC001_Clock_SetTime+0x94>
      {}
      /*Configure RTC Time register 0*/
      RTC->TIM0 = (uint32_t)\
 80094c4:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80094c8:	f2c5 0300 	movt	r3, #20480	; 0x5000
               (((timeptr->Sec) & (uint32_t)RTC_TIM0_SE_Msk) | \
 80094cc:	687a      	ldr	r2, [r7, #4]
 80094ce:	7812      	ldrb	r2, [r2, #0]
 80094d0:	f002 013f 	and.w	r1, r2, #63	; 0x3f
              ((((uint32_t)timeptr->Min) << RTC_TIM0_MI_Pos) & \
 80094d4:	687a      	ldr	r2, [r7, #4]
 80094d6:	7852      	ldrb	r2, [r2, #1]
 80094d8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80094dc:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
      /*wait until any serial transaction is completed*/      
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
      {}
      /*Configure RTC Time register 0*/
      RTC->TIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_TIM0_SE_Msk) | \
 80094e0:	4311      	orrs	r1, r2
              ((((uint32_t)timeptr->Min) << RTC_TIM0_MI_Pos) & \
                                  (uint32_t)RTC_TIM0_MI_Msk) | \
            ((((uint32_t)timeptr->Hours) << RTC_TIM0_HO_Pos) & \
 80094e2:	687a      	ldr	r2, [r7, #4]
 80094e4:	7892      	ldrb	r2, [r2, #2]
 80094e6:	ea4f 4202 	mov.w	r2, r2, lsl #16
 80094ea:	f402 12f8 	and.w	r2, r2, #2031616	; 0x1f0000
      {}
      /*Configure RTC Time register 0*/
      RTC->TIM0 = (uint32_t)\
               (((timeptr->Sec) & (uint32_t)RTC_TIM0_SE_Msk) | \
              ((((uint32_t)timeptr->Min) << RTC_TIM0_MI_Pos) & \
                                  (uint32_t)RTC_TIM0_MI_Msk) | \
 80094ee:	4311      	orrs	r1, r2
            ((((uint32_t)timeptr->Hours) << RTC_TIM0_HO_Pos) & \
                                  (uint32_t)RTC_TIM0_HO_Msk) | \
      ((((((uint32_t)timeptr->Days)-1U)) << RTC_TIM0_DA_Pos) & \
 80094f0:	687a      	ldr	r2, [r7, #4]
 80094f2:	78d2      	ldrb	r2, [r2, #3]
 80094f4:	f102 32ff 	add.w	r2, r2, #4294967295
 80094f8:	ea4f 6202 	mov.w	r2, r2, lsl #24
 80094fc:	f002 52f8 	and.w	r2, r2, #520093696	; 0x1f000000
      /*Write values into TIM0 and TIM1 registers  */
      /*wait until any serial transaction is completed*/      
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM0_Msk)!= 0x0U)
      {}
      /*Configure RTC Time register 0*/
      RTC->TIM0 = (uint32_t)\
 8009500:	430a      	orrs	r2, r1
 8009502:	621a      	str	r2, [r3, #32]
            ((((uint32_t)timeptr->Hours) << RTC_TIM0_HO_Pos) & \
                                  (uint32_t)RTC_TIM0_HO_Msk) | \
      ((((((uint32_t)timeptr->Days)-1U)) << RTC_TIM0_DA_Pos) & \
                                  (uint32_t)RTC_TIM0_DA_Msk));      
      /*wait until any serial transaction is completed*/
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)
 8009504:	bf00      	nop
 8009506:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800950a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800950e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8009512:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8009516:	2b00      	cmp	r3, #0
 8009518:	d1f5      	bne.n	8009506 <RTC001_Clock_SetTime+0xea>
      {}     
      /*Configure RTC Time register 1*/
      RTC->TIM1 = (uint32_t) (weekDay |\
 800951a:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 800951e:	f2c5 0300 	movt	r3, #20480	; 0x5000
                   (((((uint32_t)timeptr->Month)-1U) << RTC_TIM1_MO_Pos) & \
 8009522:	687a      	ldr	r2, [r7, #4]
 8009524:	7952      	ldrb	r2, [r2, #5]
 8009526:	f102 32ff 	add.w	r2, r2, #4294967295
 800952a:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800952e:	f402 6170 	and.w	r1, r2, #3840	; 0xf00
                                  (uint32_t)RTC_TIM0_DA_Msk));      
      /*wait until any serial transaction is completed*/
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)
      {}     
      /*Configure RTC Time register 1*/
      RTC->TIM1 = (uint32_t) (weekDay |\
 8009532:	697a      	ldr	r2, [r7, #20]
 8009534:	4311      	orrs	r1, r2
                   (((((uint32_t)timeptr->Month)-1U) << RTC_TIM1_MO_Pos) & \
                                              (uint32_t)RTC_TIM1_MO_Msk) | \
                         ((((uint32_t)timeptr->Year) << RTC_TIM1_YE_Pos) & \
 8009536:	687a      	ldr	r2, [r7, #4]
 8009538:	88d2      	ldrh	r2, [r2, #6]
 800953a:	ea4f 4202 	mov.w	r2, r2, lsl #16
                                  (uint32_t)RTC_TIM0_DA_Msk));      
      /*wait until any serial transaction is completed*/
      while((SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_RTC_TIM1_Msk)!= 0x0U)
      {}     
      /*Configure RTC Time register 1*/
      RTC->TIM1 = (uint32_t) (weekDay |\
 800953e:	430a      	orrs	r2, r1
 8009540:	625a      	str	r2, [r3, #36]	; 0x24
                   (((((uint32_t)timeptr->Month)-1U) << RTC_TIM1_MO_Pos) & \
                                              (uint32_t)RTC_TIM1_MO_Msk) | \
                         ((((uint32_t)timeptr->Year) << RTC_TIM1_YE_Pos) & \
                                              (uint32_t)RTC_TIM1_YE_Msk));      
      status = (uint32_t) DAVEApp_SUCCESS;
 8009542:	f04f 0300 	mov.w	r3, #0
 8009546:	613b      	str	r3, [r7, #16]
 8009548:	e002      	b.n	8009550 <RTC001_Clock_SetTime+0x134>
    }  
    else
    {
      status = (uint32_t) RTC001_INVALID_HANDLE;
 800954a:	f04f 0301 	mov.w	r3, #1
 800954e:	613b      	str	r3, [r7, #16]
      DBG002_ERROR(APP_GID,status, 0, NULL);
    }
  }while(0);

  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return status;
 8009550:	693b      	ldr	r3, [r7, #16]
}
 8009552:	4618      	mov	r0, r3
 8009554:	f107 0718 	add.w	r7, r7, #24
 8009558:	46bd      	mov	sp, r7
 800955a:	bd80      	pop	{r7, pc}

0800955c <RTC001_Time>:
/*
 *  This function is to get the time in seconds calculated from Epoch time (01/01/1970).
 */

status_t RTC001_Time(time_t* time_value)
{
 800955c:	b480      	push	{r7}
 800955e:	b08f      	sub	sp, #60	; 0x3c
 8009560:	af00      	add	r7, sp, #0
 8009562:	6078      	str	r0, [r7, #4]

  uint32_t CurrentYear = 0U, ElapsedYear = 0U;
 8009564:	f04f 0300 	mov.w	r3, #0
 8009568:	627b      	str	r3, [r7, #36]	; 0x24
 800956a:	f04f 0300 	mov.w	r3, #0
 800956e:	637b      	str	r3, [r7, #52]	; 0x34
  uint32_t CurrentMonth = 0U, ElapsedMonth = 0U;
 8009570:	f04f 0300 	mov.w	r3, #0
 8009574:	623b      	str	r3, [r7, #32]
 8009576:	f04f 0300 	mov.w	r3, #0
 800957a:	633b      	str	r3, [r7, #48]	; 0x30
  uint32_t CurrentDay = 0U, ElapsedDays = 0U;
 800957c:	f04f 0300 	mov.w	r3, #0
 8009580:	61fb      	str	r3, [r7, #28]
 8009582:	f04f 0300 	mov.w	r3, #0
 8009586:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t CurrentHour = 0U;
 8009588:	f04f 0300 	mov.w	r3, #0
 800958c:	61bb      	str	r3, [r7, #24]
  uint32_t CurrentMin = 0U;
 800958e:	f04f 0300 	mov.w	r3, #0
 8009592:	617b      	str	r3, [r7, #20]
  uint32_t CurrentSec = 0U;
 8009594:	f04f 0300 	mov.w	r3, #0
 8009598:	613b      	str	r3, [r7, #16]
  uint32_t ElapsedSeconds = 0U;
 800959a:	f04f 0300 	mov.w	r3, #0
 800959e:	60fb      	str	r3, [r7, #12]
  status_t Status = (uint32_t)RTC001_ERROR; 
 80095a0:	f04f 0302 	mov.w	r3, #2
 80095a4:	62bb      	str	r3, [r7, #40]	; 0x28
  
  DBG002_FUNCTION_ENTRY(APP_GID,RTC001_FUNCTION_ENTRY);
   /* <<<DD_RTC001_API_15>>> */
  
  /*check if RTC module is enabled and no NULL pointer*/
  if(((RTC->CTR & (RTC_CTR_ENB_Msk)) != 0U) && (time_value != NULL))
 80095a6:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80095aa:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80095ae:	685b      	ldr	r3, [r3, #4]
 80095b0:	f003 0301 	and.w	r3, r3, #1
 80095b4:	2b00      	cmp	r3, #0
 80095b6:	f000 80ed 	beq.w	8009794 <RTC001_Time+0x238>
 80095ba:	687b      	ldr	r3, [r7, #4]
 80095bc:	2b00      	cmp	r3, #0
 80095be:	f000 80e9 	beq.w	8009794 <RTC001_Time+0x238>
  {

    /*   Read values from TIM0 and TIM1 registers  */
    CurrentYear = ((uint32_t)((RTC->TIM1 & RTC_TIM1_YE_Msk) >> 16U));
 80095c2:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80095c6:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80095ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80095cc:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80095d0:	627b      	str	r3, [r7, #36]	; 0x24
    CurrentMonth = 	((uint32_t)(((RTC->TIM1 & RTC_TIM1_MO_Msk) >> 8U) + 1U));
 80095d2:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80095d6:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80095da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80095dc:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 80095e0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80095e4:	f103 0301 	add.w	r3, r3, #1
 80095e8:	623b      	str	r3, [r7, #32]
    CurrentDay = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_DA_Msk) >> 24U) + 1U));
 80095ea:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 80095ee:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80095f2:	6a1b      	ldr	r3, [r3, #32]
 80095f4:	f003 53f8 	and.w	r3, r3, #520093696	; 0x1f000000
 80095f8:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80095fc:	f103 0301 	add.w	r3, r3, #1
 8009600:	61fb      	str	r3, [r7, #28]
    CurrentHour = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_HO_Msk) >> 16U)));
 8009602:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 8009606:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800960a:	6a1b      	ldr	r3, [r3, #32]
 800960c:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
 8009610:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009614:	61bb      	str	r3, [r7, #24]
    CurrentMin = ((uint32_t)(((RTC->TIM0 & RTC_TIM0_MI_Msk) >> 8U)));
 8009616:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 800961a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800961e:	6a1b      	ldr	r3, [r3, #32]
 8009620:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
 8009624:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8009628:	617b      	str	r3, [r7, #20]
    CurrentSec = ((uint32_t)((RTC->TIM0 & RTC_TIM0_SE_Msk)));
 800962a:	f44f 4394 	mov.w	r3, #18944	; 0x4a00
 800962e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009632:	6a1b      	ldr	r3, [r3, #32]
 8009634:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009638:	613b      	str	r3, [r7, #16]
    
    /*Count number of Days for Elapsed Years since Epoch*/
    ElapsedDays = (uint32_t)(CurrentYear - RTC001_EPOCH_YEAR) *\
 800963a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800963c:	f240 126d 	movw	r2, #365	; 0x16d
 8009640:	fb02 f303 	mul.w	r3, r2, r3
 8009644:	f5a3 232f 	sub.w	r3, r3, #716800	; 0xaf000
 8009648:	f6a3 03ca 	subw	r3, r3, #2250	; 0x8ca
 800964c:	62fb      	str	r3, [r7, #44]	; 0x2c
                  (uint32_t) RTC001_DAYS_IN_AN_YEAR;

    /* Add the number of days to be adjusted for leap years, 
    start from previous year and check backwords */
    for (ElapsedYear=(CurrentYear-1U); ElapsedYear>= 1970U; ElapsedYear--)
 800964e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009650:	f103 33ff 	add.w	r3, r3, #4294967295
 8009654:	637b      	str	r3, [r7, #52]	; 0x34
 8009656:	e02c      	b.n	80096b2 <RTC001_Time+0x156>
    {
      if((((ElapsedYear) % 400U) == 0U) || \
 8009658:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800965a:	f248 531f 	movw	r3, #34079	; 0x851f
 800965e:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8009662:	fba3 1302 	umull	r1, r3, r3, r2
 8009666:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 800966a:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800966e:	fb01 f303 	mul.w	r3, r1, r3
 8009672:	1ad3      	subs	r3, r2, r3
 8009674:	2b00      	cmp	r3, #0
 8009676:	d014      	beq.n	80096a2 <RTC001_Time+0x146>
        ((((ElapsedYear) % 100U) != 0U) && (((ElapsedYear) %4U) == 0U)))
 8009678:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800967a:	f248 531f 	movw	r3, #34079	; 0x851f
 800967e:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8009682:	fba3 1302 	umull	r1, r3, r3, r2
 8009686:	ea4f 1353 	mov.w	r3, r3, lsr #5
 800968a:	f04f 0164 	mov.w	r1, #100	; 0x64
 800968e:	fb01 f303 	mul.w	r3, r1, r3
 8009692:	1ad3      	subs	r3, r2, r3

    /* Add the number of days to be adjusted for leap years, 
    start from previous year and check backwords */
    for (ElapsedYear=(CurrentYear-1U); ElapsedYear>= 1970U; ElapsedYear--)
    {
      if((((ElapsedYear) % 400U) == 0U) || \
 8009694:	2b00      	cmp	r3, #0
 8009696:	d008      	beq.n	80096aa <RTC001_Time+0x14e>
        ((((ElapsedYear) % 100U) != 0U) && (((ElapsedYear) %4U) == 0U)))
 8009698:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800969a:	f003 0303 	and.w	r3, r3, #3
 800969e:	2b00      	cmp	r3, #0
 80096a0:	d103      	bne.n	80096aa <RTC001_Time+0x14e>
      {
        ElapsedDays++;
 80096a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80096a4:	f103 0301 	add.w	r3, r3, #1
 80096a8:	62fb      	str	r3, [r7, #44]	; 0x2c
    ElapsedDays = (uint32_t)(CurrentYear - RTC001_EPOCH_YEAR) *\
                  (uint32_t) RTC001_DAYS_IN_AN_YEAR;

    /* Add the number of days to be adjusted for leap years, 
    start from previous year and check backwords */
    for (ElapsedYear=(CurrentYear-1U); ElapsedYear>= 1970U; ElapsedYear--)
 80096aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80096ac:	f103 33ff 	add.w	r3, r3, #4294967295
 80096b0:	637b      	str	r3, [r7, #52]	; 0x34
 80096b2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80096b4:	f240 73b1 	movw	r3, #1969	; 0x7b1
 80096b8:	429a      	cmp	r2, r3
 80096ba:	d8cd      	bhi.n	8009658 <RTC001_Time+0xfc>
      {
        ElapsedDays++;
      }
    }
    /*if current year is leap year add 1 only if March or later*/
    if((((CurrentYear) % 400U) == 0U) || \
 80096bc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80096be:	f248 531f 	movw	r3, #34079	; 0x851f
 80096c2:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 80096c6:	fba3 1302 	umull	r1, r3, r3, r2
 80096ca:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 80096ce:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80096d2:	fb01 f303 	mul.w	r3, r1, r3
 80096d6:	1ad3      	subs	r3, r2, r3
 80096d8:	2b00      	cmp	r3, #0
 80096da:	d014      	beq.n	8009706 <RTC001_Time+0x1aa>
      ((((CurrentYear) % 100U) != 0U) && (((CurrentYear) %4U) == 0U)))
 80096dc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80096de:	f248 531f 	movw	r3, #34079	; 0x851f
 80096e2:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 80096e6:	fba3 1302 	umull	r1, r3, r3, r2
 80096ea:	ea4f 1353 	mov.w	r3, r3, lsr #5
 80096ee:	f04f 0164 	mov.w	r1, #100	; 0x64
 80096f2:	fb01 f303 	mul.w	r3, r1, r3
 80096f6:	1ad3      	subs	r3, r2, r3
      {
        ElapsedDays++;
      }
    }
    /*if current year is leap year add 1 only if March or later*/
    if((((CurrentYear) % 400U) == 0U) || \
 80096f8:	2b00      	cmp	r3, #0
 80096fa:	d00b      	beq.n	8009714 <RTC001_Time+0x1b8>
      ((((CurrentYear) % 100U) != 0U) && (((CurrentYear) %4U) == 0U)))
 80096fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80096fe:	f003 0303 	and.w	r3, r3, #3
 8009702:	2b00      	cmp	r3, #0
 8009704:	d106      	bne.n	8009714 <RTC001_Time+0x1b8>
    {
      if(CurrentMonth > 2U)
 8009706:	6a3b      	ldr	r3, [r7, #32]
 8009708:	2b02      	cmp	r3, #2
 800970a:	d903      	bls.n	8009714 <RTC001_Time+0x1b8>
      {
        ElapsedDays++;
 800970c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800970e:	f103 0301 	add.w	r3, r3, #1
 8009712:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
    }
    
    /*Add number of Days from Elapsed months from current year*/
    for (ElapsedMonth = (CurrentMonth - 1U); ElapsedMonth != 0U; ElapsedMonth--)
 8009714:	6a3b      	ldr	r3, [r7, #32]
 8009716:	f103 33ff 	add.w	r3, r3, #4294967295
 800971a:	633b      	str	r3, [r7, #48]	; 0x30
 800971c:	e00d      	b.n	800973a <RTC001_Time+0x1de>
    {
      ElapsedDays += RTC001_DAYS_IN_MONTH[ElapsedMonth];  
 800971e:	f246 6348 	movw	r3, #26184	; 0x6648
 8009722:	f6c0 0302 	movt	r3, #2050	; 0x802
 8009726:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009728:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800972c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800972e:	18d3      	adds	r3, r2, r3
 8009730:	62fb      	str	r3, [r7, #44]	; 0x2c
        ElapsedDays++;
      }
    }
    
    /*Add number of Days from Elapsed months from current year*/
    for (ElapsedMonth = (CurrentMonth - 1U); ElapsedMonth != 0U; ElapsedMonth--)
 8009732:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009734:	f103 33ff 	add.w	r3, r3, #4294967295
 8009738:	633b      	str	r3, [r7, #48]	; 0x30
 800973a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800973c:	2b00      	cmp	r3, #0
 800973e:	d1ee      	bne.n	800971e <RTC001_Time+0x1c2>
    {
      ElapsedDays += RTC001_DAYS_IN_MONTH[ElapsedMonth];  
    } 
    
    /*add Elapsed days from current month*/
    ElapsedDays += CurrentDay - 1U;
 8009740:	69fa      	ldr	r2, [r7, #28]
 8009742:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009744:	18d3      	adds	r3, r2, r3
 8009746:	f103 33ff 	add.w	r3, r3, #4294967295
 800974a:	62fb      	str	r3, [r7, #44]	; 0x2c
    
    /*Accumulate the total seconds for ElapsedDays*/
    ElapsedSeconds = (ElapsedDays * RTC001_SECONDS_IN_A_DAY);
 800974c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800974e:	f44f 43a3 	mov.w	r3, #20864	; 0x5180
 8009752:	f2c0 0301 	movt	r3, #1
 8009756:	fb03 f302 	mul.w	r3, r3, r2
 800975a:	60fb      	str	r3, [r7, #12]

    /*Add seconds for current hour, minute and seconds*/
    ElapsedSeconds += (CurrentHour * RTC001_SECONDS_IN_AN_HOUR);   
 800975c:	69bb      	ldr	r3, [r7, #24]
 800975e:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 8009762:	fb02 f303 	mul.w	r3, r2, r3
 8009766:	68fa      	ldr	r2, [r7, #12]
 8009768:	18d3      	adds	r3, r2, r3
 800976a:	60fb      	str	r3, [r7, #12]
    ElapsedSeconds += (CurrentMin * RTC001_SECONDS_IN_A_MINUTE); 
 800976c:	697a      	ldr	r2, [r7, #20]
 800976e:	4613      	mov	r3, r2
 8009770:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8009774:	1a9b      	subs	r3, r3, r2
 8009776:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800977a:	68fa      	ldr	r2, [r7, #12]
 800977c:	18d3      	adds	r3, r2, r3
 800977e:	60fb      	str	r3, [r7, #12]
    ElapsedSeconds += CurrentSec; 
 8009780:	68fa      	ldr	r2, [r7, #12]
 8009782:	693b      	ldr	r3, [r7, #16]
 8009784:	18d3      	adds	r3, r2, r3
 8009786:	60fb      	str	r3, [r7, #12]

    *time_value = (time_t) ElapsedSeconds;
 8009788:	68fa      	ldr	r2, [r7, #12]
 800978a:	687b      	ldr	r3, [r7, #4]
 800978c:	601a      	str	r2, [r3, #0]
    Status = (uint32_t) DAVEApp_SUCCESS;
 800978e:	f04f 0300 	mov.w	r3, #0
 8009792:	62bb      	str	r3, [r7, #40]	; 0x28
    
  }
  DBG002_FUNCTION_EXIT(APP_GID,RTC001_FUNCTION_EXIT);
  return Status;
 8009794:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 8009796:	4618      	mov	r0, r3
 8009798:	f107 073c 	add.w	r7, r7, #60	; 0x3c
 800979c:	46bd      	mov	sp, r7
 800979e:	bc80      	pop	{r7}
 80097a0:	4770      	bx	lr
 80097a2:	bf00      	nop

080097a4 <RTC001_ldatevalid>:
/* return 1 if date is valid, 0 otherwise.	*/
static uint32_t RTC001_ldatevalid(uint16_t m,uint16_t d,uint16_t y)
{
 80097a4:	b480      	push	{r7}
 80097a6:	b085      	sub	sp, #20
 80097a8:	af00      	add	r7, sp, #0
 80097aa:	4613      	mov	r3, r2
 80097ac:	4602      	mov	r2, r0
 80097ae:	80fa      	strh	r2, [r7, #6]
 80097b0:	460a      	mov	r2, r1
 80097b2:	80ba      	strh	r2, [r7, #4]
 80097b4:	807b      	strh	r3, [r7, #2]
  uint32_t valid = 0U;
 80097b6:	f04f 0300 	mov.w	r3, #0
 80097ba:	60fb      	str	r3, [r7, #12]

  if ((m == 0U) || (m > 12U) )
 80097bc:	88fb      	ldrh	r3, [r7, #6]
 80097be:	2b00      	cmp	r3, #0
 80097c0:	d002      	beq.n	80097c8 <RTC001_ldatevalid+0x24>
 80097c2:	88fb      	ldrh	r3, [r7, #6]
 80097c4:	2b0c      	cmp	r3, #12
 80097c6:	d903      	bls.n	80097d0 <RTC001_ldatevalid+0x2c>
  {
    valid = 0U;
 80097c8:	f04f 0300 	mov.w	r3, #0
 80097cc:	60fb      	str	r3, [r7, #12]
 80097ce:	e041      	b.n	8009854 <RTC001_ldatevalid+0xb0>
  }
  else  if ((m != 2U) || (d < 29U))
 80097d0:	88fb      	ldrh	r3, [r7, #6]
 80097d2:	2b02      	cmp	r3, #2
 80097d4:	d102      	bne.n	80097dc <RTC001_ldatevalid+0x38>
 80097d6:	88bb      	ldrh	r3, [r7, #4]
 80097d8:	2b1c      	cmp	r3, #28
 80097da:	d80d      	bhi.n	80097f8 <RTC001_ldatevalid+0x54>
  {
     if (d <= RTC001_DAYS_IN_MONTH[m])
 80097dc:	88ba      	ldrh	r2, [r7, #4]
 80097de:	88f9      	ldrh	r1, [r7, #6]
 80097e0:	f246 6348 	movw	r3, #26184	; 0x6648
 80097e4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80097e8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80097ec:	429a      	cmp	r2, r3
 80097ee:	d831      	bhi.n	8009854 <RTC001_ldatevalid+0xb0>
     {
       valid = 1U;
 80097f0:	f04f 0301 	mov.w	r3, #1
 80097f4:	60fb      	str	r3, [r7, #12]
  {
    valid = 0U;
  }
  else  if ((m != 2U) || (d < 29U))
  {
     if (d <= RTC001_DAYS_IN_MONTH[m])
 80097f6:	e02d      	b.n	8009854 <RTC001_ldatevalid+0xb0>
     }
  }
  else /*reaches here only if m = February and day = 29*/
  {
    /*check if it is leap year*/
    if ((((y) % 400U) == 0U) || ((((y) % 100U) != 0U) && (((y) %4U) == 0U)))
 80097f8:	887a      	ldrh	r2, [r7, #2]
 80097fa:	f248 531f 	movw	r3, #34079	; 0x851f
 80097fe:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8009802:	fba3 1302 	umull	r1, r3, r3, r2
 8009806:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 800980a:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800980e:	fb01 f303 	mul.w	r3, r1, r3
 8009812:	1ad3      	subs	r3, r2, r3
 8009814:	b29b      	uxth	r3, r3
 8009816:	2b00      	cmp	r3, #0
 8009818:	d016      	beq.n	8009848 <RTC001_ldatevalid+0xa4>
 800981a:	887a      	ldrh	r2, [r7, #2]
 800981c:	f248 531f 	movw	r3, #34079	; 0x851f
 8009820:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8009824:	fba3 1302 	umull	r1, r3, r3, r2
 8009828:	ea4f 1353 	mov.w	r3, r3, lsr #5
 800982c:	f04f 0164 	mov.w	r1, #100	; 0x64
 8009830:	fb01 f303 	mul.w	r3, r1, r3
 8009834:	1ad3      	subs	r3, r2, r3
 8009836:	b29b      	uxth	r3, r3
 8009838:	2b00      	cmp	r3, #0
 800983a:	d00b      	beq.n	8009854 <RTC001_ldatevalid+0xb0>
 800983c:	887b      	ldrh	r3, [r7, #2]
 800983e:	f003 0303 	and.w	r3, r3, #3
 8009842:	b29b      	uxth	r3, r3
 8009844:	2b00      	cmp	r3, #0
 8009846:	d105      	bne.n	8009854 <RTC001_ldatevalid+0xb0>
    {
      if (d == 29U)
 8009848:	88bb      	ldrh	r3, [r7, #4]
 800984a:	2b1d      	cmp	r3, #29
 800984c:	d102      	bne.n	8009854 <RTC001_ldatevalid+0xb0>
      { 
        valid = 1U;
 800984e:	f04f 0301 	mov.w	r3, #1
 8009852:	60fb      	str	r3, [r7, #12]
      }
    }
  }
  return valid;
 8009854:	68fb      	ldr	r3, [r7, #12]
}
 8009856:	4618      	mov	r0, r3
 8009858:	f107 0714 	add.w	r7, r7, #20
 800985c:	46bd      	mov	sp, r7
 800985e:	bc80      	pop	{r7}
 8009860:	4770      	bx	lr
 8009862:	bf00      	nop

08009864 <RTC001_lweekday>:

/* given month, day, year, returns day of week, eg. Monday = 0 etc.
*/ 

static uint32_t RTC001_lweekday(uint16_t m,uint16_t d,uint16_t y)
{
 8009864:	b490      	push	{r4, r7}
 8009866:	b088      	sub	sp, #32
 8009868:	af00      	add	r7, sp, #0
 800986a:	4613      	mov	r3, r2
 800986c:	4602      	mov	r2, r0
 800986e:	80fa      	strh	r2, [r7, #6]
 8009870:	460a      	mov	r2, r1
 8009872:	80ba      	strh	r2, [r7, #4]
 8009874:	807b      	strh	r3, [r7, #2]
  uint16_t vx, tx, ix, feb;
  const uint8_t vx_list[] = 
 8009876:	f246 627c 	movw	r2, #26236	; 0x667c
 800987a:	f6c0 0202 	movt	r2, #2050	; 0x802
 800987e:	f107 0308 	add.w	r3, r7, #8
 8009882:	4614      	mov	r4, r2
 8009884:	6820      	ldr	r0, [r4, #0]
 8009886:	6861      	ldr	r1, [r4, #4]
 8009888:	68a2      	ldr	r2, [r4, #8]
 800988a:	c307      	stmia	r3!, {r0, r1, r2}
 800988c:	7b22      	ldrb	r2, [r4, #12]
 800988e:	701a      	strb	r2, [r3, #0]
  {
      0U, 20U, 0U, 16U, 24U, 20U, 0U, 24U, 4U, 12U, 8U, 16U, 12U
  };

  vx = vx_list[m];
 8009890:	88fb      	ldrh	r3, [r7, #6]
 8009892:	f107 0020 	add.w	r0, r7, #32
 8009896:	18c3      	adds	r3, r0, r3
 8009898:	f813 3c18 	ldrb.w	r3, [r3, #-24]
 800989c:	83fb      	strh	r3, [r7, #30]
  if(y > 1900U)
 800989e:	887a      	ldrh	r2, [r7, #2]
 80098a0:	f240 736c 	movw	r3, #1900	; 0x76c
 80098a4:	429a      	cmp	r2, r3
 80098a6:	d903      	bls.n	80098b0 <RTC001_lweekday+0x4c>
  {
    y = y - 1900U;
 80098a8:	887b      	ldrh	r3, [r7, #2]
 80098aa:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
 80098ae:	807b      	strh	r3, [r7, #2]
  }
  feb = (m  > 2U)? 1U : 0U;
 80098b0:	88fb      	ldrh	r3, [r7, #6]
 80098b2:	2b02      	cmp	r3, #2
 80098b4:	d902      	bls.n	80098bc <RTC001_lweekday+0x58>
 80098b6:	f04f 0301 	mov.w	r3, #1
 80098ba:	e001      	b.n	80098c0 <RTC001_lweekday+0x5c>
 80098bc:	f04f 0300 	mov.w	r3, #0
 80098c0:	83bb      	strh	r3, [r7, #28]
/* take care of February */
  ix = ((y - 21U) % 28U) + vx + feb;
 80098c2:	887b      	ldrh	r3, [r7, #2]
 80098c4:	f1a3 0215 	sub.w	r2, r3, #21
 80098c8:	ea4f 0192 	mov.w	r1, r2, lsr #2
 80098cc:	f644 1325 	movw	r3, #18725	; 0x4925
 80098d0:	f2c2 4392 	movt	r3, #9362	; 0x2492
 80098d4:	fba3 0101 	umull	r0, r1, r3, r1
 80098d8:	460b      	mov	r3, r1
 80098da:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80098de:	1a5b      	subs	r3, r3, r1
 80098e0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80098e4:	1ad3      	subs	r3, r2, r3
 80098e6:	b29a      	uxth	r2, r3
 80098e8:	8bfb      	ldrh	r3, [r7, #30]
 80098ea:	18d3      	adds	r3, r2, r3
 80098ec:	b29a      	uxth	r2, r3
 80098ee:	8bbb      	ldrh	r3, [r7, #28]
 80098f0:	18d3      	adds	r3, r2, r3
 80098f2:	837b      	strh	r3, [r7, #26]
/* take care of leap year */
  tx = ((ix + (ix / 4U)) % 7U) + d;
 80098f4:	8b7a      	ldrh	r2, [r7, #26]
 80098f6:	8b7b      	ldrh	r3, [r7, #26]
 80098f8:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80098fc:	b29b      	uxth	r3, r3
 80098fe:	18d1      	adds	r1, r2, r3
 8009900:	f644 1325 	movw	r3, #18725	; 0x4925
 8009904:	f2c2 4392 	movt	r3, #9362	; 0x2492
 8009908:	fba3 2301 	umull	r2, r3, r3, r1
 800990c:	1aca      	subs	r2, r1, r3
 800990e:	ea4f 0252 	mov.w	r2, r2, lsr #1
 8009912:	189b      	adds	r3, r3, r2
 8009914:	ea4f 0293 	mov.w	r2, r3, lsr #2
 8009918:	4613      	mov	r3, r2
 800991a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800991e:	1a9b      	subs	r3, r3, r2
 8009920:	1aca      	subs	r2, r1, r3
 8009922:	b292      	uxth	r2, r2
 8009924:	88bb      	ldrh	r3, [r7, #4]
 8009926:	18d3      	adds	r3, r2, r3
 8009928:	833b      	strh	r3, [r7, #24]
  tx = tx % 7U;
 800992a:	8b3a      	ldrh	r2, [r7, #24]
 800992c:	f644 1325 	movw	r3, #18725	; 0x4925
 8009930:	f2c2 4392 	movt	r3, #9362	; 0x2492
 8009934:	fba3 0302 	umull	r0, r3, r3, r2
 8009938:	1ad1      	subs	r1, r2, r3
 800993a:	ea4f 0151 	mov.w	r1, r1, lsr #1
 800993e:	185b      	adds	r3, r3, r1
 8009940:	ea4f 0193 	mov.w	r1, r3, lsr #2
 8009944:	460b      	mov	r3, r1
 8009946:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800994a:	1a5b      	subs	r3, r3, r1
 800994c:	1ad3      	subs	r3, r2, r3
 800994e:	833b      	strh	r3, [r7, #24]
  return ((uint32_t)tx);
 8009950:	8b3b      	ldrh	r3, [r7, #24]
}
 8009952:	4618      	mov	r0, r3
 8009954:	f107 0720 	add.w	r7, r7, #32
 8009958:	46bd      	mov	sp, r7
 800995a:	bc90      	pop	{r4, r7}
 800995c:	4770      	bx	lr
 800995e:	bf00      	nop

08009960 <RESET001_AssertReset>:
 */
 
 /* This function is to enable reset of peripheral by software  */
 
 void RESET001_AssertReset(RESET001_ResetnType Resetn)
 {
 8009960:	b480      	push	{r7}
 8009962:	b087      	sub	sp, #28
 8009964:	af00      	add	r7, sp, #0
 8009966:	6078      	str	r0, [r7, #4]
  uint32_t* RCUControlReg = 0U;
 8009968:	f04f 0300 	mov.w	r3, #0
 800996c:	617b      	str	r3, [r7, #20]
  uint32_t Temp = 0U ;
 800996e:	f04f 0300 	mov.w	r3, #0
 8009972:	613b      	str	r3, [r7, #16]
  /* <<<DD_RESET001_API_1>>> */
  SCU_RESET_TypeDef* RCUCtrlReg = SCU_RESET;
 8009974:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009978:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800997c:	60fb      	str	r3, [r7, #12]
  Temp = ((uint32_t)Resetn & CLEAR_BITMASK) >> 28;
 800997e:	687b      	ldr	r3, [r7, #4]
 8009980:	ea4f 7313 	mov.w	r3, r3, lsr #28
 8009984:	613b      	str	r3, [r7, #16]
  RCUControlReg = (uint32_t*)((uint32_t)(&RCUCtrlReg->PRSET0) + ( 0x0000000CU * Temp));
 8009986:	68fb      	ldr	r3, [r7, #12]
 8009988:	f103 0310 	add.w	r3, r3, #16
 800998c:	4619      	mov	r1, r3
 800998e:	693a      	ldr	r2, [r7, #16]
 8009990:	4613      	mov	r3, r2
 8009992:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009996:	189b      	adds	r3, r3, r2
 8009998:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800999c:	18cb      	adds	r3, r1, r3
 800999e:	617b      	str	r3, [r7, #20]
  *RCUControlReg = ((uint32_t)Resetn & RESET_BITMASK );
 80099a0:	687b      	ldr	r3, [r7, #4]
 80099a2:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 80099a6:	697b      	ldr	r3, [r7, #20]
 80099a8:	601a      	str	r2, [r3, #0]
}
 80099aa:	f107 071c 	add.w	r7, r7, #28
 80099ae:	46bd      	mov	sp, r7
 80099b0:	bc80      	pop	{r7}
 80099b2:	4770      	bx	lr

080099b4 <RESET001_DeassertReset>:

/* API to get the  reason of last reset */	

void RESET001_DeassertReset(RESET001_ResetnType Resetn)
{
 80099b4:	b480      	push	{r7}
 80099b6:	b087      	sub	sp, #28
 80099b8:	af00      	add	r7, sp, #0
 80099ba:	6078      	str	r0, [r7, #4]
  uint32_t* RCUControlReg = 0UL;
 80099bc:	f04f 0300 	mov.w	r3, #0
 80099c0:	617b      	str	r3, [r7, #20]
  uint32_t Temp = 0UL;
 80099c2:	f04f 0300 	mov.w	r3, #0
 80099c6:	613b      	str	r3, [r7, #16]
  /* <<<DD_RESET001_API_2>>> */
  SCU_RESET_TypeDef* RCUCtrlReg = SCU_RESET;  
 80099c8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 80099cc:	f2c5 0300 	movt	r3, #20480	; 0x5000
 80099d0:	60fb      	str	r3, [r7, #12]
  Temp = ((uint32_t)Resetn & CLEAR_BITMASK) >> 28;
 80099d2:	687b      	ldr	r3, [r7, #4]
 80099d4:	ea4f 7313 	mov.w	r3, r3, lsr #28
 80099d8:	613b      	str	r3, [r7, #16]
  RCUControlReg = (uint32_t*)((uint32_t)(&RCUCtrlReg->PRCLR0) + ( 0x0000000CU * Temp));
 80099da:	68fb      	ldr	r3, [r7, #12]
 80099dc:	f103 0314 	add.w	r3, r3, #20
 80099e0:	4619      	mov	r1, r3
 80099e2:	693a      	ldr	r2, [r7, #16]
 80099e4:	4613      	mov	r3, r2
 80099e6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80099ea:	189b      	adds	r3, r3, r2
 80099ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80099f0:	18cb      	adds	r3, r1, r3
 80099f2:	617b      	str	r3, [r7, #20]
  *RCUControlReg = ((uint32_t)Resetn & RESET_BITMASK) ;
 80099f4:	687b      	ldr	r3, [r7, #4]
 80099f6:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
 80099fa:	697b      	ldr	r3, [r7, #20]
 80099fc:	601a      	str	r2, [r3, #0]
}
 80099fe:	f107 071c 	add.w	r7, r7, #28
 8009a02:	46bd      	mov	sp, r7
 8009a04:	bc80      	pop	{r7}
 8009a06:	4770      	bx	lr

08009a08 <RESET001_GetResetInfo>:
	
/* API to get the  reason of last reset. */
RESET001_InfoType RESET001_GetResetInfo()
{
 8009a08:	b480      	push	{r7}
 8009a0a:	b083      	sub	sp, #12
 8009a0c:	af00      	add	r7, sp, #0
  SCU_RESET_TypeDef* RCUCtrlReg = SCU_RESET;
 8009a0e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009a12:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009a16:	607b      	str	r3, [r7, #4]
 /* <<<DD_RESET001_API_4>>> */
  return (RESET001_InfoType)(RCUCtrlReg->RSTSTAT  &  SCU_RESET_RSTSTAT_RSTSTAT_Msk);
 8009a18:	687b      	ldr	r3, [r7, #4]
 8009a1a:	681b      	ldr	r3, [r3, #0]
 8009a1c:	b2db      	uxtb	r3, r3
}
 8009a1e:	4618      	mov	r0, r3
 8009a20:	f107 070c 	add.w	r7, r7, #12
 8009a24:	46bd      	mov	sp, r7
 8009a26:	bc80      	pop	{r7}
 8009a28:	4770      	bx	lr
 8009a2a:	bf00      	nop

08009a2c <RESET001_GetStatus>:
		
/* Get the reset status of the peripheral */		
status_t RESET001_GetStatus(RESET001_ResetnType Resetn)
{
 8009a2c:	b480      	push	{r7}
 8009a2e:	b089      	sub	sp, #36	; 0x24
 8009a30:	af00      	add	r7, sp, #0
 8009a32:	6078      	str	r0, [r7, #4]
  uint32_t status = RCU_INVALID_INPUT;
 8009a34:	f04f 030f 	mov.w	r3, #15
 8009a38:	61fb      	str	r3, [r7, #28]
  uint32_t* RCUControlReg = 0U;
 8009a3a:	f04f 0300 	mov.w	r3, #0
 8009a3e:	61bb      	str	r3, [r7, #24]
  uint32_t Temp = 0U;
 8009a40:	f04f 0300 	mov.w	r3, #0
 8009a44:	617b      	str	r3, [r7, #20]
  uint32_t Getstatus = 0U;
 8009a46:	f04f 0300 	mov.w	r3, #0
 8009a4a:	613b      	str	r3, [r7, #16]
  /* <<<DD_RESET001_API_3>>> */
  SCU_RESET_TypeDef* RCUCtrlReg = SCU_RESET;
 8009a4c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009a50:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009a54:	60fb      	str	r3, [r7, #12]
  Temp = ((uint32_t)Resetn & CLEAR_BITMASK) >> 28;	
 8009a56:	687b      	ldr	r3, [r7, #4]
 8009a58:	ea4f 7313 	mov.w	r3, r3, lsr #28
 8009a5c:	617b      	str	r3, [r7, #20]
  RCUControlReg = (uint32_t*)((uint32_t)(&RCUCtrlReg->PRSTAT0) + ( 0x0000000CU * Temp));
 8009a5e:	68fb      	ldr	r3, [r7, #12]
 8009a60:	f103 030c 	add.w	r3, r3, #12
 8009a64:	4619      	mov	r1, r3
 8009a66:	697a      	ldr	r2, [r7, #20]
 8009a68:	4613      	mov	r3, r2
 8009a6a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8009a6e:	189b      	adds	r3, r3, r2
 8009a70:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8009a74:	18cb      	adds	r3, r1, r3
 8009a76:	61bb      	str	r3, [r7, #24]
  Getstatus	 = (uint32_t)((*RCUControlReg) & (uint32_t)Resetn & RESET_BITMASK) ;
 8009a78:	69bb      	ldr	r3, [r7, #24]
 8009a7a:	681a      	ldr	r2, [r3, #0]
 8009a7c:	687b      	ldr	r3, [r7, #4]
 8009a7e:	4013      	ands	r3, r2
 8009a80:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8009a84:	613b      	str	r3, [r7, #16]
  if(Getstatus != 0U)
 8009a86:	693b      	ldr	r3, [r7, #16]
 8009a88:	2b00      	cmp	r3, #0
 8009a8a:	d003      	beq.n	8009a94 <RESET001_GetStatus+0x68>
  {
	  status = RCU_SET;
 8009a8c:	f04f 0301 	mov.w	r3, #1
 8009a90:	61fb      	str	r3, [r7, #28]
 8009a92:	e002      	b.n	8009a9a <RESET001_GetStatus+0x6e>
  }
  else
  {
	  status = RCU_RESET;
 8009a94:	f04f 0300 	mov.w	r3, #0
 8009a98:	61fb      	str	r3, [r7, #28]
  }
  return status;
 8009a9a:	69fb      	ldr	r3, [r7, #28]
}
 8009a9c:	4618      	mov	r0, r3
 8009a9e:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8009aa2:	46bd      	mov	sp, r7
 8009aa4:	bc80      	pop	{r7}
 8009aa6:	4770      	bx	lr

08009aa8 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8009aa8:	b480      	push	{r7}
 8009aaa:	af00      	add	r7, sp, #0
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 8009aac:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8009ab0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8009ab4:	68db      	ldr	r3, [r3, #12]
 8009ab6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8009aba:	ea4f 2313 	mov.w	r3, r3, lsr #8
}
 8009abe:	4618      	mov	r0, r3
 8009ac0:	46bd      	mov	sp, r7
 8009ac2:	bc80      	pop	{r7}
 8009ac4:	4770      	bx	lr
 8009ac6:	bf00      	nop

08009ac8 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8009ac8:	b480      	push	{r7}
 8009aca:	b083      	sub	sp, #12
 8009acc:	af00      	add	r7, sp, #0
 8009ace:	4603      	mov	r3, r0
 8009ad0:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8009ad2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8009ad6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8009ada:	f997 2007 	ldrsb.w	r2, [r7, #7]
 8009ade:	ea4f 1252 	mov.w	r2, r2, lsr #5
 8009ae2:	79f9      	ldrb	r1, [r7, #7]
 8009ae4:	f001 011f 	and.w	r1, r1, #31
 8009ae8:	f04f 0001 	mov.w	r0, #1
 8009aec:	fa00 f101 	lsl.w	r1, r0, r1
 8009af0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8009af4:	f107 070c 	add.w	r7, r7, #12
 8009af8:	46bd      	mov	sp, r7
 8009afa:	bc80      	pop	{r7}
 8009afc:	4770      	bx	lr
 8009afe:	bf00      	nop

08009b00 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8009b00:	b480      	push	{r7}
 8009b02:	b083      	sub	sp, #12
 8009b04:	af00      	add	r7, sp, #0
 8009b06:	4603      	mov	r3, r0
 8009b08:	6039      	str	r1, [r7, #0]
 8009b0a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8009b0c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009b10:	2b00      	cmp	r3, #0
 8009b12:	da10      	bge.n	8009b36 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8009b14:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8009b18:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8009b1c:	79fa      	ldrb	r2, [r7, #7]
 8009b1e:	f002 020f 	and.w	r2, r2, #15
 8009b22:	f1a2 0104 	sub.w	r1, r2, #4
 8009b26:	683a      	ldr	r2, [r7, #0]
 8009b28:	b2d2      	uxtb	r2, r2
 8009b2a:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8009b2e:	b2d2      	uxtb	r2, r2
 8009b30:	185b      	adds	r3, r3, r1
 8009b32:	761a      	strb	r2, [r3, #24]
 8009b34:	e00d      	b.n	8009b52 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8009b36:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8009b3a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8009b3e:	f997 1007 	ldrsb.w	r1, [r7, #7]
 8009b42:	683a      	ldr	r2, [r7, #0]
 8009b44:	b2d2      	uxtb	r2, r2
 8009b46:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8009b4a:	b2d2      	uxtb	r2, r2
 8009b4c:	185b      	adds	r3, r3, r1
 8009b4e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8009b52:	f107 070c 	add.w	r7, r7, #12
 8009b56:	46bd      	mov	sp, r7
 8009b58:	bc80      	pop	{r7}
 8009b5a:	4770      	bx	lr

08009b5c <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8009b5c:	b480      	push	{r7}
 8009b5e:	b089      	sub	sp, #36	; 0x24
 8009b60:	af00      	add	r7, sp, #0
 8009b62:	60f8      	str	r0, [r7, #12]
 8009b64:	60b9      	str	r1, [r7, #8]
 8009b66:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
 8009b68:	68fb      	ldr	r3, [r7, #12]
 8009b6a:	f003 0307 	and.w	r3, r3, #7
 8009b6e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 8009b70:	69fb      	ldr	r3, [r7, #28]
 8009b72:	f1c3 0307 	rsb	r3, r3, #7
 8009b76:	2b06      	cmp	r3, #6
 8009b78:	bf28      	it	cs
 8009b7a:	2306      	movcs	r3, #6
 8009b7c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 8009b7e:	69fb      	ldr	r3, [r7, #28]
 8009b80:	f103 0306 	add.w	r3, r3, #6
 8009b84:	2b06      	cmp	r3, #6
 8009b86:	d903      	bls.n	8009b90 <NVIC_EncodePriority+0x34>
 8009b88:	69fb      	ldr	r3, [r7, #28]
 8009b8a:	f103 33ff 	add.w	r3, r3, #4294967295
 8009b8e:	e001      	b.n	8009b94 <NVIC_EncodePriority+0x38>
 8009b90:	f04f 0300 	mov.w	r3, #0
 8009b94:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 8009b96:	69bb      	ldr	r3, [r7, #24]
 8009b98:	f04f 0201 	mov.w	r2, #1
 8009b9c:	fa02 f303 	lsl.w	r3, r2, r3
 8009ba0:	f103 33ff 	add.w	r3, r3, #4294967295
 8009ba4:	461a      	mov	r2, r3
 8009ba6:	68bb      	ldr	r3, [r7, #8]
 8009ba8:	401a      	ands	r2, r3
 8009baa:	697b      	ldr	r3, [r7, #20]
 8009bac:	fa02 f203 	lsl.w	r2, r2, r3
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 8009bb0:	697b      	ldr	r3, [r7, #20]
 8009bb2:	f04f 0101 	mov.w	r1, #1
 8009bb6:	fa01 f303 	lsl.w	r3, r1, r3
 8009bba:	f103 33ff 	add.w	r3, r3, #4294967295
 8009bbe:	4619      	mov	r1, r3
 8009bc0:	687b      	ldr	r3, [r7, #4]
 8009bc2:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

  return (
 8009bc4:	4313      	orrs	r3, r2
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}
 8009bc6:	4618      	mov	r0, r3
 8009bc8:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8009bcc:	46bd      	mov	sp, r7
 8009bce:	bc80      	pop	{r7}
 8009bd0:	4770      	bx	lr
 8009bd2:	bf00      	nop

08009bd4 <NVIC_SCU001_Init>:

/*  Function to configure SCU Interrupts based on  user configuration.
 * 
 */
void NVIC_SCU001_Init()
{
 8009bd4:	b580      	push	{r7, lr}
 8009bd6:	af00      	add	r7, sp, #0
 DBG002_FUNCTION_ENTRY(APP_GID,NVIC_SCU001_FUNC_ENTRY);
  NVIC_SetPriority((IRQn_Type)64, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),63,0));
 8009bd8:	f7ff ff66 	bl	8009aa8 <NVIC_GetPriorityGrouping>
 8009bdc:	4603      	mov	r3, r0
 8009bde:	4618      	mov	r0, r3
 8009be0:	f04f 013f 	mov.w	r1, #63	; 0x3f
 8009be4:	f04f 0200 	mov.w	r2, #0
 8009be8:	f7ff ffb8 	bl	8009b5c <NVIC_EncodePriority>
 8009bec:	4603      	mov	r3, r0
 8009bee:	f04f 0040 	mov.w	r0, #64	; 0x40
 8009bf2:	4619      	mov	r1, r3
 8009bf4:	f7ff ff84 	bl	8009b00 <NVIC_SetPriority>
  /* Enable Interrupt */
  NVIC_EnableIRQ((IRQn_Type)64); 
 8009bf8:	f04f 0040 	mov.w	r0, #64	; 0x40
 8009bfc:	f7ff ff64 	bl	8009ac8 <NVIC_EnableIRQ>
 
  DBG002_FUNCTION_EXIT(APP_GID,NVIC_SCU001_FUNC_EXIT);
}
 8009c00:	bd80      	pop	{r7, pc}
 8009c02:	bf00      	nop

08009c04 <NVIC_SCU001_RegisterCallback>:
(
  NVIC_SCU001_InterruptType IntID,
  NVIC_SCU001_CallbackType userFunction,
  uint32_t CbArgs
 )
{
 8009c04:	b480      	push	{r7}
 8009c06:	b087      	sub	sp, #28
 8009c08:	af00      	add	r7, sp, #0
 8009c0a:	4603      	mov	r3, r0
 8009c0c:	60b9      	str	r1, [r7, #8]
 8009c0e:	607a      	str	r2, [r7, #4]
 8009c10:	73fb      	strb	r3, [r7, #15]
  /*<<<DD_NVIC_SCU001_API_2>>>*/
  NVIC_SCU001_HandleType* Handle = &NVIC_SCU001_Handle0;
 8009c12:	f246 4364 	movw	r3, #25700	; 0x6464
 8009c16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009c1a:	617b      	str	r3, [r7, #20]
  DBG002_FUNCTION_ENTRY(APP_GID,NVIC_SCU001_FUNC_ENTRY);
  Handle->SCU[IntID].CbListener = userFunction;
 8009c1c:	7bfa      	ldrb	r2, [r7, #15]
 8009c1e:	697b      	ldr	r3, [r7, #20]
 8009c20:	68b9      	ldr	r1, [r7, #8]
 8009c22:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  Handle->SCU[IntID].CbArg = CbArgs;
 8009c26:	7bfb      	ldrb	r3, [r7, #15]
 8009c28:	697a      	ldr	r2, [r7, #20]
 8009c2a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8009c2e:	18d3      	adds	r3, r2, r3
 8009c30:	687a      	ldr	r2, [r7, #4]
 8009c32:	605a      	str	r2, [r3, #4]
   DBG002_FUNCTION_EXIT(APP_GID,NVIC_SCU001_FUNC_EXIT);
}
 8009c34:	f107 071c 	add.w	r7, r7, #28
 8009c38:	46bd      	mov	sp, r7
 8009c3a:	bc80      	pop	{r7}
 8009c3c:	4770      	bx	lr
 8009c3e:	bf00      	nop

08009c40 <SCU_0_IRQHandler>:

/*  SCU Interrupt Handler.
 * 
 */
void SCU_0_IRQHandler(void)
{
 8009c40:	b580      	push	{r7, lr}
 8009c42:	b084      	sub	sp, #16
 8009c44:	af00      	add	r7, sp, #0
  NVIC_SCU001_CallbackType UserCallback;
  NVIC_SCU001_HandleType* Handle = &NVIC_SCU001_Handle0;
 8009c46:	f246 4364 	movw	r3, #25700	; 0x6464
 8009c4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009c4e:	60fb      	str	r3, [r7, #12]
  uint32_t callbackArg = 0;
 8009c50:	f04f 0300 	mov.w	r3, #0
 8009c54:	60bb      	str	r3, [r7, #8]
  uint32_t IrqActive= 0;
 8009c56:	f04f 0300 	mov.w	r3, #0
 8009c5a:	607b      	str	r3, [r7, #4]
  /* read the interrupt status Register */
  IrqActive = SCU_INTERRUPT->SRSTAT;
 8009c5c:	f244 0374 	movw	r3, #16500	; 0x4074
 8009c60:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009c64:	681b      	ldr	r3, [r3, #0]
 8009c66:	607b      	str	r3, [r7, #4]
  
  
  /* WDT pre-warning Interrupt */
  if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_PRWARN_Msk, SCU_INTERRUPT_SRSTAT_PRWARN_Pos))
 8009c68:	687b      	ldr	r3, [r7, #4]
 8009c6a:	f003 0301 	and.w	r3, r3, #1
 8009c6e:	2b00      	cmp	r3, #0
 8009c70:	d019      	beq.n	8009ca6 <SCU_0_IRQHandler+0x66>
  {
    /* run the listener function */
    if(Handle->SCU[NVIC_SCU001_PRWARN].CbListener != NULL)
 8009c72:	68fb      	ldr	r3, [r7, #12]
 8009c74:	681b      	ldr	r3, [r3, #0]
 8009c76:	2b00      	cmp	r3, #0
 8009c78:	d008      	beq.n	8009c8c <SCU_0_IRQHandler+0x4c>
    {
      UserCallback = Handle->SCU[NVIC_SCU001_PRWARN].CbListener;
 8009c7a:	68fb      	ldr	r3, [r7, #12]
 8009c7c:	681b      	ldr	r3, [r3, #0]
 8009c7e:	603b      	str	r3, [r7, #0]
      callbackArg = Handle->SCU[NVIC_SCU001_PRWARN].CbArg;
 8009c80:	68fb      	ldr	r3, [r7, #12]
 8009c82:	685b      	ldr	r3, [r3, #4]
 8009c84:	60bb      	str	r3, [r7, #8]
      UserCallback(callbackArg);
 8009c86:	683b      	ldr	r3, [r7, #0]
 8009c88:	68b8      	ldr	r0, [r7, #8]
 8009c8a:	4798      	blx	r3
    }
    /* clear the interrupt */
    SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_PRWARN_Msk;
 8009c8c:	f244 0374 	movw	r3, #16500	; 0x4074
 8009c90:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009c94:	f244 0274 	movw	r2, #16500	; 0x4074
 8009c98:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009c9c:	68d2      	ldr	r2, [r2, #12]
 8009c9e:	f042 0201 	orr.w	r2, r2, #1
 8009ca2:	60da      	str	r2, [r3, #12]
 8009ca4:	e211      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
  }
  /* RTC Periodic Interrupt */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_PI_Msk, SCU_INTERRUPT_SRSTAT_PI_Pos))
 8009ca6:	687b      	ldr	r3, [r7, #4]
 8009ca8:	f003 0302 	and.w	r3, r3, #2
 8009cac:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8009cb0:	2b00      	cmp	r3, #0
 8009cb2:	d019      	beq.n	8009ce8 <SCU_0_IRQHandler+0xa8>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_PI].CbListener != NULL)
 8009cb4:	68fb      	ldr	r3, [r7, #12]
 8009cb6:	689b      	ldr	r3, [r3, #8]
 8009cb8:	2b00      	cmp	r3, #0
 8009cba:	d008      	beq.n	8009cce <SCU_0_IRQHandler+0x8e>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_PI].CbListener;
 8009cbc:	68fb      	ldr	r3, [r7, #12]
 8009cbe:	689b      	ldr	r3, [r3, #8]
 8009cc0:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_PI].CbArg;
 8009cc2:	68fb      	ldr	r3, [r7, #12]
 8009cc4:	68db      	ldr	r3, [r3, #12]
 8009cc6:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009cc8:	683b      	ldr	r3, [r7, #0]
 8009cca:	68b8      	ldr	r0, [r7, #8]
 8009ccc:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_PI_Msk;
 8009cce:	f244 0374 	movw	r3, #16500	; 0x4074
 8009cd2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009cd6:	f244 0274 	movw	r2, #16500	; 0x4074
 8009cda:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009cde:	68d2      	ldr	r2, [r2, #12]
 8009ce0:	f042 0202 	orr.w	r2, r2, #2
 8009ce4:	60da      	str	r2, [r3, #12]
 8009ce6:	e1f0      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
  }
  /* RTC Alarm Interrupt  */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_AI_Msk, SCU_INTERRUPT_SRSTAT_AI_Pos))
 8009ce8:	687b      	ldr	r3, [r7, #4]
 8009cea:	f003 0304 	and.w	r3, r3, #4
 8009cee:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8009cf2:	2b00      	cmp	r3, #0
 8009cf4:	d019      	beq.n	8009d2a <SCU_0_IRQHandler+0xea>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_AI].CbListener != NULL)
 8009cf6:	68fb      	ldr	r3, [r7, #12]
 8009cf8:	691b      	ldr	r3, [r3, #16]
 8009cfa:	2b00      	cmp	r3, #0
 8009cfc:	d008      	beq.n	8009d10 <SCU_0_IRQHandler+0xd0>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_AI].CbListener;
 8009cfe:	68fb      	ldr	r3, [r7, #12]
 8009d00:	691b      	ldr	r3, [r3, #16]
 8009d02:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_AI].CbArg;
 8009d04:	68fb      	ldr	r3, [r7, #12]
 8009d06:	695b      	ldr	r3, [r3, #20]
 8009d08:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009d0a:	683b      	ldr	r3, [r7, #0]
 8009d0c:	68b8      	ldr	r0, [r7, #8]
 8009d0e:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_AI_Msk;
 8009d10:	f244 0374 	movw	r3, #16500	; 0x4074
 8009d14:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009d18:	f244 0274 	movw	r2, #16500	; 0x4074
 8009d1c:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009d20:	68d2      	ldr	r2, [r2, #12]
 8009d22:	f042 0204 	orr.w	r2, r2, #4
 8009d26:	60da      	str	r2, [r3, #12]
 8009d28:	e1cf      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
  }
  /* DLR Request Overrun Interrupt  */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_DLROVR_Msk, SCU_INTERRUPT_SRSTAT_DLROVR_Pos))
 8009d2a:	687b      	ldr	r3, [r7, #4]
 8009d2c:	f003 0308 	and.w	r3, r3, #8
 8009d30:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8009d34:	2b00      	cmp	r3, #0
 8009d36:	d019      	beq.n	8009d6c <SCU_0_IRQHandler+0x12c>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_DLROVR].CbListener != NULL)
 8009d38:	68fb      	ldr	r3, [r7, #12]
 8009d3a:	699b      	ldr	r3, [r3, #24]
 8009d3c:	2b00      	cmp	r3, #0
 8009d3e:	d008      	beq.n	8009d52 <SCU_0_IRQHandler+0x112>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_DLROVR].CbListener;
 8009d40:	68fb      	ldr	r3, [r7, #12]
 8009d42:	699b      	ldr	r3, [r3, #24]
 8009d44:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_DLROVR].CbArg;
 8009d46:	68fb      	ldr	r3, [r7, #12]
 8009d48:	69db      	ldr	r3, [r3, #28]
 8009d4a:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009d4c:	683b      	ldr	r3, [r7, #0]
 8009d4e:	68b8      	ldr	r0, [r7, #8]
 8009d50:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_DLROVR_Msk;
 8009d52:	f244 0374 	movw	r3, #16500	; 0x4074
 8009d56:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009d5a:	f244 0274 	movw	r2, #16500	; 0x4074
 8009d5e:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009d62:	68d2      	ldr	r2, [r2, #12]
 8009d64:	f042 0208 	orr.w	r2, r2, #8
 8009d68:	60da      	str	r2, [r3, #12]
 8009d6a:	e1ae      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
  }
  /* HDSTAT Mirror Register Update Status  */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDSTAT_Msk, SCU_INTERRUPT_SRSTAT_HDSTAT_Pos))
 8009d6c:	687b      	ldr	r3, [r7, #4]
 8009d6e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8009d72:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8009d76:	2b00      	cmp	r3, #0
 8009d78:	d019      	beq.n	8009dae <SCU_0_IRQHandler+0x16e>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_HDSTAT].CbListener != NULL)
 8009d7a:	68fb      	ldr	r3, [r7, #12]
 8009d7c:	6a1b      	ldr	r3, [r3, #32]
 8009d7e:	2b00      	cmp	r3, #0
 8009d80:	d008      	beq.n	8009d94 <SCU_0_IRQHandler+0x154>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_HDSTAT].CbListener;
 8009d82:	68fb      	ldr	r3, [r7, #12]
 8009d84:	6a1b      	ldr	r3, [r3, #32]
 8009d86:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_HDSTAT].CbArg;
 8009d88:	68fb      	ldr	r3, [r7, #12]
 8009d8a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009d8c:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009d8e:	683b      	ldr	r3, [r7, #0]
 8009d90:	68b8      	ldr	r0, [r7, #8]
 8009d92:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDSTAT_Msk;
 8009d94:	f244 0374 	movw	r3, #16500	; 0x4074
 8009d98:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009d9c:	f244 0274 	movw	r2, #16500	; 0x4074
 8009da0:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009da4:	68d2      	ldr	r2, [r2, #12]
 8009da6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009daa:	60da      	str	r2, [r3, #12]
 8009dac:	e18d      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
  }
  /* HDCLR Mirror Register Update  */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDCLR_Msk, SCU_INTERRUPT_SRSTAT_HDCLR_Pos))
 8009dae:	687b      	ldr	r3, [r7, #4]
 8009db0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009db4:	ea4f 4353 	mov.w	r3, r3, lsr #17
 8009db8:	2b00      	cmp	r3, #0
 8009dba:	d019      	beq.n	8009df0 <SCU_0_IRQHandler+0x1b0>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_HDCLR].CbListener != NULL)
 8009dbc:	68fb      	ldr	r3, [r7, #12]
 8009dbe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009dc0:	2b00      	cmp	r3, #0
 8009dc2:	d008      	beq.n	8009dd6 <SCU_0_IRQHandler+0x196>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_HDCLR].CbListener;
 8009dc4:	68fb      	ldr	r3, [r7, #12]
 8009dc6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009dc8:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_HDCLR].CbArg;
 8009dca:	68fb      	ldr	r3, [r7, #12]
 8009dcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009dce:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009dd0:	683b      	ldr	r3, [r7, #0]
 8009dd2:	68b8      	ldr	r0, [r7, #8]
 8009dd4:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDCLR_Msk;
 8009dd6:	f244 0374 	movw	r3, #16500	; 0x4074
 8009dda:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009dde:	f244 0274 	movw	r2, #16500	; 0x4074
 8009de2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009de6:	68d2      	ldr	r2, [r2, #12]
 8009de8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8009dec:	60da      	str	r2, [r3, #12]
 8009dee:	e16c      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  }
  /* HDSET Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDSET_Msk, SCU_INTERRUPT_SRSTAT_HDSET_Pos))
 8009df0:	687b      	ldr	r3, [r7, #4]
 8009df2:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8009df6:	ea4f 4393 	mov.w	r3, r3, lsr #18
 8009dfa:	2b00      	cmp	r3, #0
 8009dfc:	d019      	beq.n	8009e32 <SCU_0_IRQHandler+0x1f2>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_HDSET].CbListener != NULL)
 8009dfe:	68fb      	ldr	r3, [r7, #12]
 8009e00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009e02:	2b00      	cmp	r3, #0
 8009e04:	d008      	beq.n	8009e18 <SCU_0_IRQHandler+0x1d8>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_HDSET].CbListener;
 8009e06:	68fb      	ldr	r3, [r7, #12]
 8009e08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009e0a:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_HDSET].CbArg;
 8009e0c:	68fb      	ldr	r3, [r7, #12]
 8009e0e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009e10:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009e12:	683b      	ldr	r3, [r7, #0]
 8009e14:	68b8      	ldr	r0, [r7, #8]
 8009e16:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDSET_Msk;
 8009e18:	f244 0374 	movw	r3, #16500	; 0x4074
 8009e1c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009e20:	f244 0274 	movw	r2, #16500	; 0x4074
 8009e24:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009e28:	68d2      	ldr	r2, [r2, #12]
 8009e2a:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8009e2e:	60da      	str	r2, [r3, #12]
 8009e30:	e14b      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  } 
  /* HDCR Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDCR_Msk, SCU_INTERRUPT_SRSTAT_HDCR_Pos))
 8009e32:	687b      	ldr	r3, [r7, #4]
 8009e34:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8009e38:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 8009e3c:	2b00      	cmp	r3, #0
 8009e3e:	d019      	beq.n	8009e74 <SCU_0_IRQHandler+0x234>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_HDCR].CbListener != NULL)
 8009e40:	68fb      	ldr	r3, [r7, #12]
 8009e42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009e44:	2b00      	cmp	r3, #0
 8009e46:	d008      	beq.n	8009e5a <SCU_0_IRQHandler+0x21a>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_HDCR].CbListener;
 8009e48:	68fb      	ldr	r3, [r7, #12]
 8009e4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009e4c:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_HDCR].CbArg;
 8009e4e:	68fb      	ldr	r3, [r7, #12]
 8009e50:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009e52:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009e54:	683b      	ldr	r3, [r7, #0]
 8009e56:	68b8      	ldr	r0, [r7, #8]
 8009e58:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDCR_Msk;
 8009e5a:	f244 0374 	movw	r3, #16500	; 0x4074
 8009e5e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009e62:	f244 0274 	movw	r2, #16500	; 0x4074
 8009e66:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009e6a:	68d2      	ldr	r2, [r2, #12]
 8009e6c:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8009e70:	60da      	str	r2, [r3, #12]
 8009e72:	e12a      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  }
  /* OSCSICTRL Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_OSCSICTRL_Msk, SCU_INTERRUPT_SRSTAT_OSCSICTRL_Pos))
 8009e74:	687b      	ldr	r3, [r7, #4]
 8009e76:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009e7a:	ea4f 5353 	mov.w	r3, r3, lsr #21
 8009e7e:	2b00      	cmp	r3, #0
 8009e80:	d019      	beq.n	8009eb6 <SCU_0_IRQHandler+0x276>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_OSCSICTRL].CbListener != NULL)
 8009e82:	68fb      	ldr	r3, [r7, #12]
 8009e84:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009e86:	2b00      	cmp	r3, #0
 8009e88:	d008      	beq.n	8009e9c <SCU_0_IRQHandler+0x25c>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_OSCSICTRL].CbListener;
 8009e8a:	68fb      	ldr	r3, [r7, #12]
 8009e8c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009e8e:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_OSCSICTRL].CbArg;
 8009e90:	68fb      	ldr	r3, [r7, #12]
 8009e92:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009e94:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009e96:	683b      	ldr	r3, [r7, #0]
 8009e98:	68b8      	ldr	r0, [r7, #8]
 8009e9a:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_OSCSICTRL_Msk;
 8009e9c:	f244 0374 	movw	r3, #16500	; 0x4074
 8009ea0:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009ea4:	f244 0274 	movw	r2, #16500	; 0x4074
 8009ea8:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009eac:	68d2      	ldr	r2, [r2, #12]
 8009eae:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8009eb2:	60da      	str	r2, [r3, #12]
 8009eb4:	e109      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  } 
  /* OSCULSTAT Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_OSCULSTAT_Msk, SCU_INTERRUPT_SRSTAT_OSCULSTAT_Pos))
 8009eb6:	687b      	ldr	r3, [r7, #4]
 8009eb8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8009ebc:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8009ec0:	2b00      	cmp	r3, #0
 8009ec2:	d019      	beq.n	8009ef8 <SCU_0_IRQHandler+0x2b8>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_OSCULSTAT].CbListener != NULL)
 8009ec4:	68fb      	ldr	r3, [r7, #12]
 8009ec6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009ec8:	2b00      	cmp	r3, #0
 8009eca:	d008      	beq.n	8009ede <SCU_0_IRQHandler+0x29e>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_OSCULSTAT].CbListener;
 8009ecc:	68fb      	ldr	r3, [r7, #12]
 8009ece:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009ed0:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_OSCULSTAT].CbArg;
 8009ed2:	68fb      	ldr	r3, [r7, #12]
 8009ed4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8009ed6:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009ed8:	683b      	ldr	r3, [r7, #0]
 8009eda:	68b8      	ldr	r0, [r7, #8]
 8009edc:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_OSCULSTAT_Msk;
 8009ede:	f244 0374 	movw	r3, #16500	; 0x4074
 8009ee2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009ee6:	f244 0274 	movw	r2, #16500	; 0x4074
 8009eea:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009eee:	68d2      	ldr	r2, [r2, #12]
 8009ef0:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8009ef4:	60da      	str	r2, [r3, #12]
 8009ef6:	e0e8      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  }
  /* OSCULCTRL Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_OSCULCTRL_Msk, SCU_INTERRUPT_SRSTAT_OSCULCTRL_Pos))
 8009ef8:	687b      	ldr	r3, [r7, #4]
 8009efa:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8009efe:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 8009f02:	2b00      	cmp	r3, #0
 8009f04:	d019      	beq.n	8009f3a <SCU_0_IRQHandler+0x2fa>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_OSCULCTRL].CbListener != NULL)
 8009f06:	68fb      	ldr	r3, [r7, #12]
 8009f08:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009f0a:	2b00      	cmp	r3, #0
 8009f0c:	d008      	beq.n	8009f20 <SCU_0_IRQHandler+0x2e0>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_OSCULCTRL].CbListener;
 8009f0e:	68fb      	ldr	r3, [r7, #12]
 8009f10:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8009f12:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_OSCULCTRL].CbArg;
 8009f14:	68fb      	ldr	r3, [r7, #12]
 8009f16:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009f18:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009f1a:	683b      	ldr	r3, [r7, #0]
 8009f1c:	68b8      	ldr	r0, [r7, #8]
 8009f1e:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_OSCULCTRL_Msk;
 8009f20:	f244 0374 	movw	r3, #16500	; 0x4074
 8009f24:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009f28:	f244 0274 	movw	r2, #16500	; 0x4074
 8009f2c:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009f30:	68d2      	ldr	r2, [r2, #12]
 8009f32:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8009f36:	60da      	str	r2, [r3, #12]
 8009f38:	e0c7      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  } 
  /* RTC_CTR Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_CTR_Msk, SCU_INTERRUPT_SRSTAT_RTC_CTR_Pos))
 8009f3a:	687b      	ldr	r3, [r7, #4]
 8009f3c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8009f40:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8009f44:	2b00      	cmp	r3, #0
 8009f46:	d019      	beq.n	8009f7c <SCU_0_IRQHandler+0x33c>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_RTC_CTR].CbListener != NULL)
 8009f48:	68fb      	ldr	r3, [r7, #12]
 8009f4a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009f4c:	2b00      	cmp	r3, #0
 8009f4e:	d008      	beq.n	8009f62 <SCU_0_IRQHandler+0x322>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_RTC_CTR].CbListener;
 8009f50:	68fb      	ldr	r3, [r7, #12]
 8009f52:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009f54:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_RTC_CTR].CbArg;
 8009f56:	68fb      	ldr	r3, [r7, #12]
 8009f58:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8009f5a:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009f5c:	683b      	ldr	r3, [r7, #0]
 8009f5e:	68b8      	ldr	r0, [r7, #8]
 8009f60:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_CTR_Msk;
 8009f62:	f244 0374 	movw	r3, #16500	; 0x4074
 8009f66:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009f6a:	f244 0274 	movw	r2, #16500	; 0x4074
 8009f6e:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009f72:	68d2      	ldr	r2, [r2, #12]
 8009f74:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8009f78:	60da      	str	r2, [r3, #12]
 8009f7a:	e0a6      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  } 
  /* RTC_ATIM0 Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Msk, SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Pos))
 8009f7c:	687b      	ldr	r3, [r7, #4]
 8009f7e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8009f82:	ea4f 6353 	mov.w	r3, r3, lsr #25
 8009f86:	2b00      	cmp	r3, #0
 8009f88:	d019      	beq.n	8009fbe <SCU_0_IRQHandler+0x37e>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_RTC_ATIM0].CbListener != NULL)
 8009f8a:	68fb      	ldr	r3, [r7, #12]
 8009f8c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009f8e:	2b00      	cmp	r3, #0
 8009f90:	d008      	beq.n	8009fa4 <SCU_0_IRQHandler+0x364>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_RTC_ATIM0].CbListener;
 8009f92:	68fb      	ldr	r3, [r7, #12]
 8009f94:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009f96:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_RTC_ATIM0].CbArg;
 8009f98:	68fb      	ldr	r3, [r7, #12]
 8009f9a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8009f9c:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009f9e:	683b      	ldr	r3, [r7, #0]
 8009fa0:	68b8      	ldr	r0, [r7, #8]
 8009fa2:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk;
 8009fa4:	f244 0374 	movw	r3, #16500	; 0x4074
 8009fa8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009fac:	f244 0274 	movw	r2, #16500	; 0x4074
 8009fb0:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009fb4:	68d2      	ldr	r2, [r2, #12]
 8009fb6:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8009fba:	60da      	str	r2, [r3, #12]
 8009fbc:	e085      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  }
  /* RTC_ATIM1 Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Msk, SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Pos))
 8009fbe:	687b      	ldr	r3, [r7, #4]
 8009fc0:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8009fc4:	ea4f 6393 	mov.w	r3, r3, lsr #26
 8009fc8:	2b00      	cmp	r3, #0
 8009fca:	d019      	beq.n	800a000 <SCU_0_IRQHandler+0x3c0>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_RTC_ATIM1].CbListener != NULL)
 8009fcc:	68fb      	ldr	r3, [r7, #12]
 8009fce:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009fd0:	2b00      	cmp	r3, #0
 8009fd2:	d008      	beq.n	8009fe6 <SCU_0_IRQHandler+0x3a6>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_RTC_ATIM1].CbListener;
 8009fd4:	68fb      	ldr	r3, [r7, #12]
 8009fd6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009fd8:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_RTC_ATIM1].CbArg;
 8009fda:	68fb      	ldr	r3, [r7, #12]
 8009fdc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009fde:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 8009fe0:	683b      	ldr	r3, [r7, #0]
 8009fe2:	68b8      	ldr	r0, [r7, #8]
 8009fe4:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk;
 8009fe6:	f244 0374 	movw	r3, #16500	; 0x4074
 8009fea:	f2c5 0300 	movt	r3, #20480	; 0x5000
 8009fee:	f244 0274 	movw	r2, #16500	; 0x4074
 8009ff2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 8009ff6:	68d2      	ldr	r2, [r2, #12]
 8009ff8:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8009ffc:	60da      	str	r2, [r3, #12]
 8009ffe:	e064      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  }
  /* RTC_TIM0 Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_TIM0_Msk, SCU_INTERRUPT_SRSTAT_RTC_TIM0_Pos))
 800a000:	687b      	ldr	r3, [r7, #4]
 800a002:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800a006:	ea4f 63d3 	mov.w	r3, r3, lsr #27
 800a00a:	2b00      	cmp	r3, #0
 800a00c:	d019      	beq.n	800a042 <SCU_0_IRQHandler+0x402>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_RTC_TIM0].CbListener != NULL)
 800a00e:	68fb      	ldr	r3, [r7, #12]
 800a010:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a012:	2b00      	cmp	r3, #0
 800a014:	d008      	beq.n	800a028 <SCU_0_IRQHandler+0x3e8>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_RTC_TIM0].CbListener;
 800a016:	68fb      	ldr	r3, [r7, #12]
 800a018:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a01a:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_RTC_TIM0].CbArg;
 800a01c:	68fb      	ldr	r3, [r7, #12]
 800a01e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a020:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 800a022:	683b      	ldr	r3, [r7, #0]
 800a024:	68b8      	ldr	r0, [r7, #8]
 800a026:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk;
 800a028:	f244 0374 	movw	r3, #16500	; 0x4074
 800a02c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800a030:	f244 0274 	movw	r2, #16500	; 0x4074
 800a034:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800a038:	68d2      	ldr	r2, [r2, #12]
 800a03a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800a03e:	60da      	str	r2, [r3, #12]
 800a040:	e043      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  }
  /* RTC_TIM1 Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_TIM1_Msk, SCU_INTERRUPT_SRSTAT_RTC_TIM1_Pos))
 800a042:	687b      	ldr	r3, [r7, #4]
 800a044:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800a048:	ea4f 7313 	mov.w	r3, r3, lsr #28
 800a04c:	2b00      	cmp	r3, #0
 800a04e:	d019      	beq.n	800a084 <SCU_0_IRQHandler+0x444>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_RTC_TIM1].CbListener != NULL)
 800a050:	68fb      	ldr	r3, [r7, #12]
 800a052:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a054:	2b00      	cmp	r3, #0
 800a056:	d008      	beq.n	800a06a <SCU_0_IRQHandler+0x42a>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_RTC_TIM1].CbListener;
 800a058:	68fb      	ldr	r3, [r7, #12]
 800a05a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a05c:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_RTC_TIM1].CbArg;
 800a05e:	68fb      	ldr	r3, [r7, #12]
 800a060:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a062:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 800a064:	683b      	ldr	r3, [r7, #0]
 800a066:	68b8      	ldr	r0, [r7, #8]
 800a068:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk;
 800a06a:	f244 0374 	movw	r3, #16500	; 0x4074
 800a06e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800a072:	f244 0274 	movw	r2, #16500	; 0x4074
 800a076:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800a07a:	68d2      	ldr	r2, [r2, #12]
 800a07c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800a080:	60da      	str	r2, [r3, #12]
 800a082:	e022      	b.n	800a0ca <SCU_0_IRQHandler+0x48a>
	
  }
  /* Retention Memory Mirror Register Update Status */
  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RMX_Msk, SCU_INTERRUPT_SRSTAT_RMX_Pos))
 800a084:	687b      	ldr	r3, [r7, #4]
 800a086:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800a08a:	ea4f 7353 	mov.w	r3, r3, lsr #29
 800a08e:	2b00      	cmp	r3, #0
 800a090:	d01b      	beq.n	800a0ca <SCU_0_IRQHandler+0x48a>
  {
	/* run the listener function */
	if(Handle->SCU[NVIC_SCU001_RMX].CbListener != NULL)
 800a092:	68fb      	ldr	r3, [r7, #12]
 800a094:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800a098:	2b00      	cmp	r3, #0
 800a09a:	d00a      	beq.n	800a0b2 <SCU_0_IRQHandler+0x472>
	{
	  UserCallback = Handle->SCU[NVIC_SCU001_RMX].CbListener;
 800a09c:	68fb      	ldr	r3, [r7, #12]
 800a09e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800a0a2:	603b      	str	r3, [r7, #0]
	  callbackArg = Handle->SCU[NVIC_SCU001_RMX].CbArg;
 800a0a4:	68fb      	ldr	r3, [r7, #12]
 800a0a6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800a0aa:	60bb      	str	r3, [r7, #8]
	  UserCallback(callbackArg);
 800a0ac:	683b      	ldr	r3, [r7, #0]
 800a0ae:	68b8      	ldr	r0, [r7, #8]
 800a0b0:	4798      	blx	r3
	}
	/* clear the interrupt */
	SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RMX_Msk;
 800a0b2:	f244 0374 	movw	r3, #16500	; 0x4074
 800a0b6:	f2c5 0300 	movt	r3, #20480	; 0x5000
 800a0ba:	f244 0274 	movw	r2, #16500	; 0x4074
 800a0be:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800a0c2:	68d2      	ldr	r2, [r2, #12]
 800a0c4:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800a0c8:	60da      	str	r2, [r3, #12]
     * properly or this function is being called unnecessarily.
     */
  }
  
  
}
 800a0ca:	f107 0710 	add.w	r7, r7, #16
 800a0ce:	46bd      	mov	sp, r7
 800a0d0:	bd80      	pop	{r7, pc}
 800a0d2:	bf00      	nop

0800a0d4 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 800a0d4:	b480      	push	{r7}
 800a0d6:	af00      	add	r7, sp, #0
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 800a0d8:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800a0dc:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a0e0:	68db      	ldr	r3, [r3, #12]
 800a0e2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800a0e6:	ea4f 2313 	mov.w	r3, r3, lsr #8
}
 800a0ea:	4618      	mov	r0, r3
 800a0ec:	46bd      	mov	sp, r7
 800a0ee:	bc80      	pop	{r7}
 800a0f0:	4770      	bx	lr
 800a0f2:	bf00      	nop

0800a0f4 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800a0f4:	b480      	push	{r7}
 800a0f6:	b083      	sub	sp, #12
 800a0f8:	af00      	add	r7, sp, #0
 800a0fa:	4603      	mov	r3, r0
 800a0fc:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 800a0fe:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800a102:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a106:	f997 2007 	ldrsb.w	r2, [r7, #7]
 800a10a:	ea4f 1252 	mov.w	r2, r2, lsr #5
 800a10e:	79f9      	ldrb	r1, [r7, #7]
 800a110:	f001 011f 	and.w	r1, r1, #31
 800a114:	f04f 0001 	mov.w	r0, #1
 800a118:	fa00 f101 	lsl.w	r1, r0, r1
 800a11c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 800a120:	f107 070c 	add.w	r7, r7, #12
 800a124:	46bd      	mov	sp, r7
 800a126:	bc80      	pop	{r7}
 800a128:	4770      	bx	lr
 800a12a:	bf00      	nop

0800a12c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800a12c:	b480      	push	{r7}
 800a12e:	b083      	sub	sp, #12
 800a130:	af00      	add	r7, sp, #0
 800a132:	4603      	mov	r3, r0
 800a134:	6039      	str	r1, [r7, #0]
 800a136:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 800a138:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800a13c:	2b00      	cmp	r3, #0
 800a13e:	da10      	bge.n	800a162 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 800a140:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800a144:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a148:	79fa      	ldrb	r2, [r7, #7]
 800a14a:	f002 020f 	and.w	r2, r2, #15
 800a14e:	f1a2 0104 	sub.w	r1, r2, #4
 800a152:	683a      	ldr	r2, [r7, #0]
 800a154:	b2d2      	uxtb	r2, r2
 800a156:	ea4f 0282 	mov.w	r2, r2, lsl #2
 800a15a:	b2d2      	uxtb	r2, r2
 800a15c:	185b      	adds	r3, r3, r1
 800a15e:	761a      	strb	r2, [r3, #24]
 800a160:	e00d      	b.n	800a17e <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 800a162:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800a166:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800a16a:	f997 1007 	ldrsb.w	r1, [r7, #7]
 800a16e:	683a      	ldr	r2, [r7, #0]
 800a170:	b2d2      	uxtb	r2, r2
 800a172:	ea4f 0282 	mov.w	r2, r2, lsl #2
 800a176:	b2d2      	uxtb	r2, r2
 800a178:	185b      	adds	r3, r3, r1
 800a17a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800a17e:	f107 070c 	add.w	r7, r7, #12
 800a182:	46bd      	mov	sp, r7
 800a184:	bc80      	pop	{r7}
 800a186:	4770      	bx	lr

0800a188 <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800a188:	b480      	push	{r7}
 800a18a:	b089      	sub	sp, #36	; 0x24
 800a18c:	af00      	add	r7, sp, #0
 800a18e:	60f8      	str	r0, [r7, #12]
 800a190:	60b9      	str	r1, [r7, #8]
 800a192:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
 800a194:	68fb      	ldr	r3, [r7, #12]
 800a196:	f003 0307 	and.w	r3, r3, #7
 800a19a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 800a19c:	69fb      	ldr	r3, [r7, #28]
 800a19e:	f1c3 0307 	rsb	r3, r3, #7
 800a1a2:	2b06      	cmp	r3, #6
 800a1a4:	bf28      	it	cs
 800a1a6:	2306      	movcs	r3, #6
 800a1a8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 800a1aa:	69fb      	ldr	r3, [r7, #28]
 800a1ac:	f103 0306 	add.w	r3, r3, #6
 800a1b0:	2b06      	cmp	r3, #6
 800a1b2:	d903      	bls.n	800a1bc <NVIC_EncodePriority+0x34>
 800a1b4:	69fb      	ldr	r3, [r7, #28]
 800a1b6:	f103 33ff 	add.w	r3, r3, #4294967295
 800a1ba:	e001      	b.n	800a1c0 <NVIC_EncodePriority+0x38>
 800a1bc:	f04f 0300 	mov.w	r3, #0
 800a1c0:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 800a1c2:	69bb      	ldr	r3, [r7, #24]
 800a1c4:	f04f 0201 	mov.w	r2, #1
 800a1c8:	fa02 f303 	lsl.w	r3, r2, r3
 800a1cc:	f103 33ff 	add.w	r3, r3, #4294967295
 800a1d0:	461a      	mov	r2, r3
 800a1d2:	68bb      	ldr	r3, [r7, #8]
 800a1d4:	401a      	ands	r2, r3
 800a1d6:	697b      	ldr	r3, [r7, #20]
 800a1d8:	fa02 f203 	lsl.w	r2, r2, r3
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 800a1dc:	697b      	ldr	r3, [r7, #20]
 800a1de:	f04f 0101 	mov.w	r1, #1
 800a1e2:	fa01 f303 	lsl.w	r3, r1, r3
 800a1e6:	f103 33ff 	add.w	r3, r3, #4294967295
 800a1ea:	4619      	mov	r1, r3
 800a1ec:	687b      	ldr	r3, [r7, #4]
 800a1ee:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

  return (
 800a1f0:	4313      	orrs	r3, r2
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}
 800a1f2:	4618      	mov	r0, r3
 800a1f4:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800a1f8:	46bd      	mov	sp, r7
 800a1fa:	bc80      	pop	{r7}
 800a1fc:	4770      	bx	lr
 800a1fe:	bf00      	nop

0800a200 <NVIC002_EnableIRQ>:
 *    NVIC002_EnableIRQ(&NVIC002_Handle0);
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void NVIC002_EnableIRQ (const NVIC002_HandleType *const Handle) {
 800a200:	b580      	push	{r7, lr}
 800a202:	b082      	sub	sp, #8
 800a204:	af00      	add	r7, sp, #0
 800a206:	6078      	str	r0, [r7, #4]
    NVIC_EnableIRQ((IRQn_Type)(Handle->NodeID));
 800a208:	687b      	ldr	r3, [r7, #4]
 800a20a:	781b      	ldrb	r3, [r3, #0]
 800a20c:	b2db      	uxtb	r3, r3
 800a20e:	b25b      	sxtb	r3, r3
 800a210:	4618      	mov	r0, r3
 800a212:	f7ff ff6f 	bl	800a0f4 <NVIC_EnableIRQ>
}
 800a216:	f107 0708 	add.w	r7, r7, #8
 800a21a:	46bd      	mov	sp, r7
 800a21c:	bd80      	pop	{r7, pc}
 800a21e:	bf00      	nop

0800a220 <NVIC002_Init>:

/**  Function to initialize the NVIC node parameters based on 
 *  UI configuration.
 */
void NVIC002_Init(void)
{
 800a220:	b580      	push	{r7, lr}
 800a222:	b082      	sub	sp, #8
 800a224:	af00      	add	r7, sp, #0
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
 800a226:	f04f 0300 	mov.w	r3, #0
 800a22a:	607b      	str	r3, [r7, #4]
 800a22c:	e00d      	b.n	800a24a <NVIC002_Init+0x2a>
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
 800a22e:	f246 63cc 	movw	r3, #26316	; 0x66cc
 800a232:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a236:	687a      	ldr	r2, [r7, #4]
 800a238:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a23c:	4618      	mov	r0, r3
 800a23e:	f000 f80b 	bl	800a258 <NVIC002_lInit>
 *  UI configuration.
 */
void NVIC002_Init(void)
{
  uint32_t Count;
  for (Count = 0U; Count<(uint32_t)NVIC002_NUM_INSTANCES; Count++)
 800a242:	687b      	ldr	r3, [r7, #4]
 800a244:	f103 0301 	add.w	r3, r3, #1
 800a248:	607b      	str	r3, [r7, #4]
 800a24a:	687b      	ldr	r3, [r7, #4]
 800a24c:	2b00      	cmp	r3, #0
 800a24e:	d0ee      	beq.n	800a22e <NVIC002_Init+0xe>
  {
	  NVIC002_lInit(NVIC002_HandleArray[Count]);
  }
}
 800a250:	f107 0708 	add.w	r7, r7, #8
 800a254:	46bd      	mov	sp, r7
 800a256:	bd80      	pop	{r7, pc}

0800a258 <NVIC002_lInit>:

static void NVIC002_lInit(const NVIC002_HandleType * Handle)
{
 800a258:	b590      	push	{r4, r7, lr}
 800a25a:	b083      	sub	sp, #12
 800a25c:	af00      	add	r7, sp, #0
 800a25e:	6078      	str	r0, [r7, #4]
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
			             Handle->Priority);
	#else 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
 800a260:	687b      	ldr	r3, [r7, #4]
 800a262:	781b      	ldrb	r3, [r3, #0]
 800a264:	b2dc      	uxtb	r4, r3
 800a266:	f7ff ff35 	bl	800a0d4 <NVIC_GetPriorityGrouping>
 800a26a:	4601      	mov	r1, r0
			   	   	     NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
			   	   	     Handle->Priority,
 800a26c:	687b      	ldr	r3, [r7, #4]
 800a26e:	785b      	ldrb	r3, [r3, #1]
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
			             Handle->Priority);
	#else 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
 800a270:	461a      	mov	r2, r3
			   	   	     NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
			   	   	     Handle->Priority,
			   	   	     Handle->SubPriority));
 800a272:	687b      	ldr	r3, [r7, #4]
 800a274:	789b      	ldrb	r3, [r3, #2]
      Node App Instance <%=appInst%>  */
	#if (UC_FAMILY == XMC1) 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
			             Handle->Priority);
	#else 
	   NVIC_SetPriority((IRQn_Type)Handle->NodeID, 
 800a276:	4608      	mov	r0, r1
 800a278:	4611      	mov	r1, r2
 800a27a:	461a      	mov	r2, r3
 800a27c:	f7ff ff84 	bl	800a188 <NVIC_EncodePriority>
 800a280:	4603      	mov	r3, r0
 800a282:	b262      	sxtb	r2, r4
 800a284:	4610      	mov	r0, r2
 800a286:	4619      	mov	r1, r3
 800a288:	f7ff ff50 	bl	800a12c <NVIC_SetPriority>
			   	   	     NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
			   	   	     Handle->Priority,
			   	   	     Handle->SubPriority));
	#endif
	if(Handle->InterruptEnable == 1)
 800a28c:	687b      	ldr	r3, [r7, #4]
 800a28e:	78db      	ldrb	r3, [r3, #3]
 800a290:	2b01      	cmp	r3, #1
 800a292:	d102      	bne.n	800a29a <NVIC002_lInit+0x42>
	{
	   /* Enable Interrupt */
		NVIC002_EnableIRQ(Handle);
 800a294:	6878      	ldr	r0, [r7, #4]
 800a296:	f7ff ffb3 	bl	800a200 <NVIC002_EnableIRQ>
	}
   
}
 800a29a:	f107 070c 	add.w	r7, r7, #12
 800a29e:	46bd      	mov	sp, r7
 800a2a0:	bd90      	pop	{r4, r7, pc}
 800a2a2:	bf00      	nop

0800a2a4 <LMM001_lblocks>:
  return( NULL );
}
#endif
// ----------------------------------------------------------------------------

static uint16_t LMM001_lblocks( uint32_t size ) {
 800a2a4:	b480      	push	{r7}
 800a2a6:	b083      	sub	sp, #12
 800a2a8:	af00      	add	r7, sp, #0
 800a2aa:	6078      	str	r0, [r7, #4]
  //
  // When a block removed from the free list, the space used by the free
  // pointers is available for data. That's what the first calculation
  // of size is doing.

  if( size <= (sizeof(((LMM001_BlockType *)0)->body)) )
 800a2ac:	687b      	ldr	r3, [r7, #4]
 800a2ae:	2b04      	cmp	r3, #4
 800a2b0:	d802      	bhi.n	800a2b8 <LMM001_lblocks+0x14>
    return( 1 );
 800a2b2:	f04f 0301 	mov.w	r3, #1
 800a2b6:	e00a      	b.n	800a2ce <LMM001_lblocks+0x2a>

  // If it's for more than that, then we need to figure out the number of
  // additional whole blocks the size of an LMM001_BlockType are required.

  size -= ( 1 + (sizeof(((LMM001_BlockType *)0)->body)) );
 800a2b8:	687b      	ldr	r3, [r7, #4]
 800a2ba:	f1a3 0305 	sub.w	r3, r3, #5
 800a2be:	607b      	str	r3, [r7, #4]

  return( 2 + size/(sizeof(LMM001_BlockType)) );
 800a2c0:	687b      	ldr	r3, [r7, #4]
 800a2c2:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800a2c6:	b29b      	uxth	r3, r3
 800a2c8:	f103 0302 	add.w	r3, r3, #2
 800a2cc:	b29b      	uxth	r3, r3
}
 800a2ce:	4618      	mov	r0, r3
 800a2d0:	f107 070c 	add.w	r7, r7, #12
 800a2d4:	46bd      	mov	sp, r7
 800a2d6:	bc80      	pop	{r7}
 800a2d8:	4770      	bx	lr
 800a2da:	bf00      	nop

0800a2dc <LMM001_lmake_new_block>:
// ----------------------------------------------------------------------------

static void LMM001_lmake_new_block( LMM001_HandleType *HandlePtr,
								uint16_t c,
                                uint16_t blocks,
                                uint16_t freemask ) {
 800a2dc:	b480      	push	{r7}
 800a2de:	b085      	sub	sp, #20
 800a2e0:	af00      	add	r7, sp, #0
 800a2e2:	60f8      	str	r0, [r7, #12]
 800a2e4:	8179      	strh	r1, [r7, #10]
 800a2e6:	813a      	strh	r2, [r7, #8]
 800a2e8:	80fb      	strh	r3, [r7, #6]

     UMM_NBLOCK(HandlePtr,c+blocks) = UMM_NBLOCK(HandlePtr,c) & UMM_BLOCKNO_MASK;
 800a2ea:	68fb      	ldr	r3, [r7, #12]
 800a2ec:	681a      	ldr	r2, [r3, #0]
 800a2ee:	8979      	ldrh	r1, [r7, #10]
 800a2f0:	893b      	ldrh	r3, [r7, #8]
 800a2f2:	18cb      	adds	r3, r1, r3
 800a2f4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a2f8:	18d2      	adds	r2, r2, r3
 800a2fa:	68fb      	ldr	r3, [r7, #12]
 800a2fc:	6819      	ldr	r1, [r3, #0]
 800a2fe:	897b      	ldrh	r3, [r7, #10]
 800a300:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a304:	18cb      	adds	r3, r1, r3
 800a306:	881b      	ldrh	r3, [r3, #0]
 800a308:	b29b      	uxth	r3, r3
 800a30a:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a30e:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a312:	b29b      	uxth	r3, r3
 800a314:	8013      	strh	r3, [r2, #0]
     UMM_PBLOCK(HandlePtr,c+blocks) = c;
 800a316:	68fb      	ldr	r3, [r7, #12]
 800a318:	681a      	ldr	r2, [r3, #0]
 800a31a:	8979      	ldrh	r1, [r7, #10]
 800a31c:	893b      	ldrh	r3, [r7, #8]
 800a31e:	18cb      	adds	r3, r1, r3
 800a320:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a324:	18d3      	adds	r3, r2, r3
 800a326:	897a      	ldrh	r2, [r7, #10]
 800a328:	805a      	strh	r2, [r3, #2]

     UMM_PBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c) & UMM_BLOCKNO_MASK) = c+blocks;
 800a32a:	68fb      	ldr	r3, [r7, #12]
 800a32c:	681a      	ldr	r2, [r3, #0]
 800a32e:	68fb      	ldr	r3, [r7, #12]
 800a330:	6819      	ldr	r1, [r3, #0]
 800a332:	897b      	ldrh	r3, [r7, #10]
 800a334:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a338:	18cb      	adds	r3, r1, r3
 800a33a:	881b      	ldrh	r3, [r3, #0]
 800a33c:	b29b      	uxth	r3, r3
 800a33e:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a342:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a346:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a34a:	18d3      	adds	r3, r2, r3
 800a34c:	8979      	ldrh	r1, [r7, #10]
 800a34e:	893a      	ldrh	r2, [r7, #8]
 800a350:	188a      	adds	r2, r1, r2
 800a352:	b292      	uxth	r2, r2
 800a354:	805a      	strh	r2, [r3, #2]
     UMM_NBLOCK(HandlePtr,c)                                = (c+blocks) | freemask;
 800a356:	68fb      	ldr	r3, [r7, #12]
 800a358:	681a      	ldr	r2, [r3, #0]
 800a35a:	897b      	ldrh	r3, [r7, #10]
 800a35c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a360:	18d3      	adds	r3, r2, r3
 800a362:	8979      	ldrh	r1, [r7, #10]
 800a364:	893a      	ldrh	r2, [r7, #8]
 800a366:	188a      	adds	r2, r1, r2
 800a368:	b292      	uxth	r2, r2
 800a36a:	b291      	uxth	r1, r2
 800a36c:	88fa      	ldrh	r2, [r7, #6]
 800a36e:	430a      	orrs	r2, r1
 800a370:	b292      	uxth	r2, r2
 800a372:	b292      	uxth	r2, r2
 800a374:	801a      	strh	r2, [r3, #0]
}
 800a376:	f107 0714 	add.w	r7, r7, #20
 800a37a:	46bd      	mov	sp, r7
 800a37c:	bc80      	pop	{r7}
 800a37e:	4770      	bx	lr

0800a380 <LMM001_ldisconnect_from_free_list>:

// ----------------------------------------------------------------------------

static void LMM001_ldisconnect_from_free_list(LMM001_HandleType *HandlePtr, uint16_t c ) {
 800a380:	b480      	push	{r7}
 800a382:	b083      	sub	sp, #12
 800a384:	af00      	add	r7, sp, #0
 800a386:	6078      	str	r0, [r7, #4]
 800a388:	460b      	mov	r3, r1
 800a38a:	807b      	strh	r3, [r7, #2]
    // Disconnect this block from the FREE list

    UMM_NFREE(HandlePtr,UMM_PFREE(HandlePtr,c)) = UMM_NFREE(HandlePtr,c);
 800a38c:	687b      	ldr	r3, [r7, #4]
 800a38e:	681a      	ldr	r2, [r3, #0]
 800a390:	687b      	ldr	r3, [r7, #4]
 800a392:	6819      	ldr	r1, [r3, #0]
 800a394:	887b      	ldrh	r3, [r7, #2]
 800a396:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a39a:	18cb      	adds	r3, r1, r3
 800a39c:	88db      	ldrh	r3, [r3, #6]
 800a39e:	b29b      	uxth	r3, r3
 800a3a0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a3a4:	18d3      	adds	r3, r2, r3
 800a3a6:	687a      	ldr	r2, [r7, #4]
 800a3a8:	6811      	ldr	r1, [r2, #0]
 800a3aa:	887a      	ldrh	r2, [r7, #2]
 800a3ac:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800a3b0:	188a      	adds	r2, r1, r2
 800a3b2:	8892      	ldrh	r2, [r2, #4]
 800a3b4:	b292      	uxth	r2, r2
 800a3b6:	809a      	strh	r2, [r3, #4]
    UMM_PFREE(HandlePtr,UMM_NFREE(HandlePtr,c)) = UMM_PFREE(HandlePtr,c);
 800a3b8:	687b      	ldr	r3, [r7, #4]
 800a3ba:	681a      	ldr	r2, [r3, #0]
 800a3bc:	687b      	ldr	r3, [r7, #4]
 800a3be:	6819      	ldr	r1, [r3, #0]
 800a3c0:	887b      	ldrh	r3, [r7, #2]
 800a3c2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a3c6:	18cb      	adds	r3, r1, r3
 800a3c8:	889b      	ldrh	r3, [r3, #4]
 800a3ca:	b29b      	uxth	r3, r3
 800a3cc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a3d0:	18d3      	adds	r3, r2, r3
 800a3d2:	687a      	ldr	r2, [r7, #4]
 800a3d4:	6811      	ldr	r1, [r2, #0]
 800a3d6:	887a      	ldrh	r2, [r7, #2]
 800a3d8:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800a3dc:	188a      	adds	r2, r1, r2
 800a3de:	88d2      	ldrh	r2, [r2, #6]
 800a3e0:	b292      	uxth	r2, r2
 800a3e2:	80da      	strh	r2, [r3, #6]

    // And clear the free block indicator

    UMM_NBLOCK(HandlePtr,c) &= (~UMM_FREELIST_MASK);
 800a3e4:	687b      	ldr	r3, [r7, #4]
 800a3e6:	681a      	ldr	r2, [r3, #0]
 800a3e8:	887b      	ldrh	r3, [r7, #2]
 800a3ea:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a3ee:	18d2      	adds	r2, r2, r3
 800a3f0:	687b      	ldr	r3, [r7, #4]
 800a3f2:	6819      	ldr	r1, [r3, #0]
 800a3f4:	887b      	ldrh	r3, [r7, #2]
 800a3f6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a3fa:	18cb      	adds	r3, r1, r3
 800a3fc:	881b      	ldrh	r3, [r3, #0]
 800a3fe:	b29b      	uxth	r3, r3
 800a400:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a404:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a408:	b29b      	uxth	r3, r3
 800a40a:	8013      	strh	r3, [r2, #0]
}
 800a40c:	f107 070c 	add.w	r7, r7, #12
 800a410:	46bd      	mov	sp, r7
 800a412:	bc80      	pop	{r7}
 800a414:	4770      	bx	lr
 800a416:	bf00      	nop

0800a418 <LMM001_l_assimilate_up>:

// ----------------------------------------------------------------------------



static void LMM001_l_assimilate_up(LMM001_HandleType *HandlePtr, uint16_t c ) {
 800a418:	b580      	push	{r7, lr}
 800a41a:	b082      	sub	sp, #8
 800a41c:	af00      	add	r7, sp, #0
 800a41e:	6078      	str	r0, [r7, #4]
 800a420:	460b      	mov	r3, r1
 800a422:	807b      	strh	r3, [r7, #2]

  if( UMM_NBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK ) {
 800a424:	687b      	ldr	r3, [r7, #4]
 800a426:	681a      	ldr	r2, [r3, #0]
 800a428:	687b      	ldr	r3, [r7, #4]
 800a42a:	6819      	ldr	r1, [r3, #0]
 800a42c:	887b      	ldrh	r3, [r7, #2]
 800a42e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a432:	18cb      	adds	r3, r1, r3
 800a434:	881b      	ldrh	r3, [r3, #0]
 800a436:	b29b      	uxth	r3, r3
 800a438:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a43c:	18d3      	adds	r3, r2, r3
 800a43e:	881b      	ldrh	r3, [r3, #0]
 800a440:	b29b      	uxth	r3, r3
 800a442:	b29b      	uxth	r3, r3
 800a444:	b21b      	sxth	r3, r3
 800a446:	2b00      	cmp	r3, #0
 800a448:	da40      	bge.n	800a4cc <LMM001_l_assimilate_up+0xb4>
#ifdef LMM001_DEBUG
    DBG_LOG_DEBUG( "Assimilate up to next block, which is FREE\n" );
#endif
    // Disconnect the next block from the FREE list

    LMM001_ldisconnect_from_free_list( HandlePtr,UMM_NBLOCK(HandlePtr,c) );
 800a44a:	687b      	ldr	r3, [r7, #4]
 800a44c:	681a      	ldr	r2, [r3, #0]
 800a44e:	887b      	ldrh	r3, [r7, #2]
 800a450:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a454:	18d3      	adds	r3, r2, r3
 800a456:	881b      	ldrh	r3, [r3, #0]
 800a458:	b29b      	uxth	r3, r3
 800a45a:	6878      	ldr	r0, [r7, #4]
 800a45c:	4619      	mov	r1, r3
 800a45e:	f7ff ff8f 	bl	800a380 <LMM001_ldisconnect_from_free_list>

    // Assimilate the next block with this one

    UMM_PBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) & UMM_BLOCKNO_MASK) = c;
 800a462:	687b      	ldr	r3, [r7, #4]
 800a464:	681a      	ldr	r2, [r3, #0]
 800a466:	687b      	ldr	r3, [r7, #4]
 800a468:	6819      	ldr	r1, [r3, #0]
 800a46a:	687b      	ldr	r3, [r7, #4]
 800a46c:	6818      	ldr	r0, [r3, #0]
 800a46e:	887b      	ldrh	r3, [r7, #2]
 800a470:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a474:	18c3      	adds	r3, r0, r3
 800a476:	881b      	ldrh	r3, [r3, #0]
 800a478:	b29b      	uxth	r3, r3
 800a47a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a47e:	18cb      	adds	r3, r1, r3
 800a480:	881b      	ldrh	r3, [r3, #0]
 800a482:	b29b      	uxth	r3, r3
 800a484:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a488:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a48c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a490:	18d3      	adds	r3, r2, r3
 800a492:	887a      	ldrh	r2, [r7, #2]
 800a494:	805a      	strh	r2, [r3, #2]
    UMM_NBLOCK(HandlePtr,c) = UMM_NBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) & UMM_BLOCKNO_MASK;
 800a496:	687b      	ldr	r3, [r7, #4]
 800a498:	681a      	ldr	r2, [r3, #0]
 800a49a:	887b      	ldrh	r3, [r7, #2]
 800a49c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a4a0:	18d2      	adds	r2, r2, r3
 800a4a2:	687b      	ldr	r3, [r7, #4]
 800a4a4:	6819      	ldr	r1, [r3, #0]
 800a4a6:	687b      	ldr	r3, [r7, #4]
 800a4a8:	6818      	ldr	r0, [r3, #0]
 800a4aa:	887b      	ldrh	r3, [r7, #2]
 800a4ac:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a4b0:	18c3      	adds	r3, r0, r3
 800a4b2:	881b      	ldrh	r3, [r3, #0]
 800a4b4:	b29b      	uxth	r3, r3
 800a4b6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a4ba:	18cb      	adds	r3, r1, r3
 800a4bc:	881b      	ldrh	r3, [r3, #0]
 800a4be:	b29b      	uxth	r3, r3
 800a4c0:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a4c4:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a4c8:	b29b      	uxth	r3, r3
 800a4ca:	8013      	strh	r3, [r2, #0]
  } 
}
 800a4cc:	f107 0708 	add.w	r7, r7, #8
 800a4d0:	46bd      	mov	sp, r7
 800a4d2:	bd80      	pop	{r7, pc}

0800a4d4 <LMM001_l_assimilate_down>:

// ----------------------------------------------------------------------------

static uint16_t LMM001_l_assimilate_down( LMM001_HandleType *HandlePtr,uint16_t c, uint16_t freemask ) {
 800a4d4:	b480      	push	{r7}
 800a4d6:	b083      	sub	sp, #12
 800a4d8:	af00      	add	r7, sp, #0
 800a4da:	6078      	str	r0, [r7, #4]
 800a4dc:	4613      	mov	r3, r2
 800a4de:	460a      	mov	r2, r1
 800a4e0:	807a      	strh	r2, [r7, #2]
 800a4e2:	803b      	strh	r3, [r7, #0]

    UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) = UMM_NBLOCK(HandlePtr,c) | freemask;
 800a4e4:	687b      	ldr	r3, [r7, #4]
 800a4e6:	681a      	ldr	r2, [r3, #0]
 800a4e8:	687b      	ldr	r3, [r7, #4]
 800a4ea:	6819      	ldr	r1, [r3, #0]
 800a4ec:	887b      	ldrh	r3, [r7, #2]
 800a4ee:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a4f2:	18cb      	adds	r3, r1, r3
 800a4f4:	885b      	ldrh	r3, [r3, #2]
 800a4f6:	b29b      	uxth	r3, r3
 800a4f8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a4fc:	18d3      	adds	r3, r2, r3
 800a4fe:	687a      	ldr	r2, [r7, #4]
 800a500:	6811      	ldr	r1, [r2, #0]
 800a502:	887a      	ldrh	r2, [r7, #2]
 800a504:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800a508:	188a      	adds	r2, r1, r2
 800a50a:	8812      	ldrh	r2, [r2, #0]
 800a50c:	b291      	uxth	r1, r2
 800a50e:	883a      	ldrh	r2, [r7, #0]
 800a510:	430a      	orrs	r2, r1
 800a512:	b292      	uxth	r2, r2
 800a514:	801a      	strh	r2, [r3, #0]
    UMM_PBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) = UMM_PBLOCK(HandlePtr,c);
 800a516:	687b      	ldr	r3, [r7, #4]
 800a518:	681a      	ldr	r2, [r3, #0]
 800a51a:	687b      	ldr	r3, [r7, #4]
 800a51c:	6819      	ldr	r1, [r3, #0]
 800a51e:	887b      	ldrh	r3, [r7, #2]
 800a520:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a524:	18cb      	adds	r3, r1, r3
 800a526:	881b      	ldrh	r3, [r3, #0]
 800a528:	b29b      	uxth	r3, r3
 800a52a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a52e:	18d3      	adds	r3, r2, r3
 800a530:	687a      	ldr	r2, [r7, #4]
 800a532:	6811      	ldr	r1, [r2, #0]
 800a534:	887a      	ldrh	r2, [r7, #2]
 800a536:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800a53a:	188a      	adds	r2, r1, r2
 800a53c:	8852      	ldrh	r2, [r2, #2]
 800a53e:	b292      	uxth	r2, r2
 800a540:	805a      	strh	r2, [r3, #2]

    return( UMM_PBLOCK(HandlePtr,c) );
 800a542:	687b      	ldr	r3, [r7, #4]
 800a544:	681a      	ldr	r2, [r3, #0]
 800a546:	887b      	ldrh	r3, [r7, #2]
 800a548:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a54c:	18d3      	adds	r3, r2, r3
 800a54e:	885b      	ldrh	r3, [r3, #2]
 800a550:	b29b      	uxth	r3, r3
}
 800a552:	4618      	mov	r0, r3
 800a554:	f107 070c 	add.w	r7, r7, #12
 800a558:	46bd      	mov	sp, r7
 800a55a:	bc80      	pop	{r7}
 800a55c:	4770      	bx	lr
 800a55e:	bf00      	nop

0800a560 <LMM001_free>:
// ----------------------------------------------------------------------------
/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/
/* The function frees the memory.*/
void LMM001_free( LMM001_HandleType *HandlePtr,void *MemPtr ) {
 800a560:	b580      	push	{r7, lr}
 800a562:	b084      	sub	sp, #16
 800a564:	af00      	add	r7, sp, #0
 800a566:	6078      	str	r0, [r7, #4]
 800a568:	6039      	str	r1, [r7, #0]

  uint16_t c;

  // If we're being asked to free a NULL pointer, well that's just silly!

  if( (void *)0 == MemPtr ) {
 800a56a:	683b      	ldr	r3, [r7, #0]
 800a56c:	2b00      	cmp	r3, #0
 800a56e:	d065      	beq.n	800a63c <LMM001_free+0xdc>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800a570:	b672      	cpsid	i
  LMM001_CRITICAL_ENTRY();

  // Figure out which block we're in. Note the use of truncated division...


   c = (uint16_t)(((uint32_t)MemPtr- (uint32_t)(&(HandlePtr->umm_heap[0])))/sizeof(LMM001_BlockType));
 800a572:	683a      	ldr	r2, [r7, #0]
 800a574:	687b      	ldr	r3, [r7, #4]
 800a576:	681b      	ldr	r3, [r3, #0]
 800a578:	1ad3      	subs	r3, r2, r3
 800a57a:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800a57e:	81fb      	strh	r3, [r7, #14]

  DBG_LOG_DEBUG( "Freeing block %6i\n", c );

  // Now let's assimilate this block with the next one if possible.

  LMM001_l_assimilate_up(HandlePtr,c );
 800a580:	89fb      	ldrh	r3, [r7, #14]
 800a582:	6878      	ldr	r0, [r7, #4]
 800a584:	4619      	mov	r1, r3
 800a586:	f7ff ff47 	bl	800a418 <LMM001_l_assimilate_up>

  // Then assimilate with the previous block if possible

  if( UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK ) {
 800a58a:	687b      	ldr	r3, [r7, #4]
 800a58c:	681a      	ldr	r2, [r3, #0]
 800a58e:	687b      	ldr	r3, [r7, #4]
 800a590:	6819      	ldr	r1, [r3, #0]
 800a592:	89fb      	ldrh	r3, [r7, #14]
 800a594:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a598:	18cb      	adds	r3, r1, r3
 800a59a:	885b      	ldrh	r3, [r3, #2]
 800a59c:	b29b      	uxth	r3, r3
 800a59e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a5a2:	18d3      	adds	r3, r2, r3
 800a5a4:	881b      	ldrh	r3, [r3, #0]
 800a5a6:	b29b      	uxth	r3, r3
 800a5a8:	b29b      	uxth	r3, r3
 800a5aa:	b21b      	sxth	r3, r3
 800a5ac:	2b00      	cmp	r3, #0
 800a5ae:	da09      	bge.n	800a5c4 <LMM001_free+0x64>
#ifdef LMM001_DEBUG
    DBG_LOG_DEBUG( "Assimilate down to next block, which is FREE\n" );
#endif
    c = LMM001_l_assimilate_down(HandlePtr,c, UMM_FREELIST_MASK);
 800a5b0:	89fb      	ldrh	r3, [r7, #14]
 800a5b2:	6878      	ldr	r0, [r7, #4]
 800a5b4:	4619      	mov	r1, r3
 800a5b6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800a5ba:	f7ff ff8b 	bl	800a4d4 <LMM001_l_assimilate_down>
 800a5be:	4603      	mov	r3, r0
 800a5c0:	81fb      	strh	r3, [r7, #14]
 800a5c2:	e039      	b.n	800a638 <LMM001_free+0xd8>
    // The previous block is not a free block, so add this one to the head
    // of the free list
#ifdef LMM001_DEBUG
    DBG_LOG_DEBUG( "Just add to head of free list\n" );
#endif
    UMM_PFREE(HandlePtr,UMM_NFREE(HandlePtr,0)) = c;
 800a5c4:	687b      	ldr	r3, [r7, #4]
 800a5c6:	681a      	ldr	r2, [r3, #0]
 800a5c8:	687b      	ldr	r3, [r7, #4]
 800a5ca:	681b      	ldr	r3, [r3, #0]
 800a5cc:	889b      	ldrh	r3, [r3, #4]
 800a5ce:	b29b      	uxth	r3, r3
 800a5d0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a5d4:	18d3      	adds	r3, r2, r3
 800a5d6:	89fa      	ldrh	r2, [r7, #14]
 800a5d8:	80da      	strh	r2, [r3, #6]
    UMM_NFREE(HandlePtr,c)            = UMM_NFREE(HandlePtr,0);
 800a5da:	687b      	ldr	r3, [r7, #4]
 800a5dc:	681a      	ldr	r2, [r3, #0]
 800a5de:	89fb      	ldrh	r3, [r7, #14]
 800a5e0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a5e4:	18d3      	adds	r3, r2, r3
 800a5e6:	687a      	ldr	r2, [r7, #4]
 800a5e8:	6812      	ldr	r2, [r2, #0]
 800a5ea:	8892      	ldrh	r2, [r2, #4]
 800a5ec:	b292      	uxth	r2, r2
 800a5ee:	809a      	strh	r2, [r3, #4]
    UMM_PFREE(HandlePtr,c)            = 0;
 800a5f0:	687b      	ldr	r3, [r7, #4]
 800a5f2:	681a      	ldr	r2, [r3, #0]
 800a5f4:	89fb      	ldrh	r3, [r7, #14]
 800a5f6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a5fa:	18d3      	adds	r3, r2, r3
 800a5fc:	f04f 0200 	mov.w	r2, #0
 800a600:	719a      	strb	r2, [r3, #6]
 800a602:	f04f 0200 	mov.w	r2, #0
 800a606:	71da      	strb	r2, [r3, #7]
    UMM_NFREE(HandlePtr,0)            = c;
 800a608:	687b      	ldr	r3, [r7, #4]
 800a60a:	681b      	ldr	r3, [r3, #0]
 800a60c:	89fa      	ldrh	r2, [r7, #14]
 800a60e:	809a      	strh	r2, [r3, #4]

    UMM_NBLOCK(HandlePtr,c)          |= UMM_FREELIST_MASK;
 800a610:	687b      	ldr	r3, [r7, #4]
 800a612:	681a      	ldr	r2, [r3, #0]
 800a614:	89fb      	ldrh	r3, [r7, #14]
 800a616:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a61a:	18d2      	adds	r2, r2, r3
 800a61c:	687b      	ldr	r3, [r7, #4]
 800a61e:	6819      	ldr	r1, [r3, #0]
 800a620:	89fb      	ldrh	r3, [r7, #14]
 800a622:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a626:	18cb      	adds	r3, r1, r3
 800a628:	881b      	ldrh	r3, [r3, #0]
 800a62a:	b29b      	uxth	r3, r3
 800a62c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800a630:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 800a634:	b29b      	uxth	r3, r3
 800a636:	8013      	strh	r3, [r2, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800a638:	b662      	cpsie	i
 800a63a:	e000      	b.n	800a63e <LMM001_free+0xde>
  if( (void *)0 == MemPtr ) {
#ifdef LMM001_DEBUG
    DBG_LOG_DEBUG( "free a null pointer -> do nothing\n" );
#endif

  return;
 800a63c:	bf00      	nop
  }

  // Release the critical section...
  //
  LMM001_CRITICAL_EXIT();
}
 800a63e:	f107 0710 	add.w	r7, r7, #16
 800a642:	46bd      	mov	sp, r7
 800a644:	bd80      	pop	{r7, pc}
 800a646:	bf00      	nop

0800a648 <LMM001_malloc>:

// ----------------------------------------------------------------------------

/* The function allocates the memory.*/
void *LMM001_malloc( LMM001_HandleType * HandlePtr, uint32_t size ) {
 800a648:	b580      	push	{r7, lr}
 800a64a:	b086      	sub	sp, #24
 800a64c:	af00      	add	r7, sp, #0
 800a64e:	6078      	str	r0, [r7, #4]
 800a650:	6039      	str	r1, [r7, #0]

  uint16_t blocks;
  uint16_t blockSize = 0;
 800a652:	f04f 0300 	mov.w	r3, #0
 800a656:	82fb      	strh	r3, [r7, #22]
  // the very first thing we do is figure out if we're being asked to allocate
  // a size of 0 - and if we are we'll simply return a null pointer. if not
  // then reduce the size by 1 byte so that the subsequent calculations on
  // the number of blocks to allocate are easier...

  if( 0 == size ) {
 800a658:	683b      	ldr	r3, [r7, #0]
 800a65a:	2b00      	cmp	r3, #0
 800a65c:	d102      	bne.n	800a664 <LMM001_malloc+0x1c>
#ifdef LMM001_DEBUG
    DBG_LOG_DEBUG( "malloc a block of 0 bytes -> do nothing\n" );
#endif
    return( (void *)NULL );
 800a65e:	f04f 0300 	mov.w	r3, #0
 800a662:	e0ed      	b.n	800a840 <LMM001_malloc+0x1f8>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800a664:	b672      	cpsid	i

  // Protect the critical section...
  //
  LMM001_CRITICAL_ENTRY();

  blocks = LMM001_lblocks( size );
 800a666:	6838      	ldr	r0, [r7, #0]
 800a668:	f7ff fe1c 	bl	800a2a4 <LMM001_lblocks>
 800a66c:	4603      	mov	r3, r0
 800a66e:	81fb      	strh	r3, [r7, #14]
  // enough to hold the number of blocks we need.
  //
  // This part may be customized to be a best-fit, worst-fit, or first-fit
  // algorithm

  cf = UMM_NFREE(HandlePtr,0);
 800a670:	687b      	ldr	r3, [r7, #4]
 800a672:	681b      	ldr	r3, [r3, #0]
 800a674:	791a      	ldrb	r2, [r3, #4]
 800a676:	795b      	ldrb	r3, [r3, #5]
 800a678:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a67c:	4313      	orrs	r3, r2
 800a67e:	823b      	strh	r3, [r7, #16]

  bestBlock = UMM_NFREE(HandlePtr,0);
 800a680:	687b      	ldr	r3, [r7, #4]
 800a682:	681b      	ldr	r3, [r3, #0]
 800a684:	791a      	ldrb	r2, [r3, #4]
 800a686:	795b      	ldrb	r3, [r3, #5]
 800a688:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a68c:	4313      	orrs	r3, r2
 800a68e:	827b      	strh	r3, [r7, #18]
  bestSize  = 0x7FFF;
 800a690:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800a694:	82bb      	strh	r3, [r7, #20]

  while( UMM_NFREE(HandlePtr,cf) ) {
 800a696:	e027      	b.n	800a6e8 <LMM001_malloc+0xa0>
    blockSize = (UMM_NBLOCK(HandlePtr,cf) & UMM_BLOCKNO_MASK) - cf;
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	681a      	ldr	r2, [r3, #0]
 800a69c:	8a3b      	ldrh	r3, [r7, #16]
 800a69e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a6a2:	18d3      	adds	r3, r2, r3
 800a6a4:	881b      	ldrh	r3, [r3, #0]
 800a6a6:	b29b      	uxth	r3, r3
 800a6a8:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a6ac:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a6b0:	b29a      	uxth	r2, r3
 800a6b2:	8a3b      	ldrh	r3, [r7, #16]
 800a6b4:	1ad3      	subs	r3, r2, r3
 800a6b6:	82fb      	strh	r3, [r7, #22]
#if defined UMM_FIRST_FIT
    // This is the first block that fits!
    if( (blockSize >= blocks) )
        break;
#elif defined UMM_BEST_FIT
    if( (blockSize >= blocks) && (blockSize < bestSize) ) {
 800a6b8:	8afa      	ldrh	r2, [r7, #22]
 800a6ba:	89fb      	ldrh	r3, [r7, #14]
 800a6bc:	429a      	cmp	r2, r3
 800a6be:	d307      	bcc.n	800a6d0 <LMM001_malloc+0x88>
 800a6c0:	8afa      	ldrh	r2, [r7, #22]
 800a6c2:	8abb      	ldrh	r3, [r7, #20]
 800a6c4:	429a      	cmp	r2, r3
 800a6c6:	d203      	bcs.n	800a6d0 <LMM001_malloc+0x88>
      bestBlock = cf;
 800a6c8:	8a3b      	ldrh	r3, [r7, #16]
 800a6ca:	827b      	strh	r3, [r7, #18]
      bestSize  = blockSize;
 800a6cc:	8afb      	ldrh	r3, [r7, #22]
 800a6ce:	82bb      	strh	r3, [r7, #20]
    }
#endif

    cf = UMM_NFREE(HandlePtr,cf);
 800a6d0:	687b      	ldr	r3, [r7, #4]
 800a6d2:	681a      	ldr	r2, [r3, #0]
 800a6d4:	8a3b      	ldrh	r3, [r7, #16]
 800a6d6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a6da:	18d3      	adds	r3, r2, r3
 800a6dc:	791a      	ldrb	r2, [r3, #4]
 800a6de:	795b      	ldrb	r3, [r3, #5]
 800a6e0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800a6e4:	4313      	orrs	r3, r2
 800a6e6:	823b      	strh	r3, [r7, #16]
  cf = UMM_NFREE(HandlePtr,0);

  bestBlock = UMM_NFREE(HandlePtr,0);
  bestSize  = 0x7FFF;

  while( UMM_NFREE(HandlePtr,cf) ) {
 800a6e8:	687b      	ldr	r3, [r7, #4]
 800a6ea:	681a      	ldr	r2, [r3, #0]
 800a6ec:	8a3b      	ldrh	r3, [r7, #16]
 800a6ee:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a6f2:	18d3      	adds	r3, r2, r3
 800a6f4:	889b      	ldrh	r3, [r3, #4]
 800a6f6:	b29b      	uxth	r3, r3
 800a6f8:	2b00      	cmp	r3, #0
 800a6fa:	d1cd      	bne.n	800a698 <LMM001_malloc+0x50>
#endif

    cf = UMM_NFREE(HandlePtr,cf);
  }

  if( 0x7FFF != bestSize ) {
 800a6fc:	8aba      	ldrh	r2, [r7, #20]
 800a6fe:	f647 73ff 	movw	r3, #32767	; 0x7fff
 800a702:	429a      	cmp	r2, r3
 800a704:	d003      	beq.n	800a70e <LMM001_malloc+0xc6>
    cf        = bestBlock;
 800a706:	8a7b      	ldrh	r3, [r7, #18]
 800a708:	823b      	strh	r3, [r7, #16]
    blockSize = bestSize;
 800a70a:	8abb      	ldrh	r3, [r7, #20]
 800a70c:	82fb      	strh	r3, [r7, #22]
  }

  if( UMM_NBLOCK(HandlePtr,cf) & UMM_BLOCKNO_MASK ) {
 800a70e:	687b      	ldr	r3, [r7, #4]
 800a710:	681a      	ldr	r2, [r3, #0]
 800a712:	8a3b      	ldrh	r3, [r7, #16]
 800a714:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a718:	18d3      	adds	r3, r2, r3
 800a71a:	881b      	ldrh	r3, [r3, #0]
 800a71c:	b29b      	uxth	r3, r3
 800a71e:	ea4f 4343 	mov.w	r3, r3, lsl #17
 800a722:	ea4f 4353 	mov.w	r3, r3, lsr #17
 800a726:	2b00      	cmp	r3, #0
 800a728:	d01d      	beq.n	800a766 <LMM001_malloc+0x11e>
    // This is an existing block in the memory heap, we just need to split off
    // what we need, unlink it from the free list and mark it as in use, and
    // link the rest of the block back into the freelist as if it was a new
    // block on the free list...

    if( blockSize == blocks ) {
 800a72a:	8afa      	ldrh	r2, [r7, #22]
 800a72c:	89fb      	ldrh	r3, [r7, #14]
 800a72e:	429a      	cmp	r2, r3
 800a730:	d105      	bne.n	800a73e <LMM001_malloc+0xf6>
      // It's an exact fit and we don't neet to split off a block.
      DBG_LOG_DEBUG( "Allocating %6i blocks starting at %6i - exact\n", blocks, cf );

      // Disconnect this block from the FREE list

      LMM001_ldisconnect_from_free_list(HandlePtr, cf );
 800a732:	8a3b      	ldrh	r3, [r7, #16]
 800a734:	6878      	ldr	r0, [r7, #4]
 800a736:	4619      	mov	r1, r3
 800a738:	f7ff fe22 	bl	800a380 <LMM001_ldisconnect_from_free_list>
 800a73c:	e077      	b.n	800a82e <LMM001_malloc+0x1e6>

    } else {
     // It's not an exact fit and we need to split off a block.
     DBG_LOG_DEBUG( "Allocating %6i blocks starting at %6i - existing\n", blocks, cf );

     LMM001_lmake_new_block( HandlePtr,cf, blockSize-blocks, UMM_FREELIST_MASK );
 800a73e:	8afa      	ldrh	r2, [r7, #22]
 800a740:	89fb      	ldrh	r3, [r7, #14]
 800a742:	1ad3      	subs	r3, r2, r3
 800a744:	b29b      	uxth	r3, r3
 800a746:	8a3a      	ldrh	r2, [r7, #16]
 800a748:	6878      	ldr	r0, [r7, #4]
 800a74a:	4611      	mov	r1, r2
 800a74c:	461a      	mov	r2, r3
 800a74e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800a752:	f7ff fdc3 	bl	800a2dc <LMM001_lmake_new_block>

     cf += blockSize-blocks;
 800a756:	8afa      	ldrh	r2, [r7, #22]
 800a758:	89fb      	ldrh	r3, [r7, #14]
 800a75a:	1ad3      	subs	r3, r2, r3
 800a75c:	b29a      	uxth	r2, r3
 800a75e:	8a3b      	ldrh	r3, [r7, #16]
 800a760:	18d3      	adds	r3, r2, r3
 800a762:	823b      	strh	r3, [r7, #16]
 800a764:	e063      	b.n	800a82e <LMM001_malloc+0x1e6>
  } else {
    // We're at the end of the heap - allocate a new block, but check to see if
    // there's enough memory left for the requested block! Actually, we may need
    // one more than that if we're initializing the umm_heap for the first
    // time, which happens in the next conditional...
	  if( HandlePtr->umm_numblocks <= cf+blocks+1 ) {
 800a766:	687b      	ldr	r3, [r7, #4]
 800a768:	889b      	ldrh	r3, [r3, #4]
 800a76a:	b29b      	uxth	r3, r3
 800a76c:	461a      	mov	r2, r3
 800a76e:	8a39      	ldrh	r1, [r7, #16]
 800a770:	89fb      	ldrh	r3, [r7, #14]
 800a772:	18cb      	adds	r3, r1, r3
 800a774:	f103 0301 	add.w	r3, r3, #1
 800a778:	429a      	cmp	r2, r3
 800a77a:	dc03      	bgt.n	800a784 <LMM001_malloc+0x13c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800a77c:	b662      	cpsie	i

      // Release the critical section...
      //
      LMM001_CRITICAL_EXIT();

      return( (void *)NULL );
 800a77e:	f04f 0300 	mov.w	r3, #0
 800a782:	e05d      	b.n	800a840 <LMM001_malloc+0x1f8>

    // Now check to see if we need to initialize the free list...this assumes
    // that the BSS is set to 0 on startup. We should rarely get to the end of
    // the free list so this is the "cheapest" place to put the initialization!

    if( 0 == cf ) {
 800a784:	8a3b      	ldrh	r3, [r7, #16]
 800a786:	2b00      	cmp	r3, #0
 800a788:	d116      	bne.n	800a7b8 <LMM001_malloc+0x170>
#ifdef LMM001_DEBUG
      DBG_LOG_DEBUG( "Initializing malloc free block pointer\n" );
#endif
      UMM_NBLOCK(HandlePtr,0) = 1;
 800a78a:	687b      	ldr	r3, [r7, #4]
 800a78c:	681b      	ldr	r3, [r3, #0]
 800a78e:	f04f 0200 	mov.w	r2, #0
 800a792:	f042 0201 	orr.w	r2, r2, #1
 800a796:	701a      	strb	r2, [r3, #0]
 800a798:	f04f 0200 	mov.w	r2, #0
 800a79c:	705a      	strb	r2, [r3, #1]
      UMM_NFREE(HandlePtr,0)  = 1;
 800a79e:	687b      	ldr	r3, [r7, #4]
 800a7a0:	681b      	ldr	r3, [r3, #0]
 800a7a2:	f04f 0200 	mov.w	r2, #0
 800a7a6:	f042 0201 	orr.w	r2, r2, #1
 800a7aa:	711a      	strb	r2, [r3, #4]
 800a7ac:	f04f 0200 	mov.w	r2, #0
 800a7b0:	715a      	strb	r2, [r3, #5]
      cf            = 1;
 800a7b2:	f04f 0301 	mov.w	r3, #1
 800a7b6:	823b      	strh	r3, [r7, #16]
    }

    DBG_LOG_DEBUG( "Allocating %6i blocks starting at %6i - new     \n", blocks, cf );

    UMM_NFREE(HandlePtr,UMM_PFREE(HandlePtr,cf)) = cf+blocks;
 800a7b8:	687b      	ldr	r3, [r7, #4]
 800a7ba:	681a      	ldr	r2, [r3, #0]
 800a7bc:	687b      	ldr	r3, [r7, #4]
 800a7be:	6819      	ldr	r1, [r3, #0]
 800a7c0:	8a3b      	ldrh	r3, [r7, #16]
 800a7c2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a7c6:	18cb      	adds	r3, r1, r3
 800a7c8:	88db      	ldrh	r3, [r3, #6]
 800a7ca:	b29b      	uxth	r3, r3
 800a7cc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a7d0:	18d3      	adds	r3, r2, r3
 800a7d2:	8a39      	ldrh	r1, [r7, #16]
 800a7d4:	89fa      	ldrh	r2, [r7, #14]
 800a7d6:	188a      	adds	r2, r1, r2
 800a7d8:	b292      	uxth	r2, r2
 800a7da:	809a      	strh	r2, [r3, #4]

    memcpy( &UMM_BLOCK(HandlePtr,cf+blocks), &UMM_BLOCK(HandlePtr,cf), sizeof(LMM001_BlockType) );
 800a7dc:	687b      	ldr	r3, [r7, #4]
 800a7de:	681a      	ldr	r2, [r3, #0]
 800a7e0:	8a39      	ldrh	r1, [r7, #16]
 800a7e2:	89fb      	ldrh	r3, [r7, #14]
 800a7e4:	18cb      	adds	r3, r1, r3
 800a7e6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a7ea:	18d2      	adds	r2, r2, r3
 800a7ec:	687b      	ldr	r3, [r7, #4]
 800a7ee:	6819      	ldr	r1, [r3, #0]
 800a7f0:	8a3b      	ldrh	r3, [r7, #16]
 800a7f2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a7f6:	18cb      	adds	r3, r1, r3
 800a7f8:	4610      	mov	r0, r2
 800a7fa:	4619      	mov	r1, r3
 800a7fc:	f04f 0208 	mov.w	r2, #8
 800a800:	f018 ff08 	bl	8023614 <memcpy>

    UMM_NBLOCK(HandlePtr,cf)           = cf+blocks;
 800a804:	687b      	ldr	r3, [r7, #4]
 800a806:	681a      	ldr	r2, [r3, #0]
 800a808:	8a3b      	ldrh	r3, [r7, #16]
 800a80a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a80e:	18d3      	adds	r3, r2, r3
 800a810:	8a39      	ldrh	r1, [r7, #16]
 800a812:	89fa      	ldrh	r2, [r7, #14]
 800a814:	188a      	adds	r2, r1, r2
 800a816:	b292      	uxth	r2, r2
 800a818:	801a      	strh	r2, [r3, #0]
    UMM_PBLOCK(HandlePtr,cf+blocks)    = cf;
 800a81a:	687b      	ldr	r3, [r7, #4]
 800a81c:	681a      	ldr	r2, [r3, #0]
 800a81e:	8a39      	ldrh	r1, [r7, #16]
 800a820:	89fb      	ldrh	r3, [r7, #14]
 800a822:	18cb      	adds	r3, r1, r3
 800a824:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a828:	18d3      	adds	r3, r2, r3
 800a82a:	8a3a      	ldrh	r2, [r7, #16]
 800a82c:	805a      	strh	r2, [r3, #2]
 800a82e:	b662      	cpsie	i

  // Release the critical section...
  //
  LMM001_CRITICAL_EXIT();

  return( (void *)&UMM_DATA(HandlePtr,cf) );
 800a830:	687b      	ldr	r3, [r7, #4]
 800a832:	681a      	ldr	r2, [r3, #0]
 800a834:	8a3b      	ldrh	r3, [r7, #16]
 800a836:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a83a:	18d3      	adds	r3, r2, r3
 800a83c:	f103 0304 	add.w	r3, r3, #4
}
 800a840:	4618      	mov	r0, r3
 800a842:	f107 0718 	add.w	r7, r7, #24
 800a846:	46bd      	mov	sp, r7
 800a848:	bd80      	pop	{r7, pc}
 800a84a:	bf00      	nop

0800a84c <LMM001_realloc>:

// ----------------------------------------------------------------------------

/* The function reallocates the memory.*/
void *LMM001_realloc(LMM001_HandleType *HandlePtr, void *MemPtr, uint32_t size ) {
 800a84c:	b580      	push	{r7, lr}
 800a84e:	b088      	sub	sp, #32
 800a850:	af00      	add	r7, sp, #0
 800a852:	60f8      	str	r0, [r7, #12]
 800a854:	60b9      	str	r1, [r7, #8]
 800a856:	607a      	str	r2, [r7, #4]
  // standard says that if MemPtr is NULL and size is non-zero, then we've
  // got to work the same a malloc(). If size is also 0, then our version
  // of malloc() returns a NULL pointer, which is OK as far as the ANSI C
  // standard is concerned.

  if( ((void *)NULL == MemPtr) ) {
 800a858:	68bb      	ldr	r3, [r7, #8]
 800a85a:	2b00      	cmp	r3, #0
 800a85c:	d105      	bne.n	800a86a <LMM001_realloc+0x1e>
#ifdef LMM001_DEBUG
    DBG_LOG_DEBUG( "realloc the NULL pointer - call malloc()\n" );
#endif
    return(LMM001_malloc(HandlePtr,size));
 800a85e:	68f8      	ldr	r0, [r7, #12]
 800a860:	6879      	ldr	r1, [r7, #4]
 800a862:	f7ff fef1 	bl	800a648 <LMM001_malloc>
 800a866:	4603      	mov	r3, r0
 800a868:	e0c6      	b.n	800a9f8 <LMM001_realloc+0x1ac>

  // Now we're sure that we have a non_NULL MemPtr, but we're not sure what
  // we should do with it. If the size is 0, then the ANSI C standard says that
  // we should operate the same as free.

  if( 0 == size ) {
 800a86a:	687b      	ldr	r3, [r7, #4]
 800a86c:	2b00      	cmp	r3, #0
 800a86e:	d106      	bne.n	800a87e <LMM001_realloc+0x32>
#ifdef LMM001_DEBUG
    DBG_LOG_DEBUG( "realloc to 0 size, just free the block\n" );
#endif
    LMM001_free(HandlePtr, MemPtr );
 800a870:	68f8      	ldr	r0, [r7, #12]
 800a872:	68b9      	ldr	r1, [r7, #8]
 800a874:	f7ff fe74 	bl	800a560 <LMM001_free>
    
    return( (void *)NULL );
 800a878:	f04f 0300 	mov.w	r3, #0
 800a87c:	e0bc      	b.n	800a9f8 <LMM001_realloc+0x1ac>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800a87e:	b672      	cpsid	i
  // to the new block, and then free the old block.
  //
  // While this will work, we end up doing a lot of possibly unnecessary
  // copying. So first, let's figure out how many blocks we'll need.

  blocks = LMM001_lblocks( size );
 800a880:	6878      	ldr	r0, [r7, #4]
 800a882:	f7ff fd0f 	bl	800a2a4 <LMM001_lblocks>
 800a886:	4603      	mov	r3, r0
 800a888:	83bb      	strh	r3, [r7, #28]

  // Figure out which block we're in. Note the use of truncated division...


  c = (uint16_t)(((uint32_t)MemPtr- (uint32_t)(&(HandlePtr->umm_heap[0])))/sizeof(LMM001_BlockType));
 800a88a:	68ba      	ldr	r2, [r7, #8]
 800a88c:	68fb      	ldr	r3, [r7, #12]
 800a88e:	681b      	ldr	r3, [r3, #0]
 800a890:	1ad3      	subs	r3, r2, r3
 800a892:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800a896:	83fb      	strh	r3, [r7, #30]
					  
  // Figure out how big this block is...

  blockSize = (UMM_NBLOCK(HandlePtr,c) - c);
 800a898:	68fb      	ldr	r3, [r7, #12]
 800a89a:	681a      	ldr	r2, [r3, #0]
 800a89c:	8bfb      	ldrh	r3, [r7, #30]
 800a89e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a8a2:	18d3      	adds	r3, r2, r3
 800a8a4:	881b      	ldrh	r3, [r3, #0]
 800a8a6:	b29a      	uxth	r2, r3
 800a8a8:	8bfb      	ldrh	r3, [r7, #30]
 800a8aa:	1ad3      	subs	r3, r2, r3
 800a8ac:	837b      	strh	r3, [r7, #26]

  // Figure out how many bytes are in this block
    
  curSize   = (blockSize*sizeof(LMM001_BlockType))-(sizeof(((LMM001_BlockType *)0)->header));
 800a8ae:	8b7b      	ldrh	r3, [r7, #26]
 800a8b0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a8b4:	f1a3 0304 	sub.w	r3, r3, #4
 800a8b8:	617b      	str	r3, [r7, #20]

  // Ok, now that we're here, we know the block number of the original chunk
  // of memory, and we know how much new memory we want, and we know the original
  // block size...

  if( blockSize == blocks ) {
 800a8ba:	8b7a      	ldrh	r2, [r7, #26]
 800a8bc:	8bbb      	ldrh	r3, [r7, #28]
 800a8be:	429a      	cmp	r2, r3
 800a8c0:	d102      	bne.n	800a8c8 <LMM001_realloc+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800a8c2:	b662      	cpsie	i

    // Release the critical section...
    //
    LMM001_CRITICAL_EXIT();

    return( MemPtr );
 800a8c4:	68bb      	ldr	r3, [r7, #8]
 800a8c6:	e097      	b.n	800a9f8 <LMM001_realloc+0x1ac>
  // way, try to assimilate up to the next block before doing anything...
  //
  // If it's still too small, we have to free it anyways and it will save the
  // assimilation step later in free :-)

  LMM001_l_assimilate_up(HandlePtr, c );
 800a8c8:	8bfb      	ldrh	r3, [r7, #30]
 800a8ca:	68f8      	ldr	r0, [r7, #12]
 800a8cc:	4619      	mov	r1, r3
 800a8ce:	f7ff fda3 	bl	800a418 <LMM001_l_assimilate_up>
  // Now check if it might help to assimilate down, but don't actually
  // do the downward assimilation unless the resulting block will hold the
  // new request! If this block of code runs, then the new block will
  // either fit the request exactly, or be larger than the request.

  if( (UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK) &&
 800a8d2:	68fb      	ldr	r3, [r7, #12]
 800a8d4:	681a      	ldr	r2, [r3, #0]
 800a8d6:	68fb      	ldr	r3, [r7, #12]
 800a8d8:	6819      	ldr	r1, [r3, #0]
 800a8da:	8bfb      	ldrh	r3, [r7, #30]
 800a8dc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a8e0:	18cb      	adds	r3, r1, r3
 800a8e2:	885b      	ldrh	r3, [r3, #2]
 800a8e4:	b29b      	uxth	r3, r3
 800a8e6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a8ea:	18d3      	adds	r3, r2, r3
 800a8ec:	881b      	ldrh	r3, [r3, #0]
 800a8ee:	b29b      	uxth	r3, r3
 800a8f0:	b29b      	uxth	r3, r3
 800a8f2:	b21b      	sxth	r3, r3
 800a8f4:	2b00      	cmp	r3, #0
 800a8f6:	da3f      	bge.n	800a978 <LMM001_realloc+0x12c>
      (blocks <= (UMM_NBLOCK(HandlePtr,c)-UMM_PBLOCK(HandlePtr,c)))    ) {
 800a8f8:	8bba      	ldrh	r2, [r7, #28]
 800a8fa:	68fb      	ldr	r3, [r7, #12]
 800a8fc:	6819      	ldr	r1, [r3, #0]
 800a8fe:	8bfb      	ldrh	r3, [r7, #30]
 800a900:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a904:	18cb      	adds	r3, r1, r3
 800a906:	881b      	ldrh	r3, [r3, #0]
 800a908:	b29b      	uxth	r3, r3
 800a90a:	4619      	mov	r1, r3
 800a90c:	68fb      	ldr	r3, [r7, #12]
 800a90e:	6818      	ldr	r0, [r3, #0]
 800a910:	8bfb      	ldrh	r3, [r7, #30]
 800a912:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a916:	18c3      	adds	r3, r0, r3
 800a918:	885b      	ldrh	r3, [r3, #2]
 800a91a:	b29b      	uxth	r3, r3
 800a91c:	1acb      	subs	r3, r1, r3
  // Now check if it might help to assimilate down, but don't actually
  // do the downward assimilation unless the resulting block will hold the
  // new request! If this block of code runs, then the new block will
  // either fit the request exactly, or be larger than the request.

  if( (UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK) &&
 800a91e:	429a      	cmp	r2, r3
 800a920:	dc2a      	bgt.n	800a978 <LMM001_realloc+0x12c>

    DBG_LOG_DEBUG( "realloc() could assimilate down %i blocks - fits!\n\r", c-UMM_PBLOCK(c) );

    // Disconnect the previous block from the FREE list

    LMM001_ldisconnect_from_free_list(HandlePtr, UMM_PBLOCK(HandlePtr,c) );
 800a922:	68fb      	ldr	r3, [r7, #12]
 800a924:	681a      	ldr	r2, [r3, #0]
 800a926:	8bfb      	ldrh	r3, [r7, #30]
 800a928:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a92c:	18d3      	adds	r3, r2, r3
 800a92e:	885b      	ldrh	r3, [r3, #2]
 800a930:	b29b      	uxth	r3, r3
 800a932:	68f8      	ldr	r0, [r7, #12]
 800a934:	4619      	mov	r1, r3
 800a936:	f7ff fd23 	bl	800a380 <LMM001_ldisconnect_from_free_list>

    // Connect the previous block to the next block ... and then
    // realign the current block pointer

    c = LMM001_l_assimilate_down(HandlePtr,c, 0);
 800a93a:	8bfb      	ldrh	r3, [r7, #30]
 800a93c:	68f8      	ldr	r0, [r7, #12]
 800a93e:	4619      	mov	r1, r3
 800a940:	f04f 0200 	mov.w	r2, #0
 800a944:	f7ff fdc6 	bl	800a4d4 <LMM001_l_assimilate_down>
 800a948:	4603      	mov	r3, r0
 800a94a:	83fb      	strh	r3, [r7, #30]

    // Move the bytes down to the new block we just created, but be sure to move
    // only the original bytes.

    memmove( (void *)&UMM_DATA(HandlePtr,c), MemPtr, curSize );
 800a94c:	68fb      	ldr	r3, [r7, #12]
 800a94e:	681a      	ldr	r2, [r3, #0]
 800a950:	8bfb      	ldrh	r3, [r7, #30]
 800a952:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a956:	18d3      	adds	r3, r2, r3
 800a958:	f103 0304 	add.w	r3, r3, #4
 800a95c:	4618      	mov	r0, r3
 800a95e:	68b9      	ldr	r1, [r7, #8]
 800a960:	697a      	ldr	r2, [r7, #20]
 800a962:	f018 fef9 	bl	8023758 <memmove>
 
    // And don't forget to adjust the pointer to the new block location!

    MemPtr    = (void *)&UMM_DATA(HandlePtr,c);
 800a966:	68fb      	ldr	r3, [r7, #12]
 800a968:	681a      	ldr	r2, [r3, #0]
 800a96a:	8bfb      	ldrh	r3, [r7, #30]
 800a96c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a970:	18d3      	adds	r3, r2, r3
 800a972:	f103 0304 	add.w	r3, r3, #4
 800a976:	60bb      	str	r3, [r7, #8]
  }

  // Now calculate the block size again...and we'll have three cases

  blockSize = (UMM_NBLOCK(HandlePtr,c) - c);
 800a978:	68fb      	ldr	r3, [r7, #12]
 800a97a:	681a      	ldr	r2, [r3, #0]
 800a97c:	8bfb      	ldrh	r3, [r7, #30]
 800a97e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a982:	18d3      	adds	r3, r2, r3
 800a984:	881b      	ldrh	r3, [r3, #0]
 800a986:	b29a      	uxth	r2, r3
 800a988:	8bfb      	ldrh	r3, [r7, #30]
 800a98a:	1ad3      	subs	r3, r2, r3
 800a98c:	837b      	strh	r3, [r7, #26]

  if( blockSize == blocks ) {
 800a98e:	8b7a      	ldrh	r2, [r7, #26]
 800a990:	8bbb      	ldrh	r3, [r7, #28]
 800a992:	429a      	cmp	r2, r3
 800a994:	d02e      	beq.n	800a9f4 <LMM001_realloc+0x1a8>
    // This space intentionally left blank - return the original pointer!

    DBG_LOG_DEBUG( "realloc the same size block - %i, do nothing\n", blocks );

  } else if (blockSize > blocks ) {
 800a996:	8b7a      	ldrh	r2, [r7, #26]
 800a998:	8bbb      	ldrh	r3, [r7, #28]
 800a99a:	429a      	cmp	r2, r3
 800a99c:	d917      	bls.n	800a9ce <LMM001_realloc+0x182>
    // New block is smaller than the old block, so just make a new block
    // at the end of this one and put it up on the free list...

    DBG_LOG_DEBUG( "realloc %i to a smaller block %i, shrink and free the leftover bits\n", blockSize, blocks );

    LMM001_lmake_new_block(HandlePtr, c, blocks, 0 );
 800a99e:	8bfa      	ldrh	r2, [r7, #30]
 800a9a0:	8bbb      	ldrh	r3, [r7, #28]
 800a9a2:	68f8      	ldr	r0, [r7, #12]
 800a9a4:	4611      	mov	r1, r2
 800a9a6:	461a      	mov	r2, r3
 800a9a8:	f04f 0300 	mov.w	r3, #0
 800a9ac:	f7ff fc96 	bl	800a2dc <LMM001_lmake_new_block>
    
    LMM001_free( HandlePtr,(void *)&UMM_DATA(HandlePtr,c+blocks) );
 800a9b0:	68fb      	ldr	r3, [r7, #12]
 800a9b2:	681a      	ldr	r2, [r3, #0]
 800a9b4:	8bf9      	ldrh	r1, [r7, #30]
 800a9b6:	8bbb      	ldrh	r3, [r7, #28]
 800a9b8:	18cb      	adds	r3, r1, r3
 800a9ba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a9be:	18d3      	adds	r3, r2, r3
 800a9c0:	f103 0304 	add.w	r3, r3, #4
 800a9c4:	68f8      	ldr	r0, [r7, #12]
 800a9c6:	4619      	mov	r1, r3
 800a9c8:	f7ff fdca 	bl	800a560 <LMM001_free>
 800a9cc:	e012      	b.n	800a9f4 <LMM001_realloc+0x1a8>
  } else {
    // New block is bigger than the old block...
    
    void *oldptr = MemPtr;
 800a9ce:	68bb      	ldr	r3, [r7, #8]
 800a9d0:	613b      	str	r3, [r7, #16]
    DBG_LOG_DEBUG( "realloc %i to a bigger block %i, make new, copy, and free the old\n", blockSize, blocks );

    // Now umm_malloc() a new/ one, copy the old data to the new block, and
    // free up the old block, but only if the malloc was sucessful!

    MemPtr = LMM001_malloc( HandlePtr,size );
 800a9d2:	68f8      	ldr	r0, [r7, #12]
 800a9d4:	6879      	ldr	r1, [r7, #4]
 800a9d6:	f7ff fe37 	bl	800a648 <LMM001_malloc>
 800a9da:	60b8      	str	r0, [r7, #8]
	if(MemPtr != NULL) {
 800a9dc:	68bb      	ldr	r3, [r7, #8]
 800a9de:	2b00      	cmp	r3, #0
 800a9e0:	d004      	beq.n	800a9ec <LMM001_realloc+0x1a0>
       memcpy( MemPtr, oldptr, curSize );
 800a9e2:	68b8      	ldr	r0, [r7, #8]
 800a9e4:	6939      	ldr	r1, [r7, #16]
 800a9e6:	697a      	ldr	r2, [r7, #20]
 800a9e8:	f018 fe14 	bl	8023614 <memcpy>
    }

    LMM001_free( HandlePtr,oldptr );
 800a9ec:	68f8      	ldr	r0, [r7, #12]
 800a9ee:	6939      	ldr	r1, [r7, #16]
 800a9f0:	f7ff fdb6 	bl	800a560 <LMM001_free>
 800a9f4:	b662      	cpsie	i

  // Release the critical section...
  //
  LMM001_CRITICAL_EXIT();

  return( MemPtr );
 800a9f6:	68bb      	ldr	r3, [r7, #8]
}
 800a9f8:	4618      	mov	r0, r3
 800a9fa:	f107 0720 	add.w	r7, r7, #32
 800a9fe:	46bd      	mov	sp, r7
 800aa00:	bd80      	pop	{r7, pc}
 800aa02:	bf00      	nop

0800aa04 <IO004_Init>:
/** @ingroup IO004_Func
 * @{
 */

void IO004_Init(void)
{
 800aa04:	b480      	push	{r7}
 800aa06:	af00      	add	r7, sp, #0
   /* <<<DD_IO004_API_1>>> */
 
   

  /* Configuration of 1 Port 0 based on User configuration */
  IO004_Handle0.PortRegs->OMR |= (1U<< 0);
 800aa08:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa0c:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa10:	685a      	ldr	r2, [r3, #4]
 800aa12:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa16:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa1a:	685b      	ldr	r3, [r3, #4]
 800aa1c:	685b      	ldr	r3, [r3, #4]
 800aa1e:	f043 0301 	orr.w	r3, r3, #1
 800aa22:	6053      	str	r3, [r2, #4]
  
  IO004_Handle0.PortRegs->PDR0   &= (uint32_t)(~(PORT1_PDR0_PD0_Msk));
 800aa24:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa28:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa2c:	685a      	ldr	r2, [r3, #4]
 800aa2e:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa32:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa36:	685b      	ldr	r3, [r3, #4]
 800aa38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800aa3a:	f023 0307 	bic.w	r3, r3, #7
 800aa3e:	6413      	str	r3, [r2, #64]	; 0x40
  IO004_Handle0.PortRegs->PDR0   |= (uint32_t)((4UL << PORT1_PDR0_PD0_Pos) & \
 800aa40:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa44:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa48:	685a      	ldr	r2, [r3, #4]
 800aa4a:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa4e:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa52:	685b      	ldr	r3, [r3, #4]
 800aa54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800aa56:	f043 0304 	orr.w	r3, r3, #4
 800aa5a:	6413      	str	r3, [r2, #64]	; 0x40
                                          PORT1_PDR0_PD0_Msk);
  IO004_Handle0.PortRegs->IOCR0 |= (0U << 3);
 800aa5c:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa60:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa64:	685a      	ldr	r2, [r3, #4]
 800aa66:	f246 6394 	movw	r3, #26260	; 0x6694
 800aa6a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aa6e:	685b      	ldr	r3, [r3, #4]
 800aa70:	691b      	ldr	r3, [r3, #16]
 800aa72:	6113      	str	r3, [r2, #16]
}
 800aa74:	46bd      	mov	sp, r7
 800aa76:	bc80      	pop	{r7}
 800aa78:	4770      	bx	lr
 800aa7a:	bf00      	nop

0800aa7c <IO004_DisableOutputDriver>:

void IO004_DisableOutputDriver(const IO004_HandleType* Handle,IO004_InputModeType Mode)
{
 800aa7c:	b480      	push	{r7}
 800aa7e:	b085      	sub	sp, #20
 800aa80:	af00      	add	r7, sp, #0
 800aa82:	6078      	str	r0, [r7, #4]
 800aa84:	460b      	mov	r3, r1
 800aa86:	70fb      	strb	r3, [r7, #3]
  uint8_t Pin = Handle->PortPin;
 800aa88:	687b      	ldr	r3, [r7, #4]
 800aa8a:	785b      	ldrb	r3, [r3, #1]
 800aa8c:	73fb      	strb	r3, [r7, #15]
  /* <<<DD_IO004_API_2>>> */
  if(Pin < 4U)
 800aa8e:	7bfb      	ldrb	r3, [r7, #15]
 800aa90:	2b03      	cmp	r3, #3
 800aa92:	d823      	bhi.n	800aadc <IO004_DisableOutputDriver+0x60>
  {
    Handle->PortRegs->IOCR0  =  (uint32_t)(Handle->PortRegs->IOCR0 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800aa94:	687b      	ldr	r3, [r7, #4]
 800aa96:	685b      	ldr	r3, [r3, #4]
 800aa98:	687a      	ldr	r2, [r7, #4]
 800aa9a:	6852      	ldr	r2, [r2, #4]
 800aa9c:	6911      	ldr	r1, [r2, #16]
 800aa9e:	7bfa      	ldrb	r2, [r7, #15]
 800aaa0:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800aaa4:	f102 0203 	add.w	r2, r2, #3
 800aaa8:	f04f 001f 	mov.w	r0, #31
 800aaac:	fa00 f202 	lsl.w	r2, r0, r2
 800aab0:	ea6f 0202 	mvn.w	r2, r2
 800aab4:	400a      	ands	r2, r1
 800aab6:	611a      	str	r2, [r3, #16]
    Handle->PortRegs->IOCR0 |= (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800aab8:	687b      	ldr	r3, [r7, #4]
 800aaba:	685b      	ldr	r3, [r3, #4]
 800aabc:	687a      	ldr	r2, [r7, #4]
 800aabe:	6852      	ldr	r2, [r2, #4]
 800aac0:	6911      	ldr	r1, [r2, #16]
 800aac2:	78fa      	ldrb	r2, [r7, #3]
 800aac4:	f002 001f 	and.w	r0, r2, #31
 800aac8:	7bfa      	ldrb	r2, [r7, #15]
 800aaca:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800aace:	f102 0203 	add.w	r2, r2, #3
 800aad2:	fa00 f202 	lsl.w	r2, r0, r2
 800aad6:	430a      	orrs	r2, r1
 800aad8:	611a      	str	r2, [r3, #16]
 800aada:	e088      	b.n	800abee <IO004_DisableOutputDriver+0x172>
  } else if ((Pin >= 4U) && (Pin <= 7U))
 800aadc:	7bfb      	ldrb	r3, [r7, #15]
 800aade:	2b03      	cmp	r3, #3
 800aae0:	d92a      	bls.n	800ab38 <IO004_DisableOutputDriver+0xbc>
 800aae2:	7bfb      	ldrb	r3, [r7, #15]
 800aae4:	2b07      	cmp	r3, #7
 800aae6:	d827      	bhi.n	800ab38 <IO004_DisableOutputDriver+0xbc>
  {
    Pin = Pin - 4U;
 800aae8:	7bfb      	ldrb	r3, [r7, #15]
 800aaea:	f1a3 0304 	sub.w	r3, r3, #4
 800aaee:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR4  =  (uint32_t)(Handle->PortRegs->IOCR4 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800aaf0:	687b      	ldr	r3, [r7, #4]
 800aaf2:	685b      	ldr	r3, [r3, #4]
 800aaf4:	687a      	ldr	r2, [r7, #4]
 800aaf6:	6852      	ldr	r2, [r2, #4]
 800aaf8:	6951      	ldr	r1, [r2, #20]
 800aafa:	7bfa      	ldrb	r2, [r7, #15]
 800aafc:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ab00:	f102 0203 	add.w	r2, r2, #3
 800ab04:	f04f 001f 	mov.w	r0, #31
 800ab08:	fa00 f202 	lsl.w	r2, r0, r2
 800ab0c:	ea6f 0202 	mvn.w	r2, r2
 800ab10:	400a      	ands	r2, r1
 800ab12:	615a      	str	r2, [r3, #20]
    Handle->PortRegs->IOCR4 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800ab14:	687b      	ldr	r3, [r7, #4]
 800ab16:	685b      	ldr	r3, [r3, #4]
 800ab18:	687a      	ldr	r2, [r7, #4]
 800ab1a:	6852      	ldr	r2, [r2, #4]
 800ab1c:	6951      	ldr	r1, [r2, #20]
 800ab1e:	78fa      	ldrb	r2, [r7, #3]
 800ab20:	f002 001f 	and.w	r0, r2, #31
 800ab24:	7bfa      	ldrb	r2, [r7, #15]
 800ab26:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ab2a:	f102 0203 	add.w	r2, r2, #3
 800ab2e:	fa00 f202 	lsl.w	r2, r0, r2
 800ab32:	430a      	orrs	r2, r1
 800ab34:	615a      	str	r2, [r3, #20]
 800ab36:	e05a      	b.n	800abee <IO004_DisableOutputDriver+0x172>
  } else if ((Pin >= 8U) && (Pin <= 11U))
 800ab38:	7bfb      	ldrb	r3, [r7, #15]
 800ab3a:	2b07      	cmp	r3, #7
 800ab3c:	d92a      	bls.n	800ab94 <IO004_DisableOutputDriver+0x118>
 800ab3e:	7bfb      	ldrb	r3, [r7, #15]
 800ab40:	2b0b      	cmp	r3, #11
 800ab42:	d827      	bhi.n	800ab94 <IO004_DisableOutputDriver+0x118>
  {
    Pin = Pin - 8U;
 800ab44:	7bfb      	ldrb	r3, [r7, #15]
 800ab46:	f1a3 0308 	sub.w	r3, r3, #8
 800ab4a:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR8  =  (uint32_t)(Handle->PortRegs->IOCR8 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800ab4c:	687b      	ldr	r3, [r7, #4]
 800ab4e:	685b      	ldr	r3, [r3, #4]
 800ab50:	687a      	ldr	r2, [r7, #4]
 800ab52:	6852      	ldr	r2, [r2, #4]
 800ab54:	6991      	ldr	r1, [r2, #24]
 800ab56:	7bfa      	ldrb	r2, [r7, #15]
 800ab58:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ab5c:	f102 0203 	add.w	r2, r2, #3
 800ab60:	f04f 001f 	mov.w	r0, #31
 800ab64:	fa00 f202 	lsl.w	r2, r0, r2
 800ab68:	ea6f 0202 	mvn.w	r2, r2
 800ab6c:	400a      	ands	r2, r1
 800ab6e:	619a      	str	r2, [r3, #24]
    Handle->PortRegs->IOCR8 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800ab70:	687b      	ldr	r3, [r7, #4]
 800ab72:	685b      	ldr	r3, [r3, #4]
 800ab74:	687a      	ldr	r2, [r7, #4]
 800ab76:	6852      	ldr	r2, [r2, #4]
 800ab78:	6991      	ldr	r1, [r2, #24]
 800ab7a:	78fa      	ldrb	r2, [r7, #3]
 800ab7c:	f002 001f 	and.w	r0, r2, #31
 800ab80:	7bfa      	ldrb	r2, [r7, #15]
 800ab82:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ab86:	f102 0203 	add.w	r2, r2, #3
 800ab8a:	fa00 f202 	lsl.w	r2, r0, r2
 800ab8e:	430a      	orrs	r2, r1
 800ab90:	619a      	str	r2, [r3, #24]
 800ab92:	e02c      	b.n	800abee <IO004_DisableOutputDriver+0x172>
  } else if ((Pin >= 12U) && (Pin <= 15U))
 800ab94:	7bfb      	ldrb	r3, [r7, #15]
 800ab96:	2b0b      	cmp	r3, #11
 800ab98:	d929      	bls.n	800abee <IO004_DisableOutputDriver+0x172>
 800ab9a:	7bfb      	ldrb	r3, [r7, #15]
 800ab9c:	2b0f      	cmp	r3, #15
 800ab9e:	d826      	bhi.n	800abee <IO004_DisableOutputDriver+0x172>
  {
    Pin = Pin - 12U;
 800aba0:	7bfb      	ldrb	r3, [r7, #15]
 800aba2:	f1a3 030c 	sub.w	r3, r3, #12
 800aba6:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR12  =  (uint32_t)(Handle->PortRegs->IOCR12 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800aba8:	687b      	ldr	r3, [r7, #4]
 800abaa:	685b      	ldr	r3, [r3, #4]
 800abac:	687a      	ldr	r2, [r7, #4]
 800abae:	6852      	ldr	r2, [r2, #4]
 800abb0:	69d1      	ldr	r1, [r2, #28]
 800abb2:	7bfa      	ldrb	r2, [r7, #15]
 800abb4:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800abb8:	f102 0203 	add.w	r2, r2, #3
 800abbc:	f04f 001f 	mov.w	r0, #31
 800abc0:	fa00 f202 	lsl.w	r2, r0, r2
 800abc4:	ea6f 0202 	mvn.w	r2, r2
 800abc8:	400a      	ands	r2, r1
 800abca:	61da      	str	r2, [r3, #28]
    Handle->PortRegs->IOCR12 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800abcc:	687b      	ldr	r3, [r7, #4]
 800abce:	685b      	ldr	r3, [r3, #4]
 800abd0:	687a      	ldr	r2, [r7, #4]
 800abd2:	6852      	ldr	r2, [r2, #4]
 800abd4:	69d1      	ldr	r1, [r2, #28]
 800abd6:	78fa      	ldrb	r2, [r7, #3]
 800abd8:	f002 001f 	and.w	r0, r2, #31
 800abdc:	7bfa      	ldrb	r2, [r7, #15]
 800abde:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800abe2:	f102 0203 	add.w	r2, r2, #3
 800abe6:	fa00 f202 	lsl.w	r2, r0, r2
 800abea:	430a      	orrs	r2, r1
 800abec:	61da      	str	r2, [r3, #28]
  else
  {
	  /*Not supposed to be here */
  }

}
 800abee:	f107 0714 	add.w	r7, r7, #20
 800abf2:	46bd      	mov	sp, r7
 800abf4:	bc80      	pop	{r7}
 800abf6:	4770      	bx	lr

0800abf8 <IO004_EnableOutputDriver>:

void IO004_EnableOutputDriver(const IO004_HandleType* Handle,IO004_OutputModeType Mode)
{
 800abf8:	b480      	push	{r7}
 800abfa:	b085      	sub	sp, #20
 800abfc:	af00      	add	r7, sp, #0
 800abfe:	6078      	str	r0, [r7, #4]
 800ac00:	460b      	mov	r3, r1
 800ac02:	70fb      	strb	r3, [r7, #3]

  uint8_t Pin = Handle->PortPin;
 800ac04:	687b      	ldr	r3, [r7, #4]
 800ac06:	785b      	ldrb	r3, [r3, #1]
 800ac08:	73fb      	strb	r3, [r7, #15]
  /* <<<DD_IO004_API_2>>> */
  if(Pin < 4U)
 800ac0a:	7bfb      	ldrb	r3, [r7, #15]
 800ac0c:	2b03      	cmp	r3, #3
 800ac0e:	d823      	bhi.n	800ac58 <IO004_EnableOutputDriver+0x60>
  {
    Handle->PortRegs->IOCR0  =  (uint32_t)(Handle->PortRegs->IOCR0 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800ac10:	687b      	ldr	r3, [r7, #4]
 800ac12:	685b      	ldr	r3, [r3, #4]
 800ac14:	687a      	ldr	r2, [r7, #4]
 800ac16:	6852      	ldr	r2, [r2, #4]
 800ac18:	6911      	ldr	r1, [r2, #16]
 800ac1a:	7bfa      	ldrb	r2, [r7, #15]
 800ac1c:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ac20:	f102 0203 	add.w	r2, r2, #3
 800ac24:	f04f 001f 	mov.w	r0, #31
 800ac28:	fa00 f202 	lsl.w	r2, r0, r2
 800ac2c:	ea6f 0202 	mvn.w	r2, r2
 800ac30:	400a      	ands	r2, r1
 800ac32:	611a      	str	r2, [r3, #16]
    Handle->PortRegs->IOCR0 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800ac34:	687b      	ldr	r3, [r7, #4]
 800ac36:	685b      	ldr	r3, [r3, #4]
 800ac38:	687a      	ldr	r2, [r7, #4]
 800ac3a:	6852      	ldr	r2, [r2, #4]
 800ac3c:	6911      	ldr	r1, [r2, #16]
 800ac3e:	78fa      	ldrb	r2, [r7, #3]
 800ac40:	f002 001f 	and.w	r0, r2, #31
 800ac44:	7bfa      	ldrb	r2, [r7, #15]
 800ac46:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ac4a:	f102 0203 	add.w	r2, r2, #3
 800ac4e:	fa00 f202 	lsl.w	r2, r0, r2
 800ac52:	430a      	orrs	r2, r1
 800ac54:	611a      	str	r2, [r3, #16]
 800ac56:	e088      	b.n	800ad6a <IO004_EnableOutputDriver+0x172>
  } else if ((Pin >= 4U) && (Pin <= 7U))
 800ac58:	7bfb      	ldrb	r3, [r7, #15]
 800ac5a:	2b03      	cmp	r3, #3
 800ac5c:	d92a      	bls.n	800acb4 <IO004_EnableOutputDriver+0xbc>
 800ac5e:	7bfb      	ldrb	r3, [r7, #15]
 800ac60:	2b07      	cmp	r3, #7
 800ac62:	d827      	bhi.n	800acb4 <IO004_EnableOutputDriver+0xbc>
  {
    Pin = Pin - 4U;
 800ac64:	7bfb      	ldrb	r3, [r7, #15]
 800ac66:	f1a3 0304 	sub.w	r3, r3, #4
 800ac6a:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR4  =  (uint32_t)(Handle->PortRegs->IOCR4 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800ac6c:	687b      	ldr	r3, [r7, #4]
 800ac6e:	685b      	ldr	r3, [r3, #4]
 800ac70:	687a      	ldr	r2, [r7, #4]
 800ac72:	6852      	ldr	r2, [r2, #4]
 800ac74:	6951      	ldr	r1, [r2, #20]
 800ac76:	7bfa      	ldrb	r2, [r7, #15]
 800ac78:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ac7c:	f102 0203 	add.w	r2, r2, #3
 800ac80:	f04f 001f 	mov.w	r0, #31
 800ac84:	fa00 f202 	lsl.w	r2, r0, r2
 800ac88:	ea6f 0202 	mvn.w	r2, r2
 800ac8c:	400a      	ands	r2, r1
 800ac8e:	615a      	str	r2, [r3, #20]
    Handle->PortRegs->IOCR4 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800ac90:	687b      	ldr	r3, [r7, #4]
 800ac92:	685b      	ldr	r3, [r3, #4]
 800ac94:	687a      	ldr	r2, [r7, #4]
 800ac96:	6852      	ldr	r2, [r2, #4]
 800ac98:	6951      	ldr	r1, [r2, #20]
 800ac9a:	78fa      	ldrb	r2, [r7, #3]
 800ac9c:	f002 001f 	and.w	r0, r2, #31
 800aca0:	7bfa      	ldrb	r2, [r7, #15]
 800aca2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800aca6:	f102 0203 	add.w	r2, r2, #3
 800acaa:	fa00 f202 	lsl.w	r2, r0, r2
 800acae:	430a      	orrs	r2, r1
 800acb0:	615a      	str	r2, [r3, #20]
 800acb2:	e05a      	b.n	800ad6a <IO004_EnableOutputDriver+0x172>
  } else if ((Pin >= 8U) && (Pin <= 11U))
 800acb4:	7bfb      	ldrb	r3, [r7, #15]
 800acb6:	2b07      	cmp	r3, #7
 800acb8:	d92a      	bls.n	800ad10 <IO004_EnableOutputDriver+0x118>
 800acba:	7bfb      	ldrb	r3, [r7, #15]
 800acbc:	2b0b      	cmp	r3, #11
 800acbe:	d827      	bhi.n	800ad10 <IO004_EnableOutputDriver+0x118>
  {
    Pin = Pin - 8U;
 800acc0:	7bfb      	ldrb	r3, [r7, #15]
 800acc2:	f1a3 0308 	sub.w	r3, r3, #8
 800acc6:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR8  =  (uint32_t)(Handle->PortRegs->IOCR8 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800acc8:	687b      	ldr	r3, [r7, #4]
 800acca:	685b      	ldr	r3, [r3, #4]
 800accc:	687a      	ldr	r2, [r7, #4]
 800acce:	6852      	ldr	r2, [r2, #4]
 800acd0:	6991      	ldr	r1, [r2, #24]
 800acd2:	7bfa      	ldrb	r2, [r7, #15]
 800acd4:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800acd8:	f102 0203 	add.w	r2, r2, #3
 800acdc:	f04f 001f 	mov.w	r0, #31
 800ace0:	fa00 f202 	lsl.w	r2, r0, r2
 800ace4:	ea6f 0202 	mvn.w	r2, r2
 800ace8:	400a      	ands	r2, r1
 800acea:	619a      	str	r2, [r3, #24]
    Handle->PortRegs->IOCR8 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800acec:	687b      	ldr	r3, [r7, #4]
 800acee:	685b      	ldr	r3, [r3, #4]
 800acf0:	687a      	ldr	r2, [r7, #4]
 800acf2:	6852      	ldr	r2, [r2, #4]
 800acf4:	6991      	ldr	r1, [r2, #24]
 800acf6:	78fa      	ldrb	r2, [r7, #3]
 800acf8:	f002 001f 	and.w	r0, r2, #31
 800acfc:	7bfa      	ldrb	r2, [r7, #15]
 800acfe:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ad02:	f102 0203 	add.w	r2, r2, #3
 800ad06:	fa00 f202 	lsl.w	r2, r0, r2
 800ad0a:	430a      	orrs	r2, r1
 800ad0c:	619a      	str	r2, [r3, #24]
 800ad0e:	e02c      	b.n	800ad6a <IO004_EnableOutputDriver+0x172>
  } else if ((Pin >= 12U) && (Pin <= 15U))
 800ad10:	7bfb      	ldrb	r3, [r7, #15]
 800ad12:	2b0b      	cmp	r3, #11
 800ad14:	d929      	bls.n	800ad6a <IO004_EnableOutputDriver+0x172>
 800ad16:	7bfb      	ldrb	r3, [r7, #15]
 800ad18:	2b0f      	cmp	r3, #15
 800ad1a:	d826      	bhi.n	800ad6a <IO004_EnableOutputDriver+0x172>
  {
    Pin = Pin - 12U;
 800ad1c:	7bfb      	ldrb	r3, [r7, #15]
 800ad1e:	f1a3 030c 	sub.w	r3, r3, #12
 800ad22:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR12  =  (uint32_t)(Handle->PortRegs->IOCR12 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800ad24:	687b      	ldr	r3, [r7, #4]
 800ad26:	685b      	ldr	r3, [r3, #4]
 800ad28:	687a      	ldr	r2, [r7, #4]
 800ad2a:	6852      	ldr	r2, [r2, #4]
 800ad2c:	69d1      	ldr	r1, [r2, #28]
 800ad2e:	7bfa      	ldrb	r2, [r7, #15]
 800ad30:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ad34:	f102 0203 	add.w	r2, r2, #3
 800ad38:	f04f 001f 	mov.w	r0, #31
 800ad3c:	fa00 f202 	lsl.w	r2, r0, r2
 800ad40:	ea6f 0202 	mvn.w	r2, r2
 800ad44:	400a      	ands	r2, r1
 800ad46:	61da      	str	r2, [r3, #28]
    Handle->PortRegs->IOCR12 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800ad48:	687b      	ldr	r3, [r7, #4]
 800ad4a:	685b      	ldr	r3, [r3, #4]
 800ad4c:	687a      	ldr	r2, [r7, #4]
 800ad4e:	6852      	ldr	r2, [r2, #4]
 800ad50:	69d1      	ldr	r1, [r2, #28]
 800ad52:	78fa      	ldrb	r2, [r7, #3]
 800ad54:	f002 001f 	and.w	r0, r2, #31
 800ad58:	7bfa      	ldrb	r2, [r7, #15]
 800ad5a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ad5e:	f102 0203 	add.w	r2, r2, #3
 800ad62:	fa00 f202 	lsl.w	r2, r0, r2
 800ad66:	430a      	orrs	r2, r1
 800ad68:	61da      	str	r2, [r3, #28]
  }
  else
  {
	  /*Not supposed to be here */
  }
}
 800ad6a:	f107 0714 	add.w	r7, r7, #20
 800ad6e:	46bd      	mov	sp, r7
 800ad70:	bc80      	pop	{r7}
 800ad72:	4770      	bx	lr

0800ad74 <IO001_Init>:
/** @ingroup IO001_Func
 * @{
 */

void IO001_Init(void)
{
 800ad74:	b480      	push	{r7}
 800ad76:	af00      	add	r7, sp, #0
   /* <<<DD_IO001_API_1>>> */

  /* Configuration of Port 14 Pin 1 based on User configuration */
  /* Enable Digital Pad Input*/
  IO001_Handle0.PortRegs->PDISC  &= (~((uint32_t)0x1U << 1));
 800ad78:	f246 639c 	movw	r3, #26268	; 0x669c
 800ad7c:	f6c0 0302 	movt	r3, #2050	; 0x802
 800ad80:	685a      	ldr	r2, [r3, #4]
 800ad82:	f246 639c 	movw	r3, #26268	; 0x669c
 800ad86:	f6c0 0302 	movt	r3, #2050	; 0x802
 800ad8a:	685b      	ldr	r3, [r3, #4]
 800ad8c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800ad8e:	f023 0302 	bic.w	r3, r3, #2
 800ad92:	6613      	str	r3, [r2, #96]	; 0x60
  /*configure the Digital Input characteristics in IOCR register*/
  IO001_Handle0.PortRegs->IOCR0 |= (-1U << 11);
 800ad94:	f246 639c 	movw	r3, #26268	; 0x669c
 800ad98:	f6c0 0302 	movt	r3, #2050	; 0x802
 800ad9c:	685a      	ldr	r2, [r3, #4]
 800ad9e:	f246 639c 	movw	r3, #26268	; 0x669c
 800ada2:	f6c0 0302 	movt	r3, #2050	; 0x802
 800ada6:	685b      	ldr	r3, [r3, #4]
 800ada8:	691b      	ldr	r3, [r3, #16]
 800adaa:	ea6f 5343 	mvn.w	r3, r3, lsl #21
 800adae:	ea6f 5353 	mvn.w	r3, r3, lsr #21
 800adb2:	6113      	str	r3, [r2, #16]
}
 800adb4:	46bd      	mov	sp, r7
 800adb6:	bc80      	pop	{r7}
 800adb8:	4770      	bx	lr
 800adba:	bf00      	nop

0800adbc <IO001_EnableDigitalInput>:

void IO001_EnableDigitalInput(const IO001_HandleType* Handle,IO001_InputModeType Mode)
{
 800adbc:	b480      	push	{r7}
 800adbe:	b085      	sub	sp, #20
 800adc0:	af00      	add	r7, sp, #0
 800adc2:	6078      	str	r0, [r7, #4]
 800adc4:	460b      	mov	r3, r1
 800adc6:	70fb      	strb	r3, [r7, #3]
  uint8_t Pin = Handle->PortPin;
 800adc8:	687b      	ldr	r3, [r7, #4]
 800adca:	785b      	ldrb	r3, [r3, #1]
 800adcc:	73fb      	strb	r3, [r7, #15]
  /* <<<DD_IO001_API_2>>> */
     
  /* Enable Digital Mode */
  Handle->PortRegs->PDISC  =  (uint32_t)(Handle->PortRegs->PDISC & ~(1UL << (Pin)));
 800adce:	687b      	ldr	r3, [r7, #4]
 800add0:	685b      	ldr	r3, [r3, #4]
 800add2:	687a      	ldr	r2, [r7, #4]
 800add4:	6852      	ldr	r2, [r2, #4]
 800add6:	6e11      	ldr	r1, [r2, #96]	; 0x60
 800add8:	7bfa      	ldrb	r2, [r7, #15]
 800adda:	f04f 0001 	mov.w	r0, #1
 800adde:	fa00 f202 	lsl.w	r2, r0, r2
 800ade2:	ea6f 0202 	mvn.w	r2, r2
 800ade6:	400a      	ands	r2, r1
 800ade8:	661a      	str	r2, [r3, #96]	; 0x60
  if(Pin < 4U)
 800adea:	7bfb      	ldrb	r3, [r7, #15]
 800adec:	2b03      	cmp	r3, #3
 800adee:	d823      	bhi.n	800ae38 <IO001_EnableDigitalInput+0x7c>
  {
    Handle->PortRegs->IOCR0  =  (uint32_t)(Handle->PortRegs->IOCR0 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800adf0:	687b      	ldr	r3, [r7, #4]
 800adf2:	685b      	ldr	r3, [r3, #4]
 800adf4:	687a      	ldr	r2, [r7, #4]
 800adf6:	6852      	ldr	r2, [r2, #4]
 800adf8:	6911      	ldr	r1, [r2, #16]
 800adfa:	7bfa      	ldrb	r2, [r7, #15]
 800adfc:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ae00:	f102 0203 	add.w	r2, r2, #3
 800ae04:	f04f 001f 	mov.w	r0, #31
 800ae08:	fa00 f202 	lsl.w	r2, r0, r2
 800ae0c:	ea6f 0202 	mvn.w	r2, r2
 800ae10:	400a      	ands	r2, r1
 800ae12:	611a      	str	r2, [r3, #16]
    Handle->PortRegs->IOCR0 |= (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800ae14:	687b      	ldr	r3, [r7, #4]
 800ae16:	685b      	ldr	r3, [r3, #4]
 800ae18:	687a      	ldr	r2, [r7, #4]
 800ae1a:	6852      	ldr	r2, [r2, #4]
 800ae1c:	6911      	ldr	r1, [r2, #16]
 800ae1e:	78fa      	ldrb	r2, [r7, #3]
 800ae20:	f002 001f 	and.w	r0, r2, #31
 800ae24:	7bfa      	ldrb	r2, [r7, #15]
 800ae26:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ae2a:	f102 0203 	add.w	r2, r2, #3
 800ae2e:	fa00 f202 	lsl.w	r2, r0, r2
 800ae32:	430a      	orrs	r2, r1
 800ae34:	611a      	str	r2, [r3, #16]
 800ae36:	e088      	b.n	800af4a <IO001_EnableDigitalInput+0x18e>
  } else if ((Pin >= 4U) && (Pin <= 7U))
 800ae38:	7bfb      	ldrb	r3, [r7, #15]
 800ae3a:	2b03      	cmp	r3, #3
 800ae3c:	d92a      	bls.n	800ae94 <IO001_EnableDigitalInput+0xd8>
 800ae3e:	7bfb      	ldrb	r3, [r7, #15]
 800ae40:	2b07      	cmp	r3, #7
 800ae42:	d827      	bhi.n	800ae94 <IO001_EnableDigitalInput+0xd8>
  {
    Pin = Pin - 4U;
 800ae44:	7bfb      	ldrb	r3, [r7, #15]
 800ae46:	f1a3 0304 	sub.w	r3, r3, #4
 800ae4a:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR4  =  (uint32_t)(Handle->PortRegs->IOCR4 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800ae4c:	687b      	ldr	r3, [r7, #4]
 800ae4e:	685b      	ldr	r3, [r3, #4]
 800ae50:	687a      	ldr	r2, [r7, #4]
 800ae52:	6852      	ldr	r2, [r2, #4]
 800ae54:	6951      	ldr	r1, [r2, #20]
 800ae56:	7bfa      	ldrb	r2, [r7, #15]
 800ae58:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ae5c:	f102 0203 	add.w	r2, r2, #3
 800ae60:	f04f 001f 	mov.w	r0, #31
 800ae64:	fa00 f202 	lsl.w	r2, r0, r2
 800ae68:	ea6f 0202 	mvn.w	r2, r2
 800ae6c:	400a      	ands	r2, r1
 800ae6e:	615a      	str	r2, [r3, #20]
    Handle->PortRegs->IOCR4 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800ae70:	687b      	ldr	r3, [r7, #4]
 800ae72:	685b      	ldr	r3, [r3, #4]
 800ae74:	687a      	ldr	r2, [r7, #4]
 800ae76:	6852      	ldr	r2, [r2, #4]
 800ae78:	6951      	ldr	r1, [r2, #20]
 800ae7a:	78fa      	ldrb	r2, [r7, #3]
 800ae7c:	f002 001f 	and.w	r0, r2, #31
 800ae80:	7bfa      	ldrb	r2, [r7, #15]
 800ae82:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800ae86:	f102 0203 	add.w	r2, r2, #3
 800ae8a:	fa00 f202 	lsl.w	r2, r0, r2
 800ae8e:	430a      	orrs	r2, r1
 800ae90:	615a      	str	r2, [r3, #20]
 800ae92:	e05a      	b.n	800af4a <IO001_EnableDigitalInput+0x18e>
  } else if ((Pin >= 8U) && (Pin <= 11U))
 800ae94:	7bfb      	ldrb	r3, [r7, #15]
 800ae96:	2b07      	cmp	r3, #7
 800ae98:	d92a      	bls.n	800aef0 <IO001_EnableDigitalInput+0x134>
 800ae9a:	7bfb      	ldrb	r3, [r7, #15]
 800ae9c:	2b0b      	cmp	r3, #11
 800ae9e:	d827      	bhi.n	800aef0 <IO001_EnableDigitalInput+0x134>
  {
    Pin = Pin - 8U;
 800aea0:	7bfb      	ldrb	r3, [r7, #15]
 800aea2:	f1a3 0308 	sub.w	r3, r3, #8
 800aea6:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR8  =  (uint32_t)(Handle->PortRegs->IOCR8 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800aea8:	687b      	ldr	r3, [r7, #4]
 800aeaa:	685b      	ldr	r3, [r3, #4]
 800aeac:	687a      	ldr	r2, [r7, #4]
 800aeae:	6852      	ldr	r2, [r2, #4]
 800aeb0:	6991      	ldr	r1, [r2, #24]
 800aeb2:	7bfa      	ldrb	r2, [r7, #15]
 800aeb4:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800aeb8:	f102 0203 	add.w	r2, r2, #3
 800aebc:	f04f 001f 	mov.w	r0, #31
 800aec0:	fa00 f202 	lsl.w	r2, r0, r2
 800aec4:	ea6f 0202 	mvn.w	r2, r2
 800aec8:	400a      	ands	r2, r1
 800aeca:	619a      	str	r2, [r3, #24]
    Handle->PortRegs->IOCR8 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800aecc:	687b      	ldr	r3, [r7, #4]
 800aece:	685b      	ldr	r3, [r3, #4]
 800aed0:	687a      	ldr	r2, [r7, #4]
 800aed2:	6852      	ldr	r2, [r2, #4]
 800aed4:	6991      	ldr	r1, [r2, #24]
 800aed6:	78fa      	ldrb	r2, [r7, #3]
 800aed8:	f002 001f 	and.w	r0, r2, #31
 800aedc:	7bfa      	ldrb	r2, [r7, #15]
 800aede:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800aee2:	f102 0203 	add.w	r2, r2, #3
 800aee6:	fa00 f202 	lsl.w	r2, r0, r2
 800aeea:	430a      	orrs	r2, r1
 800aeec:	619a      	str	r2, [r3, #24]
 800aeee:	e02c      	b.n	800af4a <IO001_EnableDigitalInput+0x18e>
  } else if ((Pin >= 12U) && (Pin <= 15U))
 800aef0:	7bfb      	ldrb	r3, [r7, #15]
 800aef2:	2b0b      	cmp	r3, #11
 800aef4:	d929      	bls.n	800af4a <IO001_EnableDigitalInput+0x18e>
 800aef6:	7bfb      	ldrb	r3, [r7, #15]
 800aef8:	2b0f      	cmp	r3, #15
 800aefa:	d826      	bhi.n	800af4a <IO001_EnableDigitalInput+0x18e>
  {
    Pin = Pin - 12U;
 800aefc:	7bfb      	ldrb	r3, [r7, #15]
 800aefe:	f1a3 030c 	sub.w	r3, r3, #12
 800af02:	73fb      	strb	r3, [r7, #15]
    Handle->PortRegs->IOCR12  =  (uint32_t)(Handle->PortRegs->IOCR12 & ~(0x0000001FUL << (3U+(Pin*8U))));
 800af04:	687b      	ldr	r3, [r7, #4]
 800af06:	685b      	ldr	r3, [r3, #4]
 800af08:	687a      	ldr	r2, [r7, #4]
 800af0a:	6852      	ldr	r2, [r2, #4]
 800af0c:	69d1      	ldr	r1, [r2, #28]
 800af0e:	7bfa      	ldrb	r2, [r7, #15]
 800af10:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800af14:	f102 0203 	add.w	r2, r2, #3
 800af18:	f04f 001f 	mov.w	r0, #31
 800af1c:	fa00 f202 	lsl.w	r2, r0, r2
 800af20:	ea6f 0202 	mvn.w	r2, r2
 800af24:	400a      	ands	r2, r1
 800af26:	61da      	str	r2, [r3, #28]
    Handle->PortRegs->IOCR12 |=  (uint32_t)(((uint32_t)Mode & 0x1FUL) << (3U+(Pin*8U)));
 800af28:	687b      	ldr	r3, [r7, #4]
 800af2a:	685b      	ldr	r3, [r3, #4]
 800af2c:	687a      	ldr	r2, [r7, #4]
 800af2e:	6852      	ldr	r2, [r2, #4]
 800af30:	69d1      	ldr	r1, [r2, #28]
 800af32:	78fa      	ldrb	r2, [r7, #3]
 800af34:	f002 001f 	and.w	r0, r2, #31
 800af38:	7bfa      	ldrb	r2, [r7, #15]
 800af3a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800af3e:	f102 0203 	add.w	r2, r2, #3
 800af42:	fa00 f202 	lsl.w	r2, r0, r2
 800af46:	430a      	orrs	r2, r1
 800af48:	61da      	str	r2, [r3, #28]
  }
  else
  {
   /*Not supposed to be here */
  }
}
 800af4a:	f107 0714 	add.w	r7, r7, #20
 800af4e:	46bd      	mov	sp, r7
 800af50:	bc80      	pop	{r7}
 800af52:	4770      	bx	lr

0800af54 <IO001_DisableDigitalInput>:

void IO001_DisableDigitalInput(const IO001_HandleType* Handle)
{
 800af54:	b480      	push	{r7}
 800af56:	b083      	sub	sp, #12
 800af58:	af00      	add	r7, sp, #0
 800af5a:	6078      	str	r0, [r7, #4]
  /* <<<DD_IO001_API_3>>> */
  /* Disable Digital Mode */
  Handle->PortRegs->PDISC  |=  (uint32_t)(1UL << Handle->PortPin);
 800af5c:	687b      	ldr	r3, [r7, #4]
 800af5e:	685b      	ldr	r3, [r3, #4]
 800af60:	687a      	ldr	r2, [r7, #4]
 800af62:	6852      	ldr	r2, [r2, #4]
 800af64:	6e11      	ldr	r1, [r2, #96]	; 0x60
 800af66:	687a      	ldr	r2, [r7, #4]
 800af68:	7852      	ldrb	r2, [r2, #1]
 800af6a:	f04f 0001 	mov.w	r0, #1
 800af6e:	fa00 f202 	lsl.w	r2, r0, r2
 800af72:	430a      	orrs	r2, r1
 800af74:	661a      	str	r2, [r3, #96]	; 0x60
}
 800af76:	f107 070c 	add.w	r7, r7, #12
 800af7a:	46bd      	mov	sp, r7
 800af7c:	bc80      	pop	{r7}
 800af7e:	4770      	bx	lr

0800af80 <GMM001_Init>:
/*<<<DD_GMM001_API_1>>>*/
/* This function configures LMM001 handles using different RAM sections available
 * depending on the heap requirement.
 */
void GMM001_Init (void)
{
 800af80:	b580      	push	{r7, lr}
 800af82:	af00      	add	r7, sp, #0
  FUNCTION_ENTRY(GID_GMM001, (uint32_t)GMM001_FUNCTION_ENTRY);
  
  memset ((void *)Heap_Bank1_Start, 0, LENGTH1);
 800af84:	f246 63a4 	movw	r3, #26276	; 0x66a4
 800af88:	f6c0 0302 	movt	r3, #2050	; 0x802
 800af8c:	681b      	ldr	r3, [r3, #0]
 800af8e:	f646 30d0 	movw	r0, #27600	; 0x6bd0
 800af92:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800af96:	f04f 0100 	mov.w	r1, #0
 800af9a:	461a      	mov	r2, r3
 800af9c:	f018 fca8 	bl	80238f0 <memset>
  memset ((void *)Heap_Bank2_Start, 0, LENGTH2);
 800afa0:	f246 63a8 	movw	r3, #26280	; 0x66a8
 800afa4:	f6c0 0302 	movt	r3, #2050	; 0x802
 800afa8:	681b      	ldr	r3, [r3, #0]
 800afaa:	f644 1020 	movw	r0, #18720	; 0x4920
 800afae:	f2c3 0000 	movt	r0, #12288	; 0x3000
 800afb2:	f04f 0100 	mov.w	r1, #0
 800afb6:	461a      	mov	r2, r3
 800afb8:	f018 fc9a 	bl	80238f0 <memset>
  memset ((void *)Heap_Bank3_Start, 0, LENGTH3);
 800afbc:	f246 63ac 	movw	r3, #26284	; 0x66ac
 800afc0:	f6c0 0302 	movt	r3, #2050	; 0x802
 800afc4:	681b      	ldr	r3, [r3, #0]
 800afc6:	f240 0000 	movw	r0, #0
 800afca:	f2c1 0000 	movt	r0, #4096	; 0x1000
 800afce:	f04f 0100 	mov.w	r1, #0
 800afd2:	461a      	mov	r2, r3
 800afd4:	f018 fc8c 	bl	80238f0 <memset>

/* Allocate Heap from RAM1 and RAM2 and RAM3*/  
/*<<<DD_GMM001_API_1_6>>>*/  
  GMM001_handle0.umm_heap = ((LMM001_BlockType *)Heap_Bank1_Start);
 800afd8:	f246 43fc 	movw	r3, #25852	; 0x64fc
 800afdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800afe0:	f646 32d0 	movw	r2, #27600	; 0x6bd0
 800afe4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800afe8:	601a      	str	r2, [r3, #0]
  GMM001_handle0.umm_numblocks = (uint32_t)LENGTH1 / (sizeof(LMM001_BlockType));
 800afea:	f246 63a4 	movw	r3, #26276	; 0x66a4
 800afee:	f6c0 0302 	movt	r3, #2050	; 0x802
 800aff2:	681b      	ldr	r3, [r3, #0]
 800aff4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800aff8:	b29a      	uxth	r2, r3
 800affa:	f246 43fc 	movw	r3, #25852	; 0x64fc
 800affe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b002:	809a      	strh	r2, [r3, #4]
  GMM001_handle1.umm_heap = ((LMM001_BlockType *)Heap_Bank2_Start);
 800b004:	f246 43ec 	movw	r3, #25836	; 0x64ec
 800b008:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b00c:	f644 1220 	movw	r2, #18720	; 0x4920
 800b010:	f2c3 0200 	movt	r2, #12288	; 0x3000
 800b014:	601a      	str	r2, [r3, #0]
  GMM001_handle1.umm_numblocks = (uint32_t)LENGTH2 / (sizeof(LMM001_BlockType));
 800b016:	f246 63a8 	movw	r3, #26280	; 0x66a8
 800b01a:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b01e:	681b      	ldr	r3, [r3, #0]
 800b020:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800b024:	b29a      	uxth	r2, r3
 800b026:	f246 43ec 	movw	r3, #25836	; 0x64ec
 800b02a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b02e:	809a      	strh	r2, [r3, #4]
  GMM001_handle2.umm_heap = ((LMM001_BlockType *)Heap_Bank3_Start);
 800b030:	f246 43f4 	movw	r3, #25844	; 0x64f4
 800b034:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b038:	f240 0200 	movw	r2, #0
 800b03c:	f2c1 0200 	movt	r2, #4096	; 0x1000
 800b040:	601a      	str	r2, [r3, #0]
  GMM001_handle2.umm_numblocks = (uint32_t) LENGTH3/ (sizeof(LMM001_BlockType));
 800b042:	f246 63ac 	movw	r3, #26284	; 0x66ac
 800b046:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b04a:	681b      	ldr	r3, [r3, #0]
 800b04c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800b050:	b29a      	uxth	r2, r3
 800b052:	f246 43f4 	movw	r3, #25844	; 0x64f4
 800b056:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b05a:	809a      	strh	r2, [r3, #4]

  FUNCTION_EXIT(GID_GMM001, (uint32_t)GMM001_FUNCTION_EXIT);
}
 800b05c:	bd80      	pop	{r7, pc}
 800b05e:	bf00      	nop

0800b060 <GMM001_malloc>:
/*<<<DD_GMM001_API_2>>>*/
/*
 * The function allocates memory of 'size' number of bytes.
 */
void * GMM001_malloc (uint32_t size)
{
 800b060:	b580      	push	{r7, lr}
 800b062:	b084      	sub	sp, #16
 800b064:	af00      	add	r7, sp, #0
 800b066:	6078      	str	r0, [r7, #4]
  void * MemPtr = NULL;
 800b068:	f04f 0300 	mov.w	r3, #0
 800b06c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_GMM001, (uint32_t)GMM001_FUNCTION_ENTRY);

/*<<<DD_GMM001_API_2_1>>>*/  
  MemPtr = LMM001_malloc(&GMM001_handle0, size);
 800b06e:	f246 40fc 	movw	r0, #25852	; 0x64fc
 800b072:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b076:	6879      	ldr	r1, [r7, #4]
 800b078:	f7ff fae6 	bl	800a648 <LMM001_malloc>
 800b07c:	60f8      	str	r0, [r7, #12]
  if (MemPtr == NULL)
 800b07e:	68fb      	ldr	r3, [r7, #12]
 800b080:	2b00      	cmp	r3, #0
 800b082:	d112      	bne.n	800b0aa <GMM001_malloc+0x4a>
  {
    MemPtr = LMM001_malloc(&GMM001_handle1, size);
 800b084:	f246 40ec 	movw	r0, #25836	; 0x64ec
 800b088:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b08c:	6879      	ldr	r1, [r7, #4]
 800b08e:	f7ff fadb 	bl	800a648 <LMM001_malloc>
 800b092:	60f8      	str	r0, [r7, #12]
	if (MemPtr == NULL)
 800b094:	68fb      	ldr	r3, [r7, #12]
 800b096:	2b00      	cmp	r3, #0
 800b098:	d107      	bne.n	800b0aa <GMM001_malloc+0x4a>
	{
		MemPtr = LMM001_malloc(&GMM001_handle2, size);
 800b09a:	f246 40f4 	movw	r0, #25844	; 0x64f4
 800b09e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b0a2:	6879      	ldr	r1, [r7, #4]
 800b0a4:	f7ff fad0 	bl	800a648 <LMM001_malloc>
 800b0a8:	60f8      	str	r0, [r7, #12]
	}
  }

  FUNCTION_EXIT(GID_GMM001, (uint32_t)GMM001_FUNCTION_EXIT);
  return MemPtr;
 800b0aa:	68fb      	ldr	r3, [r7, #12]
}
 800b0ac:	4618      	mov	r0, r3
 800b0ae:	f107 0710 	add.w	r7, r7, #16
 800b0b2:	46bd      	mov	sp, r7
 800b0b4:	bd80      	pop	{r7, pc}
 800b0b6:	bf00      	nop

0800b0b8 <GMM001_realloc>:
/*<<<DD_GMM001_API_3>>>*/ 
/*
 * This function changes the size of a block of memory that was previously allocated with malloc().
 */
void * GMM001_realloc (uint32_t size, void * MemPtr)
{
 800b0b8:	b580      	push	{r7, lr}
 800b0ba:	b084      	sub	sp, #16
 800b0bc:	af00      	add	r7, sp, #0
 800b0be:	6078      	str	r0, [r7, #4]
 800b0c0:	6039      	str	r1, [r7, #0]
  void * MemPtr1 = NULL;
 800b0c2:	f04f 0300 	mov.w	r3, #0
 800b0c6:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_GMM001, (uint32_t)GMM001_FUNCTION_ENTRY);

  if (MemPtr == NULL)
 800b0c8:	683b      	ldr	r3, [r7, #0]
 800b0ca:	2b00      	cmp	r3, #0
 800b0cc:	d104      	bne.n	800b0d8 <GMM001_realloc+0x20>
  {
    return(GMM001_malloc(size));
 800b0ce:	6878      	ldr	r0, [r7, #4]
 800b0d0:	f7ff ffc6 	bl	800b060 <GMM001_malloc>
 800b0d4:	4603      	mov	r3, r0
 800b0d6:	e059      	b.n	800b18c <GMM001_realloc+0xd4>
  }

/*<<<DD_GMM001_API_3_1>>>*/   
  if (((uint32_t)MemPtr >= (uint32_t)Heap_Bank1_Start) && ((uint32_t)MemPtr <= ((uint32_t)Heap_Bank1_Start + LENGTH1)))
 800b0d8:	683a      	ldr	r2, [r7, #0]
 800b0da:	f646 33d0 	movw	r3, #27600	; 0x6bd0
 800b0de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b0e2:	429a      	cmp	r2, r3
 800b0e4:	d316      	bcc.n	800b114 <GMM001_realloc+0x5c>
 800b0e6:	683a      	ldr	r2, [r7, #0]
 800b0e8:	f246 63a4 	movw	r3, #26276	; 0x66a4
 800b0ec:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b0f0:	6819      	ldr	r1, [r3, #0]
 800b0f2:	f646 33d0 	movw	r3, #27600	; 0x6bd0
 800b0f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b0fa:	18cb      	adds	r3, r1, r3
 800b0fc:	429a      	cmp	r2, r3
 800b0fe:	d809      	bhi.n	800b114 <GMM001_realloc+0x5c>
  {
    MemPtr1 = LMM001_realloc(&GMM001_handle0, MemPtr, size);
 800b100:	f246 40fc 	movw	r0, #25852	; 0x64fc
 800b104:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b108:	6839      	ldr	r1, [r7, #0]
 800b10a:	687a      	ldr	r2, [r7, #4]
 800b10c:	f7ff fb9e 	bl	800a84c <LMM001_realloc>
 800b110:	60f8      	str	r0, [r7, #12]
 800b112:	e03a      	b.n	800b18a <GMM001_realloc+0xd2>
  }

/*<<<DD_GMM001_API_3_2>>>*/   
  else if (((uint32_t)MemPtr >= (uint32_t)Heap_Bank2_Start) && ((uint32_t)MemPtr <= ((uint32_t)Heap_Bank2_Start + LENGTH2)))
 800b114:	683a      	ldr	r2, [r7, #0]
 800b116:	f644 1320 	movw	r3, #18720	; 0x4920
 800b11a:	f2c3 0300 	movt	r3, #12288	; 0x3000
 800b11e:	429a      	cmp	r2, r3
 800b120:	d316      	bcc.n	800b150 <GMM001_realloc+0x98>
 800b122:	683a      	ldr	r2, [r7, #0]
 800b124:	f246 63a8 	movw	r3, #26280	; 0x66a8
 800b128:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b12c:	6819      	ldr	r1, [r3, #0]
 800b12e:	f644 1320 	movw	r3, #18720	; 0x4920
 800b132:	f2c3 0300 	movt	r3, #12288	; 0x3000
 800b136:	18cb      	adds	r3, r1, r3
 800b138:	429a      	cmp	r2, r3
 800b13a:	d809      	bhi.n	800b150 <GMM001_realloc+0x98>
  {
 	MemPtr1 = LMM001_realloc(&GMM001_handle1, MemPtr, size);
 800b13c:	f246 40ec 	movw	r0, #25836	; 0x64ec
 800b140:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b144:	6839      	ldr	r1, [r7, #0]
 800b146:	687a      	ldr	r2, [r7, #4]
 800b148:	f7ff fb80 	bl	800a84c <LMM001_realloc>
 800b14c:	60f8      	str	r0, [r7, #12]
 800b14e:	e01c      	b.n	800b18a <GMM001_realloc+0xd2>
  }

/*<<<DD_GMM001_API_3_3>>>*/   
  else if (((uint32_t)MemPtr >= (uint32_t)Heap_Bank3_Start) && ((uint32_t)MemPtr <= ((uint32_t)Heap_Bank3_Start + LENGTH3)))
 800b150:	683a      	ldr	r2, [r7, #0]
 800b152:	f240 0300 	movw	r3, #0
 800b156:	f2c1 0300 	movt	r3, #4096	; 0x1000
 800b15a:	429a      	cmp	r2, r3
 800b15c:	d315      	bcc.n	800b18a <GMM001_realloc+0xd2>
 800b15e:	683a      	ldr	r2, [r7, #0]
 800b160:	f246 63ac 	movw	r3, #26284	; 0x66ac
 800b164:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b168:	6819      	ldr	r1, [r3, #0]
 800b16a:	f240 0300 	movw	r3, #0
 800b16e:	f2c1 0300 	movt	r3, #4096	; 0x1000
 800b172:	18cb      	adds	r3, r1, r3
 800b174:	429a      	cmp	r2, r3
 800b176:	d808      	bhi.n	800b18a <GMM001_realloc+0xd2>
  {
    MemPtr1 = LMM001_realloc(&GMM001_handle2, MemPtr, size);
 800b178:	f246 40f4 	movw	r0, #25844	; 0x64f4
 800b17c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b180:	6839      	ldr	r1, [r7, #0]
 800b182:	687a      	ldr	r2, [r7, #4]
 800b184:	f7ff fb62 	bl	800a84c <LMM001_realloc>
 800b188:	60f8      	str	r0, [r7, #12]
  }
  FUNCTION_EXIT(GID_GMM001, (uint32_t)GMM001_FUNCTION_EXIT);
  return MemPtr1;
 800b18a:	68fb      	ldr	r3, [r7, #12]
}
 800b18c:	4618      	mov	r0, r3
 800b18e:	f107 0710 	add.w	r7, r7, #16
 800b192:	46bd      	mov	sp, r7
 800b194:	bd80      	pop	{r7, pc}
 800b196:	bf00      	nop

0800b198 <GMM001_free>:
/*<<<DD_GMM001_API_4>>>*/ 
/*
 *  The function deallocates the memory pointed by Memptr.
 */
void GMM001_free (void * MemPtr)
{
 800b198:	b580      	push	{r7, lr}
 800b19a:	b082      	sub	sp, #8
 800b19c:	af00      	add	r7, sp, #0
 800b19e:	6078      	str	r0, [r7, #4]
  FUNCTION_ENTRY(GID_GMM001, (uint32_t)GMM001_FUNCTION_ENTRY);

/*<<<DD_GMM001_API_4_1>>>*/   
  if (((uint32_t)MemPtr >= (uint32_t)Heap_Bank1_Start) && ((uint32_t)MemPtr <= ((uint32_t)Heap_Bank1_Start + LENGTH1)))
 800b1a0:	687a      	ldr	r2, [r7, #4]
 800b1a2:	f646 33d0 	movw	r3, #27600	; 0x6bd0
 800b1a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b1aa:	429a      	cmp	r2, r3
 800b1ac:	d314      	bcc.n	800b1d8 <GMM001_free+0x40>
 800b1ae:	687a      	ldr	r2, [r7, #4]
 800b1b0:	f246 63a4 	movw	r3, #26276	; 0x66a4
 800b1b4:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b1b8:	6819      	ldr	r1, [r3, #0]
 800b1ba:	f646 33d0 	movw	r3, #27600	; 0x6bd0
 800b1be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b1c2:	18cb      	adds	r3, r1, r3
 800b1c4:	429a      	cmp	r2, r3
 800b1c6:	d807      	bhi.n	800b1d8 <GMM001_free+0x40>
  {
    LMM001_free(&GMM001_handle0, MemPtr);
 800b1c8:	f246 40fc 	movw	r0, #25852	; 0x64fc
 800b1cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b1d0:	6879      	ldr	r1, [r7, #4]
 800b1d2:	f7ff f9c5 	bl	800a560 <LMM001_free>
 800b1d6:	e036      	b.n	800b246 <GMM001_free+0xae>
  }

/*<<<DD_GMM001_API_4_2>>>*/   
  else if (((uint32_t)MemPtr >= (uint32_t)Heap_Bank2_Start) && ((uint32_t)MemPtr <= ((uint32_t)Heap_Bank2_Start + LENGTH2)))
 800b1d8:	687a      	ldr	r2, [r7, #4]
 800b1da:	f644 1320 	movw	r3, #18720	; 0x4920
 800b1de:	f2c3 0300 	movt	r3, #12288	; 0x3000
 800b1e2:	429a      	cmp	r2, r3
 800b1e4:	d314      	bcc.n	800b210 <GMM001_free+0x78>
 800b1e6:	687a      	ldr	r2, [r7, #4]
 800b1e8:	f246 63a8 	movw	r3, #26280	; 0x66a8
 800b1ec:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b1f0:	6819      	ldr	r1, [r3, #0]
 800b1f2:	f644 1320 	movw	r3, #18720	; 0x4920
 800b1f6:	f2c3 0300 	movt	r3, #12288	; 0x3000
 800b1fa:	18cb      	adds	r3, r1, r3
 800b1fc:	429a      	cmp	r2, r3
 800b1fe:	d807      	bhi.n	800b210 <GMM001_free+0x78>
  {
    LMM001_free(&GMM001_handle1, MemPtr);
 800b200:	f246 40ec 	movw	r0, #25836	; 0x64ec
 800b204:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b208:	6879      	ldr	r1, [r7, #4]
 800b20a:	f7ff f9a9 	bl	800a560 <LMM001_free>
 800b20e:	e01a      	b.n	800b246 <GMM001_free+0xae>
  }

/*<<<DD_GMM001_API_4_3>>>*/   
  else if (((uint32_t)MemPtr >= (uint32_t)Heap_Bank3_Start) && ((uint32_t)MemPtr <= ((uint32_t)Heap_Bank3_Start + LENGTH3)))
 800b210:	687a      	ldr	r2, [r7, #4]
 800b212:	f240 0300 	movw	r3, #0
 800b216:	f2c1 0300 	movt	r3, #4096	; 0x1000
 800b21a:	429a      	cmp	r2, r3
 800b21c:	d313      	bcc.n	800b246 <GMM001_free+0xae>
 800b21e:	687a      	ldr	r2, [r7, #4]
 800b220:	f246 63ac 	movw	r3, #26284	; 0x66ac
 800b224:	f6c0 0302 	movt	r3, #2050	; 0x802
 800b228:	6819      	ldr	r1, [r3, #0]
 800b22a:	f240 0300 	movw	r3, #0
 800b22e:	f2c1 0300 	movt	r3, #4096	; 0x1000
 800b232:	18cb      	adds	r3, r1, r3
 800b234:	429a      	cmp	r2, r3
 800b236:	d806      	bhi.n	800b246 <GMM001_free+0xae>
  {
    LMM001_free(&GMM001_handle2, MemPtr);
 800b238:	f246 40f4 	movw	r0, #25844	; 0x64f4
 800b23c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800b240:	6879      	ldr	r1, [r7, #4]
 800b242:	f7ff f98d 	bl	800a560 <LMM001_free>
  }
  FUNCTION_EXIT(GID_GMM001, (uint32_t)GMM001_FUNCTION_EXIT);
}
 800b246:	f107 0708 	add.w	r7, r7, #8
 800b24a:	46bd      	mov	sp, r7
 800b24c:	bd80      	pop	{r7, pc}
 800b24e:	bf00      	nop

0800b250 <disk_initialize>:
/*<<<DD_FATFS004_API_1>>>*/
/*
 * The function performs the disk initialization.
 */
DSTATUS disk_initialize(BYTE Drive)
{
 800b250:	b580      	push	{r7, lr}
 800b252:	b084      	sub	sp, #16
 800b254:	af00      	add	r7, sp, #0
 800b256:	4603      	mov	r3, r0
 800b258:	71fb      	strb	r3, [r7, #7]
  DSTATUS DStatus = 0;
 800b25a:	f04f 0300 	mov.w	r3, #0
 800b25e:	73fb      	strb	r3, [r7, #15]
  FUNCTION_ENTRY(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_ENTRY);
  do
  {
/*<<<DD_FATFS004_API_1_1>>*/
/* If drive number is greater than the maximum drives allowed  */
    if (Drive >= FATFS004_MAX_DRIVES)
 800b260:	79fb      	ldrb	r3, [r7, #7]
 800b262:	2b00      	cmp	r3, #0
 800b264:	d003      	beq.n	800b26e <disk_initialize+0x1e>
    {
      DStatus = (STA_NODISK | STA_NOINIT);
 800b266:	f04f 0303 	mov.w	r3, #3
 800b26a:	73fb      	strb	r3, [r7, #15]
      break;
 800b26c:	e016      	b.n	800b29c <disk_initialize+0x4c>
    }
    /* Call the Initialize function. */
/*<<<DD_FATFS004_API_1_2>>*/
    Status = FATFS004_DeviceFunc[Drive].InitializePtr();
 800b26e:	79f9      	ldrb	r1, [r7, #7]
 800b270:	f246 62b0 	movw	r2, #26288	; 0x66b0
 800b274:	f6c0 0202 	movt	r2, #2050	; 0x802
 800b278:	460b      	mov	r3, r1
 800b27a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b27e:	185b      	adds	r3, r3, r1
 800b280:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b284:	18d3      	adds	r3, r2, r3
 800b286:	681b      	ldr	r3, [r3, #0]
 800b288:	4798      	blx	r3
 800b28a:	4603      	mov	r3, r0
 800b28c:	73bb      	strb	r3, [r7, #14]
/* Fatfs to Block Layer Error Code Mapping */
    DStatus = FATFS004_StatusCodes[Status];
 800b28e:	7bba      	ldrb	r2, [r7, #14]
 800b290:	f246 63d8 	movw	r3, #26328	; 0x66d8
 800b294:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b298:	5c9b      	ldrb	r3, [r3, r2]
 800b29a:	73fb      	strb	r3, [r7, #15]
  } while (0);
  FUNCTION_EXIT(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_EXIT);
  return DStatus;
 800b29c:	7bfb      	ldrb	r3, [r7, #15]
}
 800b29e:	4618      	mov	r0, r3
 800b2a0:	f107 0710 	add.w	r7, r7, #16
 800b2a4:	46bd      	mov	sp, r7
 800b2a6:	bd80      	pop	{r7, pc}

0800b2a8 <disk_status>:
/*<<<DD_FATFS004_API_2>>>  */
/*
 * The function gets the disk status information.
 */
DSTATUS disk_status(BYTE Drive)
{
 800b2a8:	b580      	push	{r7, lr}
 800b2aa:	b084      	sub	sp, #16
 800b2ac:	af00      	add	r7, sp, #0
 800b2ae:	4603      	mov	r3, r0
 800b2b0:	71fb      	strb	r3, [r7, #7]
  FUNCTION_ENTRY(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_ENTRY);
  do
  {
/*  <<<DD_FATFS004_API_2_1>>>  */
/* If drive number is greater than the maximum drives allowed  */
    if (Drive >= FATFS004_MAX_DRIVES)
 800b2b2:	79fb      	ldrb	r3, [r7, #7]
 800b2b4:	2b00      	cmp	r3, #0
 800b2b6:	d003      	beq.n	800b2c0 <disk_status+0x18>
    {
      DStatus = (STA_NODISK | STA_NOINIT);
 800b2b8:	f04f 0303 	mov.w	r3, #3
 800b2bc:	73fb      	strb	r3, [r7, #15]
      break;
 800b2be:	e018      	b.n	800b2f2 <disk_status+0x4a>
    }
    /* Call the Initialize function.*/
/*<<<DD_FATFS004_API_2_2>>>  */
    Status = FATFS004_DeviceFunc[Drive].GetStatusPtr();
 800b2c0:	79f9      	ldrb	r1, [r7, #7]
 800b2c2:	f246 62b0 	movw	r2, #26288	; 0x66b0
 800b2c6:	f6c0 0202 	movt	r2, #2050	; 0x802
 800b2ca:	460b      	mov	r3, r1
 800b2cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b2d0:	185b      	adds	r3, r3, r1
 800b2d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b2d6:	18d3      	adds	r3, r2, r3
 800b2d8:	f103 0304 	add.w	r3, r3, #4
 800b2dc:	681b      	ldr	r3, [r3, #0]
 800b2de:	4798      	blx	r3
 800b2e0:	4603      	mov	r3, r0
 800b2e2:	73bb      	strb	r3, [r7, #14]
/* Fatfs to Block Layer Error Code Mapping */
    DStatus = FATFS004_StatusCodes[Status];
 800b2e4:	7bba      	ldrb	r2, [r7, #14]
 800b2e6:	f246 63d8 	movw	r3, #26328	; 0x66d8
 800b2ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b2ee:	5c9b      	ldrb	r3, [r3, r2]
 800b2f0:	73fb      	strb	r3, [r7, #15]
  } while (0);
  ERROR(GID_FATFS004,FATFS004_SDMMC002_ERROR,0,0);
  FUNCTION_EXIT(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_EXIT);
  return DStatus;
 800b2f2:	7bfb      	ldrb	r3, [r7, #15]
}
 800b2f4:	4618      	mov	r0, r3
 800b2f6:	f107 0710 	add.w	r7, r7, #16
 800b2fa:	46bd      	mov	sp, r7
 800b2fc:	bd80      	pop	{r7, pc}
 800b2fe:	bf00      	nop

0800b300 <disk_read>:
  BYTE Drive,
  BYTE *Buffer,
  DWORD SectorNumber,
  BYTE SectorCount
)
{
 800b300:	b580      	push	{r7, lr}
 800b302:	b086      	sub	sp, #24
 800b304:	af00      	add	r7, sp, #0
 800b306:	60b9      	str	r1, [r7, #8]
 800b308:	607a      	str	r2, [r7, #4]
 800b30a:	4602      	mov	r2, r0
 800b30c:	73fa      	strb	r2, [r7, #15]
 800b30e:	73bb      	strb	r3, [r7, #14]
  FUNCTION_ENTRY(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_ENTRY);
  do
  {
/*<<<DD_FATFS004_API_3_1>>>*/
/* If drive number is greater than the maximum drives allowed  */
    if (Drive >= FATFS004_MAX_DRIVES )
 800b310:	7bfb      	ldrb	r3, [r7, #15]
 800b312:	2b00      	cmp	r3, #0
 800b314:	d003      	beq.n	800b31e <disk_read+0x1e>
    {
      DResult = RES_PARERR;
 800b316:	f04f 0304 	mov.w	r3, #4
 800b31a:	75fb      	strb	r3, [r7, #23]
      break;
 800b31c:	e02b      	b.n	800b376 <disk_read+0x76>
    }
/*<<<DD_FATFS004_API_3_2>>>*/
    /* If sector count is less than 1. Minimum 1 sector is needed*/
    if (SectorCount < 1)
 800b31e:	7bbb      	ldrb	r3, [r7, #14]
 800b320:	2b00      	cmp	r3, #0
 800b322:	d103      	bne.n	800b32c <disk_read+0x2c>
    {
      DResult = RES_PARERR;
 800b324:	f04f 0304 	mov.w	r3, #4
 800b328:	75fb      	strb	r3, [r7, #23]
      break;
 800b32a:	e024      	b.n	800b376 <disk_read+0x76>
    }
/*<<<DD_FATFS004_API_3_3>>>*/
    /* For BufferPtr not aligned */
    if (((uint32_t)Buffer % 4UL) != 0UL)
 800b32c:	68bb      	ldr	r3, [r7, #8]
 800b32e:	f003 0303 	and.w	r3, r3, #3
 800b332:	2b00      	cmp	r3, #0
 800b334:	d003      	beq.n	800b33e <disk_read+0x3e>
    {
      DResult = RES_PARERR;
 800b336:	f04f 0304 	mov.w	r3, #4
 800b33a:	75fb      	strb	r3, [r7, #23]
      break;
 800b33c:	e01b      	b.n	800b376 <disk_read+0x76>
    }
/*<<<DD_FATFS004_API_3_4>>>*/
    /*Call the ReadBlkPtr function.*/
    Result = FATFS004_DeviceFunc[Drive].ReadBlkPtr(Buffer, SectorNumber, \
 800b33e:	7bf9      	ldrb	r1, [r7, #15]
 800b340:	f246 62b0 	movw	r2, #26288	; 0x66b0
 800b344:	f6c0 0202 	movt	r2, #2050	; 0x802
 800b348:	460b      	mov	r3, r1
 800b34a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b34e:	185b      	adds	r3, r3, r1
 800b350:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b354:	18d3      	adds	r3, r2, r3
 800b356:	f103 0308 	add.w	r3, r3, #8
 800b35a:	681b      	ldr	r3, [r3, #0]
 800b35c:	7bba      	ldrb	r2, [r7, #14]
 800b35e:	68b8      	ldr	r0, [r7, #8]
 800b360:	6879      	ldr	r1, [r7, #4]
 800b362:	4798      	blx	r3
 800b364:	6138      	str	r0, [r7, #16]
                                                    SectorCount);
/* Fatfs to Block Layer Error Code Mapping */
    DResult = FATFS004_ErrorCodes[Result];                                               
 800b366:	f246 63d0 	movw	r3, #26320	; 0x66d0
 800b36a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b36e:	693a      	ldr	r2, [r7, #16]
 800b370:	189b      	adds	r3, r3, r2
 800b372:	781b      	ldrb	r3, [r3, #0]
 800b374:	75fb      	strb	r3, [r7, #23]
  } while (0);
  ERROR(GID_FATFS004,FATFS004_SDMMC001_ERROR,0,0);
  FUNCTION_EXIT(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_EXIT);
  return DResult;
 800b376:	7dfb      	ldrb	r3, [r7, #23]
}
 800b378:	4618      	mov	r0, r3
 800b37a:	f107 0718 	add.w	r7, r7, #24
 800b37e:	46bd      	mov	sp, r7
 800b380:	bd80      	pop	{r7, pc}
 800b382:	bf00      	nop

0800b384 <disk_write>:
  BYTE Drive,
  const BYTE*  Buffer,
  DWORD SectorNumber,
  BYTE  SectorCount
)
{
 800b384:	b580      	push	{r7, lr}
 800b386:	b086      	sub	sp, #24
 800b388:	af00      	add	r7, sp, #0
 800b38a:	60b9      	str	r1, [r7, #8]
 800b38c:	607a      	str	r2, [r7, #4]
 800b38e:	4602      	mov	r2, r0
 800b390:	73fa      	strb	r2, [r7, #15]
 800b392:	73bb      	strb	r3, [r7, #14]
  FUNCTION_ENTRY(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_ENTRY);
  do
  {
/*<<<DD_FATFS004_API_4_1>>>*/
    /* If drive number is greater than the maximum drives allowed  */
    if (Drive >= FATFS004_MAX_DRIVES)
 800b394:	7bfb      	ldrb	r3, [r7, #15]
 800b396:	2b00      	cmp	r3, #0
 800b398:	d003      	beq.n	800b3a2 <disk_write+0x1e>
    {
      DResult = RES_PARERR;
 800b39a:	f04f 0304 	mov.w	r3, #4
 800b39e:	75fb      	strb	r3, [r7, #23]
      break;
 800b3a0:	e02b      	b.n	800b3fa <disk_write+0x76>
    }
/*<<<DD_FATFS004_API_4_2>>> */
    /* If sector count is less than 1. Minimum 1 sector is needed*/
    if (SectorCount < 1)
 800b3a2:	7bbb      	ldrb	r3, [r7, #14]
 800b3a4:	2b00      	cmp	r3, #0
 800b3a6:	d103      	bne.n	800b3b0 <disk_write+0x2c>
    {
      DResult = RES_PARERR;
 800b3a8:	f04f 0304 	mov.w	r3, #4
 800b3ac:	75fb      	strb	r3, [r7, #23]
      break;
 800b3ae:	e024      	b.n	800b3fa <disk_write+0x76>
    }
/*<<<DD_FATFS004_API_4_3>>> */
    /* for BufferPtr not aligned */
    if (((uint32_t)Buffer % 4UL) != 0UL)
 800b3b0:	68bb      	ldr	r3, [r7, #8]
 800b3b2:	f003 0303 	and.w	r3, r3, #3
 800b3b6:	2b00      	cmp	r3, #0
 800b3b8:	d003      	beq.n	800b3c2 <disk_write+0x3e>
    {
      DResult = RES_PARERR;
 800b3ba:	f04f 0304 	mov.w	r3, #4
 800b3be:	75fb      	strb	r3, [r7, #23]
      break;
 800b3c0:	e01b      	b.n	800b3fa <disk_write+0x76>
    }
/*<<<DD_FATFS004_API_4_4>>> */
    /*Call the WriteBlkPtr function.*/
    Result = FATFS004_DeviceFunc[Drive].WriteBlkPtr(Buffer, SectorNumber, SectorCount);
 800b3c2:	7bf9      	ldrb	r1, [r7, #15]
 800b3c4:	f246 62b0 	movw	r2, #26288	; 0x66b0
 800b3c8:	f6c0 0202 	movt	r2, #2050	; 0x802
 800b3cc:	460b      	mov	r3, r1
 800b3ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b3d2:	185b      	adds	r3, r3, r1
 800b3d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b3d8:	18d3      	adds	r3, r2, r3
 800b3da:	f103 030c 	add.w	r3, r3, #12
 800b3de:	681b      	ldr	r3, [r3, #0]
 800b3e0:	7bba      	ldrb	r2, [r7, #14]
 800b3e2:	68b8      	ldr	r0, [r7, #8]
 800b3e4:	6879      	ldr	r1, [r7, #4]
 800b3e6:	4798      	blx	r3
 800b3e8:	6138      	str	r0, [r7, #16]
/* Fatfs to Block Layer Error Code Mapping */
    DResult = FATFS004_ErrorCodes[Result];  
 800b3ea:	f246 63d0 	movw	r3, #26320	; 0x66d0
 800b3ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b3f2:	693a      	ldr	r2, [r7, #16]
 800b3f4:	189b      	adds	r3, r3, r2
 800b3f6:	781b      	ldrb	r3, [r3, #0]
 800b3f8:	75fb      	strb	r3, [r7, #23]
  } while (0);
  ERROR(GID_FATFS004,FATFS004_SDMMC002_ERROR,0,0);
  FUNCTION_EXIT(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_EXIT);
  return DResult;
 800b3fa:	7dfb      	ldrb	r3, [r7, #23]
}
 800b3fc:	4618      	mov	r0, r3
 800b3fe:	f107 0718 	add.w	r7, r7, #24
 800b402:	46bd      	mov	sp, r7
 800b404:	bd80      	pop	{r7, pc}
 800b406:	bf00      	nop

0800b408 <disk_ioctl>:
/*<<<DD_FATFS004_API_5>>>*/
/*
 * The function performs the various IOCTL operation.
 */
DRESULT  disk_ioctl(BYTE Drive, BYTE Command, void * Buffer)
{
 800b408:	b580      	push	{r7, lr}
 800b40a:	b084      	sub	sp, #16
 800b40c:	af00      	add	r7, sp, #0
 800b40e:	460b      	mov	r3, r1
 800b410:	603a      	str	r2, [r7, #0]
 800b412:	4602      	mov	r2, r0
 800b414:	71fa      	strb	r2, [r7, #7]
 800b416:	71bb      	strb	r3, [r7, #6]
  uint32_t Result;
  FUNCTION_ENTRY(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_ENTRY);
  do
  {
/*<<<DD_FATFS004_API_5_1>>>*/
    if (Drive >= FATFS004_MAX_DRIVES)
 800b418:	79fb      	ldrb	r3, [r7, #7]
 800b41a:	2b00      	cmp	r3, #0
 800b41c:	d003      	beq.n	800b426 <disk_ioctl+0x1e>
    {
      DResult = RES_PARERR;
 800b41e:	f04f 0304 	mov.w	r3, #4
 800b422:	73fb      	strb	r3, [r7, #15]
      break;
 800b424:	e024      	b.n	800b470 <disk_ioctl+0x68>
    }
    /* for BufferPtr not aligned */
/*<<<DD_FATFS004_API_5_2>>>*/
    if (((uint32_t)Buffer % 4UL) != 0UL)
 800b426:	683b      	ldr	r3, [r7, #0]
 800b428:	f003 0303 	and.w	r3, r3, #3
 800b42c:	2b00      	cmp	r3, #0
 800b42e:	d003      	beq.n	800b438 <disk_ioctl+0x30>
    {
      DResult = RES_PARERR;
 800b430:	f04f 0304 	mov.w	r3, #4
 800b434:	73fb      	strb	r3, [r7, #15]
      break;
 800b436:	e01b      	b.n	800b470 <disk_ioctl+0x68>
    }
/*<<<DD_FATFS004_API_5_3>>>*/
    /*Call the Ioctl function.*/
    Result = FATFS004_DeviceFunc[Drive].IoctlPtr(Command, Buffer);
 800b438:	79f9      	ldrb	r1, [r7, #7]
 800b43a:	f246 62b0 	movw	r2, #26288	; 0x66b0
 800b43e:	f6c0 0202 	movt	r2, #2050	; 0x802
 800b442:	460b      	mov	r3, r1
 800b444:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b448:	185b      	adds	r3, r3, r1
 800b44a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b44e:	18d3      	adds	r3, r2, r3
 800b450:	f103 0310 	add.w	r3, r3, #16
 800b454:	681b      	ldr	r3, [r3, #0]
 800b456:	79ba      	ldrb	r2, [r7, #6]
 800b458:	4610      	mov	r0, r2
 800b45a:	6839      	ldr	r1, [r7, #0]
 800b45c:	4798      	blx	r3
 800b45e:	60b8      	str	r0, [r7, #8]
/* Fatfs to Block Layer Error Code Mapping */
    DResult = FATFS004_ErrorCodes[Result];  
 800b460:	f246 63d0 	movw	r3, #26320	; 0x66d0
 800b464:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b468:	68ba      	ldr	r2, [r7, #8]
 800b46a:	189b      	adds	r3, r3, r2
 800b46c:	781b      	ldrb	r3, [r3, #0]
 800b46e:	73fb      	strb	r3, [r7, #15]
  } while (0);
  ERROR(GID_FATFS004,FATFS004_SDMMC002_ERROR,0,0);
  FUNCTION_EXIT(GID_FATFS004, (uint32_t)FATFS004_FUNCTION_EXIT);
  return DResult;
 800b470:	7bfb      	ldrb	r3, [r7, #15]
}
 800b472:	4618      	mov	r0, r3
 800b474:	f107 0710 	add.w	r7, r7, #16
 800b478:	46bd      	mov	sp, r7
 800b47a:	bd80      	pop	{r7, pc}

0800b47c <get_fattime>:
/**
 * This is a real time clock service to be called from
 * FatFs module.This function is not required in read-only cfg
 */
DWORD get_fattime()
{
 800b47c:	b580      	push	{r7, lr}
 800b47e:	b082      	sub	sp, #8
 800b480:	af00      	add	r7, sp, #0
  RTC001_TimeHandle Time = {0};  
 800b482:	f04f 0300 	mov.w	r3, #0
 800b486:	603b      	str	r3, [r7, #0]
 800b488:	f04f 0300 	mov.w	r3, #0
 800b48c:	607b      	str	r3, [r7, #4]
  FATFS004_UnusedStatus = RTC001_Clock_GetTime(&Time);
 800b48e:	463b      	mov	r3, r7
 800b490:	4618      	mov	r0, r3
 800b492:	f7fd ff6b 	bl	800936c <RTC001_Clock_GetTime>
 800b496:	4602      	mov	r2, r0
 800b498:	f246 5304 	movw	r3, #25860	; 0x6504
 800b49c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4a0:	601a      	str	r2, [r3, #0]
/* Pack date and time into a DWORD variable */
  return    ((DWORD)(Time.Year - 1980) << 25)
 800b4a2:	88fb      	ldrh	r3, [r7, #6]
 800b4a4:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
 800b4a8:	ea4f 6243 	mov.w	r2, r3, lsl #25
      | ((DWORD)Time.Month << 21)
 800b4ac:	797b      	ldrb	r3, [r7, #5]
 800b4ae:	ea4f 5343 	mov.w	r3, r3, lsl #21
 800b4b2:	431a      	orrs	r2, r3
      | ((DWORD)Time.Days << 16)
 800b4b4:	78fb      	ldrb	r3, [r7, #3]
 800b4b6:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800b4ba:	431a      	orrs	r2, r3
      | ((DWORD)Time.Hours << 11)
 800b4bc:	78bb      	ldrb	r3, [r7, #2]
 800b4be:	ea4f 23c3 	mov.w	r3, r3, lsl #11
 800b4c2:	431a      	orrs	r2, r3
      | ((DWORD)Time.Min << 5)
 800b4c4:	787b      	ldrb	r3, [r7, #1]
 800b4c6:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800b4ca:	431a      	orrs	r2, r3
      | ((DWORD)Time.Sec >> 1);
 800b4cc:	783b      	ldrb	r3, [r7, #0]
 800b4ce:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800b4d2:	b2db      	uxtb	r3, r3
DWORD get_fattime()
{
  RTC001_TimeHandle Time = {0};  
  FATFS004_UnusedStatus = RTC001_Clock_GetTime(&Time);
/* Pack date and time into a DWORD variable */
  return    ((DWORD)(Time.Year - 1980) << 25)
 800b4d4:	4313      	orrs	r3, r2
      | ((DWORD)Time.Month << 21)
      | ((DWORD)Time.Days << 16)
      | ((DWORD)Time.Hours << 11)
      | ((DWORD)Time.Min << 5)
      | ((DWORD)Time.Sec >> 1);
}
 800b4d6:	4618      	mov	r0, r3
 800b4d8:	f107 0708 	add.w	r7, r7, #8
 800b4dc:	46bd      	mov	sp, r7
 800b4de:	bd80      	pop	{r7, pc}

0800b4e0 <FATFS002_Init>:
*******************************************************************************/
/* This functions creates mutex for the file system. Since Fatfs doesn't supports 
 * extended partition feature, only 4 logical partitions can be created.
 */
void FATFS002_Init()
{
 800b4e0:	b480      	push	{r7}
 800b4e2:	af00      	add	r7, sp, #0
  if (/* !N_DBG*/(NULL ==  FATFS002_MutexProtectId ))
  {
    ERROR(GID_FATFS002, FATFS002_MUTEX_CREATE_FAILED, 0, 0);
  }
#endif
}
 800b4e4:	46bd      	mov	sp, r7
 800b4e6:	bc80      	pop	{r7}
 800b4e8:	4770      	bx	lr
 800b4ea:	bf00      	nop

0800b4ec <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800b4ec:	b480      	push	{r7}
 800b4ee:	b087      	sub	sp, #28
 800b4f0:	af00      	add	r7, sp, #0
 800b4f2:	60f8      	str	r0, [r7, #12]
 800b4f4:	60b9      	str	r1, [r7, #8]
 800b4f6:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 800b4f8:	68fb      	ldr	r3, [r7, #12]
 800b4fa:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
 800b4fc:	68bb      	ldr	r3, [r7, #8]
 800b4fe:	613b      	str	r3, [r7, #16]
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
 800b500:	e00b      	b.n	800b51a <mem_cpy+0x2e>
		*d++ = *s++;
 800b502:	693b      	ldr	r3, [r7, #16]
 800b504:	781a      	ldrb	r2, [r3, #0]
 800b506:	697b      	ldr	r3, [r7, #20]
 800b508:	701a      	strb	r2, [r3, #0]
 800b50a:	697b      	ldr	r3, [r7, #20]
 800b50c:	f103 0301 	add.w	r3, r3, #1
 800b510:	617b      	str	r3, [r7, #20]
 800b512:	693b      	ldr	r3, [r7, #16]
 800b514:	f103 0301 	add.w	r3, r3, #1
 800b518:	613b      	str	r3, [r7, #16]
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
 800b51a:	687b      	ldr	r3, [r7, #4]
 800b51c:	2b00      	cmp	r3, #0
 800b51e:	bf0c      	ite	eq
 800b520:	2300      	moveq	r3, #0
 800b522:	2301      	movne	r3, #1
 800b524:	b2db      	uxtb	r3, r3
 800b526:	687a      	ldr	r2, [r7, #4]
 800b528:	f102 32ff 	add.w	r2, r2, #4294967295
 800b52c:	607a      	str	r2, [r7, #4]
 800b52e:	2b00      	cmp	r3, #0
 800b530:	d1e7      	bne.n	800b502 <mem_cpy+0x16>
		*d++ = *s++;
}
 800b532:	f107 071c 	add.w	r7, r7, #28
 800b536:	46bd      	mov	sp, r7
 800b538:	bc80      	pop	{r7}
 800b53a:	4770      	bx	lr

0800b53c <mem_set>:

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
 800b53c:	b480      	push	{r7}
 800b53e:	b087      	sub	sp, #28
 800b540:	af00      	add	r7, sp, #0
 800b542:	60f8      	str	r0, [r7, #12]
 800b544:	60b9      	str	r1, [r7, #8]
 800b546:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 800b548:	68fb      	ldr	r3, [r7, #12]
 800b54a:	617b      	str	r3, [r7, #20]

	while (cnt--)
 800b54c:	e007      	b.n	800b55e <mem_set+0x22>
		*d++ = (BYTE)val;
 800b54e:	68bb      	ldr	r3, [r7, #8]
 800b550:	b2da      	uxtb	r2, r3
 800b552:	697b      	ldr	r3, [r7, #20]
 800b554:	701a      	strb	r2, [r3, #0]
 800b556:	697b      	ldr	r3, [r7, #20]
 800b558:	f103 0301 	add.w	r3, r3, #1
 800b55c:	617b      	str	r3, [r7, #20]
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 800b55e:	687b      	ldr	r3, [r7, #4]
 800b560:	2b00      	cmp	r3, #0
 800b562:	bf0c      	ite	eq
 800b564:	2300      	moveq	r3, #0
 800b566:	2301      	movne	r3, #1
 800b568:	b2db      	uxtb	r3, r3
 800b56a:	687a      	ldr	r2, [r7, #4]
 800b56c:	f102 32ff 	add.w	r2, r2, #4294967295
 800b570:	607a      	str	r2, [r7, #4]
 800b572:	2b00      	cmp	r3, #0
 800b574:	d1eb      	bne.n	800b54e <mem_set+0x12>
		*d++ = (BYTE)val;
}
 800b576:	f107 071c 	add.w	r7, r7, #28
 800b57a:	46bd      	mov	sp, r7
 800b57c:	bc80      	pop	{r7}
 800b57e:	4770      	bx	lr

0800b580 <mem_cmp>:

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
 800b580:	b480      	push	{r7}
 800b582:	b089      	sub	sp, #36	; 0x24
 800b584:	af00      	add	r7, sp, #0
 800b586:	60f8      	str	r0, [r7, #12]
 800b588:	60b9      	str	r1, [r7, #8]
 800b58a:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 800b58c:	68fb      	ldr	r3, [r7, #12]
 800b58e:	61fb      	str	r3, [r7, #28]
 800b590:	68bb      	ldr	r3, [r7, #8]
 800b592:	61bb      	str	r3, [r7, #24]
	int r = 0;
 800b594:	f04f 0300 	mov.w	r3, #0
 800b598:	617b      	str	r3, [r7, #20]

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 800b59a:	bf00      	nop
 800b59c:	687b      	ldr	r3, [r7, #4]
 800b59e:	2b00      	cmp	r3, #0
 800b5a0:	bf0c      	ite	eq
 800b5a2:	2300      	moveq	r3, #0
 800b5a4:	2301      	movne	r3, #1
 800b5a6:	b2db      	uxtb	r3, r3
 800b5a8:	687a      	ldr	r2, [r7, #4]
 800b5aa:	f102 32ff 	add.w	r2, r2, #4294967295
 800b5ae:	607a      	str	r2, [r7, #4]
 800b5b0:	2b00      	cmp	r3, #0
 800b5b2:	d016      	beq.n	800b5e2 <mem_cmp+0x62>
 800b5b4:	69fb      	ldr	r3, [r7, #28]
 800b5b6:	781b      	ldrb	r3, [r3, #0]
 800b5b8:	461a      	mov	r2, r3
 800b5ba:	69bb      	ldr	r3, [r7, #24]
 800b5bc:	781b      	ldrb	r3, [r3, #0]
 800b5be:	1ad3      	subs	r3, r2, r3
 800b5c0:	617b      	str	r3, [r7, #20]
 800b5c2:	697b      	ldr	r3, [r7, #20]
 800b5c4:	2b00      	cmp	r3, #0
 800b5c6:	bf14      	ite	ne
 800b5c8:	2300      	movne	r3, #0
 800b5ca:	2301      	moveq	r3, #1
 800b5cc:	b2db      	uxtb	r3, r3
 800b5ce:	69fa      	ldr	r2, [r7, #28]
 800b5d0:	f102 0201 	add.w	r2, r2, #1
 800b5d4:	61fa      	str	r2, [r7, #28]
 800b5d6:	69ba      	ldr	r2, [r7, #24]
 800b5d8:	f102 0201 	add.w	r2, r2, #1
 800b5dc:	61ba      	str	r2, [r7, #24]
 800b5de:	2b00      	cmp	r3, #0
 800b5e0:	d1dc      	bne.n	800b59c <mem_cmp+0x1c>
	return r;
 800b5e2:	697b      	ldr	r3, [r7, #20]
}
 800b5e4:	4618      	mov	r0, r3
 800b5e6:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800b5ea:	46bd      	mov	sp, r7
 800b5ec:	bc80      	pop	{r7}
 800b5ee:	4770      	bx	lr

0800b5f0 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
 800b5f0:	b480      	push	{r7}
 800b5f2:	b083      	sub	sp, #12
 800b5f4:	af00      	add	r7, sp, #0
 800b5f6:	6078      	str	r0, [r7, #4]
 800b5f8:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
 800b5fa:	e003      	b.n	800b604 <chk_chr+0x14>
 800b5fc:	687b      	ldr	r3, [r7, #4]
 800b5fe:	f103 0301 	add.w	r3, r3, #1
 800b602:	607b      	str	r3, [r7, #4]
 800b604:	687b      	ldr	r3, [r7, #4]
 800b606:	781b      	ldrb	r3, [r3, #0]
 800b608:	2b00      	cmp	r3, #0
 800b60a:	d005      	beq.n	800b618 <chk_chr+0x28>
 800b60c:	687b      	ldr	r3, [r7, #4]
 800b60e:	781b      	ldrb	r3, [r3, #0]
 800b610:	461a      	mov	r2, r3
 800b612:	683b      	ldr	r3, [r7, #0]
 800b614:	429a      	cmp	r2, r3
 800b616:	d1f1      	bne.n	800b5fc <chk_chr+0xc>
	return *str;
 800b618:	687b      	ldr	r3, [r7, #4]
 800b61a:	781b      	ldrb	r3, [r3, #0]
}
 800b61c:	4618      	mov	r0, r3
 800b61e:	f107 070c 	add.w	r7, r7, #12
 800b622:	46bd      	mov	sp, r7
 800b624:	bc80      	pop	{r7}
 800b626:	4770      	bx	lr

0800b628 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
 800b628:	b580      	push	{r7, lr}
 800b62a:	b084      	sub	sp, #16
 800b62c:	af00      	add	r7, sp, #0
 800b62e:	6078      	str	r0, [r7, #4]
 800b630:	6039      	str	r1, [r7, #0]
	DWORD wsect;


	wsect = fs->winsect;
 800b632:	687b      	ldr	r3, [r7, #4]
 800b634:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b636:	60fb      	str	r3, [r7, #12]
	if (wsect != sector) {	/* Changed current window */
 800b638:	68fa      	ldr	r2, [r7, #12]
 800b63a:	683b      	ldr	r3, [r7, #0]
 800b63c:	429a      	cmp	r2, r3
 800b63e:	d055      	beq.n	800b6ec <move_window+0xc4>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
 800b640:	687b      	ldr	r3, [r7, #4]
 800b642:	791b      	ldrb	r3, [r3, #4]
 800b644:	2b00      	cmp	r3, #0
 800b646:	d039      	beq.n	800b6bc <move_window+0x94>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
 800b648:	687b      	ldr	r3, [r7, #4]
 800b64a:	785a      	ldrb	r2, [r3, #1]
 800b64c:	687b      	ldr	r3, [r7, #4]
 800b64e:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800b652:	4610      	mov	r0, r2
 800b654:	4619      	mov	r1, r3
 800b656:	68fa      	ldr	r2, [r7, #12]
 800b658:	f04f 0301 	mov.w	r3, #1
 800b65c:	f7ff fe92 	bl	800b384 <disk_write>
 800b660:	4603      	mov	r3, r0
 800b662:	2b00      	cmp	r3, #0
 800b664:	d002      	beq.n	800b66c <move_window+0x44>
				return FR_DISK_ERR;
 800b666:	f04f 0301 	mov.w	r3, #1
 800b66a:	e041      	b.n	800b6f0 <move_window+0xc8>
			fs->wflag = 0;
 800b66c:	687b      	ldr	r3, [r7, #4]
 800b66e:	f04f 0200 	mov.w	r2, #0
 800b672:	711a      	strb	r2, [r3, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
 800b674:	687b      	ldr	r3, [r7, #4]
 800b676:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b678:	687b      	ldr	r3, [r7, #4]
 800b67a:	6a1b      	ldr	r3, [r3, #32]
 800b67c:	18d2      	adds	r2, r2, r3
 800b67e:	68fb      	ldr	r3, [r7, #12]
 800b680:	429a      	cmp	r2, r3
 800b682:	d91b      	bls.n	800b6bc <move_window+0x94>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 800b684:	687b      	ldr	r3, [r7, #4]
 800b686:	78db      	ldrb	r3, [r3, #3]
 800b688:	72fb      	strb	r3, [r7, #11]
 800b68a:	e014      	b.n	800b6b6 <move_window+0x8e>
					wsect += fs->fsize;
 800b68c:	687b      	ldr	r3, [r7, #4]
 800b68e:	6a1b      	ldr	r3, [r3, #32]
 800b690:	68fa      	ldr	r2, [r7, #12]
 800b692:	18d3      	adds	r3, r2, r3
 800b694:	60fb      	str	r3, [r7, #12]
					disk_write(fs->drv, fs->win, wsect, 1);
 800b696:	687b      	ldr	r3, [r7, #4]
 800b698:	785a      	ldrb	r2, [r3, #1]
 800b69a:	687b      	ldr	r3, [r7, #4]
 800b69c:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800b6a0:	4610      	mov	r0, r2
 800b6a2:	4619      	mov	r1, r3
 800b6a4:	68fa      	ldr	r2, [r7, #12]
 800b6a6:	f04f 0301 	mov.w	r3, #1
 800b6aa:	f7ff fe6b 	bl	800b384 <disk_write>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
 800b6ae:	7afb      	ldrb	r3, [r7, #11]
 800b6b0:	f103 33ff 	add.w	r3, r3, #4294967295
 800b6b4:	72fb      	strb	r3, [r7, #11]
 800b6b6:	7afb      	ldrb	r3, [r7, #11]
 800b6b8:	2b01      	cmp	r3, #1
 800b6ba:	d8e7      	bhi.n	800b68c <move_window+0x64>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
 800b6bc:	683b      	ldr	r3, [r7, #0]
 800b6be:	2b00      	cmp	r3, #0
 800b6c0:	d014      	beq.n	800b6ec <move_window+0xc4>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 800b6c2:	687b      	ldr	r3, [r7, #4]
 800b6c4:	785a      	ldrb	r2, [r3, #1]
 800b6c6:	687b      	ldr	r3, [r7, #4]
 800b6c8:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800b6cc:	4610      	mov	r0, r2
 800b6ce:	4619      	mov	r1, r3
 800b6d0:	683a      	ldr	r2, [r7, #0]
 800b6d2:	f04f 0301 	mov.w	r3, #1
 800b6d6:	f7ff fe13 	bl	800b300 <disk_read>
 800b6da:	4603      	mov	r3, r0
 800b6dc:	2b00      	cmp	r3, #0
 800b6de:	d002      	beq.n	800b6e6 <move_window+0xbe>
				return FR_DISK_ERR;
 800b6e0:	f04f 0301 	mov.w	r3, #1
 800b6e4:	e004      	b.n	800b6f0 <move_window+0xc8>
			fs->winsect = sector;
 800b6e6:	687b      	ldr	r3, [r7, #4]
 800b6e8:	683a      	ldr	r2, [r7, #0]
 800b6ea:	631a      	str	r2, [r3, #48]	; 0x30
		}
	}

	return FR_OK;
 800b6ec:	f04f 0300 	mov.w	r3, #0
}
 800b6f0:	4618      	mov	r0, r3
 800b6f2:	f107 0710 	add.w	r7, r7, #16
 800b6f6:	46bd      	mov	sp, r7
 800b6f8:	bd80      	pop	{r7, pc}
 800b6fa:	bf00      	nop

0800b6fc <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
 800b6fc:	b580      	push	{r7, lr}
 800b6fe:	b084      	sub	sp, #16
 800b700:	af00      	add	r7, sp, #0
 800b702:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = move_window(fs, 0);
 800b704:	6878      	ldr	r0, [r7, #4]
 800b706:	f04f 0100 	mov.w	r1, #0
 800b70a:	f7ff ff8d 	bl	800b628 <move_window>
 800b70e:	4603      	mov	r3, r0
 800b710:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800b712:	7bfb      	ldrb	r3, [r7, #15]
 800b714:	2b00      	cmp	r3, #0
 800b716:	f040 80ab 	bne.w	800b870 <sync+0x174>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
 800b71a:	687b      	ldr	r3, [r7, #4]
 800b71c:	781b      	ldrb	r3, [r3, #0]
 800b71e:	2b03      	cmp	r3, #3
 800b720:	f040 8097 	bne.w	800b852 <sync+0x156>
 800b724:	687b      	ldr	r3, [r7, #4]
 800b726:	795b      	ldrb	r3, [r3, #5]
 800b728:	2b00      	cmp	r3, #0
 800b72a:	f000 8092 	beq.w	800b852 <sync+0x156>
			fs->winsect = 0;
 800b72e:	687b      	ldr	r3, [r7, #4]
 800b730:	f04f 0200 	mov.w	r2, #0
 800b734:	631a      	str	r2, [r3, #48]	; 0x30
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
 800b736:	687b      	ldr	r3, [r7, #4]
 800b738:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800b73c:	4618      	mov	r0, r3
 800b73e:	f04f 0100 	mov.w	r1, #0
 800b742:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b746:	f7ff fef9 	bl	800b53c <mem_set>
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 800b74a:	687b      	ldr	r3, [r7, #4]
 800b74c:	f04f 0255 	mov.w	r2, #85	; 0x55
 800b750:	f883 2232 	strb.w	r2, [r3, #562]	; 0x232
 800b754:	687b      	ldr	r3, [r7, #4]
 800b756:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 800b75a:	f883 2233 	strb.w	r2, [r3, #563]	; 0x233
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 800b75e:	687b      	ldr	r3, [r7, #4]
 800b760:	f04f 0252 	mov.w	r2, #82	; 0x52
 800b764:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
 800b768:	687b      	ldr	r3, [r7, #4]
 800b76a:	f04f 0252 	mov.w	r2, #82	; 0x52
 800b76e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800b772:	687b      	ldr	r3, [r7, #4]
 800b774:	f04f 0261 	mov.w	r2, #97	; 0x61
 800b778:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
 800b77c:	687b      	ldr	r3, [r7, #4]
 800b77e:	f04f 0241 	mov.w	r2, #65	; 0x41
 800b782:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 800b786:	687b      	ldr	r3, [r7, #4]
 800b788:	f04f 0272 	mov.w	r2, #114	; 0x72
 800b78c:	f883 2218 	strb.w	r2, [r3, #536]	; 0x218
 800b790:	687b      	ldr	r3, [r7, #4]
 800b792:	f04f 0272 	mov.w	r2, #114	; 0x72
 800b796:	f883 2219 	strb.w	r2, [r3, #537]	; 0x219
 800b79a:	687b      	ldr	r3, [r7, #4]
 800b79c:	f04f 0241 	mov.w	r2, #65	; 0x41
 800b7a0:	f883 221a 	strb.w	r2, [r3, #538]	; 0x21a
 800b7a4:	687b      	ldr	r3, [r7, #4]
 800b7a6:	f04f 0261 	mov.w	r2, #97	; 0x61
 800b7aa:	f883 221b 	strb.w	r2, [r3, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 800b7ae:	687b      	ldr	r3, [r7, #4]
 800b7b0:	691b      	ldr	r3, [r3, #16]
 800b7b2:	b2da      	uxtb	r2, r3
 800b7b4:	687b      	ldr	r3, [r7, #4]
 800b7b6:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
 800b7ba:	687b      	ldr	r3, [r7, #4]
 800b7bc:	691b      	ldr	r3, [r3, #16]
 800b7be:	b29b      	uxth	r3, r3
 800b7c0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800b7c4:	b29b      	uxth	r3, r3
 800b7c6:	b2da      	uxtb	r2, r3
 800b7c8:	687b      	ldr	r3, [r7, #4]
 800b7ca:	f883 221d 	strb.w	r2, [r3, #541]	; 0x21d
 800b7ce:	687b      	ldr	r3, [r7, #4]
 800b7d0:	691b      	ldr	r3, [r3, #16]
 800b7d2:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800b7d6:	b2da      	uxtb	r2, r3
 800b7d8:	687b      	ldr	r3, [r7, #4]
 800b7da:	f883 221e 	strb.w	r2, [r3, #542]	; 0x21e
 800b7de:	687b      	ldr	r3, [r7, #4]
 800b7e0:	691b      	ldr	r3, [r3, #16]
 800b7e2:	ea4f 6313 	mov.w	r3, r3, lsr #24
 800b7e6:	b2da      	uxtb	r2, r3
 800b7e8:	687b      	ldr	r3, [r7, #4]
 800b7ea:	f883 221f 	strb.w	r2, [r3, #543]	; 0x21f
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 800b7ee:	687b      	ldr	r3, [r7, #4]
 800b7f0:	68db      	ldr	r3, [r3, #12]
 800b7f2:	b2da      	uxtb	r2, r3
 800b7f4:	687b      	ldr	r3, [r7, #4]
 800b7f6:	f883 2220 	strb.w	r2, [r3, #544]	; 0x220
 800b7fa:	687b      	ldr	r3, [r7, #4]
 800b7fc:	68db      	ldr	r3, [r3, #12]
 800b7fe:	b29b      	uxth	r3, r3
 800b800:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800b804:	b29b      	uxth	r3, r3
 800b806:	b2da      	uxtb	r2, r3
 800b808:	687b      	ldr	r3, [r7, #4]
 800b80a:	f883 2221 	strb.w	r2, [r3, #545]	; 0x221
 800b80e:	687b      	ldr	r3, [r7, #4]
 800b810:	68db      	ldr	r3, [r3, #12]
 800b812:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800b816:	b2da      	uxtb	r2, r3
 800b818:	687b      	ldr	r3, [r7, #4]
 800b81a:	f883 2222 	strb.w	r2, [r3, #546]	; 0x222
 800b81e:	687b      	ldr	r3, [r7, #4]
 800b820:	68db      	ldr	r3, [r3, #12]
 800b822:	ea4f 6313 	mov.w	r3, r3, lsr #24
 800b826:	b2da      	uxtb	r2, r3
 800b828:	687b      	ldr	r3, [r7, #4]
 800b82a:	f883 2223 	strb.w	r2, [r3, #547]	; 0x223
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
 800b82e:	687b      	ldr	r3, [r7, #4]
 800b830:	7859      	ldrb	r1, [r3, #1]
 800b832:	687b      	ldr	r3, [r7, #4]
 800b834:	f103 0234 	add.w	r2, r3, #52	; 0x34
 800b838:	687b      	ldr	r3, [r7, #4]
 800b83a:	695b      	ldr	r3, [r3, #20]
 800b83c:	4608      	mov	r0, r1
 800b83e:	4611      	mov	r1, r2
 800b840:	461a      	mov	r2, r3
 800b842:	f04f 0301 	mov.w	r3, #1
 800b846:	f7ff fd9d 	bl	800b384 <disk_write>
			fs->fsi_flag = 0;
 800b84a:	687b      	ldr	r3, [r7, #4]
 800b84c:	f04f 0200 	mov.w	r2, #0
 800b850:	715a      	strb	r2, [r3, #5]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 800b852:	687b      	ldr	r3, [r7, #4]
 800b854:	785b      	ldrb	r3, [r3, #1]
 800b856:	4618      	mov	r0, r3
 800b858:	f04f 0100 	mov.w	r1, #0
 800b85c:	f04f 0200 	mov.w	r2, #0
 800b860:	f7ff fdd2 	bl	800b408 <disk_ioctl>
 800b864:	4603      	mov	r3, r0
 800b866:	2b00      	cmp	r3, #0
 800b868:	d002      	beq.n	800b870 <sync+0x174>
			res = FR_DISK_ERR;
 800b86a:	f04f 0301 	mov.w	r3, #1
 800b86e:	73fb      	strb	r3, [r7, #15]
	}

	return res;
 800b870:	7bfb      	ldrb	r3, [r7, #15]
}
 800b872:	4618      	mov	r0, r3
 800b874:	f107 0710 	add.w	r7, r7, #16
 800b878:	46bd      	mov	sp, r7
 800b87a:	bd80      	pop	{r7, pc}

0800b87c <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 800b87c:	b480      	push	{r7}
 800b87e:	b083      	sub	sp, #12
 800b880:	af00      	add	r7, sp, #0
 800b882:	6078      	str	r0, [r7, #4]
 800b884:	6039      	str	r1, [r7, #0]
	clst -= 2;
 800b886:	683b      	ldr	r3, [r7, #0]
 800b888:	f1a3 0302 	sub.w	r3, r3, #2
 800b88c:	603b      	str	r3, [r7, #0]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 800b88e:	687b      	ldr	r3, [r7, #4]
 800b890:	69db      	ldr	r3, [r3, #28]
 800b892:	f1a3 0202 	sub.w	r2, r3, #2
 800b896:	683b      	ldr	r3, [r7, #0]
 800b898:	429a      	cmp	r2, r3
 800b89a:	d802      	bhi.n	800b8a2 <clust2sect+0x26>
 800b89c:	f04f 0300 	mov.w	r3, #0
 800b8a0:	e007      	b.n	800b8b2 <clust2sect+0x36>
	return clst * fs->csize + fs->database;
 800b8a2:	687b      	ldr	r3, [r7, #4]
 800b8a4:	789b      	ldrb	r3, [r3, #2]
 800b8a6:	683a      	ldr	r2, [r7, #0]
 800b8a8:	fb02 f203 	mul.w	r2, r2, r3
 800b8ac:	687b      	ldr	r3, [r7, #4]
 800b8ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b8b0:	18d3      	adds	r3, r2, r3
}
 800b8b2:	4618      	mov	r0, r3
 800b8b4:	f107 070c 	add.w	r7, r7, #12
 800b8b8:	46bd      	mov	sp, r7
 800b8ba:	bc80      	pop	{r7}
 800b8bc:	4770      	bx	lr
 800b8be:	bf00      	nop

0800b8c0 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
 800b8c0:	b580      	push	{r7, lr}
 800b8c2:	b086      	sub	sp, #24
 800b8c4:	af00      	add	r7, sp, #0
 800b8c6:	6078      	str	r0, [r7, #4]
 800b8c8:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
 800b8ca:	683b      	ldr	r3, [r7, #0]
 800b8cc:	2b01      	cmp	r3, #1
 800b8ce:	d904      	bls.n	800b8da <get_fat+0x1a>
 800b8d0:	687b      	ldr	r3, [r7, #4]
 800b8d2:	69da      	ldr	r2, [r3, #28]
 800b8d4:	683b      	ldr	r3, [r7, #0]
 800b8d6:	429a      	cmp	r2, r3
 800b8d8:	d802      	bhi.n	800b8e0 <get_fat+0x20>
		return 1;
 800b8da:	f04f 0301 	mov.w	r3, #1
 800b8de:	e0bc      	b.n	800ba5a <get_fat+0x19a>

	switch (fs->fs_type) {
 800b8e0:	687b      	ldr	r3, [r7, #4]
 800b8e2:	781b      	ldrb	r3, [r3, #0]
 800b8e4:	2b02      	cmp	r3, #2
 800b8e6:	d052      	beq.n	800b98e <get_fat+0xce>
 800b8e8:	2b03      	cmp	r3, #3
 800b8ea:	d078      	beq.n	800b9de <get_fat+0x11e>
 800b8ec:	2b01      	cmp	r3, #1
 800b8ee:	f040 80b2 	bne.w	800ba56 <get_fat+0x196>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
 800b8f2:	683b      	ldr	r3, [r7, #0]
 800b8f4:	617b      	str	r3, [r7, #20]
 800b8f6:	697b      	ldr	r3, [r7, #20]
 800b8f8:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800b8fc:	697a      	ldr	r2, [r7, #20]
 800b8fe:	18d3      	adds	r3, r2, r3
 800b900:	617b      	str	r3, [r7, #20]
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800b902:	687b      	ldr	r3, [r7, #4]
 800b904:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b906:	697b      	ldr	r3, [r7, #20]
 800b908:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800b90c:	18d3      	adds	r3, r2, r3
 800b90e:	6878      	ldr	r0, [r7, #4]
 800b910:	4619      	mov	r1, r3
 800b912:	f7ff fe89 	bl	800b628 <move_window>
 800b916:	4603      	mov	r3, r0
 800b918:	2b00      	cmp	r3, #0
 800b91a:	f040 8095 	bne.w	800ba48 <get_fat+0x188>
		wc = fs->win[bc % SS(fs)]; bc++;
 800b91e:	697b      	ldr	r3, [r7, #20]
 800b920:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800b924:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800b928:	687a      	ldr	r2, [r7, #4]
 800b92a:	18d3      	adds	r3, r2, r3
 800b92c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800b930:	613b      	str	r3, [r7, #16]
 800b932:	697b      	ldr	r3, [r7, #20]
 800b934:	f103 0301 	add.w	r3, r3, #1
 800b938:	617b      	str	r3, [r7, #20]
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800b93a:	687b      	ldr	r3, [r7, #4]
 800b93c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b93e:	697b      	ldr	r3, [r7, #20]
 800b940:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800b944:	18d3      	adds	r3, r2, r3
 800b946:	6878      	ldr	r0, [r7, #4]
 800b948:	4619      	mov	r1, r3
 800b94a:	f7ff fe6d 	bl	800b628 <move_window>
 800b94e:	4603      	mov	r3, r0
 800b950:	2b00      	cmp	r3, #0
 800b952:	d17b      	bne.n	800ba4c <get_fat+0x18c>
		wc |= fs->win[bc % SS(fs)] << 8;
 800b954:	697b      	ldr	r3, [r7, #20]
 800b956:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800b95a:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800b95e:	687a      	ldr	r2, [r7, #4]
 800b960:	18d3      	adds	r3, r2, r3
 800b962:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800b966:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800b96a:	693a      	ldr	r2, [r7, #16]
 800b96c:	4313      	orrs	r3, r2
 800b96e:	613b      	str	r3, [r7, #16]
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800b970:	683b      	ldr	r3, [r7, #0]
 800b972:	f003 0301 	and.w	r3, r3, #1
 800b976:	2b00      	cmp	r3, #0
 800b978:	d003      	beq.n	800b982 <get_fat+0xc2>
 800b97a:	693b      	ldr	r3, [r7, #16]
 800b97c:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800b980:	e004      	b.n	800b98c <get_fat+0xcc>
 800b982:	693b      	ldr	r3, [r7, #16]
 800b984:	ea4f 5303 	mov.w	r3, r3, lsl #20
 800b988:	ea4f 5313 	mov.w	r3, r3, lsr #20
 800b98c:	e065      	b.n	800ba5a <get_fat+0x19a>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 800b98e:	687b      	ldr	r3, [r7, #4]
 800b990:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b992:	683b      	ldr	r3, [r7, #0]
 800b994:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800b998:	18d3      	adds	r3, r2, r3
 800b99a:	6878      	ldr	r0, [r7, #4]
 800b99c:	4619      	mov	r1, r3
 800b99e:	f7ff fe43 	bl	800b628 <move_window>
 800b9a2:	4603      	mov	r3, r0
 800b9a4:	2b00      	cmp	r3, #0
 800b9a6:	d153      	bne.n	800ba50 <get_fat+0x190>
		p = &fs->win[clst * 2 % SS(fs)];
 800b9a8:	683b      	ldr	r3, [r7, #0]
 800b9aa:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800b9ae:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800b9b2:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800b9b6:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800b9ba:	687a      	ldr	r2, [r7, #4]
 800b9bc:	18d3      	adds	r3, r2, r3
 800b9be:	f103 0304 	add.w	r3, r3, #4
 800b9c2:	60fb      	str	r3, [r7, #12]
		return LD_WORD(p);
 800b9c4:	68fb      	ldr	r3, [r7, #12]
 800b9c6:	f103 0301 	add.w	r3, r3, #1
 800b9ca:	781b      	ldrb	r3, [r3, #0]
 800b9cc:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800b9d0:	b29a      	uxth	r2, r3
 800b9d2:	68fb      	ldr	r3, [r7, #12]
 800b9d4:	781b      	ldrb	r3, [r3, #0]
 800b9d6:	4313      	orrs	r3, r2
 800b9d8:	b29b      	uxth	r3, r3
 800b9da:	b29b      	uxth	r3, r3
 800b9dc:	e03d      	b.n	800ba5a <get_fat+0x19a>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 800b9de:	687b      	ldr	r3, [r7, #4]
 800b9e0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b9e2:	683b      	ldr	r3, [r7, #0]
 800b9e4:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 800b9e8:	18d3      	adds	r3, r2, r3
 800b9ea:	6878      	ldr	r0, [r7, #4]
 800b9ec:	4619      	mov	r1, r3
 800b9ee:	f7ff fe1b 	bl	800b628 <move_window>
 800b9f2:	4603      	mov	r3, r0
 800b9f4:	2b00      	cmp	r3, #0
 800b9f6:	d12d      	bne.n	800ba54 <get_fat+0x194>
		p = &fs->win[clst * 4 % SS(fs)];
 800b9f8:	683b      	ldr	r3, [r7, #0]
 800b9fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800b9fe:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800ba02:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800ba06:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800ba0a:	687a      	ldr	r2, [r7, #4]
 800ba0c:	18d3      	adds	r3, r2, r3
 800ba0e:	f103 0304 	add.w	r3, r3, #4
 800ba12:	60fb      	str	r3, [r7, #12]
		return LD_DWORD(p) & 0x0FFFFFFF;
 800ba14:	68fb      	ldr	r3, [r7, #12]
 800ba16:	f103 0303 	add.w	r3, r3, #3
 800ba1a:	781b      	ldrb	r3, [r3, #0]
 800ba1c:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800ba20:	68fb      	ldr	r3, [r7, #12]
 800ba22:	f103 0302 	add.w	r3, r3, #2
 800ba26:	781b      	ldrb	r3, [r3, #0]
 800ba28:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800ba2c:	431a      	orrs	r2, r3
 800ba2e:	68fb      	ldr	r3, [r7, #12]
 800ba30:	f103 0301 	add.w	r3, r3, #1
 800ba34:	781b      	ldrb	r3, [r3, #0]
 800ba36:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ba3a:	431a      	orrs	r2, r3
 800ba3c:	68fb      	ldr	r3, [r7, #12]
 800ba3e:	781b      	ldrb	r3, [r3, #0]
 800ba40:	4313      	orrs	r3, r2
 800ba42:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800ba46:	e008      	b.n	800ba5a <get_fat+0x19a>
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800ba48:	bf00      	nop
 800ba4a:	e004      	b.n	800ba56 <get_fat+0x196>
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800ba4c:	bf00      	nop
 800ba4e:	e002      	b.n	800ba56 <get_fat+0x196>
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 800ba50:	bf00      	nop
 800ba52:	e000      	b.n	800ba56 <get_fat+0x196>
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 800ba54:	bf00      	nop
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 800ba56:	f04f 33ff 	mov.w	r3, #4294967295
}
 800ba5a:	4618      	mov	r0, r3
 800ba5c:	f107 0718 	add.w	r7, r7, #24
 800ba60:	46bd      	mov	sp, r7
 800ba62:	bd80      	pop	{r7, pc}

0800ba64 <put_fat>:
FRESULT put_fat (
	FATFS *fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
 800ba64:	b580      	push	{r7, lr}
 800ba66:	b088      	sub	sp, #32
 800ba68:	af00      	add	r7, sp, #0
 800ba6a:	60f8      	str	r0, [r7, #12]
 800ba6c:	60b9      	str	r1, [r7, #8]
 800ba6e:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800ba70:	68bb      	ldr	r3, [r7, #8]
 800ba72:	2b01      	cmp	r3, #1
 800ba74:	d904      	bls.n	800ba80 <put_fat+0x1c>
 800ba76:	68fb      	ldr	r3, [r7, #12]
 800ba78:	69da      	ldr	r2, [r3, #28]
 800ba7a:	68bb      	ldr	r3, [r7, #8]
 800ba7c:	429a      	cmp	r2, r3
 800ba7e:	d803      	bhi.n	800ba88 <put_fat+0x24>
		res = FR_INT_ERR;
 800ba80:	f04f 0302 	mov.w	r3, #2
 800ba84:	77fb      	strb	r3, [r7, #31]
 800ba86:	e11a      	b.n	800bcbe <put_fat+0x25a>

	} else {
		switch (fs->fs_type) {
 800ba88:	68fb      	ldr	r3, [r7, #12]
 800ba8a:	781b      	ldrb	r3, [r3, #0]
 800ba8c:	2b02      	cmp	r3, #2
 800ba8e:	f000 8083 	beq.w	800bb98 <put_fat+0x134>
 800ba92:	2b03      	cmp	r3, #3
 800ba94:	f000 80ac 	beq.w	800bbf0 <put_fat+0x18c>
 800ba98:	2b01      	cmp	r3, #1
 800ba9a:	f040 8101 	bne.w	800bca0 <put_fat+0x23c>
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
 800ba9e:	68bb      	ldr	r3, [r7, #8]
 800baa0:	61bb      	str	r3, [r7, #24]
 800baa2:	69bb      	ldr	r3, [r7, #24]
 800baa4:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800baa8:	69ba      	ldr	r2, [r7, #24]
 800baaa:	18d3      	adds	r3, r2, r3
 800baac:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800baae:	68fb      	ldr	r3, [r7, #12]
 800bab0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bab2:	69bb      	ldr	r3, [r7, #24]
 800bab4:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800bab8:	18d3      	adds	r3, r2, r3
 800baba:	68f8      	ldr	r0, [r7, #12]
 800babc:	4619      	mov	r1, r3
 800babe:	f7ff fdb3 	bl	800b628 <move_window>
 800bac2:	4603      	mov	r3, r0
 800bac4:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800bac6:	7ffb      	ldrb	r3, [r7, #31]
 800bac8:	2b00      	cmp	r3, #0
 800baca:	f040 80ed 	bne.w	800bca8 <put_fat+0x244>
			p = &fs->win[bc % SS(fs)];
 800bace:	69bb      	ldr	r3, [r7, #24]
 800bad0:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800bad4:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800bad8:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800badc:	68fa      	ldr	r2, [r7, #12]
 800bade:	18d3      	adds	r3, r2, r3
 800bae0:	f103 0304 	add.w	r3, r3, #4
 800bae4:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 800bae6:	68bb      	ldr	r3, [r7, #8]
 800bae8:	f003 0301 	and.w	r3, r3, #1
 800baec:	2b00      	cmp	r3, #0
 800baee:	d00e      	beq.n	800bb0e <put_fat+0xaa>
 800baf0:	697b      	ldr	r3, [r7, #20]
 800baf2:	781b      	ldrb	r3, [r3, #0]
 800baf4:	b2db      	uxtb	r3, r3
 800baf6:	f003 030f 	and.w	r3, r3, #15
 800bafa:	b2da      	uxtb	r2, r3
 800bafc:	687b      	ldr	r3, [r7, #4]
 800bafe:	b2db      	uxtb	r3, r3
 800bb00:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800bb04:	b2db      	uxtb	r3, r3
 800bb06:	4313      	orrs	r3, r2
 800bb08:	b2db      	uxtb	r3, r3
 800bb0a:	b2db      	uxtb	r3, r3
 800bb0c:	e001      	b.n	800bb12 <put_fat+0xae>
 800bb0e:	687b      	ldr	r3, [r7, #4]
 800bb10:	b2db      	uxtb	r3, r3
 800bb12:	697a      	ldr	r2, [r7, #20]
 800bb14:	7013      	strb	r3, [r2, #0]
			bc++;
 800bb16:	69bb      	ldr	r3, [r7, #24]
 800bb18:	f103 0301 	add.w	r3, r3, #1
 800bb1c:	61bb      	str	r3, [r7, #24]
			fs->wflag = 1;
 800bb1e:	68fb      	ldr	r3, [r7, #12]
 800bb20:	f04f 0201 	mov.w	r2, #1
 800bb24:	711a      	strb	r2, [r3, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800bb26:	68fb      	ldr	r3, [r7, #12]
 800bb28:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bb2a:	69bb      	ldr	r3, [r7, #24]
 800bb2c:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800bb30:	18d3      	adds	r3, r2, r3
 800bb32:	68f8      	ldr	r0, [r7, #12]
 800bb34:	4619      	mov	r1, r3
 800bb36:	f7ff fd77 	bl	800b628 <move_window>
 800bb3a:	4603      	mov	r3, r0
 800bb3c:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800bb3e:	7ffb      	ldrb	r3, [r7, #31]
 800bb40:	2b00      	cmp	r3, #0
 800bb42:	f040 80b3 	bne.w	800bcac <put_fat+0x248>
			p = &fs->win[bc % SS(fs)];
 800bb46:	69bb      	ldr	r3, [r7, #24]
 800bb48:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800bb4c:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800bb50:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800bb54:	68fa      	ldr	r2, [r7, #12]
 800bb56:	18d3      	adds	r3, r2, r3
 800bb58:	f103 0304 	add.w	r3, r3, #4
 800bb5c:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 800bb5e:	68bb      	ldr	r3, [r7, #8]
 800bb60:	f003 0301 	and.w	r3, r3, #1
 800bb64:	2b00      	cmp	r3, #0
 800bb66:	d004      	beq.n	800bb72 <put_fat+0x10e>
 800bb68:	687b      	ldr	r3, [r7, #4]
 800bb6a:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800bb6e:	b2db      	uxtb	r3, r3
 800bb70:	e00f      	b.n	800bb92 <put_fat+0x12e>
 800bb72:	697b      	ldr	r3, [r7, #20]
 800bb74:	781b      	ldrb	r3, [r3, #0]
 800bb76:	b2db      	uxtb	r3, r3
 800bb78:	f023 030f 	bic.w	r3, r3, #15
 800bb7c:	b2da      	uxtb	r2, r3
 800bb7e:	687b      	ldr	r3, [r7, #4]
 800bb80:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800bb84:	b2db      	uxtb	r3, r3
 800bb86:	f003 030f 	and.w	r3, r3, #15
 800bb8a:	b2db      	uxtb	r3, r3
 800bb8c:	4313      	orrs	r3, r2
 800bb8e:	b2db      	uxtb	r3, r3
 800bb90:	b2db      	uxtb	r3, r3
 800bb92:	697a      	ldr	r2, [r7, #20]
 800bb94:	7013      	strb	r3, [r2, #0]
			break;
 800bb96:	e08e      	b.n	800bcb6 <put_fat+0x252>

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800bb98:	68fb      	ldr	r3, [r7, #12]
 800bb9a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bb9c:	68bb      	ldr	r3, [r7, #8]
 800bb9e:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800bba2:	18d3      	adds	r3, r2, r3
 800bba4:	68f8      	ldr	r0, [r7, #12]
 800bba6:	4619      	mov	r1, r3
 800bba8:	f7ff fd3e 	bl	800b628 <move_window>
 800bbac:	4603      	mov	r3, r0
 800bbae:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800bbb0:	7ffb      	ldrb	r3, [r7, #31]
 800bbb2:	2b00      	cmp	r3, #0
 800bbb4:	d17c      	bne.n	800bcb0 <put_fat+0x24c>
			p = &fs->win[clst * 2 % SS(fs)];
 800bbb6:	68bb      	ldr	r3, [r7, #8]
 800bbb8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800bbbc:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800bbc0:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800bbc4:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800bbc8:	68fa      	ldr	r2, [r7, #12]
 800bbca:	18d3      	adds	r3, r2, r3
 800bbcc:	f103 0304 	add.w	r3, r3, #4
 800bbd0:	617b      	str	r3, [r7, #20]
			ST_WORD(p, (WORD)val);
 800bbd2:	687b      	ldr	r3, [r7, #4]
 800bbd4:	b2da      	uxtb	r2, r3
 800bbd6:	697b      	ldr	r3, [r7, #20]
 800bbd8:	701a      	strb	r2, [r3, #0]
 800bbda:	697b      	ldr	r3, [r7, #20]
 800bbdc:	f103 0301 	add.w	r3, r3, #1
 800bbe0:	687a      	ldr	r2, [r7, #4]
 800bbe2:	b292      	uxth	r2, r2
 800bbe4:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800bbe8:	b292      	uxth	r2, r2
 800bbea:	b2d2      	uxtb	r2, r2
 800bbec:	701a      	strb	r2, [r3, #0]
			break;
 800bbee:	e062      	b.n	800bcb6 <put_fat+0x252>

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 800bbf0:	68fb      	ldr	r3, [r7, #12]
 800bbf2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bbf4:	68bb      	ldr	r3, [r7, #8]
 800bbf6:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 800bbfa:	18d3      	adds	r3, r2, r3
 800bbfc:	68f8      	ldr	r0, [r7, #12]
 800bbfe:	4619      	mov	r1, r3
 800bc00:	f7ff fd12 	bl	800b628 <move_window>
 800bc04:	4603      	mov	r3, r0
 800bc06:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800bc08:	7ffb      	ldrb	r3, [r7, #31]
 800bc0a:	2b00      	cmp	r3, #0
 800bc0c:	d152      	bne.n	800bcb4 <put_fat+0x250>
			p = &fs->win[clst * 4 % SS(fs)];
 800bc0e:	68bb      	ldr	r3, [r7, #8]
 800bc10:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800bc14:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800bc18:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800bc1c:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800bc20:	68fa      	ldr	r2, [r7, #12]
 800bc22:	18d3      	adds	r3, r2, r3
 800bc24:	f103 0304 	add.w	r3, r3, #4
 800bc28:	617b      	str	r3, [r7, #20]
			val |= LD_DWORD(p) & 0xF0000000;
 800bc2a:	697b      	ldr	r3, [r7, #20]
 800bc2c:	f103 0303 	add.w	r3, r3, #3
 800bc30:	781b      	ldrb	r3, [r3, #0]
 800bc32:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800bc36:	697b      	ldr	r3, [r7, #20]
 800bc38:	f103 0302 	add.w	r3, r3, #2
 800bc3c:	781b      	ldrb	r3, [r3, #0]
 800bc3e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800bc42:	431a      	orrs	r2, r3
 800bc44:	697b      	ldr	r3, [r7, #20]
 800bc46:	f103 0301 	add.w	r3, r3, #1
 800bc4a:	781b      	ldrb	r3, [r3, #0]
 800bc4c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800bc50:	431a      	orrs	r2, r3
 800bc52:	697b      	ldr	r3, [r7, #20]
 800bc54:	781b      	ldrb	r3, [r3, #0]
 800bc56:	4313      	orrs	r3, r2
 800bc58:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 800bc5c:	687a      	ldr	r2, [r7, #4]
 800bc5e:	4313      	orrs	r3, r2
 800bc60:	607b      	str	r3, [r7, #4]
			ST_DWORD(p, val);
 800bc62:	687b      	ldr	r3, [r7, #4]
 800bc64:	b2da      	uxtb	r2, r3
 800bc66:	697b      	ldr	r3, [r7, #20]
 800bc68:	701a      	strb	r2, [r3, #0]
 800bc6a:	697b      	ldr	r3, [r7, #20]
 800bc6c:	f103 0301 	add.w	r3, r3, #1
 800bc70:	687a      	ldr	r2, [r7, #4]
 800bc72:	b292      	uxth	r2, r2
 800bc74:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800bc78:	b292      	uxth	r2, r2
 800bc7a:	b2d2      	uxtb	r2, r2
 800bc7c:	701a      	strb	r2, [r3, #0]
 800bc7e:	697b      	ldr	r3, [r7, #20]
 800bc80:	f103 0302 	add.w	r3, r3, #2
 800bc84:	687a      	ldr	r2, [r7, #4]
 800bc86:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800bc8a:	b2d2      	uxtb	r2, r2
 800bc8c:	701a      	strb	r2, [r3, #0]
 800bc8e:	697b      	ldr	r3, [r7, #20]
 800bc90:	f103 0303 	add.w	r3, r3, #3
 800bc94:	687a      	ldr	r2, [r7, #4]
 800bc96:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800bc9a:	b2d2      	uxtb	r2, r2
 800bc9c:	701a      	strb	r2, [r3, #0]
			break;
 800bc9e:	e00a      	b.n	800bcb6 <put_fat+0x252>

		default :
			res = FR_INT_ERR;
 800bca0:	f04f 0302 	mov.w	r3, #2
 800bca4:	77fb      	strb	r3, [r7, #31]
 800bca6:	e006      	b.n	800bcb6 <put_fat+0x252>
	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
 800bca8:	bf00      	nop
 800bcaa:	e004      	b.n	800bcb6 <put_fat+0x252>
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
 800bcac:	bf00      	nop
 800bcae:	e002      	b.n	800bcb6 <put_fat+0x252>
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
 800bcb0:	bf00      	nop
 800bcb2:	e000      	b.n	800bcb6 <put_fat+0x252>
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
			if (res != FR_OK) break;
 800bcb4:	bf00      	nop
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
 800bcb6:	68fb      	ldr	r3, [r7, #12]
 800bcb8:	f04f 0201 	mov.w	r2, #1
 800bcbc:	711a      	strb	r2, [r3, #4]
	}

	return res;
 800bcbe:	7ffb      	ldrb	r3, [r7, #31]
}
 800bcc0:	4618      	mov	r0, r3
 800bcc2:	f107 0720 	add.w	r7, r7, #32
 800bcc6:	46bd      	mov	sp, r7
 800bcc8:	bd80      	pop	{r7, pc}
 800bcca:	bf00      	nop

0800bccc <remove_chain>:
static
FRESULT remove_chain (
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 800bccc:	b580      	push	{r7, lr}
 800bcce:	b088      	sub	sp, #32
 800bcd0:	af00      	add	r7, sp, #0
 800bcd2:	6078      	str	r0, [r7, #4]
 800bcd4:	6039      	str	r1, [r7, #0]
	FRESULT res;
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
 800bcd6:	683b      	ldr	r3, [r7, #0]
 800bcd8:	61bb      	str	r3, [r7, #24]
 800bcda:	683b      	ldr	r3, [r7, #0]
 800bcdc:	617b      	str	r3, [r7, #20]
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 800bcde:	683b      	ldr	r3, [r7, #0]
 800bce0:	2b01      	cmp	r3, #1
 800bce2:	d904      	bls.n	800bcee <remove_chain+0x22>
 800bce4:	687b      	ldr	r3, [r7, #4]
 800bce6:	69da      	ldr	r2, [r3, #28]
 800bce8:	683b      	ldr	r3, [r7, #0]
 800bcea:	429a      	cmp	r2, r3
 800bcec:	d803      	bhi.n	800bcf6 <remove_chain+0x2a>
		res = FR_INT_ERR;
 800bcee:	f04f 0302 	mov.w	r3, #2
 800bcf2:	77fb      	strb	r3, [r7, #31]
 800bcf4:	e067      	b.n	800bdc6 <remove_chain+0xfa>

	} else {
		res = FR_OK;
 800bcf6:	f04f 0300 	mov.w	r3, #0
 800bcfa:	77fb      	strb	r3, [r7, #31]
		while (clst < fs->n_fatent) {			/* Not a last link? */
 800bcfc:	e05a      	b.n	800bdb4 <remove_chain+0xe8>
			nxt = get_fat(fs, clst);			/* Get cluster status */
 800bcfe:	6878      	ldr	r0, [r7, #4]
 800bd00:	6839      	ldr	r1, [r7, #0]
 800bd02:	f7ff fddd 	bl	800b8c0 <get_fat>
 800bd06:	6138      	str	r0, [r7, #16]
			if (nxt == 0) break;				/* Empty cluster? */
 800bd08:	693b      	ldr	r3, [r7, #16]
 800bd0a:	2b00      	cmp	r3, #0
 800bd0c:	d058      	beq.n	800bdc0 <remove_chain+0xf4>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 800bd0e:	693b      	ldr	r3, [r7, #16]
 800bd10:	2b01      	cmp	r3, #1
 800bd12:	d103      	bne.n	800bd1c <remove_chain+0x50>
 800bd14:	f04f 0302 	mov.w	r3, #2
 800bd18:	77fb      	strb	r3, [r7, #31]
 800bd1a:	e054      	b.n	800bdc6 <remove_chain+0xfa>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 800bd1c:	693b      	ldr	r3, [r7, #16]
 800bd1e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800bd22:	d103      	bne.n	800bd2c <remove_chain+0x60>
 800bd24:	f04f 0301 	mov.w	r3, #1
 800bd28:	77fb      	strb	r3, [r7, #31]
 800bd2a:	e04c      	b.n	800bdc6 <remove_chain+0xfa>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 800bd2c:	6878      	ldr	r0, [r7, #4]
 800bd2e:	6839      	ldr	r1, [r7, #0]
 800bd30:	f04f 0200 	mov.w	r2, #0
 800bd34:	f7ff fe96 	bl	800ba64 <put_fat>
 800bd38:	4603      	mov	r3, r0
 800bd3a:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 800bd3c:	7ffb      	ldrb	r3, [r7, #31]
 800bd3e:	2b00      	cmp	r3, #0
 800bd40:	d140      	bne.n	800bdc4 <remove_chain+0xf8>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
 800bd42:	687b      	ldr	r3, [r7, #4]
 800bd44:	691b      	ldr	r3, [r3, #16]
 800bd46:	f1b3 3fff 	cmp.w	r3, #4294967295
 800bd4a:	d009      	beq.n	800bd60 <remove_chain+0x94>
				fs->free_clust++;
 800bd4c:	687b      	ldr	r3, [r7, #4]
 800bd4e:	691b      	ldr	r3, [r3, #16]
 800bd50:	f103 0201 	add.w	r2, r3, #1
 800bd54:	687b      	ldr	r3, [r7, #4]
 800bd56:	611a      	str	r2, [r3, #16]
				fs->fsi_flag = 1;
 800bd58:	687b      	ldr	r3, [r7, #4]
 800bd5a:	f04f 0201 	mov.w	r2, #1
 800bd5e:	715a      	strb	r2, [r3, #5]
			}
#if _USE_ERASE
			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
 800bd60:	697b      	ldr	r3, [r7, #20]
 800bd62:	f103 0201 	add.w	r2, r3, #1
 800bd66:	693b      	ldr	r3, [r7, #16]
 800bd68:	429a      	cmp	r2, r3
 800bd6a:	d102      	bne.n	800bd72 <remove_chain+0xa6>
				ecl = nxt;
 800bd6c:	693b      	ldr	r3, [r7, #16]
 800bd6e:	617b      	str	r3, [r7, #20]
 800bd70:	e01e      	b.n	800bdb0 <remove_chain+0xe4>
			} else {				/* End of contiguous clusters */ 
				resion[0] = clust2sect(fs, scl);					/* Start sector */
 800bd72:	6878      	ldr	r0, [r7, #4]
 800bd74:	69b9      	ldr	r1, [r7, #24]
 800bd76:	f7ff fd81 	bl	800b87c <clust2sect>
 800bd7a:	4603      	mov	r3, r0
 800bd7c:	60bb      	str	r3, [r7, #8]
				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
 800bd7e:	6878      	ldr	r0, [r7, #4]
 800bd80:	6979      	ldr	r1, [r7, #20]
 800bd82:	f7ff fd7b 	bl	800b87c <clust2sect>
 800bd86:	4602      	mov	r2, r0
 800bd88:	687b      	ldr	r3, [r7, #4]
 800bd8a:	789b      	ldrb	r3, [r3, #2]
 800bd8c:	18d3      	adds	r3, r2, r3
 800bd8e:	f103 33ff 	add.w	r3, r3, #4294967295
 800bd92:	60fb      	str	r3, [r7, #12]
				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
 800bd94:	687b      	ldr	r3, [r7, #4]
 800bd96:	785a      	ldrb	r2, [r3, #1]
 800bd98:	f107 0308 	add.w	r3, r7, #8
 800bd9c:	4610      	mov	r0, r2
 800bd9e:	f04f 0104 	mov.w	r1, #4
 800bda2:	461a      	mov	r2, r3
 800bda4:	f7ff fb30 	bl	800b408 <disk_ioctl>
				scl = ecl = nxt;
 800bda8:	693b      	ldr	r3, [r7, #16]
 800bdaa:	617b      	str	r3, [r7, #20]
 800bdac:	697b      	ldr	r3, [r7, #20]
 800bdae:	61bb      	str	r3, [r7, #24]
			}
#endif
			clst = nxt;	/* Next cluster */
 800bdb0:	693b      	ldr	r3, [r7, #16]
 800bdb2:	603b      	str	r3, [r7, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
 800bdb4:	687b      	ldr	r3, [r7, #4]
 800bdb6:	69da      	ldr	r2, [r3, #28]
 800bdb8:	683b      	ldr	r3, [r7, #0]
 800bdba:	429a      	cmp	r2, r3
 800bdbc:	d89f      	bhi.n	800bcfe <remove_chain+0x32>
 800bdbe:	e002      	b.n	800bdc6 <remove_chain+0xfa>
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
 800bdc0:	bf00      	nop
 800bdc2:	e000      	b.n	800bdc6 <remove_chain+0xfa>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
 800bdc4:	bf00      	nop
#endif
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
 800bdc6:	7ffb      	ldrb	r3, [r7, #31]
}
 800bdc8:	4618      	mov	r0, r3
 800bdca:	f107 0720 	add.w	r7, r7, #32
 800bdce:	46bd      	mov	sp, r7
 800bdd0:	bd80      	pop	{r7, pc}
 800bdd2:	bf00      	nop

0800bdd4 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
 800bdd4:	b580      	push	{r7, lr}
 800bdd6:	b086      	sub	sp, #24
 800bdd8:	af00      	add	r7, sp, #0
 800bdda:	6078      	str	r0, [r7, #4]
 800bddc:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
 800bdde:	683b      	ldr	r3, [r7, #0]
 800bde0:	2b00      	cmp	r3, #0
 800bde2:	d10e      	bne.n	800be02 <create_chain+0x2e>
		scl = fs->last_clust;			/* Get suggested start point */
 800bde4:	687b      	ldr	r3, [r7, #4]
 800bde6:	68db      	ldr	r3, [r3, #12]
 800bde8:	613b      	str	r3, [r7, #16]
		if (!scl || scl >= fs->n_fatent) scl = 1;
 800bdea:	693b      	ldr	r3, [r7, #16]
 800bdec:	2b00      	cmp	r3, #0
 800bdee:	d004      	beq.n	800bdfa <create_chain+0x26>
 800bdf0:	687b      	ldr	r3, [r7, #4]
 800bdf2:	69da      	ldr	r2, [r3, #28]
 800bdf4:	693b      	ldr	r3, [r7, #16]
 800bdf6:	429a      	cmp	r2, r3
 800bdf8:	d817      	bhi.n	800be2a <create_chain+0x56>
 800bdfa:	f04f 0301 	mov.w	r3, #1
 800bdfe:	613b      	str	r3, [r7, #16]
 800be00:	e013      	b.n	800be2a <create_chain+0x56>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
 800be02:	6878      	ldr	r0, [r7, #4]
 800be04:	6839      	ldr	r1, [r7, #0]
 800be06:	f7ff fd5b 	bl	800b8c0 <get_fat>
 800be0a:	60b8      	str	r0, [r7, #8]
		if (cs < 2) return 1;			/* It is an invalid cluster */
 800be0c:	68bb      	ldr	r3, [r7, #8]
 800be0e:	2b01      	cmp	r3, #1
 800be10:	d802      	bhi.n	800be18 <create_chain+0x44>
 800be12:	f04f 0301 	mov.w	r3, #1
 800be16:	e06d      	b.n	800bef4 <create_chain+0x120>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800be18:	687b      	ldr	r3, [r7, #4]
 800be1a:	69da      	ldr	r2, [r3, #28]
 800be1c:	68bb      	ldr	r3, [r7, #8]
 800be1e:	429a      	cmp	r2, r3
 800be20:	d901      	bls.n	800be26 <create_chain+0x52>
 800be22:	68bb      	ldr	r3, [r7, #8]
 800be24:	e066      	b.n	800bef4 <create_chain+0x120>
		scl = clst;
 800be26:	683b      	ldr	r3, [r7, #0]
 800be28:	613b      	str	r3, [r7, #16]
	}

	ncl = scl;				/* Start cluster */
 800be2a:	693b      	ldr	r3, [r7, #16]
 800be2c:	617b      	str	r3, [r7, #20]
 800be2e:	e000      	b.n	800be32 <create_chain+0x5e>
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}
 800be30:	bf00      	nop
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 800be32:	697b      	ldr	r3, [r7, #20]
 800be34:	f103 0301 	add.w	r3, r3, #1
 800be38:	617b      	str	r3, [r7, #20]
		if (ncl >= fs->n_fatent) {		/* Wrap around */
 800be3a:	687b      	ldr	r3, [r7, #4]
 800be3c:	69da      	ldr	r2, [r3, #28]
 800be3e:	697b      	ldr	r3, [r7, #20]
 800be40:	429a      	cmp	r2, r3
 800be42:	d809      	bhi.n	800be58 <create_chain+0x84>
			ncl = 2;
 800be44:	f04f 0302 	mov.w	r3, #2
 800be48:	617b      	str	r3, [r7, #20]
			if (ncl > scl) return 0;	/* No free cluster */
 800be4a:	697a      	ldr	r2, [r7, #20]
 800be4c:	693b      	ldr	r3, [r7, #16]
 800be4e:	429a      	cmp	r2, r3
 800be50:	d902      	bls.n	800be58 <create_chain+0x84>
 800be52:	f04f 0300 	mov.w	r3, #0
 800be56:	e04d      	b.n	800bef4 <create_chain+0x120>
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 800be58:	6878      	ldr	r0, [r7, #4]
 800be5a:	6979      	ldr	r1, [r7, #20]
 800be5c:	f7ff fd30 	bl	800b8c0 <get_fat>
 800be60:	60b8      	str	r0, [r7, #8]
		if (cs == 0) break;				/* Found a free cluster */
 800be62:	68bb      	ldr	r3, [r7, #8]
 800be64:	2b00      	cmp	r3, #0
 800be66:	d00f      	beq.n	800be88 <create_chain+0xb4>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 800be68:	68bb      	ldr	r3, [r7, #8]
 800be6a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800be6e:	d002      	beq.n	800be76 <create_chain+0xa2>
 800be70:	68bb      	ldr	r3, [r7, #8]
 800be72:	2b01      	cmp	r3, #1
 800be74:	d101      	bne.n	800be7a <create_chain+0xa6>
			return cs;
 800be76:	68bb      	ldr	r3, [r7, #8]
 800be78:	e03c      	b.n	800bef4 <create_chain+0x120>
		if (ncl == scl) return 0;		/* No free cluster */
 800be7a:	697a      	ldr	r2, [r7, #20]
 800be7c:	693b      	ldr	r3, [r7, #16]
 800be7e:	429a      	cmp	r2, r3
 800be80:	d1d6      	bne.n	800be30 <create_chain+0x5c>
 800be82:	f04f 0300 	mov.w	r3, #0
 800be86:	e035      	b.n	800bef4 <create_chain+0x120>
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
 800be88:	bf00      	nop
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 800be8a:	6878      	ldr	r0, [r7, #4]
 800be8c:	6979      	ldr	r1, [r7, #20]
 800be8e:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 800be92:	f7ff fde7 	bl	800ba64 <put_fat>
 800be96:	4603      	mov	r3, r0
 800be98:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK && clst != 0) {
 800be9a:	7bfb      	ldrb	r3, [r7, #15]
 800be9c:	2b00      	cmp	r3, #0
 800be9e:	d109      	bne.n	800beb4 <create_chain+0xe0>
 800bea0:	683b      	ldr	r3, [r7, #0]
 800bea2:	2b00      	cmp	r3, #0
 800bea4:	d006      	beq.n	800beb4 <create_chain+0xe0>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 800bea6:	6878      	ldr	r0, [r7, #4]
 800bea8:	6839      	ldr	r1, [r7, #0]
 800beaa:	697a      	ldr	r2, [r7, #20]
 800beac:	f7ff fdda 	bl	800ba64 <put_fat>
 800beb0:	4603      	mov	r3, r0
 800beb2:	73fb      	strb	r3, [r7, #15]
	}
	if (res == FR_OK) {
 800beb4:	7bfb      	ldrb	r3, [r7, #15]
 800beb6:	2b00      	cmp	r3, #0
 800beb8:	d112      	bne.n	800bee0 <create_chain+0x10c>
		fs->last_clust = ncl;			/* Update FSINFO */
 800beba:	687b      	ldr	r3, [r7, #4]
 800bebc:	697a      	ldr	r2, [r7, #20]
 800bebe:	60da      	str	r2, [r3, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
 800bec0:	687b      	ldr	r3, [r7, #4]
 800bec2:	691b      	ldr	r3, [r3, #16]
 800bec4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800bec8:	d013      	beq.n	800bef2 <create_chain+0x11e>
			fs->free_clust--;
 800beca:	687b      	ldr	r3, [r7, #4]
 800becc:	691b      	ldr	r3, [r3, #16]
 800bece:	f103 32ff 	add.w	r2, r3, #4294967295
 800bed2:	687b      	ldr	r3, [r7, #4]
 800bed4:	611a      	str	r2, [r3, #16]
			fs->fsi_flag = 1;
 800bed6:	687b      	ldr	r3, [r7, #4]
 800bed8:	f04f 0201 	mov.w	r2, #1
 800bedc:	715a      	strb	r2, [r3, #5]
 800bede:	e008      	b.n	800bef2 <create_chain+0x11e>
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 800bee0:	7bfb      	ldrb	r3, [r7, #15]
 800bee2:	2b01      	cmp	r3, #1
 800bee4:	d102      	bne.n	800beec <create_chain+0x118>
 800bee6:	f04f 33ff 	mov.w	r3, #4294967295
 800beea:	e001      	b.n	800bef0 <create_chain+0x11c>
 800beec:	f04f 0301 	mov.w	r3, #1
 800bef0:	617b      	str	r3, [r7, #20]
	}

	return ncl;		/* Return new cluster number or error code */
 800bef2:	697b      	ldr	r3, [r7, #20]
}
 800bef4:	4618      	mov	r0, r3
 800bef6:	f107 0718 	add.w	r7, r7, #24
 800befa:	46bd      	mov	sp, r7
 800befc:	bd80      	pop	{r7, pc}
 800befe:	bf00      	nop

0800bf00 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
 800bf00:	b580      	push	{r7, lr}
 800bf02:	b084      	sub	sp, #16
 800bf04:	af00      	add	r7, sp, #0
 800bf06:	6078      	str	r0, [r7, #4]
 800bf08:	460b      	mov	r3, r1
 800bf0a:	807b      	strh	r3, [r7, #2]
	DWORD clst;
	WORD ic;


	dj->index = idx;
 800bf0c:	687b      	ldr	r3, [r7, #4]
 800bf0e:	887a      	ldrh	r2, [r7, #2]
 800bf10:	80da      	strh	r2, [r3, #6]
	clst = dj->sclust;
 800bf12:	687b      	ldr	r3, [r7, #4]
 800bf14:	689b      	ldr	r3, [r3, #8]
 800bf16:	60fb      	str	r3, [r7, #12]
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 800bf18:	68fb      	ldr	r3, [r7, #12]
 800bf1a:	2b01      	cmp	r3, #1
 800bf1c:	d005      	beq.n	800bf2a <dir_sdi+0x2a>
 800bf1e:	687b      	ldr	r3, [r7, #4]
 800bf20:	681b      	ldr	r3, [r3, #0]
 800bf22:	69da      	ldr	r2, [r3, #28]
 800bf24:	68fb      	ldr	r3, [r7, #12]
 800bf26:	429a      	cmp	r2, r3
 800bf28:	d802      	bhi.n	800bf30 <dir_sdi+0x30>
		return FR_INT_ERR;
 800bf2a:	f04f 0302 	mov.w	r3, #2
 800bf2e:	e06f      	b.n	800c010 <dir_sdi+0x110>
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 800bf30:	68fb      	ldr	r3, [r7, #12]
 800bf32:	2b00      	cmp	r3, #0
 800bf34:	d108      	bne.n	800bf48 <dir_sdi+0x48>
 800bf36:	687b      	ldr	r3, [r7, #4]
 800bf38:	681b      	ldr	r3, [r3, #0]
 800bf3a:	781b      	ldrb	r3, [r3, #0]
 800bf3c:	2b03      	cmp	r3, #3
 800bf3e:	d103      	bne.n	800bf48 <dir_sdi+0x48>
		clst = dj->fs->dirbase;
 800bf40:	687b      	ldr	r3, [r7, #4]
 800bf42:	681b      	ldr	r3, [r3, #0]
 800bf44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800bf46:	60fb      	str	r3, [r7, #12]

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
 800bf48:	68fb      	ldr	r3, [r7, #12]
 800bf4a:	2b00      	cmp	r3, #0
 800bf4c:	d116      	bne.n	800bf7c <dir_sdi+0x7c>
		dj->clust = clst;
 800bf4e:	687b      	ldr	r3, [r7, #4]
 800bf50:	68fa      	ldr	r2, [r7, #12]
 800bf52:	60da      	str	r2, [r3, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 800bf54:	687b      	ldr	r3, [r7, #4]
 800bf56:	681b      	ldr	r3, [r3, #0]
 800bf58:	891b      	ldrh	r3, [r3, #8]
 800bf5a:	887a      	ldrh	r2, [r7, #2]
 800bf5c:	429a      	cmp	r2, r3
 800bf5e:	d302      	bcc.n	800bf66 <dir_sdi+0x66>
			return FR_INT_ERR;
 800bf60:	f04f 0302 	mov.w	r3, #2
 800bf64:	e054      	b.n	800c010 <dir_sdi+0x110>
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 800bf66:	687b      	ldr	r3, [r7, #4]
 800bf68:	681b      	ldr	r3, [r3, #0]
 800bf6a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800bf6c:	887b      	ldrh	r3, [r7, #2]
 800bf6e:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800bf72:	b29b      	uxth	r3, r3
 800bf74:	18d2      	adds	r2, r2, r3
 800bf76:	687b      	ldr	r3, [r7, #4]
 800bf78:	611a      	str	r2, [r3, #16]
 800bf7a:	e039      	b.n	800bff0 <dir_sdi+0xf0>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
 800bf7c:	687b      	ldr	r3, [r7, #4]
 800bf7e:	681b      	ldr	r3, [r3, #0]
 800bf80:	789b      	ldrb	r3, [r3, #2]
 800bf82:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800bf86:	817b      	strh	r3, [r7, #10]
		while (idx >= ic) {	/* Follow cluster chain */
 800bf88:	e01d      	b.n	800bfc6 <dir_sdi+0xc6>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 800bf8a:	687b      	ldr	r3, [r7, #4]
 800bf8c:	681b      	ldr	r3, [r3, #0]
 800bf8e:	4618      	mov	r0, r3
 800bf90:	68f9      	ldr	r1, [r7, #12]
 800bf92:	f7ff fc95 	bl	800b8c0 <get_fat>
 800bf96:	60f8      	str	r0, [r7, #12]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800bf98:	68fb      	ldr	r3, [r7, #12]
 800bf9a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800bf9e:	d102      	bne.n	800bfa6 <dir_sdi+0xa6>
 800bfa0:	f04f 0301 	mov.w	r3, #1
 800bfa4:	e034      	b.n	800c010 <dir_sdi+0x110>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 800bfa6:	68fb      	ldr	r3, [r7, #12]
 800bfa8:	2b01      	cmp	r3, #1
 800bfaa:	d905      	bls.n	800bfb8 <dir_sdi+0xb8>
 800bfac:	687b      	ldr	r3, [r7, #4]
 800bfae:	681b      	ldr	r3, [r3, #0]
 800bfb0:	69da      	ldr	r2, [r3, #28]
 800bfb2:	68fb      	ldr	r3, [r7, #12]
 800bfb4:	429a      	cmp	r2, r3
 800bfb6:	d802      	bhi.n	800bfbe <dir_sdi+0xbe>
				return FR_INT_ERR;
 800bfb8:	f04f 0302 	mov.w	r3, #2
 800bfbc:	e028      	b.n	800c010 <dir_sdi+0x110>
			idx -= ic;
 800bfbe:	887a      	ldrh	r2, [r7, #2]
 800bfc0:	897b      	ldrh	r3, [r7, #10]
 800bfc2:	1ad3      	subs	r3, r2, r3
 800bfc4:	807b      	strh	r3, [r7, #2]
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 800bfc6:	887a      	ldrh	r2, [r7, #2]
 800bfc8:	897b      	ldrh	r3, [r7, #10]
 800bfca:	429a      	cmp	r2, r3
 800bfcc:	d2dd      	bcs.n	800bf8a <dir_sdi+0x8a>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
 800bfce:	687b      	ldr	r3, [r7, #4]
 800bfd0:	68fa      	ldr	r2, [r7, #12]
 800bfd2:	60da      	str	r2, [r3, #12]
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 800bfd4:	687b      	ldr	r3, [r7, #4]
 800bfd6:	681b      	ldr	r3, [r3, #0]
 800bfd8:	4618      	mov	r0, r3
 800bfda:	68f9      	ldr	r1, [r7, #12]
 800bfdc:	f7ff fc4e 	bl	800b87c <clust2sect>
 800bfe0:	4602      	mov	r2, r0
 800bfe2:	887b      	ldrh	r3, [r7, #2]
 800bfe4:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800bfe8:	b29b      	uxth	r3, r3
 800bfea:	18d2      	adds	r2, r2, r3
 800bfec:	687b      	ldr	r3, [r7, #4]
 800bfee:	611a      	str	r2, [r3, #16]
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
 800bff0:	687b      	ldr	r3, [r7, #4]
 800bff2:	681a      	ldr	r2, [r3, #0]
 800bff4:	887b      	ldrh	r3, [r7, #2]
 800bff6:	f003 030f 	and.w	r3, r3, #15
 800bffa:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800bffe:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800c002:	18d3      	adds	r3, r2, r3
 800c004:	f103 0204 	add.w	r2, r3, #4
 800c008:	687b      	ldr	r3, [r7, #4]
 800c00a:	615a      	str	r2, [r3, #20]

	return FR_OK;	/* Seek succeeded */
 800c00c:	f04f 0300 	mov.w	r3, #0
}
 800c010:	4618      	mov	r0, r3
 800c012:	f107 0710 	add.w	r7, r7, #16
 800c016:	46bd      	mov	sp, r7
 800c018:	bd80      	pop	{r7, pc}
 800c01a:	bf00      	nop

0800c01c <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 800c01c:	b590      	push	{r4, r7, lr}
 800c01e:	b085      	sub	sp, #20
 800c020:	af00      	add	r7, sp, #0
 800c022:	6078      	str	r0, [r7, #4]
 800c024:	6039      	str	r1, [r7, #0]
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
 800c026:	687b      	ldr	r3, [r7, #4]
 800c028:	88db      	ldrh	r3, [r3, #6]
 800c02a:	f103 0301 	add.w	r3, r3, #1
 800c02e:	813b      	strh	r3, [r7, #8]
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 800c030:	893b      	ldrh	r3, [r7, #8]
 800c032:	2b00      	cmp	r3, #0
 800c034:	d003      	beq.n	800c03e <dir_next+0x22>
 800c036:	687b      	ldr	r3, [r7, #4]
 800c038:	691b      	ldr	r3, [r3, #16]
 800c03a:	2b00      	cmp	r3, #0
 800c03c:	d102      	bne.n	800c044 <dir_next+0x28>
		return FR_NO_FILE;
 800c03e:	f04f 0304 	mov.w	r3, #4
 800c042:	e0d5      	b.n	800c1f0 <dir_next+0x1d4>

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 800c044:	893b      	ldrh	r3, [r7, #8]
 800c046:	f003 030f 	and.w	r3, r3, #15
 800c04a:	b29b      	uxth	r3, r3
 800c04c:	2b00      	cmp	r3, #0
 800c04e:	f040 80bc 	bne.w	800c1ca <dir_next+0x1ae>
		dj->sect++;					/* Next sector */
 800c052:	687b      	ldr	r3, [r7, #4]
 800c054:	691b      	ldr	r3, [r3, #16]
 800c056:	f103 0201 	add.w	r2, r3, #1
 800c05a:	687b      	ldr	r3, [r7, #4]
 800c05c:	611a      	str	r2, [r3, #16]

		if (dj->clust == 0) {	/* Static table */
 800c05e:	687b      	ldr	r3, [r7, #4]
 800c060:	68db      	ldr	r3, [r3, #12]
 800c062:	2b00      	cmp	r3, #0
 800c064:	d109      	bne.n	800c07a <dir_next+0x5e>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 800c066:	687b      	ldr	r3, [r7, #4]
 800c068:	681b      	ldr	r3, [r3, #0]
 800c06a:	891b      	ldrh	r3, [r3, #8]
 800c06c:	893a      	ldrh	r2, [r7, #8]
 800c06e:	429a      	cmp	r2, r3
 800c070:	f0c0 80ab 	bcc.w	800c1ca <dir_next+0x1ae>
				return FR_NO_FILE;
 800c074:	f04f 0304 	mov.w	r3, #4
 800c078:	e0ba      	b.n	800c1f0 <dir_next+0x1d4>
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 800c07a:	893b      	ldrh	r3, [r7, #8]
 800c07c:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800c080:	b29b      	uxth	r3, r3
 800c082:	461a      	mov	r2, r3
 800c084:	687b      	ldr	r3, [r7, #4]
 800c086:	681b      	ldr	r3, [r3, #0]
 800c088:	789b      	ldrb	r3, [r3, #2]
 800c08a:	f103 33ff 	add.w	r3, r3, #4294967295
 800c08e:	4013      	ands	r3, r2
 800c090:	2b00      	cmp	r3, #0
 800c092:	f040 809a 	bne.w	800c1ca <dir_next+0x1ae>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 800c096:	687b      	ldr	r3, [r7, #4]
 800c098:	681a      	ldr	r2, [r3, #0]
 800c09a:	687b      	ldr	r3, [r7, #4]
 800c09c:	68db      	ldr	r3, [r3, #12]
 800c09e:	4610      	mov	r0, r2
 800c0a0:	4619      	mov	r1, r3
 800c0a2:	f7ff fc0d 	bl	800b8c0 <get_fat>
 800c0a6:	60f8      	str	r0, [r7, #12]
				if (clst <= 1) return FR_INT_ERR;
 800c0a8:	68fb      	ldr	r3, [r7, #12]
 800c0aa:	2b01      	cmp	r3, #1
 800c0ac:	d802      	bhi.n	800c0b4 <dir_next+0x98>
 800c0ae:	f04f 0302 	mov.w	r3, #2
 800c0b2:	e09d      	b.n	800c1f0 <dir_next+0x1d4>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 800c0b4:	68fb      	ldr	r3, [r7, #12]
 800c0b6:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c0ba:	d102      	bne.n	800c0c2 <dir_next+0xa6>
 800c0bc:	f04f 0301 	mov.w	r3, #1
 800c0c0:	e096      	b.n	800c1f0 <dir_next+0x1d4>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 800c0c2:	687b      	ldr	r3, [r7, #4]
 800c0c4:	681b      	ldr	r3, [r3, #0]
 800c0c6:	69da      	ldr	r2, [r3, #28]
 800c0c8:	68fb      	ldr	r3, [r7, #12]
 800c0ca:	429a      	cmp	r2, r3
 800c0cc:	d871      	bhi.n	800c1b2 <dir_next+0x196>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
 800c0ce:	683b      	ldr	r3, [r7, #0]
 800c0d0:	2b00      	cmp	r3, #0
 800c0d2:	d102      	bne.n	800c0da <dir_next+0xbe>
 800c0d4:	f04f 0304 	mov.w	r3, #4
 800c0d8:	e08a      	b.n	800c1f0 <dir_next+0x1d4>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
 800c0da:	687b      	ldr	r3, [r7, #4]
 800c0dc:	681a      	ldr	r2, [r3, #0]
 800c0de:	687b      	ldr	r3, [r7, #4]
 800c0e0:	68db      	ldr	r3, [r3, #12]
 800c0e2:	4610      	mov	r0, r2
 800c0e4:	4619      	mov	r1, r3
 800c0e6:	f7ff fe75 	bl	800bdd4 <create_chain>
 800c0ea:	60f8      	str	r0, [r7, #12]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800c0ec:	68fb      	ldr	r3, [r7, #12]
 800c0ee:	2b00      	cmp	r3, #0
 800c0f0:	d102      	bne.n	800c0f8 <dir_next+0xdc>
 800c0f2:	f04f 0307 	mov.w	r3, #7
 800c0f6:	e07b      	b.n	800c1f0 <dir_next+0x1d4>
					if (clst == 1) return FR_INT_ERR;
 800c0f8:	68fb      	ldr	r3, [r7, #12]
 800c0fa:	2b01      	cmp	r3, #1
 800c0fc:	d102      	bne.n	800c104 <dir_next+0xe8>
 800c0fe:	f04f 0302 	mov.w	r3, #2
 800c102:	e075      	b.n	800c1f0 <dir_next+0x1d4>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 800c104:	68fb      	ldr	r3, [r7, #12]
 800c106:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c10a:	d102      	bne.n	800c112 <dir_next+0xf6>
 800c10c:	f04f 0301 	mov.w	r3, #1
 800c110:	e06e      	b.n	800c1f0 <dir_next+0x1d4>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
 800c112:	687b      	ldr	r3, [r7, #4]
 800c114:	681b      	ldr	r3, [r3, #0]
 800c116:	4618      	mov	r0, r3
 800c118:	f04f 0100 	mov.w	r1, #0
 800c11c:	f7ff fa84 	bl	800b628 <move_window>
 800c120:	4603      	mov	r3, r0
 800c122:	2b00      	cmp	r3, #0
 800c124:	d002      	beq.n	800c12c <dir_next+0x110>
 800c126:	f04f 0301 	mov.w	r3, #1
 800c12a:	e061      	b.n	800c1f0 <dir_next+0x1d4>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
 800c12c:	687b      	ldr	r3, [r7, #4]
 800c12e:	681b      	ldr	r3, [r3, #0]
 800c130:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800c134:	4618      	mov	r0, r3
 800c136:	f04f 0100 	mov.w	r1, #0
 800c13a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800c13e:	f7ff f9fd 	bl	800b53c <mem_set>
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
 800c142:	687b      	ldr	r3, [r7, #4]
 800c144:	681c      	ldr	r4, [r3, #0]
 800c146:	687b      	ldr	r3, [r7, #4]
 800c148:	681b      	ldr	r3, [r3, #0]
 800c14a:	4618      	mov	r0, r3
 800c14c:	68f9      	ldr	r1, [r7, #12]
 800c14e:	f7ff fb95 	bl	800b87c <clust2sect>
 800c152:	4603      	mov	r3, r0
 800c154:	6323      	str	r3, [r4, #48]	; 0x30
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 800c156:	f04f 0300 	mov.w	r3, #0
 800c15a:	72fb      	strb	r3, [r7, #11]
 800c15c:	e01b      	b.n	800c196 <dir_next+0x17a>
						dj->fs->wflag = 1;
 800c15e:	687b      	ldr	r3, [r7, #4]
 800c160:	681b      	ldr	r3, [r3, #0]
 800c162:	f04f 0201 	mov.w	r2, #1
 800c166:	711a      	strb	r2, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
 800c168:	687b      	ldr	r3, [r7, #4]
 800c16a:	681b      	ldr	r3, [r3, #0]
 800c16c:	4618      	mov	r0, r3
 800c16e:	f04f 0100 	mov.w	r1, #0
 800c172:	f7ff fa59 	bl	800b628 <move_window>
 800c176:	4603      	mov	r3, r0
 800c178:	2b00      	cmp	r3, #0
 800c17a:	d002      	beq.n	800c182 <dir_next+0x166>
 800c17c:	f04f 0301 	mov.w	r3, #1
 800c180:	e036      	b.n	800c1f0 <dir_next+0x1d4>
						dj->fs->winsect++;
 800c182:	687b      	ldr	r3, [r7, #4]
 800c184:	681b      	ldr	r3, [r3, #0]
 800c186:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c188:	f102 0201 	add.w	r2, r2, #1
 800c18c:	631a      	str	r2, [r3, #48]	; 0x30
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
 800c18e:	7afb      	ldrb	r3, [r7, #11]
 800c190:	f103 0301 	add.w	r3, r3, #1
 800c194:	72fb      	strb	r3, [r7, #11]
 800c196:	687b      	ldr	r3, [r7, #4]
 800c198:	681b      	ldr	r3, [r3, #0]
 800c19a:	789b      	ldrb	r3, [r3, #2]
 800c19c:	7afa      	ldrb	r2, [r7, #11]
 800c19e:	429a      	cmp	r2, r3
 800c1a0:	d3dd      	bcc.n	800c15e <dir_next+0x142>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
 800c1a2:	687b      	ldr	r3, [r7, #4]
 800c1a4:	681b      	ldr	r3, [r3, #0]
 800c1a6:	687a      	ldr	r2, [r7, #4]
 800c1a8:	6812      	ldr	r2, [r2, #0]
 800c1aa:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800c1ac:	7afa      	ldrb	r2, [r7, #11]
 800c1ae:	1a8a      	subs	r2, r1, r2
 800c1b0:	631a      	str	r2, [r3, #48]	; 0x30
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
 800c1b2:	687b      	ldr	r3, [r7, #4]
 800c1b4:	68fa      	ldr	r2, [r7, #12]
 800c1b6:	60da      	str	r2, [r3, #12]
				dj->sect = clust2sect(dj->fs, clst);
 800c1b8:	687b      	ldr	r3, [r7, #4]
 800c1ba:	681b      	ldr	r3, [r3, #0]
 800c1bc:	4618      	mov	r0, r3
 800c1be:	68f9      	ldr	r1, [r7, #12]
 800c1c0:	f7ff fb5c 	bl	800b87c <clust2sect>
 800c1c4:	4602      	mov	r2, r0
 800c1c6:	687b      	ldr	r3, [r7, #4]
 800c1c8:	611a      	str	r2, [r3, #16]
			}
		}
	}

	dj->index = i;
 800c1ca:	687b      	ldr	r3, [r7, #4]
 800c1cc:	893a      	ldrh	r2, [r7, #8]
 800c1ce:	80da      	strh	r2, [r3, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 800c1d0:	687b      	ldr	r3, [r7, #4]
 800c1d2:	681a      	ldr	r2, [r3, #0]
 800c1d4:	893b      	ldrh	r3, [r7, #8]
 800c1d6:	f003 030f 	and.w	r3, r3, #15
 800c1da:	ea4f 1343 	mov.w	r3, r3, lsl #5
 800c1de:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800c1e2:	18d3      	adds	r3, r2, r3
 800c1e4:	f103 0204 	add.w	r2, r3, #4
 800c1e8:	687b      	ldr	r3, [r7, #4]
 800c1ea:	615a      	str	r2, [r3, #20]

	return FR_OK;
 800c1ec:	f04f 0300 	mov.w	r3, #0
}
 800c1f0:	4618      	mov	r0, r3
 800c1f2:	f107 0714 	add.w	r7, r7, #20
 800c1f6:	46bd      	mov	sp, r7
 800c1f8:	bd90      	pop	{r4, r7, pc}
 800c1fa:	bf00      	nop

0800c1fc <dir_find>:

static
FRESULT dir_find (
	DIR *dj			/* Pointer to the directory object linked to the file name */
)
{
 800c1fc:	b580      	push	{r7, lr}
 800c1fe:	b086      	sub	sp, #24
 800c200:	af00      	add	r7, sp, #0
 800c202:	6078      	str	r0, [r7, #4]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
 800c204:	6878      	ldr	r0, [r7, #4]
 800c206:	f04f 0100 	mov.w	r1, #0
 800c20a:	f7ff fe79 	bl	800bf00 <dir_sdi>
 800c20e:	4603      	mov	r3, r0
 800c210:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) return res;
 800c212:	7dfb      	ldrb	r3, [r7, #23]
 800c214:	2b00      	cmp	r3, #0
 800c216:	d001      	beq.n	800c21c <dir_find+0x20>
 800c218:	7dfb      	ldrb	r3, [r7, #23]
 800c21a:	e03b      	b.n	800c294 <dir_find+0x98>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
 800c21c:	687b      	ldr	r3, [r7, #4]
 800c21e:	681a      	ldr	r2, [r3, #0]
 800c220:	687b      	ldr	r3, [r7, #4]
 800c222:	691b      	ldr	r3, [r3, #16]
 800c224:	4610      	mov	r0, r2
 800c226:	4619      	mov	r1, r3
 800c228:	f7ff f9fe 	bl	800b628 <move_window>
 800c22c:	4603      	mov	r3, r0
 800c22e:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800c230:	7dfb      	ldrb	r3, [r7, #23]
 800c232:	2b00      	cmp	r3, #0
 800c234:	d12a      	bne.n	800c28c <dir_find+0x90>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 800c236:	687b      	ldr	r3, [r7, #4]
 800c238:	695b      	ldr	r3, [r3, #20]
 800c23a:	613b      	str	r3, [r7, #16]
		c = dir[DIR_Name];
 800c23c:	693b      	ldr	r3, [r7, #16]
 800c23e:	781b      	ldrb	r3, [r3, #0]
 800c240:	73fb      	strb	r3, [r7, #15]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800c242:	7bfb      	ldrb	r3, [r7, #15]
 800c244:	2b00      	cmp	r3, #0
 800c246:	d103      	bne.n	800c250 <dir_find+0x54>
 800c248:	f04f 0304 	mov.w	r3, #4
 800c24c:	75fb      	strb	r3, [r7, #23]
 800c24e:	e020      	b.n	800c292 <dir_find+0x96>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 800c250:	693b      	ldr	r3, [r7, #16]
 800c252:	f103 030b 	add.w	r3, r3, #11
 800c256:	781b      	ldrb	r3, [r3, #0]
 800c258:	f003 0308 	and.w	r3, r3, #8
 800c25c:	2b00      	cmp	r3, #0
 800c25e:	d10a      	bne.n	800c276 <dir_find+0x7a>
 800c260:	687b      	ldr	r3, [r7, #4]
 800c262:	699b      	ldr	r3, [r3, #24]
 800c264:	6938      	ldr	r0, [r7, #16]
 800c266:	4619      	mov	r1, r3
 800c268:	f04f 020b 	mov.w	r2, #11
 800c26c:	f7ff f988 	bl	800b580 <mem_cmp>
 800c270:	4603      	mov	r3, r0
 800c272:	2b00      	cmp	r3, #0
 800c274:	d00c      	beq.n	800c290 <dir_find+0x94>
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
 800c276:	6878      	ldr	r0, [r7, #4]
 800c278:	f04f 0100 	mov.w	r1, #0
 800c27c:	f7ff fece 	bl	800c01c <dir_next>
 800c280:	4603      	mov	r3, r0
 800c282:	75fb      	strb	r3, [r7, #23]
	} while (res == FR_OK);
 800c284:	7dfb      	ldrb	r3, [r7, #23]
 800c286:	2b00      	cmp	r3, #0
 800c288:	d0c8      	beq.n	800c21c <dir_find+0x20>
 800c28a:	e002      	b.n	800c292 <dir_find+0x96>
#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
 800c28c:	bf00      	nop
 800c28e:	e000      	b.n	800c292 <dir_find+0x96>
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
 800c290:	bf00      	nop
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
 800c292:	7dfb      	ldrb	r3, [r7, #23]
}
 800c294:	4618      	mov	r0, r3
 800c296:	f107 0718 	add.w	r7, r7, #24
 800c29a:	46bd      	mov	sp, r7
 800c29c:	bd80      	pop	{r7, pc}
 800c29e:	bf00      	nop

0800c2a0 <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
 800c2a0:	b580      	push	{r7, lr}
 800c2a2:	b086      	sub	sp, #24
 800c2a4:	af00      	add	r7, sp, #0
 800c2a6:	6078      	str	r0, [r7, #4]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
 800c2a8:	f04f 0304 	mov.w	r3, #4
 800c2ac:	75fb      	strb	r3, [r7, #23]
	while (dj->sect) {
 800c2ae:	e02e      	b.n	800c30e <dir_read+0x6e>
		res = move_window(dj->fs, dj->sect);
 800c2b0:	687b      	ldr	r3, [r7, #4]
 800c2b2:	681a      	ldr	r2, [r3, #0]
 800c2b4:	687b      	ldr	r3, [r7, #4]
 800c2b6:	691b      	ldr	r3, [r3, #16]
 800c2b8:	4610      	mov	r0, r2
 800c2ba:	4619      	mov	r1, r3
 800c2bc:	f7ff f9b4 	bl	800b628 <move_window>
 800c2c0:	4603      	mov	r3, r0
 800c2c2:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800c2c4:	7dfb      	ldrb	r3, [r7, #23]
 800c2c6:	2b00      	cmp	r3, #0
 800c2c8:	d126      	bne.n	800c318 <dir_read+0x78>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 800c2ca:	687b      	ldr	r3, [r7, #4]
 800c2cc:	695b      	ldr	r3, [r3, #20]
 800c2ce:	613b      	str	r3, [r7, #16]
		c = dir[DIR_Name];
 800c2d0:	693b      	ldr	r3, [r7, #16]
 800c2d2:	781b      	ldrb	r3, [r3, #0]
 800c2d4:	73fb      	strb	r3, [r7, #15]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800c2d6:	7bfb      	ldrb	r3, [r7, #15]
 800c2d8:	2b00      	cmp	r3, #0
 800c2da:	d103      	bne.n	800c2e4 <dir_read+0x44>
 800c2dc:	f04f 0304 	mov.w	r3, #4
 800c2e0:	75fb      	strb	r3, [r7, #23]
 800c2e2:	e01e      	b.n	800c322 <dir_read+0x82>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
 800c2e4:	7bfb      	ldrb	r3, [r7, #15]
 800c2e6:	2be5      	cmp	r3, #229	; 0xe5
 800c2e8:	d007      	beq.n	800c2fa <dir_read+0x5a>
 800c2ea:	693b      	ldr	r3, [r7, #16]
 800c2ec:	f103 030b 	add.w	r3, r3, #11
 800c2f0:	781b      	ldrb	r3, [r3, #0]
 800c2f2:	f003 0308 	and.w	r3, r3, #8
 800c2f6:	2b00      	cmp	r3, #0
 800c2f8:	d010      	beq.n	800c31c <dir_read+0x7c>
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
 800c2fa:	6878      	ldr	r0, [r7, #4]
 800c2fc:	f04f 0100 	mov.w	r1, #0
 800c300:	f7ff fe8c 	bl	800c01c <dir_next>
 800c304:	4603      	mov	r3, r0
 800c306:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 800c308:	7dfb      	ldrb	r3, [r7, #23]
 800c30a:	2b00      	cmp	r3, #0
 800c30c:	d108      	bne.n	800c320 <dir_read+0x80>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
 800c30e:	687b      	ldr	r3, [r7, #4]
 800c310:	691b      	ldr	r3, [r3, #16]
 800c312:	2b00      	cmp	r3, #0
 800c314:	d1cc      	bne.n	800c2b0 <dir_read+0x10>
 800c316:	e004      	b.n	800c322 <dir_read+0x82>
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
 800c318:	bf00      	nop
 800c31a:	e002      	b.n	800c322 <dir_read+0x82>
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
 800c31c:	bf00      	nop
 800c31e:	e000      	b.n	800c322 <dir_read+0x82>
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
 800c320:	bf00      	nop
	}

	if (res != FR_OK) dj->sect = 0;
 800c322:	7dfb      	ldrb	r3, [r7, #23]
 800c324:	2b00      	cmp	r3, #0
 800c326:	d003      	beq.n	800c330 <dir_read+0x90>
 800c328:	687b      	ldr	r3, [r7, #4]
 800c32a:	f04f 0200 	mov.w	r2, #0
 800c32e:	611a      	str	r2, [r3, #16]

	return res;
 800c330:	7dfb      	ldrb	r3, [r7, #23]
}
 800c332:	4618      	mov	r0, r3
 800c334:	f107 0718 	add.w	r7, r7, #24
 800c338:	46bd      	mov	sp, r7
 800c33a:	bd80      	pop	{r7, pc}

0800c33c <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
 800c33c:	b580      	push	{r7, lr}
 800c33e:	b084      	sub	sp, #16
 800c340:	af00      	add	r7, sp, #0
 800c342:	6078      	str	r0, [r7, #4]
			} while (res == FR_OK && --ne);
		}
	}

#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
 800c344:	6878      	ldr	r0, [r7, #4]
 800c346:	f04f 0100 	mov.w	r1, #0
 800c34a:	f7ff fdd9 	bl	800bf00 <dir_sdi>
 800c34e:	4603      	mov	r3, r0
 800c350:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800c352:	7bfb      	ldrb	r3, [r7, #15]
 800c354:	2b00      	cmp	r3, #0
 800c356:	d122      	bne.n	800c39e <dir_register+0x62>
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
 800c358:	687b      	ldr	r3, [r7, #4]
 800c35a:	681a      	ldr	r2, [r3, #0]
 800c35c:	687b      	ldr	r3, [r7, #4]
 800c35e:	691b      	ldr	r3, [r3, #16]
 800c360:	4610      	mov	r0, r2
 800c362:	4619      	mov	r1, r3
 800c364:	f7ff f960 	bl	800b628 <move_window>
 800c368:	4603      	mov	r3, r0
 800c36a:	73fb      	strb	r3, [r7, #15]
			if (res != FR_OK) break;
 800c36c:	7bfb      	ldrb	r3, [r7, #15]
 800c36e:	2b00      	cmp	r3, #0
 800c370:	d114      	bne.n	800c39c <dir_register+0x60>
			c = *dj->dir;
 800c372:	687b      	ldr	r3, [r7, #4]
 800c374:	695b      	ldr	r3, [r3, #20]
 800c376:	781b      	ldrb	r3, [r3, #0]
 800c378:	73bb      	strb	r3, [r7, #14]
			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
 800c37a:	7bbb      	ldrb	r3, [r7, #14]
 800c37c:	2be5      	cmp	r3, #229	; 0xe5
 800c37e:	d00e      	beq.n	800c39e <dir_register+0x62>
 800c380:	7bbb      	ldrb	r3, [r7, #14]
 800c382:	2b00      	cmp	r3, #0
 800c384:	d00b      	beq.n	800c39e <dir_register+0x62>
			res = dir_next(dj, 1);			/* Next entry with table stretch */
 800c386:	6878      	ldr	r0, [r7, #4]
 800c388:	f04f 0101 	mov.w	r1, #1
 800c38c:	f7ff fe46 	bl	800c01c <dir_next>
 800c390:	4603      	mov	r3, r0
 800c392:	73fb      	strb	r3, [r7, #15]
		} while (res == FR_OK);
 800c394:	7bfb      	ldrb	r3, [r7, #15]
 800c396:	2b00      	cmp	r3, #0
 800c398:	d0de      	beq.n	800c358 <dir_register+0x1c>
 800c39a:	e000      	b.n	800c39e <dir_register+0x62>
#else	/* Non LFN configuration */
	res = dir_sdi(dj, 0);
	if (res == FR_OK) {
		do {	/* Find a blank entry for the SFN */
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
 800c39c:	bf00      	nop
			res = dir_next(dj, 1);			/* Next entry with table stretch */
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
 800c39e:	7bfb      	ldrb	r3, [r7, #15]
 800c3a0:	2b00      	cmp	r3, #0
 800c3a2:	d123      	bne.n	800c3ec <dir_register+0xb0>
		res = move_window(dj->fs, dj->sect);
 800c3a4:	687b      	ldr	r3, [r7, #4]
 800c3a6:	681a      	ldr	r2, [r3, #0]
 800c3a8:	687b      	ldr	r3, [r7, #4]
 800c3aa:	691b      	ldr	r3, [r3, #16]
 800c3ac:	4610      	mov	r0, r2
 800c3ae:	4619      	mov	r1, r3
 800c3b0:	f7ff f93a 	bl	800b628 <move_window>
 800c3b4:	4603      	mov	r3, r0
 800c3b6:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 800c3b8:	7bfb      	ldrb	r3, [r7, #15]
 800c3ba:	2b00      	cmp	r3, #0
 800c3bc:	d116      	bne.n	800c3ec <dir_register+0xb0>
			dir = dj->dir;
 800c3be:	687b      	ldr	r3, [r7, #4]
 800c3c0:	695b      	ldr	r3, [r3, #20]
 800c3c2:	60bb      	str	r3, [r7, #8]
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
 800c3c4:	68b8      	ldr	r0, [r7, #8]
 800c3c6:	f04f 0100 	mov.w	r1, #0
 800c3ca:	f04f 0220 	mov.w	r2, #32
 800c3ce:	f7ff f8b5 	bl	800b53c <mem_set>
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
 800c3d2:	687b      	ldr	r3, [r7, #4]
 800c3d4:	699b      	ldr	r3, [r3, #24]
 800c3d6:	68b8      	ldr	r0, [r7, #8]
 800c3d8:	4619      	mov	r1, r3
 800c3da:	f04f 020b 	mov.w	r2, #11
 800c3de:	f7ff f885 	bl	800b4ec <mem_cpy>
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dj->fs->wflag = 1;
 800c3e2:	687b      	ldr	r3, [r7, #4]
 800c3e4:	681b      	ldr	r3, [r3, #0]
 800c3e6:	f04f 0201 	mov.w	r2, #1
 800c3ea:	711a      	strb	r2, [r3, #4]
		}
	}

	return res;
 800c3ec:	7bfb      	ldrb	r3, [r7, #15]
}
 800c3ee:	4618      	mov	r0, r3
 800c3f0:	f107 0710 	add.w	r7, r7, #16
 800c3f4:	46bd      	mov	sp, r7
 800c3f6:	bd80      	pop	{r7, pc}

0800c3f8 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
 800c3f8:	b580      	push	{r7, lr}
 800c3fa:	b084      	sub	sp, #16
 800c3fc:	af00      	add	r7, sp, #0
 800c3fe:	6078      	str	r0, [r7, #4]
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dj, dj->index);
 800c400:	687b      	ldr	r3, [r7, #4]
 800c402:	88db      	ldrh	r3, [r3, #6]
 800c404:	6878      	ldr	r0, [r7, #4]
 800c406:	4619      	mov	r1, r3
 800c408:	f7ff fd7a 	bl	800bf00 <dir_sdi>
 800c40c:	4603      	mov	r3, r0
 800c40e:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800c410:	7bfb      	ldrb	r3, [r7, #15]
 800c412:	2b00      	cmp	r3, #0
 800c414:	d116      	bne.n	800c444 <dir_remove+0x4c>
		res = move_window(dj->fs, dj->sect);
 800c416:	687b      	ldr	r3, [r7, #4]
 800c418:	681a      	ldr	r2, [r3, #0]
 800c41a:	687b      	ldr	r3, [r7, #4]
 800c41c:	691b      	ldr	r3, [r3, #16]
 800c41e:	4610      	mov	r0, r2
 800c420:	4619      	mov	r1, r3
 800c422:	f7ff f901 	bl	800b628 <move_window>
 800c426:	4603      	mov	r3, r0
 800c428:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 800c42a:	7bfb      	ldrb	r3, [r7, #15]
 800c42c:	2b00      	cmp	r3, #0
 800c42e:	d109      	bne.n	800c444 <dir_remove+0x4c>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	695b      	ldr	r3, [r3, #20]
 800c434:	f04f 02e5 	mov.w	r2, #229	; 0xe5
 800c438:	701a      	strb	r2, [r3, #0]
			dj->fs->wflag = 1;
 800c43a:	687b      	ldr	r3, [r7, #4]
 800c43c:	681b      	ldr	r3, [r3, #0]
 800c43e:	f04f 0201 	mov.w	r2, #1
 800c442:	711a      	strb	r2, [r3, #4]
		}
	}
#endif

	return res;
 800c444:	7bfb      	ldrb	r3, [r7, #15]
}
 800c446:	4618      	mov	r0, r3
 800c448:	f107 0710 	add.w	r7, r7, #16
 800c44c:	46bd      	mov	sp, r7
 800c44e:	bd80      	pop	{r7, pc}

0800c450 <create_name>:
static
FRESULT create_name (
	DIR *dj,			/* Pointer to the directory object */
	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
)
{
 800c450:	b580      	push	{r7, lr}
 800c452:	b088      	sub	sp, #32
 800c454:	af00      	add	r7, sp, #0
 800c456:	6078      	str	r0, [r7, #4]
 800c458:	6039      	str	r1, [r7, #0]
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 800c45a:	683b      	ldr	r3, [r7, #0]
 800c45c:	681b      	ldr	r3, [r3, #0]
 800c45e:	60fb      	str	r3, [r7, #12]
 800c460:	e003      	b.n	800c46a <create_name+0x1a>
 800c462:	68fb      	ldr	r3, [r7, #12]
 800c464:	f103 0301 	add.w	r3, r3, #1
 800c468:	60fb      	str	r3, [r7, #12]
 800c46a:	68fb      	ldr	r3, [r7, #12]
 800c46c:	781b      	ldrb	r3, [r3, #0]
 800c46e:	2b2f      	cmp	r3, #47	; 0x2f
 800c470:	d0f7      	beq.n	800c462 <create_name+0x12>
 800c472:	68fb      	ldr	r3, [r7, #12]
 800c474:	781b      	ldrb	r3, [r3, #0]
 800c476:	2b5c      	cmp	r3, #92	; 0x5c
 800c478:	d0f3      	beq.n	800c462 <create_name+0x12>
	sfn = dj->fn;
 800c47a:	687b      	ldr	r3, [r7, #4]
 800c47c:	699b      	ldr	r3, [r3, #24]
 800c47e:	60bb      	str	r3, [r7, #8]
	mem_set(sfn, ' ', 11);
 800c480:	68b8      	ldr	r0, [r7, #8]
 800c482:	f04f 0120 	mov.w	r1, #32
 800c486:	f04f 020b 	mov.w	r2, #11
 800c48a:	f7ff f857 	bl	800b53c <mem_set>
	si = i = b = 0; ni = 8;
 800c48e:	f04f 0300 	mov.w	r3, #0
 800c492:	77fb      	strb	r3, [r7, #31]
 800c494:	f04f 0300 	mov.w	r3, #0
 800c498:	613b      	str	r3, [r7, #16]
 800c49a:	693b      	ldr	r3, [r7, #16]
 800c49c:	617b      	str	r3, [r7, #20]
 800c49e:	f04f 0308 	mov.w	r3, #8
 800c4a2:	61bb      	str	r3, [r7, #24]
#if _FS_RPATH
	if (p[si] == '.') { /* Is this a dot entry? */
 800c4a4:	68fa      	ldr	r2, [r7, #12]
 800c4a6:	697b      	ldr	r3, [r7, #20]
 800c4a8:	18d3      	adds	r3, r2, r3
 800c4aa:	781b      	ldrb	r3, [r3, #0]
 800c4ac:	2b2e      	cmp	r3, #46	; 0x2e
 800c4ae:	d138      	bne.n	800c522 <create_name+0xd2>
		for (;;) {
			c = (BYTE)p[si++];
 800c4b0:	68fa      	ldr	r2, [r7, #12]
 800c4b2:	697b      	ldr	r3, [r7, #20]
 800c4b4:	18d3      	adds	r3, r2, r3
 800c4b6:	781b      	ldrb	r3, [r3, #0]
 800c4b8:	77bb      	strb	r3, [r7, #30]
 800c4ba:	697b      	ldr	r3, [r7, #20]
 800c4bc:	f103 0301 	add.w	r3, r3, #1
 800c4c0:	617b      	str	r3, [r7, #20]
			if (c != '.' || si >= 3) break;
 800c4c2:	7fbb      	ldrb	r3, [r7, #30]
 800c4c4:	2b2e      	cmp	r3, #46	; 0x2e
 800c4c6:	d10c      	bne.n	800c4e2 <create_name+0x92>
 800c4c8:	697b      	ldr	r3, [r7, #20]
 800c4ca:	2b02      	cmp	r3, #2
 800c4cc:	d809      	bhi.n	800c4e2 <create_name+0x92>
			sfn[i++] = c;
 800c4ce:	68ba      	ldr	r2, [r7, #8]
 800c4d0:	693b      	ldr	r3, [r7, #16]
 800c4d2:	18d3      	adds	r3, r2, r3
 800c4d4:	7fba      	ldrb	r2, [r7, #30]
 800c4d6:	701a      	strb	r2, [r3, #0]
 800c4d8:	693b      	ldr	r3, [r7, #16]
 800c4da:	f103 0301 	add.w	r3, r3, #1
 800c4de:	613b      	str	r3, [r7, #16]
		}
 800c4e0:	e7e6      	b.n	800c4b0 <create_name+0x60>
		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
 800c4e2:	7fbb      	ldrb	r3, [r7, #30]
 800c4e4:	2b2f      	cmp	r3, #47	; 0x2f
 800c4e6:	d008      	beq.n	800c4fa <create_name+0xaa>
 800c4e8:	7fbb      	ldrb	r3, [r7, #30]
 800c4ea:	2b5c      	cmp	r3, #92	; 0x5c
 800c4ec:	d005      	beq.n	800c4fa <create_name+0xaa>
 800c4ee:	7fbb      	ldrb	r3, [r7, #30]
 800c4f0:	2b20      	cmp	r3, #32
 800c4f2:	d902      	bls.n	800c4fa <create_name+0xaa>
 800c4f4:	f04f 0306 	mov.w	r3, #6
 800c4f8:	e0bf      	b.n	800c67a <create_name+0x22a>
		*path = &p[si];									/* Return pointer to the next segment */
 800c4fa:	68fa      	ldr	r2, [r7, #12]
 800c4fc:	697b      	ldr	r3, [r7, #20]
 800c4fe:	18d2      	adds	r2, r2, r3
 800c500:	683b      	ldr	r3, [r7, #0]
 800c502:	601a      	str	r2, [r3, #0]
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
 800c504:	68bb      	ldr	r3, [r7, #8]
 800c506:	f103 020b 	add.w	r2, r3, #11
 800c50a:	7fbb      	ldrb	r3, [r7, #30]
 800c50c:	2b20      	cmp	r3, #32
 800c50e:	d802      	bhi.n	800c516 <create_name+0xc6>
 800c510:	f04f 0324 	mov.w	r3, #36	; 0x24
 800c514:	e001      	b.n	800c51a <create_name+0xca>
 800c516:	f04f 0320 	mov.w	r3, #32
 800c51a:	7013      	strb	r3, [r2, #0]
		return FR_OK;
 800c51c:	f04f 0300 	mov.w	r3, #0
 800c520:	e0ab      	b.n	800c67a <create_name+0x22a>
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 800c522:	68fa      	ldr	r2, [r7, #12]
 800c524:	697b      	ldr	r3, [r7, #20]
 800c526:	18d3      	adds	r3, r2, r3
 800c528:	781b      	ldrb	r3, [r3, #0]
 800c52a:	77bb      	strb	r3, [r7, #30]
 800c52c:	697b      	ldr	r3, [r7, #20]
 800c52e:	f103 0301 	add.w	r3, r3, #1
 800c532:	617b      	str	r3, [r7, #20]
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 800c534:	7fbb      	ldrb	r3, [r7, #30]
 800c536:	2b20      	cmp	r3, #32
 800c538:	d963      	bls.n	800c602 <create_name+0x1b2>
 800c53a:	7fbb      	ldrb	r3, [r7, #30]
 800c53c:	2b2f      	cmp	r3, #47	; 0x2f
 800c53e:	d060      	beq.n	800c602 <create_name+0x1b2>
 800c540:	7fbb      	ldrb	r3, [r7, #30]
 800c542:	2b5c      	cmp	r3, #92	; 0x5c
 800c544:	d05d      	beq.n	800c602 <create_name+0x1b2>
		if (c == '.' || i >= ni) {
 800c546:	7fbb      	ldrb	r3, [r7, #30]
 800c548:	2b2e      	cmp	r3, #46	; 0x2e
 800c54a:	d003      	beq.n	800c554 <create_name+0x104>
 800c54c:	693a      	ldr	r2, [r7, #16]
 800c54e:	69bb      	ldr	r3, [r7, #24]
 800c550:	429a      	cmp	r2, r3
 800c552:	d314      	bcc.n	800c57e <create_name+0x12e>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 800c554:	69bb      	ldr	r3, [r7, #24]
 800c556:	2b08      	cmp	r3, #8
 800c558:	d102      	bne.n	800c560 <create_name+0x110>
 800c55a:	7fbb      	ldrb	r3, [r7, #30]
 800c55c:	2b2e      	cmp	r3, #46	; 0x2e
 800c55e:	d002      	beq.n	800c566 <create_name+0x116>
 800c560:	f04f 0306 	mov.w	r3, #6
 800c564:	e089      	b.n	800c67a <create_name+0x22a>
			i = 8; ni = 11;
 800c566:	f04f 0308 	mov.w	r3, #8
 800c56a:	613b      	str	r3, [r7, #16]
 800c56c:	f04f 030b 	mov.w	r3, #11
 800c570:	61bb      	str	r3, [r7, #24]
			b <<= 2; continue;
 800c572:	7ffb      	ldrb	r3, [r7, #31]
 800c574:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c578:	77fb      	strb	r3, [r7, #31]
 800c57a:	bf00      	nop
					b |= 1; c -= 0x20;
				}
			}
			sfn[i++] = c;
		}
	}
 800c57c:	e7d1      	b.n	800c522 <create_name+0xd2>
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
 800c57e:	7fbb      	ldrb	r3, [r7, #30]
 800c580:	b25b      	sxtb	r3, r3
 800c582:	2b00      	cmp	r3, #0
 800c584:	da0c      	bge.n	800c5a0 <create_name+0x150>
			b |= 3;						/* Eliminate NT flag */
 800c586:	7ffb      	ldrb	r3, [r7, #31]
 800c588:	f043 0303 	orr.w	r3, r3, #3
 800c58c:	77fb      	strb	r3, [r7, #31]
#ifdef _EXCVT
			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
 800c58e:	7fbb      	ldrb	r3, [r7, #30]
 800c590:	f1a3 0280 	sub.w	r2, r3, #128	; 0x80
 800c594:	f246 7338 	movw	r3, #26424	; 0x6738
 800c598:	f6c0 0302 	movt	r3, #2050	; 0x802
 800c59c:	5c9b      	ldrb	r3, [r3, r2]
 800c59e:	77bb      	strb	r3, [r7, #30]
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
 800c5a0:	7fbb      	ldrb	r3, [r7, #30]
 800c5a2:	f246 60c4 	movw	r0, #26308	; 0x66c4
 800c5a6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800c5aa:	4619      	mov	r1, r3
 800c5ac:	f7ff f820 	bl	800b5f0 <chk_chr>
 800c5b0:	4603      	mov	r3, r0
 800c5b2:	2b00      	cmp	r3, #0
 800c5b4:	d002      	beq.n	800c5bc <create_name+0x16c>
				return FR_INVALID_NAME;
 800c5b6:	f04f 0306 	mov.w	r3, #6
 800c5ba:	e05e      	b.n	800c67a <create_name+0x22a>
			if (IsUpper(c)) {			/* ASCII large capital? */
 800c5bc:	7fbb      	ldrb	r3, [r7, #30]
 800c5be:	2b40      	cmp	r3, #64	; 0x40
 800c5c0:	d907      	bls.n	800c5d2 <create_name+0x182>
 800c5c2:	7fbb      	ldrb	r3, [r7, #30]
 800c5c4:	2b5a      	cmp	r3, #90	; 0x5a
 800c5c6:	d804      	bhi.n	800c5d2 <create_name+0x182>
				b |= 2;
 800c5c8:	7ffb      	ldrb	r3, [r7, #31]
 800c5ca:	f043 0302 	orr.w	r3, r3, #2
 800c5ce:	77fb      	strb	r3, [r7, #31]
 800c5d0:	e00d      	b.n	800c5ee <create_name+0x19e>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
 800c5d2:	7fbb      	ldrb	r3, [r7, #30]
 800c5d4:	2b60      	cmp	r3, #96	; 0x60
 800c5d6:	d90a      	bls.n	800c5ee <create_name+0x19e>
 800c5d8:	7fbb      	ldrb	r3, [r7, #30]
 800c5da:	2b7a      	cmp	r3, #122	; 0x7a
 800c5dc:	d807      	bhi.n	800c5ee <create_name+0x19e>
					b |= 1; c -= 0x20;
 800c5de:	7ffb      	ldrb	r3, [r7, #31]
 800c5e0:	f043 0301 	orr.w	r3, r3, #1
 800c5e4:	77fb      	strb	r3, [r7, #31]
 800c5e6:	7fbb      	ldrb	r3, [r7, #30]
 800c5e8:	f1a3 0320 	sub.w	r3, r3, #32
 800c5ec:	77bb      	strb	r3, [r7, #30]
				}
			}
			sfn[i++] = c;
 800c5ee:	68ba      	ldr	r2, [r7, #8]
 800c5f0:	693b      	ldr	r3, [r7, #16]
 800c5f2:	18d3      	adds	r3, r2, r3
 800c5f4:	7fba      	ldrb	r2, [r7, #30]
 800c5f6:	701a      	strb	r2, [r3, #0]
 800c5f8:	693b      	ldr	r3, [r7, #16]
 800c5fa:	f103 0301 	add.w	r3, r3, #1
 800c5fe:	613b      	str	r3, [r7, #16]
		}
	}
 800c600:	e78f      	b.n	800c522 <create_name+0xd2>
	*path = &p[si];						/* Return pointer to the next segment */
 800c602:	68fa      	ldr	r2, [r7, #12]
 800c604:	697b      	ldr	r3, [r7, #20]
 800c606:	18d2      	adds	r2, r2, r3
 800c608:	683b      	ldr	r3, [r7, #0]
 800c60a:	601a      	str	r2, [r3, #0]
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 800c60c:	7fbb      	ldrb	r3, [r7, #30]
 800c60e:	2b20      	cmp	r3, #32
 800c610:	d802      	bhi.n	800c618 <create_name+0x1c8>
 800c612:	f04f 0304 	mov.w	r3, #4
 800c616:	e001      	b.n	800c61c <create_name+0x1cc>
 800c618:	f04f 0300 	mov.w	r3, #0
 800c61c:	77bb      	strb	r3, [r7, #30]

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 800c61e:	693b      	ldr	r3, [r7, #16]
 800c620:	2b00      	cmp	r3, #0
 800c622:	d102      	bne.n	800c62a <create_name+0x1da>
 800c624:	f04f 0306 	mov.w	r3, #6
 800c628:	e027      	b.n	800c67a <create_name+0x22a>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
 800c62a:	68bb      	ldr	r3, [r7, #8]
 800c62c:	781b      	ldrb	r3, [r3, #0]
 800c62e:	2be5      	cmp	r3, #229	; 0xe5
 800c630:	d103      	bne.n	800c63a <create_name+0x1ea>
 800c632:	68bb      	ldr	r3, [r7, #8]
 800c634:	f04f 0205 	mov.w	r2, #5
 800c638:	701a      	strb	r2, [r3, #0]

	if (ni == 8) b <<= 2;
 800c63a:	69bb      	ldr	r3, [r7, #24]
 800c63c:	2b08      	cmp	r3, #8
 800c63e:	d103      	bne.n	800c648 <create_name+0x1f8>
 800c640:	7ffb      	ldrb	r3, [r7, #31]
 800c642:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800c646:	77fb      	strb	r3, [r7, #31]
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 800c648:	7ffb      	ldrb	r3, [r7, #31]
 800c64a:	f003 0303 	and.w	r3, r3, #3
 800c64e:	2b01      	cmp	r3, #1
 800c650:	d103      	bne.n	800c65a <create_name+0x20a>
 800c652:	7fbb      	ldrb	r3, [r7, #30]
 800c654:	f043 0310 	orr.w	r3, r3, #16
 800c658:	77bb      	strb	r3, [r7, #30]
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 800c65a:	7ffb      	ldrb	r3, [r7, #31]
 800c65c:	f003 030c 	and.w	r3, r3, #12
 800c660:	2b04      	cmp	r3, #4
 800c662:	d103      	bne.n	800c66c <create_name+0x21c>
 800c664:	7fbb      	ldrb	r3, [r7, #30]
 800c666:	f043 0308 	orr.w	r3, r3, #8
 800c66a:	77bb      	strb	r3, [r7, #30]

	sfn[NS] = c;		/* Store NT flag, File name is created */
 800c66c:	68bb      	ldr	r3, [r7, #8]
 800c66e:	f103 030b 	add.w	r3, r3, #11
 800c672:	7fba      	ldrb	r2, [r7, #30]
 800c674:	701a      	strb	r2, [r3, #0]

	return FR_OK;
 800c676:	f04f 0300 	mov.w	r3, #0
#endif
}
 800c67a:	4618      	mov	r0, r3
 800c67c:	f107 0720 	add.w	r7, r7, #32
 800c680:	46bd      	mov	sp, r7
 800c682:	bd80      	pop	{r7, pc}

0800c684 <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
 800c684:	b480      	push	{r7}
 800c686:	b089      	sub	sp, #36	; 0x24
 800c688:	af00      	add	r7, sp, #0
 800c68a:	6078      	str	r0, [r7, #4]
 800c68c:	6039      	str	r1, [r7, #0]
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
 800c68e:	683b      	ldr	r3, [r7, #0]
 800c690:	f103 0309 	add.w	r3, r3, #9
 800c694:	61bb      	str	r3, [r7, #24]
	if (dj->sect) {
 800c696:	687b      	ldr	r3, [r7, #4]
 800c698:	691b      	ldr	r3, [r3, #16]
 800c69a:	2b00      	cmp	r3, #0
 800c69c:	f000 8091 	beq.w	800c7c2 <get_fileinfo+0x13e>
		dir = dj->dir;
 800c6a0:	687b      	ldr	r3, [r7, #4]
 800c6a2:	695b      	ldr	r3, [r3, #20]
 800c6a4:	613b      	str	r3, [r7, #16]
		nt = dir[DIR_NTres];		/* NT flag */
 800c6a6:	693b      	ldr	r3, [r7, #16]
 800c6a8:	7b1b      	ldrb	r3, [r3, #12]
 800c6aa:	73fb      	strb	r3, [r7, #15]
		for (i = 0; i < 8; i++) {	/* Copy name body */
 800c6ac:	f04f 0300 	mov.w	r3, #0
 800c6b0:	61fb      	str	r3, [r7, #28]
 800c6b2:	e018      	b.n	800c6e6 <get_fileinfo+0x62>
			c = dir[i];
 800c6b4:	693a      	ldr	r2, [r7, #16]
 800c6b6:	69fb      	ldr	r3, [r7, #28]
 800c6b8:	18d3      	adds	r3, r2, r3
 800c6ba:	781b      	ldrb	r3, [r3, #0]
 800c6bc:	75fb      	strb	r3, [r7, #23]
			if (c == ' ') break;
 800c6be:	7dfb      	ldrb	r3, [r7, #23]
 800c6c0:	2b20      	cmp	r3, #32
 800c6c2:	d014      	beq.n	800c6ee <get_fileinfo+0x6a>
			if (c == NDDE) c = (TCHAR)DDE;
 800c6c4:	7dfb      	ldrb	r3, [r7, #23]
 800c6c6:	2b05      	cmp	r3, #5
 800c6c8:	d102      	bne.n	800c6d0 <get_fileinfo+0x4c>
 800c6ca:	f04f 03e5 	mov.w	r3, #229	; 0xe5
 800c6ce:	75fb      	strb	r3, [r7, #23]
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
 800c6d0:	69bb      	ldr	r3, [r7, #24]
 800c6d2:	7dfa      	ldrb	r2, [r7, #23]
 800c6d4:	701a      	strb	r2, [r3, #0]
 800c6d6:	69bb      	ldr	r3, [r7, #24]
 800c6d8:	f103 0301 	add.w	r3, r3, #1
 800c6dc:	61bb      	str	r3, [r7, #24]

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
 800c6de:	69fb      	ldr	r3, [r7, #28]
 800c6e0:	f103 0301 	add.w	r3, r3, #1
 800c6e4:	61fb      	str	r3, [r7, #28]
 800c6e6:	69fb      	ldr	r3, [r7, #28]
 800c6e8:	2b07      	cmp	r3, #7
 800c6ea:	d9e3      	bls.n	800c6b4 <get_fileinfo+0x30>
 800c6ec:	e000      	b.n	800c6f0 <get_fileinfo+0x6c>
			c = dir[i];
			if (c == ' ') break;
 800c6ee:	bf00      	nop
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
 800c6f0:	693b      	ldr	r3, [r7, #16]
 800c6f2:	f103 0308 	add.w	r3, r3, #8
 800c6f6:	781b      	ldrb	r3, [r3, #0]
 800c6f8:	2b20      	cmp	r3, #32
 800c6fa:	d023      	beq.n	800c744 <get_fileinfo+0xc0>
			*p++ = '.';
 800c6fc:	69bb      	ldr	r3, [r7, #24]
 800c6fe:	f04f 022e 	mov.w	r2, #46	; 0x2e
 800c702:	701a      	strb	r2, [r3, #0]
 800c704:	69bb      	ldr	r3, [r7, #24]
 800c706:	f103 0301 	add.w	r3, r3, #1
 800c70a:	61bb      	str	r3, [r7, #24]
			for (i = 8; i < 11; i++) {
 800c70c:	f04f 0308 	mov.w	r3, #8
 800c710:	61fb      	str	r3, [r7, #28]
 800c712:	e012      	b.n	800c73a <get_fileinfo+0xb6>
				c = dir[i];
 800c714:	693a      	ldr	r2, [r7, #16]
 800c716:	69fb      	ldr	r3, [r7, #28]
 800c718:	18d3      	adds	r3, r2, r3
 800c71a:	781b      	ldrb	r3, [r3, #0]
 800c71c:	75fb      	strb	r3, [r7, #23]
				if (c == ' ') break;
 800c71e:	7dfb      	ldrb	r3, [r7, #23]
 800c720:	2b20      	cmp	r3, #32
 800c722:	d00e      	beq.n	800c742 <get_fileinfo+0xbe>
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
 800c724:	69bb      	ldr	r3, [r7, #24]
 800c726:	7dfa      	ldrb	r2, [r7, #23]
 800c728:	701a      	strb	r2, [r3, #0]
 800c72a:	69bb      	ldr	r3, [r7, #24]
 800c72c:	f103 0301 	add.w	r3, r3, #1
 800c730:	61bb      	str	r3, [r7, #24]
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
 800c732:	69fb      	ldr	r3, [r7, #28]
 800c734:	f103 0301 	add.w	r3, r3, #1
 800c738:	61fb      	str	r3, [r7, #28]
 800c73a:	69fb      	ldr	r3, [r7, #28]
 800c73c:	2b0a      	cmp	r3, #10
 800c73e:	d9e9      	bls.n	800c714 <get_fileinfo+0x90>
 800c740:	e000      	b.n	800c744 <get_fileinfo+0xc0>
				c = dir[i];
				if (c == ' ') break;
 800c742:	bf00      	nop
				if (!c) c = '?';
#endif
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 800c744:	693b      	ldr	r3, [r7, #16]
 800c746:	7ada      	ldrb	r2, [r3, #11]
 800c748:	683b      	ldr	r3, [r7, #0]
 800c74a:	721a      	strb	r2, [r3, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 800c74c:	693b      	ldr	r3, [r7, #16]
 800c74e:	f103 031f 	add.w	r3, r3, #31
 800c752:	781b      	ldrb	r3, [r3, #0]
 800c754:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800c758:	693b      	ldr	r3, [r7, #16]
 800c75a:	f103 031e 	add.w	r3, r3, #30
 800c75e:	781b      	ldrb	r3, [r3, #0]
 800c760:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800c764:	431a      	orrs	r2, r3
 800c766:	693b      	ldr	r3, [r7, #16]
 800c768:	f103 031d 	add.w	r3, r3, #29
 800c76c:	781b      	ldrb	r3, [r3, #0]
 800c76e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c772:	431a      	orrs	r2, r3
 800c774:	693b      	ldr	r3, [r7, #16]
 800c776:	f103 031c 	add.w	r3, r3, #28
 800c77a:	781b      	ldrb	r3, [r3, #0]
 800c77c:	431a      	orrs	r2, r3
 800c77e:	683b      	ldr	r3, [r7, #0]
 800c780:	601a      	str	r2, [r3, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 800c782:	693b      	ldr	r3, [r7, #16]
 800c784:	f103 0319 	add.w	r3, r3, #25
 800c788:	781b      	ldrb	r3, [r3, #0]
 800c78a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c78e:	b29a      	uxth	r2, r3
 800c790:	693b      	ldr	r3, [r7, #16]
 800c792:	f103 0318 	add.w	r3, r3, #24
 800c796:	781b      	ldrb	r3, [r3, #0]
 800c798:	4313      	orrs	r3, r2
 800c79a:	b29b      	uxth	r3, r3
 800c79c:	b29a      	uxth	r2, r3
 800c79e:	683b      	ldr	r3, [r7, #0]
 800c7a0:	809a      	strh	r2, [r3, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 800c7a2:	693b      	ldr	r3, [r7, #16]
 800c7a4:	f103 0317 	add.w	r3, r3, #23
 800c7a8:	781b      	ldrb	r3, [r3, #0]
 800c7aa:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c7ae:	b29a      	uxth	r2, r3
 800c7b0:	693b      	ldr	r3, [r7, #16]
 800c7b2:	f103 0316 	add.w	r3, r3, #22
 800c7b6:	781b      	ldrb	r3, [r3, #0]
 800c7b8:	4313      	orrs	r3, r2
 800c7ba:	b29b      	uxth	r3, r3
 800c7bc:	b29a      	uxth	r2, r3
 800c7be:	683b      	ldr	r3, [r7, #0]
 800c7c0:	80da      	strh	r2, [r3, #6]
	}
	*p = 0;		/* Terminate SFN str by a \0 */
 800c7c2:	69bb      	ldr	r3, [r7, #24]
 800c7c4:	f04f 0200 	mov.w	r2, #0
 800c7c8:	701a      	strb	r2, [r3, #0]
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
	}
#endif
}
 800c7ca:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800c7ce:	46bd      	mov	sp, r7
 800c7d0:	bc80      	pop	{r7}
 800c7d2:	4770      	bx	lr

0800c7d4 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
 800c7d4:	b580      	push	{r7, lr}
 800c7d6:	b084      	sub	sp, #16
 800c7d8:	af00      	add	r7, sp, #0
 800c7da:	6078      	str	r0, [r7, #4]
 800c7dc:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE *dir, ns;


#if _FS_RPATH
	if (*path == '/' || *path == '\\') { /* There is a heading separator */
 800c7de:	683b      	ldr	r3, [r7, #0]
 800c7e0:	781b      	ldrb	r3, [r3, #0]
 800c7e2:	2b2f      	cmp	r3, #47	; 0x2f
 800c7e4:	d003      	beq.n	800c7ee <follow_path+0x1a>
 800c7e6:	683b      	ldr	r3, [r7, #0]
 800c7e8:	781b      	ldrb	r3, [r3, #0]
 800c7ea:	2b5c      	cmp	r3, #92	; 0x5c
 800c7ec:	d108      	bne.n	800c800 <follow_path+0x2c>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
 800c7ee:	683b      	ldr	r3, [r7, #0]
 800c7f0:	f103 0301 	add.w	r3, r3, #1
 800c7f4:	603b      	str	r3, [r7, #0]
 800c7f6:	687b      	ldr	r3, [r7, #4]
 800c7f8:	f04f 0200 	mov.w	r2, #0
 800c7fc:	609a      	str	r2, [r3, #8]
 800c7fe:	e004      	b.n	800c80a <follow_path+0x36>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
 800c800:	687b      	ldr	r3, [r7, #4]
 800c802:	681b      	ldr	r3, [r3, #0]
 800c804:	699a      	ldr	r2, [r3, #24]
 800c806:	687b      	ldr	r3, [r7, #4]
 800c808:	609a      	str	r2, [r3, #8]
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
 800c80a:	683b      	ldr	r3, [r7, #0]
 800c80c:	781b      	ldrb	r3, [r3, #0]
 800c80e:	2b1f      	cmp	r3, #31
 800c810:	d80b      	bhi.n	800c82a <follow_path+0x56>
		res = dir_sdi(dj, 0);
 800c812:	6878      	ldr	r0, [r7, #4]
 800c814:	f04f 0100 	mov.w	r1, #0
 800c818:	f7ff fb72 	bl	800bf00 <dir_sdi>
 800c81c:	4603      	mov	r3, r0
 800c81e:	73fb      	strb	r3, [r7, #15]
		dj->dir = 0;
 800c820:	687b      	ldr	r3, [r7, #4]
 800c822:	f04f 0200 	mov.w	r2, #0
 800c826:	615a      	str	r2, [r3, #20]
 800c828:	e075      	b.n	800c916 <follow_path+0x142>

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
 800c82a:	463b      	mov	r3, r7
 800c82c:	6878      	ldr	r0, [r7, #4]
 800c82e:	4619      	mov	r1, r3
 800c830:	f7ff fe0e 	bl	800c450 <create_name>
 800c834:	4603      	mov	r3, r0
 800c836:	73fb      	strb	r3, [r7, #15]
			if (res != FR_OK) break;
 800c838:	7bfb      	ldrb	r3, [r7, #15]
 800c83a:	2b00      	cmp	r3, #0
 800c83c:	d164      	bne.n	800c908 <follow_path+0x134>
			res = dir_find(dj);				/* Find it */
 800c83e:	6878      	ldr	r0, [r7, #4]
 800c840:	f7ff fcdc 	bl	800c1fc <dir_find>
 800c844:	4603      	mov	r3, r0
 800c846:	73fb      	strb	r3, [r7, #15]
			ns = *(dj->fn+NS);
 800c848:	687b      	ldr	r3, [r7, #4]
 800c84a:	699b      	ldr	r3, [r3, #24]
 800c84c:	7adb      	ldrb	r3, [r3, #11]
 800c84e:	73bb      	strb	r3, [r7, #14]
			if (res != FR_OK) {				/* Failed to find the object */
 800c850:	7bfb      	ldrb	r3, [r7, #15]
 800c852:	2b00      	cmp	r3, #0
 800c854:	d021      	beq.n	800c89a <follow_path+0xc6>
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
 800c856:	7bfb      	ldrb	r3, [r7, #15]
 800c858:	2b04      	cmp	r3, #4
 800c85a:	d157      	bne.n	800c90c <follow_path+0x138>
				/* Object not found */
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
 800c85c:	7bbb      	ldrb	r3, [r7, #14]
 800c85e:	f003 0320 	and.w	r3, r3, #32
 800c862:	2b00      	cmp	r3, #0
 800c864:	d010      	beq.n	800c888 <follow_path+0xb4>
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
 800c866:	687b      	ldr	r3, [r7, #4]
 800c868:	f04f 0200 	mov.w	r2, #0
 800c86c:	609a      	str	r2, [r3, #8]
 800c86e:	687b      	ldr	r3, [r7, #4]
 800c870:	f04f 0200 	mov.w	r2, #0
 800c874:	615a      	str	r2, [r3, #20]
					res = FR_OK;
 800c876:	f04f 0300 	mov.w	r3, #0
 800c87a:	73fb      	strb	r3, [r7, #15]
					if (!(ns & NS_LAST)) continue;
 800c87c:	7bbb      	ldrb	r3, [r7, #14]
 800c87e:	f003 0304 	and.w	r3, r3, #4
 800c882:	2b00      	cmp	r3, #0
 800c884:	d144      	bne.n	800c910 <follow_path+0x13c>
 800c886:	e03e      	b.n	800c906 <follow_path+0x132>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
 800c888:	7bbb      	ldrb	r3, [r7, #14]
 800c88a:	f003 0304 	and.w	r3, r3, #4
 800c88e:	2b00      	cmp	r3, #0
 800c890:	d13e      	bne.n	800c910 <follow_path+0x13c>
 800c892:	f04f 0305 	mov.w	r3, #5
 800c896:	73fb      	strb	r3, [r7, #15]
				}
				break;
 800c898:	e03a      	b.n	800c910 <follow_path+0x13c>
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
 800c89a:	7bbb      	ldrb	r3, [r7, #14]
 800c89c:	f003 0304 	and.w	r3, r3, #4
 800c8a0:	2b00      	cmp	r3, #0
 800c8a2:	d137      	bne.n	800c914 <follow_path+0x140>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
 800c8a4:	687b      	ldr	r3, [r7, #4]
 800c8a6:	695b      	ldr	r3, [r3, #20]
 800c8a8:	60bb      	str	r3, [r7, #8]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
 800c8aa:	68bb      	ldr	r3, [r7, #8]
 800c8ac:	f103 030b 	add.w	r3, r3, #11
 800c8b0:	781b      	ldrb	r3, [r3, #0]
 800c8b2:	f003 0310 	and.w	r3, r3, #16
 800c8b6:	2b00      	cmp	r3, #0
 800c8b8:	d103      	bne.n	800c8c2 <follow_path+0xee>
				res = FR_NO_PATH; break;
 800c8ba:	f04f 0305 	mov.w	r3, #5
 800c8be:	73fb      	strb	r3, [r7, #15]
 800c8c0:	e029      	b.n	800c916 <follow_path+0x142>
			}
			dj->sclust = LD_CLUST(dir);
 800c8c2:	68bb      	ldr	r3, [r7, #8]
 800c8c4:	f103 0315 	add.w	r3, r3, #21
 800c8c8:	781b      	ldrb	r3, [r3, #0]
 800c8ca:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c8ce:	b29a      	uxth	r2, r3
 800c8d0:	68bb      	ldr	r3, [r7, #8]
 800c8d2:	f103 0314 	add.w	r3, r3, #20
 800c8d6:	781b      	ldrb	r3, [r3, #0]
 800c8d8:	4313      	orrs	r3, r2
 800c8da:	b29b      	uxth	r3, r3
 800c8dc:	b29b      	uxth	r3, r3
 800c8de:	ea4f 4203 	mov.w	r2, r3, lsl #16
 800c8e2:	68bb      	ldr	r3, [r7, #8]
 800c8e4:	f103 031b 	add.w	r3, r3, #27
 800c8e8:	781b      	ldrb	r3, [r3, #0]
 800c8ea:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c8ee:	b299      	uxth	r1, r3
 800c8f0:	68bb      	ldr	r3, [r7, #8]
 800c8f2:	f103 031a 	add.w	r3, r3, #26
 800c8f6:	781b      	ldrb	r3, [r3, #0]
 800c8f8:	430b      	orrs	r3, r1
 800c8fa:	b29b      	uxth	r3, r3
 800c8fc:	b29b      	uxth	r3, r3
 800c8fe:	431a      	orrs	r2, r3
 800c900:	687b      	ldr	r3, [r7, #4]
 800c902:	609a      	str	r2, [r3, #8]
		}
 800c904:	e791      	b.n	800c82a <follow_path+0x56>
 800c906:	e790      	b.n	800c82a <follow_path+0x56>
		dj->dir = 0;

	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
 800c908:	bf00      	nop
 800c90a:	e004      	b.n	800c916 <follow_path+0x142>
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
 800c90c:	bf00      	nop
 800c90e:	e002      	b.n	800c916 <follow_path+0x142>
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
 800c910:	bf00      	nop
 800c912:	e000      	b.n	800c916 <follow_path+0x142>
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
 800c914:	bf00      	nop
			}
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
 800c916:	7bfb      	ldrb	r3, [r7, #15]
}
 800c918:	4618      	mov	r0, r3
 800c91a:	f107 0710 	add.w	r7, r7, #16
 800c91e:	46bd      	mov	sp, r7
 800c920:	bd80      	pop	{r7, pc}
 800c922:	bf00      	nop

0800c924 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 800c924:	b580      	push	{r7, lr}
 800c926:	b082      	sub	sp, #8
 800c928:	af00      	add	r7, sp, #0
 800c92a:	6078      	str	r0, [r7, #4]
 800c92c:	6039      	str	r1, [r7, #0]
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 800c92e:	687b      	ldr	r3, [r7, #4]
 800c930:	785a      	ldrb	r2, [r3, #1]
 800c932:	687b      	ldr	r3, [r7, #4]
 800c934:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800c938:	4610      	mov	r0, r2
 800c93a:	4619      	mov	r1, r3
 800c93c:	683a      	ldr	r2, [r7, #0]
 800c93e:	f04f 0301 	mov.w	r3, #1
 800c942:	f7fe fcdd 	bl	800b300 <disk_read>
 800c946:	4603      	mov	r3, r0
 800c948:	2b00      	cmp	r3, #0
 800c94a:	d002      	beq.n	800c952 <check_fs+0x2e>
		return 3;
 800c94c:	f04f 0303 	mov.w	r3, #3
 800c950:	e056      	b.n	800ca00 <check_fs+0xdc>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 800c952:	687b      	ldr	r3, [r7, #4]
 800c954:	f893 3233 	ldrb.w	r3, [r3, #563]	; 0x233
 800c958:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c95c:	b29a      	uxth	r2, r3
 800c95e:	687b      	ldr	r3, [r7, #4]
 800c960:	f893 3232 	ldrb.w	r3, [r3, #562]	; 0x232
 800c964:	4313      	orrs	r3, r2
 800c966:	b29b      	uxth	r3, r3
 800c968:	b21a      	sxth	r2, r3
 800c96a:	f64a 2355 	movw	r3, #43605	; 0xaa55
 800c96e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800c972:	429a      	cmp	r2, r3
 800c974:	d002      	beq.n	800c97c <check_fs+0x58>
		return 2;
 800c976:	f04f 0302 	mov.w	r3, #2
 800c97a:	e041      	b.n	800ca00 <check_fs+0xdc>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 800c97c:	687b      	ldr	r3, [r7, #4]
 800c97e:	f893 306d 	ldrb.w	r3, [r3, #109]	; 0x6d
 800c982:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800c986:	687b      	ldr	r3, [r7, #4]
 800c988:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
 800c98c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800c990:	431a      	orrs	r2, r3
 800c992:	687b      	ldr	r3, [r7, #4]
 800c994:	f893 306b 	ldrb.w	r3, [r3, #107]	; 0x6b
 800c998:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c99c:	431a      	orrs	r2, r3
 800c99e:	687b      	ldr	r3, [r7, #4]
 800c9a0:	f893 306a 	ldrb.w	r3, [r3, #106]	; 0x6a
 800c9a4:	4313      	orrs	r3, r2
 800c9a6:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
 800c9aa:	f244 1346 	movw	r3, #16710	; 0x4146
 800c9ae:	f2c0 0354 	movt	r3, #84	; 0x54
 800c9b2:	429a      	cmp	r2, r3
 800c9b4:	d102      	bne.n	800c9bc <check_fs+0x98>
		return 0;
 800c9b6:	f04f 0300 	mov.w	r3, #0
 800c9ba:	e021      	b.n	800ca00 <check_fs+0xdc>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
 800c9bc:	687b      	ldr	r3, [r7, #4]
 800c9be:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
 800c9c2:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800c9c6:	687b      	ldr	r3, [r7, #4]
 800c9c8:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
 800c9cc:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800c9d0:	431a      	orrs	r2, r3
 800c9d2:	687b      	ldr	r3, [r7, #4]
 800c9d4:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
 800c9d8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800c9dc:	431a      	orrs	r2, r3
 800c9de:	687b      	ldr	r3, [r7, #4]
 800c9e0:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
 800c9e4:	4313      	orrs	r3, r2
 800c9e6:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
 800c9ea:	f244 1346 	movw	r3, #16710	; 0x4146
 800c9ee:	f2c0 0354 	movt	r3, #84	; 0x54
 800c9f2:	429a      	cmp	r2, r3
 800c9f4:	d102      	bne.n	800c9fc <check_fs+0xd8>
		return 0;
 800c9f6:	f04f 0300 	mov.w	r3, #0
 800c9fa:	e001      	b.n	800ca00 <check_fs+0xdc>

	return 1;
 800c9fc:	f04f 0301 	mov.w	r3, #1
}
 800ca00:	4618      	mov	r0, r3
 800ca02:	f107 0708 	add.w	r7, r7, #8
 800ca06:	46bd      	mov	sp, r7
 800ca08:	bd80      	pop	{r7, pc}
 800ca0a:	bf00      	nop

0800ca0c <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
 800ca0c:	b580      	push	{r7, lr}
 800ca0e:	b092      	sub	sp, #72	; 0x48
 800ca10:	af00      	add	r7, sp, #0
 800ca12:	60f8      	str	r0, [r7, #12]
 800ca14:	60b9      	str	r1, [r7, #8]
 800ca16:	4613      	mov	r3, r2
 800ca18:	71fb      	strb	r3, [r7, #7]
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
 800ca1a:	68fb      	ldr	r3, [r7, #12]
 800ca1c:	681b      	ldr	r3, [r3, #0]
 800ca1e:	62fb      	str	r3, [r7, #44]	; 0x2c
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
 800ca20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ca22:	781b      	ldrb	r3, [r3, #0]
 800ca24:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800ca28:	643b      	str	r3, [r7, #64]	; 0x40
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 800ca2a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ca2c:	2b09      	cmp	r3, #9
 800ca2e:	d80d      	bhi.n	800ca4c <chk_mounted+0x40>
 800ca30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ca32:	f103 0301 	add.w	r3, r3, #1
 800ca36:	781b      	ldrb	r3, [r3, #0]
 800ca38:	2b3a      	cmp	r3, #58	; 0x3a
 800ca3a:	d107      	bne.n	800ca4c <chk_mounted+0x40>
		p += 2; *path = p;				/* Return pointer to the path name */
 800ca3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ca3e:	f103 0302 	add.w	r3, r3, #2
 800ca42:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ca44:	68fb      	ldr	r3, [r7, #12]
 800ca46:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ca48:	601a      	str	r2, [r3, #0]
 800ca4a:	e005      	b.n	800ca58 <chk_mounted+0x4c>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
 800ca4c:	f640 53da 	movw	r3, #3546	; 0xdda
 800ca50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca54:	781b      	ldrb	r3, [r3, #0]
 800ca56:	643b      	str	r3, [r7, #64]	; 0x40
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 800ca58:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ca5a:	2b01      	cmp	r3, #1
 800ca5c:	d902      	bls.n	800ca64 <chk_mounted+0x58>
		return FR_INVALID_DRIVE;
 800ca5e:	f04f 030b 	mov.w	r3, #11
 800ca62:	e2d3      	b.n	800d00c <chk_mounted+0x600>
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
 800ca64:	f640 53d0 	movw	r3, #3536	; 0xdd0
 800ca68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca6c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ca6e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ca72:	62bb      	str	r3, [r7, #40]	; 0x28
 800ca74:	68bb      	ldr	r3, [r7, #8]
 800ca76:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800ca78:	601a      	str	r2, [r3, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800ca7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ca7c:	2b00      	cmp	r3, #0
 800ca7e:	d102      	bne.n	800ca86 <chk_mounted+0x7a>
 800ca80:	f04f 030c 	mov.w	r3, #12
 800ca84:	e2c2      	b.n	800d00c <chk_mounted+0x600>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
 800ca86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ca88:	781b      	ldrb	r3, [r3, #0]
 800ca8a:	2b00      	cmp	r3, #0
 800ca8c:	d01c      	beq.n	800cac8 <chk_mounted+0xbc>
		stat = disk_status(fs->drv);
 800ca8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ca90:	785b      	ldrb	r3, [r3, #1]
 800ca92:	4618      	mov	r0, r3
 800ca94:	f7fe fc08 	bl	800b2a8 <disk_status>
 800ca98:	4603      	mov	r3, r0
 800ca9a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 800ca9e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800caa2:	f003 0301 	and.w	r3, r3, #1
 800caa6:	2b00      	cmp	r3, #0
 800caa8:	d10e      	bne.n	800cac8 <chk_mounted+0xbc>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
 800caaa:	79fb      	ldrb	r3, [r7, #7]
 800caac:	2b00      	cmp	r3, #0
 800caae:	d008      	beq.n	800cac2 <chk_mounted+0xb6>
 800cab0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800cab4:	f003 0304 	and.w	r3, r3, #4
 800cab8:	2b00      	cmp	r3, #0
 800caba:	d002      	beq.n	800cac2 <chk_mounted+0xb6>
				return FR_WRITE_PROTECTED;
 800cabc:	f04f 030a 	mov.w	r3, #10
 800cac0:	e2a4      	b.n	800d00c <chk_mounted+0x600>
			return FR_OK;				/* The file system object is valid */
 800cac2:	f04f 0300 	mov.w	r3, #0
 800cac6:	e2a1      	b.n	800d00c <chk_mounted+0x600>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 800cac8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800caca:	f04f 0200 	mov.w	r2, #0
 800cace:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800cad0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800cad2:	b2da      	uxtb	r2, r3
 800cad4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cad6:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
 800cad8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cada:	785b      	ldrb	r3, [r3, #1]
 800cadc:	4618      	mov	r0, r3
 800cade:	f7fe fbb7 	bl	800b250 <disk_initialize>
 800cae2:	4603      	mov	r3, r0
 800cae4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 800cae8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800caec:	f003 0301 	and.w	r3, r3, #1
 800caf0:	2b00      	cmp	r3, #0
 800caf2:	d002      	beq.n	800cafa <chk_mounted+0xee>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
 800caf4:	f04f 0303 	mov.w	r3, #3
 800caf8:	e288      	b.n	800d00c <chk_mounted+0x600>
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 800cafa:	79fb      	ldrb	r3, [r7, #7]
 800cafc:	2b00      	cmp	r3, #0
 800cafe:	d008      	beq.n	800cb12 <chk_mounted+0x106>
 800cb00:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800cb04:	f003 0304 	and.w	r3, r3, #4
 800cb08:	2b00      	cmp	r3, #0
 800cb0a:	d002      	beq.n	800cb12 <chk_mounted+0x106>
		return FR_WRITE_PROTECTED;
 800cb0c:	f04f 030a 	mov.w	r3, #10
 800cb10:	e27c      	b.n	800d00c <chk_mounted+0x600>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 800cb12:	f04f 0300 	mov.w	r3, #0
 800cb16:	63fb      	str	r3, [r7, #60]	; 0x3c
 800cb18:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800cb1a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800cb1c:	f7ff ff02 	bl	800c924 <check_fs>
 800cb20:	4603      	mov	r3, r0
 800cb22:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
 800cb26:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800cb2a:	2b01      	cmp	r3, #1
 800cb2c:	d141      	bne.n	800cbb2 <chk_mounted+0x1a6>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
 800cb2e:	f04f 0300 	mov.w	r3, #0
 800cb32:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
		if (pi) pi--;
 800cb36:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800cb3a:	2b00      	cmp	r3, #0
 800cb3c:	d005      	beq.n	800cb4a <chk_mounted+0x13e>
 800cb3e:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800cb42:	f103 33ff 	add.w	r3, r3, #4294967295
 800cb46:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
 800cb4a:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800cb4e:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800cb52:	f503 73df 	add.w	r3, r3, #446	; 0x1be
 800cb56:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800cb5a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800cb5c:	18d3      	adds	r3, r2, r3
 800cb5e:	f103 0304 	add.w	r3, r3, #4
 800cb62:	623b      	str	r3, [r7, #32]
		if (tbl[4]) {						/* Is the partition existing? */
 800cb64:	6a3b      	ldr	r3, [r7, #32]
 800cb66:	f103 0304 	add.w	r3, r3, #4
 800cb6a:	781b      	ldrb	r3, [r3, #0]
 800cb6c:	2b00      	cmp	r3, #0
 800cb6e:	d020      	beq.n	800cbb2 <chk_mounted+0x1a6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 800cb70:	6a3b      	ldr	r3, [r7, #32]
 800cb72:	f103 030b 	add.w	r3, r3, #11
 800cb76:	781b      	ldrb	r3, [r3, #0]
 800cb78:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800cb7c:	6a3b      	ldr	r3, [r7, #32]
 800cb7e:	f103 030a 	add.w	r3, r3, #10
 800cb82:	781b      	ldrb	r3, [r3, #0]
 800cb84:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800cb88:	431a      	orrs	r2, r3
 800cb8a:	6a3b      	ldr	r3, [r7, #32]
 800cb8c:	f103 0309 	add.w	r3, r3, #9
 800cb90:	781b      	ldrb	r3, [r3, #0]
 800cb92:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cb96:	431a      	orrs	r2, r3
 800cb98:	6a3b      	ldr	r3, [r7, #32]
 800cb9a:	f103 0308 	add.w	r3, r3, #8
 800cb9e:	781b      	ldrb	r3, [r3, #0]
 800cba0:	4313      	orrs	r3, r2
 800cba2:	63fb      	str	r3, [r7, #60]	; 0x3c
			fmt = check_fs(fs, bsect);		/* Check the partition */
 800cba4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800cba6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800cba8:	f7ff febc 	bl	800c924 <check_fs>
 800cbac:	4603      	mov	r3, r0
 800cbae:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
 800cbb2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800cbb6:	2b03      	cmp	r3, #3
 800cbb8:	d102      	bne.n	800cbc0 <chk_mounted+0x1b4>
 800cbba:	f04f 0301 	mov.w	r3, #1
 800cbbe:	e225      	b.n	800d00c <chk_mounted+0x600>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 800cbc0:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800cbc4:	2b00      	cmp	r3, #0
 800cbc6:	d002      	beq.n	800cbce <chk_mounted+0x1c2>
 800cbc8:	f04f 030d 	mov.w	r3, #13
 800cbcc:	e21e      	b.n	800d00c <chk_mounted+0x600>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 800cbce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cbd0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800cbd4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cbd8:	b29a      	uxth	r2, r3
 800cbda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cbdc:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 800cbe0:	4313      	orrs	r3, r2
 800cbe2:	b29b      	uxth	r3, r3
 800cbe4:	b21b      	sxth	r3, r3
 800cbe6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800cbea:	d002      	beq.n	800cbf2 <chk_mounted+0x1e6>
		return FR_NO_FILESYSTEM;
 800cbec:	f04f 030d 	mov.w	r3, #13
 800cbf0:	e20c      	b.n	800d00c <chk_mounted+0x600>

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 800cbf2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cbf4:	f893 304b 	ldrb.w	r3, [r3, #75]	; 0x4b
 800cbf8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cbfc:	b29a      	uxth	r2, r3
 800cbfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc00:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 800cc04:	4313      	orrs	r3, r2
 800cc06:	b29b      	uxth	r3, r3
 800cc08:	b29b      	uxth	r3, r3
 800cc0a:	63bb      	str	r3, [r7, #56]	; 0x38
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 800cc0c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cc0e:	2b00      	cmp	r3, #0
 800cc10:	d115      	bne.n	800cc3e <chk_mounted+0x232>
 800cc12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc14:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 800cc18:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800cc1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc1e:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
 800cc22:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800cc26:	431a      	orrs	r2, r3
 800cc28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc2a:	f893 3059 	ldrb.w	r3, [r3, #89]	; 0x59
 800cc2e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cc32:	431a      	orrs	r2, r3
 800cc34:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc36:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 800cc3a:	4313      	orrs	r3, r2
 800cc3c:	63bb      	str	r3, [r7, #56]	; 0x38
	fs->fsize = fasize;
 800cc3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc40:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800cc42:	621a      	str	r2, [r3, #32]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 800cc44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc46:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800cc4a:	77fb      	strb	r3, [r7, #31]
 800cc4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc4e:	7ffa      	ldrb	r2, [r7, #31]
 800cc50:	70da      	strb	r2, [r3, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 800cc52:	7ffb      	ldrb	r3, [r7, #31]
 800cc54:	2b01      	cmp	r3, #1
 800cc56:	d005      	beq.n	800cc64 <chk_mounted+0x258>
 800cc58:	7ffb      	ldrb	r3, [r7, #31]
 800cc5a:	2b02      	cmp	r3, #2
 800cc5c:	d002      	beq.n	800cc64 <chk_mounted+0x258>
 800cc5e:	f04f 030d 	mov.w	r3, #13
 800cc62:	e1d3      	b.n	800d00c <chk_mounted+0x600>
	fasize *= b;										/* Number of sectors for FAT area */
 800cc64:	7ffa      	ldrb	r2, [r7, #31]
 800cc66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cc68:	fb02 f303 	mul.w	r3, r2, r3
 800cc6c:	63bb      	str	r3, [r7, #56]	; 0x38

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 800cc6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc70:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800cc74:	77fb      	strb	r3, [r7, #31]
 800cc76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc78:	7ffa      	ldrb	r2, [r7, #31]
 800cc7a:	709a      	strb	r2, [r3, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 800cc7c:	7ffb      	ldrb	r3, [r7, #31]
 800cc7e:	2b00      	cmp	r3, #0
 800cc80:	d006      	beq.n	800cc90 <chk_mounted+0x284>
 800cc82:	7ffa      	ldrb	r2, [r7, #31]
 800cc84:	7ffb      	ldrb	r3, [r7, #31]
 800cc86:	f103 33ff 	add.w	r3, r3, #4294967295
 800cc8a:	4013      	ands	r3, r2
 800cc8c:	2b00      	cmp	r3, #0
 800cc8e:	d002      	beq.n	800cc96 <chk_mounted+0x28a>
 800cc90:	f04f 030d 	mov.w	r3, #13
 800cc94:	e1ba      	b.n	800d00c <chk_mounted+0x600>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 800cc96:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc98:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 800cc9c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cca0:	b29a      	uxth	r2, r3
 800cca2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cca4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800cca8:	4313      	orrs	r3, r2
 800ccaa:	b29b      	uxth	r3, r3
 800ccac:	b29a      	uxth	r2, r3
 800ccae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccb0:	811a      	strh	r2, [r3, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 800ccb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccb4:	891b      	ldrh	r3, [r3, #8]
 800ccb6:	f003 030f 	and.w	r3, r3, #15
 800ccba:	b29b      	uxth	r3, r3
 800ccbc:	2b00      	cmp	r3, #0
 800ccbe:	d002      	beq.n	800ccc6 <chk_mounted+0x2ba>
 800ccc0:	f04f 030d 	mov.w	r3, #13
 800ccc4:	e1a2      	b.n	800d00c <chk_mounted+0x600>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 800ccc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccc8:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 800cccc:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ccd0:	b29a      	uxth	r2, r3
 800ccd2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccd4:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
 800ccd8:	4313      	orrs	r3, r2
 800ccda:	b29b      	uxth	r3, r3
 800ccdc:	b29b      	uxth	r3, r3
 800ccde:	637b      	str	r3, [r7, #52]	; 0x34
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 800cce0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cce2:	2b00      	cmp	r3, #0
 800cce4:	d115      	bne.n	800cd12 <chk_mounted+0x306>
 800cce6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cce8:	f893 3057 	ldrb.w	r3, [r3, #87]	; 0x57
 800ccec:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800ccf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccf2:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 800ccf6:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800ccfa:	431a      	orrs	r2, r3
 800ccfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ccfe:	f893 3055 	ldrb.w	r3, [r3, #85]	; 0x55
 800cd02:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cd06:	431a      	orrs	r2, r3
 800cd08:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd0a:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800cd0e:	4313      	orrs	r3, r2
 800cd10:	637b      	str	r3, [r7, #52]	; 0x34

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 800cd12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd14:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 800cd18:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cd1c:	b29a      	uxth	r2, r3
 800cd1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd20:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 800cd24:	4313      	orrs	r3, r2
 800cd26:	b29b      	uxth	r3, r3
 800cd28:	83bb      	strh	r3, [r7, #28]
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 800cd2a:	8bbb      	ldrh	r3, [r7, #28]
 800cd2c:	2b00      	cmp	r3, #0
 800cd2e:	d102      	bne.n	800cd36 <chk_mounted+0x32a>
 800cd30:	f04f 030d 	mov.w	r3, #13
 800cd34:	e16a      	b.n	800d00c <chk_mounted+0x600>

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 800cd36:	8bba      	ldrh	r2, [r7, #28]
 800cd38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cd3a:	18d2      	adds	r2, r2, r3
 800cd3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd3e:	891b      	ldrh	r3, [r3, #8]
 800cd40:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800cd44:	b29b      	uxth	r3, r3
 800cd46:	18d3      	adds	r3, r2, r3
 800cd48:	61bb      	str	r3, [r7, #24]
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800cd4a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800cd4c:	69bb      	ldr	r3, [r7, #24]
 800cd4e:	429a      	cmp	r2, r3
 800cd50:	d202      	bcs.n	800cd58 <chk_mounted+0x34c>
 800cd52:	f04f 030d 	mov.w	r3, #13
 800cd56:	e159      	b.n	800d00c <chk_mounted+0x600>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 800cd58:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800cd5a:	69bb      	ldr	r3, [r7, #24]
 800cd5c:	1ad2      	subs	r2, r2, r3
 800cd5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd60:	789b      	ldrb	r3, [r3, #2]
 800cd62:	fbb2 f3f3 	udiv	r3, r2, r3
 800cd66:	617b      	str	r3, [r7, #20]
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 800cd68:	697b      	ldr	r3, [r7, #20]
 800cd6a:	2b00      	cmp	r3, #0
 800cd6c:	d102      	bne.n	800cd74 <chk_mounted+0x368>
 800cd6e:	f04f 030d 	mov.w	r3, #13
 800cd72:	e14b      	b.n	800d00c <chk_mounted+0x600>
	fmt = FS_FAT12;
 800cd74:	f04f 0301 	mov.w	r3, #1
 800cd78:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 800cd7c:	697a      	ldr	r2, [r7, #20]
 800cd7e:	f640 73f5 	movw	r3, #4085	; 0xff5
 800cd82:	429a      	cmp	r2, r3
 800cd84:	d903      	bls.n	800cd8e <chk_mounted+0x382>
 800cd86:	f04f 0302 	mov.w	r3, #2
 800cd8a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 800cd8e:	697a      	ldr	r2, [r7, #20]
 800cd90:	f64f 73f5 	movw	r3, #65525	; 0xfff5
 800cd94:	429a      	cmp	r2, r3
 800cd96:	d903      	bls.n	800cda0 <chk_mounted+0x394>
 800cd98:	f04f 0303 	mov.w	r3, #3
 800cd9c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 800cda0:	697b      	ldr	r3, [r7, #20]
 800cda2:	f103 0202 	add.w	r2, r3, #2
 800cda6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cda8:	61da      	str	r2, [r3, #28]
	fs->database = bsect + sysect;						/* Data start sector */
 800cdaa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800cdac:	69bb      	ldr	r3, [r7, #24]
 800cdae:	18d2      	adds	r2, r2, r3
 800cdb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cdb2:	62da      	str	r2, [r3, #44]	; 0x2c
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 800cdb4:	8bba      	ldrh	r2, [r7, #28]
 800cdb6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800cdb8:	18d2      	adds	r2, r2, r3
 800cdba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cdbc:	625a      	str	r2, [r3, #36]	; 0x24
	if (fmt == FS_FAT32) {
 800cdbe:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800cdc2:	2b03      	cmp	r3, #3
 800cdc4:	d123      	bne.n	800ce0e <chk_mounted+0x402>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 800cdc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cdc8:	891b      	ldrh	r3, [r3, #8]
 800cdca:	2b00      	cmp	r3, #0
 800cdcc:	d002      	beq.n	800cdd4 <chk_mounted+0x3c8>
 800cdce:	f04f 030d 	mov.w	r3, #13
 800cdd2:	e11b      	b.n	800d00c <chk_mounted+0x600>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 800cdd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cdd6:	f893 3063 	ldrb.w	r3, [r3, #99]	; 0x63
 800cdda:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800cdde:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cde0:	f893 3062 	ldrb.w	r3, [r3, #98]	; 0x62
 800cde4:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800cde8:	431a      	orrs	r2, r3
 800cdea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cdec:	f893 3061 	ldrb.w	r3, [r3, #97]	; 0x61
 800cdf0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cdf4:	431a      	orrs	r2, r3
 800cdf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cdf8:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800cdfc:	431a      	orrs	r2, r3
 800cdfe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce00:	629a      	str	r2, [r3, #40]	; 0x28
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 800ce02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce04:	69db      	ldr	r3, [r3, #28]
 800ce06:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800ce0a:	633b      	str	r3, [r7, #48]	; 0x30
 800ce0c:	e023      	b.n	800ce56 <chk_mounted+0x44a>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 800ce0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce10:	891b      	ldrh	r3, [r3, #8]
 800ce12:	2b00      	cmp	r3, #0
 800ce14:	d102      	bne.n	800ce1c <chk_mounted+0x410>
 800ce16:	f04f 030d 	mov.w	r3, #13
 800ce1a:	e0f7      	b.n	800d00c <chk_mounted+0x600>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800ce1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce1e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ce20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ce22:	18d2      	adds	r2, r2, r3
 800ce24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce26:	629a      	str	r2, [r3, #40]	; 0x28
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800ce28:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800ce2c:	2b02      	cmp	r3, #2
 800ce2e:	d104      	bne.n	800ce3a <chk_mounted+0x42e>
 800ce30:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce32:	69db      	ldr	r3, [r3, #28]
 800ce34:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800ce38:	e00c      	b.n	800ce54 <chk_mounted+0x448>
 800ce3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce3c:	69da      	ldr	r2, [r3, #28]
 800ce3e:	4613      	mov	r3, r2
 800ce40:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800ce44:	189b      	adds	r3, r3, r2
 800ce46:	ea4f 0253 	mov.w	r2, r3, lsr #1
 800ce4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce4c:	69db      	ldr	r3, [r3, #28]
 800ce4e:	f003 0301 	and.w	r3, r3, #1
 800ce52:	18d3      	adds	r3, r2, r3
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
 800ce54:	633b      	str	r3, [r7, #48]	; 0x30
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 800ce56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce58:	6a1a      	ldr	r2, [r3, #32]
 800ce5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ce5c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800ce60:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800ce64:	429a      	cmp	r2, r3
 800ce66:	d202      	bcs.n	800ce6e <chk_mounted+0x462>
		return FR_NO_FILESYSTEM;
 800ce68:	f04f 030d 	mov.w	r3, #13
 800ce6c:	e0ce      	b.n	800d00c <chk_mounted+0x600>

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
 800ce6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce70:	f04f 32ff 	mov.w	r2, #4294967295
 800ce74:	611a      	str	r2, [r3, #16]
	fs->last_clust = 0;
 800ce76:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce78:	f04f 0200 	mov.w	r2, #0
 800ce7c:	60da      	str	r2, [r3, #12]

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
 800ce7e:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800ce82:	2b03      	cmp	r3, #3
 800ce84:	f040 809c 	bne.w	800cfc0 <chk_mounted+0x5b4>
	 	fs->fsi_flag = 0;
 800ce88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce8a:	f04f 0200 	mov.w	r2, #0
 800ce8e:	715a      	strb	r2, [r3, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
 800ce90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce92:	f893 3065 	ldrb.w	r3, [r3, #101]	; 0x65
 800ce96:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800ce9a:	b29a      	uxth	r2, r3
 800ce9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ce9e:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 800cea2:	4313      	orrs	r3, r2
 800cea4:	b29b      	uxth	r3, r3
 800cea6:	b29b      	uxth	r3, r3
 800cea8:	461a      	mov	r2, r3
 800ceaa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ceac:	18d2      	adds	r2, r2, r3
 800ceae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ceb0:	615a      	str	r2, [r3, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 800ceb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ceb4:	7859      	ldrb	r1, [r3, #1]
 800ceb6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ceb8:	f103 0234 	add.w	r2, r3, #52	; 0x34
 800cebc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cebe:	695b      	ldr	r3, [r3, #20]
 800cec0:	4608      	mov	r0, r1
 800cec2:	4611      	mov	r1, r2
 800cec4:	461a      	mov	r2, r3
 800cec6:	f04f 0301 	mov.w	r3, #1
 800ceca:	f7fe fa19 	bl	800b300 <disk_read>
 800cece:	4603      	mov	r3, r0
 800ced0:	2b00      	cmp	r3, #0
 800ced2:	d175      	bne.n	800cfc0 <chk_mounted+0x5b4>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 800ced4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ced6:	f893 3233 	ldrb.w	r3, [r3, #563]	; 0x233
 800ceda:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cede:	b29a      	uxth	r2, r3
 800cee0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cee2:	f893 3232 	ldrb.w	r3, [r3, #562]	; 0x232
 800cee6:	4313      	orrs	r3, r2
 800cee8:	b29b      	uxth	r3, r3

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
 800ceea:	b21a      	sxth	r2, r3
 800ceec:	f64a 2355 	movw	r3, #43605	; 0xaa55
 800cef0:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800cef4:	429a      	cmp	r2, r3
 800cef6:	d163      	bne.n	800cfc0 <chk_mounted+0x5b4>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 800cef8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cefa:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 800cefe:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800cf02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf04:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 800cf08:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800cf0c:	431a      	orrs	r2, r3
 800cf0e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf10:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800cf14:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cf18:	431a      	orrs	r2, r3
 800cf1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf1c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800cf20:	431a      	orrs	r2, r3
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
 800cf22:	f245 2352 	movw	r3, #21074	; 0x5252
 800cf26:	f2c4 1361 	movt	r3, #16737	; 0x4161
 800cf2a:	429a      	cmp	r2, r3
 800cf2c:	d148      	bne.n	800cfc0 <chk_mounted+0x5b4>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
 800cf2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf30:	f893 321b 	ldrb.w	r3, [r3, #539]	; 0x21b
 800cf34:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800cf38:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf3a:	f893 321a 	ldrb.w	r3, [r3, #538]	; 0x21a
 800cf3e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800cf42:	431a      	orrs	r2, r3
 800cf44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf46:	f893 3219 	ldrb.w	r3, [r3, #537]	; 0x219
 800cf4a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cf4e:	431a      	orrs	r2, r3
 800cf50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf52:	f893 3218 	ldrb.w	r3, [r3, #536]	; 0x218
 800cf56:	431a      	orrs	r2, r3
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
 800cf58:	f247 2372 	movw	r3, #29298	; 0x7272
 800cf5c:	f2c6 1341 	movt	r3, #24897	; 0x6141
 800cf60:	429a      	cmp	r2, r3
 800cf62:	d12d      	bne.n	800cfc0 <chk_mounted+0x5b4>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 800cf64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf66:	f893 3223 	ldrb.w	r3, [r3, #547]	; 0x223
 800cf6a:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800cf6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf70:	f893 3222 	ldrb.w	r3, [r3, #546]	; 0x222
 800cf74:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800cf78:	431a      	orrs	r2, r3
 800cf7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf7c:	f893 3221 	ldrb.w	r3, [r3, #545]	; 0x221
 800cf80:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cf84:	431a      	orrs	r2, r3
 800cf86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf88:	f893 3220 	ldrb.w	r3, [r3, #544]	; 0x220
 800cf8c:	431a      	orrs	r2, r3
 800cf8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf90:	60da      	str	r2, [r3, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 800cf92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf94:	f893 321f 	ldrb.w	r3, [r3, #543]	; 0x21f
 800cf98:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800cf9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf9e:	f893 321e 	ldrb.w	r3, [r3, #542]	; 0x21e
 800cfa2:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800cfa6:	431a      	orrs	r2, r3
 800cfa8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cfaa:	f893 321d 	ldrb.w	r3, [r3, #541]	; 0x21d
 800cfae:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800cfb2:	431a      	orrs	r2, r3
 800cfb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cfb6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
 800cfba:	431a      	orrs	r2, r3
 800cfbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cfbe:	611a      	str	r2, [r3, #16]
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
 800cfc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cfc2:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 800cfc6:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 800cfc8:	f640 53d8 	movw	r3, #3544	; 0xdd8
 800cfcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cfd0:	881b      	ldrh	r3, [r3, #0]
 800cfd2:	f103 0301 	add.w	r3, r3, #1
 800cfd6:	b29a      	uxth	r2, r3
 800cfd8:	f640 53d8 	movw	r3, #3544	; 0xdd8
 800cfdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cfe0:	801a      	strh	r2, [r3, #0]
 800cfe2:	f640 53d8 	movw	r3, #3544	; 0xdd8
 800cfe6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cfea:	881a      	ldrh	r2, [r3, #0]
 800cfec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cfee:	80da      	strh	r2, [r3, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
 800cff0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cff2:	f04f 0200 	mov.w	r2, #0
 800cff6:	631a      	str	r2, [r3, #48]	; 0x30
	fs->wflag = 0;
 800cff8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cffa:	f04f 0200 	mov.w	r2, #0
 800cffe:	711a      	strb	r2, [r3, #4]
#if _FS_RPATH
	fs->cdir = 0;			/* Current directory (root dir) */
 800d000:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d002:	f04f 0200 	mov.w	r2, #0
 800d006:	619a      	str	r2, [r3, #24]
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
 800d008:	f04f 0300 	mov.w	r3, #0
}
 800d00c:	4618      	mov	r0, r3
 800d00e:	f107 0748 	add.w	r7, r7, #72	; 0x48
 800d012:	46bd      	mov	sp, r7
 800d014:	bd80      	pop	{r7, pc}
 800d016:	bf00      	nop

0800d018 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
 800d018:	b580      	push	{r7, lr}
 800d01a:	b082      	sub	sp, #8
 800d01c:	af00      	add	r7, sp, #0
 800d01e:	6078      	str	r0, [r7, #4]
 800d020:	460b      	mov	r3, r1
 800d022:	807b      	strh	r3, [r7, #2]
	if (!fs || !fs->fs_type || fs->id != id)
 800d024:	687b      	ldr	r3, [r7, #4]
 800d026:	2b00      	cmp	r3, #0
 800d028:	d008      	beq.n	800d03c <validate+0x24>
 800d02a:	687b      	ldr	r3, [r7, #4]
 800d02c:	781b      	ldrb	r3, [r3, #0]
 800d02e:	2b00      	cmp	r3, #0
 800d030:	d004      	beq.n	800d03c <validate+0x24>
 800d032:	687b      	ldr	r3, [r7, #4]
 800d034:	88db      	ldrh	r3, [r3, #6]
 800d036:	887a      	ldrh	r2, [r7, #2]
 800d038:	429a      	cmp	r2, r3
 800d03a:	d002      	beq.n	800d042 <validate+0x2a>
		return FR_INVALID_OBJECT;
 800d03c:	f04f 0309 	mov.w	r3, #9
 800d040:	e00e      	b.n	800d060 <validate+0x48>

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
 800d042:	687b      	ldr	r3, [r7, #4]
 800d044:	785b      	ldrb	r3, [r3, #1]
 800d046:	4618      	mov	r0, r3
 800d048:	f7fe f92e 	bl	800b2a8 <disk_status>
 800d04c:	4603      	mov	r3, r0
 800d04e:	f003 0301 	and.w	r3, r3, #1
 800d052:	2b00      	cmp	r3, #0
 800d054:	d002      	beq.n	800d05c <validate+0x44>
		return FR_NOT_READY;
 800d056:	f04f 0303 	mov.w	r3, #3
 800d05a:	e001      	b.n	800d060 <validate+0x48>

	return FR_OK;
 800d05c:	f04f 0300 	mov.w	r3, #0
}
 800d060:	4618      	mov	r0, r3
 800d062:	f107 0708 	add.w	r7, r7, #8
 800d066:	46bd      	mov	sp, r7
 800d068:	bd80      	pop	{r7, pc}
 800d06a:	bf00      	nop

0800d06c <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
 800d06c:	b480      	push	{r7}
 800d06e:	b085      	sub	sp, #20
 800d070:	af00      	add	r7, sp, #0
 800d072:	4603      	mov	r3, r0
 800d074:	6039      	str	r1, [r7, #0]
 800d076:	71fb      	strb	r3, [r7, #7]
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
 800d078:	79fb      	ldrb	r3, [r7, #7]
 800d07a:	2b01      	cmp	r3, #1
 800d07c:	d902      	bls.n	800d084 <f_mount+0x18>
		return FR_INVALID_DRIVE;
 800d07e:	f04f 030b 	mov.w	r3, #11
 800d082:	e01f      	b.n	800d0c4 <f_mount+0x58>
	rfs = FatFs[vol];			/* Get current fs object */
 800d084:	79fa      	ldrb	r2, [r7, #7]
 800d086:	f640 53d0 	movw	r3, #3536	; 0xdd0
 800d08a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d08e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d092:	60fb      	str	r3, [r7, #12]

	if (rfs) {
 800d094:	68fb      	ldr	r3, [r7, #12]
 800d096:	2b00      	cmp	r3, #0
 800d098:	d003      	beq.n	800d0a2 <f_mount+0x36>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
 800d09a:	68fb      	ldr	r3, [r7, #12]
 800d09c:	f04f 0200 	mov.w	r2, #0
 800d0a0:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
 800d0a2:	683b      	ldr	r3, [r7, #0]
 800d0a4:	2b00      	cmp	r3, #0
 800d0a6:	d003      	beq.n	800d0b0 <f_mount+0x44>
		fs->fs_type = 0;		/* Clear new fs object */
 800d0a8:	683b      	ldr	r3, [r7, #0]
 800d0aa:	f04f 0200 	mov.w	r2, #0
 800d0ae:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
 800d0b0:	79fa      	ldrb	r2, [r7, #7]
 800d0b2:	f640 53d0 	movw	r3, #3536	; 0xdd0
 800d0b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d0ba:	6839      	ldr	r1, [r7, #0]
 800d0bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	return FR_OK;
 800d0c0:	f04f 0300 	mov.w	r3, #0
}
 800d0c4:	4618      	mov	r0, r3
 800d0c6:	f107 0714 	add.w	r7, r7, #20
 800d0ca:	46bd      	mov	sp, r7
 800d0cc:	bc80      	pop	{r7}
 800d0ce:	4770      	bx	lr

0800d0d0 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 800d0d0:	b580      	push	{r7, lr}
 800d0d2:	b092      	sub	sp, #72	; 0x48
 800d0d4:	af00      	add	r7, sp, #0
 800d0d6:	60f8      	str	r0, [r7, #12]
 800d0d8:	60b9      	str	r1, [r7, #8]
 800d0da:	4613      	mov	r3, r2
 800d0dc:	71fb      	strb	r3, [r7, #7]
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
 800d0de:	68fb      	ldr	r3, [r7, #12]
 800d0e0:	f04f 0200 	mov.w	r2, #0
 800d0e4:	601a      	str	r2, [r3, #0]

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 800d0e6:	79fb      	ldrb	r3, [r7, #7]
 800d0e8:	f003 031f 	and.w	r3, r3, #31
 800d0ec:	71fb      	strb	r3, [r7, #7]
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
 800d0ee:	79fb      	ldrb	r3, [r7, #7]
 800d0f0:	f023 0301 	bic.w	r3, r3, #1
 800d0f4:	b2db      	uxtb	r3, r3
 800d0f6:	f107 0108 	add.w	r1, r7, #8
 800d0fa:	f107 021c 	add.w	r2, r7, #28
 800d0fe:	4608      	mov	r0, r1
 800d100:	4611      	mov	r1, r2
 800d102:	461a      	mov	r2, r3
 800d104:	f7ff fc82 	bl	800ca0c <chk_mounted>
 800d108:	4603      	mov	r3, r0
 800d10a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
 800d10e:	f107 0310 	add.w	r3, r7, #16
 800d112:	637b      	str	r3, [r7, #52]	; 0x34
	if (res == FR_OK)
 800d114:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d118:	2b00      	cmp	r3, #0
 800d11a:	d109      	bne.n	800d130 <f_open+0x60>
		res = follow_path(&dj, path);	/* Follow the file path */
 800d11c:	68bb      	ldr	r3, [r7, #8]
 800d11e:	f107 021c 	add.w	r2, r7, #28
 800d122:	4610      	mov	r0, r2
 800d124:	4619      	mov	r1, r3
 800d126:	f7ff fb55 	bl	800c7d4 <follow_path>
 800d12a:	4603      	mov	r3, r0
 800d12c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	dir = dj.dir;
 800d130:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d132:	643b      	str	r3, [r7, #64]	; 0x40

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
 800d134:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d138:	2b00      	cmp	r3, #0
 800d13a:	d106      	bne.n	800d14a <f_open+0x7a>
		if (!dir)	/* Current dir itself */
 800d13c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d13e:	2b00      	cmp	r3, #0
 800d140:	d103      	bne.n	800d14a <f_open+0x7a>
			res = FR_INVALID_NAME;
 800d142:	f04f 0306 	mov.w	r3, #6
 800d146:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800d14a:	79fb      	ldrb	r3, [r7, #7]
 800d14c:	f003 031c 	and.w	r3, r3, #28
 800d150:	2b00      	cmp	r3, #0
 800d152:	f000 80d5 	beq.w	800d300 <f_open+0x230>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
 800d156:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d15a:	2b00      	cmp	r3, #0
 800d15c:	d012      	beq.n	800d184 <f_open+0xb4>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 800d15e:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d162:	2b04      	cmp	r3, #4
 800d164:	d107      	bne.n	800d176 <f_open+0xa6>
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
				res = dir_register(&dj);
 800d166:	f107 031c 	add.w	r3, r7, #28
 800d16a:	4618      	mov	r0, r3
 800d16c:	f7ff f8e6 	bl	800c33c <dir_register>
 800d170:	4603      	mov	r3, r0
 800d172:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
 800d176:	79fb      	ldrb	r3, [r7, #7]
 800d178:	f043 0308 	orr.w	r3, r3, #8
 800d17c:	71fb      	strb	r3, [r7, #7]
			dir = dj.dir;					/* New entry */
 800d17e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d180:	643b      	str	r3, [r7, #64]	; 0x40
 800d182:	e015      	b.n	800d1b0 <f_open+0xe0>
		}
		else {								/* Any object is already existing */
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 800d184:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d186:	f103 030b 	add.w	r3, r3, #11
 800d18a:	781b      	ldrb	r3, [r3, #0]
 800d18c:	f003 0311 	and.w	r3, r3, #17
 800d190:	2b00      	cmp	r3, #0
 800d192:	d004      	beq.n	800d19e <f_open+0xce>
				res = FR_DENIED;
 800d194:	f04f 0307 	mov.w	r3, #7
 800d198:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800d19c:	e008      	b.n	800d1b0 <f_open+0xe0>
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 800d19e:	79fb      	ldrb	r3, [r7, #7]
 800d1a0:	f003 0304 	and.w	r3, r3, #4
 800d1a4:	2b00      	cmp	r3, #0
 800d1a6:	d003      	beq.n	800d1b0 <f_open+0xe0>
					res = FR_EXIST;
 800d1a8:	f04f 0308 	mov.w	r3, #8
 800d1ac:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 800d1b0:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d1b4:	2b00      	cmp	r3, #0
 800d1b6:	f040 80c5 	bne.w	800d344 <f_open+0x274>
 800d1ba:	79fb      	ldrb	r3, [r7, #7]
 800d1bc:	f003 0308 	and.w	r3, r3, #8
 800d1c0:	2b00      	cmp	r3, #0
 800d1c2:	f000 80bf 	beq.w	800d344 <f_open+0x274>
			dw = get_fattime();					/* Created time */
 800d1c6:	f7fe f959 	bl	800b47c <get_fattime>
 800d1ca:	63f8      	str	r0, [r7, #60]	; 0x3c
			ST_DWORD(dir+DIR_CrtTime, dw);
 800d1cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d1ce:	f103 030e 	add.w	r3, r3, #14
 800d1d2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d1d4:	b2d2      	uxtb	r2, r2
 800d1d6:	701a      	strb	r2, [r3, #0]
 800d1d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d1da:	f103 030f 	add.w	r3, r3, #15
 800d1de:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d1e0:	b292      	uxth	r2, r2
 800d1e2:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800d1e6:	b292      	uxth	r2, r2
 800d1e8:	b2d2      	uxtb	r2, r2
 800d1ea:	701a      	strb	r2, [r3, #0]
 800d1ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d1ee:	f103 0310 	add.w	r3, r3, #16
 800d1f2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d1f4:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800d1f8:	b2d2      	uxtb	r2, r2
 800d1fa:	701a      	strb	r2, [r3, #0]
 800d1fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d1fe:	f103 0311 	add.w	r3, r3, #17
 800d202:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d204:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800d208:	b2d2      	uxtb	r2, r2
 800d20a:	701a      	strb	r2, [r3, #0]
			dir[DIR_Attr] = 0;					/* Reset attribute */
 800d20c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d20e:	f103 030b 	add.w	r3, r3, #11
 800d212:	f04f 0200 	mov.w	r2, #0
 800d216:	701a      	strb	r2, [r3, #0]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
 800d218:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d21a:	f103 031c 	add.w	r3, r3, #28
 800d21e:	f04f 0200 	mov.w	r2, #0
 800d222:	701a      	strb	r2, [r3, #0]
 800d224:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d226:	f103 031d 	add.w	r3, r3, #29
 800d22a:	f04f 0200 	mov.w	r2, #0
 800d22e:	701a      	strb	r2, [r3, #0]
 800d230:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d232:	f103 031e 	add.w	r3, r3, #30
 800d236:	f04f 0200 	mov.w	r2, #0
 800d23a:	701a      	strb	r2, [r3, #0]
 800d23c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d23e:	f103 031f 	add.w	r3, r3, #31
 800d242:	f04f 0200 	mov.w	r2, #0
 800d246:	701a      	strb	r2, [r3, #0]
			cl = LD_CLUST(dir);					/* Get start cluster */
 800d248:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d24a:	f103 0315 	add.w	r3, r3, #21
 800d24e:	781b      	ldrb	r3, [r3, #0]
 800d250:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d254:	b29a      	uxth	r2, r3
 800d256:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d258:	f103 0314 	add.w	r3, r3, #20
 800d25c:	781b      	ldrb	r3, [r3, #0]
 800d25e:	4313      	orrs	r3, r2
 800d260:	b29b      	uxth	r3, r3
 800d262:	b29b      	uxth	r3, r3
 800d264:	ea4f 4203 	mov.w	r2, r3, lsl #16
 800d268:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d26a:	f103 031b 	add.w	r3, r3, #27
 800d26e:	781b      	ldrb	r3, [r3, #0]
 800d270:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d274:	b299      	uxth	r1, r3
 800d276:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d278:	f103 031a 	add.w	r3, r3, #26
 800d27c:	781b      	ldrb	r3, [r3, #0]
 800d27e:	430b      	orrs	r3, r1
 800d280:	b29b      	uxth	r3, r3
 800d282:	b29b      	uxth	r3, r3
 800d284:	4313      	orrs	r3, r2
 800d286:	63bb      	str	r3, [r7, #56]	; 0x38
			ST_CLUST(dir, 0);					/* cluster = 0 */
 800d288:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d28a:	f103 031a 	add.w	r3, r3, #26
 800d28e:	f04f 0200 	mov.w	r2, #0
 800d292:	701a      	strb	r2, [r3, #0]
 800d294:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d296:	f103 031b 	add.w	r3, r3, #27
 800d29a:	f04f 0200 	mov.w	r2, #0
 800d29e:	701a      	strb	r2, [r3, #0]
 800d2a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d2a2:	f103 0314 	add.w	r3, r3, #20
 800d2a6:	f04f 0200 	mov.w	r2, #0
 800d2aa:	701a      	strb	r2, [r3, #0]
 800d2ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d2ae:	f103 0315 	add.w	r3, r3, #21
 800d2b2:	f04f 0200 	mov.w	r2, #0
 800d2b6:	701a      	strb	r2, [r3, #0]
			dj.fs->wflag = 1;
 800d2b8:	69fb      	ldr	r3, [r7, #28]
 800d2ba:	f04f 0201 	mov.w	r2, #1
 800d2be:	711a      	strb	r2, [r3, #4]
			if (cl) {							/* Remove the cluster chain if exist */
 800d2c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d2c2:	2b00      	cmp	r3, #0
 800d2c4:	d03e      	beq.n	800d344 <f_open+0x274>
				dw = dj.fs->winsect;
 800d2c6:	69fb      	ldr	r3, [r7, #28]
 800d2c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d2ca:	63fb      	str	r3, [r7, #60]	; 0x3c
				res = remove_chain(dj.fs, cl);
 800d2cc:	69fb      	ldr	r3, [r7, #28]
 800d2ce:	4618      	mov	r0, r3
 800d2d0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800d2d2:	f7fe fcfb 	bl	800bccc <remove_chain>
 800d2d6:	4603      	mov	r3, r0
 800d2d8:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
				if (res == FR_OK) {
 800d2dc:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d2e0:	2b00      	cmp	r3, #0
 800d2e2:	d12f      	bne.n	800d344 <f_open+0x274>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 800d2e4:	69fb      	ldr	r3, [r7, #28]
 800d2e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800d2e8:	f102 32ff 	add.w	r2, r2, #4294967295
 800d2ec:	60da      	str	r2, [r3, #12]
					res = move_window(dj.fs, dw);
 800d2ee:	69fb      	ldr	r3, [r7, #28]
 800d2f0:	4618      	mov	r0, r3
 800d2f2:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800d2f4:	f7fe f998 	bl	800b628 <move_window>
 800d2f8:	4603      	mov	r3, r0
 800d2fa:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800d2fe:	e021      	b.n	800d344 <f_open+0x274>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
 800d300:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d304:	2b00      	cmp	r3, #0
 800d306:	d11d      	bne.n	800d344 <f_open+0x274>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
 800d308:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d30a:	f103 030b 	add.w	r3, r3, #11
 800d30e:	781b      	ldrb	r3, [r3, #0]
 800d310:	f003 0310 	and.w	r3, r3, #16
 800d314:	2b00      	cmp	r3, #0
 800d316:	d004      	beq.n	800d322 <f_open+0x252>
				res = FR_NO_FILE;
 800d318:	f04f 0304 	mov.w	r3, #4
 800d31c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800d320:	e010      	b.n	800d344 <f_open+0x274>
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 800d322:	79fb      	ldrb	r3, [r7, #7]
 800d324:	f003 0302 	and.w	r3, r3, #2
 800d328:	2b00      	cmp	r3, #0
 800d32a:	d00b      	beq.n	800d344 <f_open+0x274>
 800d32c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d32e:	f103 030b 	add.w	r3, r3, #11
 800d332:	781b      	ldrb	r3, [r3, #0]
 800d334:	f003 0301 	and.w	r3, r3, #1
 800d338:	2b00      	cmp	r3, #0
 800d33a:	d003      	beq.n	800d344 <f_open+0x274>
					res = FR_DENIED;
 800d33c:	f04f 0307 	mov.w	r3, #7
 800d340:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			}
		}
	}
	if (res == FR_OK) {
 800d344:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d348:	2b00      	cmp	r3, #0
 800d34a:	d10f      	bne.n	800d36c <f_open+0x29c>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
 800d34c:	79fb      	ldrb	r3, [r7, #7]
 800d34e:	f003 0308 	and.w	r3, r3, #8
 800d352:	2b00      	cmp	r3, #0
 800d354:	d003      	beq.n	800d35e <f_open+0x28e>
			mode |= FA__WRITTEN;
 800d356:	79fb      	ldrb	r3, [r7, #7]
 800d358:	f043 0320 	orr.w	r3, r3, #32
 800d35c:	71fb      	strb	r3, [r7, #7]
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
 800d35e:	69fb      	ldr	r3, [r7, #28]
 800d360:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800d362:	68fb      	ldr	r3, [r7, #12]
 800d364:	61da      	str	r2, [r3, #28]
		fp->dir_ptr = dir;
 800d366:	68fb      	ldr	r3, [r7, #12]
 800d368:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800d36a:	621a      	str	r2, [r3, #32]
		}
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
 800d36c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800d370:	2b00      	cmp	r3, #0
 800d372:	d14d      	bne.n	800d410 <f_open+0x340>
		fp->flag = mode;					/* File access mode */
 800d374:	68fb      	ldr	r3, [r7, #12]
 800d376:	79fa      	ldrb	r2, [r7, #7]
 800d378:	719a      	strb	r2, [r3, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
 800d37a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d37c:	f103 0315 	add.w	r3, r3, #21
 800d380:	781b      	ldrb	r3, [r3, #0]
 800d382:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d386:	b29a      	uxth	r2, r3
 800d388:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d38a:	f103 0314 	add.w	r3, r3, #20
 800d38e:	781b      	ldrb	r3, [r3, #0]
 800d390:	4313      	orrs	r3, r2
 800d392:	b29b      	uxth	r3, r3
 800d394:	b29b      	uxth	r3, r3
 800d396:	ea4f 4203 	mov.w	r2, r3, lsl #16
 800d39a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d39c:	f103 031b 	add.w	r3, r3, #27
 800d3a0:	781b      	ldrb	r3, [r3, #0]
 800d3a2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d3a6:	b299      	uxth	r1, r3
 800d3a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d3aa:	f103 031a 	add.w	r3, r3, #26
 800d3ae:	781b      	ldrb	r3, [r3, #0]
 800d3b0:	430b      	orrs	r3, r1
 800d3b2:	b29b      	uxth	r3, r3
 800d3b4:	b29b      	uxth	r3, r3
 800d3b6:	431a      	orrs	r2, r3
 800d3b8:	68fb      	ldr	r3, [r7, #12]
 800d3ba:	611a      	str	r2, [r3, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 800d3bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d3be:	f103 031f 	add.w	r3, r3, #31
 800d3c2:	781b      	ldrb	r3, [r3, #0]
 800d3c4:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800d3c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d3ca:	f103 031e 	add.w	r3, r3, #30
 800d3ce:	781b      	ldrb	r3, [r3, #0]
 800d3d0:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800d3d4:	431a      	orrs	r2, r3
 800d3d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d3d8:	f103 031d 	add.w	r3, r3, #29
 800d3dc:	781b      	ldrb	r3, [r3, #0]
 800d3de:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d3e2:	431a      	orrs	r2, r3
 800d3e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d3e6:	f103 031c 	add.w	r3, r3, #28
 800d3ea:	781b      	ldrb	r3, [r3, #0]
 800d3ec:	431a      	orrs	r2, r3
 800d3ee:	68fb      	ldr	r3, [r7, #12]
 800d3f0:	60da      	str	r2, [r3, #12]
		fp->fptr = 0;						/* File pointer */
 800d3f2:	68fb      	ldr	r3, [r7, #12]
 800d3f4:	f04f 0200 	mov.w	r2, #0
 800d3f8:	609a      	str	r2, [r3, #8]
		fp->dsect = 0;
 800d3fa:	68fb      	ldr	r3, [r7, #12]
 800d3fc:	f04f 0200 	mov.w	r2, #0
 800d400:	619a      	str	r2, [r3, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 800d402:	69fa      	ldr	r2, [r7, #28]
 800d404:	68fb      	ldr	r3, [r7, #12]
 800d406:	601a      	str	r2, [r3, #0]
 800d408:	69fb      	ldr	r3, [r7, #28]
 800d40a:	88da      	ldrh	r2, [r3, #6]
 800d40c:	68fb      	ldr	r3, [r7, #12]
 800d40e:	809a      	strh	r2, [r3, #4]
	}

	LEAVE_FF(dj.fs, res);
 800d410:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 800d414:	4618      	mov	r0, r3
 800d416:	f107 0748 	add.w	r7, r7, #72	; 0x48
 800d41a:	46bd      	mov	sp, r7
 800d41c:	bd80      	pop	{r7, pc}
 800d41e:	bf00      	nop

0800d420 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 800d420:	b580      	push	{r7, lr}
 800d422:	b08c      	sub	sp, #48	; 0x30
 800d424:	af00      	add	r7, sp, #0
 800d426:	60f8      	str	r0, [r7, #12]
 800d428:	60b9      	str	r1, [r7, #8]
 800d42a:	607a      	str	r2, [r7, #4]
 800d42c:	603b      	str	r3, [r7, #0]
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;
 800d42e:	68bb      	ldr	r3, [r7, #8]
 800d430:	623b      	str	r3, [r7, #32]


	*br = 0;	/* Initialize byte counter */
 800d432:	683b      	ldr	r3, [r7, #0]
 800d434:	f04f 0200 	mov.w	r2, #0
 800d438:	601a      	str	r2, [r3, #0]

	res = validate(fp->fs, fp->id);				/* Check validity */
 800d43a:	68fb      	ldr	r3, [r7, #12]
 800d43c:	681a      	ldr	r2, [r3, #0]
 800d43e:	68fb      	ldr	r3, [r7, #12]
 800d440:	889b      	ldrh	r3, [r3, #4]
 800d442:	4610      	mov	r0, r2
 800d444:	4619      	mov	r1, r3
 800d446:	f7ff fde7 	bl	800d018 <validate>
 800d44a:	4603      	mov	r3, r0
 800d44c:	77fb      	strb	r3, [r7, #31]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 800d44e:	7ffb      	ldrb	r3, [r7, #31]
 800d450:	2b00      	cmp	r3, #0
 800d452:	d001      	beq.n	800d458 <f_read+0x38>
 800d454:	7ffb      	ldrb	r3, [r7, #31]
 800d456:	e156      	b.n	800d706 <f_read+0x2e6>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
 800d458:	68fb      	ldr	r3, [r7, #12]
 800d45a:	799b      	ldrb	r3, [r3, #6]
 800d45c:	b2db      	uxtb	r3, r3
 800d45e:	b25b      	sxtb	r3, r3
 800d460:	2b00      	cmp	r3, #0
 800d462:	da02      	bge.n	800d46a <f_read+0x4a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
 800d464:	f04f 0302 	mov.w	r3, #2
 800d468:	e14d      	b.n	800d706 <f_read+0x2e6>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 800d46a:	68fb      	ldr	r3, [r7, #12]
 800d46c:	799b      	ldrb	r3, [r3, #6]
 800d46e:	f003 0301 	and.w	r3, r3, #1
 800d472:	2b00      	cmp	r3, #0
 800d474:	d102      	bne.n	800d47c <f_read+0x5c>
		LEAVE_FF(fp->fs, FR_DENIED);
 800d476:	f04f 0307 	mov.w	r3, #7
 800d47a:	e144      	b.n	800d706 <f_read+0x2e6>
	remain = fp->fsize - fp->fptr;
 800d47c:	68fb      	ldr	r3, [r7, #12]
 800d47e:	68da      	ldr	r2, [r3, #12]
 800d480:	68fb      	ldr	r3, [r7, #12]
 800d482:	689b      	ldr	r3, [r3, #8]
 800d484:	1ad3      	subs	r3, r2, r3
 800d486:	61bb      	str	r3, [r7, #24]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 800d488:	687a      	ldr	r2, [r7, #4]
 800d48a:	69bb      	ldr	r3, [r7, #24]
 800d48c:	429a      	cmp	r2, r3
 800d48e:	f240 8134 	bls.w	800d6fa <f_read+0x2da>
 800d492:	69bb      	ldr	r3, [r7, #24]
 800d494:	607b      	str	r3, [r7, #4]

	for ( ;  btr;								/* Repeat until all data read */
 800d496:	e130      	b.n	800d6fa <f_read+0x2da>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 800d498:	68fb      	ldr	r3, [r7, #12]
 800d49a:	689b      	ldr	r3, [r3, #8]
 800d49c:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800d4a0:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800d4a4:	2b00      	cmp	r3, #0
 800d4a6:	f040 80f4 	bne.w	800d692 <f_read+0x272>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 800d4aa:	68fb      	ldr	r3, [r7, #12]
 800d4ac:	689b      	ldr	r3, [r3, #8]
 800d4ae:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800d4b2:	b2da      	uxtb	r2, r3
 800d4b4:	68fb      	ldr	r3, [r7, #12]
 800d4b6:	681b      	ldr	r3, [r3, #0]
 800d4b8:	789b      	ldrb	r3, [r3, #2]
 800d4ba:	f103 33ff 	add.w	r3, r3, #4294967295
 800d4be:	b2db      	uxtb	r3, r3
 800d4c0:	4013      	ands	r3, r2
 800d4c2:	75fb      	strb	r3, [r7, #23]
			if (!csect) {						/* On the cluster boundary? */
 800d4c4:	7dfb      	ldrb	r3, [r7, #23]
 800d4c6:	2b00      	cmp	r3, #0
 800d4c8:	d12e      	bne.n	800d528 <f_read+0x108>
				if (fp->fptr == 0) {			/* On the top of the file? */
 800d4ca:	68fb      	ldr	r3, [r7, #12]
 800d4cc:	689b      	ldr	r3, [r3, #8]
 800d4ce:	2b00      	cmp	r3, #0
 800d4d0:	d103      	bne.n	800d4da <f_read+0xba>
					clst = fp->sclust;			/* Follow from the origin */
 800d4d2:	68fb      	ldr	r3, [r7, #12]
 800d4d4:	691b      	ldr	r3, [r3, #16]
 800d4d6:	62fb      	str	r3, [r7, #44]	; 0x2c
 800d4d8:	e008      	b.n	800d4ec <f_read+0xcc>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
 800d4da:	68fb      	ldr	r3, [r7, #12]
 800d4dc:	681a      	ldr	r2, [r3, #0]
 800d4de:	68fb      	ldr	r3, [r7, #12]
 800d4e0:	695b      	ldr	r3, [r3, #20]
 800d4e2:	4610      	mov	r0, r2
 800d4e4:	4619      	mov	r1, r3
 800d4e6:	f7fe f9eb 	bl	800b8c0 <get_fat>
 800d4ea:	62f8      	str	r0, [r7, #44]	; 0x2c
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 800d4ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d4ee:	2b01      	cmp	r3, #1
 800d4f0:	d809      	bhi.n	800d506 <f_read+0xe6>
 800d4f2:	68fb      	ldr	r3, [r7, #12]
 800d4f4:	799b      	ldrb	r3, [r3, #6]
 800d4f6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d4fa:	b2da      	uxtb	r2, r3
 800d4fc:	68fb      	ldr	r3, [r7, #12]
 800d4fe:	719a      	strb	r2, [r3, #6]
 800d500:	f04f 0302 	mov.w	r3, #2
 800d504:	e0ff      	b.n	800d706 <f_read+0x2e6>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 800d506:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d508:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d50c:	d109      	bne.n	800d522 <f_read+0x102>
 800d50e:	68fb      	ldr	r3, [r7, #12]
 800d510:	799b      	ldrb	r3, [r3, #6]
 800d512:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d516:	b2da      	uxtb	r2, r3
 800d518:	68fb      	ldr	r3, [r7, #12]
 800d51a:	719a      	strb	r2, [r3, #6]
 800d51c:	f04f 0301 	mov.w	r3, #1
 800d520:	e0f1      	b.n	800d706 <f_read+0x2e6>
				fp->clust = clst;				/* Update current cluster */
 800d522:	68fb      	ldr	r3, [r7, #12]
 800d524:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d526:	615a      	str	r2, [r3, #20]
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 800d528:	68fb      	ldr	r3, [r7, #12]
 800d52a:	681a      	ldr	r2, [r3, #0]
 800d52c:	68fb      	ldr	r3, [r7, #12]
 800d52e:	695b      	ldr	r3, [r3, #20]
 800d530:	4610      	mov	r0, r2
 800d532:	4619      	mov	r1, r3
 800d534:	f7fe f9a2 	bl	800b87c <clust2sect>
 800d538:	6138      	str	r0, [r7, #16]
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 800d53a:	693b      	ldr	r3, [r7, #16]
 800d53c:	2b00      	cmp	r3, #0
 800d53e:	d109      	bne.n	800d554 <f_read+0x134>
 800d540:	68fb      	ldr	r3, [r7, #12]
 800d542:	799b      	ldrb	r3, [r3, #6]
 800d544:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d548:	b2da      	uxtb	r2, r3
 800d54a:	68fb      	ldr	r3, [r7, #12]
 800d54c:	719a      	strb	r2, [r3, #6]
 800d54e:	f04f 0302 	mov.w	r3, #2
 800d552:	e0d8      	b.n	800d706 <f_read+0x2e6>
			sect += csect;
 800d554:	7dfb      	ldrb	r3, [r7, #23]
 800d556:	693a      	ldr	r2, [r7, #16]
 800d558:	18d3      	adds	r3, r2, r3
 800d55a:	613b      	str	r3, [r7, #16]
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
 800d55c:	687b      	ldr	r3, [r7, #4]
 800d55e:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800d562:	627b      	str	r3, [r7, #36]	; 0x24
			if (cc) {							/* Read maximum contiguous sectors directly */
 800d564:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d566:	2b00      	cmp	r3, #0
 800d568:	d048      	beq.n	800d5fc <f_read+0x1dc>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 800d56a:	7dfa      	ldrb	r2, [r7, #23]
 800d56c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d56e:	18d2      	adds	r2, r2, r3
 800d570:	68fb      	ldr	r3, [r7, #12]
 800d572:	681b      	ldr	r3, [r3, #0]
 800d574:	789b      	ldrb	r3, [r3, #2]
 800d576:	429a      	cmp	r2, r3
 800d578:	d906      	bls.n	800d588 <f_read+0x168>
					cc = fp->fs->csize - csect;
 800d57a:	68fb      	ldr	r3, [r7, #12]
 800d57c:	681b      	ldr	r3, [r3, #0]
 800d57e:	789b      	ldrb	r3, [r3, #2]
 800d580:	461a      	mov	r2, r3
 800d582:	7dfb      	ldrb	r3, [r7, #23]
 800d584:	1ad3      	subs	r3, r2, r3
 800d586:	627b      	str	r3, [r7, #36]	; 0x24
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
 800d588:	68fb      	ldr	r3, [r7, #12]
 800d58a:	681b      	ldr	r3, [r3, #0]
 800d58c:	785a      	ldrb	r2, [r3, #1]
 800d58e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d590:	b2db      	uxtb	r3, r3
 800d592:	4610      	mov	r0, r2
 800d594:	6a39      	ldr	r1, [r7, #32]
 800d596:	693a      	ldr	r2, [r7, #16]
 800d598:	f7fd feb2 	bl	800b300 <disk_read>
 800d59c:	4603      	mov	r3, r0
 800d59e:	2b00      	cmp	r3, #0
 800d5a0:	d009      	beq.n	800d5b6 <f_read+0x196>
					ABORT(fp->fs, FR_DISK_ERR);
 800d5a2:	68fb      	ldr	r3, [r7, #12]
 800d5a4:	799b      	ldrb	r3, [r3, #6]
 800d5a6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d5aa:	b2da      	uxtb	r2, r3
 800d5ac:	68fb      	ldr	r3, [r7, #12]
 800d5ae:	719a      	strb	r2, [r3, #6]
 800d5b0:	f04f 0301 	mov.w	r3, #1
 800d5b4:	e0a7      	b.n	800d706 <f_read+0x2e6>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
 800d5b6:	68fb      	ldr	r3, [r7, #12]
 800d5b8:	799b      	ldrb	r3, [r3, #6]
 800d5ba:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800d5be:	2b00      	cmp	r3, #0
 800d5c0:	d017      	beq.n	800d5f2 <f_read+0x1d2>
 800d5c2:	68fb      	ldr	r3, [r7, #12]
 800d5c4:	699a      	ldr	r2, [r3, #24]
 800d5c6:	693b      	ldr	r3, [r7, #16]
 800d5c8:	1ad2      	subs	r2, r2, r3
 800d5ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d5cc:	429a      	cmp	r2, r3
 800d5ce:	d210      	bcs.n	800d5f2 <f_read+0x1d2>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 800d5d0:	68fb      	ldr	r3, [r7, #12]
 800d5d2:	699a      	ldr	r2, [r3, #24]
 800d5d4:	693b      	ldr	r3, [r7, #16]
 800d5d6:	1ad3      	subs	r3, r2, r3
 800d5d8:	ea4f 2343 	mov.w	r3, r3, lsl #9
 800d5dc:	6a3a      	ldr	r2, [r7, #32]
 800d5de:	18d2      	adds	r2, r2, r3
 800d5e0:	68fb      	ldr	r3, [r7, #12]
 800d5e2:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800d5e6:	4610      	mov	r0, r2
 800d5e8:	4619      	mov	r1, r3
 800d5ea:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d5ee:	f7fd ff7d 	bl	800b4ec <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
 800d5f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d5f4:	ea4f 2343 	mov.w	r3, r3, lsl #9
 800d5f8:	62bb      	str	r3, [r7, #40]	; 0x28
				continue;
 800d5fa:	e06a      	b.n	800d6d2 <f_read+0x2b2>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
 800d5fc:	68fb      	ldr	r3, [r7, #12]
 800d5fe:	699a      	ldr	r2, [r3, #24]
 800d600:	693b      	ldr	r3, [r7, #16]
 800d602:	429a      	cmp	r2, r3
 800d604:	d042      	beq.n	800d68c <f_read+0x26c>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
 800d606:	68fb      	ldr	r3, [r7, #12]
 800d608:	799b      	ldrb	r3, [r3, #6]
 800d60a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800d60e:	2b00      	cmp	r3, #0
 800d610:	d022      	beq.n	800d658 <f_read+0x238>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 800d612:	68fb      	ldr	r3, [r7, #12]
 800d614:	681b      	ldr	r3, [r3, #0]
 800d616:	7859      	ldrb	r1, [r3, #1]
 800d618:	68fb      	ldr	r3, [r7, #12]
 800d61a:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800d61e:	68fb      	ldr	r3, [r7, #12]
 800d620:	699b      	ldr	r3, [r3, #24]
 800d622:	4608      	mov	r0, r1
 800d624:	4611      	mov	r1, r2
 800d626:	461a      	mov	r2, r3
 800d628:	f04f 0301 	mov.w	r3, #1
 800d62c:	f7fd feaa 	bl	800b384 <disk_write>
 800d630:	4603      	mov	r3, r0
 800d632:	2b00      	cmp	r3, #0
 800d634:	d009      	beq.n	800d64a <f_read+0x22a>
						ABORT(fp->fs, FR_DISK_ERR);
 800d636:	68fb      	ldr	r3, [r7, #12]
 800d638:	799b      	ldrb	r3, [r3, #6]
 800d63a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d63e:	b2da      	uxtb	r2, r3
 800d640:	68fb      	ldr	r3, [r7, #12]
 800d642:	719a      	strb	r2, [r3, #6]
 800d644:	f04f 0301 	mov.w	r3, #1
 800d648:	e05d      	b.n	800d706 <f_read+0x2e6>
					fp->flag &= ~FA__DIRTY;
 800d64a:	68fb      	ldr	r3, [r7, #12]
 800d64c:	799b      	ldrb	r3, [r3, #6]
 800d64e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800d652:	b2da      	uxtb	r2, r3
 800d654:	68fb      	ldr	r3, [r7, #12]
 800d656:	719a      	strb	r2, [r3, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
 800d658:	68fb      	ldr	r3, [r7, #12]
 800d65a:	681b      	ldr	r3, [r3, #0]
 800d65c:	785a      	ldrb	r2, [r3, #1]
 800d65e:	68fb      	ldr	r3, [r7, #12]
 800d660:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800d664:	4610      	mov	r0, r2
 800d666:	4619      	mov	r1, r3
 800d668:	693a      	ldr	r2, [r7, #16]
 800d66a:	f04f 0301 	mov.w	r3, #1
 800d66e:	f7fd fe47 	bl	800b300 <disk_read>
 800d672:	4603      	mov	r3, r0
 800d674:	2b00      	cmp	r3, #0
 800d676:	d009      	beq.n	800d68c <f_read+0x26c>
					ABORT(fp->fs, FR_DISK_ERR);
 800d678:	68fb      	ldr	r3, [r7, #12]
 800d67a:	799b      	ldrb	r3, [r3, #6]
 800d67c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d680:	b2da      	uxtb	r2, r3
 800d682:	68fb      	ldr	r3, [r7, #12]
 800d684:	719a      	strb	r2, [r3, #6]
 800d686:	f04f 0301 	mov.w	r3, #1
 800d68a:	e03c      	b.n	800d706 <f_read+0x2e6>
			}
#endif
			fp->dsect = sect;
 800d68c:	68fb      	ldr	r3, [r7, #12]
 800d68e:	693a      	ldr	r2, [r7, #16]
 800d690:	619a      	str	r2, [r3, #24]
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 800d692:	68fb      	ldr	r3, [r7, #12]
 800d694:	689b      	ldr	r3, [r3, #8]
 800d696:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800d69a:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800d69e:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 800d6a2:	62bb      	str	r3, [r7, #40]	; 0x28
		if (rcnt > btr) rcnt = btr;
 800d6a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d6a6:	687b      	ldr	r3, [r7, #4]
 800d6a8:	429a      	cmp	r2, r3
 800d6aa:	d901      	bls.n	800d6b0 <f_read+0x290>
 800d6ac:	687b      	ldr	r3, [r7, #4]
 800d6ae:	62bb      	str	r3, [r7, #40]	; 0x28
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 800d6b0:	68fb      	ldr	r3, [r7, #12]
 800d6b2:	689b      	ldr	r3, [r3, #8]
 800d6b4:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800d6b8:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800d6bc:	f103 0320 	add.w	r3, r3, #32
 800d6c0:	68fa      	ldr	r2, [r7, #12]
 800d6c2:	18d3      	adds	r3, r2, r3
 800d6c4:	f103 0304 	add.w	r3, r3, #4
 800d6c8:	6a38      	ldr	r0, [r7, #32]
 800d6ca:	4619      	mov	r1, r3
 800d6cc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d6ce:	f7fd ff0d 	bl	800b4ec <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800d6d2:	6a3a      	ldr	r2, [r7, #32]
 800d6d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d6d6:	18d3      	adds	r3, r2, r3
 800d6d8:	623b      	str	r3, [r7, #32]
 800d6da:	68fb      	ldr	r3, [r7, #12]
 800d6dc:	689a      	ldr	r2, [r3, #8]
 800d6de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d6e0:	18d2      	adds	r2, r2, r3
 800d6e2:	68fb      	ldr	r3, [r7, #12]
 800d6e4:	609a      	str	r2, [r3, #8]
 800d6e6:	683b      	ldr	r3, [r7, #0]
 800d6e8:	681a      	ldr	r2, [r3, #0]
 800d6ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d6ec:	18d2      	adds	r2, r2, r3
 800d6ee:	683b      	ldr	r3, [r7, #0]
 800d6f0:	601a      	str	r2, [r3, #0]
 800d6f2:	687a      	ldr	r2, [r7, #4]
 800d6f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d6f6:	1ad3      	subs	r3, r2, r3
 800d6f8:	607b      	str	r3, [r7, #4]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
 800d6fa:	687b      	ldr	r3, [r7, #4]
 800d6fc:	2b00      	cmp	r3, #0
 800d6fe:	f47f aecb 	bne.w	800d498 <f_read+0x78>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
 800d702:	f04f 0300 	mov.w	r3, #0
}
 800d706:	4618      	mov	r0, r3
 800d708:	f107 0730 	add.w	r7, r7, #48	; 0x30
 800d70c:	46bd      	mov	sp, r7
 800d70e:	bd80      	pop	{r7, pc}

0800d710 <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
 800d710:	b580      	push	{r7, lr}
 800d712:	b08a      	sub	sp, #40	; 0x28
 800d714:	af00      	add	r7, sp, #0
 800d716:	60f8      	str	r0, [r7, #12]
 800d718:	60b9      	str	r1, [r7, #8]
 800d71a:	607a      	str	r2, [r7, #4]
 800d71c:	603b      	str	r3, [r7, #0]
	FRESULT res;
	DWORD clst, sect;
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
 800d71e:	68bb      	ldr	r3, [r7, #8]
 800d720:	61bb      	str	r3, [r7, #24]
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */
 800d722:	683b      	ldr	r3, [r7, #0]
 800d724:	f04f 0200 	mov.w	r2, #0
 800d728:	601a      	str	r2, [r3, #0]

	res = validate(fp->fs, fp->id);			/* Check validity */
 800d72a:	68fb      	ldr	r3, [r7, #12]
 800d72c:	681a      	ldr	r2, [r3, #0]
 800d72e:	68fb      	ldr	r3, [r7, #12]
 800d730:	889b      	ldrh	r3, [r3, #4]
 800d732:	4610      	mov	r0, r2
 800d734:	4619      	mov	r1, r3
 800d736:	f7ff fc6f 	bl	800d018 <validate>
 800d73a:	4603      	mov	r3, r0
 800d73c:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 800d73e:	7dfb      	ldrb	r3, [r7, #23]
 800d740:	2b00      	cmp	r3, #0
 800d742:	d001      	beq.n	800d748 <f_write+0x38>
 800d744:	7dfb      	ldrb	r3, [r7, #23]
 800d746:	e188      	b.n	800da5a <f_write+0x34a>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
 800d748:	68fb      	ldr	r3, [r7, #12]
 800d74a:	799b      	ldrb	r3, [r3, #6]
 800d74c:	b2db      	uxtb	r3, r3
 800d74e:	b25b      	sxtb	r3, r3
 800d750:	2b00      	cmp	r3, #0
 800d752:	da02      	bge.n	800d75a <f_write+0x4a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
 800d754:	f04f 0302 	mov.w	r3, #2
 800d758:	e17f      	b.n	800da5a <f_write+0x34a>
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 800d75a:	68fb      	ldr	r3, [r7, #12]
 800d75c:	799b      	ldrb	r3, [r3, #6]
 800d75e:	f003 0302 	and.w	r3, r3, #2
 800d762:	2b00      	cmp	r3, #0
 800d764:	d102      	bne.n	800d76c <f_write+0x5c>
		LEAVE_FF(fp->fs, FR_DENIED);
 800d766:	f04f 0307 	mov.w	r3, #7
 800d76a:	e176      	b.n	800da5a <f_write+0x34a>
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
 800d76c:	68fb      	ldr	r3, [r7, #12]
 800d76e:	68da      	ldr	r2, [r3, #12]
 800d770:	687b      	ldr	r3, [r7, #4]
 800d772:	18d2      	adds	r2, r2, r3
 800d774:	68fb      	ldr	r3, [r7, #12]
 800d776:	68db      	ldr	r3, [r3, #12]
 800d778:	429a      	cmp	r2, r3
 800d77a:	f080 8155 	bcs.w	800da28 <f_write+0x318>
 800d77e:	f04f 0300 	mov.w	r3, #0
 800d782:	607b      	str	r3, [r7, #4]

	for ( ;  btw;							/* Repeat until all data written */
 800d784:	e150      	b.n	800da28 <f_write+0x318>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 800d786:	68fb      	ldr	r3, [r7, #12]
 800d788:	689b      	ldr	r3, [r3, #8]
 800d78a:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800d78e:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800d792:	2b00      	cmp	r3, #0
 800d794:	f040 810d 	bne.w	800d9b2 <f_write+0x2a2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 800d798:	68fb      	ldr	r3, [r7, #12]
 800d79a:	689b      	ldr	r3, [r3, #8]
 800d79c:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800d7a0:	b2da      	uxtb	r2, r3
 800d7a2:	68fb      	ldr	r3, [r7, #12]
 800d7a4:	681b      	ldr	r3, [r3, #0]
 800d7a6:	789b      	ldrb	r3, [r3, #2]
 800d7a8:	f103 33ff 	add.w	r3, r3, #4294967295
 800d7ac:	b2db      	uxtb	r3, r3
 800d7ae:	4013      	ands	r3, r2
 800d7b0:	75bb      	strb	r3, [r7, #22]
			if (!csect) {					/* On the cluster boundary? */
 800d7b2:	7dbb      	ldrb	r3, [r7, #22]
 800d7b4:	2b00      	cmp	r3, #0
 800d7b6:	d140      	bne.n	800d83a <f_write+0x12a>
				if (fp->fptr == 0) {		/* On the top of the file? */
 800d7b8:	68fb      	ldr	r3, [r7, #12]
 800d7ba:	689b      	ldr	r3, [r3, #8]
 800d7bc:	2b00      	cmp	r3, #0
 800d7be:	d111      	bne.n	800d7e4 <f_write+0xd4>
					clst = fp->sclust;		/* Follow from the origin */
 800d7c0:	68fb      	ldr	r3, [r7, #12]
 800d7c2:	691b      	ldr	r3, [r3, #16]
 800d7c4:	627b      	str	r3, [r7, #36]	; 0x24
					if (clst == 0)			/* When no cluster is allocated, */
 800d7c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d7c8:	2b00      	cmp	r3, #0
 800d7ca:	d114      	bne.n	800d7f6 <f_write+0xe6>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 800d7cc:	68fb      	ldr	r3, [r7, #12]
 800d7ce:	681b      	ldr	r3, [r3, #0]
 800d7d0:	4618      	mov	r0, r3
 800d7d2:	f04f 0100 	mov.w	r1, #0
 800d7d6:	f7fe fafd 	bl	800bdd4 <create_chain>
 800d7da:	6278      	str	r0, [r7, #36]	; 0x24
 800d7dc:	68fb      	ldr	r3, [r7, #12]
 800d7de:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d7e0:	611a      	str	r2, [r3, #16]
 800d7e2:	e008      	b.n	800d7f6 <f_write+0xe6>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800d7e4:	68fb      	ldr	r3, [r7, #12]
 800d7e6:	681a      	ldr	r2, [r3, #0]
 800d7e8:	68fb      	ldr	r3, [r7, #12]
 800d7ea:	695b      	ldr	r3, [r3, #20]
 800d7ec:	4610      	mov	r0, r2
 800d7ee:	4619      	mov	r1, r3
 800d7f0:	f7fe faf0 	bl	800bdd4 <create_chain>
 800d7f4:	6278      	str	r0, [r7, #36]	; 0x24
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800d7f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d7f8:	2b00      	cmp	r3, #0
 800d7fa:	f000 811a 	beq.w	800da32 <f_write+0x322>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 800d7fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d800:	2b01      	cmp	r3, #1
 800d802:	d109      	bne.n	800d818 <f_write+0x108>
 800d804:	68fb      	ldr	r3, [r7, #12]
 800d806:	799b      	ldrb	r3, [r3, #6]
 800d808:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d80c:	b2da      	uxtb	r2, r3
 800d80e:	68fb      	ldr	r3, [r7, #12]
 800d810:	719a      	strb	r2, [r3, #6]
 800d812:	f04f 0302 	mov.w	r3, #2
 800d816:	e120      	b.n	800da5a <f_write+0x34a>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 800d818:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d81a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d81e:	d109      	bne.n	800d834 <f_write+0x124>
 800d820:	68fb      	ldr	r3, [r7, #12]
 800d822:	799b      	ldrb	r3, [r3, #6]
 800d824:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d828:	b2da      	uxtb	r2, r3
 800d82a:	68fb      	ldr	r3, [r7, #12]
 800d82c:	719a      	strb	r2, [r3, #6]
 800d82e:	f04f 0301 	mov.w	r3, #1
 800d832:	e112      	b.n	800da5a <f_write+0x34a>
				fp->clust = clst;			/* Update current cluster */
 800d834:	68fb      	ldr	r3, [r7, #12]
 800d836:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d838:	615a      	str	r2, [r3, #20]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 800d83a:	68fb      	ldr	r3, [r7, #12]
 800d83c:	799b      	ldrb	r3, [r3, #6]
 800d83e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800d842:	2b00      	cmp	r3, #0
 800d844:	d022      	beq.n	800d88c <f_write+0x17c>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 800d846:	68fb      	ldr	r3, [r7, #12]
 800d848:	681b      	ldr	r3, [r3, #0]
 800d84a:	7859      	ldrb	r1, [r3, #1]
 800d84c:	68fb      	ldr	r3, [r7, #12]
 800d84e:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800d852:	68fb      	ldr	r3, [r7, #12]
 800d854:	699b      	ldr	r3, [r3, #24]
 800d856:	4608      	mov	r0, r1
 800d858:	4611      	mov	r1, r2
 800d85a:	461a      	mov	r2, r3
 800d85c:	f04f 0301 	mov.w	r3, #1
 800d860:	f7fd fd90 	bl	800b384 <disk_write>
 800d864:	4603      	mov	r3, r0
 800d866:	2b00      	cmp	r3, #0
 800d868:	d009      	beq.n	800d87e <f_write+0x16e>
					ABORT(fp->fs, FR_DISK_ERR);
 800d86a:	68fb      	ldr	r3, [r7, #12]
 800d86c:	799b      	ldrb	r3, [r3, #6]
 800d86e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d872:	b2da      	uxtb	r2, r3
 800d874:	68fb      	ldr	r3, [r7, #12]
 800d876:	719a      	strb	r2, [r3, #6]
 800d878:	f04f 0301 	mov.w	r3, #1
 800d87c:	e0ed      	b.n	800da5a <f_write+0x34a>
				fp->flag &= ~FA__DIRTY;
 800d87e:	68fb      	ldr	r3, [r7, #12]
 800d880:	799b      	ldrb	r3, [r3, #6]
 800d882:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800d886:	b2da      	uxtb	r2, r3
 800d888:	68fb      	ldr	r3, [r7, #12]
 800d88a:	719a      	strb	r2, [r3, #6]
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 800d88c:	68fb      	ldr	r3, [r7, #12]
 800d88e:	681a      	ldr	r2, [r3, #0]
 800d890:	68fb      	ldr	r3, [r7, #12]
 800d892:	695b      	ldr	r3, [r3, #20]
 800d894:	4610      	mov	r0, r2
 800d896:	4619      	mov	r1, r3
 800d898:	f7fd fff0 	bl	800b87c <clust2sect>
 800d89c:	6138      	str	r0, [r7, #16]
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 800d89e:	693b      	ldr	r3, [r7, #16]
 800d8a0:	2b00      	cmp	r3, #0
 800d8a2:	d109      	bne.n	800d8b8 <f_write+0x1a8>
 800d8a4:	68fb      	ldr	r3, [r7, #12]
 800d8a6:	799b      	ldrb	r3, [r3, #6]
 800d8a8:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d8ac:	b2da      	uxtb	r2, r3
 800d8ae:	68fb      	ldr	r3, [r7, #12]
 800d8b0:	719a      	strb	r2, [r3, #6]
 800d8b2:	f04f 0302 	mov.w	r3, #2
 800d8b6:	e0d0      	b.n	800da5a <f_write+0x34a>
			sect += csect;
 800d8b8:	7dbb      	ldrb	r3, [r7, #22]
 800d8ba:	693a      	ldr	r2, [r7, #16]
 800d8bc:	18d3      	adds	r3, r2, r3
 800d8be:	613b      	str	r3, [r7, #16]
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
 800d8c0:	687b      	ldr	r3, [r7, #4]
 800d8c2:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800d8c6:	61fb      	str	r3, [r7, #28]
			if (cc) {						/* Write maximum contiguous sectors directly */
 800d8c8:	69fb      	ldr	r3, [r7, #28]
 800d8ca:	2b00      	cmp	r3, #0
 800d8cc:	d049      	beq.n	800d962 <f_write+0x252>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 800d8ce:	7dba      	ldrb	r2, [r7, #22]
 800d8d0:	69fb      	ldr	r3, [r7, #28]
 800d8d2:	18d2      	adds	r2, r2, r3
 800d8d4:	68fb      	ldr	r3, [r7, #12]
 800d8d6:	681b      	ldr	r3, [r3, #0]
 800d8d8:	789b      	ldrb	r3, [r3, #2]
 800d8da:	429a      	cmp	r2, r3
 800d8dc:	d906      	bls.n	800d8ec <f_write+0x1dc>
					cc = fp->fs->csize - csect;
 800d8de:	68fb      	ldr	r3, [r7, #12]
 800d8e0:	681b      	ldr	r3, [r3, #0]
 800d8e2:	789b      	ldrb	r3, [r3, #2]
 800d8e4:	461a      	mov	r2, r3
 800d8e6:	7dbb      	ldrb	r3, [r7, #22]
 800d8e8:	1ad3      	subs	r3, r2, r3
 800d8ea:	61fb      	str	r3, [r7, #28]
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
 800d8ec:	68fb      	ldr	r3, [r7, #12]
 800d8ee:	681b      	ldr	r3, [r3, #0]
 800d8f0:	785a      	ldrb	r2, [r3, #1]
 800d8f2:	69fb      	ldr	r3, [r7, #28]
 800d8f4:	b2db      	uxtb	r3, r3
 800d8f6:	4610      	mov	r0, r2
 800d8f8:	69b9      	ldr	r1, [r7, #24]
 800d8fa:	693a      	ldr	r2, [r7, #16]
 800d8fc:	f7fd fd42 	bl	800b384 <disk_write>
 800d900:	4603      	mov	r3, r0
 800d902:	2b00      	cmp	r3, #0
 800d904:	d009      	beq.n	800d91a <f_write+0x20a>
					ABORT(fp->fs, FR_DISK_ERR);
 800d906:	68fb      	ldr	r3, [r7, #12]
 800d908:	799b      	ldrb	r3, [r3, #6]
 800d90a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d90e:	b2da      	uxtb	r2, r3
 800d910:	68fb      	ldr	r3, [r7, #12]
 800d912:	719a      	strb	r2, [r3, #6]
 800d914:	f04f 0301 	mov.w	r3, #1
 800d918:	e09f      	b.n	800da5a <f_write+0x34a>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 800d91a:	68fb      	ldr	r3, [r7, #12]
 800d91c:	699a      	ldr	r2, [r3, #24]
 800d91e:	693b      	ldr	r3, [r7, #16]
 800d920:	1ad2      	subs	r2, r2, r3
 800d922:	69fb      	ldr	r3, [r7, #28]
 800d924:	429a      	cmp	r2, r3
 800d926:	d217      	bcs.n	800d958 <f_write+0x248>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 800d928:	68fb      	ldr	r3, [r7, #12]
 800d92a:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800d92e:	68fb      	ldr	r3, [r7, #12]
 800d930:	6999      	ldr	r1, [r3, #24]
 800d932:	693b      	ldr	r3, [r7, #16]
 800d934:	1acb      	subs	r3, r1, r3
 800d936:	ea4f 2343 	mov.w	r3, r3, lsl #9
 800d93a:	69b9      	ldr	r1, [r7, #24]
 800d93c:	18cb      	adds	r3, r1, r3
 800d93e:	4610      	mov	r0, r2
 800d940:	4619      	mov	r1, r3
 800d942:	f44f 7200 	mov.w	r2, #512	; 0x200
 800d946:	f7fd fdd1 	bl	800b4ec <mem_cpy>
					fp->flag &= ~FA__DIRTY;
 800d94a:	68fb      	ldr	r3, [r7, #12]
 800d94c:	799b      	ldrb	r3, [r3, #6]
 800d94e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800d952:	b2da      	uxtb	r2, r3
 800d954:	68fb      	ldr	r3, [r7, #12]
 800d956:	719a      	strb	r2, [r3, #6]
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 800d958:	69fb      	ldr	r3, [r7, #28]
 800d95a:	ea4f 2343 	mov.w	r3, r3, lsl #9
 800d95e:	623b      	str	r3, [r7, #32]
				continue;
 800d960:	e04e      	b.n	800da00 <f_write+0x2f0>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 800d962:	68fb      	ldr	r3, [r7, #12]
 800d964:	699a      	ldr	r2, [r3, #24]
 800d966:	693b      	ldr	r3, [r7, #16]
 800d968:	429a      	cmp	r2, r3
 800d96a:	d01f      	beq.n	800d9ac <f_write+0x29c>
				if (fp->fptr < fp->fsize &&
 800d96c:	68fb      	ldr	r3, [r7, #12]
 800d96e:	689a      	ldr	r2, [r3, #8]
 800d970:	68fb      	ldr	r3, [r7, #12]
 800d972:	68db      	ldr	r3, [r3, #12]
 800d974:	429a      	cmp	r2, r3
 800d976:	d219      	bcs.n	800d9ac <f_write+0x29c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
 800d978:	68fb      	ldr	r3, [r7, #12]
 800d97a:	681b      	ldr	r3, [r3, #0]
 800d97c:	785a      	ldrb	r2, [r3, #1]
 800d97e:	68fb      	ldr	r3, [r7, #12]
 800d980:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800d984:	4610      	mov	r0, r2
 800d986:	4619      	mov	r1, r3
 800d988:	693a      	ldr	r2, [r7, #16]
 800d98a:	f04f 0301 	mov.w	r3, #1
 800d98e:	f7fd fcb7 	bl	800b300 <disk_read>
 800d992:	4603      	mov	r3, r0
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
 800d994:	2b00      	cmp	r3, #0
 800d996:	d009      	beq.n	800d9ac <f_write+0x29c>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
 800d998:	68fb      	ldr	r3, [r7, #12]
 800d99a:	799b      	ldrb	r3, [r3, #6]
 800d99c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800d9a0:	b2da      	uxtb	r2, r3
 800d9a2:	68fb      	ldr	r3, [r7, #12]
 800d9a4:	719a      	strb	r2, [r3, #6]
 800d9a6:	f04f 0301 	mov.w	r3, #1
 800d9aa:	e056      	b.n	800da5a <f_write+0x34a>
			}
#endif
			fp->dsect = sect;
 800d9ac:	68fb      	ldr	r3, [r7, #12]
 800d9ae:	693a      	ldr	r2, [r7, #16]
 800d9b0:	619a      	str	r2, [r3, #24]
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 800d9b2:	68fb      	ldr	r3, [r7, #12]
 800d9b4:	689b      	ldr	r3, [r3, #8]
 800d9b6:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800d9ba:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800d9be:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 800d9c2:	623b      	str	r3, [r7, #32]
		if (wcnt > btw) wcnt = btw;
 800d9c4:	6a3a      	ldr	r2, [r7, #32]
 800d9c6:	687b      	ldr	r3, [r7, #4]
 800d9c8:	429a      	cmp	r2, r3
 800d9ca:	d901      	bls.n	800d9d0 <f_write+0x2c0>
 800d9cc:	687b      	ldr	r3, [r7, #4]
 800d9ce:	623b      	str	r3, [r7, #32]
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 800d9d0:	68fb      	ldr	r3, [r7, #12]
 800d9d2:	689b      	ldr	r3, [r3, #8]
 800d9d4:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800d9d8:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800d9dc:	f103 0320 	add.w	r3, r3, #32
 800d9e0:	68fa      	ldr	r2, [r7, #12]
 800d9e2:	18d3      	adds	r3, r2, r3
 800d9e4:	f103 0304 	add.w	r3, r3, #4
 800d9e8:	4618      	mov	r0, r3
 800d9ea:	69b9      	ldr	r1, [r7, #24]
 800d9ec:	6a3a      	ldr	r2, [r7, #32]
 800d9ee:	f7fd fd7d 	bl	800b4ec <mem_cpy>
		fp->flag |= FA__DIRTY;
 800d9f2:	68fb      	ldr	r3, [r7, #12]
 800d9f4:	799b      	ldrb	r3, [r3, #6]
 800d9f6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800d9fa:	b2da      	uxtb	r2, r3
 800d9fc:	68fb      	ldr	r3, [r7, #12]
 800d9fe:	719a      	strb	r2, [r3, #6]
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 800da00:	69ba      	ldr	r2, [r7, #24]
 800da02:	6a3b      	ldr	r3, [r7, #32]
 800da04:	18d3      	adds	r3, r2, r3
 800da06:	61bb      	str	r3, [r7, #24]
 800da08:	68fb      	ldr	r3, [r7, #12]
 800da0a:	689a      	ldr	r2, [r3, #8]
 800da0c:	6a3b      	ldr	r3, [r7, #32]
 800da0e:	18d2      	adds	r2, r2, r3
 800da10:	68fb      	ldr	r3, [r7, #12]
 800da12:	609a      	str	r2, [r3, #8]
 800da14:	683b      	ldr	r3, [r7, #0]
 800da16:	681a      	ldr	r2, [r3, #0]
 800da18:	6a3b      	ldr	r3, [r7, #32]
 800da1a:	18d2      	adds	r2, r2, r3
 800da1c:	683b      	ldr	r3, [r7, #0]
 800da1e:	601a      	str	r2, [r3, #0]
 800da20:	687a      	ldr	r2, [r7, #4]
 800da22:	6a3b      	ldr	r3, [r7, #32]
 800da24:	1ad3      	subs	r3, r2, r3
 800da26:	607b      	str	r3, [r7, #4]
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
 800da28:	687b      	ldr	r3, [r7, #4]
 800da2a:	2b00      	cmp	r3, #0
 800da2c:	f47f aeab 	bne.w	800d786 <f_write+0x76>
 800da30:	e000      	b.n	800da34 <f_write+0x324>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800da32:	bf00      	nop
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 800da34:	68fb      	ldr	r3, [r7, #12]
 800da36:	689a      	ldr	r2, [r3, #8]
 800da38:	68fb      	ldr	r3, [r7, #12]
 800da3a:	68db      	ldr	r3, [r3, #12]
 800da3c:	429a      	cmp	r2, r3
 800da3e:	d903      	bls.n	800da48 <f_write+0x338>
 800da40:	68fb      	ldr	r3, [r7, #12]
 800da42:	689a      	ldr	r2, [r3, #8]
 800da44:	68fb      	ldr	r3, [r7, #12]
 800da46:	60da      	str	r2, [r3, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 800da48:	68fb      	ldr	r3, [r7, #12]
 800da4a:	799b      	ldrb	r3, [r3, #6]
 800da4c:	f043 0320 	orr.w	r3, r3, #32
 800da50:	b2da      	uxtb	r2, r3
 800da52:	68fb      	ldr	r3, [r7, #12]
 800da54:	719a      	strb	r2, [r3, #6]

	LEAVE_FF(fp->fs, FR_OK);
 800da56:	f04f 0300 	mov.w	r3, #0
}
 800da5a:	4618      	mov	r0, r3
 800da5c:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800da60:	46bd      	mov	sp, r7
 800da62:	bd80      	pop	{r7, pc}

0800da64 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
 800da64:	b580      	push	{r7, lr}
 800da66:	b086      	sub	sp, #24
 800da68:	af00      	add	r7, sp, #0
 800da6a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 800da6c:	687b      	ldr	r3, [r7, #4]
 800da6e:	681a      	ldr	r2, [r3, #0]
 800da70:	687b      	ldr	r3, [r7, #4]
 800da72:	889b      	ldrh	r3, [r3, #4]
 800da74:	4610      	mov	r0, r2
 800da76:	4619      	mov	r1, r3
 800da78:	f7ff face 	bl	800d018 <validate>
 800da7c:	4603      	mov	r3, r0
 800da7e:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800da80:	7dfb      	ldrb	r3, [r7, #23]
 800da82:	2b00      	cmp	r3, #0
 800da84:	f040 80c7 	bne.w	800dc16 <f_sync+0x1b2>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 800da88:	687b      	ldr	r3, [r7, #4]
 800da8a:	799b      	ldrb	r3, [r3, #6]
 800da8c:	f003 0320 	and.w	r3, r3, #32
 800da90:	2b00      	cmp	r3, #0
 800da92:	f000 80c0 	beq.w	800dc16 <f_sync+0x1b2>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
 800da96:	687b      	ldr	r3, [r7, #4]
 800da98:	799b      	ldrb	r3, [r3, #6]
 800da9a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800da9e:	2b00      	cmp	r3, #0
 800daa0:	d01b      	beq.n	800dada <f_sync+0x76>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 800daa2:	687b      	ldr	r3, [r7, #4]
 800daa4:	681b      	ldr	r3, [r3, #0]
 800daa6:	7859      	ldrb	r1, [r3, #1]
 800daa8:	687b      	ldr	r3, [r7, #4]
 800daaa:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800daae:	687b      	ldr	r3, [r7, #4]
 800dab0:	699b      	ldr	r3, [r3, #24]
 800dab2:	4608      	mov	r0, r1
 800dab4:	4611      	mov	r1, r2
 800dab6:	461a      	mov	r2, r3
 800dab8:	f04f 0301 	mov.w	r3, #1
 800dabc:	f7fd fc62 	bl	800b384 <disk_write>
 800dac0:	4603      	mov	r3, r0
 800dac2:	2b00      	cmp	r3, #0
 800dac4:	d002      	beq.n	800dacc <f_sync+0x68>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 800dac6:	f04f 0301 	mov.w	r3, #1
 800daca:	e0a5      	b.n	800dc18 <f_sync+0x1b4>
				fp->flag &= ~FA__DIRTY;
 800dacc:	687b      	ldr	r3, [r7, #4]
 800dace:	799b      	ldrb	r3, [r3, #6]
 800dad0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800dad4:	b2da      	uxtb	r2, r3
 800dad6:	687b      	ldr	r3, [r7, #4]
 800dad8:	719a      	strb	r2, [r3, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 800dada:	687b      	ldr	r3, [r7, #4]
 800dadc:	681a      	ldr	r2, [r3, #0]
 800dade:	687b      	ldr	r3, [r7, #4]
 800dae0:	69db      	ldr	r3, [r3, #28]
 800dae2:	4610      	mov	r0, r2
 800dae4:	4619      	mov	r1, r3
 800dae6:	f7fd fd9f 	bl	800b628 <move_window>
 800daea:	4603      	mov	r3, r0
 800daec:	75fb      	strb	r3, [r7, #23]
			if (res == FR_OK) {
 800daee:	7dfb      	ldrb	r3, [r7, #23]
 800daf0:	2b00      	cmp	r3, #0
 800daf2:	f040 8090 	bne.w	800dc16 <f_sync+0x1b2>
				dir = fp->dir_ptr;
 800daf6:	687b      	ldr	r3, [r7, #4]
 800daf8:	6a1b      	ldr	r3, [r3, #32]
 800dafa:	613b      	str	r3, [r7, #16]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 800dafc:	693b      	ldr	r3, [r7, #16]
 800dafe:	f103 030b 	add.w	r3, r3, #11
 800db02:	693a      	ldr	r2, [r7, #16]
 800db04:	f102 020b 	add.w	r2, r2, #11
 800db08:	7812      	ldrb	r2, [r2, #0]
 800db0a:	f042 0220 	orr.w	r2, r2, #32
 800db0e:	b2d2      	uxtb	r2, r2
 800db10:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 800db12:	693b      	ldr	r3, [r7, #16]
 800db14:	f103 031c 	add.w	r3, r3, #28
 800db18:	687a      	ldr	r2, [r7, #4]
 800db1a:	68d2      	ldr	r2, [r2, #12]
 800db1c:	b2d2      	uxtb	r2, r2
 800db1e:	701a      	strb	r2, [r3, #0]
 800db20:	693b      	ldr	r3, [r7, #16]
 800db22:	f103 031d 	add.w	r3, r3, #29
 800db26:	687a      	ldr	r2, [r7, #4]
 800db28:	68d2      	ldr	r2, [r2, #12]
 800db2a:	b292      	uxth	r2, r2
 800db2c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800db30:	b292      	uxth	r2, r2
 800db32:	b2d2      	uxtb	r2, r2
 800db34:	701a      	strb	r2, [r3, #0]
 800db36:	693b      	ldr	r3, [r7, #16]
 800db38:	f103 031e 	add.w	r3, r3, #30
 800db3c:	687a      	ldr	r2, [r7, #4]
 800db3e:	68d2      	ldr	r2, [r2, #12]
 800db40:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800db44:	b2d2      	uxtb	r2, r2
 800db46:	701a      	strb	r2, [r3, #0]
 800db48:	693b      	ldr	r3, [r7, #16]
 800db4a:	f103 031f 	add.w	r3, r3, #31
 800db4e:	687a      	ldr	r2, [r7, #4]
 800db50:	68d2      	ldr	r2, [r2, #12]
 800db52:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800db56:	b2d2      	uxtb	r2, r2
 800db58:	701a      	strb	r2, [r3, #0]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
 800db5a:	693b      	ldr	r3, [r7, #16]
 800db5c:	f103 031a 	add.w	r3, r3, #26
 800db60:	687a      	ldr	r2, [r7, #4]
 800db62:	6912      	ldr	r2, [r2, #16]
 800db64:	b2d2      	uxtb	r2, r2
 800db66:	701a      	strb	r2, [r3, #0]
 800db68:	693b      	ldr	r3, [r7, #16]
 800db6a:	f103 031b 	add.w	r3, r3, #27
 800db6e:	687a      	ldr	r2, [r7, #4]
 800db70:	6912      	ldr	r2, [r2, #16]
 800db72:	b292      	uxth	r2, r2
 800db74:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800db78:	b292      	uxth	r2, r2
 800db7a:	b2d2      	uxtb	r2, r2
 800db7c:	701a      	strb	r2, [r3, #0]
 800db7e:	693b      	ldr	r3, [r7, #16]
 800db80:	f103 0314 	add.w	r3, r3, #20
 800db84:	687a      	ldr	r2, [r7, #4]
 800db86:	6912      	ldr	r2, [r2, #16]
 800db88:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800db8c:	b2d2      	uxtb	r2, r2
 800db8e:	701a      	strb	r2, [r3, #0]
 800db90:	693b      	ldr	r3, [r7, #16]
 800db92:	f103 0315 	add.w	r3, r3, #21
 800db96:	687a      	ldr	r2, [r7, #4]
 800db98:	6912      	ldr	r2, [r2, #16]
 800db9a:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800db9e:	b292      	uxth	r2, r2
 800dba0:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800dba4:	b292      	uxth	r2, r2
 800dba6:	b2d2      	uxtb	r2, r2
 800dba8:	701a      	strb	r2, [r3, #0]
				tim = get_fattime();						/* Update updated time */
 800dbaa:	f7fd fc67 	bl	800b47c <get_fattime>
 800dbae:	60f8      	str	r0, [r7, #12]
				ST_DWORD(dir+DIR_WrtTime, tim);
 800dbb0:	693b      	ldr	r3, [r7, #16]
 800dbb2:	f103 0316 	add.w	r3, r3, #22
 800dbb6:	68fa      	ldr	r2, [r7, #12]
 800dbb8:	b2d2      	uxtb	r2, r2
 800dbba:	701a      	strb	r2, [r3, #0]
 800dbbc:	693b      	ldr	r3, [r7, #16]
 800dbbe:	f103 0317 	add.w	r3, r3, #23
 800dbc2:	68fa      	ldr	r2, [r7, #12]
 800dbc4:	b292      	uxth	r2, r2
 800dbc6:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800dbca:	b292      	uxth	r2, r2
 800dbcc:	b2d2      	uxtb	r2, r2
 800dbce:	701a      	strb	r2, [r3, #0]
 800dbd0:	693b      	ldr	r3, [r7, #16]
 800dbd2:	f103 0318 	add.w	r3, r3, #24
 800dbd6:	68fa      	ldr	r2, [r7, #12]
 800dbd8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800dbdc:	b2d2      	uxtb	r2, r2
 800dbde:	701a      	strb	r2, [r3, #0]
 800dbe0:	693b      	ldr	r3, [r7, #16]
 800dbe2:	f103 0319 	add.w	r3, r3, #25
 800dbe6:	68fa      	ldr	r2, [r7, #12]
 800dbe8:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800dbec:	b2d2      	uxtb	r2, r2
 800dbee:	701a      	strb	r2, [r3, #0]
				fp->flag &= ~FA__WRITTEN;
 800dbf0:	687b      	ldr	r3, [r7, #4]
 800dbf2:	799b      	ldrb	r3, [r3, #6]
 800dbf4:	f023 0320 	bic.w	r3, r3, #32
 800dbf8:	b2da      	uxtb	r2, r3
 800dbfa:	687b      	ldr	r3, [r7, #4]
 800dbfc:	719a      	strb	r2, [r3, #6]
				fp->fs->wflag = 1;
 800dbfe:	687b      	ldr	r3, [r7, #4]
 800dc00:	681b      	ldr	r3, [r3, #0]
 800dc02:	f04f 0201 	mov.w	r2, #1
 800dc06:	711a      	strb	r2, [r3, #4]
				res = sync(fp->fs);
 800dc08:	687b      	ldr	r3, [r7, #4]
 800dc0a:	681b      	ldr	r3, [r3, #0]
 800dc0c:	4618      	mov	r0, r3
 800dc0e:	f7fd fd75 	bl	800b6fc <sync>
 800dc12:	4603      	mov	r3, r0
 800dc14:	75fb      	strb	r3, [r7, #23]
			}
		}
	}

	LEAVE_FF(fp->fs, res);
 800dc16:	7dfb      	ldrb	r3, [r7, #23]
}
 800dc18:	4618      	mov	r0, r3
 800dc1a:	f107 0718 	add.w	r7, r7, #24
 800dc1e:	46bd      	mov	sp, r7
 800dc20:	bd80      	pop	{r7, pc}
 800dc22:	bf00      	nop

0800dc24 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 800dc24:	b580      	push	{r7, lr}
 800dc26:	b084      	sub	sp, #16
 800dc28:	af00      	add	r7, sp, #0
 800dc2a:	6078      	str	r0, [r7, #4]
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
 800dc2c:	6878      	ldr	r0, [r7, #4]
 800dc2e:	f7ff ff19 	bl	800da64 <f_sync>
 800dc32:	4603      	mov	r3, r0
 800dc34:	73fb      	strb	r3, [r7, #15]
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 800dc36:	7bfb      	ldrb	r3, [r7, #15]
 800dc38:	2b00      	cmp	r3, #0
 800dc3a:	d103      	bne.n	800dc44 <f_close+0x20>
 800dc3c:	687b      	ldr	r3, [r7, #4]
 800dc3e:	f04f 0200 	mov.w	r2, #0
 800dc42:	601a      	str	r2, [r3, #0]
	return res;
 800dc44:	7bfb      	ldrb	r3, [r7, #15]
#endif
}
 800dc46:	4618      	mov	r0, r3
 800dc48:	f107 0710 	add.w	r7, r7, #16
 800dc4c:	46bd      	mov	sp, r7
 800dc4e:	bd80      	pop	{r7, pc}

0800dc50 <f_chdrive>:
#if _FS_RPATH >= 1

FRESULT f_chdrive (
	BYTE drv		/* Drive number */
)
{
 800dc50:	b480      	push	{r7}
 800dc52:	b083      	sub	sp, #12
 800dc54:	af00      	add	r7, sp, #0
 800dc56:	4603      	mov	r3, r0
 800dc58:	71fb      	strb	r3, [r7, #7]
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 800dc5a:	79fb      	ldrb	r3, [r7, #7]
 800dc5c:	2b01      	cmp	r3, #1
 800dc5e:	d902      	bls.n	800dc66 <f_chdrive+0x16>
 800dc60:	f04f 030b 	mov.w	r3, #11
 800dc64:	e007      	b.n	800dc76 <f_chdrive+0x26>

	CurrVol = drv;
 800dc66:	f640 53da 	movw	r3, #3546	; 0xdda
 800dc6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dc6e:	79fa      	ldrb	r2, [r7, #7]
 800dc70:	701a      	strb	r2, [r3, #0]

	return FR_OK;
 800dc72:	f04f 0300 	mov.w	r3, #0
}
 800dc76:	4618      	mov	r0, r3
 800dc78:	f107 070c 	add.w	r7, r7, #12
 800dc7c:	46bd      	mov	sp, r7
 800dc7e:	bc80      	pop	{r7}
 800dc80:	4770      	bx	lr
 800dc82:	bf00      	nop

0800dc84 <f_chdir>:


FRESULT f_chdir (
	const TCHAR *path	/* Pointer to the directory path */
)
{
 800dc84:	b580      	push	{r7, lr}
 800dc86:	b08e      	sub	sp, #56	; 0x38
 800dc88:	af00      	add	r7, sp, #0
 800dc8a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
 800dc8c:	f107 0204 	add.w	r2, r7, #4
 800dc90:	f107 0318 	add.w	r3, r7, #24
 800dc94:	4610      	mov	r0, r2
 800dc96:	4619      	mov	r1, r3
 800dc98:	f04f 0200 	mov.w	r2, #0
 800dc9c:	f7fe feb6 	bl	800ca0c <chk_mounted>
 800dca0:	4603      	mov	r3, r0
 800dca2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 800dca6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800dcaa:	2b00      	cmp	r3, #0
 800dcac:	d14d      	bne.n	800dd4a <f_chdir+0xc6>
		INIT_BUF(dj);
 800dcae:	f107 030c 	add.w	r3, r7, #12
 800dcb2:	633b      	str	r3, [r7, #48]	; 0x30
		res = follow_path(&dj, path);		/* Follow the path */
 800dcb4:	687b      	ldr	r3, [r7, #4]
 800dcb6:	f107 0218 	add.w	r2, r7, #24
 800dcba:	4610      	mov	r0, r2
 800dcbc:	4619      	mov	r1, r3
 800dcbe:	f7fe fd89 	bl	800c7d4 <follow_path>
 800dcc2:	4603      	mov	r3, r0
 800dcc4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		FREE_BUF();
		if (res == FR_OK) {					/* Follow completed */
 800dcc8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800dccc:	2b00      	cmp	r3, #0
 800dcce:	d134      	bne.n	800dd3a <f_chdir+0xb6>
			if (!dj.dir) {
 800dcd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dcd2:	2b00      	cmp	r3, #0
 800dcd4:	d103      	bne.n	800dcde <f_chdir+0x5a>
				dj.fs->cdir = dj.sclust;	/* Start directory itself */
 800dcd6:	69bb      	ldr	r3, [r7, #24]
 800dcd8:	6a3a      	ldr	r2, [r7, #32]
 800dcda:	619a      	str	r2, [r3, #24]
 800dcdc:	e02d      	b.n	800dd3a <f_chdir+0xb6>
			} else {
				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
 800dcde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dce0:	f103 030b 	add.w	r3, r3, #11
 800dce4:	781b      	ldrb	r3, [r3, #0]
 800dce6:	f003 0310 	and.w	r3, r3, #16
 800dcea:	2b00      	cmp	r3, #0
 800dcec:	d021      	beq.n	800dd32 <f_chdir+0xae>
					dj.fs->cdir = LD_CLUST(dj.dir);
 800dcee:	69bb      	ldr	r3, [r7, #24]
 800dcf0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800dcf2:	f102 0215 	add.w	r2, r2, #21
 800dcf6:	7812      	ldrb	r2, [r2, #0]
 800dcf8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800dcfc:	b291      	uxth	r1, r2
 800dcfe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800dd00:	f102 0214 	add.w	r2, r2, #20
 800dd04:	7812      	ldrb	r2, [r2, #0]
 800dd06:	430a      	orrs	r2, r1
 800dd08:	b292      	uxth	r2, r2
 800dd0a:	b292      	uxth	r2, r2
 800dd0c:	ea4f 4102 	mov.w	r1, r2, lsl #16
 800dd10:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800dd12:	f102 021b 	add.w	r2, r2, #27
 800dd16:	7812      	ldrb	r2, [r2, #0]
 800dd18:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800dd1c:	b290      	uxth	r0, r2
 800dd1e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800dd20:	f102 021a 	add.w	r2, r2, #26
 800dd24:	7812      	ldrb	r2, [r2, #0]
 800dd26:	4302      	orrs	r2, r0
 800dd28:	b292      	uxth	r2, r2
 800dd2a:	b292      	uxth	r2, r2
 800dd2c:	430a      	orrs	r2, r1
 800dd2e:	619a      	str	r2, [r3, #24]
 800dd30:	e003      	b.n	800dd3a <f_chdir+0xb6>
				else
					res = FR_NO_PATH;		/* Reached but a file */
 800dd32:	f04f 0305 	mov.w	r3, #5
 800dd36:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800dd3a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800dd3e:	2b04      	cmp	r3, #4
 800dd40:	d103      	bne.n	800dd4a <f_chdir+0xc6>
 800dd42:	f04f 0305 	mov.w	r3, #5
 800dd46:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	}

	LEAVE_FF(dj.fs, res);
 800dd4a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 800dd4e:	4618      	mov	r0, r3
 800dd50:	f107 0738 	add.w	r7, r7, #56	; 0x38
 800dd54:	46bd      	mov	sp, r7
 800dd56:	bd80      	pop	{r7, pc}

0800dd58 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
 800dd58:	b580      	push	{r7, lr}
 800dd5a:	b088      	sub	sp, #32
 800dd5c:	af00      	add	r7, sp, #0
 800dd5e:	6078      	str	r0, [r7, #4]
 800dd60:	6039      	str	r1, [r7, #0]
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 800dd62:	687b      	ldr	r3, [r7, #4]
 800dd64:	681a      	ldr	r2, [r3, #0]
 800dd66:	687b      	ldr	r3, [r7, #4]
 800dd68:	889b      	ldrh	r3, [r3, #4]
 800dd6a:	4610      	mov	r0, r2
 800dd6c:	4619      	mov	r1, r3
 800dd6e:	f7ff f953 	bl	800d018 <validate>
 800dd72:	4603      	mov	r3, r0
 800dd74:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 800dd76:	7dfb      	ldrb	r3, [r7, #23]
 800dd78:	2b00      	cmp	r3, #0
 800dd7a:	d001      	beq.n	800dd80 <f_lseek+0x28>
 800dd7c:	7dfb      	ldrb	r3, [r7, #23]
 800dd7e:	e157      	b.n	800e030 <f_lseek+0x2d8>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
 800dd80:	687b      	ldr	r3, [r7, #4]
 800dd82:	799b      	ldrb	r3, [r3, #6]
 800dd84:	b2db      	uxtb	r3, r3
 800dd86:	b25b      	sxtb	r3, r3
 800dd88:	2b00      	cmp	r3, #0
 800dd8a:	da02      	bge.n	800dd92 <f_lseek+0x3a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
 800dd8c:	f04f 0302 	mov.w	r3, #2
 800dd90:	e14e      	b.n	800e030 <f_lseek+0x2d8>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 800dd92:	687b      	ldr	r3, [r7, #4]
 800dd94:	68da      	ldr	r2, [r3, #12]
 800dd96:	683b      	ldr	r3, [r7, #0]
 800dd98:	429a      	cmp	r2, r3
 800dd9a:	d208      	bcs.n	800ddae <f_lseek+0x56>
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
 800dd9c:	687b      	ldr	r3, [r7, #4]
 800dd9e:	799b      	ldrb	r3, [r3, #6]
 800dda0:	f003 0302 	and.w	r3, r3, #2
 800dda4:	2b00      	cmp	r3, #0
 800dda6:	d102      	bne.n	800ddae <f_lseek+0x56>
#endif
			) ofs = fp->fsize;
 800dda8:	687b      	ldr	r3, [r7, #4]
 800ddaa:	68db      	ldr	r3, [r3, #12]
 800ddac:	603b      	str	r3, [r7, #0]

		ifptr = fp->fptr;
 800ddae:	687b      	ldr	r3, [r7, #4]
 800ddb0:	689b      	ldr	r3, [r3, #8]
 800ddb2:	613b      	str	r3, [r7, #16]
		fp->fptr = nsect = 0;
 800ddb4:	f04f 0300 	mov.w	r3, #0
 800ddb8:	61bb      	str	r3, [r7, #24]
 800ddba:	687b      	ldr	r3, [r7, #4]
 800ddbc:	69ba      	ldr	r2, [r7, #24]
 800ddbe:	609a      	str	r2, [r3, #8]
		if (ofs) {
 800ddc0:	683b      	ldr	r3, [r7, #0]
 800ddc2:	2b00      	cmp	r3, #0
 800ddc4:	f000 80cf 	beq.w	800df66 <f_lseek+0x20e>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 800ddc8:	687b      	ldr	r3, [r7, #4]
 800ddca:	681b      	ldr	r3, [r3, #0]
 800ddcc:	789b      	ldrb	r3, [r3, #2]
 800ddce:	ea4f 2343 	mov.w	r3, r3, lsl #9
 800ddd2:	60fb      	str	r3, [r7, #12]
			if (ifptr > 0 &&
 800ddd4:	693b      	ldr	r3, [r7, #16]
 800ddd6:	2b00      	cmp	r3, #0
 800ddd8:	d01f      	beq.n	800de1a <f_lseek+0xc2>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 800ddda:	683b      	ldr	r3, [r7, #0]
 800dddc:	f103 32ff 	add.w	r2, r3, #4294967295
 800dde0:	68fb      	ldr	r3, [r7, #12]
 800dde2:	fbb2 f2f3 	udiv	r2, r2, r3
 800dde6:	693b      	ldr	r3, [r7, #16]
 800dde8:	f103 31ff 	add.w	r1, r3, #4294967295
 800ddec:	68fb      	ldr	r3, [r7, #12]
 800ddee:	fbb1 f3f3 	udiv	r3, r1, r3

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
 800ddf2:	429a      	cmp	r2, r3
 800ddf4:	d311      	bcc.n	800de1a <f_lseek+0xc2>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 800ddf6:	693b      	ldr	r3, [r7, #16]
 800ddf8:	f103 32ff 	add.w	r2, r3, #4294967295
 800ddfc:	68fb      	ldr	r3, [r7, #12]
 800ddfe:	f1c3 0300 	rsb	r3, r3, #0
 800de02:	401a      	ands	r2, r3
 800de04:	687b      	ldr	r3, [r7, #4]
 800de06:	609a      	str	r2, [r3, #8]
				ofs -= fp->fptr;
 800de08:	687b      	ldr	r3, [r7, #4]
 800de0a:	689b      	ldr	r3, [r3, #8]
 800de0c:	683a      	ldr	r2, [r7, #0]
 800de0e:	1ad3      	subs	r3, r2, r3
 800de10:	603b      	str	r3, [r7, #0]
				clst = fp->clust;
 800de12:	687b      	ldr	r3, [r7, #4]
 800de14:	695b      	ldr	r3, [r3, #20]
 800de16:	61fb      	str	r3, [r7, #28]
 800de18:	e02e      	b.n	800de78 <f_lseek+0x120>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
 800de1a:	687b      	ldr	r3, [r7, #4]
 800de1c:	691b      	ldr	r3, [r3, #16]
 800de1e:	61fb      	str	r3, [r7, #28]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 800de20:	69fb      	ldr	r3, [r7, #28]
 800de22:	2b00      	cmp	r3, #0
 800de24:	d125      	bne.n	800de72 <f_lseek+0x11a>
					clst = create_chain(fp->fs, 0);
 800de26:	687b      	ldr	r3, [r7, #4]
 800de28:	681b      	ldr	r3, [r3, #0]
 800de2a:	4618      	mov	r0, r3
 800de2c:	f04f 0100 	mov.w	r1, #0
 800de30:	f7fd ffd0 	bl	800bdd4 <create_chain>
 800de34:	61f8      	str	r0, [r7, #28]
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 800de36:	69fb      	ldr	r3, [r7, #28]
 800de38:	2b01      	cmp	r3, #1
 800de3a:	d109      	bne.n	800de50 <f_lseek+0xf8>
 800de3c:	687b      	ldr	r3, [r7, #4]
 800de3e:	799b      	ldrb	r3, [r3, #6]
 800de40:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800de44:	b2da      	uxtb	r2, r3
 800de46:	687b      	ldr	r3, [r7, #4]
 800de48:	719a      	strb	r2, [r3, #6]
 800de4a:	f04f 0302 	mov.w	r3, #2
 800de4e:	e0ef      	b.n	800e030 <f_lseek+0x2d8>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 800de50:	69fb      	ldr	r3, [r7, #28]
 800de52:	f1b3 3fff 	cmp.w	r3, #4294967295
 800de56:	d109      	bne.n	800de6c <f_lseek+0x114>
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	799b      	ldrb	r3, [r3, #6]
 800de5c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800de60:	b2da      	uxtb	r2, r3
 800de62:	687b      	ldr	r3, [r7, #4]
 800de64:	719a      	strb	r2, [r3, #6]
 800de66:	f04f 0301 	mov.w	r3, #1
 800de6a:	e0e1      	b.n	800e030 <f_lseek+0x2d8>
					fp->sclust = clst;
 800de6c:	687b      	ldr	r3, [r7, #4]
 800de6e:	69fa      	ldr	r2, [r7, #28]
 800de70:	611a      	str	r2, [r3, #16]
				}
#endif
				fp->clust = clst;
 800de72:	687b      	ldr	r3, [r7, #4]
 800de74:	69fa      	ldr	r2, [r7, #28]
 800de76:	615a      	str	r2, [r3, #20]
			}
			if (clst != 0) {
 800de78:	69fb      	ldr	r3, [r7, #28]
 800de7a:	2b00      	cmp	r3, #0
 800de7c:	d073      	beq.n	800df66 <f_lseek+0x20e>
				while (ofs > bcs) {						/* Cluster following loop */
 800de7e:	e047      	b.n	800df10 <f_lseek+0x1b8>
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 800de80:	687b      	ldr	r3, [r7, #4]
 800de82:	799b      	ldrb	r3, [r3, #6]
 800de84:	f003 0302 	and.w	r3, r3, #2
 800de88:	2b00      	cmp	r3, #0
 800de8a:	d00c      	beq.n	800dea6 <f_lseek+0x14e>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 800de8c:	687b      	ldr	r3, [r7, #4]
 800de8e:	681b      	ldr	r3, [r3, #0]
 800de90:	4618      	mov	r0, r3
 800de92:	69f9      	ldr	r1, [r7, #28]
 800de94:	f7fd ff9e 	bl	800bdd4 <create_chain>
 800de98:	61f8      	str	r0, [r7, #28]
						if (clst == 0) {				/* When disk gets full, clip file size */
 800de9a:	69fb      	ldr	r3, [r7, #28]
 800de9c:	2b00      	cmp	r3, #0
 800de9e:	d109      	bne.n	800deb4 <f_lseek+0x15c>
							ofs = bcs; break;
 800dea0:	68fb      	ldr	r3, [r7, #12]
 800dea2:	603b      	str	r3, [r7, #0]
 800dea4:	e038      	b.n	800df18 <f_lseek+0x1c0>
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
 800dea6:	687b      	ldr	r3, [r7, #4]
 800dea8:	681b      	ldr	r3, [r3, #0]
 800deaa:	4618      	mov	r0, r3
 800deac:	69f9      	ldr	r1, [r7, #28]
 800deae:	f7fd fd07 	bl	800b8c0 <get_fat>
 800deb2:	61f8      	str	r0, [r7, #28]
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 800deb4:	69fb      	ldr	r3, [r7, #28]
 800deb6:	f1b3 3fff 	cmp.w	r3, #4294967295
 800deba:	d109      	bne.n	800ded0 <f_lseek+0x178>
 800debc:	687b      	ldr	r3, [r7, #4]
 800debe:	799b      	ldrb	r3, [r3, #6]
 800dec0:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800dec4:	b2da      	uxtb	r2, r3
 800dec6:	687b      	ldr	r3, [r7, #4]
 800dec8:	719a      	strb	r2, [r3, #6]
 800deca:	f04f 0301 	mov.w	r3, #1
 800dece:	e0af      	b.n	800e030 <f_lseek+0x2d8>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 800ded0:	69fb      	ldr	r3, [r7, #28]
 800ded2:	2b01      	cmp	r3, #1
 800ded4:	d905      	bls.n	800dee2 <f_lseek+0x18a>
 800ded6:	687b      	ldr	r3, [r7, #4]
 800ded8:	681b      	ldr	r3, [r3, #0]
 800deda:	69da      	ldr	r2, [r3, #28]
 800dedc:	69fb      	ldr	r3, [r7, #28]
 800dede:	429a      	cmp	r2, r3
 800dee0:	d809      	bhi.n	800def6 <f_lseek+0x19e>
 800dee2:	687b      	ldr	r3, [r7, #4]
 800dee4:	799b      	ldrb	r3, [r3, #6]
 800dee6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800deea:	b2da      	uxtb	r2, r3
 800deec:	687b      	ldr	r3, [r7, #4]
 800deee:	719a      	strb	r2, [r3, #6]
 800def0:	f04f 0302 	mov.w	r3, #2
 800def4:	e09c      	b.n	800e030 <f_lseek+0x2d8>
					fp->clust = clst;
 800def6:	687b      	ldr	r3, [r7, #4]
 800def8:	69fa      	ldr	r2, [r7, #28]
 800defa:	615a      	str	r2, [r3, #20]
					fp->fptr += bcs;
 800defc:	687b      	ldr	r3, [r7, #4]
 800defe:	689a      	ldr	r2, [r3, #8]
 800df00:	68fb      	ldr	r3, [r7, #12]
 800df02:	18d2      	adds	r2, r2, r3
 800df04:	687b      	ldr	r3, [r7, #4]
 800df06:	609a      	str	r2, [r3, #8]
					ofs -= bcs;
 800df08:	683a      	ldr	r2, [r7, #0]
 800df0a:	68fb      	ldr	r3, [r7, #12]
 800df0c:	1ad3      	subs	r3, r2, r3
 800df0e:	603b      	str	r3, [r7, #0]
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
 800df10:	683a      	ldr	r2, [r7, #0]
 800df12:	68fb      	ldr	r3, [r7, #12]
 800df14:	429a      	cmp	r2, r3
 800df16:	d8b3      	bhi.n	800de80 <f_lseek+0x128>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
 800df18:	687b      	ldr	r3, [r7, #4]
 800df1a:	689a      	ldr	r2, [r3, #8]
 800df1c:	683b      	ldr	r3, [r7, #0]
 800df1e:	18d2      	adds	r2, r2, r3
 800df20:	687b      	ldr	r3, [r7, #4]
 800df22:	609a      	str	r2, [r3, #8]
				if (ofs % SS(fp->fs)) {
 800df24:	683b      	ldr	r3, [r7, #0]
 800df26:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800df2a:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800df2e:	2b00      	cmp	r3, #0
 800df30:	d019      	beq.n	800df66 <f_lseek+0x20e>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
 800df32:	687b      	ldr	r3, [r7, #4]
 800df34:	681b      	ldr	r3, [r3, #0]
 800df36:	4618      	mov	r0, r3
 800df38:	69f9      	ldr	r1, [r7, #28]
 800df3a:	f7fd fc9f 	bl	800b87c <clust2sect>
 800df3e:	61b8      	str	r0, [r7, #24]
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 800df40:	69bb      	ldr	r3, [r7, #24]
 800df42:	2b00      	cmp	r3, #0
 800df44:	d109      	bne.n	800df5a <f_lseek+0x202>
 800df46:	687b      	ldr	r3, [r7, #4]
 800df48:	799b      	ldrb	r3, [r3, #6]
 800df4a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800df4e:	b2da      	uxtb	r2, r3
 800df50:	687b      	ldr	r3, [r7, #4]
 800df52:	719a      	strb	r2, [r3, #6]
 800df54:	f04f 0302 	mov.w	r3, #2
 800df58:	e06a      	b.n	800e030 <f_lseek+0x2d8>
					nsect += ofs / SS(fp->fs);
 800df5a:	683b      	ldr	r3, [r7, #0]
 800df5c:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800df60:	69ba      	ldr	r2, [r7, #24]
 800df62:	18d3      	adds	r3, r2, r3
 800df64:	61bb      	str	r3, [r7, #24]
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 800df66:	687b      	ldr	r3, [r7, #4]
 800df68:	689b      	ldr	r3, [r3, #8]
 800df6a:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 800df6e:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 800df72:	2b00      	cmp	r3, #0
 800df74:	d04a      	beq.n	800e00c <f_lseek+0x2b4>
 800df76:	687b      	ldr	r3, [r7, #4]
 800df78:	699a      	ldr	r2, [r3, #24]
 800df7a:	69bb      	ldr	r3, [r7, #24]
 800df7c:	429a      	cmp	r2, r3
 800df7e:	d045      	beq.n	800e00c <f_lseek+0x2b4>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
 800df80:	687b      	ldr	r3, [r7, #4]
 800df82:	799b      	ldrb	r3, [r3, #6]
 800df84:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800df88:	2b00      	cmp	r3, #0
 800df8a:	d022      	beq.n	800dfd2 <f_lseek+0x27a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
 800df8c:	687b      	ldr	r3, [r7, #4]
 800df8e:	681b      	ldr	r3, [r3, #0]
 800df90:	7859      	ldrb	r1, [r3, #1]
 800df92:	687b      	ldr	r3, [r7, #4]
 800df94:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800df98:	687b      	ldr	r3, [r7, #4]
 800df9a:	699b      	ldr	r3, [r3, #24]
 800df9c:	4608      	mov	r0, r1
 800df9e:	4611      	mov	r1, r2
 800dfa0:	461a      	mov	r2, r3
 800dfa2:	f04f 0301 	mov.w	r3, #1
 800dfa6:	f7fd f9ed 	bl	800b384 <disk_write>
 800dfaa:	4603      	mov	r3, r0
 800dfac:	2b00      	cmp	r3, #0
 800dfae:	d009      	beq.n	800dfc4 <f_lseek+0x26c>
					ABORT(fp->fs, FR_DISK_ERR);
 800dfb0:	687b      	ldr	r3, [r7, #4]
 800dfb2:	799b      	ldrb	r3, [r3, #6]
 800dfb4:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800dfb8:	b2da      	uxtb	r2, r3
 800dfba:	687b      	ldr	r3, [r7, #4]
 800dfbc:	719a      	strb	r2, [r3, #6]
 800dfbe:	f04f 0301 	mov.w	r3, #1
 800dfc2:	e035      	b.n	800e030 <f_lseek+0x2d8>
				fp->flag &= ~FA__DIRTY;
 800dfc4:	687b      	ldr	r3, [r7, #4]
 800dfc6:	799b      	ldrb	r3, [r3, #6]
 800dfc8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800dfcc:	b2da      	uxtb	r2, r3
 800dfce:	687b      	ldr	r3, [r7, #4]
 800dfd0:	719a      	strb	r2, [r3, #6]
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
 800dfd2:	687b      	ldr	r3, [r7, #4]
 800dfd4:	681b      	ldr	r3, [r3, #0]
 800dfd6:	785a      	ldrb	r2, [r3, #1]
 800dfd8:	687b      	ldr	r3, [r7, #4]
 800dfda:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800dfde:	4610      	mov	r0, r2
 800dfe0:	4619      	mov	r1, r3
 800dfe2:	69ba      	ldr	r2, [r7, #24]
 800dfe4:	f04f 0301 	mov.w	r3, #1
 800dfe8:	f7fd f98a 	bl	800b300 <disk_read>
 800dfec:	4603      	mov	r3, r0
 800dfee:	2b00      	cmp	r3, #0
 800dff0:	d009      	beq.n	800e006 <f_lseek+0x2ae>
				ABORT(fp->fs, FR_DISK_ERR);
 800dff2:	687b      	ldr	r3, [r7, #4]
 800dff4:	799b      	ldrb	r3, [r3, #6]
 800dff6:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800dffa:	b2da      	uxtb	r2, r3
 800dffc:	687b      	ldr	r3, [r7, #4]
 800dffe:	719a      	strb	r2, [r3, #6]
 800e000:	f04f 0301 	mov.w	r3, #1
 800e004:	e014      	b.n	800e030 <f_lseek+0x2d8>
#endif
			fp->dsect = nsect;
 800e006:	687b      	ldr	r3, [r7, #4]
 800e008:	69ba      	ldr	r2, [r7, #24]
 800e00a:	619a      	str	r2, [r3, #24]
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
 800e00c:	687b      	ldr	r3, [r7, #4]
 800e00e:	689a      	ldr	r2, [r3, #8]
 800e010:	687b      	ldr	r3, [r7, #4]
 800e012:	68db      	ldr	r3, [r3, #12]
 800e014:	429a      	cmp	r2, r3
 800e016:	d90a      	bls.n	800e02e <f_lseek+0x2d6>
			fp->fsize = fp->fptr;
 800e018:	687b      	ldr	r3, [r7, #4]
 800e01a:	689a      	ldr	r2, [r3, #8]
 800e01c:	687b      	ldr	r3, [r7, #4]
 800e01e:	60da      	str	r2, [r3, #12]
			fp->flag |= FA__WRITTEN;
 800e020:	687b      	ldr	r3, [r7, #4]
 800e022:	799b      	ldrb	r3, [r3, #6]
 800e024:	f043 0320 	orr.w	r3, r3, #32
 800e028:	b2da      	uxtb	r2, r3
 800e02a:	687b      	ldr	r3, [r7, #4]
 800e02c:	719a      	strb	r2, [r3, #6]
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
 800e02e:	7dfb      	ldrb	r3, [r7, #23]
}
 800e030:	4618      	mov	r0, r3
 800e032:	f107 0720 	add.w	r7, r7, #32
 800e036:	46bd      	mov	sp, r7
 800e038:	bd80      	pop	{r7, pc}
 800e03a:	bf00      	nop

0800e03c <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
 800e03c:	b580      	push	{r7, lr}
 800e03e:	b086      	sub	sp, #24
 800e040:	af00      	add	r7, sp, #0
 800e042:	6078      	str	r0, [r7, #4]
 800e044:	6039      	str	r1, [r7, #0]
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
 800e046:	687b      	ldr	r3, [r7, #4]
 800e048:	463a      	mov	r2, r7
 800e04a:	4610      	mov	r0, r2
 800e04c:	4619      	mov	r1, r3
 800e04e:	f04f 0200 	mov.w	r2, #0
 800e052:	f7fe fcdb 	bl	800ca0c <chk_mounted>
 800e056:	4603      	mov	r3, r0
 800e058:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800e05a:	7dfb      	ldrb	r3, [r7, #23]
 800e05c:	2b00      	cmp	r3, #0
 800e05e:	d158      	bne.n	800e112 <f_opendir+0xd6>
		INIT_BUF(*dj);
 800e060:	687b      	ldr	r3, [r7, #4]
 800e062:	f107 0208 	add.w	r2, r7, #8
 800e066:	619a      	str	r2, [r3, #24]
		res = follow_path(dj, path);			/* Follow the path to the directory */
 800e068:	683b      	ldr	r3, [r7, #0]
 800e06a:	6878      	ldr	r0, [r7, #4]
 800e06c:	4619      	mov	r1, r3
 800e06e:	f7fe fbb1 	bl	800c7d4 <follow_path>
 800e072:	4603      	mov	r3, r0
 800e074:	75fb      	strb	r3, [r7, #23]
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
 800e076:	7dfb      	ldrb	r3, [r7, #23]
 800e078:	2b00      	cmp	r3, #0
 800e07a:	d144      	bne.n	800e106 <f_opendir+0xca>
			if (dj->dir) {						/* It is not the root dir */
 800e07c:	687b      	ldr	r3, [r7, #4]
 800e07e:	695b      	ldr	r3, [r3, #20]
 800e080:	2b00      	cmp	r3, #0
 800e082:	d031      	beq.n	800e0e8 <f_opendir+0xac>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
 800e084:	687b      	ldr	r3, [r7, #4]
 800e086:	695b      	ldr	r3, [r3, #20]
 800e088:	f103 030b 	add.w	r3, r3, #11
 800e08c:	781b      	ldrb	r3, [r3, #0]
 800e08e:	f003 0310 	and.w	r3, r3, #16
 800e092:	2b00      	cmp	r3, #0
 800e094:	d025      	beq.n	800e0e2 <f_opendir+0xa6>
					dj->sclust = LD_CLUST(dj->dir);
 800e096:	687b      	ldr	r3, [r7, #4]
 800e098:	695b      	ldr	r3, [r3, #20]
 800e09a:	f103 0315 	add.w	r3, r3, #21
 800e09e:	781b      	ldrb	r3, [r3, #0]
 800e0a0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800e0a4:	b29a      	uxth	r2, r3
 800e0a6:	687b      	ldr	r3, [r7, #4]
 800e0a8:	695b      	ldr	r3, [r3, #20]
 800e0aa:	f103 0314 	add.w	r3, r3, #20
 800e0ae:	781b      	ldrb	r3, [r3, #0]
 800e0b0:	4313      	orrs	r3, r2
 800e0b2:	b29b      	uxth	r3, r3
 800e0b4:	b29b      	uxth	r3, r3
 800e0b6:	ea4f 4203 	mov.w	r2, r3, lsl #16
 800e0ba:	687b      	ldr	r3, [r7, #4]
 800e0bc:	695b      	ldr	r3, [r3, #20]
 800e0be:	f103 031b 	add.w	r3, r3, #27
 800e0c2:	781b      	ldrb	r3, [r3, #0]
 800e0c4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800e0c8:	b299      	uxth	r1, r3
 800e0ca:	687b      	ldr	r3, [r7, #4]
 800e0cc:	695b      	ldr	r3, [r3, #20]
 800e0ce:	f103 031a 	add.w	r3, r3, #26
 800e0d2:	781b      	ldrb	r3, [r3, #0]
 800e0d4:	430b      	orrs	r3, r1
 800e0d6:	b29b      	uxth	r3, r3
 800e0d8:	b29b      	uxth	r3, r3
 800e0da:	431a      	orrs	r2, r3
 800e0dc:	687b      	ldr	r3, [r7, #4]
 800e0de:	609a      	str	r2, [r3, #8]
 800e0e0:	e002      	b.n	800e0e8 <f_opendir+0xac>
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
 800e0e2:	f04f 0305 	mov.w	r3, #5
 800e0e6:	75fb      	strb	r3, [r7, #23]
				}
			}
			if (res == FR_OK) {
 800e0e8:	7dfb      	ldrb	r3, [r7, #23]
 800e0ea:	2b00      	cmp	r3, #0
 800e0ec:	d10b      	bne.n	800e106 <f_opendir+0xca>
				dj->id = dj->fs->id;
 800e0ee:	687b      	ldr	r3, [r7, #4]
 800e0f0:	681b      	ldr	r3, [r3, #0]
 800e0f2:	88da      	ldrh	r2, [r3, #6]
 800e0f4:	687b      	ldr	r3, [r7, #4]
 800e0f6:	809a      	strh	r2, [r3, #4]
				res = dir_sdi(dj, 0);			/* Rewind dir */
 800e0f8:	6878      	ldr	r0, [r7, #4]
 800e0fa:	f04f 0100 	mov.w	r1, #0
 800e0fe:	f7fd feff 	bl	800bf00 <dir_sdi>
 800e102:	4603      	mov	r3, r0
 800e104:	75fb      	strb	r3, [r7, #23]
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 800e106:	7dfb      	ldrb	r3, [r7, #23]
 800e108:	2b04      	cmp	r3, #4
 800e10a:	d102      	bne.n	800e112 <f_opendir+0xd6>
 800e10c:	f04f 0305 	mov.w	r3, #5
 800e110:	75fb      	strb	r3, [r7, #23]
	}

	LEAVE_FF(dj->fs, res);
 800e112:	7dfb      	ldrb	r3, [r7, #23]
}
 800e114:	4618      	mov	r0, r3
 800e116:	f107 0718 	add.w	r7, r7, #24
 800e11a:	46bd      	mov	sp, r7
 800e11c:	bd80      	pop	{r7, pc}
 800e11e:	bf00      	nop

0800e120 <f_readdir>:

FRESULT f_readdir (
	DIR *dj,			/* Pointer to the open directory object */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 800e120:	b580      	push	{r7, lr}
 800e122:	b086      	sub	sp, #24
 800e124:	af00      	add	r7, sp, #0
 800e126:	6078      	str	r0, [r7, #4]
 800e128:	6039      	str	r1, [r7, #0]
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dj->fs, dj->id);			/* Check validity of the object */
 800e12a:	687b      	ldr	r3, [r7, #4]
 800e12c:	681a      	ldr	r2, [r3, #0]
 800e12e:	687b      	ldr	r3, [r7, #4]
 800e130:	889b      	ldrh	r3, [r3, #4]
 800e132:	4610      	mov	r0, r2
 800e134:	4619      	mov	r1, r3
 800e136:	f7fe ff6f 	bl	800d018 <validate>
 800e13a:	4603      	mov	r3, r0
 800e13c:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 800e13e:	7dfb      	ldrb	r3, [r7, #23]
 800e140:	2b00      	cmp	r3, #0
 800e142:	d135      	bne.n	800e1b0 <f_readdir+0x90>
		if (!fno) {
 800e144:	683b      	ldr	r3, [r7, #0]
 800e146:	2b00      	cmp	r3, #0
 800e148:	d107      	bne.n	800e15a <f_readdir+0x3a>
			res = dir_sdi(dj, 0);			/* Rewind the directory object */
 800e14a:	6878      	ldr	r0, [r7, #4]
 800e14c:	f04f 0100 	mov.w	r1, #0
 800e150:	f7fd fed6 	bl	800bf00 <dir_sdi>
 800e154:	4603      	mov	r3, r0
 800e156:	75fb      	strb	r3, [r7, #23]
 800e158:	e02a      	b.n	800e1b0 <f_readdir+0x90>
		} else {
			INIT_BUF(*dj);
 800e15a:	687b      	ldr	r3, [r7, #4]
 800e15c:	f107 0208 	add.w	r2, r7, #8
 800e160:	619a      	str	r2, [r3, #24]
			res = dir_read(dj);				/* Read an directory item */
 800e162:	6878      	ldr	r0, [r7, #4]
 800e164:	f7fe f89c 	bl	800c2a0 <dir_read>
 800e168:	4603      	mov	r3, r0
 800e16a:	75fb      	strb	r3, [r7, #23]
			if (res == FR_NO_FILE) {		/* Reached end of dir */
 800e16c:	7dfb      	ldrb	r3, [r7, #23]
 800e16e:	2b04      	cmp	r3, #4
 800e170:	d106      	bne.n	800e180 <f_readdir+0x60>
				dj->sect = 0;
 800e172:	687b      	ldr	r3, [r7, #4]
 800e174:	f04f 0200 	mov.w	r2, #0
 800e178:	611a      	str	r2, [r3, #16]
				res = FR_OK;
 800e17a:	f04f 0300 	mov.w	r3, #0
 800e17e:	75fb      	strb	r3, [r7, #23]
			}
			if (res == FR_OK) {				/* A valid entry is found */
 800e180:	7dfb      	ldrb	r3, [r7, #23]
 800e182:	2b00      	cmp	r3, #0
 800e184:	d114      	bne.n	800e1b0 <f_readdir+0x90>
				get_fileinfo(dj, fno);		/* Get the object information */
 800e186:	6878      	ldr	r0, [r7, #4]
 800e188:	6839      	ldr	r1, [r7, #0]
 800e18a:	f7fe fa7b 	bl	800c684 <get_fileinfo>
				res = dir_next(dj, 0);		/* Increment index for next */
 800e18e:	6878      	ldr	r0, [r7, #4]
 800e190:	f04f 0100 	mov.w	r1, #0
 800e194:	f7fd ff42 	bl	800c01c <dir_next>
 800e198:	4603      	mov	r3, r0
 800e19a:	75fb      	strb	r3, [r7, #23]
				if (res == FR_NO_FILE) {
 800e19c:	7dfb      	ldrb	r3, [r7, #23]
 800e19e:	2b04      	cmp	r3, #4
 800e1a0:	d106      	bne.n	800e1b0 <f_readdir+0x90>
					dj->sect = 0;
 800e1a2:	687b      	ldr	r3, [r7, #4]
 800e1a4:	f04f 0200 	mov.w	r2, #0
 800e1a8:	611a      	str	r2, [r3, #16]
					res = FR_OK;
 800e1aa:	f04f 0300 	mov.w	r3, #0
 800e1ae:	75fb      	strb	r3, [r7, #23]
			}
			FREE_BUF();
		}
	}

	LEAVE_FF(dj->fs, res);
 800e1b0:	7dfb      	ldrb	r3, [r7, #23]
}
 800e1b2:	4618      	mov	r0, r3
 800e1b4:	f107 0718 	add.w	r7, r7, #24
 800e1b8:	46bd      	mov	sp, r7
 800e1ba:	bd80      	pop	{r7, pc}

0800e1bc <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
 800e1bc:	b580      	push	{r7, lr}
 800e1be:	b08e      	sub	sp, #56	; 0x38
 800e1c0:	af00      	add	r7, sp, #0
 800e1c2:	6078      	str	r0, [r7, #4]
 800e1c4:	6039      	str	r1, [r7, #0]
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
 800e1c6:	f107 0204 	add.w	r2, r7, #4
 800e1ca:	f107 0318 	add.w	r3, r7, #24
 800e1ce:	4610      	mov	r0, r2
 800e1d0:	4619      	mov	r1, r3
 800e1d2:	f04f 0200 	mov.w	r2, #0
 800e1d6:	f7fe fc19 	bl	800ca0c <chk_mounted>
 800e1da:	4603      	mov	r3, r0
 800e1dc:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 800e1e0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800e1e4:	2b00      	cmp	r3, #0
 800e1e6:	d11e      	bne.n	800e226 <f_stat+0x6a>
		INIT_BUF(dj);
 800e1e8:	f107 030c 	add.w	r3, r7, #12
 800e1ec:	633b      	str	r3, [r7, #48]	; 0x30
		res = follow_path(&dj, path);	/* Follow the file path */
 800e1ee:	687b      	ldr	r3, [r7, #4]
 800e1f0:	f107 0218 	add.w	r2, r7, #24
 800e1f4:	4610      	mov	r0, r2
 800e1f6:	4619      	mov	r1, r3
 800e1f8:	f7fe faec 	bl	800c7d4 <follow_path>
 800e1fc:	4603      	mov	r3, r0
 800e1fe:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (res == FR_OK) {				/* Follow completed */
 800e202:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800e206:	2b00      	cmp	r3, #0
 800e208:	d10d      	bne.n	800e226 <f_stat+0x6a>
			if (dj.dir)		/* Found an object */
 800e20a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e20c:	2b00      	cmp	r3, #0
 800e20e:	d006      	beq.n	800e21e <f_stat+0x62>
				get_fileinfo(&dj, fno);
 800e210:	f107 0318 	add.w	r3, r7, #24
 800e214:	4618      	mov	r0, r3
 800e216:	6839      	ldr	r1, [r7, #0]
 800e218:	f7fe fa34 	bl	800c684 <get_fileinfo>
 800e21c:	e003      	b.n	800e226 <f_stat+0x6a>
			else			/* It is root dir */
				res = FR_INVALID_NAME;
 800e21e:	f04f 0306 	mov.w	r3, #6
 800e222:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
 800e226:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 800e22a:	4618      	mov	r0, r3
 800e22c:	f107 0738 	add.w	r7, r7, #56	; 0x38
 800e230:	46bd      	mov	sp, r7
 800e232:	bd80      	pop	{r7, pc}

0800e234 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
 800e234:	b580      	push	{r7, lr}
 800e236:	b08c      	sub	sp, #48	; 0x30
 800e238:	af00      	add	r7, sp, #0
 800e23a:	60f8      	str	r0, [r7, #12]
 800e23c:	60b9      	str	r1, [r7, #8]
 800e23e:	607a      	str	r2, [r7, #4]
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
 800e240:	f107 030c 	add.w	r3, r7, #12
 800e244:	4618      	mov	r0, r3
 800e246:	6879      	ldr	r1, [r7, #4]
 800e248:	f04f 0200 	mov.w	r2, #0
 800e24c:	f7fe fbde 	bl	800ca0c <chk_mounted>
 800e250:	4603      	mov	r3, r0
 800e252:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (res == FR_OK) {
 800e256:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800e25a:	2b00      	cmp	r3, #0
 800e25c:	f040 80cf 	bne.w	800e3fe <f_getfree+0x1ca>
		/* If free_clust is valid, return it without full cluster scan */
		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
 800e260:	687b      	ldr	r3, [r7, #4]
 800e262:	681b      	ldr	r3, [r3, #0]
 800e264:	691a      	ldr	r2, [r3, #16]
 800e266:	687b      	ldr	r3, [r7, #4]
 800e268:	681b      	ldr	r3, [r3, #0]
 800e26a:	69db      	ldr	r3, [r3, #28]
 800e26c:	f1a3 0302 	sub.w	r3, r3, #2
 800e270:	429a      	cmp	r2, r3
 800e272:	d805      	bhi.n	800e280 <f_getfree+0x4c>
			*nclst = (*fatfs)->free_clust;
 800e274:	687b      	ldr	r3, [r7, #4]
 800e276:	681b      	ldr	r3, [r3, #0]
 800e278:	691a      	ldr	r2, [r3, #16]
 800e27a:	68bb      	ldr	r3, [r7, #8]
 800e27c:	601a      	str	r2, [r3, #0]
 800e27e:	e0be      	b.n	800e3fe <f_getfree+0x1ca>
		} else {
			/* Get number of free clusters */
			fat = (*fatfs)->fs_type;
 800e280:	687b      	ldr	r3, [r7, #4]
 800e282:	681b      	ldr	r3, [r3, #0]
 800e284:	781b      	ldrb	r3, [r3, #0]
 800e286:	75fb      	strb	r3, [r7, #23]
			n = 0;
 800e288:	f04f 0300 	mov.w	r3, #0
 800e28c:	62bb      	str	r3, [r7, #40]	; 0x28
			if (fat == FS_FAT12) {
 800e28e:	7dfb      	ldrb	r3, [r7, #23]
 800e290:	2b01      	cmp	r3, #1
 800e292:	d12d      	bne.n	800e2f0 <f_getfree+0xbc>
				clst = 2;
 800e294:	f04f 0302 	mov.w	r3, #2
 800e298:	627b      	str	r3, [r7, #36]	; 0x24
				do {
					stat = get_fat(*fatfs, clst);
 800e29a:	687b      	ldr	r3, [r7, #4]
 800e29c:	681b      	ldr	r3, [r3, #0]
 800e29e:	4618      	mov	r0, r3
 800e2a0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800e2a2:	f7fd fb0d 	bl	800b8c0 <get_fat>
 800e2a6:	6138      	str	r0, [r7, #16]
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 800e2a8:	693b      	ldr	r3, [r7, #16]
 800e2aa:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e2ae:	d104      	bne.n	800e2ba <f_getfree+0x86>
 800e2b0:	f04f 0301 	mov.w	r3, #1
 800e2b4:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800e2b8:	e092      	b.n	800e3e0 <f_getfree+0x1ac>
					if (stat == 1) { res = FR_INT_ERR; break; }
 800e2ba:	693b      	ldr	r3, [r7, #16]
 800e2bc:	2b01      	cmp	r3, #1
 800e2be:	d105      	bne.n	800e2cc <f_getfree+0x98>
 800e2c0:	f04f 0302 	mov.w	r3, #2
 800e2c4:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 800e2c8:	bf00      	nop
 800e2ca:	e089      	b.n	800e3e0 <f_getfree+0x1ac>
					if (stat == 0) n++;
 800e2cc:	693b      	ldr	r3, [r7, #16]
 800e2ce:	2b00      	cmp	r3, #0
 800e2d0:	d103      	bne.n	800e2da <f_getfree+0xa6>
 800e2d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e2d4:	f103 0301 	add.w	r3, r3, #1
 800e2d8:	62bb      	str	r3, [r7, #40]	; 0x28
				} while (++clst < (*fatfs)->n_fatent);
 800e2da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e2dc:	f103 0301 	add.w	r3, r3, #1
 800e2e0:	627b      	str	r3, [r7, #36]	; 0x24
 800e2e2:	687b      	ldr	r3, [r7, #4]
 800e2e4:	681b      	ldr	r3, [r3, #0]
 800e2e6:	69db      	ldr	r3, [r3, #28]
 800e2e8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e2ea:	429a      	cmp	r2, r3
 800e2ec:	d3d5      	bcc.n	800e29a <f_getfree+0x66>
 800e2ee:	e077      	b.n	800e3e0 <f_getfree+0x1ac>
			} else {
				clst = (*fatfs)->n_fatent;
 800e2f0:	687b      	ldr	r3, [r7, #4]
 800e2f2:	681b      	ldr	r3, [r3, #0]
 800e2f4:	69db      	ldr	r3, [r3, #28]
 800e2f6:	627b      	str	r3, [r7, #36]	; 0x24
				sect = (*fatfs)->fatbase;
 800e2f8:	687b      	ldr	r3, [r7, #4]
 800e2fa:	681b      	ldr	r3, [r3, #0]
 800e2fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e2fe:	623b      	str	r3, [r7, #32]
				i = 0; p = 0;
 800e300:	f04f 0300 	mov.w	r3, #0
 800e304:	61fb      	str	r3, [r7, #28]
 800e306:	f04f 0300 	mov.w	r3, #0
 800e30a:	61bb      	str	r3, [r7, #24]
				do {
					if (!i) {
 800e30c:	69fb      	ldr	r3, [r7, #28]
 800e30e:	2b00      	cmp	r3, #0
 800e310:	d119      	bne.n	800e346 <f_getfree+0x112>
						res = move_window(*fatfs, sect++);
 800e312:	687b      	ldr	r3, [r7, #4]
 800e314:	681a      	ldr	r2, [r3, #0]
 800e316:	6a3b      	ldr	r3, [r7, #32]
 800e318:	6a39      	ldr	r1, [r7, #32]
 800e31a:	f101 0101 	add.w	r1, r1, #1
 800e31e:	6239      	str	r1, [r7, #32]
 800e320:	4610      	mov	r0, r2
 800e322:	4619      	mov	r1, r3
 800e324:	f7fd f980 	bl	800b628 <move_window>
 800e328:	4603      	mov	r3, r0
 800e32a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
						if (res != FR_OK) break;
 800e32e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 800e332:	2b00      	cmp	r3, #0
 800e334:	d153      	bne.n	800e3de <f_getfree+0x1aa>
						p = (*fatfs)->win;
 800e336:	687b      	ldr	r3, [r7, #4]
 800e338:	681b      	ldr	r3, [r3, #0]
 800e33a:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800e33e:	61bb      	str	r3, [r7, #24]
						i = SS(*fatfs);
 800e340:	f44f 7300 	mov.w	r3, #512	; 0x200
 800e344:	61fb      	str	r3, [r7, #28]
					}
					if (fat == FS_FAT16) {
 800e346:	7dfb      	ldrb	r3, [r7, #23]
 800e348:	2b02      	cmp	r3, #2
 800e34a:	d119      	bne.n	800e380 <f_getfree+0x14c>
						if (LD_WORD(p) == 0) n++;
 800e34c:	69bb      	ldr	r3, [r7, #24]
 800e34e:	f103 0301 	add.w	r3, r3, #1
 800e352:	781b      	ldrb	r3, [r3, #0]
 800e354:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800e358:	b29a      	uxth	r2, r3
 800e35a:	69bb      	ldr	r3, [r7, #24]
 800e35c:	781b      	ldrb	r3, [r3, #0]
 800e35e:	4313      	orrs	r3, r2
 800e360:	b29b      	uxth	r3, r3
 800e362:	2b00      	cmp	r3, #0
 800e364:	d103      	bne.n	800e36e <f_getfree+0x13a>
 800e366:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e368:	f103 0301 	add.w	r3, r3, #1
 800e36c:	62bb      	str	r3, [r7, #40]	; 0x28
						p += 2; i -= 2;
 800e36e:	69bb      	ldr	r3, [r7, #24]
 800e370:	f103 0302 	add.w	r3, r3, #2
 800e374:	61bb      	str	r3, [r7, #24]
 800e376:	69fb      	ldr	r3, [r7, #28]
 800e378:	f1a3 0302 	sub.w	r3, r3, #2
 800e37c:	61fb      	str	r3, [r7, #28]
 800e37e:	e026      	b.n	800e3ce <f_getfree+0x19a>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 800e380:	69bb      	ldr	r3, [r7, #24]
 800e382:	f103 0303 	add.w	r3, r3, #3
 800e386:	781b      	ldrb	r3, [r3, #0]
 800e388:	ea4f 6203 	mov.w	r2, r3, lsl #24
 800e38c:	69bb      	ldr	r3, [r7, #24]
 800e38e:	f103 0302 	add.w	r3, r3, #2
 800e392:	781b      	ldrb	r3, [r3, #0]
 800e394:	ea4f 4303 	mov.w	r3, r3, lsl #16
 800e398:	431a      	orrs	r2, r3
 800e39a:	69bb      	ldr	r3, [r7, #24]
 800e39c:	f103 0301 	add.w	r3, r3, #1
 800e3a0:	781b      	ldrb	r3, [r3, #0]
 800e3a2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800e3a6:	431a      	orrs	r2, r3
 800e3a8:	69bb      	ldr	r3, [r7, #24]
 800e3aa:	781b      	ldrb	r3, [r3, #0]
 800e3ac:	4313      	orrs	r3, r2
 800e3ae:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800e3b2:	2b00      	cmp	r3, #0
 800e3b4:	d103      	bne.n	800e3be <f_getfree+0x18a>
 800e3b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e3b8:	f103 0301 	add.w	r3, r3, #1
 800e3bc:	62bb      	str	r3, [r7, #40]	; 0x28
						p += 4; i -= 4;
 800e3be:	69bb      	ldr	r3, [r7, #24]
 800e3c0:	f103 0304 	add.w	r3, r3, #4
 800e3c4:	61bb      	str	r3, [r7, #24]
 800e3c6:	69fb      	ldr	r3, [r7, #28]
 800e3c8:	f1a3 0304 	sub.w	r3, r3, #4
 800e3cc:	61fb      	str	r3, [r7, #28]
					}
				} while (--clst);
 800e3ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e3d0:	f103 33ff 	add.w	r3, r3, #4294967295
 800e3d4:	627b      	str	r3, [r7, #36]	; 0x24
 800e3d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e3d8:	2b00      	cmp	r3, #0
 800e3da:	d197      	bne.n	800e30c <f_getfree+0xd8>
 800e3dc:	e000      	b.n	800e3e0 <f_getfree+0x1ac>
				sect = (*fatfs)->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(*fatfs, sect++);
						if (res != FR_OK) break;
 800e3de:	bf00      	nop
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			(*fatfs)->free_clust = n;
 800e3e0:	687b      	ldr	r3, [r7, #4]
 800e3e2:	681b      	ldr	r3, [r3, #0]
 800e3e4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e3e6:	611a      	str	r2, [r3, #16]
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
 800e3e8:	7dfb      	ldrb	r3, [r7, #23]
 800e3ea:	2b03      	cmp	r3, #3
 800e3ec:	d104      	bne.n	800e3f8 <f_getfree+0x1c4>
 800e3ee:	687b      	ldr	r3, [r7, #4]
 800e3f0:	681b      	ldr	r3, [r3, #0]
 800e3f2:	f04f 0201 	mov.w	r2, #1
 800e3f6:	715a      	strb	r2, [r3, #5]
			*nclst = n;
 800e3f8:	68bb      	ldr	r3, [r7, #8]
 800e3fa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800e3fc:	601a      	str	r2, [r3, #0]
		}
	}
	LEAVE_FF(*fatfs, res);
 800e3fe:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 800e402:	4618      	mov	r0, r3
 800e404:	f107 0730 	add.w	r7, r7, #48	; 0x30
 800e408:	46bd      	mov	sp, r7
 800e40a:	bd80      	pop	{r7, pc}

0800e40c <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
	FIL *fp		/* Pointer to the file object */
)
{
 800e40c:	b580      	push	{r7, lr}
 800e40e:	b084      	sub	sp, #16
 800e410:	af00      	add	r7, sp, #0
 800e412:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DWORD ncl;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
 800e414:	687b      	ldr	r3, [r7, #4]
 800e416:	681a      	ldr	r2, [r3, #0]
 800e418:	687b      	ldr	r3, [r7, #4]
 800e41a:	889b      	ldrh	r3, [r3, #4]
 800e41c:	4610      	mov	r0, r2
 800e41e:	4619      	mov	r1, r3
 800e420:	f7fe fdfa 	bl	800d018 <validate>
 800e424:	4603      	mov	r3, r0
 800e426:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 800e428:	7bfb      	ldrb	r3, [r7, #15]
 800e42a:	2b00      	cmp	r3, #0
 800e42c:	d112      	bne.n	800e454 <f_truncate+0x48>
		if (fp->flag & FA__ERROR) {			/* Check abort flag */
 800e42e:	687b      	ldr	r3, [r7, #4]
 800e430:	799b      	ldrb	r3, [r3, #6]
 800e432:	b2db      	uxtb	r3, r3
 800e434:	b25b      	sxtb	r3, r3
 800e436:	2b00      	cmp	r3, #0
 800e438:	da03      	bge.n	800e442 <f_truncate+0x36>
			res = FR_INT_ERR;
 800e43a:	f04f 0302 	mov.w	r3, #2
 800e43e:	73fb      	strb	r3, [r7, #15]
 800e440:	e008      	b.n	800e454 <f_truncate+0x48>
		} else {
			if (!(fp->flag & FA_WRITE))		/* Check access mode */
 800e442:	687b      	ldr	r3, [r7, #4]
 800e444:	799b      	ldrb	r3, [r3, #6]
 800e446:	f003 0302 	and.w	r3, r3, #2
 800e44a:	2b00      	cmp	r3, #0
 800e44c:	d102      	bne.n	800e454 <f_truncate+0x48>
				res = FR_DENIED;
 800e44e:	f04f 0307 	mov.w	r3, #7
 800e452:	73fb      	strb	r3, [r7, #15]
		}
	}
	if (res == FR_OK) {
 800e454:	7bfb      	ldrb	r3, [r7, #15]
 800e456:	2b00      	cmp	r3, #0
 800e458:	d166      	bne.n	800e528 <f_truncate+0x11c>
		if (fp->fsize > fp->fptr) {
 800e45a:	687b      	ldr	r3, [r7, #4]
 800e45c:	68da      	ldr	r2, [r3, #12]
 800e45e:	687b      	ldr	r3, [r7, #4]
 800e460:	689b      	ldr	r3, [r3, #8]
 800e462:	429a      	cmp	r2, r3
 800e464:	d956      	bls.n	800e514 <f_truncate+0x108>
			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
 800e466:	687b      	ldr	r3, [r7, #4]
 800e468:	689a      	ldr	r2, [r3, #8]
 800e46a:	687b      	ldr	r3, [r7, #4]
 800e46c:	60da      	str	r2, [r3, #12]
			fp->flag |= FA__WRITTEN;
 800e46e:	687b      	ldr	r3, [r7, #4]
 800e470:	799b      	ldrb	r3, [r3, #6]
 800e472:	f043 0320 	orr.w	r3, r3, #32
 800e476:	b2da      	uxtb	r2, r3
 800e478:	687b      	ldr	r3, [r7, #4]
 800e47a:	719a      	strb	r2, [r3, #6]
			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
 800e47c:	687b      	ldr	r3, [r7, #4]
 800e47e:	689b      	ldr	r3, [r3, #8]
 800e480:	2b00      	cmp	r3, #0
 800e482:	d10e      	bne.n	800e4a2 <f_truncate+0x96>
				res = remove_chain(fp->fs, fp->sclust);
 800e484:	687b      	ldr	r3, [r7, #4]
 800e486:	681a      	ldr	r2, [r3, #0]
 800e488:	687b      	ldr	r3, [r7, #4]
 800e48a:	691b      	ldr	r3, [r3, #16]
 800e48c:	4610      	mov	r0, r2
 800e48e:	4619      	mov	r1, r3
 800e490:	f7fd fc1c 	bl	800bccc <remove_chain>
 800e494:	4603      	mov	r3, r0
 800e496:	73fb      	strb	r3, [r7, #15]
				fp->sclust = 0;
 800e498:	687b      	ldr	r3, [r7, #4]
 800e49a:	f04f 0200 	mov.w	r2, #0
 800e49e:	611a      	str	r2, [r3, #16]
 800e4a0:	e038      	b.n	800e514 <f_truncate+0x108>
			} else {				/* When truncate a part of the file, remove remaining clusters */
				ncl = get_fat(fp->fs, fp->clust);
 800e4a2:	687b      	ldr	r3, [r7, #4]
 800e4a4:	681a      	ldr	r2, [r3, #0]
 800e4a6:	687b      	ldr	r3, [r7, #4]
 800e4a8:	695b      	ldr	r3, [r3, #20]
 800e4aa:	4610      	mov	r0, r2
 800e4ac:	4619      	mov	r1, r3
 800e4ae:	f7fd fa07 	bl	800b8c0 <get_fat>
 800e4b2:	60b8      	str	r0, [r7, #8]
				res = FR_OK;
 800e4b4:	f04f 0300 	mov.w	r3, #0
 800e4b8:	73fb      	strb	r3, [r7, #15]
				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
 800e4ba:	68bb      	ldr	r3, [r7, #8]
 800e4bc:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e4c0:	d102      	bne.n	800e4c8 <f_truncate+0xbc>
 800e4c2:	f04f 0301 	mov.w	r3, #1
 800e4c6:	73fb      	strb	r3, [r7, #15]
				if (ncl == 1) res = FR_INT_ERR;
 800e4c8:	68bb      	ldr	r3, [r7, #8]
 800e4ca:	2b01      	cmp	r3, #1
 800e4cc:	d102      	bne.n	800e4d4 <f_truncate+0xc8>
 800e4ce:	f04f 0302 	mov.w	r3, #2
 800e4d2:	73fb      	strb	r3, [r7, #15]
				if (res == FR_OK && ncl < fp->fs->n_fatent) {
 800e4d4:	7bfb      	ldrb	r3, [r7, #15]
 800e4d6:	2b00      	cmp	r3, #0
 800e4d8:	d11c      	bne.n	800e514 <f_truncate+0x108>
 800e4da:	687b      	ldr	r3, [r7, #4]
 800e4dc:	681b      	ldr	r3, [r3, #0]
 800e4de:	69da      	ldr	r2, [r3, #28]
 800e4e0:	68bb      	ldr	r3, [r7, #8]
 800e4e2:	429a      	cmp	r2, r3
 800e4e4:	d916      	bls.n	800e514 <f_truncate+0x108>
					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
 800e4e6:	687b      	ldr	r3, [r7, #4]
 800e4e8:	681a      	ldr	r2, [r3, #0]
 800e4ea:	687b      	ldr	r3, [r7, #4]
 800e4ec:	695b      	ldr	r3, [r3, #20]
 800e4ee:	4610      	mov	r0, r2
 800e4f0:	4619      	mov	r1, r3
 800e4f2:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 800e4f6:	f7fd fab5 	bl	800ba64 <put_fat>
 800e4fa:	4603      	mov	r3, r0
 800e4fc:	73fb      	strb	r3, [r7, #15]
					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
 800e4fe:	7bfb      	ldrb	r3, [r7, #15]
 800e500:	2b00      	cmp	r3, #0
 800e502:	d107      	bne.n	800e514 <f_truncate+0x108>
 800e504:	687b      	ldr	r3, [r7, #4]
 800e506:	681b      	ldr	r3, [r3, #0]
 800e508:	4618      	mov	r0, r3
 800e50a:	68b9      	ldr	r1, [r7, #8]
 800e50c:	f7fd fbde 	bl	800bccc <remove_chain>
 800e510:	4603      	mov	r3, r0
 800e512:	73fb      	strb	r3, [r7, #15]
				}
			}
		}
		if (res != FR_OK) fp->flag |= FA__ERROR;
 800e514:	7bfb      	ldrb	r3, [r7, #15]
 800e516:	2b00      	cmp	r3, #0
 800e518:	d006      	beq.n	800e528 <f_truncate+0x11c>
 800e51a:	687b      	ldr	r3, [r7, #4]
 800e51c:	799b      	ldrb	r3, [r3, #6]
 800e51e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800e522:	b2da      	uxtb	r2, r3
 800e524:	687b      	ldr	r3, [r7, #4]
 800e526:	719a      	strb	r2, [r3, #6]
	}

	LEAVE_FF(fp->fs, res);
 800e528:	7bfb      	ldrb	r3, [r7, #15]
}
 800e52a:	4618      	mov	r0, r3
 800e52c:	f107 0710 	add.w	r7, r7, #16
 800e530:	46bd      	mov	sp, r7
 800e532:	bd80      	pop	{r7, pc}

0800e534 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
 800e534:	b580      	push	{r7, lr}
 800e536:	b096      	sub	sp, #88	; 0x58
 800e538:	af00      	add	r7, sp, #0
 800e53a:	6078      	str	r0, [r7, #4]
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
 800e53c:	f107 0204 	add.w	r2, r7, #4
 800e540:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800e544:	4610      	mov	r0, r2
 800e546:	4619      	mov	r1, r3
 800e548:	f04f 0201 	mov.w	r2, #1
 800e54c:	f7fe fa5e 	bl	800ca0c <chk_mounted>
 800e550:	4603      	mov	r3, r0
 800e552:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (res == FR_OK) {
 800e556:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e55a:	2b00      	cmp	r3, #0
 800e55c:	f040 80c9 	bne.w	800e6f2 <f_unlink+0x1be>
		INIT_BUF(dj);
 800e560:	f107 0308 	add.w	r3, r7, #8
 800e564:	64bb      	str	r3, [r7, #72]	; 0x48
		res = follow_path(&dj, path);		/* Follow the file path */
 800e566:	687b      	ldr	r3, [r7, #4]
 800e568:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800e56c:	4610      	mov	r0, r2
 800e56e:	4619      	mov	r1, r3
 800e570:	f7fe f930 	bl	800c7d4 <follow_path>
 800e574:	4603      	mov	r3, r0
 800e576:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 800e57a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e57e:	2b00      	cmp	r3, #0
 800e580:	d10b      	bne.n	800e59a <f_unlink+0x66>
 800e582:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800e584:	f103 030b 	add.w	r3, r3, #11
 800e588:	781b      	ldrb	r3, [r3, #0]
 800e58a:	f003 0320 	and.w	r3, r3, #32
 800e58e:	2b00      	cmp	r3, #0
 800e590:	d003      	beq.n	800e59a <f_unlink+0x66>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
 800e592:	f04f 0306 	mov.w	r3, #6
 800e596:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
#if _FS_SHARE
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
 800e59a:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e59e:	2b00      	cmp	r3, #0
 800e5a0:	f040 80a7 	bne.w	800e6f2 <f_unlink+0x1be>
			dir = dj.dir;
 800e5a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e5a6:	653b      	str	r3, [r7, #80]	; 0x50
			if (!dir) {
 800e5a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e5aa:	2b00      	cmp	r3, #0
 800e5ac:	d104      	bne.n	800e5b8 <f_unlink+0x84>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
 800e5ae:	f04f 0306 	mov.w	r3, #6
 800e5b2:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 800e5b6:	e00b      	b.n	800e5d0 <f_unlink+0x9c>
			} else {
				if (dir[DIR_Attr] & AM_RDO)
 800e5b8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e5ba:	f103 030b 	add.w	r3, r3, #11
 800e5be:	781b      	ldrb	r3, [r3, #0]
 800e5c0:	f003 0301 	and.w	r3, r3, #1
 800e5c4:	2b00      	cmp	r3, #0
 800e5c6:	d003      	beq.n	800e5d0 <f_unlink+0x9c>
					res = FR_DENIED;		/* Cannot remove R/O object */
 800e5c8:	f04f 0307 	mov.w	r3, #7
 800e5cc:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
			}
			dclst = LD_CLUST(dir);
 800e5d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e5d2:	f103 0315 	add.w	r3, r3, #21
 800e5d6:	781b      	ldrb	r3, [r3, #0]
 800e5d8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800e5dc:	b29a      	uxth	r2, r3
 800e5de:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e5e0:	f103 0314 	add.w	r3, r3, #20
 800e5e4:	781b      	ldrb	r3, [r3, #0]
 800e5e6:	4313      	orrs	r3, r2
 800e5e8:	b29b      	uxth	r3, r3
 800e5ea:	b29b      	uxth	r3, r3
 800e5ec:	ea4f 4203 	mov.w	r2, r3, lsl #16
 800e5f0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e5f2:	f103 031b 	add.w	r3, r3, #27
 800e5f6:	781b      	ldrb	r3, [r3, #0]
 800e5f8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800e5fc:	b299      	uxth	r1, r3
 800e5fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e600:	f103 031a 	add.w	r3, r3, #26
 800e604:	781b      	ldrb	r3, [r3, #0]
 800e606:	430b      	orrs	r3, r1
 800e608:	b29b      	uxth	r3, r3
 800e60a:	b29b      	uxth	r3, r3
 800e60c:	4313      	orrs	r3, r2
 800e60e:	64fb      	str	r3, [r7, #76]	; 0x4c
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
 800e610:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e614:	2b00      	cmp	r3, #0
 800e616:	d146      	bne.n	800e6a6 <f_unlink+0x172>
 800e618:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e61a:	f103 030b 	add.w	r3, r3, #11
 800e61e:	781b      	ldrb	r3, [r3, #0]
 800e620:	f003 0310 	and.w	r3, r3, #16
 800e624:	2b00      	cmp	r3, #0
 800e626:	d03e      	beq.n	800e6a6 <f_unlink+0x172>
				if (dclst < 2) {
 800e628:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e62a:	2b01      	cmp	r3, #1
 800e62c:	d804      	bhi.n	800e638 <f_unlink+0x104>
					res = FR_INT_ERR;
 800e62e:	f04f 0302 	mov.w	r3, #2
 800e632:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 800e636:	e036      	b.n	800e6a6 <f_unlink+0x172>
				} else {
					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
 800e638:	f107 0214 	add.w	r2, r7, #20
 800e63c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800e640:	4610      	mov	r0, r2
 800e642:	4619      	mov	r1, r3
 800e644:	f04f 021c 	mov.w	r2, #28
 800e648:	f7fc ff50 	bl	800b4ec <mem_cpy>
					sdj.sclust = dclst;
 800e64c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e64e:	61fb      	str	r3, [r7, #28]
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 800e650:	f107 0314 	add.w	r3, r7, #20
 800e654:	4618      	mov	r0, r3
 800e656:	f04f 0102 	mov.w	r1, #2
 800e65a:	f7fd fc51 	bl	800bf00 <dir_sdi>
 800e65e:	4603      	mov	r3, r0
 800e660:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
					if (res == FR_OK) {
 800e664:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e668:	2b00      	cmp	r3, #0
 800e66a:	d11c      	bne.n	800e6a6 <f_unlink+0x172>
						res = dir_read(&sdj);
 800e66c:	f107 0314 	add.w	r3, r7, #20
 800e670:	4618      	mov	r0, r3
 800e672:	f7fd fe15 	bl	800c2a0 <dir_read>
 800e676:	4603      	mov	r3, r0
 800e678:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
						if (res == FR_OK			/* Not empty dir */
 800e67c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e680:	2b00      	cmp	r3, #0
 800e682:	d004      	beq.n	800e68e <f_unlink+0x15a>
#if _FS_RPATH
						|| dclst == sdj.fs->cdir	/* Current dir */
 800e684:	697b      	ldr	r3, [r7, #20]
 800e686:	699a      	ldr	r2, [r3, #24]
 800e688:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e68a:	429a      	cmp	r2, r3
 800e68c:	d103      	bne.n	800e696 <f_unlink+0x162>
#endif
						) res = FR_DENIED;
 800e68e:	f04f 0307 	mov.w	r3, #7
 800e692:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
 800e696:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e69a:	2b04      	cmp	r3, #4
 800e69c:	d103      	bne.n	800e6a6 <f_unlink+0x172>
 800e69e:	f04f 0300 	mov.w	r3, #0
 800e6a2:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
					}
				}
			}
			if (res == FR_OK) {
 800e6a6:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e6aa:	2b00      	cmp	r3, #0
 800e6ac:	d121      	bne.n	800e6f2 <f_unlink+0x1be>
				res = dir_remove(&dj);		/* Remove the directory entry */
 800e6ae:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800e6b2:	4618      	mov	r0, r3
 800e6b4:	f7fd fea0 	bl	800c3f8 <dir_remove>
 800e6b8:	4603      	mov	r3, r0
 800e6ba:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
				if (res == FR_OK) {
 800e6be:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e6c2:	2b00      	cmp	r3, #0
 800e6c4:	d115      	bne.n	800e6f2 <f_unlink+0x1be>
					if (dclst)				/* Remove the cluster chain if exist */
 800e6c6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e6c8:	2b00      	cmp	r3, #0
 800e6ca:	d007      	beq.n	800e6dc <f_unlink+0x1a8>
						res = remove_chain(dj.fs, dclst);
 800e6cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6ce:	4618      	mov	r0, r3
 800e6d0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800e6d2:	f7fd fafb 	bl	800bccc <remove_chain>
 800e6d6:	4603      	mov	r3, r0
 800e6d8:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
					if (res == FR_OK) res = sync(dj.fs);
 800e6dc:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800e6e0:	2b00      	cmp	r3, #0
 800e6e2:	d106      	bne.n	800e6f2 <f_unlink+0x1be>
 800e6e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e6e6:	4618      	mov	r0, r3
 800e6e8:	f7fd f808 	bl	800b6fc <sync>
 800e6ec:	4603      	mov	r3, r0
 800e6ee:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
				}
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
 800e6f2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
}
 800e6f6:	4618      	mov	r0, r3
 800e6f8:	f107 0758 	add.w	r7, r7, #88	; 0x58
 800e6fc:	46bd      	mov	sp, r7
 800e6fe:	bd80      	pop	{r7, pc}

0800e700 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
 800e700:	b580      	push	{r7, lr}
 800e702:	b092      	sub	sp, #72	; 0x48
 800e704:	af00      	add	r7, sp, #0
 800e706:	6078      	str	r0, [r7, #4]
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
 800e708:	f7fc feb8 	bl	800b47c <get_fattime>
 800e70c:	63b8      	str	r0, [r7, #56]	; 0x38
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
 800e70e:	f107 0204 	add.w	r2, r7, #4
 800e712:	f107 0314 	add.w	r3, r7, #20
 800e716:	4610      	mov	r0, r2
 800e718:	4619      	mov	r1, r3
 800e71a:	f04f 0201 	mov.w	r2, #1
 800e71e:	f7fe f975 	bl	800ca0c <chk_mounted>
 800e722:	4603      	mov	r3, r0
 800e724:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res == FR_OK) {
 800e728:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e72c:	2b00      	cmp	r3, #0
 800e72e:	f040 81a1 	bne.w	800ea74 <f_mkdir+0x374>
		INIT_BUF(dj);
 800e732:	f107 0308 	add.w	r3, r7, #8
 800e736:	62fb      	str	r3, [r7, #44]	; 0x2c
		res = follow_path(&dj, path);			/* Follow the file path */
 800e738:	687b      	ldr	r3, [r7, #4]
 800e73a:	f107 0214 	add.w	r2, r7, #20
 800e73e:	4610      	mov	r0, r2
 800e740:	4619      	mov	r1, r3
 800e742:	f7fe f847 	bl	800c7d4 <follow_path>
 800e746:	4603      	mov	r3, r0
 800e748:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 800e74c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e750:	2b00      	cmp	r3, #0
 800e752:	d103      	bne.n	800e75c <f_mkdir+0x5c>
 800e754:	f04f 0308 	mov.w	r3, #8
 800e758:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
 800e75c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e760:	2b04      	cmp	r3, #4
 800e762:	d10b      	bne.n	800e77c <f_mkdir+0x7c>
 800e764:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e766:	f103 030b 	add.w	r3, r3, #11
 800e76a:	781b      	ldrb	r3, [r3, #0]
 800e76c:	f003 0320 	and.w	r3, r3, #32
 800e770:	2b00      	cmp	r3, #0
 800e772:	d003      	beq.n	800e77c <f_mkdir+0x7c>
			res = FR_INVALID_NAME;
 800e774:	f04f 0306 	mov.w	r3, #6
 800e778:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		if (res == FR_NO_FILE) {				/* Can create a new directory */
 800e77c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e780:	2b04      	cmp	r3, #4
 800e782:	f040 8177 	bne.w	800ea74 <f_mkdir+0x374>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
 800e786:	697b      	ldr	r3, [r7, #20]
 800e788:	4618      	mov	r0, r3
 800e78a:	f04f 0100 	mov.w	r1, #0
 800e78e:	f7fd fb21 	bl	800bdd4 <create_chain>
 800e792:	6378      	str	r0, [r7, #52]	; 0x34
			res = FR_OK;
 800e794:	f04f 0300 	mov.w	r3, #0
 800e798:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 800e79c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e79e:	2b00      	cmp	r3, #0
 800e7a0:	d103      	bne.n	800e7aa <f_mkdir+0xaa>
 800e7a2:	f04f 0307 	mov.w	r3, #7
 800e7a6:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			if (dcl == 1) res = FR_INT_ERR;
 800e7aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e7ac:	2b01      	cmp	r3, #1
 800e7ae:	d103      	bne.n	800e7b8 <f_mkdir+0xb8>
 800e7b0:	f04f 0302 	mov.w	r3, #2
 800e7b4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 800e7b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e7ba:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e7be:	d103      	bne.n	800e7c8 <f_mkdir+0xc8>
 800e7c0:	f04f 0301 	mov.w	r3, #1
 800e7c4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			if (res == FR_OK)					/* Flush FAT */
 800e7c8:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e7cc:	2b00      	cmp	r3, #0
 800e7ce:	d108      	bne.n	800e7e2 <f_mkdir+0xe2>
				res = move_window(dj.fs, 0);
 800e7d0:	697b      	ldr	r3, [r7, #20]
 800e7d2:	4618      	mov	r0, r3
 800e7d4:	f04f 0100 	mov.w	r1, #0
 800e7d8:	f7fc ff26 	bl	800b628 <move_window>
 800e7dc:	4603      	mov	r3, r0
 800e7de:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			if (res == FR_OK) {					/* Initialize the new directory table */
 800e7e2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e7e6:	2b00      	cmp	r3, #0
 800e7e8:	f040 80d7 	bne.w	800e99a <f_mkdir+0x29a>
				dsc = clust2sect(dj.fs, dcl);
 800e7ec:	697b      	ldr	r3, [r7, #20]
 800e7ee:	4618      	mov	r0, r3
 800e7f0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800e7f2:	f7fd f843 	bl	800b87c <clust2sect>
 800e7f6:	6438      	str	r0, [r7, #64]	; 0x40
				dir = dj.fs->win;
 800e7f8:	697b      	ldr	r3, [r7, #20]
 800e7fa:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800e7fe:	633b      	str	r3, [r7, #48]	; 0x30
				mem_set(dir, 0, SS(dj.fs));
 800e800:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800e802:	f04f 0100 	mov.w	r1, #0
 800e806:	f44f 7200 	mov.w	r2, #512	; 0x200
 800e80a:	f7fc fe97 	bl	800b53c <mem_set>
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
 800e80e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800e810:	f04f 0120 	mov.w	r1, #32
 800e814:	f04f 020b 	mov.w	r2, #11
 800e818:	f7fc fe90 	bl	800b53c <mem_set>
				dir[DIR_Name] = '.';
 800e81c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e81e:	f04f 022e 	mov.w	r2, #46	; 0x2e
 800e822:	701a      	strb	r2, [r3, #0]
				dir[DIR_Attr] = AM_DIR;
 800e824:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e826:	f103 030b 	add.w	r3, r3, #11
 800e82a:	f04f 0210 	mov.w	r2, #16
 800e82e:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir+DIR_WrtTime, tim);
 800e830:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e832:	f103 0316 	add.w	r3, r3, #22
 800e836:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e838:	b2d2      	uxtb	r2, r2
 800e83a:	701a      	strb	r2, [r3, #0]
 800e83c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e83e:	f103 0317 	add.w	r3, r3, #23
 800e842:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e844:	b292      	uxth	r2, r2
 800e846:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800e84a:	b292      	uxth	r2, r2
 800e84c:	b2d2      	uxtb	r2, r2
 800e84e:	701a      	strb	r2, [r3, #0]
 800e850:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e852:	f103 0318 	add.w	r3, r3, #24
 800e856:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e858:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800e85c:	b2d2      	uxtb	r2, r2
 800e85e:	701a      	strb	r2, [r3, #0]
 800e860:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e862:	f103 0319 	add.w	r3, r3, #25
 800e866:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e868:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800e86c:	b2d2      	uxtb	r2, r2
 800e86e:	701a      	strb	r2, [r3, #0]
				ST_CLUST(dir, dcl);
 800e870:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e872:	f103 031a 	add.w	r3, r3, #26
 800e876:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e878:	b2d2      	uxtb	r2, r2
 800e87a:	701a      	strb	r2, [r3, #0]
 800e87c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e87e:	f103 031b 	add.w	r3, r3, #27
 800e882:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e884:	b292      	uxth	r2, r2
 800e886:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800e88a:	b292      	uxth	r2, r2
 800e88c:	b2d2      	uxtb	r2, r2
 800e88e:	701a      	strb	r2, [r3, #0]
 800e890:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e892:	f103 0314 	add.w	r3, r3, #20
 800e896:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e898:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800e89c:	b2d2      	uxtb	r2, r2
 800e89e:	701a      	strb	r2, [r3, #0]
 800e8a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8a2:	f103 0315 	add.w	r3, r3, #21
 800e8a6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e8a8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800e8ac:	b292      	uxth	r2, r2
 800e8ae:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800e8b2:	b292      	uxth	r2, r2
 800e8b4:	b2d2      	uxtb	r2, r2
 800e8b6:	701a      	strb	r2, [r3, #0]
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
 800e8b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8ba:	f103 0320 	add.w	r3, r3, #32
 800e8be:	4618      	mov	r0, r3
 800e8c0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800e8c2:	f04f 0220 	mov.w	r2, #32
 800e8c6:	f7fc fe11 	bl	800b4ec <mem_cpy>
				dir[33] = '.'; pcl = dj.sclust;
 800e8ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8cc:	f103 0321 	add.w	r3, r3, #33	; 0x21
 800e8d0:	f04f 022e 	mov.w	r2, #46	; 0x2e
 800e8d4:	701a      	strb	r2, [r3, #0]
 800e8d6:	69fb      	ldr	r3, [r7, #28]
 800e8d8:	63fb      	str	r3, [r7, #60]	; 0x3c
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
 800e8da:	697b      	ldr	r3, [r7, #20]
 800e8dc:	781b      	ldrb	r3, [r3, #0]
 800e8de:	2b03      	cmp	r3, #3
 800e8e0:	d107      	bne.n	800e8f2 <f_mkdir+0x1f2>
 800e8e2:	697b      	ldr	r3, [r7, #20]
 800e8e4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e8e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e8e8:	429a      	cmp	r2, r3
 800e8ea:	d102      	bne.n	800e8f2 <f_mkdir+0x1f2>
					pcl = 0;
 800e8ec:	f04f 0300 	mov.w	r3, #0
 800e8f0:	63fb      	str	r3, [r7, #60]	; 0x3c
				ST_CLUST(dir+SZ_DIR, pcl);
 800e8f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e8f4:	f103 033a 	add.w	r3, r3, #58	; 0x3a
 800e8f8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e8fa:	b2d2      	uxtb	r2, r2
 800e8fc:	701a      	strb	r2, [r3, #0]
 800e8fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e900:	f103 033b 	add.w	r3, r3, #59	; 0x3b
 800e904:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e906:	b292      	uxth	r2, r2
 800e908:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800e90c:	b292      	uxth	r2, r2
 800e90e:	b2d2      	uxtb	r2, r2
 800e910:	701a      	strb	r2, [r3, #0]
 800e912:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e914:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800e918:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e91a:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800e91e:	b2d2      	uxtb	r2, r2
 800e920:	701a      	strb	r2, [r3, #0]
 800e922:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e924:	f103 0335 	add.w	r3, r3, #53	; 0x35
 800e928:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e92a:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800e92e:	b292      	uxth	r2, r2
 800e930:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800e934:	b292      	uxth	r2, r2
 800e936:	b2d2      	uxtb	r2, r2
 800e938:	701a      	strb	r2, [r3, #0]
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 800e93a:	697b      	ldr	r3, [r7, #20]
 800e93c:	789b      	ldrb	r3, [r3, #2]
 800e93e:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 800e942:	e024      	b.n	800e98e <f_mkdir+0x28e>
					dj.fs->winsect = dsc++;
 800e944:	697b      	ldr	r3, [r7, #20]
 800e946:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800e948:	631a      	str	r2, [r3, #48]	; 0x30
 800e94a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800e94c:	f103 0301 	add.w	r3, r3, #1
 800e950:	643b      	str	r3, [r7, #64]	; 0x40
					dj.fs->wflag = 1;
 800e952:	697b      	ldr	r3, [r7, #20]
 800e954:	f04f 0201 	mov.w	r2, #1
 800e958:	711a      	strb	r2, [r3, #4]
					res = move_window(dj.fs, 0);
 800e95a:	697b      	ldr	r3, [r7, #20]
 800e95c:	4618      	mov	r0, r3
 800e95e:	f04f 0100 	mov.w	r1, #0
 800e962:	f7fc fe61 	bl	800b628 <move_window>
 800e966:	4603      	mov	r3, r0
 800e968:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
					if (res != FR_OK) break;
 800e96c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e970:	2b00      	cmp	r3, #0
 800e972:	d111      	bne.n	800e998 <f_mkdir+0x298>
					mem_set(dir, 0, SS(dj.fs));
 800e974:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800e976:	f04f 0100 	mov.w	r1, #0
 800e97a:	f44f 7200 	mov.w	r2, #512	; 0x200
 800e97e:	f7fc fddd 	bl	800b53c <mem_set>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 800e982:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800e986:	f103 33ff 	add.w	r3, r3, #4294967295
 800e98a:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 800e98e:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800e992:	2b00      	cmp	r3, #0
 800e994:	d1d6      	bne.n	800e944 <f_mkdir+0x244>
 800e996:	e000      	b.n	800e99a <f_mkdir+0x29a>
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
 800e998:	bf00      	nop
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
 800e99a:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e99e:	2b00      	cmp	r3, #0
 800e9a0:	d107      	bne.n	800e9b2 <f_mkdir+0x2b2>
 800e9a2:	f107 0314 	add.w	r3, r7, #20
 800e9a6:	4618      	mov	r0, r3
 800e9a8:	f7fd fcc8 	bl	800c33c <dir_register>
 800e9ac:	4603      	mov	r3, r0
 800e9ae:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			if (res != FR_OK) {
 800e9b2:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800e9b6:	2b00      	cmp	r3, #0
 800e9b8:	d005      	beq.n	800e9c6 <f_mkdir+0x2c6>
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
 800e9ba:	697b      	ldr	r3, [r7, #20]
 800e9bc:	4618      	mov	r0, r3
 800e9be:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800e9c0:	f7fd f984 	bl	800bccc <remove_chain>
 800e9c4:	e056      	b.n	800ea74 <f_mkdir+0x374>
			} else {
				dir = dj.dir;
 800e9c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e9c8:	633b      	str	r3, [r7, #48]	; 0x30
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
 800e9ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e9cc:	f103 030b 	add.w	r3, r3, #11
 800e9d0:	f04f 0210 	mov.w	r2, #16
 800e9d4:	701a      	strb	r2, [r3, #0]
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
 800e9d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e9d8:	f103 0316 	add.w	r3, r3, #22
 800e9dc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e9de:	b2d2      	uxtb	r2, r2
 800e9e0:	701a      	strb	r2, [r3, #0]
 800e9e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e9e4:	f103 0317 	add.w	r3, r3, #23
 800e9e8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e9ea:	b292      	uxth	r2, r2
 800e9ec:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800e9f0:	b292      	uxth	r2, r2
 800e9f2:	b2d2      	uxtb	r2, r2
 800e9f4:	701a      	strb	r2, [r3, #0]
 800e9f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e9f8:	f103 0318 	add.w	r3, r3, #24
 800e9fc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e9fe:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800ea02:	b2d2      	uxtb	r2, r2
 800ea04:	701a      	strb	r2, [r3, #0]
 800ea06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea08:	f103 0319 	add.w	r3, r3, #25
 800ea0c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ea0e:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800ea12:	b2d2      	uxtb	r2, r2
 800ea14:	701a      	strb	r2, [r3, #0]
				ST_CLUST(dir, dcl);					/* Table start cluster */
 800ea16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea18:	f103 031a 	add.w	r3, r3, #26
 800ea1c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ea1e:	b2d2      	uxtb	r2, r2
 800ea20:	701a      	strb	r2, [r3, #0]
 800ea22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea24:	f103 031b 	add.w	r3, r3, #27
 800ea28:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ea2a:	b292      	uxth	r2, r2
 800ea2c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800ea30:	b292      	uxth	r2, r2
 800ea32:	b2d2      	uxtb	r2, r2
 800ea34:	701a      	strb	r2, [r3, #0]
 800ea36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea38:	f103 0314 	add.w	r3, r3, #20
 800ea3c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ea3e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800ea42:	b2d2      	uxtb	r2, r2
 800ea44:	701a      	strb	r2, [r3, #0]
 800ea46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea48:	f103 0315 	add.w	r3, r3, #21
 800ea4c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ea4e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800ea52:	b292      	uxth	r2, r2
 800ea54:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800ea58:	b292      	uxth	r2, r2
 800ea5a:	b2d2      	uxtb	r2, r2
 800ea5c:	701a      	strb	r2, [r3, #0]
				dj.fs->wflag = 1;
 800ea5e:	697b      	ldr	r3, [r7, #20]
 800ea60:	f04f 0201 	mov.w	r2, #1
 800ea64:	711a      	strb	r2, [r3, #4]
				res = sync(dj.fs);
 800ea66:	697b      	ldr	r3, [r7, #20]
 800ea68:	4618      	mov	r0, r3
 800ea6a:	f7fc fe47 	bl	800b6fc <sync>
 800ea6e:	4603      	mov	r3, r0
 800ea70:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
			}
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
 800ea74:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 800ea78:	4618      	mov	r0, r3
 800ea7a:	f107 0748 	add.w	r7, r7, #72	; 0x48
 800ea7e:	46bd      	mov	sp, r7
 800ea80:	bd80      	pop	{r7, pc}
 800ea82:	bf00      	nop

0800ea84 <f_chmod>:
FRESULT f_chmod (
	const TCHAR *path,	/* Pointer to the file path */
	BYTE value,			/* Attribute bits */
	BYTE mask			/* Attribute mask to change */
)
{
 800ea84:	b580      	push	{r7, lr}
 800ea86:	b08e      	sub	sp, #56	; 0x38
 800ea88:	af00      	add	r7, sp, #0
 800ea8a:	6078      	str	r0, [r7, #4]
 800ea8c:	4613      	mov	r3, r2
 800ea8e:	460a      	mov	r2, r1
 800ea90:	70fa      	strb	r2, [r7, #3]
 800ea92:	70bb      	strb	r3, [r7, #2]
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
 800ea94:	f107 0204 	add.w	r2, r7, #4
 800ea98:	f107 0314 	add.w	r3, r7, #20
 800ea9c:	4610      	mov	r0, r2
 800ea9e:	4619      	mov	r1, r3
 800eaa0:	f04f 0201 	mov.w	r2, #1
 800eaa4:	f7fd ffb2 	bl	800ca0c <chk_mounted>
 800eaa8:	4603      	mov	r3, r0
 800eaaa:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 800eaae:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800eab2:	2b00      	cmp	r3, #0
 800eab4:	d14d      	bne.n	800eb52 <f_chmod+0xce>
		INIT_BUF(dj);
 800eab6:	f107 0308 	add.w	r3, r7, #8
 800eaba:	62fb      	str	r3, [r7, #44]	; 0x2c
		res = follow_path(&dj, path);		/* Follow the file path */
 800eabc:	687b      	ldr	r3, [r7, #4]
 800eabe:	f107 0214 	add.w	r2, r7, #20
 800eac2:	4610      	mov	r0, r2
 800eac4:	4619      	mov	r1, r3
 800eac6:	f7fd fe85 	bl	800c7d4 <follow_path>
 800eaca:	4603      	mov	r3, r0
 800eacc:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 800ead0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800ead4:	2b00      	cmp	r3, #0
 800ead6:	d10b      	bne.n	800eaf0 <f_chmod+0x6c>
 800ead8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eada:	f103 030b 	add.w	r3, r3, #11
 800eade:	781b      	ldrb	r3, [r3, #0]
 800eae0:	f003 0320 	and.w	r3, r3, #32
 800eae4:	2b00      	cmp	r3, #0
 800eae6:	d003      	beq.n	800eaf0 <f_chmod+0x6c>
			res = FR_INVALID_NAME;
 800eae8:	f04f 0306 	mov.w	r3, #6
 800eaec:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (res == FR_OK) {
 800eaf0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800eaf4:	2b00      	cmp	r3, #0
 800eaf6:	d12c      	bne.n	800eb52 <f_chmod+0xce>
			dir = dj.dir;
 800eaf8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800eafa:	633b      	str	r3, [r7, #48]	; 0x30
			if (!dir) {						/* Is it a root directory? */
 800eafc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800eafe:	2b00      	cmp	r3, #0
 800eb00:	d104      	bne.n	800eb0c <f_chmod+0x88>
				res = FR_INVALID_NAME;
 800eb02:	f04f 0306 	mov.w	r3, #6
 800eb06:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 800eb0a:	e022      	b.n	800eb52 <f_chmod+0xce>
			} else {						/* File or sub directory */
				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
 800eb0c:	78bb      	ldrb	r3, [r7, #2]
 800eb0e:	f003 0327 	and.w	r3, r3, #39	; 0x27
 800eb12:	70bb      	strb	r3, [r7, #2]
				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
 800eb14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800eb16:	f103 030b 	add.w	r3, r3, #11
 800eb1a:	78f9      	ldrb	r1, [r7, #3]
 800eb1c:	78ba      	ldrb	r2, [r7, #2]
 800eb1e:	400a      	ands	r2, r1
 800eb20:	b2d1      	uxtb	r1, r2
 800eb22:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800eb24:	f102 020b 	add.w	r2, r2, #11
 800eb28:	7810      	ldrb	r0, [r2, #0]
 800eb2a:	78ba      	ldrb	r2, [r7, #2]
 800eb2c:	ea6f 0202 	mvn.w	r2, r2
 800eb30:	b2d2      	uxtb	r2, r2
 800eb32:	4002      	ands	r2, r0
 800eb34:	b2d2      	uxtb	r2, r2
 800eb36:	430a      	orrs	r2, r1
 800eb38:	b2d2      	uxtb	r2, r2
 800eb3a:	701a      	strb	r2, [r3, #0]
				dj.fs->wflag = 1;
 800eb3c:	697b      	ldr	r3, [r7, #20]
 800eb3e:	f04f 0201 	mov.w	r2, #1
 800eb42:	711a      	strb	r2, [r3, #4]
				res = sync(dj.fs);
 800eb44:	697b      	ldr	r3, [r7, #20]
 800eb46:	4618      	mov	r0, r3
 800eb48:	f7fc fdd8 	bl	800b6fc <sync>
 800eb4c:	4603      	mov	r3, r0
 800eb4e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			}
		}
	}

	LEAVE_FF(dj.fs, res);
 800eb52:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 800eb56:	4618      	mov	r0, r3
 800eb58:	f107 0738 	add.w	r7, r7, #56	; 0x38
 800eb5c:	46bd      	mov	sp, r7
 800eb5e:	bd80      	pop	{r7, pc}

0800eb60 <f_utime>:

FRESULT f_utime (
	const TCHAR *path,	/* Pointer to the file/directory name */
	const FILINFO *fno	/* Pointer to the time stamp to be set */
)
{
 800eb60:	b580      	push	{r7, lr}
 800eb62:	b08e      	sub	sp, #56	; 0x38
 800eb64:	af00      	add	r7, sp, #0
 800eb66:	6078      	str	r0, [r7, #4]
 800eb68:	6039      	str	r1, [r7, #0]
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
 800eb6a:	f107 0204 	add.w	r2, r7, #4
 800eb6e:	f107 0314 	add.w	r3, r7, #20
 800eb72:	4610      	mov	r0, r2
 800eb74:	4619      	mov	r1, r3
 800eb76:	f04f 0201 	mov.w	r2, #1
 800eb7a:	f7fd ff47 	bl	800ca0c <chk_mounted>
 800eb7e:	4603      	mov	r3, r0
 800eb80:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res == FR_OK) {
 800eb84:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800eb88:	2b00      	cmp	r3, #0
 800eb8a:	d157      	bne.n	800ec3c <f_utime+0xdc>
		INIT_BUF(dj);
 800eb8c:	f107 0308 	add.w	r3, r7, #8
 800eb90:	62fb      	str	r3, [r7, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
 800eb92:	687b      	ldr	r3, [r7, #4]
 800eb94:	f107 0214 	add.w	r2, r7, #20
 800eb98:	4610      	mov	r0, r2
 800eb9a:	4619      	mov	r1, r3
 800eb9c:	f7fd fe1a 	bl	800c7d4 <follow_path>
 800eba0:	4603      	mov	r3, r0
 800eba2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		FREE_BUF();
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
 800eba6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800ebaa:	2b00      	cmp	r3, #0
 800ebac:	d10b      	bne.n	800ebc6 <f_utime+0x66>
 800ebae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ebb0:	f103 030b 	add.w	r3, r3, #11
 800ebb4:	781b      	ldrb	r3, [r3, #0]
 800ebb6:	f003 0320 	and.w	r3, r3, #32
 800ebba:	2b00      	cmp	r3, #0
 800ebbc:	d003      	beq.n	800ebc6 <f_utime+0x66>
			res = FR_INVALID_NAME;
 800ebbe:	f04f 0306 	mov.w	r3, #6
 800ebc2:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (res == FR_OK) {
 800ebc6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800ebca:	2b00      	cmp	r3, #0
 800ebcc:	d136      	bne.n	800ec3c <f_utime+0xdc>
			dir = dj.dir;
 800ebce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ebd0:	633b      	str	r3, [r7, #48]	; 0x30
			if (!dir) {					/* Root directory */
 800ebd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	d104      	bne.n	800ebe2 <f_utime+0x82>
				res = FR_INVALID_NAME;
 800ebd8:	f04f 0306 	mov.w	r3, #6
 800ebdc:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 800ebe0:	e02c      	b.n	800ec3c <f_utime+0xdc>
			} else {					/* File or sub-directory */
				ST_WORD(dir+DIR_WrtTime, fno->ftime);
 800ebe2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ebe4:	f103 0316 	add.w	r3, r3, #22
 800ebe8:	683a      	ldr	r2, [r7, #0]
 800ebea:	88d2      	ldrh	r2, [r2, #6]
 800ebec:	b2d2      	uxtb	r2, r2
 800ebee:	701a      	strb	r2, [r3, #0]
 800ebf0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ebf2:	f103 0317 	add.w	r3, r3, #23
 800ebf6:	683a      	ldr	r2, [r7, #0]
 800ebf8:	88d2      	ldrh	r2, [r2, #6]
 800ebfa:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800ebfe:	b292      	uxth	r2, r2
 800ec00:	b2d2      	uxtb	r2, r2
 800ec02:	701a      	strb	r2, [r3, #0]
				ST_WORD(dir+DIR_WrtDate, fno->fdate);
 800ec04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ec06:	f103 0318 	add.w	r3, r3, #24
 800ec0a:	683a      	ldr	r2, [r7, #0]
 800ec0c:	8892      	ldrh	r2, [r2, #4]
 800ec0e:	b2d2      	uxtb	r2, r2
 800ec10:	701a      	strb	r2, [r3, #0]
 800ec12:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ec14:	f103 0319 	add.w	r3, r3, #25
 800ec18:	683a      	ldr	r2, [r7, #0]
 800ec1a:	8892      	ldrh	r2, [r2, #4]
 800ec1c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800ec20:	b292      	uxth	r2, r2
 800ec22:	b2d2      	uxtb	r2, r2
 800ec24:	701a      	strb	r2, [r3, #0]
				dj.fs->wflag = 1;
 800ec26:	697b      	ldr	r3, [r7, #20]
 800ec28:	f04f 0201 	mov.w	r2, #1
 800ec2c:	711a      	strb	r2, [r3, #4]
				res = sync(dj.fs);
 800ec2e:	697b      	ldr	r3, [r7, #20]
 800ec30:	4618      	mov	r0, r3
 800ec32:	f7fc fd63 	bl	800b6fc <sync>
 800ec36:	4603      	mov	r3, r0
 800ec38:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
			}
		}
	}

	LEAVE_FF(dj.fs, res);
 800ec3c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 800ec40:	4618      	mov	r0, r3
 800ec42:	f107 0738 	add.w	r7, r7, #56	; 0x38
 800ec46:	46bd      	mov	sp, r7
 800ec48:	bd80      	pop	{r7, pc}
 800ec4a:	bf00      	nop

0800ec4c <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
 800ec4c:	b580      	push	{r7, lr}
 800ec4e:	b09c      	sub	sp, #112	; 0x70
 800ec50:	af00      	add	r7, sp, #0
 800ec52:	6078      	str	r0, [r7, #4]
 800ec54:	6039      	str	r1, [r7, #0]
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
 800ec56:	f107 0204 	add.w	r2, r7, #4
 800ec5a:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800ec5e:	4610      	mov	r0, r2
 800ec60:	4619      	mov	r1, r3
 800ec62:	f04f 0201 	mov.w	r2, #1
 800ec66:	f7fd fed1 	bl	800ca0c <chk_mounted>
 800ec6a:	4603      	mov	r3, r0
 800ec6c:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
	if (res == FR_OK) {
 800ec70:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ec74:	2b00      	cmp	r3, #0
 800ec76:	f040 811c 	bne.w	800eeb2 <f_rename+0x266>
		djn.fs = djo.fs;
 800ec7a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ec7c:	62fb      	str	r3, [r7, #44]	; 0x2c
		INIT_BUF(djo);
 800ec7e:	f107 0308 	add.w	r3, r7, #8
 800ec82:	663b      	str	r3, [r7, #96]	; 0x60
		res = follow_path(&djo, path_old);		/* Check old object */
 800ec84:	687b      	ldr	r3, [r7, #4]
 800ec86:	f107 0248 	add.w	r2, r7, #72	; 0x48
 800ec8a:	4610      	mov	r0, r2
 800ec8c:	4619      	mov	r1, r3
 800ec8e:	f7fd fda1 	bl	800c7d4 <follow_path>
 800ec92:	4603      	mov	r3, r0
 800ec94:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
 800ec98:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ec9c:	2b00      	cmp	r3, #0
 800ec9e:	d10b      	bne.n	800ecb8 <f_rename+0x6c>
 800eca0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800eca2:	f103 030b 	add.w	r3, r3, #11
 800eca6:	781b      	ldrb	r3, [r3, #0]
 800eca8:	f003 0320 	and.w	r3, r3, #32
 800ecac:	2b00      	cmp	r3, #0
 800ecae:	d003      	beq.n	800ecb8 <f_rename+0x6c>
			res = FR_INVALID_NAME;
 800ecb0:	f04f 0306 	mov.w	r3, #6
 800ecb4:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
#if _FS_SHARE
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
 800ecb8:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ecbc:	2b00      	cmp	r3, #0
 800ecbe:	f040 80f8 	bne.w	800eeb2 <f_rename+0x266>
			if (!djo.dir) {						/* Is root dir? */
 800ecc2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ecc4:	2b00      	cmp	r3, #0
 800ecc6:	d104      	bne.n	800ecd2 <f_rename+0x86>
				res = FR_NO_FILE;
 800ecc8:	f04f 0304 	mov.w	r3, #4
 800eccc:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
 800ecd0:	e0ef      	b.n	800eeb2 <f_rename+0x266>
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
 800ecd2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ecd4:	f103 030b 	add.w	r3, r3, #11
 800ecd8:	f107 0214 	add.w	r2, r7, #20
 800ecdc:	4610      	mov	r0, r2
 800ecde:	4619      	mov	r1, r3
 800ece0:	f04f 0215 	mov.w	r2, #21
 800ece4:	f7fc fc02 	bl	800b4ec <mem_cpy>
				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
 800ece8:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800ecec:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800ecf0:	4610      	mov	r0, r2
 800ecf2:	4619      	mov	r1, r3
 800ecf4:	f04f 021c 	mov.w	r2, #28
 800ecf8:	f7fc fbf8 	bl	800b4ec <mem_cpy>
				res = follow_path(&djn, path_new);
 800ecfc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ed00:	4618      	mov	r0, r3
 800ed02:	6839      	ldr	r1, [r7, #0]
 800ed04:	f7fd fd66 	bl	800c7d4 <follow_path>
 800ed08:	4603      	mov	r3, r0
 800ed0a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
 800ed0e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ed12:	2b00      	cmp	r3, #0
 800ed14:	d103      	bne.n	800ed1e <f_rename+0xd2>
 800ed16:	f04f 0308 	mov.w	r3, #8
 800ed1a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
 800ed1e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ed22:	2b04      	cmp	r3, #4
 800ed24:	f040 80c5 	bne.w	800eeb2 <f_rename+0x266>
/* Start critical section that any interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
 800ed28:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ed2c:	4618      	mov	r0, r3
 800ed2e:	f7fd fb05 	bl	800c33c <dir_register>
 800ed32:	4603      	mov	r3, r0
 800ed34:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
					if (res == FR_OK) {
 800ed38:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ed3c:	2b00      	cmp	r3, #0
 800ed3e:	f040 80b8 	bne.w	800eeb2 <f_rename+0x266>
						dir = djn.dir;					/* Copy object information except for name */
 800ed42:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ed44:	66bb      	str	r3, [r7, #104]	; 0x68
						mem_cpy(dir+13, buf+2, 19);
 800ed46:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ed48:	f103 020d 	add.w	r2, r3, #13
 800ed4c:	f107 0314 	add.w	r3, r7, #20
 800ed50:	f103 0302 	add.w	r3, r3, #2
 800ed54:	4610      	mov	r0, r2
 800ed56:	4619      	mov	r1, r3
 800ed58:	f04f 0213 	mov.w	r2, #19
 800ed5c:	f7fc fbc6 	bl	800b4ec <mem_cpy>
						dir[DIR_Attr] = buf[0] | AM_ARC;
 800ed60:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ed62:	f103 030b 	add.w	r3, r3, #11
 800ed66:	7d3a      	ldrb	r2, [r7, #20]
 800ed68:	f042 0220 	orr.w	r2, r2, #32
 800ed6c:	b2d2      	uxtb	r2, r2
 800ed6e:	701a      	strb	r2, [r3, #0]
						djo.fs->wflag = 1;
 800ed70:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ed72:	f04f 0201 	mov.w	r2, #1
 800ed76:	711a      	strb	r2, [r3, #4]
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
 800ed78:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800ed7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ed7c:	429a      	cmp	r2, r3
 800ed7e:	f000 8081 	beq.w	800ee84 <f_rename+0x238>
 800ed82:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ed84:	f103 030b 	add.w	r3, r3, #11
 800ed88:	781b      	ldrb	r3, [r3, #0]
 800ed8a:	f003 0310 	and.w	r3, r3, #16
 800ed8e:	2b00      	cmp	r3, #0
 800ed90:	d078      	beq.n	800ee84 <f_rename+0x238>
							dw = clust2sect(djn.fs, LD_CLUST(dir));
 800ed92:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ed94:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ed96:	f103 0315 	add.w	r3, r3, #21
 800ed9a:	781b      	ldrb	r3, [r3, #0]
 800ed9c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800eda0:	b299      	uxth	r1, r3
 800eda2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800eda4:	f103 0314 	add.w	r3, r3, #20
 800eda8:	781b      	ldrb	r3, [r3, #0]
 800edaa:	430b      	orrs	r3, r1
 800edac:	b29b      	uxth	r3, r3
 800edae:	b29b      	uxth	r3, r3
 800edb0:	ea4f 4103 	mov.w	r1, r3, lsl #16
 800edb4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800edb6:	f103 031b 	add.w	r3, r3, #27
 800edba:	781b      	ldrb	r3, [r3, #0]
 800edbc:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800edc0:	b298      	uxth	r0, r3
 800edc2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800edc4:	f103 031a 	add.w	r3, r3, #26
 800edc8:	781b      	ldrb	r3, [r3, #0]
 800edca:	4303      	orrs	r3, r0
 800edcc:	b29b      	uxth	r3, r3
 800edce:	b29b      	uxth	r3, r3
 800edd0:	430b      	orrs	r3, r1
 800edd2:	4610      	mov	r0, r2
 800edd4:	4619      	mov	r1, r3
 800edd6:	f7fc fd51 	bl	800b87c <clust2sect>
 800edda:	6678      	str	r0, [r7, #100]	; 0x64
							if (!dw) {
 800eddc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800edde:	2b00      	cmp	r3, #0
 800ede0:	d104      	bne.n	800edec <f_rename+0x1a0>
								res = FR_INT_ERR;
 800ede2:	f04f 0302 	mov.w	r3, #2
 800ede6:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
 800edea:	e04b      	b.n	800ee84 <f_rename+0x238>
							} else {
								res = move_window(djn.fs, dw);
 800edec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800edee:	4618      	mov	r0, r3
 800edf0:	6e79      	ldr	r1, [r7, #100]	; 0x64
 800edf2:	f7fc fc19 	bl	800b628 <move_window>
 800edf6:	4603      	mov	r3, r0
 800edf8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
								dir = djn.fs->win+SZ_DIR;	/* .. entry */
 800edfc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800edfe:	f103 0354 	add.w	r3, r3, #84	; 0x54
 800ee02:	66bb      	str	r3, [r7, #104]	; 0x68
								if (res == FR_OK && dir[1] == '.') {
 800ee04:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ee08:	2b00      	cmp	r3, #0
 800ee0a:	d13b      	bne.n	800ee84 <f_rename+0x238>
 800ee0c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ee0e:	f103 0301 	add.w	r3, r3, #1
 800ee12:	781b      	ldrb	r3, [r3, #0]
 800ee14:	2b2e      	cmp	r3, #46	; 0x2e
 800ee16:	d135      	bne.n	800ee84 <f_rename+0x238>
									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
 800ee18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ee1a:	781b      	ldrb	r3, [r3, #0]
 800ee1c:	2b03      	cmp	r3, #3
 800ee1e:	d104      	bne.n	800ee2a <f_rename+0x1de>
 800ee20:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ee22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ee24:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ee26:	429a      	cmp	r2, r3
 800ee28:	d001      	beq.n	800ee2e <f_rename+0x1e2>
 800ee2a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ee2c:	e001      	b.n	800ee32 <f_rename+0x1e6>
 800ee2e:	f04f 0300 	mov.w	r3, #0
 800ee32:	667b      	str	r3, [r7, #100]	; 0x64
									ST_CLUST(dir, dw);
 800ee34:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ee36:	f103 031a 	add.w	r3, r3, #26
 800ee3a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800ee3c:	b2d2      	uxtb	r2, r2
 800ee3e:	701a      	strb	r2, [r3, #0]
 800ee40:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ee42:	f103 031b 	add.w	r3, r3, #27
 800ee46:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800ee48:	b292      	uxth	r2, r2
 800ee4a:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800ee4e:	b292      	uxth	r2, r2
 800ee50:	b2d2      	uxtb	r2, r2
 800ee52:	701a      	strb	r2, [r3, #0]
 800ee54:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ee56:	f103 0314 	add.w	r3, r3, #20
 800ee5a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800ee5c:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800ee60:	b2d2      	uxtb	r2, r2
 800ee62:	701a      	strb	r2, [r3, #0]
 800ee64:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ee66:	f103 0315 	add.w	r3, r3, #21
 800ee6a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800ee6c:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800ee70:	b292      	uxth	r2, r2
 800ee72:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800ee76:	b292      	uxth	r2, r2
 800ee78:	b2d2      	uxtb	r2, r2
 800ee7a:	701a      	strb	r2, [r3, #0]
									djn.fs->wflag = 1;
 800ee7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ee7e:	f04f 0201 	mov.w	r2, #1
 800ee82:	711a      	strb	r2, [r3, #4]
								}
							}
						}
						if (res == FR_OK) {
 800ee84:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800ee88:	2b00      	cmp	r3, #0
 800ee8a:	d112      	bne.n	800eeb2 <f_rename+0x266>
							res = dir_remove(&djo);		/* Remove old entry */
 800ee8c:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800ee90:	4618      	mov	r0, r3
 800ee92:	f7fd fab1 	bl	800c3f8 <dir_remove>
 800ee96:	4603      	mov	r3, r0
 800ee98:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
							if (res == FR_OK)
 800ee9c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800eea0:	2b00      	cmp	r3, #0
 800eea2:	d106      	bne.n	800eeb2 <f_rename+0x266>
								res = sync(djo.fs);
 800eea4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800eea6:	4618      	mov	r0, r3
 800eea8:	f7fc fc28 	bl	800b6fc <sync>
 800eeac:	4603      	mov	r3, r0
 800eeae:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				}
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
 800eeb2:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
}
 800eeb6:	4618      	mov	r0, r3
 800eeb8:	f107 0770 	add.w	r7, r7, #112	; 0x70
 800eebc:	46bd      	mov	sp, r7
 800eebe:	bd80      	pop	{r7, pc}

0800eec0 <f_mkfs>:
FRESULT f_mkfs (
	BYTE drv,		/* Logical drive number */
	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
	UINT au			/* Allocation unit size [bytes] */
)
{
 800eec0:	b580      	push	{r7, lr}
 800eec2:	b096      	sub	sp, #88	; 0x58
 800eec4:	af00      	add	r7, sp, #0
 800eec6:	460b      	mov	r3, r1
 800eec8:	603a      	str	r2, [r7, #0]
 800eeca:	4602      	mov	r2, r0
 800eecc:	71fa      	strb	r2, [r7, #7]
 800eece:	71bb      	strb	r3, [r7, #6]
	FATFS *fs;
	DSTATUS stat;


	/* Check mounted drive and clear work area */
	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
 800eed0:	79fb      	ldrb	r3, [r7, #7]
 800eed2:	2b01      	cmp	r3, #1
 800eed4:	d903      	bls.n	800eede <f_mkfs+0x1e>
 800eed6:	f04f 030b 	mov.w	r3, #11
 800eeda:	f000 bdc3 	b.w	800fa64 <f_mkfs+0xba4>
	if (sfd > 1) return FR_INVALID_PARAMETER;
 800eede:	79bb      	ldrb	r3, [r7, #6]
 800eee0:	2b01      	cmp	r3, #1
 800eee2:	d903      	bls.n	800eeec <f_mkfs+0x2c>
 800eee4:	f04f 0313 	mov.w	r3, #19
 800eee8:	f000 bdbc 	b.w	800fa64 <f_mkfs+0xba4>
	if (au & (au - 1)) return FR_INVALID_PARAMETER;
 800eeec:	683b      	ldr	r3, [r7, #0]
 800eeee:	f103 32ff 	add.w	r2, r3, #4294967295
 800eef2:	683b      	ldr	r3, [r7, #0]
 800eef4:	4013      	ands	r3, r2
 800eef6:	2b00      	cmp	r3, #0
 800eef8:	d003      	beq.n	800ef02 <f_mkfs+0x42>
 800eefa:	f04f 0313 	mov.w	r3, #19
 800eefe:	f000 bdb1 	b.w	800fa64 <f_mkfs+0xba4>
	fs = FatFs[drv];
 800ef02:	79fa      	ldrb	r2, [r7, #7]
 800ef04:	f640 53d0 	movw	r3, #3536	; 0xdd0
 800ef08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ef0c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ef10:	63bb      	str	r3, [r7, #56]	; 0x38
	if (!fs) return FR_NOT_ENABLED;
 800ef12:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef14:	2b00      	cmp	r3, #0
 800ef16:	d103      	bne.n	800ef20 <f_mkfs+0x60>
 800ef18:	f04f 030c 	mov.w	r3, #12
 800ef1c:	f000 bda2 	b.w	800fa64 <f_mkfs+0xba4>
	fs->fs_type = 0;
 800ef20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ef22:	f04f 0200 	mov.w	r2, #0
 800ef26:	701a      	strb	r2, [r3, #0]
	pdrv = LD2PD(drv);	/* Physical drive */
 800ef28:	79fb      	ldrb	r3, [r7, #7]
 800ef2a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
 800ef2e:	f04f 0300 	mov.w	r3, #0
 800ef32:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

	/* Get disk statics */
	stat = disk_initialize(pdrv);
 800ef36:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800ef3a:	4618      	mov	r0, r3
 800ef3c:	f7fc f988 	bl	800b250 <disk_initialize>
 800ef40:	4603      	mov	r3, r0
 800ef42:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
	if (stat & STA_NOINIT) return FR_NOT_READY;
 800ef46:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 800ef4a:	f003 0301 	and.w	r3, r3, #1
 800ef4e:	2b00      	cmp	r3, #0
 800ef50:	d003      	beq.n	800ef5a <f_mkfs+0x9a>
 800ef52:	f04f 0303 	mov.w	r3, #3
 800ef56:	f000 bd85 	b.w	800fa64 <f_mkfs+0xba4>
	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
 800ef5a:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
 800ef5e:	f003 0304 	and.w	r3, r3, #4
 800ef62:	2b00      	cmp	r3, #0
 800ef64:	d003      	beq.n	800ef6e <f_mkfs+0xae>
 800ef66:	f04f 030a 	mov.w	r3, #10
 800ef6a:	f000 bd7b 	b.w	800fa64 <f_mkfs+0xba4>
		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
		n_vol = LD_DWORD(tbl+12);	/* Volume size */
	} else {
		/* Create a partition in this function */
		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
 800ef6e:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800ef72:	f107 0314 	add.w	r3, r7, #20
 800ef76:	4610      	mov	r0, r2
 800ef78:	f04f 0101 	mov.w	r1, #1
 800ef7c:	461a      	mov	r2, r3
 800ef7e:	f7fc fa43 	bl	800b408 <disk_ioctl>
 800ef82:	4603      	mov	r3, r0
 800ef84:	2b00      	cmp	r3, #0
 800ef86:	d102      	bne.n	800ef8e <f_mkfs+0xce>
 800ef88:	697b      	ldr	r3, [r7, #20]
 800ef8a:	2b7f      	cmp	r3, #127	; 0x7f
 800ef8c:	d803      	bhi.n	800ef96 <f_mkfs+0xd6>
			return FR_DISK_ERR;
 800ef8e:	f04f 0301 	mov.w	r3, #1
 800ef92:	f000 bd67 	b.w	800fa64 <f_mkfs+0xba4>
		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
 800ef96:	79bb      	ldrb	r3, [r7, #6]
 800ef98:	2b00      	cmp	r3, #0
 800ef9a:	d002      	beq.n	800efa2 <f_mkfs+0xe2>
 800ef9c:	f04f 0300 	mov.w	r3, #0
 800efa0:	e001      	b.n	800efa6 <f_mkfs+0xe6>
 800efa2:	f04f 033f 	mov.w	r3, #63	; 0x3f
 800efa6:	633b      	str	r3, [r7, #48]	; 0x30
		n_vol -= b_vol;				/* Volume size */
 800efa8:	697a      	ldr	r2, [r7, #20]
 800efaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800efac:	1ad3      	subs	r3, r2, r3
 800efae:	617b      	str	r3, [r7, #20]
	}

	if (!au) {				/* AU auto selection */
 800efb0:	683b      	ldr	r3, [r7, #0]
 800efb2:	2b00      	cmp	r3, #0
 800efb4:	d124      	bne.n	800f000 <f_mkfs+0x140>
		vs = n_vol / (2000 / (SS(fs) / 512));
 800efb6:	697a      	ldr	r2, [r7, #20]
 800efb8:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800efbc:	f2c1 0362 	movt	r3, #4194	; 0x1062
 800efc0:	fba3 1302 	umull	r1, r3, r3, r2
 800efc4:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 800efc8:	62fb      	str	r3, [r7, #44]	; 0x2c
		for (i = 0; vs < vst[i]; i++) ;
 800efca:	f04f 0300 	mov.w	r3, #0
 800efce:	64fb      	str	r3, [r7, #76]	; 0x4c
 800efd0:	e003      	b.n	800efda <f_mkfs+0x11a>
 800efd2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800efd4:	f103 0301 	add.w	r3, r3, #1
 800efd8:	64fb      	str	r3, [r7, #76]	; 0x4c
 800efda:	f246 7308 	movw	r3, #26376	; 0x6708
 800efde:	f6c0 0302 	movt	r3, #2050	; 0x802
 800efe2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800efe4:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800efe8:	461a      	mov	r2, r3
 800efea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800efec:	429a      	cmp	r2, r3
 800efee:	d8f0      	bhi.n	800efd2 <f_mkfs+0x112>
		au = cst[i];
 800eff0:	f246 7320 	movw	r3, #26400	; 0x6720
 800eff4:	f6c0 0302 	movt	r3, #2050	; 0x802
 800eff8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800effa:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 800effe:	603b      	str	r3, [r7, #0]
	}
	au /= SS(fs);		/* Number of sectors per cluster */
 800f000:	683b      	ldr	r3, [r7, #0]
 800f002:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800f006:	603b      	str	r3, [r7, #0]
	if (au == 0) au = 1;
 800f008:	683b      	ldr	r3, [r7, #0]
 800f00a:	2b00      	cmp	r3, #0
 800f00c:	d102      	bne.n	800f014 <f_mkfs+0x154>
 800f00e:	f04f 0301 	mov.w	r3, #1
 800f012:	603b      	str	r3, [r7, #0]
	if (au > 128) au = 128;
 800f014:	683b      	ldr	r3, [r7, #0]
 800f016:	2b80      	cmp	r3, #128	; 0x80
 800f018:	d902      	bls.n	800f020 <f_mkfs+0x160>
 800f01a:	f04f 0380 	mov.w	r3, #128	; 0x80
 800f01e:	603b      	str	r3, [r7, #0]

	/* Pre-compute number of clusters and FAT syb-type */
	n_clst = n_vol / au;
 800f020:	697a      	ldr	r2, [r7, #20]
 800f022:	683b      	ldr	r3, [r7, #0]
 800f024:	fbb2 f3f3 	udiv	r3, r2, r3
 800f028:	62bb      	str	r3, [r7, #40]	; 0x28
	fmt = FS_FAT12;
 800f02a:	f04f 0301 	mov.w	r3, #1
 800f02e:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
 800f032:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f034:	f640 73f5 	movw	r3, #4085	; 0xff5
 800f038:	429a      	cmp	r2, r3
 800f03a:	d903      	bls.n	800f044 <f_mkfs+0x184>
 800f03c:	f04f 0302 	mov.w	r3, #2
 800f040:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
 800f044:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f046:	f64f 73f5 	movw	r3, #65525	; 0xfff5
 800f04a:	429a      	cmp	r2, r3
 800f04c:	d903      	bls.n	800f056 <f_mkfs+0x196>
 800f04e:	f04f 0303 	mov.w	r3, #3
 800f052:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

	/* Determine offset and size of FAT structure */
	if (fmt == FS_FAT32) {
 800f056:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f05a:	2b03      	cmp	r3, #3
 800f05c:	d110      	bne.n	800f080 <f_mkfs+0x1c0>
		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
 800f05e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f060:	f103 0382 	add.w	r3, r3, #130	; 0x82
 800f064:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800f068:	f103 33ff 	add.w	r3, r3, #4294967295
 800f06c:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800f070:	643b      	str	r3, [r7, #64]	; 0x40
		n_rsv = 32;
 800f072:	f04f 0320 	mov.w	r3, #32
 800f076:	647b      	str	r3, [r7, #68]	; 0x44
		n_dir = 0;
 800f078:	f04f 0300 	mov.w	r3, #0
 800f07c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800f07e:	e021      	b.n	800f0c4 <f_mkfs+0x204>
	} else {
		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
 800f080:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f084:	2b01      	cmp	r3, #1
 800f086:	d10b      	bne.n	800f0a0 <f_mkfs+0x1e0>
 800f088:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f08a:	4613      	mov	r3, r2
 800f08c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800f090:	189b      	adds	r3, r3, r2
 800f092:	f103 0301 	add.w	r3, r3, #1
 800f096:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800f09a:	f103 0303 	add.w	r3, r3, #3
 800f09e:	e004      	b.n	800f0aa <f_mkfs+0x1ea>
 800f0a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f0a2:	f103 0302 	add.w	r3, r3, #2
 800f0a6:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800f0aa:	643b      	str	r3, [r7, #64]	; 0x40
		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
 800f0ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f0ae:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800f0b2:	ea4f 2353 	mov.w	r3, r3, lsr #9
 800f0b6:	643b      	str	r3, [r7, #64]	; 0x40
		n_rsv = 1;
 800f0b8:	f04f 0301 	mov.w	r3, #1
 800f0bc:	647b      	str	r3, [r7, #68]	; 0x44
		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
 800f0be:	f04f 0320 	mov.w	r3, #32
 800f0c2:	63fb      	str	r3, [r7, #60]	; 0x3c
	}
	b_fat = b_vol + n_rsv;				/* FAT area start sector */
 800f0c4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f0c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f0c8:	18d3      	adds	r3, r2, r3
 800f0ca:	64bb      	str	r3, [r7, #72]	; 0x48
	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
 800f0cc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f0ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f0d0:	18d3      	adds	r3, r2, r3
 800f0d2:	627b      	str	r3, [r7, #36]	; 0x24
	b_data = b_dir + n_dir;				/* Data area start sector */
 800f0d4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800f0d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f0d8:	18d3      	adds	r3, r2, r3
 800f0da:	623b      	str	r3, [r7, #32]
	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
 800f0dc:	6a3a      	ldr	r2, [r7, #32]
 800f0de:	683b      	ldr	r3, [r7, #0]
 800f0e0:	18d2      	adds	r2, r2, r3
 800f0e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f0e4:	1ad2      	subs	r2, r2, r3
 800f0e6:	697b      	ldr	r3, [r7, #20]
 800f0e8:	429a      	cmp	r2, r3
 800f0ea:	d903      	bls.n	800f0f4 <f_mkfs+0x234>
 800f0ec:	f04f 030e 	mov.w	r3, #14
 800f0f0:	f000 bcb8 	b.w	800fa64 <f_mkfs+0xba4>

	/* Align data start sector to erase block boundary (for flash memory media) */
	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
 800f0f4:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800f0f8:	f107 0318 	add.w	r3, r7, #24
 800f0fc:	4610      	mov	r0, r2
 800f0fe:	f04f 0103 	mov.w	r1, #3
 800f102:	461a      	mov	r2, r3
 800f104:	f7fc f980 	bl	800b408 <disk_ioctl>
 800f108:	4603      	mov	r3, r0
 800f10a:	2b00      	cmp	r3, #0
 800f10c:	d106      	bne.n	800f11c <f_mkfs+0x25c>
 800f10e:	69bb      	ldr	r3, [r7, #24]
 800f110:	2b00      	cmp	r3, #0
 800f112:	d003      	beq.n	800f11c <f_mkfs+0x25c>
 800f114:	69bb      	ldr	r3, [r7, #24]
 800f116:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800f11a:	d902      	bls.n	800f122 <f_mkfs+0x262>
 800f11c:	f04f 0301 	mov.w	r3, #1
 800f120:	61bb      	str	r3, [r7, #24]
	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
 800f122:	69ba      	ldr	r2, [r7, #24]
 800f124:	6a3b      	ldr	r3, [r7, #32]
 800f126:	18d3      	adds	r3, r2, r3
 800f128:	f103 32ff 	add.w	r2, r3, #4294967295
 800f12c:	69bb      	ldr	r3, [r7, #24]
 800f12e:	f1c3 0300 	rsb	r3, r3, #0
 800f132:	4013      	ands	r3, r2
 800f134:	61bb      	str	r3, [r7, #24]
	n = (n - b_data) / N_FATS;
 800f136:	69ba      	ldr	r2, [r7, #24]
 800f138:	6a3b      	ldr	r3, [r7, #32]
 800f13a:	1ad3      	subs	r3, r2, r3
 800f13c:	61bb      	str	r3, [r7, #24]
	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
 800f13e:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f142:	2b03      	cmp	r3, #3
 800f144:	d108      	bne.n	800f158 <f_mkfs+0x298>
		n_rsv += n;
 800f146:	69bb      	ldr	r3, [r7, #24]
 800f148:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f14a:	18d3      	adds	r3, r2, r3
 800f14c:	647b      	str	r3, [r7, #68]	; 0x44
		b_fat += n;
 800f14e:	69bb      	ldr	r3, [r7, #24]
 800f150:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800f152:	18d3      	adds	r3, r2, r3
 800f154:	64bb      	str	r3, [r7, #72]	; 0x48
 800f156:	e003      	b.n	800f160 <f_mkfs+0x2a0>
	} else {					/* FAT12/16: Expand FAT size */
		n_fat += n;
 800f158:	69bb      	ldr	r3, [r7, #24]
 800f15a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f15c:	18d3      	adds	r3, r2, r3
 800f15e:	643b      	str	r3, [r7, #64]	; 0x40
	}

	/* Determine number of clusters and final check of validity of the FAT sub-type */
	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
 800f160:	697a      	ldr	r2, [r7, #20]
 800f162:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800f164:	1ad2      	subs	r2, r2, r3
 800f166:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f168:	1ad2      	subs	r2, r2, r3
 800f16a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f16c:	1ad2      	subs	r2, r2, r3
 800f16e:	683b      	ldr	r3, [r7, #0]
 800f170:	fbb2 f3f3 	udiv	r3, r2, r3
 800f174:	62bb      	str	r3, [r7, #40]	; 0x28
	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
 800f176:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f17a:	2b02      	cmp	r3, #2
 800f17c:	d104      	bne.n	800f188 <f_mkfs+0x2c8>
 800f17e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f180:	f640 73f5 	movw	r3, #4085	; 0xff5
 800f184:	429a      	cmp	r2, r3
 800f186:	d908      	bls.n	800f19a <f_mkfs+0x2da>
		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
 800f188:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f18c:	2b03      	cmp	r3, #3
 800f18e:	d108      	bne.n	800f1a2 <f_mkfs+0x2e2>
 800f190:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f192:	f64f 73f5 	movw	r3, #65525	; 0xfff5
 800f196:	429a      	cmp	r2, r3
 800f198:	d803      	bhi.n	800f1a2 <f_mkfs+0x2e2>
		return FR_MKFS_ABORTED;
 800f19a:	f04f 030e 	mov.w	r3, #14
 800f19e:	f000 bc61 	b.w	800fa64 <f_mkfs+0xba4>

	switch (fmt) {	/* Determine system ID for partition table */
 800f1a2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f1a6:	2b01      	cmp	r3, #1
 800f1a8:	d002      	beq.n	800f1b0 <f_mkfs+0x2f0>
 800f1aa:	2b02      	cmp	r3, #2
 800f1ac:	d005      	beq.n	800f1ba <f_mkfs+0x2fa>
 800f1ae:	e011      	b.n	800f1d4 <f_mkfs+0x314>
	case FS_FAT12:	sys = 0x01; break;
 800f1b0:	f04f 0301 	mov.w	r3, #1
 800f1b4:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
 800f1b8:	e010      	b.n	800f1dc <f_mkfs+0x31c>
	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
 800f1ba:	697a      	ldr	r2, [r7, #20]
 800f1bc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800f1c0:	429a      	cmp	r2, r3
 800f1c2:	d802      	bhi.n	800f1ca <f_mkfs+0x30a>
 800f1c4:	f04f 0304 	mov.w	r3, #4
 800f1c8:	e001      	b.n	800f1ce <f_mkfs+0x30e>
 800f1ca:	f04f 0306 	mov.w	r3, #6
 800f1ce:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
 800f1d2:	e003      	b.n	800f1dc <f_mkfs+0x31c>
	default: 		sys = 0x0C;
 800f1d4:	f04f 030c 	mov.w	r3, #12
 800f1d8:	f887 3055 	strb.w	r3, [r7, #85]	; 0x55
		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
		tbl[4] = sys;
		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
		md = 0xF8;
	} else {
		if (sfd) {	/* No patition table (SFD) */
 800f1dc:	79bb      	ldrb	r3, [r7, #6]
 800f1de:	2b00      	cmp	r3, #0
 800f1e0:	d004      	beq.n	800f1ec <f_mkfs+0x32c>
			md = 0xF0;
 800f1e2:	f04f 03f0 	mov.w	r3, #240	; 0xf0
 800f1e6:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
 800f1ea:	e0a5      	b.n	800f338 <f_mkfs+0x478>
		} else {	/* Create partition table (FDISK) */
			mem_set(fs->win, 0, SS(fs));
 800f1ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f1ee:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800f1f2:	4618      	mov	r0, r3
 800f1f4:	f04f 0100 	mov.w	r1, #0
 800f1f8:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f1fc:	f7fc f99e 	bl	800b53c <mem_set>
			tbl = fs->win+MBR_Table;	/* Create partiton table for single partition in the drive */
 800f200:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f202:	f503 73f9 	add.w	r3, r3, #498	; 0x1f2
 800f206:	61fb      	str	r3, [r7, #28]
			tbl[1] = 1;						/* Partition start head */
 800f208:	69fb      	ldr	r3, [r7, #28]
 800f20a:	f103 0301 	add.w	r3, r3, #1
 800f20e:	f04f 0201 	mov.w	r2, #1
 800f212:	701a      	strb	r2, [r3, #0]
			tbl[2] = 1;						/* Partition start sector */
 800f214:	69fb      	ldr	r3, [r7, #28]
 800f216:	f103 0302 	add.w	r3, r3, #2
 800f21a:	f04f 0201 	mov.w	r2, #1
 800f21e:	701a      	strb	r2, [r3, #0]
			tbl[3] = 0;						/* Partition start cylinder */
 800f220:	69fb      	ldr	r3, [r7, #28]
 800f222:	f103 0303 	add.w	r3, r3, #3
 800f226:	f04f 0200 	mov.w	r2, #0
 800f22a:	701a      	strb	r2, [r3, #0]
			tbl[4] = sys;					/* System type */
 800f22c:	69fb      	ldr	r3, [r7, #28]
 800f22e:	f103 0304 	add.w	r3, r3, #4
 800f232:	f897 2055 	ldrb.w	r2, [r7, #85]	; 0x55
 800f236:	701a      	strb	r2, [r3, #0]
			tbl[5] = 254;					/* Partition end head */
 800f238:	69fb      	ldr	r3, [r7, #28]
 800f23a:	f103 0305 	add.w	r3, r3, #5
 800f23e:	f04f 02fe 	mov.w	r2, #254	; 0xfe
 800f242:	701a      	strb	r2, [r3, #0]
			n = (b_vol + n_vol) / 63 / 255;
 800f244:	697a      	ldr	r2, [r7, #20]
 800f246:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f248:	18d2      	adds	r2, r2, r3
 800f24a:	f245 635b 	movw	r3, #22107	; 0x565b
 800f24e:	f2c0 5315 	movt	r3, #1301	; 0x515
 800f252:	fba3 1302 	umull	r1, r3, r3, r2
 800f256:	1ad2      	subs	r2, r2, r3
 800f258:	ea4f 0252 	mov.w	r2, r2, lsr #1
 800f25c:	189b      	adds	r3, r3, r2
 800f25e:	ea4f 3353 	mov.w	r3, r3, lsr #13
 800f262:	61bb      	str	r3, [r7, #24]
			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partiiton end sector */
 800f264:	69fb      	ldr	r3, [r7, #28]
 800f266:	f103 0306 	add.w	r3, r3, #6
 800f26a:	69ba      	ldr	r2, [r7, #24]
 800f26c:	ea4f 0292 	mov.w	r2, r2, lsr #2
 800f270:	b2d2      	uxtb	r2, r2
 800f272:	f042 023f 	orr.w	r2, r2, #63	; 0x3f
 800f276:	b2d2      	uxtb	r2, r2
 800f278:	701a      	strb	r2, [r3, #0]
			tbl[7] = (BYTE)n;				/* End cylinder */
 800f27a:	69fb      	ldr	r3, [r7, #28]
 800f27c:	f103 0307 	add.w	r3, r3, #7
 800f280:	69ba      	ldr	r2, [r7, #24]
 800f282:	b2d2      	uxtb	r2, r2
 800f284:	701a      	strb	r2, [r3, #0]
			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
 800f286:	69fb      	ldr	r3, [r7, #28]
 800f288:	f103 0308 	add.w	r3, r3, #8
 800f28c:	f04f 023f 	mov.w	r2, #63	; 0x3f
 800f290:	701a      	strb	r2, [r3, #0]
 800f292:	69fb      	ldr	r3, [r7, #28]
 800f294:	f103 0309 	add.w	r3, r3, #9
 800f298:	f04f 0200 	mov.w	r2, #0
 800f29c:	701a      	strb	r2, [r3, #0]
 800f29e:	69fb      	ldr	r3, [r7, #28]
 800f2a0:	f103 030a 	add.w	r3, r3, #10
 800f2a4:	f04f 0200 	mov.w	r2, #0
 800f2a8:	701a      	strb	r2, [r3, #0]
 800f2aa:	69fb      	ldr	r3, [r7, #28]
 800f2ac:	f103 030b 	add.w	r3, r3, #11
 800f2b0:	f04f 0200 	mov.w	r2, #0
 800f2b4:	701a      	strb	r2, [r3, #0]
			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
 800f2b6:	69fb      	ldr	r3, [r7, #28]
 800f2b8:	f103 030c 	add.w	r3, r3, #12
 800f2bc:	697a      	ldr	r2, [r7, #20]
 800f2be:	b2d2      	uxtb	r2, r2
 800f2c0:	701a      	strb	r2, [r3, #0]
 800f2c2:	69fb      	ldr	r3, [r7, #28]
 800f2c4:	f103 030d 	add.w	r3, r3, #13
 800f2c8:	697a      	ldr	r2, [r7, #20]
 800f2ca:	b292      	uxth	r2, r2
 800f2cc:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f2d0:	b292      	uxth	r2, r2
 800f2d2:	b2d2      	uxtb	r2, r2
 800f2d4:	701a      	strb	r2, [r3, #0]
 800f2d6:	69fb      	ldr	r3, [r7, #28]
 800f2d8:	f103 030e 	add.w	r3, r3, #14
 800f2dc:	697a      	ldr	r2, [r7, #20]
 800f2de:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f2e2:	b2d2      	uxtb	r2, r2
 800f2e4:	701a      	strb	r2, [r3, #0]
 800f2e6:	69fb      	ldr	r3, [r7, #28]
 800f2e8:	f103 030f 	add.w	r3, r3, #15
 800f2ec:	697a      	ldr	r2, [r7, #20]
 800f2ee:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f2f2:	b2d2      	uxtb	r2, r2
 800f2f4:	701a      	strb	r2, [r3, #0]
			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
 800f2f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f2f8:	f04f 0255 	mov.w	r2, #85	; 0x55
 800f2fc:	f883 2232 	strb.w	r2, [r3, #562]	; 0x232
 800f300:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f302:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 800f306:	f883 2233 	strb.w	r2, [r3, #563]	; 0x233
			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
 800f30a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f30c:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800f310:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800f314:	4610      	mov	r0, r2
 800f316:	4619      	mov	r1, r3
 800f318:	f04f 0200 	mov.w	r2, #0
 800f31c:	f04f 0301 	mov.w	r3, #1
 800f320:	f7fc f830 	bl	800b384 <disk_write>
 800f324:	4603      	mov	r3, r0
 800f326:	2b00      	cmp	r3, #0
 800f328:	d002      	beq.n	800f330 <f_mkfs+0x470>
				return FR_DISK_ERR;
 800f32a:	f04f 0301 	mov.w	r3, #1
 800f32e:	e399      	b.n	800fa64 <f_mkfs+0xba4>
			md = 0xF8;
 800f330:	f04f 03f8 	mov.w	r3, #248	; 0xf8
 800f334:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
		}
	}

	/* Create BPB in the VBR */
	tbl = fs->win;							/* Clear sector */
 800f338:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800f33a:	f103 0334 	add.w	r3, r3, #52	; 0x34
 800f33e:	61fb      	str	r3, [r7, #28]
	mem_set(tbl, 0, SS(fs));
 800f340:	69f8      	ldr	r0, [r7, #28]
 800f342:	f04f 0100 	mov.w	r1, #0
 800f346:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f34a:	f7fc f8f7 	bl	800b53c <mem_set>
	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
 800f34e:	69f8      	ldr	r0, [r7, #28]
 800f350:	f246 61d4 	movw	r1, #26324	; 0x66d4
 800f354:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f358:	f04f 020b 	mov.w	r2, #11
 800f35c:	f7fc f8c6 	bl	800b4ec <mem_cpy>
	i = SS(fs);								/* Sector size */
 800f360:	f44f 7300 	mov.w	r3, #512	; 0x200
 800f364:	64fb      	str	r3, [r7, #76]	; 0x4c
	ST_WORD(tbl+BPB_BytsPerSec, i);
 800f366:	69fb      	ldr	r3, [r7, #28]
 800f368:	f103 030b 	add.w	r3, r3, #11
 800f36c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f36e:	b2d2      	uxtb	r2, r2
 800f370:	701a      	strb	r2, [r3, #0]
 800f372:	69fb      	ldr	r3, [r7, #28]
 800f374:	f103 030c 	add.w	r3, r3, #12
 800f378:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f37a:	b292      	uxth	r2, r2
 800f37c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f380:	b292      	uxth	r2, r2
 800f382:	b2d2      	uxtb	r2, r2
 800f384:	701a      	strb	r2, [r3, #0]
	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
 800f386:	69fb      	ldr	r3, [r7, #28]
 800f388:	f103 030d 	add.w	r3, r3, #13
 800f38c:	683a      	ldr	r2, [r7, #0]
 800f38e:	b2d2      	uxtb	r2, r2
 800f390:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
 800f392:	69fb      	ldr	r3, [r7, #28]
 800f394:	f103 030e 	add.w	r3, r3, #14
 800f398:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f39a:	b2d2      	uxtb	r2, r2
 800f39c:	701a      	strb	r2, [r3, #0]
 800f39e:	69fb      	ldr	r3, [r7, #28]
 800f3a0:	f103 030f 	add.w	r3, r3, #15
 800f3a4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800f3a6:	b292      	uxth	r2, r2
 800f3a8:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f3ac:	b292      	uxth	r2, r2
 800f3ae:	b2d2      	uxtb	r2, r2
 800f3b0:	701a      	strb	r2, [r3, #0]
	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
 800f3b2:	69fb      	ldr	r3, [r7, #28]
 800f3b4:	f103 0310 	add.w	r3, r3, #16
 800f3b8:	f04f 0201 	mov.w	r2, #1
 800f3bc:	701a      	strb	r2, [r3, #0]
	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
 800f3be:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f3c2:	2b03      	cmp	r3, #3
 800f3c4:	d102      	bne.n	800f3cc <f_mkfs+0x50c>
 800f3c6:	f04f 0300 	mov.w	r3, #0
 800f3ca:	e001      	b.n	800f3d0 <f_mkfs+0x510>
 800f3cc:	f44f 7300 	mov.w	r3, #512	; 0x200
 800f3d0:	64fb      	str	r3, [r7, #76]	; 0x4c
	ST_WORD(tbl+BPB_RootEntCnt, i);
 800f3d2:	69fb      	ldr	r3, [r7, #28]
 800f3d4:	f103 0311 	add.w	r3, r3, #17
 800f3d8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f3da:	b2d2      	uxtb	r2, r2
 800f3dc:	701a      	strb	r2, [r3, #0]
 800f3de:	69fb      	ldr	r3, [r7, #28]
 800f3e0:	f103 0312 	add.w	r3, r3, #18
 800f3e4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800f3e6:	b292      	uxth	r2, r2
 800f3e8:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f3ec:	b292      	uxth	r2, r2
 800f3ee:	b2d2      	uxtb	r2, r2
 800f3f0:	701a      	strb	r2, [r3, #0]
	if (n_vol < 0x10000) {					/* Number of total sectors */
 800f3f2:	697a      	ldr	r2, [r7, #20]
 800f3f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800f3f8:	429a      	cmp	r2, r3
 800f3fa:	d810      	bhi.n	800f41e <f_mkfs+0x55e>
		ST_WORD(tbl+BPB_TotSec16, n_vol);
 800f3fc:	69fb      	ldr	r3, [r7, #28]
 800f3fe:	f103 0313 	add.w	r3, r3, #19
 800f402:	697a      	ldr	r2, [r7, #20]
 800f404:	b2d2      	uxtb	r2, r2
 800f406:	701a      	strb	r2, [r3, #0]
 800f408:	69fb      	ldr	r3, [r7, #28]
 800f40a:	f103 0314 	add.w	r3, r3, #20
 800f40e:	697a      	ldr	r2, [r7, #20]
 800f410:	b292      	uxth	r2, r2
 800f412:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f416:	b292      	uxth	r2, r2
 800f418:	b2d2      	uxtb	r2, r2
 800f41a:	701a      	strb	r2, [r3, #0]
 800f41c:	e01f      	b.n	800f45e <f_mkfs+0x59e>
	} else {
		ST_DWORD(tbl+BPB_TotSec32, n_vol);
 800f41e:	69fb      	ldr	r3, [r7, #28]
 800f420:	f103 0320 	add.w	r3, r3, #32
 800f424:	697a      	ldr	r2, [r7, #20]
 800f426:	b2d2      	uxtb	r2, r2
 800f428:	701a      	strb	r2, [r3, #0]
 800f42a:	69fb      	ldr	r3, [r7, #28]
 800f42c:	f103 0321 	add.w	r3, r3, #33	; 0x21
 800f430:	697a      	ldr	r2, [r7, #20]
 800f432:	b292      	uxth	r2, r2
 800f434:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f438:	b292      	uxth	r2, r2
 800f43a:	b2d2      	uxtb	r2, r2
 800f43c:	701a      	strb	r2, [r3, #0]
 800f43e:	69fb      	ldr	r3, [r7, #28]
 800f440:	f103 0322 	add.w	r3, r3, #34	; 0x22
 800f444:	697a      	ldr	r2, [r7, #20]
 800f446:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f44a:	b2d2      	uxtb	r2, r2
 800f44c:	701a      	strb	r2, [r3, #0]
 800f44e:	69fb      	ldr	r3, [r7, #28]
 800f450:	f103 0323 	add.w	r3, r3, #35	; 0x23
 800f454:	697a      	ldr	r2, [r7, #20]
 800f456:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f45a:	b2d2      	uxtb	r2, r2
 800f45c:	701a      	strb	r2, [r3, #0]
	}
	tbl[BPB_Media] = md;					/* Media descriptor */
 800f45e:	69fb      	ldr	r3, [r7, #28]
 800f460:	f103 0315 	add.w	r3, r3, #21
 800f464:	f897 2056 	ldrb.w	r2, [r7, #86]	; 0x56
 800f468:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
 800f46a:	69fb      	ldr	r3, [r7, #28]
 800f46c:	f103 0318 	add.w	r3, r3, #24
 800f470:	f04f 023f 	mov.w	r2, #63	; 0x3f
 800f474:	701a      	strb	r2, [r3, #0]
 800f476:	69fb      	ldr	r3, [r7, #28]
 800f478:	f103 0319 	add.w	r3, r3, #25
 800f47c:	f04f 0200 	mov.w	r2, #0
 800f480:	701a      	strb	r2, [r3, #0]
	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
 800f482:	69fb      	ldr	r3, [r7, #28]
 800f484:	f103 031a 	add.w	r3, r3, #26
 800f488:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f48c:	701a      	strb	r2, [r3, #0]
 800f48e:	69fb      	ldr	r3, [r7, #28]
 800f490:	f103 031b 	add.w	r3, r3, #27
 800f494:	f04f 0200 	mov.w	r2, #0
 800f498:	701a      	strb	r2, [r3, #0]
	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
 800f49a:	69fb      	ldr	r3, [r7, #28]
 800f49c:	f103 031c 	add.w	r3, r3, #28
 800f4a0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f4a2:	b2d2      	uxtb	r2, r2
 800f4a4:	701a      	strb	r2, [r3, #0]
 800f4a6:	69fb      	ldr	r3, [r7, #28]
 800f4a8:	f103 031d 	add.w	r3, r3, #29
 800f4ac:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f4ae:	b292      	uxth	r2, r2
 800f4b0:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f4b4:	b292      	uxth	r2, r2
 800f4b6:	b2d2      	uxtb	r2, r2
 800f4b8:	701a      	strb	r2, [r3, #0]
 800f4ba:	69fb      	ldr	r3, [r7, #28]
 800f4bc:	f103 031e 	add.w	r3, r3, #30
 800f4c0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f4c2:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f4c6:	b2d2      	uxtb	r2, r2
 800f4c8:	701a      	strb	r2, [r3, #0]
 800f4ca:	69fb      	ldr	r3, [r7, #28]
 800f4cc:	f103 031f 	add.w	r3, r3, #31
 800f4d0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f4d2:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f4d6:	b2d2      	uxtb	r2, r2
 800f4d8:	701a      	strb	r2, [r3, #0]
	n = get_fattime();						/* Use current time as VSN */
 800f4da:	f7fb ffcf 	bl	800b47c <get_fattime>
 800f4de:	4603      	mov	r3, r0
 800f4e0:	61bb      	str	r3, [r7, #24]
	if (fmt == FS_FAT32) {
 800f4e2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f4e6:	2b03      	cmp	r3, #3
 800f4e8:	f040 8089 	bne.w	800f5fe <f_mkfs+0x73e>
		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
 800f4ec:	69fb      	ldr	r3, [r7, #28]
 800f4ee:	f103 0343 	add.w	r3, r3, #67	; 0x43
 800f4f2:	69ba      	ldr	r2, [r7, #24]
 800f4f4:	b2d2      	uxtb	r2, r2
 800f4f6:	701a      	strb	r2, [r3, #0]
 800f4f8:	69fb      	ldr	r3, [r7, #28]
 800f4fa:	f103 0344 	add.w	r3, r3, #68	; 0x44
 800f4fe:	69ba      	ldr	r2, [r7, #24]
 800f500:	b292      	uxth	r2, r2
 800f502:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f506:	b292      	uxth	r2, r2
 800f508:	b2d2      	uxtb	r2, r2
 800f50a:	701a      	strb	r2, [r3, #0]
 800f50c:	69fb      	ldr	r3, [r7, #28]
 800f50e:	f103 0345 	add.w	r3, r3, #69	; 0x45
 800f512:	69ba      	ldr	r2, [r7, #24]
 800f514:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f518:	b2d2      	uxtb	r2, r2
 800f51a:	701a      	strb	r2, [r3, #0]
 800f51c:	69fb      	ldr	r3, [r7, #28]
 800f51e:	f103 0346 	add.w	r3, r3, #70	; 0x46
 800f522:	69ba      	ldr	r2, [r7, #24]
 800f524:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f528:	b2d2      	uxtb	r2, r2
 800f52a:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
 800f52c:	69fb      	ldr	r3, [r7, #28]
 800f52e:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800f532:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f534:	b2d2      	uxtb	r2, r2
 800f536:	701a      	strb	r2, [r3, #0]
 800f538:	69fb      	ldr	r3, [r7, #28]
 800f53a:	f103 0325 	add.w	r3, r3, #37	; 0x25
 800f53e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f540:	b292      	uxth	r2, r2
 800f542:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f546:	b292      	uxth	r2, r2
 800f548:	b2d2      	uxtb	r2, r2
 800f54a:	701a      	strb	r2, [r3, #0]
 800f54c:	69fb      	ldr	r3, [r7, #28]
 800f54e:	f103 0326 	add.w	r3, r3, #38	; 0x26
 800f552:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f554:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f558:	b2d2      	uxtb	r2, r2
 800f55a:	701a      	strb	r2, [r3, #0]
 800f55c:	69fb      	ldr	r3, [r7, #28]
 800f55e:	f103 0327 	add.w	r3, r3, #39	; 0x27
 800f562:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f564:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f568:	b2d2      	uxtb	r2, r2
 800f56a:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
 800f56c:	69fb      	ldr	r3, [r7, #28]
 800f56e:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 800f572:	f04f 0202 	mov.w	r2, #2
 800f576:	701a      	strb	r2, [r3, #0]
 800f578:	69fb      	ldr	r3, [r7, #28]
 800f57a:	f103 032d 	add.w	r3, r3, #45	; 0x2d
 800f57e:	f04f 0200 	mov.w	r2, #0
 800f582:	701a      	strb	r2, [r3, #0]
 800f584:	69fb      	ldr	r3, [r7, #28]
 800f586:	f103 032e 	add.w	r3, r3, #46	; 0x2e
 800f58a:	f04f 0200 	mov.w	r2, #0
 800f58e:	701a      	strb	r2, [r3, #0]
 800f590:	69fb      	ldr	r3, [r7, #28]
 800f592:	f103 032f 	add.w	r3, r3, #47	; 0x2f
 800f596:	f04f 0200 	mov.w	r2, #0
 800f59a:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
 800f59c:	69fb      	ldr	r3, [r7, #28]
 800f59e:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800f5a2:	f04f 0201 	mov.w	r2, #1
 800f5a6:	701a      	strb	r2, [r3, #0]
 800f5a8:	69fb      	ldr	r3, [r7, #28]
 800f5aa:	f103 0331 	add.w	r3, r3, #49	; 0x31
 800f5ae:	f04f 0200 	mov.w	r2, #0
 800f5b2:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
 800f5b4:	69fb      	ldr	r3, [r7, #28]
 800f5b6:	f103 0332 	add.w	r3, r3, #50	; 0x32
 800f5ba:	f04f 0206 	mov.w	r2, #6
 800f5be:	701a      	strb	r2, [r3, #0]
 800f5c0:	69fb      	ldr	r3, [r7, #28]
 800f5c2:	f103 0333 	add.w	r3, r3, #51	; 0x33
 800f5c6:	f04f 0200 	mov.w	r2, #0
 800f5ca:	701a      	strb	r2, [r3, #0]
		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
 800f5cc:	69fb      	ldr	r3, [r7, #28]
 800f5ce:	f103 0340 	add.w	r3, r3, #64	; 0x40
 800f5d2:	f04f 0280 	mov.w	r2, #128	; 0x80
 800f5d6:	701a      	strb	r2, [r3, #0]
		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
 800f5d8:	69fb      	ldr	r3, [r7, #28]
 800f5da:	f103 0342 	add.w	r3, r3, #66	; 0x42
 800f5de:	f04f 0229 	mov.w	r2, #41	; 0x29
 800f5e2:	701a      	strb	r2, [r3, #0]
		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
 800f5e4:	69fb      	ldr	r3, [r7, #28]
 800f5e6:	f103 0347 	add.w	r3, r3, #71	; 0x47
 800f5ea:	4618      	mov	r0, r3
 800f5ec:	f246 61e0 	movw	r1, #26336	; 0x66e0
 800f5f0:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f5f4:	f04f 0213 	mov.w	r2, #19
 800f5f8:	f7fb ff78 	bl	800b4ec <mem_cpy>
 800f5fc:	e047      	b.n	800f68e <f_mkfs+0x7ce>
	} else {
		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
 800f5fe:	69fb      	ldr	r3, [r7, #28]
 800f600:	f103 0327 	add.w	r3, r3, #39	; 0x27
 800f604:	69ba      	ldr	r2, [r7, #24]
 800f606:	b2d2      	uxtb	r2, r2
 800f608:	701a      	strb	r2, [r3, #0]
 800f60a:	69fb      	ldr	r3, [r7, #28]
 800f60c:	f103 0328 	add.w	r3, r3, #40	; 0x28
 800f610:	69ba      	ldr	r2, [r7, #24]
 800f612:	b292      	uxth	r2, r2
 800f614:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f618:	b292      	uxth	r2, r2
 800f61a:	b2d2      	uxtb	r2, r2
 800f61c:	701a      	strb	r2, [r3, #0]
 800f61e:	69fb      	ldr	r3, [r7, #28]
 800f620:	f103 0329 	add.w	r3, r3, #41	; 0x29
 800f624:	69ba      	ldr	r2, [r7, #24]
 800f626:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f62a:	b2d2      	uxtb	r2, r2
 800f62c:	701a      	strb	r2, [r3, #0]
 800f62e:	69fb      	ldr	r3, [r7, #28]
 800f630:	f103 032a 	add.w	r3, r3, #42	; 0x2a
 800f634:	69ba      	ldr	r2, [r7, #24]
 800f636:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f63a:	b2d2      	uxtb	r2, r2
 800f63c:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
 800f63e:	69fb      	ldr	r3, [r7, #28]
 800f640:	f103 0316 	add.w	r3, r3, #22
 800f644:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f646:	b2d2      	uxtb	r2, r2
 800f648:	701a      	strb	r2, [r3, #0]
 800f64a:	69fb      	ldr	r3, [r7, #28]
 800f64c:	f103 0317 	add.w	r3, r3, #23
 800f650:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f652:	b292      	uxth	r2, r2
 800f654:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f658:	b292      	uxth	r2, r2
 800f65a:	b2d2      	uxtb	r2, r2
 800f65c:	701a      	strb	r2, [r3, #0]
		tbl[BS_DrvNum] = 0x80;				/* Drive number */
 800f65e:	69fb      	ldr	r3, [r7, #28]
 800f660:	f103 0324 	add.w	r3, r3, #36	; 0x24
 800f664:	f04f 0280 	mov.w	r2, #128	; 0x80
 800f668:	701a      	strb	r2, [r3, #0]
		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
 800f66a:	69fb      	ldr	r3, [r7, #28]
 800f66c:	f103 0326 	add.w	r3, r3, #38	; 0x26
 800f670:	f04f 0229 	mov.w	r2, #41	; 0x29
 800f674:	701a      	strb	r2, [r3, #0]
		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
 800f676:	69fb      	ldr	r3, [r7, #28]
 800f678:	f103 032b 	add.w	r3, r3, #43	; 0x2b
 800f67c:	4618      	mov	r0, r3
 800f67e:	f246 61f4 	movw	r1, #26356	; 0x66f4
 800f682:	f6c0 0102 	movt	r1, #2050	; 0x802
 800f686:	f04f 0213 	mov.w	r2, #19
 800f68a:	f7fb ff2f 	bl	800b4ec <mem_cpy>
	}
	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
 800f68e:	69fb      	ldr	r3, [r7, #28]
 800f690:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 800f694:	f04f 0255 	mov.w	r2, #85	; 0x55
 800f698:	701a      	strb	r2, [r3, #0]
 800f69a:	69fb      	ldr	r3, [r7, #28]
 800f69c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800f6a0:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 800f6a4:	701a      	strb	r2, [r3, #0]
	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
 800f6a6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800f6aa:	4618      	mov	r0, r3
 800f6ac:	69f9      	ldr	r1, [r7, #28]
 800f6ae:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f6b0:	f04f 0301 	mov.w	r3, #1
 800f6b4:	f7fb fe66 	bl	800b384 <disk_write>
 800f6b8:	4603      	mov	r3, r0
 800f6ba:	2b00      	cmp	r3, #0
 800f6bc:	d002      	beq.n	800f6c4 <f_mkfs+0x804>
		return FR_DISK_ERR;
 800f6be:	f04f 0301 	mov.w	r3, #1
 800f6c2:	e1cf      	b.n	800fa64 <f_mkfs+0xba4>
	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
 800f6c4:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f6c8:	2b03      	cmp	r3, #3
 800f6ca:	d10b      	bne.n	800f6e4 <f_mkfs+0x824>
		disk_write(pdrv, tbl, b_vol + 6, 1);
 800f6cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f6ce:	f103 0306 	add.w	r3, r3, #6
 800f6d2:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800f6d6:	4610      	mov	r0, r2
 800f6d8:	69f9      	ldr	r1, [r7, #28]
 800f6da:	461a      	mov	r2, r3
 800f6dc:	f04f 0301 	mov.w	r3, #1
 800f6e0:	f7fb fe50 	bl	800b384 <disk_write>

	/* Initialize FAT area */
	wsect = b_fat;
 800f6e4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f6e6:	653b      	str	r3, [r7, #80]	; 0x50
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
 800f6e8:	f04f 0300 	mov.w	r3, #0
 800f6ec:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f6ee:	e0cb      	b.n	800f888 <f_mkfs+0x9c8>
		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
 800f6f0:	69f8      	ldr	r0, [r7, #28]
 800f6f2:	f04f 0100 	mov.w	r1, #0
 800f6f6:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f6fa:	f7fb ff1f 	bl	800b53c <mem_set>
		n = md;								/* Media descriptor byte */
 800f6fe:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 800f702:	61bb      	str	r3, [r7, #24]
		if (fmt != FS_FAT32) {
 800f704:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f708:	2b03      	cmp	r3, #3
 800f70a:	d02c      	beq.n	800f766 <f_mkfs+0x8a6>
			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
 800f70c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f710:	2b01      	cmp	r3, #1
 800f712:	d104      	bne.n	800f71e <f_mkfs+0x85e>
 800f714:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 800f718:	f2c0 03ff 	movt	r3, #255	; 0xff
 800f71c:	e001      	b.n	800f722 <f_mkfs+0x862>
 800f71e:	f06f 03ff 	mvn.w	r3, #255	; 0xff
 800f722:	69ba      	ldr	r2, [r7, #24]
 800f724:	4313      	orrs	r3, r2
 800f726:	61bb      	str	r3, [r7, #24]
			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
 800f728:	69bb      	ldr	r3, [r7, #24]
 800f72a:	b2da      	uxtb	r2, r3
 800f72c:	69fb      	ldr	r3, [r7, #28]
 800f72e:	701a      	strb	r2, [r3, #0]
 800f730:	69fb      	ldr	r3, [r7, #28]
 800f732:	f103 0301 	add.w	r3, r3, #1
 800f736:	69ba      	ldr	r2, [r7, #24]
 800f738:	b292      	uxth	r2, r2
 800f73a:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f73e:	b292      	uxth	r2, r2
 800f740:	b2d2      	uxtb	r2, r2
 800f742:	701a      	strb	r2, [r3, #0]
 800f744:	69fb      	ldr	r3, [r7, #28]
 800f746:	f103 0302 	add.w	r3, r3, #2
 800f74a:	69ba      	ldr	r2, [r7, #24]
 800f74c:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f750:	b2d2      	uxtb	r2, r2
 800f752:	701a      	strb	r2, [r3, #0]
 800f754:	69fb      	ldr	r3, [r7, #28]
 800f756:	f103 0303 	add.w	r3, r3, #3
 800f75a:	69ba      	ldr	r2, [r7, #24]
 800f75c:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f760:	b2d2      	uxtb	r2, r2
 800f762:	701a      	strb	r2, [r3, #0]
 800f764:	e051      	b.n	800f80a <f_mkfs+0x94a>
		} else {
			n |= 0xFFFFFF00;
 800f766:	69bb      	ldr	r3, [r7, #24]
 800f768:	f063 03ff 	orn	r3, r3, #255	; 0xff
 800f76c:	61bb      	str	r3, [r7, #24]
			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
 800f76e:	69bb      	ldr	r3, [r7, #24]
 800f770:	b2da      	uxtb	r2, r3
 800f772:	69fb      	ldr	r3, [r7, #28]
 800f774:	701a      	strb	r2, [r3, #0]
 800f776:	69fb      	ldr	r3, [r7, #28]
 800f778:	f103 0301 	add.w	r3, r3, #1
 800f77c:	69ba      	ldr	r2, [r7, #24]
 800f77e:	b292      	uxth	r2, r2
 800f780:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f784:	b292      	uxth	r2, r2
 800f786:	b2d2      	uxtb	r2, r2
 800f788:	701a      	strb	r2, [r3, #0]
 800f78a:	69fb      	ldr	r3, [r7, #28]
 800f78c:	f103 0302 	add.w	r3, r3, #2
 800f790:	69ba      	ldr	r2, [r7, #24]
 800f792:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f796:	b2d2      	uxtb	r2, r2
 800f798:	701a      	strb	r2, [r3, #0]
 800f79a:	69fb      	ldr	r3, [r7, #28]
 800f79c:	f103 0303 	add.w	r3, r3, #3
 800f7a0:	69ba      	ldr	r2, [r7, #24]
 800f7a2:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f7a6:	b2d2      	uxtb	r2, r2
 800f7a8:	701a      	strb	r2, [r3, #0]
			ST_DWORD(tbl+4, 0xFFFFFFFF);
 800f7aa:	69fb      	ldr	r3, [r7, #28]
 800f7ac:	f103 0304 	add.w	r3, r3, #4
 800f7b0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f7b4:	701a      	strb	r2, [r3, #0]
 800f7b6:	69fb      	ldr	r3, [r7, #28]
 800f7b8:	f103 0305 	add.w	r3, r3, #5
 800f7bc:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f7c0:	701a      	strb	r2, [r3, #0]
 800f7c2:	69fb      	ldr	r3, [r7, #28]
 800f7c4:	f103 0306 	add.w	r3, r3, #6
 800f7c8:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f7cc:	701a      	strb	r2, [r3, #0]
 800f7ce:	69fb      	ldr	r3, [r7, #28]
 800f7d0:	f103 0307 	add.w	r3, r3, #7
 800f7d4:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f7d8:	701a      	strb	r2, [r3, #0]
			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
 800f7da:	69fb      	ldr	r3, [r7, #28]
 800f7dc:	f103 0308 	add.w	r3, r3, #8
 800f7e0:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f7e4:	701a      	strb	r2, [r3, #0]
 800f7e6:	69fb      	ldr	r3, [r7, #28]
 800f7e8:	f103 0309 	add.w	r3, r3, #9
 800f7ec:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f7f0:	701a      	strb	r2, [r3, #0]
 800f7f2:	69fb      	ldr	r3, [r7, #28]
 800f7f4:	f103 030a 	add.w	r3, r3, #10
 800f7f8:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800f7fc:	701a      	strb	r2, [r3, #0]
 800f7fe:	69fb      	ldr	r3, [r7, #28]
 800f800:	f103 030b 	add.w	r3, r3, #11
 800f804:	f04f 020f 	mov.w	r2, #15
 800f808:	701a      	strb	r2, [r3, #0]
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 800f80a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f80c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800f80e:	f102 0201 	add.w	r2, r2, #1
 800f812:	653a      	str	r2, [r7, #80]	; 0x50
 800f814:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800f818:	4610      	mov	r0, r2
 800f81a:	69f9      	ldr	r1, [r7, #28]
 800f81c:	461a      	mov	r2, r3
 800f81e:	f04f 0301 	mov.w	r3, #1
 800f822:	f7fb fdaf 	bl	800b384 <disk_write>
 800f826:	4603      	mov	r3, r0
 800f828:	2b00      	cmp	r3, #0
 800f82a:	d002      	beq.n	800f832 <f_mkfs+0x972>
			return FR_DISK_ERR;
 800f82c:	f04f 0301 	mov.w	r3, #1
 800f830:	e118      	b.n	800fa64 <f_mkfs+0xba4>
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
 800f832:	69f8      	ldr	r0, [r7, #28]
 800f834:	f04f 0100 	mov.w	r1, #0
 800f838:	f44f 7200 	mov.w	r2, #512	; 0x200
 800f83c:	f7fb fe7e 	bl	800b53c <mem_set>
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
 800f840:	f04f 0301 	mov.w	r3, #1
 800f844:	61bb      	str	r3, [r7, #24]
 800f846:	e017      	b.n	800f878 <f_mkfs+0x9b8>
			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 800f848:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f84a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800f84c:	f102 0201 	add.w	r2, r2, #1
 800f850:	653a      	str	r2, [r7, #80]	; 0x50
 800f852:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800f856:	4610      	mov	r0, r2
 800f858:	69f9      	ldr	r1, [r7, #28]
 800f85a:	461a      	mov	r2, r3
 800f85c:	f04f 0301 	mov.w	r3, #1
 800f860:	f7fb fd90 	bl	800b384 <disk_write>
 800f864:	4603      	mov	r3, r0
 800f866:	2b00      	cmp	r3, #0
 800f868:	d002      	beq.n	800f870 <f_mkfs+0x9b0>
				return FR_DISK_ERR;
 800f86a:	f04f 0301 	mov.w	r3, #1
 800f86e:	e0f9      	b.n	800fa64 <f_mkfs+0xba4>
			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
		}
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
			return FR_DISK_ERR;
		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
 800f870:	69bb      	ldr	r3, [r7, #24]
 800f872:	f103 0301 	add.w	r3, r3, #1
 800f876:	61bb      	str	r3, [r7, #24]
 800f878:	69ba      	ldr	r2, [r7, #24]
 800f87a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f87c:	429a      	cmp	r2, r3
 800f87e:	d3e3      	bcc.n	800f848 <f_mkfs+0x988>
	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
		disk_write(pdrv, tbl, b_vol + 6, 1);

	/* Initialize FAT area */
	wsect = b_fat;
	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
 800f880:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f882:	f103 0301 	add.w	r3, r3, #1
 800f886:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f888:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f88a:	2b00      	cmp	r3, #0
 800f88c:	f43f af30 	beq.w	800f6f0 <f_mkfs+0x830>
				return FR_DISK_ERR;
		}
	}

	/* Initialize root directory */
	i = (fmt == FS_FAT32) ? au : n_dir;
 800f890:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f894:	2b03      	cmp	r3, #3
 800f896:	d101      	bne.n	800f89c <f_mkfs+0x9dc>
 800f898:	683b      	ldr	r3, [r7, #0]
 800f89a:	e000      	b.n	800f89e <f_mkfs+0x9de>
 800f89c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f89e:	64fb      	str	r3, [r7, #76]	; 0x4c
	do {
		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
 800f8a0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f8a2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800f8a4:	f102 0201 	add.w	r2, r2, #1
 800f8a8:	653a      	str	r2, [r7, #80]	; 0x50
 800f8aa:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800f8ae:	4610      	mov	r0, r2
 800f8b0:	69f9      	ldr	r1, [r7, #28]
 800f8b2:	461a      	mov	r2, r3
 800f8b4:	f04f 0301 	mov.w	r3, #1
 800f8b8:	f7fb fd64 	bl	800b384 <disk_write>
 800f8bc:	4603      	mov	r3, r0
 800f8be:	2b00      	cmp	r3, #0
 800f8c0:	d002      	beq.n	800f8c8 <f_mkfs+0xa08>
			return FR_DISK_ERR;
 800f8c2:	f04f 0301 	mov.w	r3, #1
 800f8c6:	e0cd      	b.n	800fa64 <f_mkfs+0xba4>
	} while (--i);
 800f8c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f8ca:	f103 33ff 	add.w	r3, r3, #4294967295
 800f8ce:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f8d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f8d2:	2b00      	cmp	r3, #0
 800f8d4:	d1e4      	bne.n	800f8a0 <f_mkfs+0x9e0>

#if _USE_ERASE	/* Erase data area if needed */
	{
		DWORD eb[2];

		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
 800f8d6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f8d8:	60fb      	str	r3, [r7, #12]
 800f8da:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f8de:	2b03      	cmp	r3, #3
 800f8e0:	d102      	bne.n	800f8e8 <f_mkfs+0xa28>
 800f8e2:	f04f 0301 	mov.w	r3, #1
 800f8e6:	e001      	b.n	800f8ec <f_mkfs+0xa2c>
 800f8e8:	f04f 0300 	mov.w	r3, #0
 800f8ec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f8ee:	1ad3      	subs	r3, r2, r3
 800f8f0:	683a      	ldr	r2, [r7, #0]
 800f8f2:	fb02 f203 	mul.w	r2, r2, r3
 800f8f6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800f8f8:	18d3      	adds	r3, r2, r3
 800f8fa:	f103 33ff 	add.w	r3, r3, #4294967295
 800f8fe:	613b      	str	r3, [r7, #16]
		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
 800f900:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800f904:	f107 030c 	add.w	r3, r7, #12
 800f908:	4610      	mov	r0, r2
 800f90a:	f04f 0104 	mov.w	r1, #4
 800f90e:	461a      	mov	r2, r3
 800f910:	f7fb fd7a 	bl	800b408 <disk_ioctl>
	}
#endif

	/* Create FSInfo if needed */
	if (fmt == FS_FAT32) {
 800f914:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 800f918:	2b03      	cmp	r3, #3
 800f91a:	f040 8094 	bne.w	800fa46 <f_mkfs+0xb86>
		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
 800f91e:	69fb      	ldr	r3, [r7, #28]
 800f920:	f04f 0252 	mov.w	r2, #82	; 0x52
 800f924:	701a      	strb	r2, [r3, #0]
 800f926:	69fb      	ldr	r3, [r7, #28]
 800f928:	f103 0301 	add.w	r3, r3, #1
 800f92c:	f04f 0252 	mov.w	r2, #82	; 0x52
 800f930:	701a      	strb	r2, [r3, #0]
 800f932:	69fb      	ldr	r3, [r7, #28]
 800f934:	f103 0302 	add.w	r3, r3, #2
 800f938:	f04f 0261 	mov.w	r2, #97	; 0x61
 800f93c:	701a      	strb	r2, [r3, #0]
 800f93e:	69fb      	ldr	r3, [r7, #28]
 800f940:	f103 0303 	add.w	r3, r3, #3
 800f944:	f04f 0241 	mov.w	r2, #65	; 0x41
 800f948:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
 800f94a:	69fb      	ldr	r3, [r7, #28]
 800f94c:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 800f950:	f04f 0272 	mov.w	r2, #114	; 0x72
 800f954:	701a      	strb	r2, [r3, #0]
 800f956:	69fb      	ldr	r3, [r7, #28]
 800f958:	f203 13e5 	addw	r3, r3, #485	; 0x1e5
 800f95c:	f04f 0272 	mov.w	r2, #114	; 0x72
 800f960:	701a      	strb	r2, [r3, #0]
 800f962:	69fb      	ldr	r3, [r7, #28]
 800f964:	f503 73f3 	add.w	r3, r3, #486	; 0x1e6
 800f968:	f04f 0241 	mov.w	r2, #65	; 0x41
 800f96c:	701a      	strb	r2, [r3, #0]
 800f96e:	69fb      	ldr	r3, [r7, #28]
 800f970:	f203 13e7 	addw	r3, r3, #487	; 0x1e7
 800f974:	f04f 0261 	mov.w	r2, #97	; 0x61
 800f978:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
 800f97a:	69fb      	ldr	r3, [r7, #28]
 800f97c:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 800f980:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f982:	b2d2      	uxtb	r2, r2
 800f984:	f102 32ff 	add.w	r2, r2, #4294967295
 800f988:	b2d2      	uxtb	r2, r2
 800f98a:	701a      	strb	r2, [r3, #0]
 800f98c:	69fb      	ldr	r3, [r7, #28]
 800f98e:	f203 13e9 	addw	r3, r3, #489	; 0x1e9
 800f992:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f994:	b292      	uxth	r2, r2
 800f996:	f102 32ff 	add.w	r2, r2, #4294967295
 800f99a:	b292      	uxth	r2, r2
 800f99c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 800f9a0:	b292      	uxth	r2, r2
 800f9a2:	b2d2      	uxtb	r2, r2
 800f9a4:	701a      	strb	r2, [r3, #0]
 800f9a6:	69fb      	ldr	r3, [r7, #28]
 800f9a8:	f503 73f5 	add.w	r3, r3, #490	; 0x1ea
 800f9ac:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f9ae:	f102 32ff 	add.w	r2, r2, #4294967295
 800f9b2:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800f9b6:	b2d2      	uxtb	r2, r2
 800f9b8:	701a      	strb	r2, [r3, #0]
 800f9ba:	69fb      	ldr	r3, [r7, #28]
 800f9bc:	f203 13eb 	addw	r3, r3, #491	; 0x1eb
 800f9c0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f9c2:	f102 32ff 	add.w	r2, r2, #4294967295
 800f9c6:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800f9ca:	b2d2      	uxtb	r2, r2
 800f9cc:	701a      	strb	r2, [r3, #0]
		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
 800f9ce:	69fb      	ldr	r3, [r7, #28]
 800f9d0:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 800f9d4:	f04f 0202 	mov.w	r2, #2
 800f9d8:	701a      	strb	r2, [r3, #0]
 800f9da:	69fb      	ldr	r3, [r7, #28]
 800f9dc:	f203 13ed 	addw	r3, r3, #493	; 0x1ed
 800f9e0:	f04f 0200 	mov.w	r2, #0
 800f9e4:	701a      	strb	r2, [r3, #0]
 800f9e6:	69fb      	ldr	r3, [r7, #28]
 800f9e8:	f503 73f7 	add.w	r3, r3, #494	; 0x1ee
 800f9ec:	f04f 0200 	mov.w	r2, #0
 800f9f0:	701a      	strb	r2, [r3, #0]
 800f9f2:	69fb      	ldr	r3, [r7, #28]
 800f9f4:	f203 13ef 	addw	r3, r3, #495	; 0x1ef
 800f9f8:	f04f 0200 	mov.w	r2, #0
 800f9fc:	701a      	strb	r2, [r3, #0]
		ST_WORD(tbl+BS_55AA, 0xAA55);
 800f9fe:	69fb      	ldr	r3, [r7, #28]
 800fa00:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 800fa04:	f04f 0255 	mov.w	r2, #85	; 0x55
 800fa08:	701a      	strb	r2, [r3, #0]
 800fa0a:	69fb      	ldr	r3, [r7, #28]
 800fa0c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 800fa10:	f04f 02aa 	mov.w	r2, #170	; 0xaa
 800fa14:	701a      	strb	r2, [r3, #0]
		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
 800fa16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fa18:	f103 0301 	add.w	r3, r3, #1
 800fa1c:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800fa20:	4610      	mov	r0, r2
 800fa22:	69f9      	ldr	r1, [r7, #28]
 800fa24:	461a      	mov	r2, r3
 800fa26:	f04f 0301 	mov.w	r3, #1
 800fa2a:	f7fb fcab 	bl	800b384 <disk_write>
		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
 800fa2e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fa30:	f103 0307 	add.w	r3, r3, #7
 800fa34:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
 800fa38:	4610      	mov	r0, r2
 800fa3a:	69f9      	ldr	r1, [r7, #28]
 800fa3c:	461a      	mov	r2, r3
 800fa3e:	f04f 0301 	mov.w	r3, #1
 800fa42:	f7fb fc9f 	bl	800b384 <disk_write>
	}

	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
 800fa46:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800fa4a:	4618      	mov	r0, r3
 800fa4c:	f04f 0100 	mov.w	r1, #0
 800fa50:	f04f 0200 	mov.w	r2, #0
 800fa54:	f7fb fcd8 	bl	800b408 <disk_ioctl>
 800fa58:	4603      	mov	r3, r0
 800fa5a:	2b00      	cmp	r3, #0
 800fa5c:	bf0c      	ite	eq
 800fa5e:	2300      	moveq	r3, #0
 800fa60:	2301      	movne	r3, #1
 800fa62:	b2db      	uxtb	r3, r3
}
 800fa64:	4618      	mov	r0, r3
 800fa66:	f107 0758 	add.w	r7, r7, #88	; 0x58
 800fa6a:	46bd      	mov	sp, r7
 800fa6c:	bd80      	pop	{r7, pc}
 800fa6e:	bf00      	nop

0800fa70 <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fil		/* Pointer to the file object */
)
{
 800fa70:	b580      	push	{r7, lr}
 800fa72:	b088      	sub	sp, #32
 800fa74:	af00      	add	r7, sp, #0
 800fa76:	60f8      	str	r0, [r7, #12]
 800fa78:	60b9      	str	r1, [r7, #8]
 800fa7a:	607a      	str	r2, [r7, #4]
	int n = 0;
 800fa7c:	f04f 0300 	mov.w	r3, #0
 800fa80:	61fb      	str	r3, [r7, #28]
	TCHAR c, *p = buff;
 800fa82:	68fb      	ldr	r3, [r7, #12]
 800fa84:	61bb      	str	r3, [r7, #24]
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {			/* Read bytes until buffer gets filled */
 800fa86:	e01c      	b.n	800fac2 <f_gets+0x52>
		f_read(fil, s, 1, &rc);
 800fa88:	f107 0214 	add.w	r2, r7, #20
 800fa8c:	f107 0310 	add.w	r3, r7, #16
 800fa90:	6878      	ldr	r0, [r7, #4]
 800fa92:	4611      	mov	r1, r2
 800fa94:	f04f 0201 	mov.w	r2, #1
 800fa98:	f7fd fcc2 	bl	800d420 <f_read>
		if (rc != 1) break;			/* Break on EOF or error */
 800fa9c:	693b      	ldr	r3, [r7, #16]
 800fa9e:	2b01      	cmp	r3, #1
 800faa0:	d116      	bne.n	800fad0 <f_gets+0x60>
		c = s[0];
 800faa2:	7d3b      	ldrb	r3, [r7, #20]
 800faa4:	75fb      	strb	r3, [r7, #23]
		}
#endif
#if _USE_STRFUNC >= 2
		if (c == '\r') continue;	/* Strip '\r' */
#endif
		*p++ = c;
 800faa6:	69bb      	ldr	r3, [r7, #24]
 800faa8:	7dfa      	ldrb	r2, [r7, #23]
 800faaa:	701a      	strb	r2, [r3, #0]
 800faac:	69bb      	ldr	r3, [r7, #24]
 800faae:	f103 0301 	add.w	r3, r3, #1
 800fab2:	61bb      	str	r3, [r7, #24]
		n++;
 800fab4:	69fb      	ldr	r3, [r7, #28]
 800fab6:	f103 0301 	add.w	r3, r3, #1
 800faba:	61fb      	str	r3, [r7, #28]
		if (c == '\n') break;		/* Break on EOL */
 800fabc:	7dfb      	ldrb	r3, [r7, #23]
 800fabe:	2b0a      	cmp	r3, #10
 800fac0:	d008      	beq.n	800fad4 <f_gets+0x64>
	TCHAR c, *p = buff;
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {			/* Read bytes until buffer gets filled */
 800fac2:	68bb      	ldr	r3, [r7, #8]
 800fac4:	f103 32ff 	add.w	r2, r3, #4294967295
 800fac8:	69fb      	ldr	r3, [r7, #28]
 800faca:	429a      	cmp	r2, r3
 800facc:	dcdc      	bgt.n	800fa88 <f_gets+0x18>
 800face:	e002      	b.n	800fad6 <f_gets+0x66>
		f_read(fil, s, 1, &rc);
		if (rc != 1) break;			/* Break on EOF or error */
 800fad0:	bf00      	nop
 800fad2:	e000      	b.n	800fad6 <f_gets+0x66>
#if _USE_STRFUNC >= 2
		if (c == '\r') continue;	/* Strip '\r' */
#endif
		*p++ = c;
		n++;
		if (c == '\n') break;		/* Break on EOL */
 800fad4:	bf00      	nop
	}
	*p = 0;
 800fad6:	69bb      	ldr	r3, [r7, #24]
 800fad8:	f04f 0200 	mov.w	r2, #0
 800fadc:	701a      	strb	r2, [r3, #0]
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
 800fade:	69fb      	ldr	r3, [r7, #28]
 800fae0:	2b00      	cmp	r3, #0
 800fae2:	d001      	beq.n	800fae8 <f_gets+0x78>
 800fae4:	68fb      	ldr	r3, [r7, #12]
 800fae6:	e001      	b.n	800faec <f_gets+0x7c>
 800fae8:	f04f 0300 	mov.w	r3, #0
}
 800faec:	4618      	mov	r0, r3
 800faee:	f107 0720 	add.w	r7, r7, #32
 800faf2:	46bd      	mov	sp, r7
 800faf4:	bd80      	pop	{r7, pc}
 800faf6:	bf00      	nop

0800faf8 <f_putc>:
/*-----------------------------------------------------------------------*/
int f_putc (
	TCHAR c,	/* A character to be output */
	FIL* fil	/* Pointer to the file object */
)
{
 800faf8:	b580      	push	{r7, lr}
 800fafa:	b086      	sub	sp, #24
 800fafc:	af00      	add	r7, sp, #0
 800fafe:	4603      	mov	r3, r0
 800fb00:	6039      	str	r1, [r7, #0]
 800fb02:	71fb      	strb	r3, [r7, #7]
			s[2] = (BYTE)(0x80 | (c & 0x3F));
			btw = 3;
		}
	}
#else				/* Write the character without conversion */
	s[0] = (BYTE)c;
 800fb04:	79fb      	ldrb	r3, [r7, #7]
 800fb06:	733b      	strb	r3, [r7, #12]
	btw = 1;
 800fb08:	f04f 0301 	mov.w	r3, #1
 800fb0c:	617b      	str	r3, [r7, #20]
#endif
	f_write(fil, s, btw, &bw);		/* Write the char to the file */
 800fb0e:	f107 020c 	add.w	r2, r7, #12
 800fb12:	f107 0310 	add.w	r3, r7, #16
 800fb16:	6838      	ldr	r0, [r7, #0]
 800fb18:	4611      	mov	r1, r2
 800fb1a:	697a      	ldr	r2, [r7, #20]
 800fb1c:	f7fd fdf8 	bl	800d710 <f_write>
	return (bw == btw) ? 1 : EOF;	/* Return the result */
 800fb20:	693a      	ldr	r2, [r7, #16]
 800fb22:	697b      	ldr	r3, [r7, #20]
 800fb24:	429a      	cmp	r2, r3
 800fb26:	d102      	bne.n	800fb2e <f_putc+0x36>
 800fb28:	f04f 0301 	mov.w	r3, #1
 800fb2c:	e001      	b.n	800fb32 <f_putc+0x3a>
 800fb2e:	f04f 33ff 	mov.w	r3, #4294967295
}
 800fb32:	4618      	mov	r0, r3
 800fb34:	f107 0718 	add.w	r7, r7, #24
 800fb38:	46bd      	mov	sp, r7
 800fb3a:	bd80      	pop	{r7, pc}

0800fb3c <f_puts>:
/*-----------------------------------------------------------------------*/
int f_puts (
	const TCHAR* str,	/* Pointer to the string to be output */
	FIL* fil			/* Pointer to the file object */
)
{
 800fb3c:	b580      	push	{r7, lr}
 800fb3e:	b084      	sub	sp, #16
 800fb40:	af00      	add	r7, sp, #0
 800fb42:	6078      	str	r0, [r7, #4]
 800fb44:	6039      	str	r1, [r7, #0]
	int n;


	for (n = 0; *str; str++, n++) {
 800fb46:	f04f 0300 	mov.w	r3, #0
 800fb4a:	60fb      	str	r3, [r7, #12]
 800fb4c:	e014      	b.n	800fb78 <f_puts+0x3c>
		if (f_putc(*str, fil) == EOF) return EOF;
 800fb4e:	687b      	ldr	r3, [r7, #4]
 800fb50:	781b      	ldrb	r3, [r3, #0]
 800fb52:	4618      	mov	r0, r3
 800fb54:	6839      	ldr	r1, [r7, #0]
 800fb56:	f7ff ffcf 	bl	800faf8 <f_putc>
 800fb5a:	4603      	mov	r3, r0
 800fb5c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fb60:	d102      	bne.n	800fb68 <f_puts+0x2c>
 800fb62:	f04f 33ff 	mov.w	r3, #4294967295
 800fb66:	e00c      	b.n	800fb82 <f_puts+0x46>
)
{
	int n;


	for (n = 0; *str; str++, n++) {
 800fb68:	687b      	ldr	r3, [r7, #4]
 800fb6a:	f103 0301 	add.w	r3, r3, #1
 800fb6e:	607b      	str	r3, [r7, #4]
 800fb70:	68fb      	ldr	r3, [r7, #12]
 800fb72:	f103 0301 	add.w	r3, r3, #1
 800fb76:	60fb      	str	r3, [r7, #12]
 800fb78:	687b      	ldr	r3, [r7, #4]
 800fb7a:	781b      	ldrb	r3, [r3, #0]
 800fb7c:	2b00      	cmp	r3, #0
 800fb7e:	d1e6      	bne.n	800fb4e <f_puts+0x12>
		if (f_putc(*str, fil) == EOF) return EOF;
	}
	return n;
 800fb80:	68fb      	ldr	r3, [r7, #12]
}
 800fb82:	4618      	mov	r0, r3
 800fb84:	f107 0710 	add.w	r7, r7, #16
 800fb88:	46bd      	mov	sp, r7
 800fb8a:	bd80      	pop	{r7, pc}

0800fb8c <f_printf>:
int f_printf (
	FIL* fil,			/* Pointer to the file object */
	const TCHAR* str,	/* Pointer to the format string */
	...					/* Optional arguments... */
)
{
 800fb8c:	b40e      	push	{r1, r2, r3}
 800fb8e:	b580      	push	{r7, lr}
 800fb90:	b093      	sub	sp, #76	; 0x4c
 800fb92:	af00      	add	r7, sp, #0
 800fb94:	6078      	str	r0, [r7, #4]
	ULONG v;
	TCHAR c, d, s[16], *p;
	int res, chc, cc;


	va_start(arp, str);
 800fb96:	f107 0358 	add.w	r3, r7, #88	; 0x58
 800fb9a:	61fb      	str	r3, [r7, #28]

	for (cc = res = 0; cc != EOF; res += cc) {
 800fb9c:	f04f 0300 	mov.w	r3, #0
 800fba0:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fba2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fba4:	627b      	str	r3, [r7, #36]	; 0x24
 800fba6:	e23e      	b.n	8010026 <f_printf+0x49a>
		c = *str++;
 800fba8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fbaa:	781b      	ldrb	r3, [r3, #0]
 800fbac:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800fbb0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fbb2:	f103 0301 	add.w	r3, r3, #1
 800fbb6:	657b      	str	r3, [r7, #84]	; 0x54
		if (c == 0) break;			/* End of string */
 800fbb8:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fbbc:	2b00      	cmp	r3, #0
 800fbbe:	f000 8238 	beq.w	8010032 <f_printf+0x4a6>
		if (c != '%') {				/* Non escape character */
 800fbc2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fbc6:	2b25      	cmp	r3, #37	; 0x25
 800fbc8:	d00f      	beq.n	800fbea <f_printf+0x5e>
			cc = f_putc(c, fil);
 800fbca:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fbce:	4618      	mov	r0, r3
 800fbd0:	6879      	ldr	r1, [r7, #4]
 800fbd2:	f7ff ff91 	bl	800faf8 <f_putc>
 800fbd6:	6278      	str	r0, [r7, #36]	; 0x24
			if (cc != EOF) cc = 1;
 800fbd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fbda:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fbde:	f000 821b 	beq.w	8010018 <f_printf+0x48c>
 800fbe2:	f04f 0301 	mov.w	r3, #1
 800fbe6:	627b      	str	r3, [r7, #36]	; 0x24
			continue;
 800fbe8:	e216      	b.n	8010018 <f_printf+0x48c>
		}
		w = f = 0;
 800fbea:	f04f 0300 	mov.w	r3, #0
 800fbee:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800fbf2:	f04f 0300 	mov.w	r3, #0
 800fbf6:	63bb      	str	r3, [r7, #56]	; 0x38
		c = *str++;
 800fbf8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fbfa:	781b      	ldrb	r3, [r3, #0]
 800fbfc:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800fc00:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fc02:	f103 0301 	add.w	r3, r3, #1
 800fc06:	657b      	str	r3, [r7, #84]	; 0x54
		if (c == '0') {				/* Flag: '0' padding */
 800fc08:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fc0c:	2b30      	cmp	r3, #48	; 0x30
 800fc0e:	d10c      	bne.n	800fc2a <f_printf+0x9e>
			f = 1; c = *str++;
 800fc10:	f04f 0301 	mov.w	r3, #1
 800fc14:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800fc18:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fc1a:	781b      	ldrb	r3, [r3, #0]
 800fc1c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800fc20:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fc22:	f103 0301 	add.w	r3, r3, #1
 800fc26:	657b      	str	r3, [r7, #84]	; 0x54
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *str++;
			}
		}
		while (IsDigit(c)) {		/* Precision */
 800fc28:	e026      	b.n	800fc78 <f_printf+0xec>
		w = f = 0;
		c = *str++;
		if (c == '0') {				/* Flag: '0' padding */
			f = 1; c = *str++;
		} else {
			if (c == '-') {			/* Flag: left justified */
 800fc2a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fc2e:	2b2d      	cmp	r3, #45	; 0x2d
 800fc30:	d122      	bne.n	800fc78 <f_printf+0xec>
				f = 2; c = *str++;
 800fc32:	f04f 0302 	mov.w	r3, #2
 800fc36:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800fc3a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fc3c:	781b      	ldrb	r3, [r3, #0]
 800fc3e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800fc42:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fc44:	f103 0301 	add.w	r3, r3, #1
 800fc48:	657b      	str	r3, [r7, #84]	; 0x54
			}
		}
		while (IsDigit(c)) {		/* Precision */
 800fc4a:	e015      	b.n	800fc78 <f_printf+0xec>
			w = w * 10 + c - '0';
 800fc4c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800fc4e:	4613      	mov	r3, r2
 800fc50:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800fc54:	189b      	adds	r3, r3, r2
 800fc56:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800fc5a:	461a      	mov	r2, r3
 800fc5c:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fc60:	18d3      	adds	r3, r2, r3
 800fc62:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 800fc66:	63bb      	str	r3, [r7, #56]	; 0x38
			c = *str++;
 800fc68:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fc6a:	781b      	ldrb	r3, [r3, #0]
 800fc6c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800fc70:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fc72:	f103 0301 	add.w	r3, r3, #1
 800fc76:	657b      	str	r3, [r7, #84]	; 0x54
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *str++;
			}
		}
		while (IsDigit(c)) {		/* Precision */
 800fc78:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fc7c:	2b2f      	cmp	r3, #47	; 0x2f
 800fc7e:	d903      	bls.n	800fc88 <f_printf+0xfc>
 800fc80:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fc84:	2b39      	cmp	r3, #57	; 0x39
 800fc86:	d9e1      	bls.n	800fc4c <f_printf+0xc0>
			w = w * 10 + c - '0';
			c = *str++;
		}
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
 800fc88:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fc8c:	2b6c      	cmp	r3, #108	; 0x6c
 800fc8e:	d003      	beq.n	800fc98 <f_printf+0x10c>
 800fc90:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fc94:	2b4c      	cmp	r3, #76	; 0x4c
 800fc96:	d10d      	bne.n	800fcb4 <f_printf+0x128>
			f |= 4; c = *str++;
 800fc98:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800fc9c:	f043 0304 	orr.w	r3, r3, #4
 800fca0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 800fca4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fca6:	781b      	ldrb	r3, [r3, #0]
 800fca8:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800fcac:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fcae:	f103 0301 	add.w	r3, r3, #1
 800fcb2:	657b      	str	r3, [r7, #84]	; 0x54
		}
		if (!c) break;
 800fcb4:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fcb8:	2b00      	cmp	r3, #0
 800fcba:	f000 81bc 	beq.w	8010036 <f_printf+0x4aa>
		d = c;
 800fcbe:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fcc2:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
		if (IsLower(d)) d -= 0x20;
 800fcc6:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800fcca:	2b60      	cmp	r3, #96	; 0x60
 800fccc:	d909      	bls.n	800fce2 <f_printf+0x156>
 800fcce:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800fcd2:	2b7a      	cmp	r3, #122	; 0x7a
 800fcd4:	d805      	bhi.n	800fce2 <f_printf+0x156>
 800fcd6:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800fcda:	f1a3 0320 	sub.w	r3, r3, #32
 800fcde:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
		switch (d) {				/* Type is... */
 800fce2:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800fce6:	f1a3 0342 	sub.w	r3, r3, #66	; 0x42
 800fcea:	2b16      	cmp	r3, #22
 800fcec:	f200 80b0 	bhi.w	800fe50 <f_printf+0x2c4>
 800fcf0:	a201      	add	r2, pc, #4	; (adr r2, 800fcf8 <f_printf+0x16c>)
 800fcf2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fcf6:	bf00      	nop
 800fcf8:	0800fe29 	.word	0x0800fe29
 800fcfc:	0800fe11 	.word	0x0800fe11
 800fd00:	0800fe3d 	.word	0x0800fe3d
 800fd04:	0800fe51 	.word	0x0800fe51
 800fd08:	0800fe51 	.word	0x0800fe51
 800fd0c:	0800fe51 	.word	0x0800fe51
 800fd10:	0800fe51 	.word	0x0800fe51
 800fd14:	0800fe51 	.word	0x0800fe51
 800fd18:	0800fe51 	.word	0x0800fe51
 800fd1c:	0800fe51 	.word	0x0800fe51
 800fd20:	0800fe51 	.word	0x0800fe51
 800fd24:	0800fe51 	.word	0x0800fe51
 800fd28:	0800fe51 	.word	0x0800fe51
 800fd2c:	0800fe33 	.word	0x0800fe33
 800fd30:	0800fe51 	.word	0x0800fe51
 800fd34:	0800fe51 	.word	0x0800fe51
 800fd38:	0800fe51 	.word	0x0800fe51
 800fd3c:	0800fd55 	.word	0x0800fd55
 800fd40:	0800fe51 	.word	0x0800fe51
 800fd44:	0800fe3d 	.word	0x0800fe3d
 800fd48:	0800fe51 	.word	0x0800fe51
 800fd4c:	0800fe51 	.word	0x0800fe51
 800fd50:	0800fe47 	.word	0x0800fe47
		case 'S' :					/* String */
			p = va_arg(arp, TCHAR*);
 800fd54:	69fb      	ldr	r3, [r7, #28]
 800fd56:	f103 0204 	add.w	r2, r3, #4
 800fd5a:	61fa      	str	r2, [r7, #28]
 800fd5c:	681b      	ldr	r3, [r3, #0]
 800fd5e:	623b      	str	r3, [r7, #32]
			for (j = 0; p[j]; j++) ;
 800fd60:	f04f 0300 	mov.w	r3, #0
 800fd64:	63fb      	str	r3, [r7, #60]	; 0x3c
 800fd66:	e003      	b.n	800fd70 <f_printf+0x1e4>
 800fd68:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fd6a:	f103 0301 	add.w	r3, r3, #1
 800fd6e:	63fb      	str	r3, [r7, #60]	; 0x3c
 800fd70:	6a3a      	ldr	r2, [r7, #32]
 800fd72:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800fd74:	18d3      	adds	r3, r2, r3
 800fd76:	781b      	ldrb	r3, [r3, #0]
 800fd78:	2b00      	cmp	r3, #0
 800fd7a:	d1f5      	bne.n	800fd68 <f_printf+0x1dc>
			chc = 0;
 800fd7c:	f04f 0300 	mov.w	r3, #0
 800fd80:	62bb      	str	r3, [r7, #40]	; 0x28
			if (!(f & 2)) {
 800fd82:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800fd86:	f003 0302 	and.w	r3, r3, #2
 800fd8a:	2b00      	cmp	r3, #0
 800fd8c:	d117      	bne.n	800fdbe <f_printf+0x232>
				while (j++ < w) chc += (cc = f_putc(' ', fil));
 800fd8e:	e009      	b.n	800fda4 <f_printf+0x218>
 800fd90:	f04f 0020 	mov.w	r0, #32
 800fd94:	6879      	ldr	r1, [r7, #4]
 800fd96:	f7ff feaf 	bl	800faf8 <f_putc>
 800fd9a:	6278      	str	r0, [r7, #36]	; 0x24
 800fd9c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800fd9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fda0:	18d3      	adds	r3, r2, r3
 800fda2:	62bb      	str	r3, [r7, #40]	; 0x28
 800fda4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800fda6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fda8:	429a      	cmp	r2, r3
 800fdaa:	bf2c      	ite	cs
 800fdac:	2300      	movcs	r3, #0
 800fdae:	2301      	movcc	r3, #1
 800fdb0:	b2db      	uxtb	r3, r3
 800fdb2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800fdb4:	f102 0201 	add.w	r2, r2, #1
 800fdb8:	63fa      	str	r2, [r7, #60]	; 0x3c
 800fdba:	2b00      	cmp	r3, #0
 800fdbc:	d1e8      	bne.n	800fd90 <f_printf+0x204>
			}
			chc += (cc = f_puts(p, fil));
 800fdbe:	6a38      	ldr	r0, [r7, #32]
 800fdc0:	6879      	ldr	r1, [r7, #4]
 800fdc2:	f7ff febb 	bl	800fb3c <f_puts>
 800fdc6:	6278      	str	r0, [r7, #36]	; 0x24
 800fdc8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800fdca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fdcc:	18d3      	adds	r3, r2, r3
 800fdce:	62bb      	str	r3, [r7, #40]	; 0x28
			while (j++ < w) chc += (cc = f_putc(' ', fil));
 800fdd0:	e009      	b.n	800fde6 <f_printf+0x25a>
 800fdd2:	f04f 0020 	mov.w	r0, #32
 800fdd6:	6879      	ldr	r1, [r7, #4]
 800fdd8:	f7ff fe8e 	bl	800faf8 <f_putc>
 800fddc:	6278      	str	r0, [r7, #36]	; 0x24
 800fdde:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800fde0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fde2:	18d3      	adds	r3, r2, r3
 800fde4:	62bb      	str	r3, [r7, #40]	; 0x28
 800fde6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800fde8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fdea:	429a      	cmp	r2, r3
 800fdec:	bf2c      	ite	cs
 800fdee:	2300      	movcs	r3, #0
 800fdf0:	2301      	movcc	r3, #1
 800fdf2:	b2db      	uxtb	r3, r3
 800fdf4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800fdf6:	f102 0201 	add.w	r2, r2, #1
 800fdfa:	63fa      	str	r2, [r7, #60]	; 0x3c
 800fdfc:	2b00      	cmp	r3, #0
 800fdfe:	d1e8      	bne.n	800fdd2 <f_printf+0x246>
			if (cc != EOF) cc = chc;
 800fe00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe02:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fe06:	f000 8109 	beq.w	801001c <f_printf+0x490>
 800fe0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fe0c:	627b      	str	r3, [r7, #36]	; 0x24
			continue;
 800fe0e:	e105      	b.n	801001c <f_printf+0x490>
		case 'C' :					/* Character */
			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
 800fe10:	69fb      	ldr	r3, [r7, #28]
 800fe12:	f103 0204 	add.w	r2, r3, #4
 800fe16:	61fa      	str	r2, [r7, #28]
 800fe18:	681b      	ldr	r3, [r3, #0]
 800fe1a:	b2db      	uxtb	r3, r3
 800fe1c:	4618      	mov	r0, r3
 800fe1e:	6879      	ldr	r1, [r7, #4]
 800fe20:	f7ff fe6a 	bl	800faf8 <f_putc>
 800fe24:	6278      	str	r0, [r7, #36]	; 0x24
 800fe26:	e0fa      	b.n	801001e <f_printf+0x492>
		case 'B' :					/* Binary */
			r = 2; break;
 800fe28:	f04f 0302 	mov.w	r3, #2
 800fe2c:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 800fe30:	e016      	b.n	800fe60 <f_printf+0x2d4>
		case 'O' :					/* Octal */
			r = 8; break;
 800fe32:	f04f 0308 	mov.w	r3, #8
 800fe36:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 800fe3a:	e011      	b.n	800fe60 <f_printf+0x2d4>
		case 'D' :					/* Signed decimal */
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
 800fe3c:	f04f 030a 	mov.w	r3, #10
 800fe40:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 800fe44:	e00c      	b.n	800fe60 <f_printf+0x2d4>
		case 'X' :					/* Hexdecimal */
			r = 16; break;
 800fe46:	f04f 0310 	mov.w	r3, #16
 800fe4a:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
 800fe4e:	e007      	b.n	800fe60 <f_printf+0x2d4>
		default:					/* Unknown type (passthrough) */
			cc = f_putc(c, fil); continue;
 800fe50:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800fe54:	4618      	mov	r0, r3
 800fe56:	6879      	ldr	r1, [r7, #4]
 800fe58:	f7ff fe4e 	bl	800faf8 <f_putc>
 800fe5c:	6278      	str	r0, [r7, #36]	; 0x24
 800fe5e:	e0de      	b.n	801001e <f_printf+0x492>
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
 800fe60:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800fe64:	f003 0304 	and.w	r3, r3, #4
 800fe68:	2b00      	cmp	r3, #0
 800fe6a:	d005      	beq.n	800fe78 <f_printf+0x2ec>
 800fe6c:	69fb      	ldr	r3, [r7, #28]
 800fe6e:	f103 0204 	add.w	r2, r3, #4
 800fe72:	61fa      	str	r2, [r7, #28]
 800fe74:	681b      	ldr	r3, [r3, #0]
 800fe76:	e00e      	b.n	800fe96 <f_printf+0x30a>
 800fe78:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800fe7c:	2b44      	cmp	r3, #68	; 0x44
 800fe7e:	d105      	bne.n	800fe8c <f_printf+0x300>
 800fe80:	69fb      	ldr	r3, [r7, #28]
 800fe82:	f103 0204 	add.w	r2, r3, #4
 800fe86:	61fa      	str	r2, [r7, #28]
 800fe88:	681b      	ldr	r3, [r3, #0]
 800fe8a:	e004      	b.n	800fe96 <f_printf+0x30a>
 800fe8c:	69fb      	ldr	r3, [r7, #28]
 800fe8e:	f103 0204 	add.w	r2, r3, #4
 800fe92:	61fa      	str	r2, [r7, #28]
 800fe94:	681b      	ldr	r3, [r3, #0]
 800fe96:	637b      	str	r3, [r7, #52]	; 0x34
		if (d == 'D' && (v & 0x80000000)) {
 800fe98:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800fe9c:	2b44      	cmp	r3, #68	; 0x44
 800fe9e:	d10c      	bne.n	800feba <f_printf+0x32e>
 800fea0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fea2:	2b00      	cmp	r3, #0
 800fea4:	da09      	bge.n	800feba <f_printf+0x32e>
			v = 0 - v;
 800fea6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fea8:	f1c3 0300 	rsb	r3, r3, #0
 800feac:	637b      	str	r3, [r7, #52]	; 0x34
			f |= 8;
 800feae:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800feb2:	f043 0308 	orr.w	r3, r3, #8
 800feb6:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		}
		i = 0;
 800feba:	f04f 0300 	mov.w	r3, #0
 800febe:	643b      	str	r3, [r7, #64]	; 0x40
		do {
			d = (TCHAR)(v % r); v /= r;
 800fec0:	f897 2046 	ldrb.w	r2, [r7, #70]	; 0x46
 800fec4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fec6:	fbb3 f1f2 	udiv	r1, r3, r2
 800feca:	fb02 f201 	mul.w	r2, r2, r1
 800fece:	1a9b      	subs	r3, r3, r2
 800fed0:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 800fed4:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800fed8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800feda:	fbb2 f3f3 	udiv	r3, r2, r3
 800fede:	637b      	str	r3, [r7, #52]	; 0x34
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 800fee0:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800fee4:	2b09      	cmp	r3, #9
 800fee6:	d90d      	bls.n	800ff04 <f_printf+0x378>
 800fee8:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800feec:	2b78      	cmp	r3, #120	; 0x78
 800feee:	d102      	bne.n	800fef6 <f_printf+0x36a>
 800fef0:	f04f 0327 	mov.w	r3, #39	; 0x27
 800fef4:	e001      	b.n	800fefa <f_printf+0x36e>
 800fef6:	f04f 0307 	mov.w	r3, #7
 800fefa:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 800fefe:	189b      	adds	r3, r3, r2
 800ff00:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
			s[i++] = d + '0';
 800ff04:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800ff08:	f103 0330 	add.w	r3, r3, #48	; 0x30
 800ff0c:	b2da      	uxtb	r2, r3
 800ff0e:	f107 010c 	add.w	r1, r7, #12
 800ff12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ff14:	18cb      	adds	r3, r1, r3
 800ff16:	701a      	strb	r2, [r3, #0]
 800ff18:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ff1a:	f103 0301 	add.w	r3, r3, #1
 800ff1e:	643b      	str	r3, [r7, #64]	; 0x40
		} while (v && i < sizeof(s) / sizeof(s[0]));
 800ff20:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ff22:	2b00      	cmp	r3, #0
 800ff24:	d002      	beq.n	800ff2c <f_printf+0x3a0>
 800ff26:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ff28:	2b0f      	cmp	r3, #15
 800ff2a:	d9c9      	bls.n	800fec0 <f_printf+0x334>
		if (f & 8) s[i++] = '-';
 800ff2c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800ff30:	f003 0308 	and.w	r3, r3, #8
 800ff34:	2b00      	cmp	r3, #0
 800ff36:	d00a      	beq.n	800ff4e <f_printf+0x3c2>
 800ff38:	f107 020c 	add.w	r2, r7, #12
 800ff3c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ff3e:	18d3      	adds	r3, r2, r3
 800ff40:	f04f 022d 	mov.w	r2, #45	; 0x2d
 800ff44:	701a      	strb	r2, [r3, #0]
 800ff46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ff48:	f103 0301 	add.w	r3, r3, #1
 800ff4c:	643b      	str	r3, [r7, #64]	; 0x40
		j = i; d = (f & 1) ? '0' : ' ';
 800ff4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ff50:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ff52:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800ff56:	f003 0301 	and.w	r3, r3, #1
 800ff5a:	2b00      	cmp	r3, #0
 800ff5c:	d002      	beq.n	800ff64 <f_printf+0x3d8>
 800ff5e:	f04f 0330 	mov.w	r3, #48	; 0x30
 800ff62:	e001      	b.n	800ff68 <f_printf+0x3dc>
 800ff64:	f04f 0320 	mov.w	r3, #32
 800ff68:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
		res = 0;
 800ff6c:	f04f 0300 	mov.w	r3, #0
 800ff70:	62fb      	str	r3, [r7, #44]	; 0x2c
		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
 800ff72:	e00a      	b.n	800ff8a <f_printf+0x3fe>
 800ff74:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 800ff78:	4618      	mov	r0, r3
 800ff7a:	6879      	ldr	r1, [r7, #4]
 800ff7c:	f7ff fdbc 	bl	800faf8 <f_putc>
 800ff80:	6278      	str	r0, [r7, #36]	; 0x24
 800ff82:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ff84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ff86:	18d3      	adds	r3, r2, r3
 800ff88:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ff8a:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 800ff8e:	f003 0302 	and.w	r3, r3, #2
 800ff92:	2b00      	cmp	r3, #0
 800ff94:	d10c      	bne.n	800ffb0 <f_printf+0x424>
 800ff96:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ff98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ff9a:	429a      	cmp	r2, r3
 800ff9c:	bf2c      	ite	cs
 800ff9e:	2300      	movcs	r3, #0
 800ffa0:	2301      	movcc	r3, #1
 800ffa2:	b2db      	uxtb	r3, r3
 800ffa4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800ffa6:	f102 0201 	add.w	r2, r2, #1
 800ffaa:	63fa      	str	r2, [r7, #60]	; 0x3c
 800ffac:	2b00      	cmp	r3, #0
 800ffae:	d1e1      	bne.n	800ff74 <f_printf+0x3e8>
		do res += (cc = f_putc(s[--i], fil)); while(i);
 800ffb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ffb2:	f103 33ff 	add.w	r3, r3, #4294967295
 800ffb6:	643b      	str	r3, [r7, #64]	; 0x40
 800ffb8:	f107 020c 	add.w	r2, r7, #12
 800ffbc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ffbe:	18d3      	adds	r3, r2, r3
 800ffc0:	781b      	ldrb	r3, [r3, #0]
 800ffc2:	4618      	mov	r0, r3
 800ffc4:	6879      	ldr	r1, [r7, #4]
 800ffc6:	f7ff fd97 	bl	800faf8 <f_putc>
 800ffca:	6278      	str	r0, [r7, #36]	; 0x24
 800ffcc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ffce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ffd0:	18d3      	adds	r3, r2, r3
 800ffd2:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ffd4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ffd6:	2b00      	cmp	r3, #0
 800ffd8:	d1ea      	bne.n	800ffb0 <f_printf+0x424>
		while (j++ < w) res += (cc = f_putc(' ', fil));
 800ffda:	e009      	b.n	800fff0 <f_printf+0x464>
 800ffdc:	f04f 0020 	mov.w	r0, #32
 800ffe0:	6879      	ldr	r1, [r7, #4]
 800ffe2:	f7ff fd89 	bl	800faf8 <f_putc>
 800ffe6:	6278      	str	r0, [r7, #36]	; 0x24
 800ffe8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ffea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ffec:	18d3      	adds	r3, r2, r3
 800ffee:	62fb      	str	r3, [r7, #44]	; 0x2c
 800fff0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800fff2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fff4:	429a      	cmp	r2, r3
 800fff6:	bf2c      	ite	cs
 800fff8:	2300      	movcs	r3, #0
 800fffa:	2301      	movcc	r3, #1
 800fffc:	b2db      	uxtb	r3, r3
 800fffe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010000:	f102 0201 	add.w	r2, r2, #1
 8010004:	63fa      	str	r2, [r7, #60]	; 0x3c
 8010006:	2b00      	cmp	r3, #0
 8010008:	d1e8      	bne.n	800ffdc <f_printf+0x450>
		if (cc != EOF) cc = res;
 801000a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801000c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8010010:	d005      	beq.n	801001e <f_printf+0x492>
 8010012:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010014:	627b      	str	r3, [r7, #36]	; 0x24
 8010016:	e002      	b.n	801001e <f_printf+0x492>
		c = *str++;
		if (c == 0) break;			/* End of string */
		if (c != '%') {				/* Non escape character */
			cc = f_putc(c, fil);
			if (cc != EOF) cc = 1;
			continue;
 8010018:	bf00      	nop
 801001a:	e000      	b.n	801001e <f_printf+0x492>
				while (j++ < w) chc += (cc = f_putc(' ', fil));
			}
			chc += (cc = f_puts(p, fil));
			while (j++ < w) chc += (cc = f_putc(' ', fil));
			if (cc != EOF) cc = chc;
			continue;
 801001c:	bf00      	nop
	int res, chc, cc;


	va_start(arp, str);

	for (cc = res = 0; cc != EOF; res += cc) {
 801001e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010020:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010022:	18d3      	adds	r3, r2, r3
 8010024:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010026:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010028:	f1b3 3fff 	cmp.w	r3, #4294967295
 801002c:	f47f adbc 	bne.w	800fba8 <f_printf+0x1c>
 8010030:	e002      	b.n	8010038 <f_printf+0x4ac>
		c = *str++;
		if (c == 0) break;			/* End of string */
 8010032:	bf00      	nop
 8010034:	e000      	b.n	8010038 <f_printf+0x4ac>
			c = *str++;
		}
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
			f |= 4; c = *str++;
		}
		if (!c) break;
 8010036:	bf00      	nop
		while (j++ < w) res += (cc = f_putc(' ', fil));
		if (cc != EOF) cc = res;
	}

	va_end(arp);
	return (cc == EOF) ? cc : res;
 8010038:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801003a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801003e:	d101      	bne.n	8010044 <f_printf+0x4b8>
 8010040:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010042:	e000      	b.n	8010046 <f_printf+0x4ba>
 8010044:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 8010046:	4618      	mov	r0, r3
 8010048:	f107 074c 	add.w	r7, r7, #76	; 0x4c
 801004c:	46bd      	mov	sp, r7
 801004e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8010052:	b003      	add	sp, #12
 8010054:	4770      	bx	lr
 8010056:	bf00      	nop

08010058 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
 8010058:	b580      	push	{r7, lr}
 801005a:	b084      	sub	sp, #16
 801005c:	af00      	add	r7, sp, #0
 801005e:	6078      	str	r0, [r7, #4]
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 8010060:	e00c      	b.n	801007c <free_etharp_q+0x24>
    r = q;
 8010062:	687b      	ldr	r3, [r7, #4]
 8010064:	60fb      	str	r3, [r7, #12]
    q = q->next;
 8010066:	687b      	ldr	r3, [r7, #4]
 8010068:	681b      	ldr	r3, [r3, #0]
 801006a:	607b      	str	r3, [r7, #4]
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
 801006c:	68fb      	ldr	r3, [r7, #12]
 801006e:	685b      	ldr	r3, [r3, #4]
 8010070:	4618      	mov	r0, r3
 8010072:	f002 ff25 	bl	8012ec0 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
 8010076:	68f8      	ldr	r0, [r7, #12]
 8010078:	f001 ff1e 	bl	8011eb8 <mem_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 801007c:	687b      	ldr	r3, [r7, #4]
 801007e:	2b00      	cmp	r3, #0
 8010080:	d1ef      	bne.n	8010062 <free_etharp_q+0xa>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
 8010082:	f107 0710 	add.w	r7, r7, #16
 8010086:	46bd      	mov	sp, r7
 8010088:	bd80      	pop	{r7, pc}
 801008a:	bf00      	nop

0801008c <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 801008c:	b580      	push	{r7, lr}
 801008e:	b082      	sub	sp, #8
 8010090:	af00      	add	r7, sp, #0
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8010092:	f04f 0300 	mov.w	r3, #0
 8010096:	71fb      	strb	r3, [r7, #7]
 8010098:	e0ae      	b.n	80101f8 <etharp_tmr+0x16c>
    arp_table[i].ctime++;
 801009a:	79fa      	ldrb	r2, [r7, #7]
 801009c:	f640 51e0 	movw	r1, #3552	; 0xde0
 80100a0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80100a4:	4613      	mov	r3, r2
 80100a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80100aa:	189b      	adds	r3, r3, r2
 80100ac:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80100b0:	18cb      	adds	r3, r1, r3
 80100b2:	f103 0308 	add.w	r3, r3, #8
 80100b6:	79db      	ldrb	r3, [r3, #7]
 80100b8:	f103 0301 	add.w	r3, r3, #1
 80100bc:	b2d8      	uxtb	r0, r3
 80100be:	f640 51e0 	movw	r1, #3552	; 0xde0
 80100c2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80100c6:	4613      	mov	r3, r2
 80100c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80100cc:	189b      	adds	r3, r3, r2
 80100ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80100d2:	18cb      	adds	r3, r1, r3
 80100d4:	f103 0308 	add.w	r3, r3, #8
 80100d8:	4602      	mov	r2, r0
 80100da:	71da      	strb	r2, [r3, #7]
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
 80100dc:	79f9      	ldrb	r1, [r7, #7]
 80100de:	f640 52e0 	movw	r2, #3552	; 0xde0
 80100e2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80100e6:	460b      	mov	r3, r1
 80100e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80100ec:	185b      	adds	r3, r3, r1
 80100ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80100f2:	18d3      	adds	r3, r2, r3
 80100f4:	f103 0308 	add.w	r3, r3, #8
 80100f8:	799b      	ldrb	r3, [r3, #6]
 80100fa:	2b02      	cmp	r3, #2
 80100fc:	d110      	bne.n	8010120 <etharp_tmr+0x94>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
 80100fe:	79f9      	ldrb	r1, [r7, #7]
 8010100:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010104:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010108:	460b      	mov	r3, r1
 801010a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801010e:	185b      	adds	r3, r3, r1
 8010110:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010114:	18d3      	adds	r3, r2, r3
 8010116:	f103 0308 	add.w	r3, r3, #8
 801011a:	79db      	ldrb	r3, [r3, #7]

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
 801011c:	2bef      	cmp	r3, #239	; 0xef
 801011e:	d821      	bhi.n	8010164 <etharp_tmr+0xd8>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 8010120:	79f9      	ldrb	r1, [r7, #7]
 8010122:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010126:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801012a:	460b      	mov	r3, r1
 801012c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010130:	185b      	adds	r3, r3, r1
 8010132:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010136:	18d3      	adds	r3, r2, r3
 8010138:	f103 0308 	add.w	r3, r3, #8
 801013c:	799b      	ldrb	r3, [r3, #6]
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
 801013e:	2b01      	cmp	r3, #1
 8010140:	d14f      	bne.n	80101e2 <etharp_tmr+0x156>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
 8010142:	79f9      	ldrb	r1, [r7, #7]
 8010144:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010148:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801014c:	460b      	mov	r3, r1
 801014e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010152:	185b      	adds	r3, r3, r1
 8010154:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010158:	18d3      	adds	r3, r2, r3
 801015a:	f103 0308 	add.w	r3, r3, #8
 801015e:	79db      	ldrb	r3, [r3, #7]
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 8010160:	2b01      	cmp	r3, #1
 8010162:	d93e      	bls.n	80101e2 <etharp_tmr+0x156>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
 8010164:	79f9      	ldrb	r1, [r7, #7]
 8010166:	f640 52e0 	movw	r2, #3552	; 0xde0
 801016a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801016e:	460b      	mov	r3, r1
 8010170:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010174:	185b      	adds	r3, r3, r1
 8010176:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801017a:	18d3      	adds	r3, r2, r3
 801017c:	681b      	ldr	r3, [r3, #0]
 801017e:	2b00      	cmp	r3, #0
 8010180:	d01e      	beq.n	80101c0 <etharp_tmr+0x134>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
 8010182:	79f9      	ldrb	r1, [r7, #7]
 8010184:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010188:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801018c:	460b      	mov	r3, r1
 801018e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010192:	185b      	adds	r3, r3, r1
 8010194:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010198:	18d3      	adds	r3, r2, r3
 801019a:	681b      	ldr	r3, [r3, #0]
 801019c:	4618      	mov	r0, r3
 801019e:	f7ff ff5b 	bl	8010058 <free_etharp_q>
        arp_table[i].q = NULL;
 80101a2:	79f9      	ldrb	r1, [r7, #7]
 80101a4:	f640 52e0 	movw	r2, #3552	; 0xde0
 80101a8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80101ac:	460b      	mov	r3, r1
 80101ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80101b2:	185b      	adds	r3, r3, r1
 80101b4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80101b8:	18d3      	adds	r3, r2, r3
 80101ba:	f04f 0200 	mov.w	r2, #0
 80101be:	601a      	str	r2, [r3, #0]
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
 80101c0:	79f9      	ldrb	r1, [r7, #7]
 80101c2:	f640 52e0 	movw	r2, #3552	; 0xde0
 80101c6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80101ca:	460b      	mov	r3, r1
 80101cc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80101d0:	185b      	adds	r3, r3, r1
 80101d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80101d6:	18d3      	adds	r3, r2, r3
 80101d8:	f103 0308 	add.w	r3, r3, #8
 80101dc:	f04f 0200 	mov.w	r2, #0
 80101e0:	719a      	strb	r2, [r3, #6]
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
 80101e2:	79fa      	ldrb	r2, [r7, #7]
 80101e4:	4613      	mov	r3, r2
 80101e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80101ea:	189b      	adds	r3, r3, r2
 80101ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80101f0:	79fb      	ldrb	r3, [r7, #7]
 80101f2:	f103 0301 	add.w	r3, r3, #1
 80101f6:	71fb      	strb	r3, [r7, #7]
 80101f8:	79fb      	ldrb	r3, [r7, #7]
 80101fa:	2b09      	cmp	r3, #9
 80101fc:	f67f af4d 	bls.w	801009a <etharp_tmr+0xe>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
 8010200:	f107 0708 	add.w	r7, r7, #8
 8010204:	46bd      	mov	sp, r7
 8010206:	bd80      	pop	{r7, pc}

08010208 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
 8010208:	b580      	push	{r7, lr}
 801020a:	b084      	sub	sp, #16
 801020c:	af00      	add	r7, sp, #0
 801020e:	6078      	str	r0, [r7, #4]
 8010210:	460b      	mov	r3, r1
 8010212:	70fb      	strb	r3, [r7, #3]
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8010214:	f04f 030a 	mov.w	r3, #10
 8010218:	73fb      	strb	r3, [r7, #15]
 801021a:	f04f 030a 	mov.w	r3, #10
 801021e:	73bb      	strb	r3, [r7, #14]
  s8_t empty = ARP_TABLE_SIZE;
 8010220:	f04f 030a 	mov.w	r3, #10
 8010224:	737b      	strb	r3, [r7, #13]
  u8_t i = 0, age_pending = 0, age_stable = 0;
 8010226:	f04f 0300 	mov.w	r3, #0
 801022a:	733b      	strb	r3, [r7, #12]
 801022c:	f04f 0300 	mov.w	r3, #0
 8010230:	72fb      	strb	r3, [r7, #11]
 8010232:	f04f 0300 	mov.w	r3, #0
 8010236:	72bb      	strb	r3, [r7, #10]
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 8010238:	f04f 030a 	mov.w	r3, #10
 801023c:	727b      	strb	r3, [r7, #9]
  /* its age */
  u8_t age_queue = 0;
 801023e:	f04f 0300 	mov.w	r3, #0
 8010242:	723b      	strb	r3, [r7, #8]
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
 8010244:	687b      	ldr	r3, [r7, #4]
 8010246:	2b00      	cmp	r3, #0
 8010248:	d034      	beq.n	80102b4 <find_entry+0xac>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
 801024a:	f640 63a8 	movw	r3, #3752	; 0xea8
 801024e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010252:	781b      	ldrb	r3, [r3, #0]
 8010254:	4619      	mov	r1, r3
 8010256:	f640 52e0 	movw	r2, #3552	; 0xde0
 801025a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801025e:	460b      	mov	r3, r1
 8010260:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010264:	185b      	adds	r3, r3, r1
 8010266:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801026a:	18d3      	adds	r3, r2, r3
 801026c:	f103 0308 	add.w	r3, r3, #8
 8010270:	799b      	ldrb	r3, [r3, #6]
 8010272:	2b02      	cmp	r3, #2
 8010274:	d11e      	bne.n	80102b4 <find_entry+0xac>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
 8010276:	687b      	ldr	r3, [r7, #4]
 8010278:	6818      	ldr	r0, [r3, #0]
 801027a:	f640 63a8 	movw	r3, #3752	; 0xea8
 801027e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010282:	781b      	ldrb	r3, [r3, #0]
 8010284:	4619      	mov	r1, r3
 8010286:	f640 52e0 	movw	r2, #3552	; 0xde0
 801028a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801028e:	460b      	mov	r3, r1
 8010290:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010294:	185b      	adds	r3, r3, r1
 8010296:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801029a:	18d3      	adds	r3, r2, r3
 801029c:	f103 0304 	add.w	r3, r3, #4
 80102a0:	681b      	ldr	r3, [r3, #0]
 80102a2:	4298      	cmp	r0, r3
 80102a4:	d106      	bne.n	80102b4 <find_entry+0xac>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
 80102a6:	f640 63a8 	movw	r3, #3752	; 0xea8
 80102aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80102ae:	781b      	ldrb	r3, [r3, #0]
 80102b0:	b2db      	uxtb	r3, r3
 80102b2:	e19f      	b.n	80105f4 <find_entry+0x3ec>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80102b4:	f04f 0300 	mov.w	r3, #0
 80102b8:	733b      	strb	r3, [r7, #12]
 80102ba:	e0f7      	b.n	80104ac <find_entry+0x2a4>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
 80102bc:	f997 300d 	ldrsb.w	r3, [r7, #13]
 80102c0:	2b0a      	cmp	r3, #10
 80102c2:	d113      	bne.n	80102ec <find_entry+0xe4>
 80102c4:	7b39      	ldrb	r1, [r7, #12]
 80102c6:	f640 52e0 	movw	r2, #3552	; 0xde0
 80102ca:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80102ce:	460b      	mov	r3, r1
 80102d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80102d4:	185b      	adds	r3, r3, r1
 80102d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80102da:	18d3      	adds	r3, r2, r3
 80102dc:	f103 0308 	add.w	r3, r3, #8
 80102e0:	799b      	ldrb	r3, [r3, #6]
 80102e2:	2b00      	cmp	r3, #0
 80102e4:	d102      	bne.n	80102ec <find_entry+0xe4>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 80102e6:	7b3b      	ldrb	r3, [r7, #12]
 80102e8:	737b      	strb	r3, [r7, #13]
 80102ea:	e0db      	b.n	80104a4 <find_entry+0x29c>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 80102ec:	7b39      	ldrb	r1, [r7, #12]
 80102ee:	f640 52e0 	movw	r2, #3552	; 0xde0
 80102f2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80102f6:	460b      	mov	r3, r1
 80102f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80102fc:	185b      	adds	r3, r3, r1
 80102fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010302:	18d3      	adds	r3, r2, r3
 8010304:	f103 0308 	add.w	r3, r3, #8
 8010308:	799b      	ldrb	r3, [r3, #6]
 801030a:	2b01      	cmp	r3, #1
 801030c:	d177      	bne.n	80103fe <find_entry+0x1f6>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 801030e:	687b      	ldr	r3, [r7, #4]
 8010310:	2b00      	cmp	r3, #0
 8010312:	d01a      	beq.n	801034a <find_entry+0x142>
 8010314:	687b      	ldr	r3, [r7, #4]
 8010316:	6818      	ldr	r0, [r3, #0]
 8010318:	7b39      	ldrb	r1, [r7, #12]
 801031a:	f640 52e0 	movw	r2, #3552	; 0xde0
 801031e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010322:	460b      	mov	r3, r1
 8010324:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010328:	185b      	adds	r3, r3, r1
 801032a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801032e:	18d3      	adds	r3, r2, r3
 8010330:	f103 0304 	add.w	r3, r3, #4
 8010334:	681b      	ldr	r3, [r3, #0]
 8010336:	4298      	cmp	r0, r3
 8010338:	d107      	bne.n	801034a <find_entry+0x142>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
 801033a:	f640 63a8 	movw	r3, #3752	; 0xea8
 801033e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010342:	7b3a      	ldrb	r2, [r7, #12]
 8010344:	701a      	strb	r2, [r3, #0]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
 8010346:	7b3b      	ldrb	r3, [r7, #12]
 8010348:	e154      	b.n	80105f4 <find_entry+0x3ec>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
 801034a:	7b39      	ldrb	r1, [r7, #12]
 801034c:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010350:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010354:	460b      	mov	r3, r1
 8010356:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801035a:	185b      	adds	r3, r3, r1
 801035c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010360:	18d3      	adds	r3, r2, r3
 8010362:	681b      	ldr	r3, [r3, #0]
 8010364:	2b00      	cmp	r3, #0
 8010366:	d025      	beq.n	80103b4 <find_entry+0x1ac>
        if (arp_table[i].ctime >= age_queue) {
 8010368:	7b39      	ldrb	r1, [r7, #12]
 801036a:	f640 52e0 	movw	r2, #3552	; 0xde0
 801036e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010372:	460b      	mov	r3, r1
 8010374:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010378:	185b      	adds	r3, r3, r1
 801037a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801037e:	18d3      	adds	r3, r2, r3
 8010380:	f103 0308 	add.w	r3, r3, #8
 8010384:	79db      	ldrb	r3, [r3, #7]
 8010386:	7a3a      	ldrb	r2, [r7, #8]
 8010388:	429a      	cmp	r2, r3
 801038a:	f200 808b 	bhi.w	80104a4 <find_entry+0x29c>
          old_queue = i;
 801038e:	7b3b      	ldrb	r3, [r7, #12]
 8010390:	727b      	strb	r3, [r7, #9]
          age_queue = arp_table[i].ctime;
 8010392:	7b39      	ldrb	r1, [r7, #12]
 8010394:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010398:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801039c:	460b      	mov	r3, r1
 801039e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80103a2:	185b      	adds	r3, r3, r1
 80103a4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80103a8:	18d3      	adds	r3, r2, r3
 80103aa:	f103 0308 	add.w	r3, r3, #8
 80103ae:	79db      	ldrb	r3, [r3, #7]
 80103b0:	723b      	strb	r3, [r7, #8]
 80103b2:	e077      	b.n	80104a4 <find_entry+0x29c>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
 80103b4:	7b39      	ldrb	r1, [r7, #12]
 80103b6:	f640 52e0 	movw	r2, #3552	; 0xde0
 80103ba:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80103be:	460b      	mov	r3, r1
 80103c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80103c4:	185b      	adds	r3, r3, r1
 80103c6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80103ca:	18d3      	adds	r3, r2, r3
 80103cc:	f103 0308 	add.w	r3, r3, #8
 80103d0:	79db      	ldrb	r3, [r3, #7]
 80103d2:	7afa      	ldrb	r2, [r7, #11]
 80103d4:	429a      	cmp	r2, r3
 80103d6:	d865      	bhi.n	80104a4 <find_entry+0x29c>
          old_pending = i;
 80103d8:	7b3b      	ldrb	r3, [r7, #12]
 80103da:	73fb      	strb	r3, [r7, #15]
          age_pending = arp_table[i].ctime;
 80103dc:	7b39      	ldrb	r1, [r7, #12]
 80103de:	f640 52e0 	movw	r2, #3552	; 0xde0
 80103e2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80103e6:	460b      	mov	r3, r1
 80103e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80103ec:	185b      	adds	r3, r3, r1
 80103ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80103f2:	18d3      	adds	r3, r2, r3
 80103f4:	f103 0308 	add.w	r3, r3, #8
 80103f8:	79db      	ldrb	r3, [r3, #7]
 80103fa:	72fb      	strb	r3, [r7, #11]
 80103fc:	e052      	b.n	80104a4 <find_entry+0x29c>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
 80103fe:	7b39      	ldrb	r1, [r7, #12]
 8010400:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010404:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010408:	460b      	mov	r3, r1
 801040a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801040e:	185b      	adds	r3, r3, r1
 8010410:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010414:	18d3      	adds	r3, r2, r3
 8010416:	f103 0308 	add.w	r3, r3, #8
 801041a:	799b      	ldrb	r3, [r3, #6]
 801041c:	2b02      	cmp	r3, #2
 801041e:	d141      	bne.n	80104a4 <find_entry+0x29c>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 8010420:	687b      	ldr	r3, [r7, #4]
 8010422:	2b00      	cmp	r3, #0
 8010424:	d01a      	beq.n	801045c <find_entry+0x254>
 8010426:	687b      	ldr	r3, [r7, #4]
 8010428:	6818      	ldr	r0, [r3, #0]
 801042a:	7b39      	ldrb	r1, [r7, #12]
 801042c:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010430:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010434:	460b      	mov	r3, r1
 8010436:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801043a:	185b      	adds	r3, r3, r1
 801043c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010440:	18d3      	adds	r3, r2, r3
 8010442:	f103 0304 	add.w	r3, r3, #4
 8010446:	681b      	ldr	r3, [r3, #0]
 8010448:	4298      	cmp	r0, r3
 801044a:	d107      	bne.n	801045c <find_entry+0x254>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
 801044c:	f640 63a8 	movw	r3, #3752	; 0xea8
 8010450:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010454:	7b3a      	ldrb	r2, [r7, #12]
 8010456:	701a      	strb	r2, [r3, #0]
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
 8010458:	7b3b      	ldrb	r3, [r7, #12]
 801045a:	e0cb      	b.n	80105f4 <find_entry+0x3ec>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
 801045c:	7b39      	ldrb	r1, [r7, #12]
 801045e:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010462:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010466:	460b      	mov	r3, r1
 8010468:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801046c:	185b      	adds	r3, r3, r1
 801046e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010472:	18d3      	adds	r3, r2, r3
 8010474:	f103 0308 	add.w	r3, r3, #8
 8010478:	79db      	ldrb	r3, [r3, #7]
 801047a:	7aba      	ldrb	r2, [r7, #10]
 801047c:	429a      	cmp	r2, r3
 801047e:	d811      	bhi.n	80104a4 <find_entry+0x29c>
        old_stable = i;
 8010480:	7b3b      	ldrb	r3, [r7, #12]
 8010482:	73bb      	strb	r3, [r7, #14]
        age_stable = arp_table[i].ctime;
 8010484:	7b39      	ldrb	r1, [r7, #12]
 8010486:	f640 52e0 	movw	r2, #3552	; 0xde0
 801048a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801048e:	460b      	mov	r3, r1
 8010490:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010494:	185b      	adds	r3, r3, r1
 8010496:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801049a:	18d3      	adds	r3, r2, r3
 801049c:	f103 0308 	add.w	r3, r3, #8
 80104a0:	79db      	ldrb	r3, [r3, #7]
 80104a2:	72bb      	strb	r3, [r7, #10]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 80104a4:	7b3b      	ldrb	r3, [r7, #12]
 80104a6:	f103 0301 	add.w	r3, r3, #1
 80104aa:	733b      	strb	r3, [r7, #12]
 80104ac:	7b3b      	ldrb	r3, [r7, #12]
 80104ae:	2b09      	cmp	r3, #9
 80104b0:	f67f af04 	bls.w	80102bc <find_entry+0xb4>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
 80104b4:	f997 300d 	ldrsb.w	r3, [r7, #13]
 80104b8:	2b0a      	cmp	r3, #10
 80104ba:	d104      	bne.n	80104c6 <find_entry+0x2be>
 80104bc:	78fb      	ldrb	r3, [r7, #3]
 80104be:	f003 0301 	and.w	r3, r3, #1
 80104c2:	2b00      	cmp	r3, #0
 80104c4:	d004      	beq.n	80104d0 <find_entry+0x2c8>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
 80104c6:	78fb      	ldrb	r3, [r7, #3]
 80104c8:	f003 0302 	and.w	r3, r3, #2
 80104cc:	2b00      	cmp	r3, #0
 80104ce:	d002      	beq.n	80104d6 <find_entry+0x2ce>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
 80104d0:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80104d4:	e08e      	b.n	80105f4 <find_entry+0x3ec>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 80104d6:	f997 300d 	ldrsb.w	r3, [r7, #13]
 80104da:	2b09      	cmp	r3, #9
 80104dc:	dc02      	bgt.n	80104e4 <find_entry+0x2dc>
    i = empty;
 80104de:	7b7b      	ldrb	r3, [r7, #13]
 80104e0:	733b      	strb	r3, [r7, #12]
 80104e2:	e03d      	b.n	8010560 <find_entry+0x358>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
 80104e4:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80104e8:	2b09      	cmp	r3, #9
 80104ea:	dc09      	bgt.n	8010500 <find_entry+0x2f8>
    /* recycle oldest stable*/
    i = old_stable;
 80104ec:	7bbb      	ldrb	r3, [r7, #14]
 80104ee:	733b      	strb	r3, [r7, #12]
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 80104f0:	7b3a      	ldrb	r2, [r7, #12]
 80104f2:	4613      	mov	r3, r2
 80104f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80104f8:	189b      	adds	r3, r3, r2
 80104fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80104fe:	e02f      	b.n	8010560 <find_entry+0x358>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
 8010500:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8010504:	2b09      	cmp	r3, #9
 8010506:	dc02      	bgt.n	801050e <find_entry+0x306>
    /* recycle oldest pending */
    i = old_pending;
 8010508:	7bfb      	ldrb	r3, [r7, #15]
 801050a:	733b      	strb	r3, [r7, #12]
 801050c:	e028      	b.n	8010560 <find_entry+0x358>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
 801050e:	f997 3009 	ldrsb.w	r3, [r7, #9]
 8010512:	2b09      	cmp	r3, #9
 8010514:	dc21      	bgt.n	801055a <find_entry+0x352>
    /* recycle oldest pending */
    i = old_queue;
 8010516:	7a7b      	ldrb	r3, [r7, #9]
 8010518:	733b      	strb	r3, [r7, #12]
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 801051a:	7b39      	ldrb	r1, [r7, #12]
 801051c:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010520:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010524:	460b      	mov	r3, r1
 8010526:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801052a:	185b      	adds	r3, r3, r1
 801052c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010530:	18d3      	adds	r3, r2, r3
 8010532:	681b      	ldr	r3, [r3, #0]
 8010534:	4618      	mov	r0, r3
 8010536:	f7ff fd8f 	bl	8010058 <free_etharp_q>
    arp_table[i].q = NULL;
 801053a:	7b39      	ldrb	r1, [r7, #12]
 801053c:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010540:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010544:	460b      	mov	r3, r1
 8010546:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801054a:	185b      	adds	r3, r3, r1
 801054c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010550:	18d3      	adds	r3, r2, r3
 8010552:	f04f 0200 	mov.w	r2, #0
 8010556:	601a      	str	r2, [r3, #0]
 8010558:	e002      	b.n	8010560 <find_entry+0x358>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
 801055a:	f04f 03ff 	mov.w	r3, #255	; 0xff
 801055e:	e049      	b.n	80105f4 <find_entry+0x3ec>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
 8010560:	7b3a      	ldrb	r2, [r7, #12]
 8010562:	4613      	mov	r3, r2
 8010564:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010568:	189b      	adds	r3, r3, r2
 801056a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 801056e:	7b39      	ldrb	r1, [r7, #12]
 8010570:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010574:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010578:	460b      	mov	r3, r1
 801057a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801057e:	185b      	adds	r3, r3, r1
 8010580:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010584:	18d3      	adds	r3, r2, r3
 8010586:	f103 0308 	add.w	r3, r3, #8
 801058a:	f04f 0200 	mov.w	r2, #0
 801058e:	719a      	strb	r2, [r3, #6]

  /* IP address given? */
  if (ipaddr != NULL) {
 8010590:	687b      	ldr	r3, [r7, #4]
 8010592:	2b00      	cmp	r3, #0
 8010594:	d016      	beq.n	80105c4 <find_entry+0x3bc>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
 8010596:	7b38      	ldrb	r0, [r7, #12]
 8010598:	687b      	ldr	r3, [r7, #4]
 801059a:	2b00      	cmp	r3, #0
 801059c:	d002      	beq.n	80105a4 <find_entry+0x39c>
 801059e:	687b      	ldr	r3, [r7, #4]
 80105a0:	6819      	ldr	r1, [r3, #0]
 80105a2:	e001      	b.n	80105a8 <find_entry+0x3a0>
 80105a4:	f04f 0100 	mov.w	r1, #0
 80105a8:	f640 52e0 	movw	r2, #3552	; 0xde0
 80105ac:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80105b0:	4603      	mov	r3, r0
 80105b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80105b6:	181b      	adds	r3, r3, r0
 80105b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80105bc:	18d3      	adds	r3, r2, r3
 80105be:	f103 0304 	add.w	r3, r3, #4
 80105c2:	6019      	str	r1, [r3, #0]
  }
  arp_table[i].ctime = 0;
 80105c4:	7b39      	ldrb	r1, [r7, #12]
 80105c6:	f640 52e0 	movw	r2, #3552	; 0xde0
 80105ca:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80105ce:	460b      	mov	r3, r1
 80105d0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80105d4:	185b      	adds	r3, r3, r1
 80105d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80105da:	18d3      	adds	r3, r2, r3
 80105dc:	f103 0308 	add.w	r3, r3, #8
 80105e0:	f04f 0200 	mov.w	r2, #0
 80105e4:	71da      	strb	r2, [r3, #7]
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
 80105e6:	f640 63a8 	movw	r3, #3752	; 0xea8
 80105ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80105ee:	7b3a      	ldrb	r2, [r7, #12]
 80105f0:	701a      	strb	r2, [r3, #0]
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
 80105f2:	7b3b      	ldrb	r3, [r7, #12]
 80105f4:	b25b      	sxtb	r3, r3
}
 80105f6:	4618      	mov	r0, r3
 80105f8:	f107 0710 	add.w	r7, r7, #16
 80105fc:	46bd      	mov	sp, r7
 80105fe:	bd80      	pop	{r7, pc}

08010600 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 8010600:	b580      	push	{r7, lr}
 8010602:	b086      	sub	sp, #24
 8010604:	af00      	add	r7, sp, #0
 8010606:	60f8      	str	r0, [r7, #12]
 8010608:	60b9      	str	r1, [r7, #8]
 801060a:	607a      	str	r2, [r7, #4]
 801060c:	603b      	str	r3, [r7, #0]
  struct eth_hdr *ethhdr = p->payload;
 801060e:	68bb      	ldr	r3, [r7, #8]
 8010610:	685b      	ldr	r3, [r3, #4]
 8010612:	613b      	str	r3, [r7, #16]
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
 8010614:	f04f 0306 	mov.w	r3, #6
 8010618:	75fb      	strb	r3, [r7, #23]
  while(k > 0) {
 801061a:	e010      	b.n	801063e <etharp_send_ip+0x3e>
    k--;
 801061c:	7dfb      	ldrb	r3, [r7, #23]
 801061e:	f103 33ff 	add.w	r3, r3, #4294967295
 8010622:	75fb      	strb	r3, [r7, #23]
    ethhdr->dest.addr[k] = dst->addr[k];
 8010624:	7dfb      	ldrb	r3, [r7, #23]
 8010626:	7dfa      	ldrb	r2, [r7, #23]
 8010628:	6839      	ldr	r1, [r7, #0]
 801062a:	5c89      	ldrb	r1, [r1, r2]
 801062c:	693a      	ldr	r2, [r7, #16]
 801062e:	54d1      	strb	r1, [r2, r3]
    ethhdr->src.addr[k]  = src->addr[k];
 8010630:	7dfb      	ldrb	r3, [r7, #23]
 8010632:	7dfa      	ldrb	r2, [r7, #23]
 8010634:	6879      	ldr	r1, [r7, #4]
 8010636:	5c8a      	ldrb	r2, [r1, r2]
 8010638:	6939      	ldr	r1, [r7, #16]
 801063a:	18cb      	adds	r3, r1, r3
 801063c:	719a      	strb	r2, [r3, #6]
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
 801063e:	7dfb      	ldrb	r3, [r7, #23]
 8010640:	2b00      	cmp	r3, #0
 8010642:	d1eb      	bne.n	801061c <etharp_send_ip+0x1c>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
 8010644:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8010648:	f008 fd86 	bl	8019158 <htons>
 801064c:	4603      	mov	r3, r0
 801064e:	461a      	mov	r2, r3
 8010650:	693b      	ldr	r3, [r7, #16]
 8010652:	819a      	strh	r2, [r3, #12]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 8010654:	68fb      	ldr	r3, [r7, #12]
 8010656:	699b      	ldr	r3, [r3, #24]
 8010658:	68f8      	ldr	r0, [r7, #12]
 801065a:	68b9      	ldr	r1, [r7, #8]
 801065c:	4798      	blx	r3
 801065e:	4603      	mov	r3, r0
}
 8010660:	4618      	mov	r0, r3
 8010662:	f107 0718 	add.w	r7, r7, #24
 8010666:	46bd      	mov	sp, r7
 8010668:	bd80      	pop	{r7, pc}
 801066a:	bf00      	nop

0801066c <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 801066c:	b590      	push	{r4, r7, lr}
 801066e:	b089      	sub	sp, #36	; 0x24
 8010670:	af00      	add	r7, sp, #0
 8010672:	60f8      	str	r0, [r7, #12]
 8010674:	60b9      	str	r1, [r7, #8]
 8010676:	607a      	str	r2, [r7, #4]
 8010678:	70fb      	strb	r3, [r7, #3]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 801067a:	68bb      	ldr	r3, [r7, #8]
 801067c:	2b00      	cmp	r3, #0
 801067e:	d019      	beq.n	80106b4 <update_arp_entry+0x48>
 8010680:	68bb      	ldr	r3, [r7, #8]
 8010682:	681b      	ldr	r3, [r3, #0]
 8010684:	2b00      	cmp	r3, #0
 8010686:	d015      	beq.n	80106b4 <update_arp_entry+0x48>
      ip_addr_isbroadcast(ipaddr, netif) ||
 8010688:	68b8      	ldr	r0, [r7, #8]
 801068a:	68f9      	ldr	r1, [r7, #12]
 801068c:	f009 fa52 	bl	8019b34 <ip_addr_isbroadcast>
 8010690:	4603      	mov	r3, r0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 8010692:	2b00      	cmp	r3, #0
 8010694:	d10e      	bne.n	80106b4 <update_arp_entry+0x48>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
 8010696:	68bb      	ldr	r3, [r7, #8]
 8010698:	681c      	ldr	r4, [r3, #0]
 801069a:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 801069e:	f008 fda1 	bl	80191e4 <ntohl>
 80106a2:	4603      	mov	r3, r0
 80106a4:	401c      	ands	r4, r3
 80106a6:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 80106aa:	f008 fd9b 	bl	80191e4 <ntohl>
 80106ae:	4603      	mov	r3, r0
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
 80106b0:	429c      	cmp	r4, r3
 80106b2:	d102      	bne.n	80106ba <update_arp_entry+0x4e>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 80106b4:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 80106b8:	e0a6      	b.n	8010808 <update_arp_entry+0x19c>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
 80106ba:	78fb      	ldrb	r3, [r7, #3]
 80106bc:	68b8      	ldr	r0, [r7, #8]
 80106be:	4619      	mov	r1, r3
 80106c0:	f7ff fda2 	bl	8010208 <find_entry>
 80106c4:	4603      	mov	r3, r0
 80106c6:	77bb      	strb	r3, [r7, #30]
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
 80106c8:	f997 301e 	ldrsb.w	r3, [r7, #30]
 80106cc:	2b00      	cmp	r3, #0
 80106ce:	da01      	bge.n	80106d4 <update_arp_entry+0x68>
    return (err_t)i;
 80106d0:	7fbb      	ldrb	r3, [r7, #30]
 80106d2:	e099      	b.n	8010808 <update_arp_entry+0x19c>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
 80106d4:	f997 101e 	ldrsb.w	r1, [r7, #30]
 80106d8:	f640 52e0 	movw	r2, #3552	; 0xde0
 80106dc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80106e0:	460b      	mov	r3, r1
 80106e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80106e6:	185b      	adds	r3, r3, r1
 80106e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80106ec:	18d3      	adds	r3, r2, r3
 80106ee:	f103 0308 	add.w	r3, r3, #8
 80106f2:	f04f 0202 	mov.w	r2, #2
 80106f6:	719a      	strb	r2, [r3, #6]
  /* record network interface */
  arp_table[i].netif = netif;
 80106f8:	f997 101e 	ldrsb.w	r1, [r7, #30]
 80106fc:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010700:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010704:	460b      	mov	r3, r1
 8010706:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801070a:	185b      	adds	r3, r3, r1
 801070c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010710:	18d3      	adds	r3, r2, r3
 8010712:	f103 0310 	add.w	r3, r3, #16
 8010716:	68fa      	ldr	r2, [r7, #12]
 8010718:	601a      	str	r2, [r3, #0]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
 801071a:	f04f 0306 	mov.w	r3, #6
 801071e:	77fb      	strb	r3, [r7, #31]
  while (k > 0) {
 8010720:	e019      	b.n	8010756 <update_arp_entry+0xea>
    k--;
 8010722:	7ffb      	ldrb	r3, [r7, #31]
 8010724:	f103 33ff 	add.w	r3, r3, #4294967295
 8010728:	77fb      	strb	r3, [r7, #31]
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
 801072a:	f997 101e 	ldrsb.w	r1, [r7, #30]
 801072e:	7ffc      	ldrb	r4, [r7, #31]
 8010730:	7ffb      	ldrb	r3, [r7, #31]
 8010732:	687a      	ldr	r2, [r7, #4]
 8010734:	5cd0      	ldrb	r0, [r2, r3]
 8010736:	f640 52e0 	movw	r2, #3552	; 0xde0
 801073a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801073e:	460b      	mov	r3, r1
 8010740:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010744:	185b      	adds	r3, r3, r1
 8010746:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801074a:	18d3      	adds	r3, r2, r3
 801074c:	191b      	adds	r3, r3, r4
 801074e:	f103 0308 	add.w	r3, r3, #8
 8010752:	4602      	mov	r2, r0
 8010754:	701a      	strb	r2, [r3, #0]
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
 8010756:	7ffb      	ldrb	r3, [r7, #31]
 8010758:	2b00      	cmp	r3, #0
 801075a:	d1e2      	bne.n	8010722 <update_arp_entry+0xb6>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
 801075c:	f997 101e 	ldrsb.w	r1, [r7, #30]
 8010760:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010764:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010768:	460b      	mov	r3, r1
 801076a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801076e:	185b      	adds	r3, r3, r1
 8010770:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010774:	18d3      	adds	r3, r2, r3
 8010776:	f103 0308 	add.w	r3, r3, #8
 801077a:	f04f 0200 	mov.w	r2, #0
 801077e:	71da      	strb	r2, [r3, #7]
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
 8010780:	e030      	b.n	80107e4 <update_arp_entry+0x178>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
 8010782:	f997 101e 	ldrsb.w	r1, [r7, #30]
 8010786:	f640 52e0 	movw	r2, #3552	; 0xde0
 801078a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801078e:	460b      	mov	r3, r1
 8010790:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010794:	185b      	adds	r3, r3, r1
 8010796:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801079a:	18d3      	adds	r3, r2, r3
 801079c:	681b      	ldr	r3, [r3, #0]
 801079e:	61bb      	str	r3, [r7, #24]
    /* pop first item off the queue */
    arp_table[i].q = q->next;
 80107a0:	f997 101e 	ldrsb.w	r1, [r7, #30]
 80107a4:	69bb      	ldr	r3, [r7, #24]
 80107a6:	6818      	ldr	r0, [r3, #0]
 80107a8:	f640 52e0 	movw	r2, #3552	; 0xde0
 80107ac:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80107b0:	460b      	mov	r3, r1
 80107b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80107b6:	185b      	adds	r3, r3, r1
 80107b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80107bc:	18d3      	adds	r3, r2, r3
 80107be:	6018      	str	r0, [r3, #0]
    /* get the packet pointer */
    p = q->p;
 80107c0:	69bb      	ldr	r3, [r7, #24]
 80107c2:	685b      	ldr	r3, [r3, #4]
 80107c4:	617b      	str	r3, [r7, #20]
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
 80107c6:	69b8      	ldr	r0, [r7, #24]
 80107c8:	f001 fb76 	bl	8011eb8 <mem_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 80107cc:	68fb      	ldr	r3, [r7, #12]
 80107ce:	f103 0323 	add.w	r3, r3, #35	; 0x23
 80107d2:	68f8      	ldr	r0, [r7, #12]
 80107d4:	6979      	ldr	r1, [r7, #20]
 80107d6:	461a      	mov	r2, r3
 80107d8:	687b      	ldr	r3, [r7, #4]
 80107da:	f7ff ff11 	bl	8010600 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 80107de:	6978      	ldr	r0, [r7, #20]
 80107e0:	f002 fb6e 	bl	8012ec0 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
 80107e4:	f997 101e 	ldrsb.w	r1, [r7, #30]
 80107e8:	f640 52e0 	movw	r2, #3552	; 0xde0
 80107ec:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80107f0:	460b      	mov	r3, r1
 80107f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80107f6:	185b      	adds	r3, r3, r1
 80107f8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80107fc:	18d3      	adds	r3, r2, r3
 80107fe:	681b      	ldr	r3, [r3, #0]
 8010800:	2b00      	cmp	r3, #0
 8010802:	d1be      	bne.n	8010782 <update_arp_entry+0x116>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
 8010804:	f04f 0300 	mov.w	r3, #0
 8010808:	b25b      	sxtb	r3, r3
}
 801080a:	4618      	mov	r0, r3
 801080c:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8010810:	46bd      	mov	sp, r7
 8010812:	bd90      	pop	{r4, r7, pc}

08010814 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
 8010814:	b580      	push	{r7, lr}
 8010816:	b086      	sub	sp, #24
 8010818:	af00      	add	r7, sp, #0
 801081a:	60f8      	str	r0, [r7, #12]
 801081c:	60b9      	str	r1, [r7, #8]
 801081e:	607a      	str	r2, [r7, #4]
 8010820:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
 8010822:	68b8      	ldr	r0, [r7, #8]
 8010824:	f04f 0102 	mov.w	r1, #2
 8010828:	f7ff fcee 	bl	8010208 <find_entry>
 801082c:	4603      	mov	r3, r0
 801082e:	75fb      	strb	r3, [r7, #23]
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
 8010830:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8010834:	2b00      	cmp	r3, #0
 8010836:	db35      	blt.n	80108a4 <etharp_find_addr+0x90>
 8010838:	f997 1017 	ldrsb.w	r1, [r7, #23]
 801083c:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010840:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010844:	460b      	mov	r3, r1
 8010846:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801084a:	185b      	adds	r3, r3, r1
 801084c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010850:	18d3      	adds	r3, r2, r3
 8010852:	f103 0308 	add.w	r3, r3, #8
 8010856:	799b      	ldrb	r3, [r3, #6]
 8010858:	2b02      	cmp	r3, #2
 801085a:	d123      	bne.n	80108a4 <etharp_find_addr+0x90>
      *eth_ret = &arp_table[i].ethaddr;
 801085c:	f997 2017 	ldrsb.w	r2, [r7, #23]
 8010860:	4613      	mov	r3, r2
 8010862:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010866:	189b      	adds	r3, r3, r2
 8010868:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801086c:	f103 0208 	add.w	r2, r3, #8
 8010870:	f640 53e0 	movw	r3, #3552	; 0xde0
 8010874:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010878:	18d2      	adds	r2, r2, r3
 801087a:	687b      	ldr	r3, [r7, #4]
 801087c:	601a      	str	r2, [r3, #0]
      *ip_ret = &arp_table[i].ipaddr;
 801087e:	f997 2017 	ldrsb.w	r2, [r7, #23]
 8010882:	4613      	mov	r3, r2
 8010884:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010888:	189b      	adds	r3, r3, r2
 801088a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801088e:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010892:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010896:	189b      	adds	r3, r3, r2
 8010898:	f103 0204 	add.w	r2, r3, #4
 801089c:	683b      	ldr	r3, [r7, #0]
 801089e:	601a      	str	r2, [r3, #0]
      return i;
 80108a0:	7dfb      	ldrb	r3, [r7, #23]
 80108a2:	e001      	b.n	80108a8 <etharp_find_addr+0x94>
  }
  return -1;
 80108a4:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80108a8:	b25b      	sxtb	r3, r3
}
 80108aa:	4618      	mov	r0, r3
 80108ac:	f107 0718 	add.w	r7, r7, #24
 80108b0:	46bd      	mov	sp, r7
 80108b2:	bd80      	pop	{r7, pc}

080108b4 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
 80108b4:	b580      	push	{r7, lr}
 80108b6:	b084      	sub	sp, #16
 80108b8:	af00      	add	r7, sp, #0
 80108ba:	6078      	str	r0, [r7, #4]
 80108bc:	6039      	str	r1, [r7, #0]
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 80108be:	687b      	ldr	r3, [r7, #4]
 80108c0:	2b00      	cmp	r3, #0
 80108c2:	d01f      	beq.n	8010904 <etharp_ip_input+0x50>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = p->payload;
 80108c4:	683b      	ldr	r3, [r7, #0]
 80108c6:	685b      	ldr	r3, [r3, #4]
 80108c8:	60fb      	str	r3, [r7, #12]
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 80108ca:	68fb      	ldr	r3, [r7, #12]
 80108cc:	f103 030e 	add.w	r3, r3, #14
 80108d0:	60bb      	str	r3, [r7, #8]
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(iphdr->src), &(netif->ip_addr), &(netif->netmask))) {
 80108d2:	68bb      	ldr	r3, [r7, #8]
 80108d4:	68da      	ldr	r2, [r3, #12]
 80108d6:	687b      	ldr	r3, [r7, #4]
 80108d8:	685b      	ldr	r3, [r3, #4]
 80108da:	405a      	eors	r2, r3
 80108dc:	687b      	ldr	r3, [r7, #4]
 80108de:	689b      	ldr	r3, [r3, #8]
 80108e0:	4013      	ands	r3, r2
 80108e2:	2b00      	cmp	r3, #0
 80108e4:	d10d      	bne.n	8010902 <etharp_ip_input+0x4e>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(iphdr->src), &(ethhdr->src), 0);
 80108e6:	68bb      	ldr	r3, [r7, #8]
 80108e8:	f103 020c 	add.w	r2, r3, #12
 80108ec:	68fb      	ldr	r3, [r7, #12]
 80108ee:	f103 0306 	add.w	r3, r3, #6
 80108f2:	6878      	ldr	r0, [r7, #4]
 80108f4:	4611      	mov	r1, r2
 80108f6:	461a      	mov	r2, r3
 80108f8:	f04f 0300 	mov.w	r3, #0
 80108fc:	f7ff feb6 	bl	801066c <update_arp_entry>
 8010900:	e000      	b.n	8010904 <etharp_ip_input+0x50>
#endif /* ETHARP_SUPPORT_VLAN */

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(iphdr->src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
 8010902:	bf00      	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(iphdr->src), &(ethhdr->src), 0);
}
 8010904:	f107 0710 	add.w	r7, r7, #16
 8010908:	46bd      	mov	sp, r7
 801090a:	bd80      	pop	{r7, pc}

0801090c <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
 801090c:	b590      	push	{r4, r7, lr}
 801090e:	b08b      	sub	sp, #44	; 0x2c
 8010910:	af00      	add	r7, sp, #0
 8010912:	60f8      	str	r0, [r7, #12]
 8010914:	60b9      	str	r1, [r7, #8]
 8010916:	607a      	str	r2, [r7, #4]
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 8010918:	68fb      	ldr	r3, [r7, #12]
 801091a:	2b00      	cmp	r3, #0
 801091c:	f000 80e6 	beq.w	8010aec <etharp_arp_input+0x1e0>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
 8010920:	687b      	ldr	r3, [r7, #4]
 8010922:	895b      	ldrh	r3, [r3, #10]
 8010924:	2b29      	cmp	r3, #41	; 0x29
 8010926:	d803      	bhi.n	8010930 <etharp_arp_input+0x24>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
 8010928:	6878      	ldr	r0, [r7, #4]
 801092a:	f002 fac9 	bl	8012ec0 <pbuf_free>
 801092e:	e0dd      	b.n	8010aec <etharp_arp_input+0x1e0>
    return;
  }

  ethhdr = p->payload;
 8010930:	687b      	ldr	r3, [r7, #4]
 8010932:	685b      	ldr	r3, [r3, #4]
 8010934:	623b      	str	r3, [r7, #32]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 8010936:	6a3b      	ldr	r3, [r7, #32]
 8010938:	f103 030e 	add.w	r3, r3, #14
 801093c:	61fb      	str	r3, [r7, #28]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
 801093e:	69fb      	ldr	r3, [r7, #28]
 8010940:	881b      	ldrh	r3, [r3, #0]
 8010942:	b29c      	uxth	r4, r3
 8010944:	f04f 0001 	mov.w	r0, #1
 8010948:	f008 fc06 	bl	8019158 <htons>
 801094c:	4603      	mov	r3, r0
 801094e:	429c      	cmp	r4, r3
 8010950:	d11d      	bne.n	801098e <etharp_arp_input+0x82>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
 8010952:	69fb      	ldr	r3, [r7, #28]
 8010954:	889b      	ldrh	r3, [r3, #4]
 8010956:	b29c      	uxth	r4, r3
 8010958:	f240 6004 	movw	r0, #1540	; 0x604
 801095c:	f008 fbfc 	bl	8019158 <htons>
 8010960:	4603      	mov	r3, r0
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
 8010962:	429c      	cmp	r4, r3
 8010964:	d113      	bne.n	801098e <etharp_arp_input+0x82>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
 8010966:	69fb      	ldr	r3, [r7, #28]
 8010968:	885b      	ldrh	r3, [r3, #2]
 801096a:	b29c      	uxth	r4, r3
 801096c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8010970:	f008 fbf2 	bl	8019158 <htons>
 8010974:	4603      	mov	r3, r0
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
 8010976:	429c      	cmp	r4, r3
 8010978:	d109      	bne.n	801098e <etharp_arp_input+0x82>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (ethhdr->type != htons(ETHTYPE_ARP)))  {
 801097a:	6a3b      	ldr	r3, [r7, #32]
 801097c:	899b      	ldrh	r3, [r3, #12]
 801097e:	b29c      	uxth	r4, r3
 8010980:	f640 0006 	movw	r0, #2054	; 0x806
 8010984:	f008 fbe8 	bl	8019158 <htons>
 8010988:	4603      	mov	r3, r0
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
 801098a:	429c      	cmp	r4, r3
 801098c:	d003      	beq.n	8010996 <etharp_arp_input+0x8a>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), ethhdr->type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
 801098e:	6878      	ldr	r0, [r7, #4]
 8010990:	f002 fa96 	bl	8012ec0 <pbuf_free>
 8010994:	e0aa      	b.n	8010aec <etharp_arp_input+0x1e0>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
 8010996:	69fa      	ldr	r2, [r7, #28]
 8010998:	f107 0318 	add.w	r3, r7, #24
 801099c:	f102 020e 	add.w	r2, r2, #14
 80109a0:	6810      	ldr	r0, [r2, #0]
 80109a2:	6018      	str	r0, [r3, #0]
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
 80109a4:	69fa      	ldr	r2, [r7, #28]
 80109a6:	f107 0314 	add.w	r3, r7, #20
 80109aa:	f102 0218 	add.w	r2, r2, #24
 80109ae:	6810      	ldr	r0, [r2, #0]
 80109b0:	6018      	str	r0, [r3, #0]

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
 80109b2:	68fb      	ldr	r3, [r7, #12]
 80109b4:	685b      	ldr	r3, [r3, #4]
 80109b6:	2b00      	cmp	r3, #0
 80109b8:	d104      	bne.n	80109c4 <etharp_arp_input+0xb8>
    for_us = 0;
 80109ba:	f04f 0300 	mov.w	r3, #0
 80109be:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 80109c2:	e009      	b.n	80109d8 <etharp_arp_input+0xcc>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 80109c4:	697a      	ldr	r2, [r7, #20]
 80109c6:	68fb      	ldr	r3, [r7, #12]
 80109c8:	685b      	ldr	r3, [r3, #4]
 80109ca:	429a      	cmp	r2, r3
 80109cc:	bf14      	ite	ne
 80109ce:	2300      	movne	r3, #0
 80109d0:	2301      	moveq	r3, #1
 80109d2:	b2db      	uxtb	r3, r3
 80109d4:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  }

  /* ARP message directed to us? */
  if (for_us) {
 80109d8:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 80109dc:	2b00      	cmp	r3, #0
 80109de:	d00c      	beq.n	80109fa <etharp_arp_input+0xee>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
 80109e0:	69fb      	ldr	r3, [r7, #28]
 80109e2:	f103 0308 	add.w	r3, r3, #8
 80109e6:	f107 0218 	add.w	r2, r7, #24
 80109ea:	68f8      	ldr	r0, [r7, #12]
 80109ec:	4611      	mov	r1, r2
 80109ee:	461a      	mov	r2, r3
 80109f0:	f04f 0301 	mov.w	r3, #1
 80109f4:	f7ff fe3a 	bl	801066c <update_arp_entry>
 80109f8:	e00b      	b.n	8010a12 <etharp_arp_input+0x106>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
 80109fa:	69fb      	ldr	r3, [r7, #28]
 80109fc:	f103 0308 	add.w	r3, r3, #8
 8010a00:	f107 0218 	add.w	r2, r7, #24
 8010a04:	68f8      	ldr	r0, [r7, #12]
 8010a06:	4611      	mov	r1, r2
 8010a08:	461a      	mov	r2, r3
 8010a0a:	f04f 0300 	mov.w	r3, #0
 8010a0e:	f7ff fe2d 	bl	801066c <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
 8010a12:	69fb      	ldr	r3, [r7, #28]
 8010a14:	88db      	ldrh	r3, [r3, #6]
 8010a16:	b29b      	uxth	r3, r3
 8010a18:	4618      	mov	r0, r3
 8010a1a:	f008 fb9d 	bl	8019158 <htons>
 8010a1e:	4603      	mov	r3, r0
 8010a20:	2b01      	cmp	r3, #1
 8010a22:	d002      	beq.n	8010a2a <etharp_arp_input+0x11e>
 8010a24:	2b02      	cmp	r3, #2
 8010a26:	d05b      	beq.n	8010ae0 <etharp_arp_input+0x1d4>
 8010a28:	e059      	b.n	8010ade <etharp_arp_input+0x1d2>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
 8010a2a:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8010a2e:	2b00      	cmp	r3, #0
 8010a30:	d058      	beq.n	8010ae4 <etharp_arp_input+0x1d8>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
 8010a32:	f04f 0002 	mov.w	r0, #2
 8010a36:	f008 fb8f 	bl	8019158 <htons>
 8010a3a:	4603      	mov	r3, r0
 8010a3c:	461a      	mov	r2, r3
 8010a3e:	69fb      	ldr	r3, [r7, #28]
 8010a40:	80da      	strh	r2, [r3, #6]

      hdr->dipaddr = hdr->sipaddr;
 8010a42:	69fb      	ldr	r3, [r7, #28]
 8010a44:	69fa      	ldr	r2, [r7, #28]
 8010a46:	f103 0318 	add.w	r3, r3, #24
 8010a4a:	f102 020e 	add.w	r2, r2, #14
 8010a4e:	6812      	ldr	r2, [r2, #0]
 8010a50:	601a      	str	r2, [r3, #0]
      SMEMCPY(&hdr->sipaddr, &netif->ip_addr, sizeof(hdr->sipaddr));
 8010a52:	69fb      	ldr	r3, [r7, #28]
 8010a54:	f103 020e 	add.w	r2, r3, #14
 8010a58:	68fb      	ldr	r3, [r7, #12]
 8010a5a:	f103 0304 	add.w	r3, r3, #4
 8010a5e:	4610      	mov	r0, r2
 8010a60:	4619      	mov	r1, r3
 8010a62:	f04f 0204 	mov.w	r2, #4
 8010a66:	f012 fdd5 	bl	8023614 <memcpy>

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
 8010a6a:	f04f 0306 	mov.w	r3, #6
 8010a6e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
 8010a72:	e02a      	b.n	8010aca <etharp_arp_input+0x1be>
        i--;
 8010a74:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010a78:	f103 33ff 	add.w	r3, r3, #4294967295
 8010a7c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
 8010a80:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010a84:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8010a88:	69f9      	ldr	r1, [r7, #28]
 8010a8a:	188a      	adds	r2, r1, r2
 8010a8c:	7a12      	ldrb	r2, [r2, #8]
 8010a8e:	69f9      	ldr	r1, [r7, #28]
 8010a90:	18cb      	adds	r3, r1, r3
 8010a92:	749a      	strb	r2, [r3, #18]
#if LWIP_AUTOIP
        ethhdr->dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        ethhdr->dest.addr[i] = hdr->shwaddr.addr[i];
 8010a94:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010a98:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8010a9c:	69f9      	ldr	r1, [r7, #28]
 8010a9e:	188a      	adds	r2, r1, r2
 8010aa0:	7a11      	ldrb	r1, [r2, #8]
 8010aa2:	6a3a      	ldr	r2, [r7, #32]
 8010aa4:	54d1      	strb	r1, [r2, r3]
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
 8010aa6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010aaa:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8010aae:	68b9      	ldr	r1, [r7, #8]
 8010ab0:	5c8a      	ldrb	r2, [r1, r2]
 8010ab2:	69f9      	ldr	r1, [r7, #28]
 8010ab4:	18cb      	adds	r3, r1, r3
 8010ab6:	721a      	strb	r2, [r3, #8]
        ethhdr->src.addr[i] = ethaddr->addr[i];
 8010ab8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010abc:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8010ac0:	68b9      	ldr	r1, [r7, #8]
 8010ac2:	5c8a      	ldrb	r2, [r1, r2]
 8010ac4:	6a39      	ldr	r1, [r7, #32]
 8010ac6:	18cb      	adds	r3, r1, r3
 8010ac8:	719a      	strb	r2, [r3, #6]
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
 8010aca:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8010ace:	2b00      	cmp	r3, #0
 8010ad0:	d1d0      	bne.n	8010a74 <etharp_arp_input+0x168>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
 8010ad2:	68fb      	ldr	r3, [r7, #12]
 8010ad4:	699b      	ldr	r3, [r3, #24]
 8010ad6:	68f8      	ldr	r0, [r7, #12]
 8010ad8:	6879      	ldr	r1, [r7, #4]
 8010ada:	4798      	blx	r3
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
 8010adc:	e002      	b.n	8010ae4 <etharp_arp_input+0x1d8>
#endif
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
 8010ade:	e002      	b.n	8010ae6 <etharp_arp_input+0x1da>
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
#endif
    break;
 8010ae0:	bf00      	nop
 8010ae2:	e000      	b.n	8010ae6 <etharp_arp_input+0x1da>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
 8010ae4:	bf00      	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
 8010ae6:	6878      	ldr	r0, [r7, #4]
 8010ae8:	f002 f9ea 	bl	8012ec0 <pbuf_free>
}
 8010aec:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 8010af0:	46bd      	mov	sp, r7
 8010af2:	bd90      	pop	{r4, r7, pc}

08010af4 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
 8010af4:	b590      	push	{r4, r7, lr}
 8010af6:	b089      	sub	sp, #36	; 0x24
 8010af8:	af00      	add	r7, sp, #0
 8010afa:	60f8      	str	r0, [r7, #12]
 8010afc:	60b9      	str	r1, [r7, #8]
 8010afe:	607a      	str	r2, [r7, #4]
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 8010b00:	68b8      	ldr	r0, [r7, #8]
 8010b02:	f04f 010e 	mov.w	r1, #14
 8010b06:	f002 f961 	bl	8012dcc <pbuf_header>
 8010b0a:	4603      	mov	r3, r0
 8010b0c:	2b00      	cmp	r3, #0
 8010b0e:	d002      	beq.n	8010b16 <etharp_output+0x22>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
 8010b10:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 8010b14:	e071      	b.n	8010bfa <etharp_output+0x106>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
 8010b16:	f04f 0300 	mov.w	r3, #0
 8010b1a:	61fb      	str	r3, [r7, #28]
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 8010b1c:	6878      	ldr	r0, [r7, #4]
 8010b1e:	68f9      	ldr	r1, [r7, #12]
 8010b20:	f009 f808 	bl	8019b34 <ip_addr_isbroadcast>
 8010b24:	4603      	mov	r3, r0
 8010b26:	2b00      	cmp	r3, #0
 8010b28:	d005      	beq.n	8010b36 <etharp_output+0x42>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
 8010b2a:	f246 73b8 	movw	r3, #26552	; 0x67b8
 8010b2e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8010b32:	61fb      	str	r3, [r7, #28]
 8010b34:	e057      	b.n	8010be6 <etharp_output+0xf2>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
 8010b36:	687b      	ldr	r3, [r7, #4]
 8010b38:	681c      	ldr	r4, [r3, #0]
 8010b3a:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8010b3e:	f008 fb51 	bl	80191e4 <ntohl>
 8010b42:	4603      	mov	r3, r0
 8010b44:	401c      	ands	r4, r3
 8010b46:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8010b4a:	f008 fb4b 	bl	80191e4 <ntohl>
 8010b4e:	4603      	mov	r3, r0
 8010b50:	429c      	cmp	r4, r3
 8010b52:	d12b      	bne.n	8010bac <etharp_output+0xb8>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
 8010b54:	f04f 0301 	mov.w	r3, #1
 8010b58:	753b      	strb	r3, [r7, #20]
    mcastaddr.addr[1] = 0x00;
 8010b5a:	f04f 0300 	mov.w	r3, #0
 8010b5e:	757b      	strb	r3, [r7, #21]
    mcastaddr.addr[2] = 0x5e;
 8010b60:	f04f 035e 	mov.w	r3, #94	; 0x5e
 8010b64:	75bb      	strb	r3, [r7, #22]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 8010b66:	687b      	ldr	r3, [r7, #4]
 8010b68:	681b      	ldr	r3, [r3, #0]
 8010b6a:	4618      	mov	r0, r3
 8010b6c:	f008 fb3a 	bl	80191e4 <ntohl>
 8010b70:	4603      	mov	r3, r0
 8010b72:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8010b76:	b2db      	uxtb	r3, r3
 8010b78:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010b7c:	b2db      	uxtb	r3, r3
 8010b7e:	75fb      	strb	r3, [r7, #23]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 8010b80:	687b      	ldr	r3, [r7, #4]
 8010b82:	681b      	ldr	r3, [r3, #0]
 8010b84:	4618      	mov	r0, r3
 8010b86:	f008 fb2d 	bl	80191e4 <ntohl>
 8010b8a:	4603      	mov	r3, r0
 8010b8c:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8010b90:	b2db      	uxtb	r3, r3
 8010b92:	763b      	strb	r3, [r7, #24]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 8010b94:	687b      	ldr	r3, [r7, #4]
 8010b96:	681b      	ldr	r3, [r3, #0]
 8010b98:	4618      	mov	r0, r3
 8010b9a:	f008 fb23 	bl	80191e4 <ntohl>
 8010b9e:	4603      	mov	r3, r0
 8010ba0:	b2db      	uxtb	r3, r3
 8010ba2:	767b      	strb	r3, [r7, #25]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 8010ba4:	f107 0314 	add.w	r3, r7, #20
 8010ba8:	61fb      	str	r3, [r7, #28]
 8010baa:	e01c      	b.n	8010be6 <etharp_output+0xf2>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
 8010bac:	687b      	ldr	r3, [r7, #4]
 8010bae:	681a      	ldr	r2, [r3, #0]
 8010bb0:	68fb      	ldr	r3, [r7, #12]
 8010bb2:	685b      	ldr	r3, [r3, #4]
 8010bb4:	405a      	eors	r2, r3
 8010bb6:	68fb      	ldr	r3, [r7, #12]
 8010bb8:	689b      	ldr	r3, [r3, #8]
 8010bba:	4013      	ands	r3, r2
 8010bbc:	2b00      	cmp	r3, #0
 8010bbe:	d00b      	beq.n	8010bd8 <etharp_output+0xe4>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
 8010bc0:	68fb      	ldr	r3, [r7, #12]
 8010bc2:	68db      	ldr	r3, [r3, #12]
 8010bc4:	2b00      	cmp	r3, #0
 8010bc6:	d004      	beq.n	8010bd2 <etharp_output+0xde>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
 8010bc8:	68fb      	ldr	r3, [r7, #12]
 8010bca:	f103 030c 	add.w	r3, r3, #12
 8010bce:	607b      	str	r3, [r7, #4]
 8010bd0:	e002      	b.n	8010bd8 <etharp_output+0xe4>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
 8010bd2:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 8010bd6:	e010      	b.n	8010bfa <etharp_output+0x106>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
 8010bd8:	68f8      	ldr	r0, [r7, #12]
 8010bda:	6879      	ldr	r1, [r7, #4]
 8010bdc:	68ba      	ldr	r2, [r7, #8]
 8010bde:	f000 f813 	bl	8010c08 <etharp_query>
 8010be2:	4603      	mov	r3, r0
 8010be4:	e009      	b.n	8010bfa <etharp_output+0x106>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 8010be6:	68fb      	ldr	r3, [r7, #12]
 8010be8:	f103 0323 	add.w	r3, r3, #35	; 0x23
 8010bec:	68f8      	ldr	r0, [r7, #12]
 8010bee:	68b9      	ldr	r1, [r7, #8]
 8010bf0:	461a      	mov	r2, r3
 8010bf2:	69fb      	ldr	r3, [r7, #28]
 8010bf4:	f7ff fd04 	bl	8010600 <etharp_send_ip>
 8010bf8:	4603      	mov	r3, r0
 8010bfa:	b25b      	sxtb	r3, r3
}
 8010bfc:	4618      	mov	r0, r3
 8010bfe:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8010c02:	46bd      	mov	sp, r7
 8010c04:	bd90      	pop	{r4, r7, pc}
 8010c06:	bf00      	nop

08010c08 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
 8010c08:	b590      	push	{r4, r7, lr}
 8010c0a:	b08d      	sub	sp, #52	; 0x34
 8010c0c:	af00      	add	r7, sp, #0
 8010c0e:	60f8      	str	r0, [r7, #12]
 8010c10:	60b9      	str	r1, [r7, #8]
 8010c12:	607a      	str	r2, [r7, #4]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 8010c14:	68fb      	ldr	r3, [r7, #12]
 8010c16:	f103 0323 	add.w	r3, r3, #35	; 0x23
 8010c1a:	61fb      	str	r3, [r7, #28]
  err_t result = ERR_MEM;
 8010c1c:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8010c20:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8010c24:	68b8      	ldr	r0, [r7, #8]
 8010c26:	68f9      	ldr	r1, [r7, #12]
 8010c28:	f008 ff84 	bl	8019b34 <ip_addr_isbroadcast>
 8010c2c:	4603      	mov	r3, r0
 8010c2e:	2b00      	cmp	r3, #0
 8010c30:	d115      	bne.n	8010c5e <etharp_query+0x56>
      ip_addr_ismulticast(ipaddr) ||
 8010c32:	68bb      	ldr	r3, [r7, #8]
 8010c34:	681c      	ldr	r4, [r3, #0]
 8010c36:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8010c3a:	f008 fad3 	bl	80191e4 <ntohl>
 8010c3e:	4603      	mov	r3, r0
 8010c40:	401c      	ands	r4, r3
 8010c42:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8010c46:	f008 facd 	bl	80191e4 <ntohl>
 8010c4a:	4603      	mov	r3, r0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 8010c4c:	429c      	cmp	r4, r3
 8010c4e:	d006      	beq.n	8010c5e <etharp_query+0x56>
      ip_addr_ismulticast(ipaddr) ||
 8010c50:	68bb      	ldr	r3, [r7, #8]
 8010c52:	2b00      	cmp	r3, #0
 8010c54:	d003      	beq.n	8010c5e <etharp_query+0x56>
      ip_addr_isany(ipaddr)) {
 8010c56:	68bb      	ldr	r3, [r7, #8]
 8010c58:	681b      	ldr	r3, [r3, #0]
 8010c5a:	2b00      	cmp	r3, #0
 8010c5c:	d102      	bne.n	8010c64 <etharp_query+0x5c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 8010c5e:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 8010c62:	e13d      	b.n	8010ee0 <etharp_query+0x2d8>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
 8010c64:	68b8      	ldr	r0, [r7, #8]
 8010c66:	f04f 0101 	mov.w	r1, #1
 8010c6a:	f7ff facd 	bl	8010208 <find_entry>
 8010c6e:	4603      	mov	r3, r0
 8010c70:	76fb      	strb	r3, [r7, #27]
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
 8010c72:	f997 301b 	ldrsb.w	r3, [r7, #27]
 8010c76:	2b00      	cmp	r3, #0
 8010c78:	da01      	bge.n	8010c7e <etharp_query+0x76>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
 8010c7a:	7efb      	ldrb	r3, [r7, #27]
 8010c7c:	e130      	b.n	8010ee0 <etharp_query+0x2d8>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 8010c7e:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010c82:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010c86:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010c8a:	460b      	mov	r3, r1
 8010c8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010c90:	185b      	adds	r3, r3, r1
 8010c92:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010c96:	18d3      	adds	r3, r2, r3
 8010c98:	f103 0308 	add.w	r3, r3, #8
 8010c9c:	799b      	ldrb	r3, [r3, #6]
 8010c9e:	2b00      	cmp	r3, #0
 8010ca0:	d111      	bne.n	8010cc6 <etharp_query+0xbe>
    arp_table[i].state = ETHARP_STATE_PENDING;
 8010ca2:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010ca6:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010caa:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010cae:	460b      	mov	r3, r1
 8010cb0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010cb4:	185b      	adds	r3, r3, r1
 8010cb6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010cba:	18d3      	adds	r3, r2, r3
 8010cbc:	f103 0308 	add.w	r3, r3, #8
 8010cc0:	f04f 0201 	mov.w	r2, #1
 8010cc4:	719a      	strb	r2, [r3, #6]
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 8010cc6:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010cca:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010cce:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010cd2:	460b      	mov	r3, r1
 8010cd4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010cd8:	185b      	adds	r3, r3, r1
 8010cda:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010cde:	18d3      	adds	r3, r2, r3
 8010ce0:	f103 0308 	add.w	r3, r3, #8
 8010ce4:	799b      	ldrb	r3, [r3, #6]
 8010ce6:	2b01      	cmp	r3, #1
 8010ce8:	d007      	beq.n	8010cfa <etharp_query+0xf2>
 8010cea:	f997 201b 	ldrsb.w	r2, [r7, #27]
 8010cee:	4613      	mov	r3, r2
 8010cf0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010cf4:	189b      	adds	r3, r3, r2
 8010cf6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 8010cfa:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010cfe:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010d02:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010d06:	460b      	mov	r3, r1
 8010d08:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010d0c:	185b      	adds	r3, r3, r1
 8010d0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010d12:	18d3      	adds	r3, r2, r3
 8010d14:	f103 0308 	add.w	r3, r3, #8
 8010d18:	799b      	ldrb	r3, [r3, #6]
 8010d1a:	2b01      	cmp	r3, #1
 8010d1c:	d002      	beq.n	8010d24 <etharp_query+0x11c>
 8010d1e:	687b      	ldr	r3, [r7, #4]
 8010d20:	2b00      	cmp	r3, #0
 8010d22:	d106      	bne.n	8010d32 <etharp_query+0x12a>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 8010d24:	68f8      	ldr	r0, [r7, #12]
 8010d26:	68b9      	ldr	r1, [r7, #8]
 8010d28:	f000 f96e 	bl	8011008 <etharp_request>
 8010d2c:	4603      	mov	r3, r0
 8010d2e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
 8010d32:	687b      	ldr	r3, [r7, #4]
 8010d34:	2b00      	cmp	r3, #0
 8010d36:	f000 80d1 	beq.w	8010edc <etharp_query+0x2d4>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
 8010d3a:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010d3e:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010d42:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010d46:	460b      	mov	r3, r1
 8010d48:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010d4c:	185b      	adds	r3, r3, r1
 8010d4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010d52:	18d3      	adds	r3, r2, r3
 8010d54:	f103 0308 	add.w	r3, r3, #8
 8010d58:	799b      	ldrb	r3, [r3, #6]
 8010d5a:	2b02      	cmp	r3, #2
 8010d5c:	d117      	bne.n	8010d8e <etharp_query+0x186>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 8010d5e:	f997 201b 	ldrsb.w	r2, [r7, #27]
 8010d62:	4613      	mov	r3, r2
 8010d64:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010d68:	189b      	adds	r3, r3, r2
 8010d6a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010d6e:	f103 0208 	add.w	r2, r3, #8
 8010d72:	f640 53e0 	movw	r3, #3552	; 0xde0
 8010d76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010d7a:	18d3      	adds	r3, r2, r3
 8010d7c:	68f8      	ldr	r0, [r7, #12]
 8010d7e:	6879      	ldr	r1, [r7, #4]
 8010d80:	69fa      	ldr	r2, [r7, #28]
 8010d82:	f7ff fc3d 	bl	8010600 <etharp_send_ip>
 8010d86:	4603      	mov	r3, r0
 8010d88:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010d8c:	e0a6      	b.n	8010edc <etharp_query+0x2d4>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 8010d8e:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010d92:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010d96:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010d9a:	460b      	mov	r3, r1
 8010d9c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010da0:	185b      	adds	r3, r3, r1
 8010da2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010da6:	18d3      	adds	r3, r2, r3
 8010da8:	f103 0308 	add.w	r3, r3, #8
 8010dac:	799b      	ldrb	r3, [r3, #6]
 8010dae:	2b01      	cmp	r3, #1
 8010db0:	f040 8094 	bne.w	8010edc <etharp_query+0x2d4>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
 8010db4:	f04f 0300 	mov.w	r3, #0
 8010db8:	627b      	str	r3, [r7, #36]	; 0x24
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
 8010dba:	687b      	ldr	r3, [r7, #4]
 8010dbc:	62bb      	str	r3, [r7, #40]	; 0x28
      while (p) {
 8010dbe:	e00f      	b.n	8010de0 <etharp_query+0x1d8>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 8010dc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010dc2:	895a      	ldrh	r2, [r3, #10]
 8010dc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010dc6:	891b      	ldrh	r3, [r3, #8]
 8010dc8:	429a      	cmp	r2, r3
        if(p->type != PBUF_ROM) {
 8010dca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010dcc:	7b1b      	ldrb	r3, [r3, #12]
 8010dce:	2b01      	cmp	r3, #1
 8010dd0:	d003      	beq.n	8010dda <etharp_query+0x1d2>
          copy_needed = 1;
 8010dd2:	f04f 0301 	mov.w	r3, #1
 8010dd6:	627b      	str	r3, [r7, #36]	; 0x24
          break;
 8010dd8:	e005      	b.n	8010de6 <etharp_query+0x1de>
        }
        p = p->next;
 8010dda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010ddc:	681b      	ldr	r3, [r3, #0]
 8010dde:	62bb      	str	r3, [r7, #40]	; 0x28
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
 8010de0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010de2:	2b00      	cmp	r3, #0
 8010de4:	d1ec      	bne.n	8010dc0 <etharp_query+0x1b8>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
 8010de6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010de8:	2b00      	cmp	r3, #0
 8010dea:	d01a      	beq.n	8010e22 <etharp_query+0x21a>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 8010dec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010dee:	891b      	ldrh	r3, [r3, #8]
 8010df0:	f04f 0003 	mov.w	r0, #3
 8010df4:	4619      	mov	r1, r3
 8010df6:	f04f 0200 	mov.w	r2, #0
 8010dfa:	f001 fe59 	bl	8012ab0 <pbuf_alloc>
 8010dfe:	62b8      	str	r0, [r7, #40]	; 0x28
        if(p != NULL) {
 8010e00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010e02:	2b00      	cmp	r3, #0
 8010e04:	d012      	beq.n	8010e2c <etharp_query+0x224>
          if (pbuf_copy(p, q) != ERR_OK) {
 8010e06:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010e08:	6879      	ldr	r1, [r7, #4]
 8010e0a:	f002 f947 	bl	801309c <pbuf_copy>
 8010e0e:	4603      	mov	r3, r0
 8010e10:	2b00      	cmp	r3, #0
 8010e12:	d00b      	beq.n	8010e2c <etharp_query+0x224>
            pbuf_free(p);
 8010e14:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010e16:	f002 f853 	bl	8012ec0 <pbuf_free>
            p = NULL;
 8010e1a:	f04f 0300 	mov.w	r3, #0
 8010e1e:	62bb      	str	r3, [r7, #40]	; 0x28
 8010e20:	e004      	b.n	8010e2c <etharp_query+0x224>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
 8010e22:	687b      	ldr	r3, [r7, #4]
 8010e24:	62bb      	str	r3, [r7, #40]	; 0x28
        pbuf_ref(p);
 8010e26:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010e28:	f002 f8b8 	bl	8012f9c <pbuf_ref>
      }
      /* packet could be taken over? */
      if (p != NULL) {
 8010e2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010e2e:	2b00      	cmp	r3, #0
 8010e30:	d054      	beq.n	8010edc <etharp_query+0x2d4>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
 8010e32:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8010e36:	f6c0 0302 	movt	r3, #2050	; 0x802
 8010e3a:	899b      	ldrh	r3, [r3, #12]
 8010e3c:	4618      	mov	r0, r3
 8010e3e:	f001 f967 	bl	8012110 <mem_malloc>
 8010e42:	6178      	str	r0, [r7, #20]
        if (new_entry != NULL) {
 8010e44:	697b      	ldr	r3, [r7, #20]
 8010e46:	2b00      	cmp	r3, #0
 8010e48:	d045      	beq.n	8010ed6 <etharp_query+0x2ce>
          new_entry->next = 0;
 8010e4a:	697b      	ldr	r3, [r7, #20]
 8010e4c:	f04f 0200 	mov.w	r2, #0
 8010e50:	601a      	str	r2, [r3, #0]
          new_entry->p = p;
 8010e52:	697b      	ldr	r3, [r7, #20]
 8010e54:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010e56:	605a      	str	r2, [r3, #4]
          if(arp_table[i].q != NULL) {
 8010e58:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010e5c:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010e60:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010e64:	460b      	mov	r3, r1
 8010e66:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010e6a:	185b      	adds	r3, r3, r1
 8010e6c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010e70:	18d3      	adds	r3, r2, r3
 8010e72:	681b      	ldr	r3, [r3, #0]
 8010e74:	2b00      	cmp	r3, #0
 8010e76:	d01a      	beq.n	8010eae <etharp_query+0x2a6>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
 8010e78:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010e7c:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010e80:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010e84:	460b      	mov	r3, r1
 8010e86:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010e8a:	185b      	adds	r3, r3, r1
 8010e8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010e90:	18d3      	adds	r3, r2, r3
 8010e92:	681b      	ldr	r3, [r3, #0]
 8010e94:	623b      	str	r3, [r7, #32]
            while (r->next != NULL) {
 8010e96:	e002      	b.n	8010e9e <etharp_query+0x296>
              r = r->next;
 8010e98:	6a3b      	ldr	r3, [r7, #32]
 8010e9a:	681b      	ldr	r3, [r3, #0]
 8010e9c:	623b      	str	r3, [r7, #32]
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
 8010e9e:	6a3b      	ldr	r3, [r7, #32]
 8010ea0:	681b      	ldr	r3, [r3, #0]
 8010ea2:	2b00      	cmp	r3, #0
 8010ea4:	d1f8      	bne.n	8010e98 <etharp_query+0x290>
              r = r->next;
            }
            r->next = new_entry;
 8010ea6:	6a3b      	ldr	r3, [r7, #32]
 8010ea8:	697a      	ldr	r2, [r7, #20]
 8010eaa:	601a      	str	r2, [r3, #0]
 8010eac:	e00e      	b.n	8010ecc <etharp_query+0x2c4>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
 8010eae:	f997 101b 	ldrsb.w	r1, [r7, #27]
 8010eb2:	f640 52e0 	movw	r2, #3552	; 0xde0
 8010eb6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8010eba:	460b      	mov	r3, r1
 8010ebc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010ec0:	185b      	adds	r3, r3, r1
 8010ec2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8010ec6:	18d3      	adds	r3, r2, r3
 8010ec8:	697a      	ldr	r2, [r7, #20]
 8010eca:	601a      	str	r2, [r3, #0]
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
 8010ecc:	f04f 0300 	mov.w	r3, #0
 8010ed0:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8010ed4:	e002      	b.n	8010edc <etharp_query+0x2d4>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
 8010ed6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010ed8:	f001 fff2 	bl	8012ec0 <pbuf_free>
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
 8010edc:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8010ee0:	b25b      	sxtb	r3, r3
}
 8010ee2:	4618      	mov	r0, r3
 8010ee4:	f107 0734 	add.w	r7, r7, #52	; 0x34
 8010ee8:	46bd      	mov	sp, r7
 8010eea:	bd90      	pop	{r4, r7, pc}

08010eec <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
 8010eec:	b580      	push	{r7, lr}
 8010eee:	b088      	sub	sp, #32
 8010ef0:	af00      	add	r7, sp, #0
 8010ef2:	60f8      	str	r0, [r7, #12]
 8010ef4:	60b9      	str	r1, [r7, #8]
 8010ef6:	607a      	str	r2, [r7, #4]
 8010ef8:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  err_t result = ERR_OK;
 8010efa:	f04f 0300 	mov.w	r3, #0
 8010efe:	77bb      	strb	r3, [r7, #30]
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 8010f00:	f04f 0003 	mov.w	r0, #3
 8010f04:	f04f 012a 	mov.w	r1, #42	; 0x2a
 8010f08:	f04f 0200 	mov.w	r2, #0
 8010f0c:	f001 fdd0 	bl	8012ab0 <pbuf_alloc>
 8010f10:	61b8      	str	r0, [r7, #24]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 8010f12:	69bb      	ldr	r3, [r7, #24]
 8010f14:	2b00      	cmp	r3, #0
 8010f16:	d102      	bne.n	8010f1e <etharp_raw+0x32>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
 8010f18:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8010f1c:	e06e      	b.n	8010ffc <etharp_raw+0x110>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = p->payload;
 8010f1e:	69bb      	ldr	r3, [r7, #24]
 8010f20:	685b      	ldr	r3, [r3, #4]
 8010f22:	617b      	str	r3, [r7, #20]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 8010f24:	697b      	ldr	r3, [r7, #20]
 8010f26:	f103 030e 	add.w	r3, r3, #14
 8010f2a:	613b      	str	r3, [r7, #16]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 8010f2c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8010f2e:	4618      	mov	r0, r3
 8010f30:	f008 f912 	bl	8019158 <htons>
 8010f34:	4603      	mov	r3, r0
 8010f36:	461a      	mov	r2, r3
 8010f38:	693b      	ldr	r3, [r7, #16]
 8010f3a:	80da      	strh	r2, [r3, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
 8010f3c:	f04f 0306 	mov.w	r3, #6
 8010f40:	77fb      	strb	r3, [r7, #31]
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
 8010f42:	e01e      	b.n	8010f82 <etharp_raw+0x96>
    k--;
 8010f44:	7ffb      	ldrb	r3, [r7, #31]
 8010f46:	f103 33ff 	add.w	r3, r3, #4294967295
 8010f4a:	77fb      	strb	r3, [r7, #31]
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
 8010f4c:	7ffb      	ldrb	r3, [r7, #31]
 8010f4e:	7ffa      	ldrb	r2, [r7, #31]
 8010f50:	6839      	ldr	r1, [r7, #0]
 8010f52:	5c8a      	ldrb	r2, [r1, r2]
 8010f54:	6939      	ldr	r1, [r7, #16]
 8010f56:	18cb      	adds	r3, r1, r3
 8010f58:	721a      	strb	r2, [r3, #8]
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
 8010f5a:	7ffb      	ldrb	r3, [r7, #31]
 8010f5c:	7ffa      	ldrb	r2, [r7, #31]
 8010f5e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8010f60:	5c8a      	ldrb	r2, [r1, r2]
 8010f62:	6939      	ldr	r1, [r7, #16]
 8010f64:	18cb      	adds	r3, r1, r3
 8010f66:	749a      	strb	r2, [r3, #18]
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    ethhdr->dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    ethhdr->dest.addr[k] = ethdst_addr->addr[k];
 8010f68:	7ffb      	ldrb	r3, [r7, #31]
 8010f6a:	7ffa      	ldrb	r2, [r7, #31]
 8010f6c:	6879      	ldr	r1, [r7, #4]
 8010f6e:	5c89      	ldrb	r1, [r1, r2]
 8010f70:	697a      	ldr	r2, [r7, #20]
 8010f72:	54d1      	strb	r1, [r2, r3]
#endif /* LWIP_AUTOIP */
    ethhdr->src.addr[k]  = ethsrc_addr->addr[k];
 8010f74:	7ffb      	ldrb	r3, [r7, #31]
 8010f76:	7ffa      	ldrb	r2, [r7, #31]
 8010f78:	68b9      	ldr	r1, [r7, #8]
 8010f7a:	5c8a      	ldrb	r2, [r1, r2]
 8010f7c:	6979      	ldr	r1, [r7, #20]
 8010f7e:	18cb      	adds	r3, r1, r3
 8010f80:	719a      	strb	r2, [r3, #6]
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
 8010f82:	7ffb      	ldrb	r3, [r7, #31]
 8010f84:	2b00      	cmp	r3, #0
 8010f86:	d1dd      	bne.n	8010f44 <etharp_raw+0x58>
#else  /* LWIP_AUTOIP */
    ethhdr->dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    ethhdr->src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
 8010f88:	693b      	ldr	r3, [r7, #16]
 8010f8a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8010f8c:	f103 0318 	add.w	r3, r3, #24
 8010f90:	6812      	ldr	r2, [r2, #0]
 8010f92:	601a      	str	r2, [r3, #0]
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
 8010f94:	693b      	ldr	r3, [r7, #16]
 8010f96:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010f98:	f103 030e 	add.w	r3, r3, #14
 8010f9c:	6812      	ldr	r2, [r2, #0]
 8010f9e:	601a      	str	r2, [r3, #0]
  

  hdr->hwtype = htons(HWTYPE_ETHERNET);
 8010fa0:	f04f 0001 	mov.w	r0, #1
 8010fa4:	f008 f8d8 	bl	8019158 <htons>
 8010fa8:	4603      	mov	r3, r0
 8010faa:	461a      	mov	r2, r3
 8010fac:	693b      	ldr	r3, [r7, #16]
 8010fae:	801a      	strh	r2, [r3, #0]
  hdr->proto = htons(ETHTYPE_IP);
 8010fb0:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8010fb4:	f008 f8d0 	bl	8019158 <htons>
 8010fb8:	4603      	mov	r3, r0
 8010fba:	461a      	mov	r2, r3
 8010fbc:	693b      	ldr	r3, [r7, #16]
 8010fbe:	805a      	strh	r2, [r3, #2]
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
 8010fc0:	f240 6004 	movw	r0, #1540	; 0x604
 8010fc4:	f008 f8c8 	bl	8019158 <htons>
 8010fc8:	4603      	mov	r3, r0
 8010fca:	461a      	mov	r2, r3
 8010fcc:	693b      	ldr	r3, [r7, #16]
 8010fce:	809a      	strh	r2, [r3, #4]

  ethhdr->type = htons(ETHTYPE_ARP);
 8010fd0:	f640 0006 	movw	r0, #2054	; 0x806
 8010fd4:	f008 f8c0 	bl	8019158 <htons>
 8010fd8:	4603      	mov	r3, r0
 8010fda:	461a      	mov	r2, r3
 8010fdc:	697b      	ldr	r3, [r7, #20]
 8010fde:	819a      	strh	r2, [r3, #12]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 8010fe0:	68fb      	ldr	r3, [r7, #12]
 8010fe2:	699b      	ldr	r3, [r3, #24]
 8010fe4:	68f8      	ldr	r0, [r7, #12]
 8010fe6:	69b9      	ldr	r1, [r7, #24]
 8010fe8:	4798      	blx	r3
 8010fea:	4603      	mov	r3, r0
 8010fec:	77bb      	strb	r3, [r7, #30]
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 8010fee:	69b8      	ldr	r0, [r7, #24]
 8010ff0:	f001 ff66 	bl	8012ec0 <pbuf_free>
  p = NULL;
 8010ff4:	f04f 0300 	mov.w	r3, #0
 8010ff8:	61bb      	str	r3, [r7, #24]
  /* could not allocate pbuf for ARP request */

  return result;
 8010ffa:	7fbb      	ldrb	r3, [r7, #30]
 8010ffc:	b25b      	sxtb	r3, r3
}
 8010ffe:	4618      	mov	r0, r3
 8011000:	f107 0720 	add.w	r7, r7, #32
 8011004:	46bd      	mov	sp, r7
 8011006:	bd80      	pop	{r7, pc}

08011008 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
 8011008:	b590      	push	{r4, r7, lr}
 801100a:	b087      	sub	sp, #28
 801100c:	af04      	add	r7, sp, #16
 801100e:	6078      	str	r0, [r7, #4]
 8011010:	6039      	str	r1, [r7, #0]
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8011012:	687b      	ldr	r3, [r7, #4]
 8011014:	f103 0223 	add.w	r2, r3, #35	; 0x23
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 8011018:	687b      	ldr	r3, [r7, #4]
 801101a:	f103 0423 	add.w	r4, r3, #35	; 0x23
 801101e:	687b      	ldr	r3, [r7, #4]
 8011020:	f103 0304 	add.w	r3, r3, #4
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 8011024:	9300      	str	r3, [sp, #0]
 8011026:	f246 73c0 	movw	r3, #26560	; 0x67c0
 801102a:	f6c0 0302 	movt	r3, #2050	; 0x802
 801102e:	9301      	str	r3, [sp, #4]
 8011030:	683b      	ldr	r3, [r7, #0]
 8011032:	9302      	str	r3, [sp, #8]
 8011034:	f04f 0301 	mov.w	r3, #1
 8011038:	9303      	str	r3, [sp, #12]
 801103a:	6878      	ldr	r0, [r7, #4]
 801103c:	4611      	mov	r1, r2
 801103e:	f246 72b8 	movw	r2, #26552	; 0x67b8
 8011042:	f6c0 0202 	movt	r2, #2050	; 0x802
 8011046:	4623      	mov	r3, r4
 8011048:	f7ff ff50 	bl	8010eec <etharp_raw>
 801104c:	4603      	mov	r3, r0
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 801104e:	4618      	mov	r0, r3
 8011050:	f107 070c 	add.w	r7, r7, #12
 8011054:	46bd      	mov	sp, r7
 8011056:	bd90      	pop	{r4, r7, pc}

08011058 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 8011058:	b580      	push	{r7, lr}
 801105a:	b084      	sub	sp, #16
 801105c:	af00      	add	r7, sp, #0
 801105e:	6078      	str	r0, [r7, #4]
 8011060:	6039      	str	r1, [r7, #0]
  struct eth_hdr* ethhdr;
  u16_t type;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
 8011062:	687b      	ldr	r3, [r7, #4]
 8011064:	685b      	ldr	r3, [r3, #4]
 8011066:	60fb      	str	r3, [r7, #12]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = htons(ethhdr->type);
 8011068:	68fb      	ldr	r3, [r7, #12]
 801106a:	899b      	ldrh	r3, [r3, #12]
 801106c:	b29b      	uxth	r3, r3
 801106e:	4618      	mov	r0, r3
 8011070:	f008 f872 	bl	8019158 <htons>
 8011074:	4603      	mov	r3, r0
 8011076:	817b      	strh	r3, [r7, #10]
#endif /* ETHARP_VLAN_CHECK */
    type = htons(vlan->tpid);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  switch (type) {
 8011078:	897b      	ldrh	r3, [r7, #10]
 801107a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 801107e:	d004      	beq.n	801108a <ethernet_input+0x32>
 8011080:	f640 0206 	movw	r2, #2054	; 0x806
 8011084:	4293      	cmp	r3, r2
 8011086:	d018      	beq.n	80110ba <ethernet_input+0x62>
 8011088:	e020      	b.n	80110cc <ethernet_input+0x74>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
 801108a:	6838      	ldr	r0, [r7, #0]
 801108c:	6879      	ldr	r1, [r7, #4]
 801108e:	f7ff fc11 	bl	80108b4 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)SIZEOF_ETH_HDR)) {
 8011092:	6878      	ldr	r0, [r7, #4]
 8011094:	f06f 010d 	mvn.w	r1, #13
 8011098:	f001 fe98 	bl	8012dcc <pbuf_header>
 801109c:	4603      	mov	r3, r0
 801109e:	2b00      	cmp	r3, #0
 80110a0:	d006      	beq.n	80110b0 <ethernet_input+0x58>
        LWIP_ASSERT("Can't move over header in packet", 0);
        pbuf_free(p);
 80110a2:	6878      	ldr	r0, [r7, #4]
 80110a4:	f001 ff0c 	bl	8012ec0 <pbuf_free>
        p = NULL;
 80110a8:	f04f 0300 	mov.w	r3, #0
 80110ac:	607b      	str	r3, [r7, #4]
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
      }
      break;
 80110ae:	e014      	b.n	80110da <ethernet_input+0x82>
        LWIP_ASSERT("Can't move over header in packet", 0);
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
 80110b0:	6878      	ldr	r0, [r7, #4]
 80110b2:	6839      	ldr	r1, [r7, #0]
 80110b4:	f008 fa5a 	bl	801956c <ip_input>
      }
      break;
 80110b8:	e00f      	b.n	80110da <ethernet_input+0x82>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 80110ba:	683b      	ldr	r3, [r7, #0]
 80110bc:	f103 0323 	add.w	r3, r3, #35	; 0x23
 80110c0:	6838      	ldr	r0, [r7, #0]
 80110c2:	4619      	mov	r1, r3
 80110c4:	687a      	ldr	r2, [r7, #4]
 80110c6:	f7ff fc21 	bl	801090c <etharp_arp_input>
      break;
 80110ca:	e006      	b.n	80110da <ethernet_input+0x82>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
 80110cc:	6878      	ldr	r0, [r7, #4]
 80110ce:	f001 fef7 	bl	8012ec0 <pbuf_free>
      p = NULL;
 80110d2:	f04f 0300 	mov.w	r3, #0
 80110d6:	607b      	str	r3, [r7, #4]
      break;
 80110d8:	bf00      	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
 80110da:	f04f 0300 	mov.w	r3, #0
 80110de:	b25b      	sxtb	r3, r3
}
 80110e0:	4618      	mov	r0, r3
 80110e2:	f107 0710 	add.w	r7, r7, #16
 80110e6:	46bd      	mov	sp, r7
 80110e8:	bd80      	pop	{r7, pc}
 80110ea:	bf00      	nop

080110ec <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
 80110ec:	b580      	push	{r7, lr}
 80110ee:	b086      	sub	sp, #24
 80110f0:	af00      	add	r7, sp, #0
 80110f2:	6078      	str	r0, [r7, #4]
  /* <<<DD_LWIP_PORT_2_1>>> */
  status_t Status = DAVEApp_SUCCESS;
 80110f4:	f04f 0300 	mov.w	r3, #0
 80110f8:	617b      	str	r3, [r7, #20]
  Eth_IoctlParamType GetMacParams;

  GetMacParams.Address = (uint32_t) netif->hwaddr;
 80110fa:	687b      	ldr	r3, [r7, #4]
 80110fc:	f103 0323 	add.w	r3, r3, #35	; 0x23
 8011100:	60fb      	str	r3, [r7, #12]

  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 8011102:	687b      	ldr	r3, [r7, #4]
 8011104:	f04f 0206 	mov.w	r2, #6
 8011108:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
 801110c:	687b      	ldr	r3, [r7, #4]
 801110e:	f04f 0232 	mov.w	r2, #50	; 0x32
 8011112:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29

  /* maximum transfer unit */
  netif->mtu = MAX_MTU_SIZE;
 8011116:	687b      	ldr	r3, [r7, #4]
 8011118:	f240 52dc 	movw	r2, #1500	; 0x5dc
 801111c:	841a      	strh	r2, [r3, #32]

  /* Do whatever else is needed to initialize interface. */
  Status = Eth_InitNetworkInterface();
 801111e:	f00c fb67 	bl	801d7f0 <Eth_InitNetworkInterface>
 8011122:	6178      	str	r0, [r7, #20]
  if (Status != DAVEApp_SUCCESS)
  {
	  DBG002_ERROR(GID_LWIP, lwIP_INIT_ERROR, 0, NULL);
  }
  Status = Eth_OpenNetworkInterface();
 8011124:	f00c fbd6 	bl	801d8d4 <Eth_OpenNetworkInterface>
 8011128:	6178      	str	r0, [r7, #20]
  if (Status != DAVEApp_SUCCESS)
  {
    DBG002_ERROR(GID_LWIP, lwIP_INIT_ERROR, 0, NULL);
  }
  /* Get MAC hardware address */
  Status = Eth_PerformIoctl(IOCTL_GET_MAC_ADDRESS, &GetMacParams);
 801112a:	f107 0308 	add.w	r3, r7, #8
 801112e:	f04f 0008 	mov.w	r0, #8
 8011132:	4619      	mov	r1, r3
 8011134:	f00d f938 	bl	801e3a8 <Eth_PerformIoctl>
 8011138:	6178      	str	r0, [r7, #20]
  if (Status != DAVEApp_SUCCESS)
  {
    DBG002_ERROR(GID_LWIP, lwIP_INIT_ERROR, 0, NULL);
  }
  return;
}
 801113a:	f107 0718 	add.w	r7, r7, #24
 801113e:	46bd      	mov	sp, r7
 8011140:	bd80      	pop	{r7, pc}
 8011142:	bf00      	nop

08011144 <low_level_output>:
 *       dropped because of memory failure (except for the TCP timers).
 */
extern status_t Eth_GetTxBuffer(uint8_t** Buffer);
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
 8011144:	b580      	push	{r7, lr}
 8011146:	b088      	sub	sp, #32
 8011148:	af00      	add	r7, sp, #0
 801114a:	6078      	str	r0, [r7, #4]
 801114c:	6039      	str	r1, [r7, #0]
  /* <<<DD_LWIP_PORT_3_1>>> */
  /* struct ethernetif *ethernetif = netif->state; */
  struct pbuf *q;
  status_t Status = lwIP_INIT_ERROR;
 801114e:	f04f 0301 	mov.w	r3, #1
 8011152:	617b      	str	r3, [r7, #20]
  uint8_t* GetBuffer;
  uint8_t* Temp;
  uint32_t TxLength;
  q=p;
 8011154:	683b      	ldr	r3, [r7, #0]
 8011156:	61fb      	str	r3, [r7, #28]
  TxLength = q->tot_len;
 8011158:	69fb      	ldr	r3, [r7, #28]
 801115a:	891b      	ldrh	r3, [r3, #8]
 801115c:	613b      	str	r3, [r7, #16]

  Eth_GetTxBuffer(&GetBuffer);
 801115e:	f107 030c 	add.w	r3, r7, #12
 8011162:	4618      	mov	r0, r3
 8011164:	f00c fb2e 	bl	801d7c4 <Eth_GetTxBuffer>
  Temp = GetBuffer;
 8011168:	68fb      	ldr	r3, [r7, #12]
 801116a:	61bb      	str	r3, [r7, #24]
#if ETH_PAD_SIZE
  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif
  if(TxLength > 1500)
 801116c:	693a      	ldr	r2, [r7, #16]
 801116e:	f240 53dc 	movw	r3, #1500	; 0x5dc
 8011172:	429a      	cmp	r2, r3
 8011174:	d903      	bls.n	801117e <low_level_output+0x3a>
  {
    TxLength = 0;    
 8011176:	f04f 0300 	mov.w	r3, #0
 801117a:	613b      	str	r3, [r7, #16]
 801117c:	e01c      	b.n	80111b8 <low_level_output+0x74>
  }
  else
  {
    for(q = p; q != NULL; q = q->next)
 801117e:	683b      	ldr	r3, [r7, #0]
 8011180:	61fb      	str	r3, [r7, #28]
 8011182:	e010      	b.n	80111a6 <low_level_output+0x62>
    {
  
      /* Send the data from the pbuf to the interface, one pbuf at a
         time. The size of the data in each pbuf is kept in the ->len
         variable. */
        memcpy(Temp,q->payload,q->len);
 8011184:	69fb      	ldr	r3, [r7, #28]
 8011186:	685a      	ldr	r2, [r3, #4]
 8011188:	69fb      	ldr	r3, [r7, #28]
 801118a:	895b      	ldrh	r3, [r3, #10]
 801118c:	69b8      	ldr	r0, [r7, #24]
 801118e:	4611      	mov	r1, r2
 8011190:	461a      	mov	r2, r3
 8011192:	f012 fa3f 	bl	8023614 <memcpy>
        Temp += q->len;
 8011196:	69fb      	ldr	r3, [r7, #28]
 8011198:	895b      	ldrh	r3, [r3, #10]
 801119a:	69ba      	ldr	r2, [r7, #24]
 801119c:	18d3      	adds	r3, r2, r3
 801119e:	61bb      	str	r3, [r7, #24]
  {
    TxLength = 0;    
  }
  else
  {
    for(q = p; q != NULL; q = q->next)
 80111a0:	69fb      	ldr	r3, [r7, #28]
 80111a2:	681b      	ldr	r3, [r3, #0]
 80111a4:	61fb      	str	r3, [r7, #28]
 80111a6:	69fb      	ldr	r3, [r7, #28]
 80111a8:	2b00      	cmp	r3, #0
 80111aa:	d1eb      	bne.n	8011184 <low_level_output+0x40>
         time. The size of the data in each pbuf is kept in the ->len
         variable. */
        memcpy(Temp,q->payload,q->len);
        Temp += q->len;
    }
    Status = Eth_TransmitFrames(GetBuffer, TxLength);
 80111ac:	68fb      	ldr	r3, [r7, #12]
 80111ae:	4618      	mov	r0, r3
 80111b0:	6939      	ldr	r1, [r7, #16]
 80111b2:	f00c fd85 	bl	801dcc0 <Eth_TransmitFrames>
 80111b6:	6178      	str	r0, [r7, #20]
  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif
  
  LINK_STATS_INC(link.xmit);

  return ERR_OK;
 80111b8:	f04f 0300 	mov.w	r3, #0
 80111bc:	b25b      	sxtb	r3, r3
}
 80111be:	4618      	mov	r0, r3
 80111c0:	f107 0720 	add.w	r7, r7, #32
 80111c4:	46bd      	mov	sp, r7
 80111c6:	bd80      	pop	{r7, pc}

080111c8 <lwip_Input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void lwip_Input(unsigned char *PacketBuffer, uint32_t PacketLength)
{
 80111c8:	b580      	push	{r7, lr}
 80111ca:	b086      	sub	sp, #24
 80111cc:	af00      	add	r7, sp, #0
 80111ce:	6078      	str	r0, [r7, #4]
 80111d0:	6039      	str	r1, [r7, #0]
  /* <<<DD_LWIP_PORT_4_1>>> */
  struct pbuf *p, *q;
  uint32_t Length =0;
 80111d2:	f04f 0300 	mov.w	r3, #0
 80111d6:	613b      	str	r3, [r7, #16]
  struct eth_hdr *ethhdr;

  /* We allocate a pbuf chain of pbufs from the pool. */
  p = pbuf_alloc(PBUF_RAW, PacketLength, PBUF_POOL);
 80111d8:	683b      	ldr	r3, [r7, #0]
 80111da:	b29b      	uxth	r3, r3
 80111dc:	f04f 0003 	mov.w	r0, #3
 80111e0:	4619      	mov	r1, r3
 80111e2:	f04f 0203 	mov.w	r2, #3
 80111e6:	f001 fc63 	bl	8012ab0 <pbuf_alloc>
 80111ea:	60f8      	str	r0, [r7, #12]

  if (p != NULL)
 80111ec:	68fb      	ldr	r3, [r7, #12]
 80111ee:	2b00      	cmp	r3, #0
 80111f0:	d049      	beq.n	8011286 <lwip_Input+0xbe>
  {
	for (q = p; q != NULL; q = q->next)
 80111f2:	68fb      	ldr	r3, [r7, #12]
 80111f4:	617b      	str	r3, [r7, #20]
 80111f6:	e013      	b.n	8011220 <lwip_Input+0x58>
	{
	  memcpy((u8_t*)q->payload, (u8_t*)&PacketBuffer[Length], q->len);
 80111f8:	697b      	ldr	r3, [r7, #20]
 80111fa:	6859      	ldr	r1, [r3, #4]
 80111fc:	687a      	ldr	r2, [r7, #4]
 80111fe:	693b      	ldr	r3, [r7, #16]
 8011200:	18d2      	adds	r2, r2, r3
 8011202:	697b      	ldr	r3, [r7, #20]
 8011204:	895b      	ldrh	r3, [r3, #10]
 8011206:	4608      	mov	r0, r1
 8011208:	4611      	mov	r1, r2
 801120a:	461a      	mov	r2, r3
 801120c:	f012 fa02 	bl	8023614 <memcpy>
	  Length = Length + q->len;
 8011210:	697b      	ldr	r3, [r7, #20]
 8011212:	895b      	ldrh	r3, [r3, #10]
 8011214:	693a      	ldr	r2, [r7, #16]
 8011216:	18d3      	adds	r3, r2, r3
 8011218:	613b      	str	r3, [r7, #16]
  /* We allocate a pbuf chain of pbufs from the pool. */
  p = pbuf_alloc(PBUF_RAW, PacketLength, PBUF_POOL);

  if (p != NULL)
  {
	for (q = p; q != NULL; q = q->next)
 801121a:	697b      	ldr	r3, [r7, #20]
 801121c:	681b      	ldr	r3, [r3, #0]
 801121e:	617b      	str	r3, [r7, #20]
 8011220:	697b      	ldr	r3, [r7, #20]
 8011222:	2b00      	cmp	r3, #0
 8011224:	d1e8      	bne.n	80111f8 <lwip_Input+0x30>
	  DBG002_ERROR(GID_LWIP, lwIP_OUT_OF_MEM, 0, NULL);
	  return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
 8011226:	68fb      	ldr	r3, [r7, #12]
 8011228:	685b      	ldr	r3, [r3, #4]
 801122a:	60bb      	str	r3, [r7, #8]

  switch (htons(ethhdr->type))
 801122c:	68bb      	ldr	r3, [r7, #8]
 801122e:	899b      	ldrh	r3, [r3, #12]
 8011230:	b29b      	uxth	r3, r3
 8011232:	4618      	mov	r0, r3
 8011234:	f007 ff90 	bl	8019158 <htons>
 8011238:	4603      	mov	r3, r0
 801123a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 801123e:	d003      	beq.n	8011248 <lwip_Input+0x80>
 8011240:	f640 0206 	movw	r2, #2054	; 0x806
 8011244:	4293      	cmp	r3, r2
 8011246:	d114      	bne.n	8011272 <lwip_Input+0xaa>
    case ETHTYPE_PPPOEDISC:
    case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */

    /* full packet send to tcpip_thread to process */
    if ((&(netif))->input(p, &netif) != ERR_OK)
 8011248:	f246 5310 	movw	r3, #25872	; 0x6510
 801124c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011250:	691b      	ldr	r3, [r3, #16]
 8011252:	68f8      	ldr	r0, [r7, #12]
 8011254:	f246 5110 	movw	r1, #25872	; 0x6510
 8011258:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801125c:	4798      	blx	r3
 801125e:	4603      	mov	r3, r0
 8011260:	2b00      	cmp	r3, #0
 8011262:	d00d      	beq.n	8011280 <lwip_Input+0xb8>
    {
      LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
      pbuf_free(p);
 8011264:	68f8      	ldr	r0, [r7, #12]
 8011266:	f001 fe2b 	bl	8012ec0 <pbuf_free>
      p = NULL;
 801126a:	f04f 0300 	mov.w	r3, #0
 801126e:	60fb      	str	r3, [r7, #12]
    }
    break;
 8011270:	e006      	b.n	8011280 <lwip_Input+0xb8>

    default:
    {
      pbuf_free(p);
 8011272:	68f8      	ldr	r0, [r7, #12]
 8011274:	f001 fe24 	bl	8012ec0 <pbuf_free>
      p = NULL;
 8011278:	f04f 0300 	mov.w	r3, #0
 801127c:	60fb      	str	r3, [r7, #12]
      break;
 801127e:	e000      	b.n	8011282 <lwip_Input+0xba>
    {
      LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
      pbuf_free(p);
      p = NULL;
    }
    break;
 8011280:	bf00      	nop
      p = NULL;
      break;
    }
  }/* End switch */

  return;
 8011282:	bf00      	nop
 8011284:	e000      	b.n	8011288 <lwip_Input+0xc0>
	}
  }
  else
  {
	  DBG002_ERROR(GID_LWIP, lwIP_OUT_OF_MEM, 0, NULL);
	  return;
 8011286:	bf00      	nop
      break;
    }
  }/* End switch */

  return;
}
 8011288:	f107 0718 	add.w	r7, r7, #24
 801128c:	46bd      	mov	sp, r7
 801128e:	bd80      	pop	{r7, pc}

08011290 <ethernetif_init>:
 * This function is used to initialize the netif structure. It initializes the
 * ethernet lld.
 */
err_t
ethernetif_init(struct netif *netif)
{
 8011290:	b580      	push	{r7, lr}
 8011292:	b084      	sub	sp, #16
 8011294:	af00      	add	r7, sp, #0
 8011296:	6078      	str	r0, [r7, #4]
	/* <<<DD_LWIP_PORT_5_1>>> */
	  struct ethernetif *ethernetif;

	  LWIP_ASSERT("netif != NULL", (netif != NULL));

	  ethernetif = mem_malloc(sizeof(struct ethernetif));
 8011298:	f04f 0004 	mov.w	r0, #4
 801129c:	f000 ff38 	bl	8012110 <mem_malloc>
 80112a0:	60f8      	str	r0, [r7, #12]

	  if (ethernetif == NULL)
 80112a2:	68fb      	ldr	r3, [r7, #12]
 80112a4:	2b00      	cmp	r3, #0
 80112a6:	d102      	bne.n	80112ae <ethernetif_init+0x1e>
	  {
	    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
	    return ERR_MEM;
 80112a8:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80112ac:	e022      	b.n	80112f4 <ethernetif_init+0x64>
	   */
	  //todo:to be moved to proper place
	#define LINK_SPEED_OF_YOUR_NETIF_IN_BPS 10000000
	  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

	  netif->state = ethernetif;
 80112ae:	687b      	ldr	r3, [r7, #4]
 80112b0:	68fa      	ldr	r2, [r7, #12]
 80112b2:	61da      	str	r2, [r3, #28]
	  netif->name[0] = IFNAME0;
 80112b4:	687b      	ldr	r3, [r7, #4]
 80112b6:	f04f 0265 	mov.w	r2, #101	; 0x65
 80112ba:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
	  netif->name[1] = IFNAME1;
 80112be:	687b      	ldr	r3, [r7, #4]
 80112c0:	f04f 026e 	mov.w	r2, #110	; 0x6e
 80112c4:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b

	  /* We directly use etharp_output() here to save a function call.
	   * You can instead declare your own function an call etharp_output()
	   * from it if you have to do some checks before sending (e.g. if link
	   * is available...) */
	  netif->output = etharp_output;
 80112c8:	687a      	ldr	r2, [r7, #4]
 80112ca:	f640 23f5 	movw	r3, #2805	; 0xaf5
 80112ce:	f6c0 0301 	movt	r3, #2049	; 0x801
 80112d2:	6153      	str	r3, [r2, #20]
	  netif->linkoutput = low_level_output;
 80112d4:	687a      	ldr	r2, [r7, #4]
 80112d6:	f241 1345 	movw	r3, #4421	; 0x1145
 80112da:	f6c0 0301 	movt	r3, #2049	; 0x801
 80112de:	6193      	str	r3, [r2, #24]
	  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
 80112e0:	687b      	ldr	r3, [r7, #4]
 80112e2:	f103 0223 	add.w	r2, r3, #35	; 0x23
 80112e6:	68fb      	ldr	r3, [r7, #12]
 80112e8:	601a      	str	r2, [r3, #0]

	  /* initialize the hardware */
	  low_level_init(netif);
 80112ea:	6878      	ldr	r0, [r7, #4]
 80112ec:	f7ff fefe 	bl	80110ec <low_level_init>

	  return ERR_OK;
 80112f0:	f04f 0300 	mov.w	r3, #0
 80112f4:	b25b      	sxtb	r3, r3
}
 80112f6:	4618      	mov	r0, r3
 80112f8:	f107 0710 	add.w	r7, r7, #16
 80112fc:	46bd      	mov	sp, r7
 80112fe:	bd80      	pop	{r7, pc}

08011300 <Eth_Received_Data_Handler>:
/*
 * This handler function is used to handle the Ethernet Packet. Here the Packet
 * is passed to the lwIP stack
 */
void Eth_Received_Data_Handler(uint32_t PacketBuffer, uint32_t PacketLength)
{
 8011300:	b580      	push	{r7, lr}
 8011302:	b082      	sub	sp, #8
 8011304:	af00      	add	r7, sp, #0
 8011306:	6078      	str	r0, [r7, #4]
 8011308:	6039      	str	r1, [r7, #0]
	 lwip_Input((u8*)PacketBuffer, PacketLength);
 801130a:	687b      	ldr	r3, [r7, #4]
 801130c:	4618      	mov	r0, r3
 801130e:	6839      	ldr	r1, [r7, #0]
 8011310:	f7ff ff5a 	bl	80111c8 <lwip_Input>

}
 8011314:	f107 0708 	add.w	r7, r7, #8
 8011318:	46bd      	mov	sp, r7
 801131a:	bd80      	pop	{r7, pc}

0801131c <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (DNS_SERVER_ADDRESS).
 */
void
dns_init()
{
 801131c:	b580      	push	{r7, lr}
 801131e:	b082      	sub	sp, #8
 8011320:	af00      	add	r7, sp, #0
  struct ip_addr dnsserver;
  
  /* initialize default DNS server address */
  dnsserver.addr = DNS_SERVER_ADDRESS;
 8011322:	f246 70c8 	movw	r0, #26568	; 0x67c8
 8011326:	f6c0 0002 	movt	r0, #2050	; 0x802
 801132a:	f007 fd41 	bl	8018db0 <inet_addr>
 801132e:	4603      	mov	r3, r0
 8011330:	607b      	str	r3, [r7, #4]

  LWIP_DEBUGF(DNS_DEBUG, ("dns_init: initializing\n"));

  /* if dns client not yet initialized... */
  if (dns_pcb == NULL) {
 8011332:	f640 63ac 	movw	r3, #3756	; 0xeac
 8011336:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801133a:	681b      	ldr	r3, [r3, #0]
 801133c:	2b00      	cmp	r3, #0
 801133e:	d131      	bne.n	80113a4 <dns_init+0x88>
    dns_pcb = udp_new();
 8011340:	f006 ff2a 	bl	8018198 <udp_new>
 8011344:	4602      	mov	r2, r0
 8011346:	f640 63ac 	movw	r3, #3756	; 0xeac
 801134a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801134e:	601a      	str	r2, [r3, #0]

    if (dns_pcb != NULL) {
 8011350:	f640 63ac 	movw	r3, #3756	; 0xeac
 8011354:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011358:	681b      	ldr	r3, [r3, #0]
 801135a:	2b00      	cmp	r3, #0
 801135c:	d022      	beq.n	80113a4 <dns_init+0x88>
       * global variable) */
      LWIP_ASSERT("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",
        DNS_STATE_UNUSED == 0);

      /* initialize DNS client */
      udp_bind(dns_pcb, IP_ADDR_ANY, 0);
 801135e:	f640 63ac 	movw	r3, #3756	; 0xeac
 8011362:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011366:	681b      	ldr	r3, [r3, #0]
 8011368:	4618      	mov	r0, r3
 801136a:	f646 0178 	movw	r1, #26744	; 0x6878
 801136e:	f6c0 0102 	movt	r1, #2050	; 0x802
 8011372:	f04f 0200 	mov.w	r2, #0
 8011376:	f006 fddd 	bl	8017f34 <udp_bind>
      udp_recv(dns_pcb, dns_recv, NULL);
 801137a:	f640 63ac 	movw	r3, #3756	; 0xeac
 801137e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011382:	681b      	ldr	r3, [r3, #0]
 8011384:	4618      	mov	r0, r3
 8011386:	f641 1101 	movw	r1, #6401	; 0x1901
 801138a:	f6c0 0101 	movt	r1, #2049	; 0x801
 801138e:	f04f 0200 	mov.w	r2, #0
 8011392:	f006 feb5 	bl	8018100 <udp_recv>

      /* initialize default DNS primary server */
      dns_setserver(0, &dnsserver);
 8011396:	f107 0304 	add.w	r3, r7, #4
 801139a:	f04f 0000 	mov.w	r0, #0
 801139e:	4619      	mov	r1, r3
 80113a0:	f000 f804 	bl	80113ac <dns_setserver>
    }
  }
#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
 80113a4:	f107 0708 	add.w	r7, r7, #8
 80113a8:	46bd      	mov	sp, r7
 80113aa:	bd80      	pop	{r7, pc}

080113ac <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, struct ip_addr *dnsserver)
{
 80113ac:	b480      	push	{r7}
 80113ae:	b083      	sub	sp, #12
 80113b0:	af00      	add	r7, sp, #0
 80113b2:	4603      	mov	r3, r0
 80113b4:	6039      	str	r1, [r7, #0]
 80113b6:	71fb      	strb	r3, [r7, #7]
  if ((numdns < DNS_MAX_SERVERS) && (dns_pcb != NULL) &&
 80113b8:	79fb      	ldrb	r3, [r7, #7]
 80113ba:	2b01      	cmp	r3, #1
 80113bc:	d819      	bhi.n	80113f2 <dns_setserver+0x46>
 80113be:	f640 63ac 	movw	r3, #3756	; 0xeac
 80113c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80113c6:	681b      	ldr	r3, [r3, #0]
 80113c8:	2b00      	cmp	r3, #0
 80113ca:	d012      	beq.n	80113f2 <dns_setserver+0x46>
 80113cc:	683b      	ldr	r3, [r7, #0]
 80113ce:	2b00      	cmp	r3, #0
 80113d0:	d00f      	beq.n	80113f2 <dns_setserver+0x46>
      (dnsserver != NULL) && (dnsserver->addr !=0 )) {
 80113d2:	683b      	ldr	r3, [r7, #0]
 80113d4:	681b      	ldr	r3, [r3, #0]
 80113d6:	2b00      	cmp	r3, #0
 80113d8:	d00b      	beq.n	80113f2 <dns_setserver+0x46>
    dns_servers[numdns] = (*dnsserver);
 80113da:	79fb      	ldrb	r3, [r7, #7]
 80113dc:	f241 3214 	movw	r2, #4884	; 0x1314
 80113e0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80113e4:	6839      	ldr	r1, [r7, #0]
 80113e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80113ea:	18d3      	adds	r3, r2, r3
 80113ec:	460a      	mov	r2, r1
 80113ee:	6810      	ldr	r0, [r2, #0]
 80113f0:	6018      	str	r0, [r3, #0]
  }
}
 80113f2:	f107 070c 	add.w	r7, r7, #12
 80113f6:	46bd      	mov	sp, r7
 80113f8:	bc80      	pop	{r7}
 80113fa:	4770      	bx	lr

080113fc <dns_getserver>:
 * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
 *         server has not been configured.
 */
struct ip_addr
dns_getserver(u8_t numdns)
{
 80113fc:	b480      	push	{r7}
 80113fe:	b085      	sub	sp, #20
 8011400:	af00      	add	r7, sp, #0
 8011402:	4603      	mov	r3, r0
 8011404:	71fb      	strb	r3, [r7, #7]
  if (numdns < DNS_MAX_SERVERS) {
 8011406:	79fb      	ldrb	r3, [r7, #7]
 8011408:	2b01      	cmp	r3, #1
 801140a:	d808      	bhi.n	801141e <dns_getserver+0x22>
    return dns_servers[numdns];
 801140c:	79fa      	ldrb	r2, [r7, #7]
 801140e:	f241 3314 	movw	r3, #4884	; 0x1314
 8011412:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011416:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801141a:	60fb      	str	r3, [r7, #12]
 801141c:	e007      	b.n	801142e <dns_getserver+0x32>
  } else {
    return *IP_ADDR_ANY;
 801141e:	f646 0378 	movw	r3, #26744	; 0x6878
 8011422:	f6c0 0302 	movt	r3, #2050	; 0x802
 8011426:	f107 020c 	add.w	r2, r7, #12
 801142a:	6818      	ldr	r0, [r3, #0]
 801142c:	6010      	str	r0, [r2, #0]
 801142e:	f04f 0300 	mov.w	r3, #0
 8011432:	7b3a      	ldrb	r2, [r7, #12]
 8011434:	f362 0307 	bfi	r3, r2, #0, #8
 8011438:	7b7a      	ldrb	r2, [r7, #13]
 801143a:	f362 230f 	bfi	r3, r2, #8, #8
 801143e:	7bba      	ldrb	r2, [r7, #14]
 8011440:	f362 4317 	bfi	r3, r2, #16, #8
 8011444:	7bfa      	ldrb	r2, [r7, #15]
 8011446:	f362 631f 	bfi	r3, r2, #24, #8
  }
}
 801144a:	4618      	mov	r0, r3
 801144c:	f107 0714 	add.w	r7, r7, #20
 8011450:	46bd      	mov	sp, r7
 8011452:	bc80      	pop	{r7}
 8011454:	4770      	bx	lr
 8011456:	bf00      	nop

08011458 <dns_tmr>:
 * The DNS resolver client timer - handle retries and timeouts and should
 * be called every DNS_TMR_INTERVAL milliseconds (every second by default).
 */
void
dns_tmr(void)
{
 8011458:	b580      	push	{r7, lr}
 801145a:	af00      	add	r7, sp, #0
  if (dns_pcb != NULL) {
 801145c:	f640 63ac 	movw	r3, #3756	; 0xeac
 8011460:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011464:	681b      	ldr	r3, [r3, #0]
 8011466:	2b00      	cmp	r3, #0
 8011468:	d001      	beq.n	801146e <dns_tmr+0x16>
    LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
    dns_check_entries();
 801146a:	f000 fa33 	bl	80118d4 <dns_check_entries>
  }
}
 801146e:	bd80      	pop	{r7, pc}

08011470 <dns_lookup>:
 *         better check for failure: != INADDR_NONE) or INADDR_NONE if the hostname
 *         was not found in the cached dns_table.
 */
static u32_t
dns_lookup(const char *name)
{
 8011470:	b580      	push	{r7, lr}
 8011472:	b084      	sub	sp, #16
 8011474:	af00      	add	r7, sp, #0
 8011476:	6078      	str	r0, [r7, #4]
    return addr;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8011478:	f04f 0300 	mov.w	r3, #0
 801147c:	73fb      	strb	r3, [r7, #15]
 801147e:	e033      	b.n	80114e8 <dns_lookup+0x78>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 8011480:	7bfa      	ldrb	r2, [r7, #15]
 8011482:	f640 63b4 	movw	r3, #3764	; 0xeb4
 8011486:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801148a:	f44f 718c 	mov.w	r1, #280	; 0x118
 801148e:	fb01 f202 	mul.w	r2, r1, r2
 8011492:	189b      	adds	r3, r3, r2
 8011494:	781b      	ldrb	r3, [r3, #0]
 8011496:	2b03      	cmp	r3, #3
 8011498:	d122      	bne.n	80114e0 <dns_lookup+0x70>
        (strcmp(name, dns_table[i].name) == 0)) {
 801149a:	7bfb      	ldrb	r3, [r7, #15]
 801149c:	f44f 728c 	mov.w	r2, #280	; 0x118
 80114a0:	fb02 f303 	mul.w	r3, r2, r3
 80114a4:	f103 0208 	add.w	r2, r3, #8
 80114a8:	f640 63b4 	movw	r3, #3764	; 0xeb4
 80114ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80114b0:	18d3      	adds	r3, r2, r3
 80114b2:	f103 0304 	add.w	r3, r3, #4
 80114b6:	6878      	ldr	r0, [r7, #4]
 80114b8:	4619      	mov	r1, r3
 80114ba:	f013 f9f5 	bl	80248a8 <strcmp>
 80114be:	4603      	mov	r3, r0
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 80114c0:	2b00      	cmp	r3, #0
 80114c2:	d10d      	bne.n	80114e0 <dns_lookup+0x70>
        (strcmp(name, dns_table[i].name) == 0)) {
      LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
      ip_addr_debug_print(DNS_DEBUG, &(dns_table[i].ipaddr));
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      return dns_table[i].ipaddr.addr;
 80114c4:	7bfa      	ldrb	r2, [r7, #15]
 80114c6:	f640 63b4 	movw	r3, #3764	; 0xeb4
 80114ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80114ce:	f44f 718c 	mov.w	r1, #280	; 0x118
 80114d2:	fb01 f202 	mul.w	r2, r1, r2
 80114d6:	189b      	adds	r3, r3, r2
 80114d8:	f503 7386 	add.w	r3, r3, #268	; 0x10c
 80114dc:	681b      	ldr	r3, [r3, #0]
 80114de:	e008      	b.n	80114f2 <dns_lookup+0x82>
    return addr;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80114e0:	7bfb      	ldrb	r3, [r7, #15]
 80114e2:	f103 0301 	add.w	r3, r3, #1
 80114e6:	73fb      	strb	r3, [r7, #15]
 80114e8:	7bfb      	ldrb	r3, [r7, #15]
 80114ea:	2b03      	cmp	r3, #3
 80114ec:	d9c8      	bls.n	8011480 <dns_lookup+0x10>
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      return dns_table[i].ipaddr.addr;
    }
  }

  return INADDR_NONE;
 80114ee:	f04f 33ff 	mov.w	r3, #4294967295
}
 80114f2:	4618      	mov	r0, r3
 80114f4:	f107 0710 	add.w	r7, r7, #16
 80114f8:	46bd      	mov	sp, r7
 80114fa:	bd80      	pop	{r7, pc}

080114fc <dns_compare_name>:
 * @param response encoded hostname in the DNS response
 * @return 0: names equal; 1: names differ
 */
static u8_t
dns_compare_name(unsigned char *query, unsigned char *response)
{
 80114fc:	b480      	push	{r7}
 80114fe:	b085      	sub	sp, #20
 8011500:	af00      	add	r7, sp, #0
 8011502:	6078      	str	r0, [r7, #4]
 8011504:	6039      	str	r1, [r7, #0]
  unsigned char n;

  do {
    n = *response++;
 8011506:	683b      	ldr	r3, [r7, #0]
 8011508:	781b      	ldrb	r3, [r3, #0]
 801150a:	73fb      	strb	r3, [r7, #15]
 801150c:	683b      	ldr	r3, [r7, #0]
 801150e:	f103 0301 	add.w	r3, r3, #1
 8011512:	603b      	str	r3, [r7, #0]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 8011514:	7bfb      	ldrb	r3, [r7, #15]
 8011516:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801151a:	2bc0      	cmp	r3, #192	; 0xc0
 801151c:	d115      	bne.n	801154a <dns_compare_name+0x4e>
      /* Compressed name */
      break;
 801151e:	e01f      	b.n	8011560 <dns_compare_name+0x64>
    } else {
      /* Not compressed name */
      while (n > 0) {
        if ((*query) != (*response)) {
 8011520:	687b      	ldr	r3, [r7, #4]
 8011522:	781a      	ldrb	r2, [r3, #0]
 8011524:	683b      	ldr	r3, [r7, #0]
 8011526:	781b      	ldrb	r3, [r3, #0]
 8011528:	429a      	cmp	r2, r3
 801152a:	d002      	beq.n	8011532 <dns_compare_name+0x36>
          return 1;
 801152c:	f04f 0301 	mov.w	r3, #1
 8011530:	e018      	b.n	8011564 <dns_compare_name+0x68>
        }
        ++response;
 8011532:	683b      	ldr	r3, [r7, #0]
 8011534:	f103 0301 	add.w	r3, r3, #1
 8011538:	603b      	str	r3, [r7, #0]
        ++query;
 801153a:	687b      	ldr	r3, [r7, #4]
 801153c:	f103 0301 	add.w	r3, r3, #1
 8011540:	607b      	str	r3, [r7, #4]
        --n;
 8011542:	7bfb      	ldrb	r3, [r7, #15]
 8011544:	f103 33ff 	add.w	r3, r3, #4294967295
 8011548:	73fb      	strb	r3, [r7, #15]
    if ((n & 0xc0) == 0xc0) {
      /* Compressed name */
      break;
    } else {
      /* Not compressed name */
      while (n > 0) {
 801154a:	7bfb      	ldrb	r3, [r7, #15]
 801154c:	2b00      	cmp	r3, #0
 801154e:	d1e7      	bne.n	8011520 <dns_compare_name+0x24>
        }
        ++response;
        ++query;
        --n;
      };
      ++query;
 8011550:	687b      	ldr	r3, [r7, #4]
 8011552:	f103 0301 	add.w	r3, r3, #1
 8011556:	607b      	str	r3, [r7, #4]
    }
  } while (*response != 0);
 8011558:	683b      	ldr	r3, [r7, #0]
 801155a:	781b      	ldrb	r3, [r3, #0]
 801155c:	2b00      	cmp	r3, #0
 801155e:	d1d2      	bne.n	8011506 <dns_compare_name+0xa>

  return 0;
 8011560:	f04f 0300 	mov.w	r3, #0
}
 8011564:	4618      	mov	r0, r3
 8011566:	f107 0714 	add.w	r7, r7, #20
 801156a:	46bd      	mov	sp, r7
 801156c:	bc80      	pop	{r7}
 801156e:	4770      	bx	lr

08011570 <dns_parse_name>:
 * @param query encoded DNS name in the DNS server response
 * @return end of the name
 */
static unsigned char *
dns_parse_name(unsigned char *query)
{
 8011570:	b480      	push	{r7}
 8011572:	b085      	sub	sp, #20
 8011574:	af00      	add	r7, sp, #0
 8011576:	6078      	str	r0, [r7, #4]
  unsigned char n;

  do {
    n = *query++;
 8011578:	687b      	ldr	r3, [r7, #4]
 801157a:	781b      	ldrb	r3, [r3, #0]
 801157c:	73fb      	strb	r3, [r7, #15]
 801157e:	687b      	ldr	r3, [r7, #4]
 8011580:	f103 0301 	add.w	r3, r3, #1
 8011584:	607b      	str	r3, [r7, #4]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 8011586:	7bfb      	ldrb	r3, [r7, #15]
 8011588:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801158c:	2bc0      	cmp	r3, #192	; 0xc0
 801158e:	d108      	bne.n	80115a2 <dns_parse_name+0x32>
      /* Compressed name */
      break;
 8011590:	e00e      	b.n	80115b0 <dns_parse_name+0x40>
    } else {
      /* Not compressed name */
      while (n > 0) {
        ++query;
 8011592:	687b      	ldr	r3, [r7, #4]
 8011594:	f103 0301 	add.w	r3, r3, #1
 8011598:	607b      	str	r3, [r7, #4]
        --n;
 801159a:	7bfb      	ldrb	r3, [r7, #15]
 801159c:	f103 33ff 	add.w	r3, r3, #4294967295
 80115a0:	73fb      	strb	r3, [r7, #15]
    if ((n & 0xc0) == 0xc0) {
      /* Compressed name */
      break;
    } else {
      /* Not compressed name */
      while (n > 0) {
 80115a2:	7bfb      	ldrb	r3, [r7, #15]
 80115a4:	2b00      	cmp	r3, #0
 80115a6:	d1f4      	bne.n	8011592 <dns_parse_name+0x22>
        ++query;
        --n;
      };
    }
  } while (*query != 0);
 80115a8:	687b      	ldr	r3, [r7, #4]
 80115aa:	781b      	ldrb	r3, [r3, #0]
 80115ac:	2b00      	cmp	r3, #0
 80115ae:	d1e3      	bne.n	8011578 <dns_parse_name+0x8>

  return query + 1;
 80115b0:	687b      	ldr	r3, [r7, #4]
 80115b2:	f103 0301 	add.w	r3, r3, #1
}
 80115b6:	4618      	mov	r0, r3
 80115b8:	f107 0714 	add.w	r7, r7, #20
 80115bc:	46bd      	mov	sp, r7
 80115be:	bc80      	pop	{r7}
 80115c0:	4770      	bx	lr
 80115c2:	bf00      	nop

080115c4 <dns_send>:
 *        DNS query packet
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t numdns, const char* name, u8_t id)
{
 80115c4:	b580      	push	{r7, lr}
 80115c6:	b08a      	sub	sp, #40	; 0x28
 80115c8:	af00      	add	r7, sp, #0
 80115ca:	6039      	str	r1, [r7, #0]
 80115cc:	4613      	mov	r3, r2
 80115ce:	4602      	mov	r2, r0
 80115d0:	71fa      	strb	r2, [r7, #7]
 80115d2:	71bb      	strb	r3, [r7, #6]
              (u16_t)(numdns), name));
  LWIP_ASSERT("dns server out of array", numdns < DNS_MAX_SERVERS);
  LWIP_ASSERT("dns server has no IP address set", dns_servers[numdns].addr != 0);

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, SIZEOF_DNS_HDR + DNS_MAX_NAME_LENGTH +
 80115d4:	f04f 0000 	mov.w	r0, #0
 80115d8:	f44f 7188 	mov.w	r1, #272	; 0x110
 80115dc:	f04f 0200 	mov.w	r2, #0
 80115e0:	f001 fa66 	bl	8012ab0 <pbuf_alloc>
 80115e4:	6178      	str	r0, [r7, #20]
                 SIZEOF_DNS_QUERY, PBUF_RAM);
  if (p != NULL) {
 80115e6:	697b      	ldr	r3, [r7, #20]
 80115e8:	2b00      	cmp	r3, #0
 80115ea:	f000 80a9 	beq.w	8011740 <dns_send+0x17c>
    LWIP_ASSERT("pbuf must be in one piece", p->next == NULL);
    /* fill dns header */
    hdr = (struct dns_hdr*)p->payload;
 80115ee:	697b      	ldr	r3, [r7, #20]
 80115f0:	685b      	ldr	r3, [r3, #4]
 80115f2:	613b      	str	r3, [r7, #16]
    memset(hdr, 0, SIZEOF_DNS_HDR);
 80115f4:	6938      	ldr	r0, [r7, #16]
 80115f6:	f04f 0100 	mov.w	r1, #0
 80115fa:	f04f 020c 	mov.w	r2, #12
 80115fe:	f012 f977 	bl	80238f0 <memset>
    hdr->id = htons(id);
 8011602:	79bb      	ldrb	r3, [r7, #6]
 8011604:	b29b      	uxth	r3, r3
 8011606:	4618      	mov	r0, r3
 8011608:	f007 fda6 	bl	8019158 <htons>
 801160c:	4603      	mov	r3, r0
 801160e:	461a      	mov	r2, r3
 8011610:	693b      	ldr	r3, [r7, #16]
 8011612:	801a      	strh	r2, [r3, #0]
    hdr->flags1 = DNS_FLAG1_RD;
 8011614:	693b      	ldr	r3, [r7, #16]
 8011616:	f04f 0201 	mov.w	r2, #1
 801161a:	709a      	strb	r2, [r3, #2]
    hdr->numquestions = htons(1);
 801161c:	f04f 0001 	mov.w	r0, #1
 8011620:	f007 fd9a 	bl	8019158 <htons>
 8011624:	4603      	mov	r3, r0
 8011626:	461a      	mov	r2, r3
 8011628:	693b      	ldr	r3, [r7, #16]
 801162a:	809a      	strh	r2, [r3, #4]
    query = (char*)hdr + SIZEOF_DNS_HDR;
 801162c:	693b      	ldr	r3, [r7, #16]
 801162e:	f103 030c 	add.w	r3, r3, #12
 8011632:	623b      	str	r3, [r7, #32]
    pHostname = name;
 8011634:	683b      	ldr	r3, [r7, #0]
 8011636:	61fb      	str	r3, [r7, #28]
    --pHostname;
 8011638:	69fb      	ldr	r3, [r7, #28]
 801163a:	f103 33ff 	add.w	r3, r3, #4294967295
 801163e:	61fb      	str	r3, [r7, #28]

    /* convert hostname into suitable query format. */
    do {
      ++pHostname;
 8011640:	69fb      	ldr	r3, [r7, #28]
 8011642:	f103 0301 	add.w	r3, r3, #1
 8011646:	61fb      	str	r3, [r7, #28]
      nptr = query;
 8011648:	6a3b      	ldr	r3, [r7, #32]
 801164a:	60fb      	str	r3, [r7, #12]
      ++query;
 801164c:	6a3b      	ldr	r3, [r7, #32]
 801164e:	f103 0301 	add.w	r3, r3, #1
 8011652:	623b      	str	r3, [r7, #32]
      for(n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {
 8011654:	f04f 0300 	mov.w	r3, #0
 8011658:	76fb      	strb	r3, [r7, #27]
 801165a:	e00f      	b.n	801167c <dns_send+0xb8>
        *query = *pHostname;
 801165c:	69fb      	ldr	r3, [r7, #28]
 801165e:	781a      	ldrb	r2, [r3, #0]
 8011660:	6a3b      	ldr	r3, [r7, #32]
 8011662:	701a      	strb	r2, [r3, #0]
        ++query;
 8011664:	6a3b      	ldr	r3, [r7, #32]
 8011666:	f103 0301 	add.w	r3, r3, #1
 801166a:	623b      	str	r3, [r7, #32]
        ++n;
 801166c:	7efb      	ldrb	r3, [r7, #27]
 801166e:	f103 0301 	add.w	r3, r3, #1
 8011672:	76fb      	strb	r3, [r7, #27]
    /* convert hostname into suitable query format. */
    do {
      ++pHostname;
      nptr = query;
      ++query;
      for(n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {
 8011674:	69fb      	ldr	r3, [r7, #28]
 8011676:	f103 0301 	add.w	r3, r3, #1
 801167a:	61fb      	str	r3, [r7, #28]
 801167c:	69fb      	ldr	r3, [r7, #28]
 801167e:	781b      	ldrb	r3, [r3, #0]
 8011680:	2b2e      	cmp	r3, #46	; 0x2e
 8011682:	d003      	beq.n	801168c <dns_send+0xc8>
 8011684:	69fb      	ldr	r3, [r7, #28]
 8011686:	781b      	ldrb	r3, [r3, #0]
 8011688:	2b00      	cmp	r3, #0
 801168a:	d1e7      	bne.n	801165c <dns_send+0x98>
        *query = *pHostname;
        ++query;
        ++n;
      }
      *nptr = n;
 801168c:	68fb      	ldr	r3, [r7, #12]
 801168e:	7efa      	ldrb	r2, [r7, #27]
 8011690:	701a      	strb	r2, [r3, #0]
    } while(*pHostname != 0);
 8011692:	69fb      	ldr	r3, [r7, #28]
 8011694:	781b      	ldrb	r3, [r3, #0]
 8011696:	2b00      	cmp	r3, #0
 8011698:	d1d2      	bne.n	8011640 <dns_send+0x7c>
    *query++='\0';
 801169a:	6a3b      	ldr	r3, [r7, #32]
 801169c:	f04f 0200 	mov.w	r2, #0
 80116a0:	701a      	strb	r2, [r3, #0]
 80116a2:	6a3b      	ldr	r3, [r7, #32]
 80116a4:	f103 0301 	add.w	r3, r3, #1
 80116a8:	623b      	str	r3, [r7, #32]

    /* fill dns query */
    qry.type  = htons(DNS_RRTYPE_A);
 80116aa:	f04f 0001 	mov.w	r0, #1
 80116ae:	f007 fd53 	bl	8019158 <htons>
 80116b2:	4603      	mov	r3, r0
 80116b4:	813b      	strh	r3, [r7, #8]
    qry.class = htons(DNS_RRCLASS_IN);
 80116b6:	f04f 0001 	mov.w	r0, #1
 80116ba:	f007 fd4d 	bl	8019158 <htons>
 80116be:	4603      	mov	r3, r0
 80116c0:	817b      	strh	r3, [r7, #10]
    MEMCPY( query, &qry, SIZEOF_DNS_QUERY);
 80116c2:	6a3b      	ldr	r3, [r7, #32]
 80116c4:	f107 0208 	add.w	r2, r7, #8
 80116c8:	6810      	ldr	r0, [r2, #0]
 80116ca:	6018      	str	r0, [r3, #0]

    /* resize pbuf to the exact dns query */
    pbuf_realloc(p, (query + SIZEOF_DNS_QUERY) - ((char*)(p->payload)));
 80116cc:	6a3b      	ldr	r3, [r7, #32]
 80116ce:	f103 0304 	add.w	r3, r3, #4
 80116d2:	461a      	mov	r2, r3
 80116d4:	697b      	ldr	r3, [r7, #20]
 80116d6:	685b      	ldr	r3, [r3, #4]
 80116d8:	1ad3      	subs	r3, r2, r3
 80116da:	b29b      	uxth	r3, r3
 80116dc:	6978      	ldr	r0, [r7, #20]
 80116de:	4619      	mov	r1, r3
 80116e0:	f001 fb0e 	bl	8012d00 <pbuf_realloc>

    /* connect to the server for faster receiving */
    udp_connect(dns_pcb, &dns_servers[numdns], DNS_SERVER_PORT);
 80116e4:	f640 63ac 	movw	r3, #3756	; 0xeac
 80116e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80116ec:	681a      	ldr	r2, [r3, #0]
 80116ee:	79fb      	ldrb	r3, [r7, #7]
 80116f0:	ea4f 0183 	mov.w	r1, r3, lsl #2
 80116f4:	f241 3314 	movw	r3, #4884	; 0x1314
 80116f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80116fc:	18cb      	adds	r3, r1, r3
 80116fe:	4610      	mov	r0, r2
 8011700:	4619      	mov	r1, r3
 8011702:	f04f 0235 	mov.w	r2, #53	; 0x35
 8011706:	f006 fc87 	bl	8018018 <udp_connect>
    /* send dns packet */
    err = udp_sendto(dns_pcb, p, &dns_servers[numdns], DNS_SERVER_PORT);
 801170a:	f640 63ac 	movw	r3, #3756	; 0xeac
 801170e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011712:	681a      	ldr	r2, [r3, #0]
 8011714:	79fb      	ldrb	r3, [r7, #7]
 8011716:	ea4f 0183 	mov.w	r1, r3, lsl #2
 801171a:	f241 3314 	movw	r3, #4884	; 0x1314
 801171e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011722:	18cb      	adds	r3, r1, r3
 8011724:	4610      	mov	r0, r2
 8011726:	6979      	ldr	r1, [r7, #20]
 8011728:	461a      	mov	r2, r3
 801172a:	f04f 0335 	mov.w	r3, #53	; 0x35
 801172e:	f006 fb2d 	bl	8017d8c <udp_sendto>
 8011732:	4603      	mov	r3, r0
 8011734:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    /* free pbuf */
    pbuf_free(p);
 8011738:	6978      	ldr	r0, [r7, #20]
 801173a:	f001 fbc1 	bl	8012ec0 <pbuf_free>
 801173e:	e003      	b.n	8011748 <dns_send+0x184>
  } else {
    err = ERR_MEM;
 8011740:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8011744:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  return err;
 8011748:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801174c:	b25b      	sxtb	r3, r3
}
 801174e:	4618      	mov	r0, r3
 8011750:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8011754:	46bd      	mov	sp, r7
 8011756:	bd80      	pop	{r7, pc}

08011758 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
 8011758:	b580      	push	{r7, lr}
 801175a:	b084      	sub	sp, #16
 801175c:	af00      	add	r7, sp, #0
 801175e:	4603      	mov	r3, r0
 8011760:	71fb      	strb	r3, [r7, #7]
  struct dns_table_entry *pEntry = &dns_table[i];
 8011762:	79fb      	ldrb	r3, [r7, #7]
 8011764:	f44f 728c 	mov.w	r2, #280	; 0x118
 8011768:	fb02 f203 	mul.w	r2, r2, r3
 801176c:	f640 63b4 	movw	r3, #3764	; 0xeb4
 8011770:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011774:	18d3      	adds	r3, r2, r3
 8011776:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);

  switch(pEntry->state) {
 8011778:	68fb      	ldr	r3, [r7, #12]
 801177a:	781b      	ldrb	r3, [r3, #0]
 801177c:	2b03      	cmp	r3, #3
 801177e:	f200 809f 	bhi.w	80118c0 <dns_check_entry+0x168>
 8011782:	a201      	add	r2, pc, #4	; (adr r2, 8011788 <dns_check_entry+0x30>)
 8011784:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011788:	080118c1 	.word	0x080118c1
 801178c:	08011799 	.word	0x08011799
 8011790:	080117d1 	.word	0x080117d1
 8011794:	08011899 	.word	0x08011899

    case DNS_STATE_NEW: {
      /* initialize new entry */
      pEntry->state   = DNS_STATE_ASKING;
 8011798:	68fb      	ldr	r3, [r7, #12]
 801179a:	f04f 0202 	mov.w	r2, #2
 801179e:	701a      	strb	r2, [r3, #0]
      pEntry->numdns  = 0;
 80117a0:	68fb      	ldr	r3, [r7, #12]
 80117a2:	f04f 0200 	mov.w	r2, #0
 80117a6:	705a      	strb	r2, [r3, #1]
      pEntry->tmr     = 1;
 80117a8:	68fb      	ldr	r3, [r7, #12]
 80117aa:	f04f 0201 	mov.w	r2, #1
 80117ae:	709a      	strb	r2, [r3, #2]
      pEntry->retries = 0;
 80117b0:	68fb      	ldr	r3, [r7, #12]
 80117b2:	f04f 0200 	mov.w	r2, #0
 80117b6:	70da      	strb	r2, [r3, #3]
      
      /* send DNS packet for this entry */
      dns_send(pEntry->numdns, pEntry->name, i);
 80117b8:	68fb      	ldr	r3, [r7, #12]
 80117ba:	7859      	ldrb	r1, [r3, #1]
 80117bc:	68fb      	ldr	r3, [r7, #12]
 80117be:	f103 020c 	add.w	r2, r3, #12
 80117c2:	79fb      	ldrb	r3, [r7, #7]
 80117c4:	4608      	mov	r0, r1
 80117c6:	4611      	mov	r1, r2
 80117c8:	461a      	mov	r2, r3
 80117ca:	f7ff fefb 	bl	80115c4 <dns_send>
      break;
 80117ce:	e07c      	b.n	80118ca <dns_check_entry+0x172>
    }

    case DNS_STATE_ASKING: {
      if (--pEntry->tmr == 0) {
 80117d0:	68fb      	ldr	r3, [r7, #12]
 80117d2:	789b      	ldrb	r3, [r3, #2]
 80117d4:	f103 33ff 	add.w	r3, r3, #4294967295
 80117d8:	b2da      	uxtb	r2, r3
 80117da:	68fb      	ldr	r3, [r7, #12]
 80117dc:	709a      	strb	r2, [r3, #2]
 80117de:	68fb      	ldr	r3, [r7, #12]
 80117e0:	789b      	ldrb	r3, [r3, #2]
 80117e2:	2b00      	cmp	r3, #0
 80117e4:	d16e      	bne.n	80118c4 <dns_check_entry+0x16c>
        if (++pEntry->retries == DNS_MAX_RETRIES) {
 80117e6:	68fb      	ldr	r3, [r7, #12]
 80117e8:	78db      	ldrb	r3, [r3, #3]
 80117ea:	f103 0301 	add.w	r3, r3, #1
 80117ee:	b2da      	uxtb	r2, r3
 80117f0:	68fb      	ldr	r3, [r7, #12]
 80117f2:	70da      	strb	r2, [r3, #3]
 80117f4:	68fb      	ldr	r3, [r7, #12]
 80117f6:	78db      	ldrb	r3, [r3, #3]
 80117f8:	2b04      	cmp	r3, #4
 80117fa:	d13d      	bne.n	8011878 <dns_check_entry+0x120>
          if ((pEntry->numdns+1<DNS_MAX_SERVERS) && (dns_servers[pEntry->numdns+1].addr!=0)) {
 80117fc:	68fb      	ldr	r3, [r7, #12]
 80117fe:	785b      	ldrb	r3, [r3, #1]
 8011800:	f103 0301 	add.w	r3, r3, #1
 8011804:	2b01      	cmp	r3, #1
 8011806:	dc1b      	bgt.n	8011840 <dns_check_entry+0xe8>
 8011808:	68fb      	ldr	r3, [r7, #12]
 801180a:	785b      	ldrb	r3, [r3, #1]
 801180c:	f103 0201 	add.w	r2, r3, #1
 8011810:	f241 3314 	movw	r3, #4884	; 0x1314
 8011814:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011818:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801181c:	2b00      	cmp	r3, #0
 801181e:	d00f      	beq.n	8011840 <dns_check_entry+0xe8>
            /* change of server */
            pEntry->numdns++;
 8011820:	68fb      	ldr	r3, [r7, #12]
 8011822:	785b      	ldrb	r3, [r3, #1]
 8011824:	f103 0301 	add.w	r3, r3, #1
 8011828:	b2da      	uxtb	r2, r3
 801182a:	68fb      	ldr	r3, [r7, #12]
 801182c:	705a      	strb	r2, [r3, #1]
            pEntry->tmr     = 1;
 801182e:	68fb      	ldr	r3, [r7, #12]
 8011830:	f04f 0201 	mov.w	r2, #1
 8011834:	709a      	strb	r2, [r3, #2]
            pEntry->retries = 0;
 8011836:	68fb      	ldr	r3, [r7, #12]
 8011838:	f04f 0200 	mov.w	r2, #0
 801183c:	70da      	strb	r2, [r3, #3]
            break;
 801183e:	e044      	b.n	80118ca <dns_check_entry+0x172>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", pEntry->name));
            /* call specified callback function if provided */
            if (pEntry->found)
 8011840:	68fb      	ldr	r3, [r7, #12]
 8011842:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8011846:	2b00      	cmp	r3, #0
 8011848:	d00c      	beq.n	8011864 <dns_check_entry+0x10c>
              (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
 801184a:	68fb      	ldr	r3, [r7, #12]
 801184c:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8011850:	68fa      	ldr	r2, [r7, #12]
 8011852:	f102 010c 	add.w	r1, r2, #12
 8011856:	68fa      	ldr	r2, [r7, #12]
 8011858:	f8d2 2114 	ldr.w	r2, [r2, #276]	; 0x114
 801185c:	4608      	mov	r0, r1
 801185e:	f04f 0100 	mov.w	r1, #0
 8011862:	4798      	blx	r3
            /* flush this entry */
            pEntry->state   = DNS_STATE_UNUSED;
 8011864:	68fb      	ldr	r3, [r7, #12]
 8011866:	f04f 0200 	mov.w	r2, #0
 801186a:	701a      	strb	r2, [r3, #0]
            pEntry->found   = NULL;
 801186c:	68fb      	ldr	r3, [r7, #12]
 801186e:	f04f 0200 	mov.w	r2, #0
 8011872:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            break;
 8011876:	e028      	b.n	80118ca <dns_check_entry+0x172>
          }
        }

        /* wait longer for the next retry */
        pEntry->tmr = pEntry->retries;
 8011878:	68fb      	ldr	r3, [r7, #12]
 801187a:	78da      	ldrb	r2, [r3, #3]
 801187c:	68fb      	ldr	r3, [r7, #12]
 801187e:	709a      	strb	r2, [r3, #2]

        /* send DNS packet for this entry */
        dns_send(pEntry->numdns, pEntry->name, i);
 8011880:	68fb      	ldr	r3, [r7, #12]
 8011882:	7859      	ldrb	r1, [r3, #1]
 8011884:	68fb      	ldr	r3, [r7, #12]
 8011886:	f103 020c 	add.w	r2, r3, #12
 801188a:	79fb      	ldrb	r3, [r7, #7]
 801188c:	4608      	mov	r0, r1
 801188e:	4611      	mov	r1, r2
 8011890:	461a      	mov	r2, r3
 8011892:	f7ff fe97 	bl	80115c4 <dns_send>
      }
      break;
 8011896:	e015      	b.n	80118c4 <dns_check_entry+0x16c>
    }

    case DNS_STATE_DONE: {
      /* if the time to live is nul */
      if (--pEntry->ttl == 0) {
 8011898:	68fb      	ldr	r3, [r7, #12]
 801189a:	689b      	ldr	r3, [r3, #8]
 801189c:	f103 32ff 	add.w	r2, r3, #4294967295
 80118a0:	68fb      	ldr	r3, [r7, #12]
 80118a2:	609a      	str	r2, [r3, #8]
 80118a4:	68fb      	ldr	r3, [r7, #12]
 80118a6:	689b      	ldr	r3, [r3, #8]
 80118a8:	2b00      	cmp	r3, #0
 80118aa:	d10d      	bne.n	80118c8 <dns_check_entry+0x170>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", pEntry->name));
        /* flush this entry */
        pEntry->state = DNS_STATE_UNUSED;
 80118ac:	68fb      	ldr	r3, [r7, #12]
 80118ae:	f04f 0200 	mov.w	r2, #0
 80118b2:	701a      	strb	r2, [r3, #0]
        pEntry->found = NULL;
 80118b4:	68fb      	ldr	r3, [r7, #12]
 80118b6:	f04f 0200 	mov.w	r2, #0
 80118ba:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
      }
      break;
 80118be:	e003      	b.n	80118c8 <dns_check_entry+0x170>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
      break;
 80118c0:	bf00      	nop
 80118c2:	e002      	b.n	80118ca <dns_check_entry+0x172>
        pEntry->tmr = pEntry->retries;

        /* send DNS packet for this entry */
        dns_send(pEntry->numdns, pEntry->name, i);
      }
      break;
 80118c4:	bf00      	nop
 80118c6:	e000      	b.n	80118ca <dns_check_entry+0x172>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", pEntry->name));
        /* flush this entry */
        pEntry->state = DNS_STATE_UNUSED;
        pEntry->found = NULL;
      }
      break;
 80118c8:	bf00      	nop
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
      break;
  }
}
 80118ca:	f107 0710 	add.w	r7, r7, #16
 80118ce:	46bd      	mov	sp, r7
 80118d0:	bd80      	pop	{r7, pc}
 80118d2:	bf00      	nop

080118d4 <dns_check_entries>:
/**
 * Call dns_check_entry for each entry in dns_table - check all entries.
 */
static void
dns_check_entries(void)
{
 80118d4:	b580      	push	{r7, lr}
 80118d6:	b082      	sub	sp, #8
 80118d8:	af00      	add	r7, sp, #0
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80118da:	f04f 0300 	mov.w	r3, #0
 80118de:	71fb      	strb	r3, [r7, #7]
 80118e0:	e007      	b.n	80118f2 <dns_check_entries+0x1e>
    dns_check_entry(i);
 80118e2:	79fb      	ldrb	r3, [r7, #7]
 80118e4:	4618      	mov	r0, r3
 80118e6:	f7ff ff37 	bl	8011758 <dns_check_entry>
static void
dns_check_entries(void)
{
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80118ea:	79fb      	ldrb	r3, [r7, #7]
 80118ec:	f103 0301 	add.w	r3, r3, #1
 80118f0:	71fb      	strb	r3, [r7, #7]
 80118f2:	79fb      	ldrb	r3, [r7, #7]
 80118f4:	2b03      	cmp	r3, #3
 80118f6:	d9f4      	bls.n	80118e2 <dns_check_entries+0xe>
    dns_check_entry(i);
  }
}
 80118f8:	f107 0708 	add.w	r7, r7, #8
 80118fc:	46bd      	mov	sp, r7
 80118fe:	bd80      	pop	{r7, pc}

08011900 <dns_recv>:
 *
 * @params see udp.h
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
 8011900:	b580      	push	{r7, lr}
 8011902:	b08c      	sub	sp, #48	; 0x30
 8011904:	af00      	add	r7, sp, #0
 8011906:	60f8      	str	r0, [r7, #12]
 8011908:	60b9      	str	r1, [r7, #8]
 801190a:	607a      	str	r2, [r7, #4]
 801190c:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  /* is the dns message too big ? */
  if (p->tot_len > DNS_MSG_SIZE) {
 801190e:	687b      	ldr	r3, [r7, #4]
 8011910:	891b      	ldrh	r3, [r3, #8]
 8011912:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8011916:	f200 80ff 	bhi.w	8011b18 <dns_recv+0x218>
    /* free pbuf and return */
    goto memerr1;
  }

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {
 801191a:	687b      	ldr	r3, [r7, #4]
 801191c:	891b      	ldrh	r3, [r3, #8]
 801191e:	2b19      	cmp	r3, #25
 8011920:	f240 80fc 	bls.w	8011b1c <dns_recv+0x21c>
    goto memerr1;
  }
#endif /* (DNS_USES_STATIC_BUF == 2) */

  /* copy dns payload inside static buffer for processing */ 
  if (pbuf_copy_partial(p, dns_payload, p->tot_len, 0) == p->tot_len) {
 8011924:	687b      	ldr	r3, [r7, #4]
 8011926:	891b      	ldrh	r3, [r3, #8]
 8011928:	6878      	ldr	r0, [r7, #4]
 801192a:	f241 311c 	movw	r1, #4892	; 0x131c
 801192e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8011932:	461a      	mov	r2, r3
 8011934:	f04f 0300 	mov.w	r3, #0
 8011938:	f001 fc38 	bl	80131ac <pbuf_copy_partial>
 801193c:	4603      	mov	r3, r0
 801193e:	461a      	mov	r2, r3
 8011940:	687b      	ldr	r3, [r7, #4]
 8011942:	891b      	ldrh	r3, [r3, #8]
 8011944:	429a      	cmp	r2, r3
 8011946:	f040 80eb 	bne.w	8011b20 <dns_recv+0x220>
    /* The ID in the DNS header should be our entry into the name table. */
    hdr = (struct dns_hdr*)dns_payload;
 801194a:	f241 331c 	movw	r3, #4892	; 0x131c
 801194e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011952:	627b      	str	r3, [r7, #36]	; 0x24
    i = htons(hdr->id);
 8011954:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011956:	881b      	ldrh	r3, [r3, #0]
 8011958:	b29b      	uxth	r3, r3
 801195a:	4618      	mov	r0, r3
 801195c:	f007 fbfc 	bl	8019158 <htons>
 8011960:	4603      	mov	r3, r0
 8011962:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (i < DNS_TABLE_SIZE) {
 8011966:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801196a:	2b03      	cmp	r3, #3
 801196c:	f200 80d8 	bhi.w	8011b20 <dns_recv+0x220>
      pEntry = &dns_table[i];
 8011970:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8011974:	f44f 728c 	mov.w	r2, #280	; 0x118
 8011978:	fb02 f203 	mul.w	r2, r2, r3
 801197c:	f640 63b4 	movw	r3, #3764	; 0xeb4
 8011980:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011984:	18d3      	adds	r3, r2, r3
 8011986:	61fb      	str	r3, [r7, #28]
      if(pEntry->state == DNS_STATE_ASKING) {
 8011988:	69fb      	ldr	r3, [r7, #28]
 801198a:	781b      	ldrb	r3, [r3, #0]
 801198c:	2b02      	cmp	r3, #2
 801198e:	f040 80c7 	bne.w	8011b20 <dns_recv+0x220>
        /* This entry is now completed. */
        pEntry->state = DNS_STATE_DONE;
 8011992:	69fb      	ldr	r3, [r7, #28]
 8011994:	f04f 0203 	mov.w	r2, #3
 8011998:	701a      	strb	r2, [r3, #0]
        pEntry->err   = hdr->flags2 & DNS_FLAG2_ERR_MASK;
 801199a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801199c:	78db      	ldrb	r3, [r3, #3]
 801199e:	f003 030f 	and.w	r3, r3, #15
 80119a2:	b2da      	uxtb	r2, r3
 80119a4:	69fb      	ldr	r3, [r7, #28]
 80119a6:	715a      	strb	r2, [r3, #5]

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = htons(hdr->numquestions);
 80119a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119aa:	889b      	ldrh	r3, [r3, #4]
 80119ac:	b29b      	uxth	r3, r3
 80119ae:	4618      	mov	r0, r3
 80119b0:	f007 fbd2 	bl	8019158 <htons>
 80119b4:	4603      	mov	r3, r0
 80119b6:	76fb      	strb	r3, [r7, #27]
        nanswers   = htons(hdr->numanswers);
 80119b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119ba:	88db      	ldrh	r3, [r3, #6]
 80119bc:	b29b      	uxth	r3, r3
 80119be:	4618      	mov	r0, r3
 80119c0:	f007 fbca 	bl	8019158 <htons>
 80119c4:	4603      	mov	r3, r0
 80119c6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

        /* Check for error. If so, call callback to inform. */
        if (((hdr->flags1 & DNS_FLAG1_RESPONSE) == 0) || (pEntry->err != 0) || (nquestions != 1)) {
 80119ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119cc:	789b      	ldrb	r3, [r3, #2]
 80119ce:	b2db      	uxtb	r3, r3
 80119d0:	b25b      	sxtb	r3, r3
 80119d2:	2b00      	cmp	r3, #0
 80119d4:	f280 8084 	bge.w	8011ae0 <dns_recv+0x1e0>
 80119d8:	69fb      	ldr	r3, [r7, #28]
 80119da:	795b      	ldrb	r3, [r3, #5]
 80119dc:	2b00      	cmp	r3, #0
 80119de:	d17f      	bne.n	8011ae0 <dns_recv+0x1e0>
 80119e0:	7efb      	ldrb	r3, [r7, #27]
 80119e2:	2b01      	cmp	r3, #1
 80119e4:	d17c      	bne.n	8011ae0 <dns_recv+0x1e0>
          goto responseerr;
        }

#if DNS_DOES_NAME_CHECK
        /* Check if the name in the "question" part match with the name in the entry. */
        if (dns_compare_name((unsigned char *)(pEntry->name), (unsigned char *)dns_payload + SIZEOF_DNS_HDR) != 0) {
 80119e6:	69fb      	ldr	r3, [r7, #28]
 80119e8:	f103 030c 	add.w	r3, r3, #12
 80119ec:	4618      	mov	r0, r3
 80119ee:	4951      	ldr	r1, [pc, #324]	; (8011b34 <dns_recv+0x234>)
 80119f0:	f7ff fd84 	bl	80114fc <dns_compare_name>
 80119f4:	4603      	mov	r3, r0
 80119f6:	2b00      	cmp	r3, #0
 80119f8:	d171      	bne.n	8011ade <dns_recv+0x1de>
          goto responseerr;
        }
#endif /* DNS_DOES_NAME_CHECK */

        /* Skip the name in the "question" part */
        pHostname = (char *) dns_parse_name((unsigned char *)dns_payload + SIZEOF_DNS_HDR) + SIZEOF_DNS_QUERY;
 80119fa:	484e      	ldr	r0, [pc, #312]	; (8011b34 <dns_recv+0x234>)
 80119fc:	f7ff fdb8 	bl	8011570 <dns_parse_name>
 8011a00:	4603      	mov	r3, r0
 8011a02:	f103 0304 	add.w	r3, r3, #4
 8011a06:	62fb      	str	r3, [r7, #44]	; 0x2c

        while(nanswers > 0) {
 8011a08:	e064      	b.n	8011ad4 <dns_recv+0x1d4>
          /* skip answer resource record's host name */
          pHostname = (char *) dns_parse_name((unsigned char *)pHostname);
 8011a0a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011a0c:	f7ff fdb0 	bl	8011570 <dns_parse_name>
 8011a10:	62f8      	str	r0, [r7, #44]	; 0x2c

          /* Check for IP address type and Internet class. Others are discarded. */
          MEMCPY(&ans, pHostname, SIZEOF_DNS_ANSWER);
 8011a12:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011a14:	f107 0310 	add.w	r3, r7, #16
 8011a18:	6810      	ldr	r0, [r2, #0]
 8011a1a:	6851      	ldr	r1, [r2, #4]
 8011a1c:	c303      	stmia	r3!, {r0, r1}
 8011a1e:	8912      	ldrh	r2, [r2, #8]
 8011a20:	801a      	strh	r2, [r3, #0]
          if((ntohs(ans.type) == DNS_RRTYPE_A) && (ntohs(ans.class) == DNS_RRCLASS_IN) && (ntohs(ans.len) == sizeof(struct ip_addr)) ) {
 8011a22:	8a3b      	ldrh	r3, [r7, #16]
 8011a24:	4618      	mov	r0, r3
 8011a26:	f007 fbaf 	bl	8019188 <ntohs>
 8011a2a:	4603      	mov	r3, r0
 8011a2c:	2b01      	cmp	r3, #1
 8011a2e:	d141      	bne.n	8011ab4 <dns_recv+0x1b4>
 8011a30:	8a7b      	ldrh	r3, [r7, #18]
 8011a32:	4618      	mov	r0, r3
 8011a34:	f007 fba8 	bl	8019188 <ntohs>
 8011a38:	4603      	mov	r3, r0
 8011a3a:	2b01      	cmp	r3, #1
 8011a3c:	d13a      	bne.n	8011ab4 <dns_recv+0x1b4>
 8011a3e:	8b3b      	ldrh	r3, [r7, #24]
 8011a40:	4618      	mov	r0, r3
 8011a42:	f007 fba1 	bl	8019188 <ntohs>
 8011a46:	4603      	mov	r3, r0
 8011a48:	2b04      	cmp	r3, #4
 8011a4a:	d133      	bne.n	8011ab4 <dns_recv+0x1b4>
            /* read the answer resource record's TTL, and maximize it if needed */
            pEntry->ttl = ntohl(ans.ttl);
 8011a4c:	697b      	ldr	r3, [r7, #20]
 8011a4e:	4618      	mov	r0, r3
 8011a50:	f007 fbc8 	bl	80191e4 <ntohl>
 8011a54:	4602      	mov	r2, r0
 8011a56:	69fb      	ldr	r3, [r7, #28]
 8011a58:	609a      	str	r2, [r3, #8]
            if (pEntry->ttl > DNS_MAX_TTL) {
 8011a5a:	69fb      	ldr	r3, [r7, #28]
 8011a5c:	689a      	ldr	r2, [r3, #8]
 8011a5e:	f44f 536a 	mov.w	r3, #14976	; 0x3a80
 8011a62:	f2c0 0309 	movt	r3, #9
 8011a66:	429a      	cmp	r2, r3
 8011a68:	d905      	bls.n	8011a76 <dns_recv+0x176>
              pEntry->ttl = DNS_MAX_TTL;
 8011a6a:	69fa      	ldr	r2, [r7, #28]
 8011a6c:	f44f 536a 	mov.w	r3, #14976	; 0x3a80
 8011a70:	f2c0 0309 	movt	r3, #9
 8011a74:	6093      	str	r3, [r2, #8]
            }
            /* read the IP address after answer resource record's header */
            MEMCPY( &(pEntry->ipaddr), (pHostname+SIZEOF_DNS_ANSWER), sizeof(struct ip_addr));
 8011a76:	69fb      	ldr	r3, [r7, #28]
 8011a78:	f503 7286 	add.w	r2, r3, #268	; 0x10c
 8011a7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011a7e:	f103 030a 	add.w	r3, r3, #10
 8011a82:	4610      	mov	r0, r2
 8011a84:	4619      	mov	r1, r3
 8011a86:	f04f 0204 	mov.w	r2, #4
 8011a8a:	f011 fdc3 	bl	8023614 <memcpy>
            LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", pEntry->name));
            ip_addr_debug_print(DNS_DEBUG, (&(pEntry->ipaddr)));
            LWIP_DEBUGF(DNS_DEBUG, ("\n"));
            /* call specified callback function if provided */
            if (pEntry->found) {
 8011a8e:	69fb      	ldr	r3, [r7, #28]
 8011a90:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8011a94:	2b00      	cmp	r3, #0
 8011a96:	d045      	beq.n	8011b24 <dns_recv+0x224>
              (*pEntry->found)(pEntry->name, &pEntry->ipaddr, pEntry->arg);
 8011a98:	69fb      	ldr	r3, [r7, #28]
 8011a9a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8011a9e:	69fa      	ldr	r2, [r7, #28]
 8011aa0:	f102 000c 	add.w	r0, r2, #12
 8011aa4:	69fa      	ldr	r2, [r7, #28]
 8011aa6:	f502 7186 	add.w	r1, r2, #268	; 0x10c
 8011aaa:	69fa      	ldr	r2, [r7, #28]
 8011aac:	f8d2 2114 	ldr.w	r2, [r2, #276]	; 0x114
 8011ab0:	4798      	blx	r3
            }
            /* deallocate memory and return */
            goto memerr2;
 8011ab2:	e037      	b.n	8011b24 <dns_recv+0x224>
          } else {
            pHostname = pHostname + SIZEOF_DNS_ANSWER + htons(ans.len);
 8011ab4:	8b3b      	ldrh	r3, [r7, #24]
 8011ab6:	4618      	mov	r0, r3
 8011ab8:	f007 fb4e 	bl	8019158 <htons>
 8011abc:	4603      	mov	r3, r0
 8011abe:	f103 030a 	add.w	r3, r3, #10
 8011ac2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011ac4:	18d3      	adds	r3, r2, r3
 8011ac6:	62fb      	str	r3, [r7, #44]	; 0x2c
          }
          --nanswers;
 8011ac8:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8011acc:	f103 33ff 	add.w	r3, r3, #4294967295
 8011ad0:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
#endif /* DNS_DOES_NAME_CHECK */

        /* Skip the name in the "question" part */
        pHostname = (char *) dns_parse_name((unsigned char *)dns_payload + SIZEOF_DNS_HDR) + SIZEOF_DNS_QUERY;

        while(nanswers > 0) {
 8011ad4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8011ad8:	2b00      	cmp	r3, #0
 8011ada:	d196      	bne.n	8011a0a <dns_recv+0x10a>
          }
          --nanswers;
        }
        LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", pEntry->name));
        /* call callback to indicate error, clean up memory and return */
        goto responseerr;
 8011adc:	e000      	b.n	8011ae0 <dns_recv+0x1e0>
#if DNS_DOES_NAME_CHECK
        /* Check if the name in the "question" part match with the name in the entry. */
        if (dns_compare_name((unsigned char *)(pEntry->name), (unsigned char *)dns_payload + SIZEOF_DNS_HDR) != 0) {
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", pEntry->name));
          /* call callback to indicate error, clean up memory and return */
          goto responseerr;
 8011ade:	bf00      	nop
  /* deallocate memory and return */
  goto memerr2;

responseerr:
  /* ERROR: call specified callback function with NULL as name to indicate an error */
  if (pEntry->found) {
 8011ae0:	69fb      	ldr	r3, [r7, #28]
 8011ae2:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8011ae6:	2b00      	cmp	r3, #0
 8011ae8:	d00c      	beq.n	8011b04 <dns_recv+0x204>
    (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
 8011aea:	69fb      	ldr	r3, [r7, #28]
 8011aec:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8011af0:	69fa      	ldr	r2, [r7, #28]
 8011af2:	f102 010c 	add.w	r1, r2, #12
 8011af6:	69fa      	ldr	r2, [r7, #28]
 8011af8:	f8d2 2114 	ldr.w	r2, [r2, #276]	; 0x114
 8011afc:	4608      	mov	r0, r1
 8011afe:	f04f 0100 	mov.w	r1, #0
 8011b02:	4798      	blx	r3
  }
  /* flush this entry */
  pEntry->state = DNS_STATE_UNUSED;
 8011b04:	69fb      	ldr	r3, [r7, #28]
 8011b06:	f04f 0200 	mov.w	r2, #0
 8011b0a:	701a      	strb	r2, [r3, #0]
  pEntry->found = NULL;
 8011b0c:	69fb      	ldr	r3, [r7, #28]
 8011b0e:	f04f 0200 	mov.w	r2, #0
 8011b12:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 8011b16:	e006      	b.n	8011b26 <dns_recv+0x226>

  /* is the dns message too big ? */
  if (p->tot_len > DNS_MSG_SIZE) {
    LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too big\n"));
    /* free pbuf and return */
    goto memerr1;
 8011b18:	bf00      	nop
 8011b1a:	e004      	b.n	8011b26 <dns_recv+0x226>

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {
    LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too small\n"));
    /* free pbuf and return */
    goto memerr1;
 8011b1c:	bf00      	nop
 8011b1e:	e002      	b.n	8011b26 <dns_recv+0x226>
      }
    }
  }

  /* deallocate memory and return */
  goto memerr2;
 8011b20:	bf00      	nop
 8011b22:	e000      	b.n	8011b26 <dns_recv+0x226>
            /* call specified callback function if provided */
            if (pEntry->found) {
              (*pEntry->found)(pEntry->name, &pEntry->ipaddr, pEntry->arg);
            }
            /* deallocate memory and return */
            goto memerr2;
 8011b24:	bf00      	nop
  mem_free(dns_payload);
#endif /* (DNS_USES_STATIC_BUF == 2) */

memerr1:
  /* free pbuf */
  pbuf_free(p);
 8011b26:	6878      	ldr	r0, [r7, #4]
 8011b28:	f001 f9ca 	bl	8012ec0 <pbuf_free>
  return;
}
 8011b2c:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8011b30:	46bd      	mov	sp, r7
 8011b32:	bd80      	pop	{r7, pc}
 8011b34:	20001328 	.word	0x20001328

08011b38 <dns_enqueue>:
 * @param callback_arg argument to pass to the callback function
 * @return @return a err_t return code.
 */
static err_t
dns_enqueue(const char *name, dns_found_callback found, void *callback_arg)
{
 8011b38:	b580      	push	{r7, lr}
 8011b3a:	b086      	sub	sp, #24
 8011b3c:	af00      	add	r7, sp, #0
 8011b3e:	60f8      	str	r0, [r7, #12]
 8011b40:	60b9      	str	r1, [r7, #8]
 8011b42:	607a      	str	r2, [r7, #4]
  u8_t i;
  u8_t lseq, lseqi;
  struct dns_table_entry *pEntry = NULL;
 8011b44:	f04f 0300 	mov.w	r3, #0
 8011b48:	613b      	str	r3, [r7, #16]

  /* search an unused entry, or the oldest one */
  lseq = lseqi = 0;
 8011b4a:	f04f 0300 	mov.w	r3, #0
 8011b4e:	757b      	strb	r3, [r7, #21]
 8011b50:	7d7b      	ldrb	r3, [r7, #21]
 8011b52:	75bb      	strb	r3, [r7, #22]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8011b54:	f04f 0300 	mov.w	r3, #0
 8011b58:	75fb      	strb	r3, [r7, #23]
 8011b5a:	e02d      	b.n	8011bb8 <dns_enqueue+0x80>
    pEntry = &dns_table[i];
 8011b5c:	7dfb      	ldrb	r3, [r7, #23]
 8011b5e:	f44f 728c 	mov.w	r2, #280	; 0x118
 8011b62:	fb02 f203 	mul.w	r2, r2, r3
 8011b66:	f640 63b4 	movw	r3, #3764	; 0xeb4
 8011b6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011b6e:	18d3      	adds	r3, r2, r3
 8011b70:	613b      	str	r3, [r7, #16]
    /* is it an unused entry ? */
    if (pEntry->state == DNS_STATE_UNUSED)
 8011b72:	693b      	ldr	r3, [r7, #16]
 8011b74:	781b      	ldrb	r3, [r3, #0]
 8011b76:	2b00      	cmp	r3, #0
 8011b78:	d022      	beq.n	8011bc0 <dns_enqueue+0x88>
      break;

    /* check if this is the oldest completed entry */
    if (pEntry->state == DNS_STATE_DONE) {
 8011b7a:	693b      	ldr	r3, [r7, #16]
 8011b7c:	781b      	ldrb	r3, [r3, #0]
 8011b7e:	2b03      	cmp	r3, #3
 8011b80:	d116      	bne.n	8011bb0 <dns_enqueue+0x78>
      if ((dns_seqno - pEntry->seqno) > lseq) {
 8011b82:	f640 63b0 	movw	r3, #3760	; 0xeb0
 8011b86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011b8a:	781b      	ldrb	r3, [r3, #0]
 8011b8c:	461a      	mov	r2, r3
 8011b8e:	693b      	ldr	r3, [r7, #16]
 8011b90:	791b      	ldrb	r3, [r3, #4]
 8011b92:	1ad2      	subs	r2, r2, r3
 8011b94:	7dbb      	ldrb	r3, [r7, #22]
 8011b96:	429a      	cmp	r2, r3
 8011b98:	dd0a      	ble.n	8011bb0 <dns_enqueue+0x78>
        lseq = dns_seqno - pEntry->seqno;
 8011b9a:	f640 63b0 	movw	r3, #3760	; 0xeb0
 8011b9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011ba2:	781a      	ldrb	r2, [r3, #0]
 8011ba4:	693b      	ldr	r3, [r7, #16]
 8011ba6:	791b      	ldrb	r3, [r3, #4]
 8011ba8:	1ad3      	subs	r3, r2, r3
 8011baa:	75bb      	strb	r3, [r7, #22]
        lseqi = i;
 8011bac:	7dfb      	ldrb	r3, [r7, #23]
 8011bae:	757b      	strb	r3, [r7, #21]
  u8_t lseq, lseqi;
  struct dns_table_entry *pEntry = NULL;

  /* search an unused entry, or the oldest one */
  lseq = lseqi = 0;
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8011bb0:	7dfb      	ldrb	r3, [r7, #23]
 8011bb2:	f103 0301 	add.w	r3, r3, #1
 8011bb6:	75fb      	strb	r3, [r7, #23]
 8011bb8:	7dfb      	ldrb	r3, [r7, #23]
 8011bba:	2b03      	cmp	r3, #3
 8011bbc:	d9ce      	bls.n	8011b5c <dns_enqueue+0x24>
 8011bbe:	e000      	b.n	8011bc2 <dns_enqueue+0x8a>
    pEntry = &dns_table[i];
    /* is it an unused entry ? */
    if (pEntry->state == DNS_STATE_UNUSED)
      break;
 8011bc0:	bf00      	nop
      }
    }
  }

  /* if we don't have found an unused entry, use the oldest completed one */
  if (i == DNS_TABLE_SIZE) {
 8011bc2:	7dfb      	ldrb	r3, [r7, #23]
 8011bc4:	2b04      	cmp	r3, #4
 8011bc6:	d11f      	bne.n	8011c08 <dns_enqueue+0xd0>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
 8011bc8:	7d7b      	ldrb	r3, [r7, #21]
 8011bca:	2b03      	cmp	r3, #3
 8011bcc:	d80c      	bhi.n	8011be8 <dns_enqueue+0xb0>
 8011bce:	7d7a      	ldrb	r2, [r7, #21]
 8011bd0:	f640 63b4 	movw	r3, #3764	; 0xeb4
 8011bd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011bd8:	f44f 718c 	mov.w	r1, #280	; 0x118
 8011bdc:	fb01 f202 	mul.w	r2, r1, r2
 8011be0:	189b      	adds	r3, r3, r2
 8011be2:	781b      	ldrb	r3, [r3, #0]
 8011be4:	2b03      	cmp	r3, #3
 8011be6:	d002      	beq.n	8011bee <dns_enqueue+0xb6>
      /* no entry can't be used now, table is full */
      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
      return ERR_MEM;
 8011be8:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8011bec:	e035      	b.n	8011c5a <dns_enqueue+0x122>
    } else {
      /* use the oldest completed one */
      i = lseqi;
 8011bee:	7d7b      	ldrb	r3, [r7, #21]
 8011bf0:	75fb      	strb	r3, [r7, #23]
      pEntry = &dns_table[i];
 8011bf2:	7dfb      	ldrb	r3, [r7, #23]
 8011bf4:	f44f 728c 	mov.w	r2, #280	; 0x118
 8011bf8:	fb02 f203 	mul.w	r2, r2, r3
 8011bfc:	f640 63b4 	movw	r3, #3764	; 0xeb4
 8011c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011c04:	18d3      	adds	r3, r2, r3
 8011c06:	613b      	str	r3, [r7, #16]

  /* use this entry */
  LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));

  /* fill the entry */
  pEntry->state = DNS_STATE_NEW;
 8011c08:	693b      	ldr	r3, [r7, #16]
 8011c0a:	f04f 0201 	mov.w	r2, #1
 8011c0e:	701a      	strb	r2, [r3, #0]
  pEntry->seqno = dns_seqno++;
 8011c10:	f640 63b0 	movw	r3, #3760	; 0xeb0
 8011c14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011c18:	781b      	ldrb	r3, [r3, #0]
 8011c1a:	693a      	ldr	r2, [r7, #16]
 8011c1c:	4619      	mov	r1, r3
 8011c1e:	7111      	strb	r1, [r2, #4]
 8011c20:	f103 0301 	add.w	r3, r3, #1
 8011c24:	b2da      	uxtb	r2, r3
 8011c26:	f640 63b0 	movw	r3, #3760	; 0xeb0
 8011c2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011c2e:	701a      	strb	r2, [r3, #0]
  pEntry->found = found;
 8011c30:	693b      	ldr	r3, [r7, #16]
 8011c32:	68ba      	ldr	r2, [r7, #8]
 8011c34:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  pEntry->arg   = callback_arg;
 8011c38:	693b      	ldr	r3, [r7, #16]
 8011c3a:	687a      	ldr	r2, [r7, #4]
 8011c3c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  strcpy(pEntry->name, name);
 8011c40:	693b      	ldr	r3, [r7, #16]
 8011c42:	f103 030c 	add.w	r3, r3, #12
 8011c46:	4618      	mov	r0, r3
 8011c48:	68f9      	ldr	r1, [r7, #12]
 8011c4a:	f012 ff1b 	bl	8024a84 <strcpy>

  /* force to send query without waiting timer */
  dns_check_entry(i);
 8011c4e:	7dfb      	ldrb	r3, [r7, #23]
 8011c50:	4618      	mov	r0, r3
 8011c52:	f7ff fd81 	bl	8011758 <dns_check_entry>

  /* dns query is enqueued */
  return ERR_INPROGRESS;
 8011c56:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 8011c5a:	b25b      	sxtb	r3, r3
}
 8011c5c:	4618      	mov	r0, r3
 8011c5e:	f107 0718 	add.w	r7, r7, #24
 8011c62:	46bd      	mov	sp, r7
 8011c64:	bd80      	pop	{r7, pc}
 8011c66:	bf00      	nop

08011c68 <dns_gethostbyname>:
 * @return a err_t return code.
 */
err_t
dns_gethostbyname(const char *hostname, struct ip_addr *addr, dns_found_callback found,
                  void *callback_arg)
{
 8011c68:	b580      	push	{r7, lr}
 8011c6a:	b084      	sub	sp, #16
 8011c6c:	af00      	add	r7, sp, #0
 8011c6e:	60f8      	str	r0, [r7, #12]
 8011c70:	60b9      	str	r1, [r7, #8]
 8011c72:	607a      	str	r2, [r7, #4]
 8011c74:	603b      	str	r3, [r7, #0]
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((dns_pcb == NULL) || (addr == NULL) ||
 8011c76:	f640 63ac 	movw	r3, #3756	; 0xeac
 8011c7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011c7e:	681b      	ldr	r3, [r3, #0]
 8011c80:	2b00      	cmp	r3, #0
 8011c82:	d00f      	beq.n	8011ca4 <dns_gethostbyname+0x3c>
 8011c84:	68bb      	ldr	r3, [r7, #8]
 8011c86:	2b00      	cmp	r3, #0
 8011c88:	d00c      	beq.n	8011ca4 <dns_gethostbyname+0x3c>
 8011c8a:	68fb      	ldr	r3, [r7, #12]
 8011c8c:	2b00      	cmp	r3, #0
 8011c8e:	d009      	beq.n	8011ca4 <dns_gethostbyname+0x3c>
      (!hostname) || (!hostname[0]) ||
 8011c90:	68fb      	ldr	r3, [r7, #12]
 8011c92:	781b      	ldrb	r3, [r3, #0]
 8011c94:	2b00      	cmp	r3, #0
 8011c96:	d005      	beq.n	8011ca4 <dns_gethostbyname+0x3c>
      (strlen(hostname) >= DNS_MAX_NAME_LENGTH)) {
 8011c98:	68f8      	ldr	r0, [r7, #12]
 8011c9a:	f012 ff51 	bl	8024b40 <strlen>
 8011c9e:	4603      	mov	r3, r0
                  void *callback_arg)
{
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((dns_pcb == NULL) || (addr == NULL) ||
      (!hostname) || (!hostname[0]) ||
 8011ca0:	2bff      	cmp	r3, #255	; 0xff
 8011ca2:	d902      	bls.n	8011caa <dns_gethostbyname+0x42>
      (strlen(hostname) >= DNS_MAX_NAME_LENGTH)) {
    return ERR_VAL;
 8011ca4:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8011ca8:	e01e      	b.n	8011ce8 <dns_gethostbyname+0x80>
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK
   * already have this address cached? */
  if (((addr->addr = inet_addr(hostname)) != INADDR_NONE) ||
 8011caa:	68f8      	ldr	r0, [r7, #12]
 8011cac:	f007 f880 	bl	8018db0 <inet_addr>
 8011cb0:	4602      	mov	r2, r0
 8011cb2:	68bb      	ldr	r3, [r7, #8]
 8011cb4:	601a      	str	r2, [r3, #0]
 8011cb6:	68bb      	ldr	r3, [r7, #8]
 8011cb8:	681b      	ldr	r3, [r3, #0]
 8011cba:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011cbe:	d10a      	bne.n	8011cd6 <dns_gethostbyname+0x6e>
      ((addr->addr = dns_lookup(hostname)) != INADDR_NONE)) {
 8011cc0:	68f8      	ldr	r0, [r7, #12]
 8011cc2:	f7ff fbd5 	bl	8011470 <dns_lookup>
 8011cc6:	4602      	mov	r2, r0
 8011cc8:	68bb      	ldr	r3, [r7, #8]
 8011cca:	601a      	str	r2, [r3, #0]
 8011ccc:	68bb      	ldr	r3, [r7, #8]
 8011cce:	681b      	ldr	r3, [r3, #0]
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK
   * already have this address cached? */
  if (((addr->addr = inet_addr(hostname)) != INADDR_NONE) ||
 8011cd0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011cd4:	d002      	beq.n	8011cdc <dns_gethostbyname+0x74>
      ((addr->addr = dns_lookup(hostname)) != INADDR_NONE)) {
    return ERR_OK;
 8011cd6:	f04f 0300 	mov.w	r3, #0
 8011cda:	e005      	b.n	8011ce8 <dns_gethostbyname+0x80>
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, found, callback_arg);
 8011cdc:	68f8      	ldr	r0, [r7, #12]
 8011cde:	6879      	ldr	r1, [r7, #4]
 8011ce0:	683a      	ldr	r2, [r7, #0]
 8011ce2:	f7ff ff29 	bl	8011b38 <dns_enqueue>
 8011ce6:	4603      	mov	r3, r0
 8011ce8:	b25b      	sxtb	r3, r3
}
 8011cea:	4618      	mov	r0, r3
 8011cec:	f107 0710 	add.w	r7, r7, #16
 8011cf0:	46bd      	mov	sp, r7
 8011cf2:	bd80      	pop	{r7, pc}

08011cf4 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 8011cf4:	b580      	push	{r7, lr}
 8011cf6:	af00      	add	r7, sp, #0
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  mem_init();
 8011cf8:	f000 f880 	bl	8011dfc <mem_init>
#endif /* LWIP_SNMP */
#if LWIP_AUTOIP
  autoip_init();
#endif /* LWIP_AUTOIP */
#if LWIP_IGMP
  igmp_init();
 8011cfc:	f006 fbec 	bl	80184d8 <igmp_init>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
 8011d00:	f7ff fb0c 	bl	801131c <dns_init>
#endif /* LWIP_DNS */
}
 8011d04:	bd80      	pop	{r7, pc}
 8011d06:	bf00      	nop

08011d08 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 8011d08:	b480      	push	{r7}
 8011d0a:	b085      	sub	sp, #20
 8011d0c:	af00      	add	r7, sp, #0
 8011d0e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)&ram[mem->next];
 8011d10:	f245 5330 	movw	r3, #21808	; 0x5530
 8011d14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011d18:	681a      	ldr	r2, [r3, #0]
 8011d1a:	687b      	ldr	r3, [r7, #4]
 8011d1c:	881b      	ldrh	r3, [r3, #0]
 8011d1e:	18d3      	adds	r3, r2, r3
 8011d20:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 8011d22:	687a      	ldr	r2, [r7, #4]
 8011d24:	68fb      	ldr	r3, [r7, #12]
 8011d26:	429a      	cmp	r2, r3
 8011d28:	d02e      	beq.n	8011d88 <plug_holes+0x80>
 8011d2a:	68fb      	ldr	r3, [r7, #12]
 8011d2c:	791b      	ldrb	r3, [r3, #4]
 8011d2e:	2b00      	cmp	r3, #0
 8011d30:	d12a      	bne.n	8011d88 <plug_holes+0x80>
 8011d32:	f245 5334 	movw	r3, #21812	; 0x5534
 8011d36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011d3a:	681b      	ldr	r3, [r3, #0]
 8011d3c:	68fa      	ldr	r2, [r7, #12]
 8011d3e:	429a      	cmp	r2, r3
 8011d40:	d022      	beq.n	8011d88 <plug_holes+0x80>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8011d42:	f245 5338 	movw	r3, #21816	; 0x5538
 8011d46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011d4a:	681a      	ldr	r2, [r3, #0]
 8011d4c:	68fb      	ldr	r3, [r7, #12]
 8011d4e:	429a      	cmp	r2, r3
 8011d50:	d105      	bne.n	8011d5e <plug_holes+0x56>
      lfree = mem;
 8011d52:	f245 5338 	movw	r3, #21816	; 0x5538
 8011d56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011d5a:	687a      	ldr	r2, [r7, #4]
 8011d5c:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
 8011d5e:	68fb      	ldr	r3, [r7, #12]
 8011d60:	881a      	ldrh	r2, [r3, #0]
 8011d62:	687b      	ldr	r3, [r7, #4]
 8011d64:	801a      	strh	r2, [r3, #0]
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
 8011d66:	f245 5330 	movw	r3, #21808	; 0x5530
 8011d6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011d6e:	681a      	ldr	r2, [r3, #0]
 8011d70:	68fb      	ldr	r3, [r7, #12]
 8011d72:	881b      	ldrh	r3, [r3, #0]
 8011d74:	18d2      	adds	r2, r2, r3
 8011d76:	6879      	ldr	r1, [r7, #4]
 8011d78:	f245 5330 	movw	r3, #21808	; 0x5530
 8011d7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011d80:	681b      	ldr	r3, [r3, #0]
 8011d82:	1acb      	subs	r3, r1, r3
 8011d84:	b29b      	uxth	r3, r3
 8011d86:	8053      	strh	r3, [r2, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
 8011d88:	f245 5330 	movw	r3, #21808	; 0x5530
 8011d8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011d90:	681a      	ldr	r2, [r3, #0]
 8011d92:	687b      	ldr	r3, [r7, #4]
 8011d94:	885b      	ldrh	r3, [r3, #2]
 8011d96:	18d3      	adds	r3, r2, r3
 8011d98:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
 8011d9a:	68ba      	ldr	r2, [r7, #8]
 8011d9c:	687b      	ldr	r3, [r7, #4]
 8011d9e:	429a      	cmp	r2, r3
 8011da0:	d026      	beq.n	8011df0 <plug_holes+0xe8>
 8011da2:	68bb      	ldr	r3, [r7, #8]
 8011da4:	791b      	ldrb	r3, [r3, #4]
 8011da6:	2b00      	cmp	r3, #0
 8011da8:	d122      	bne.n	8011df0 <plug_holes+0xe8>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 8011daa:	f245 5338 	movw	r3, #21816	; 0x5538
 8011dae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011db2:	681a      	ldr	r2, [r3, #0]
 8011db4:	687b      	ldr	r3, [r7, #4]
 8011db6:	429a      	cmp	r2, r3
 8011db8:	d105      	bne.n	8011dc6 <plug_holes+0xbe>
      lfree = pmem;
 8011dba:	f245 5338 	movw	r3, #21816	; 0x5538
 8011dbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011dc2:	68ba      	ldr	r2, [r7, #8]
 8011dc4:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
 8011dc6:	687b      	ldr	r3, [r7, #4]
 8011dc8:	881a      	ldrh	r2, [r3, #0]
 8011dca:	68bb      	ldr	r3, [r7, #8]
 8011dcc:	801a      	strh	r2, [r3, #0]
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
 8011dce:	f245 5330 	movw	r3, #21808	; 0x5530
 8011dd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011dd6:	681a      	ldr	r2, [r3, #0]
 8011dd8:	687b      	ldr	r3, [r7, #4]
 8011dda:	881b      	ldrh	r3, [r3, #0]
 8011ddc:	18d2      	adds	r2, r2, r3
 8011dde:	68b9      	ldr	r1, [r7, #8]
 8011de0:	f245 5330 	movw	r3, #21808	; 0x5530
 8011de4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011de8:	681b      	ldr	r3, [r3, #0]
 8011dea:	1acb      	subs	r3, r1, r3
 8011dec:	b29b      	uxth	r3, r3
 8011dee:	8053      	strh	r3, [r2, #2]
  }
}
 8011df0:	f107 0714 	add.w	r7, r7, #20
 8011df4:	46bd      	mov	sp, r7
 8011df6:	bc80      	pop	{r7}
 8011df8:	4770      	bx	lr
 8011dfa:	bf00      	nop

08011dfc <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8011dfc:	b480      	push	{r7}
 8011dfe:	b083      	sub	sp, #12
 8011e00:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
 8011e02:	f241 531c 	movw	r3, #5404	; 0x151c
 8011e06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e0a:	f103 0303 	add.w	r3, r3, #3
 8011e0e:	f023 0303 	bic.w	r3, r3, #3
 8011e12:	461a      	mov	r2, r3
 8011e14:	f245 5330 	movw	r3, #21808	; 0x5530
 8011e18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e1c:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
 8011e1e:	f245 5330 	movw	r3, #21808	; 0x5530
 8011e22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e26:	681b      	ldr	r3, [r3, #0]
 8011e28:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
 8011e2a:	687b      	ldr	r3, [r7, #4]
 8011e2c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8011e30:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 8011e32:	687b      	ldr	r3, [r7, #4]
 8011e34:	f04f 0200 	mov.w	r2, #0
 8011e38:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 8011e3a:	687b      	ldr	r3, [r7, #4]
 8011e3c:	f04f 0200 	mov.w	r2, #0
 8011e40:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
 8011e42:	f245 5330 	movw	r3, #21808	; 0x5530
 8011e46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e4a:	681b      	ldr	r3, [r3, #0]
 8011e4c:	f503 4280 	add.w	r2, r3, #16384	; 0x4000
 8011e50:	f245 5334 	movw	r3, #21812	; 0x5534
 8011e54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e58:	601a      	str	r2, [r3, #0]
  ram_end->used = 1;
 8011e5a:	f245 5334 	movw	r3, #21812	; 0x5534
 8011e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e62:	681b      	ldr	r3, [r3, #0]
 8011e64:	f04f 0201 	mov.w	r2, #1
 8011e68:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8011e6a:	f245 5334 	movw	r3, #21812	; 0x5534
 8011e6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e72:	681b      	ldr	r3, [r3, #0]
 8011e74:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8011e78:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 8011e7a:	f245 5334 	movw	r3, #21812	; 0x5534
 8011e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e82:	681b      	ldr	r3, [r3, #0]
 8011e84:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8011e88:	805a      	strh	r2, [r3, #2]

  mem_sem = sys_sem_new(1);
 8011e8a:	f245 533c 	movw	r3, #21820	; 0x553c
 8011e8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011e92:	f04f 0201 	mov.w	r2, #1
 8011e96:	701a      	strb	r2, [r3, #0]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
 8011e98:	f245 5330 	movw	r3, #21808	; 0x5530
 8011e9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011ea0:	681a      	ldr	r2, [r3, #0]
 8011ea2:	f245 5338 	movw	r3, #21816	; 0x5538
 8011ea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011eaa:	601a      	str	r2, [r3, #0]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
 8011eac:	f107 070c 	add.w	r7, r7, #12
 8011eb0:	46bd      	mov	sp, r7
 8011eb2:	bc80      	pop	{r7}
 8011eb4:	4770      	bx	lr
 8011eb6:	bf00      	nop

08011eb8 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 8011eb8:	b580      	push	{r7, lr}
 8011eba:	b084      	sub	sp, #16
 8011ebc:	af00      	add	r7, sp, #0
 8011ebe:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 8011ec0:	687b      	ldr	r3, [r7, #4]
 8011ec2:	2b00      	cmp	r3, #0
 8011ec4:	d030      	beq.n	8011f28 <mem_free+0x70>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8011ec6:	f245 5330 	movw	r3, #21808	; 0x5530
 8011eca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011ece:	681b      	ldr	r3, [r3, #0]
 8011ed0:	687a      	ldr	r2, [r7, #4]
 8011ed2:	429a      	cmp	r2, r3
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8011ed4:	f245 5330 	movw	r3, #21808	; 0x5530
 8011ed8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011edc:	681b      	ldr	r3, [r3, #0]
 8011ede:	687a      	ldr	r2, [r7, #4]
 8011ee0:	429a      	cmp	r2, r3
 8011ee2:	d323      	bcc.n	8011f2c <mem_free+0x74>
 8011ee4:	f245 5334 	movw	r3, #21812	; 0x5534
 8011ee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011eec:	681b      	ldr	r3, [r3, #0]
 8011eee:	687a      	ldr	r2, [r7, #4]
 8011ef0:	429a      	cmp	r2, r3
 8011ef2:	d21b      	bcs.n	8011f2c <mem_free+0x74>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8011ef4:	687b      	ldr	r3, [r7, #4]
 8011ef6:	f1a3 0308 	sub.w	r3, r3, #8
 8011efa:	60fb      	str	r3, [r7, #12]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 8011efc:	68fb      	ldr	r3, [r7, #12]
 8011efe:	f04f 0200 	mov.w	r2, #0
 8011f02:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 8011f04:	f245 5338 	movw	r3, #21816	; 0x5538
 8011f08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011f0c:	681b      	ldr	r3, [r3, #0]
 8011f0e:	68fa      	ldr	r2, [r7, #12]
 8011f10:	429a      	cmp	r2, r3
 8011f12:	d205      	bcs.n	8011f20 <mem_free+0x68>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 8011f14:	f245 5338 	movw	r3, #21816	; 0x5538
 8011f18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011f1c:	68fa      	ldr	r2, [r7, #12]
 8011f1e:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 8011f20:	68f8      	ldr	r0, [r7, #12]
 8011f22:	f7ff fef1 	bl	8011d08 <plug_holes>
 8011f26:	e002      	b.n	8011f2e <mem_free+0x76>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
 8011f28:	bf00      	nop
 8011f2a:	e000      	b.n	8011f2e <mem_free+0x76>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
 8011f2c:	bf00      	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 8011f2e:	f107 0710 	add.w	r7, r7, #16
 8011f32:	46bd      	mov	sp, r7
 8011f34:	bd80      	pop	{r7, pc}
 8011f36:	bf00      	nop

08011f38 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
 8011f38:	b480      	push	{r7}
 8011f3a:	b087      	sub	sp, #28
 8011f3c:	af00      	add	r7, sp, #0
 8011f3e:	6078      	str	r0, [r7, #4]
 8011f40:	460b      	mov	r3, r1
 8011f42:	807b      	strh	r3, [r7, #2]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8011f44:	887b      	ldrh	r3, [r7, #2]
 8011f46:	f103 0303 	add.w	r3, r3, #3
 8011f4a:	b29b      	uxth	r3, r3
 8011f4c:	f023 0303 	bic.w	r3, r3, #3
 8011f50:	807b      	strh	r3, [r7, #2]

  if(newsize < MIN_SIZE_ALIGNED) {
 8011f52:	887b      	ldrh	r3, [r7, #2]
 8011f54:	2b0b      	cmp	r3, #11
 8011f56:	d802      	bhi.n	8011f5e <mem_realloc+0x26>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 8011f58:	f04f 030c 	mov.w	r3, #12
 8011f5c:	807b      	strh	r3, [r7, #2]
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 8011f5e:	887b      	ldrh	r3, [r7, #2]
 8011f60:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8011f64:	d902      	bls.n	8011f6c <mem_realloc+0x34>
    return NULL;
 8011f66:	f04f 0300 	mov.w	r3, #0
 8011f6a:	e0ca      	b.n	8012102 <mem_realloc+0x1ca>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8011f6c:	f245 5330 	movw	r3, #21808	; 0x5530
 8011f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011f74:	681b      	ldr	r3, [r3, #0]
 8011f76:	687a      	ldr	r2, [r7, #4]
 8011f78:	429a      	cmp	r2, r3
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8011f7a:	f245 5330 	movw	r3, #21808	; 0x5530
 8011f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011f82:	681b      	ldr	r3, [r3, #0]
 8011f84:	687a      	ldr	r2, [r7, #4]
 8011f86:	429a      	cmp	r2, r3
 8011f88:	d307      	bcc.n	8011f9a <mem_realloc+0x62>
 8011f8a:	f245 5334 	movw	r3, #21812	; 0x5534
 8011f8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011f92:	681b      	ldr	r3, [r3, #0]
 8011f94:	687a      	ldr	r2, [r7, #4]
 8011f96:	429a      	cmp	r2, r3
 8011f98:	d301      	bcc.n	8011f9e <mem_realloc+0x66>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
 8011f9a:	687b      	ldr	r3, [r7, #4]
 8011f9c:	e0b1      	b.n	8012102 <mem_realloc+0x1ca>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8011f9e:	687b      	ldr	r3, [r7, #4]
 8011fa0:	f1a3 0308 	sub.w	r3, r3, #8
 8011fa4:	617b      	str	r3, [r7, #20]
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
 8011fa6:	697a      	ldr	r2, [r7, #20]
 8011fa8:	f245 5330 	movw	r3, #21808	; 0x5530
 8011fac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011fb0:	681b      	ldr	r3, [r3, #0]
 8011fb2:	1ad3      	subs	r3, r2, r3
 8011fb4:	827b      	strh	r3, [r7, #18]

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 8011fb6:	697b      	ldr	r3, [r7, #20]
 8011fb8:	881a      	ldrh	r2, [r3, #0]
 8011fba:	8a7b      	ldrh	r3, [r7, #18]
 8011fbc:	1ad3      	subs	r3, r2, r3
 8011fbe:	b29b      	uxth	r3, r3
 8011fc0:	f1a3 0308 	sub.w	r3, r3, #8
 8011fc4:	823b      	strh	r3, [r7, #16]
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
 8011fc6:	887a      	ldrh	r2, [r7, #2]
 8011fc8:	8a3b      	ldrh	r3, [r7, #16]
 8011fca:	429a      	cmp	r2, r3
 8011fcc:	d902      	bls.n	8011fd4 <mem_realloc+0x9c>
    /* not supported */
    return NULL;
 8011fce:	f04f 0300 	mov.w	r3, #0
 8011fd2:	e096      	b.n	8012102 <mem_realloc+0x1ca>
  }
  if (newsize == size) {
 8011fd4:	887a      	ldrh	r2, [r7, #2]
 8011fd6:	8a3b      	ldrh	r3, [r7, #16]
 8011fd8:	429a      	cmp	r2, r3
 8011fda:	d101      	bne.n	8011fe0 <mem_realloc+0xa8>
    /* No change in size, simply return */
    return rmem;
 8011fdc:	687b      	ldr	r3, [r7, #4]
 8011fde:	e090      	b.n	8012102 <mem_realloc+0x1ca>
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
 8011fe0:	f245 5330 	movw	r3, #21808	; 0x5530
 8011fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8011fe8:	681a      	ldr	r2, [r3, #0]
 8011fea:	697b      	ldr	r3, [r7, #20]
 8011fec:	881b      	ldrh	r3, [r3, #0]
 8011fee:	18d3      	adds	r3, r2, r3
 8011ff0:	60fb      	str	r3, [r7, #12]
  if(mem2->used == 0) {
 8011ff2:	68fb      	ldr	r3, [r7, #12]
 8011ff4:	791b      	ldrb	r3, [r3, #4]
 8011ff6:	2b00      	cmp	r3, #0
 8011ff8:	d142      	bne.n	8012080 <mem_realloc+0x148>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 8011ffa:	68fb      	ldr	r3, [r7, #12]
 8011ffc:	881b      	ldrh	r3, [r3, #0]
 8011ffe:	817b      	strh	r3, [r7, #10]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8012000:	8a7a      	ldrh	r2, [r7, #18]
 8012002:	887b      	ldrh	r3, [r7, #2]
 8012004:	18d3      	adds	r3, r2, r3
 8012006:	b29b      	uxth	r3, r3
 8012008:	f103 0308 	add.w	r3, r3, #8
 801200c:	813b      	strh	r3, [r7, #8]
    if (lfree == mem2) {
 801200e:	f245 5338 	movw	r3, #21816	; 0x5538
 8012012:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012016:	681a      	ldr	r2, [r3, #0]
 8012018:	68fb      	ldr	r3, [r7, #12]
 801201a:	429a      	cmp	r2, r3
 801201c:	d10b      	bne.n	8012036 <mem_realloc+0xfe>
      lfree = (struct mem *)&ram[ptr2];
 801201e:	f245 5330 	movw	r3, #21808	; 0x5530
 8012022:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012026:	681a      	ldr	r2, [r3, #0]
 8012028:	893b      	ldrh	r3, [r7, #8]
 801202a:	18d2      	adds	r2, r2, r3
 801202c:	f245 5338 	movw	r3, #21816	; 0x5538
 8012030:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012034:	601a      	str	r2, [r3, #0]
    }
    mem2 = (struct mem *)&ram[ptr2];
 8012036:	f245 5330 	movw	r3, #21808	; 0x5530
 801203a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801203e:	681a      	ldr	r2, [r3, #0]
 8012040:	893b      	ldrh	r3, [r7, #8]
 8012042:	18d3      	adds	r3, r2, r3
 8012044:	60fb      	str	r3, [r7, #12]
    mem2->used = 0;
 8012046:	68fb      	ldr	r3, [r7, #12]
 8012048:	f04f 0200 	mov.w	r2, #0
 801204c:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 801204e:	68fb      	ldr	r3, [r7, #12]
 8012050:	897a      	ldrh	r2, [r7, #10]
 8012052:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 8012054:	68fb      	ldr	r3, [r7, #12]
 8012056:	8a7a      	ldrh	r2, [r7, #18]
 8012058:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 801205a:	697b      	ldr	r3, [r7, #20]
 801205c:	893a      	ldrh	r2, [r7, #8]
 801205e:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8012060:	68fb      	ldr	r3, [r7, #12]
 8012062:	881b      	ldrh	r3, [r3, #0]
 8012064:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8012068:	d04a      	beq.n	8012100 <mem_realloc+0x1c8>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
 801206a:	f245 5330 	movw	r3, #21808	; 0x5530
 801206e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012072:	681a      	ldr	r2, [r3, #0]
 8012074:	68fb      	ldr	r3, [r7, #12]
 8012076:	881b      	ldrh	r3, [r3, #0]
 8012078:	18d3      	adds	r3, r2, r3
 801207a:	893a      	ldrh	r2, [r7, #8]
 801207c:	805a      	strh	r2, [r3, #2]
 801207e:	e03f      	b.n	8012100 <mem_realloc+0x1c8>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8012080:	887b      	ldrh	r3, [r7, #2]
 8012082:	f103 0214 	add.w	r2, r3, #20
 8012086:	8a3b      	ldrh	r3, [r7, #16]
 8012088:	429a      	cmp	r2, r3
 801208a:	d839      	bhi.n	8012100 <mem_realloc+0x1c8>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 801208c:	8a7a      	ldrh	r2, [r7, #18]
 801208e:	887b      	ldrh	r3, [r7, #2]
 8012090:	18d3      	adds	r3, r2, r3
 8012092:	b29b      	uxth	r3, r3
 8012094:	f103 0308 	add.w	r3, r3, #8
 8012098:	813b      	strh	r3, [r7, #8]
    mem2 = (struct mem *)&ram[ptr2];
 801209a:	f245 5330 	movw	r3, #21808	; 0x5530
 801209e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80120a2:	681a      	ldr	r2, [r3, #0]
 80120a4:	893b      	ldrh	r3, [r7, #8]
 80120a6:	18d3      	adds	r3, r2, r3
 80120a8:	60fb      	str	r3, [r7, #12]
    if (mem2 < lfree) {
 80120aa:	f245 5338 	movw	r3, #21816	; 0x5538
 80120ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80120b2:	681b      	ldr	r3, [r3, #0]
 80120b4:	68fa      	ldr	r2, [r7, #12]
 80120b6:	429a      	cmp	r2, r3
 80120b8:	d205      	bcs.n	80120c6 <mem_realloc+0x18e>
      lfree = mem2;
 80120ba:	f245 5338 	movw	r3, #21816	; 0x5538
 80120be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80120c2:	68fa      	ldr	r2, [r7, #12]
 80120c4:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
 80120c6:	68fb      	ldr	r3, [r7, #12]
 80120c8:	f04f 0200 	mov.w	r2, #0
 80120cc:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 80120ce:	697b      	ldr	r3, [r7, #20]
 80120d0:	881a      	ldrh	r2, [r3, #0]
 80120d2:	68fb      	ldr	r3, [r7, #12]
 80120d4:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 80120d6:	68fb      	ldr	r3, [r7, #12]
 80120d8:	8a7a      	ldrh	r2, [r7, #18]
 80120da:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 80120dc:	697b      	ldr	r3, [r7, #20]
 80120de:	893a      	ldrh	r2, [r7, #8]
 80120e0:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80120e2:	68fb      	ldr	r3, [r7, #12]
 80120e4:	881b      	ldrh	r3, [r3, #0]
 80120e6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80120ea:	d009      	beq.n	8012100 <mem_realloc+0x1c8>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
 80120ec:	f245 5330 	movw	r3, #21808	; 0x5530
 80120f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80120f4:	681a      	ldr	r2, [r3, #0]
 80120f6:	68fb      	ldr	r3, [r7, #12]
 80120f8:	881b      	ldrh	r3, [r3, #0]
 80120fa:	18d3      	adds	r3, r2, r3
 80120fc:	893a      	ldrh	r2, [r7, #8]
 80120fe:	805a      	strh	r2, [r3, #2]
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
 8012100:	687b      	ldr	r3, [r7, #4]
}
 8012102:	4618      	mov	r0, r3
 8012104:	f107 071c 	add.w	r7, r7, #28
 8012108:	46bd      	mov	sp, r7
 801210a:	bc80      	pop	{r7}
 801210c:	4770      	bx	lr
 801210e:	bf00      	nop

08012110 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 8012110:	b480      	push	{r7}
 8012112:	b087      	sub	sp, #28
 8012114:	af00      	add	r7, sp, #0
 8012116:	4603      	mov	r3, r0
 8012118:	80fb      	strh	r3, [r7, #6]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 801211a:	88fb      	ldrh	r3, [r7, #6]
 801211c:	2b00      	cmp	r3, #0
 801211e:	d102      	bne.n	8012126 <mem_malloc+0x16>
    return NULL;
 8012120:	f04f 0300 	mov.w	r3, #0
 8012124:	e0c8      	b.n	80122b8 <mem_malloc+0x1a8>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 8012126:	88fb      	ldrh	r3, [r7, #6]
 8012128:	f103 0303 	add.w	r3, r3, #3
 801212c:	b29b      	uxth	r3, r3
 801212e:	f023 0303 	bic.w	r3, r3, #3
 8012132:	80fb      	strh	r3, [r7, #6]

  if(size < MIN_SIZE_ALIGNED) {
 8012134:	88fb      	ldrh	r3, [r7, #6]
 8012136:	2b0b      	cmp	r3, #11
 8012138:	d802      	bhi.n	8012140 <mem_malloc+0x30>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 801213a:	f04f 030c 	mov.w	r3, #12
 801213e:	80fb      	strh	r3, [r7, #6]
  }

  if (size > MEM_SIZE_ALIGNED) {
 8012140:	88fb      	ldrh	r3, [r7, #6]
 8012142:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8012146:	d902      	bls.n	801214e <mem_malloc+0x3e>
    return NULL;
 8012148:	f04f 0300 	mov.w	r3, #0
 801214c:	e0b4      	b.n	80122b8 <mem_malloc+0x1a8>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
 801214e:	f245 5338 	movw	r3, #21816	; 0x5538
 8012152:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012156:	681b      	ldr	r3, [r3, #0]
 8012158:	461a      	mov	r2, r3
 801215a:	f245 5330 	movw	r3, #21808	; 0x5530
 801215e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012162:	681b      	ldr	r3, [r3, #0]
 8012164:	1ad3      	subs	r3, r2, r3
 8012166:	82fb      	strh	r3, [r7, #22]
 8012168:	e09d      	b.n	80122a6 <mem_malloc+0x196>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
 801216a:	f245 5330 	movw	r3, #21808	; 0x5530
 801216e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012172:	681a      	ldr	r2, [r3, #0]
 8012174:	8afb      	ldrh	r3, [r7, #22]
 8012176:	18d3      	adds	r3, r2, r3
 8012178:	613b      	str	r3, [r7, #16]
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 801217a:	693b      	ldr	r3, [r7, #16]
 801217c:	791b      	ldrb	r3, [r3, #4]
 801217e:	2b00      	cmp	r3, #0
 8012180:	f040 8088 	bne.w	8012294 <mem_malloc+0x184>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 8012184:	693b      	ldr	r3, [r7, #16]
 8012186:	881b      	ldrh	r3, [r3, #0]
 8012188:	461a      	mov	r2, r3
 801218a:	8afb      	ldrh	r3, [r7, #22]
 801218c:	1ad3      	subs	r3, r2, r3
 801218e:	f1a3 0208 	sub.w	r2, r3, #8
 8012192:	88fb      	ldrh	r3, [r7, #6]
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 8012194:	429a      	cmp	r2, r3
 8012196:	d37d      	bcc.n	8012294 <mem_malloc+0x184>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 8012198:	693b      	ldr	r3, [r7, #16]
 801219a:	881b      	ldrh	r3, [r3, #0]
 801219c:	461a      	mov	r2, r3
 801219e:	8afb      	ldrh	r3, [r7, #22]
 80121a0:	1ad3      	subs	r3, r2, r3
 80121a2:	f1a3 0208 	sub.w	r2, r3, #8
 80121a6:	88fb      	ldrh	r3, [r7, #6]
 80121a8:	f103 0314 	add.w	r3, r3, #20
 80121ac:	429a      	cmp	r2, r3
 80121ae:	d330      	bcc.n	8012212 <mem_malloc+0x102>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 80121b0:	8afa      	ldrh	r2, [r7, #22]
 80121b2:	88fb      	ldrh	r3, [r7, #6]
 80121b4:	18d3      	adds	r3, r2, r3
 80121b6:	b29b      	uxth	r3, r3
 80121b8:	f103 0308 	add.w	r3, r3, #8
 80121bc:	81fb      	strh	r3, [r7, #14]
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
 80121be:	f245 5330 	movw	r3, #21808	; 0x5530
 80121c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80121c6:	681a      	ldr	r2, [r3, #0]
 80121c8:	89fb      	ldrh	r3, [r7, #14]
 80121ca:	18d3      	adds	r3, r2, r3
 80121cc:	60bb      	str	r3, [r7, #8]
          mem2->used = 0;
 80121ce:	68bb      	ldr	r3, [r7, #8]
 80121d0:	f04f 0200 	mov.w	r2, #0
 80121d4:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 80121d6:	693b      	ldr	r3, [r7, #16]
 80121d8:	881a      	ldrh	r2, [r3, #0]
 80121da:	68bb      	ldr	r3, [r7, #8]
 80121dc:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 80121de:	68bb      	ldr	r3, [r7, #8]
 80121e0:	8afa      	ldrh	r2, [r7, #22]
 80121e2:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 80121e4:	693b      	ldr	r3, [r7, #16]
 80121e6:	89fa      	ldrh	r2, [r7, #14]
 80121e8:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 80121ea:	693b      	ldr	r3, [r7, #16]
 80121ec:	f04f 0201 	mov.w	r2, #1
 80121f0:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 80121f2:	68bb      	ldr	r3, [r7, #8]
 80121f4:	881b      	ldrh	r3, [r3, #0]
 80121f6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80121fa:	d00e      	beq.n	801221a <mem_malloc+0x10a>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
 80121fc:	f245 5330 	movw	r3, #21808	; 0x5530
 8012200:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012204:	681a      	ldr	r2, [r3, #0]
 8012206:	68bb      	ldr	r3, [r7, #8]
 8012208:	881b      	ldrh	r3, [r3, #0]
 801220a:	18d3      	adds	r3, r2, r3
 801220c:	89fa      	ldrh	r2, [r7, #14]
 801220e:	805a      	strh	r2, [r3, #2]
 8012210:	e003      	b.n	801221a <mem_malloc+0x10a>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8012212:	693b      	ldr	r3, [r7, #16]
 8012214:	f04f 0201 	mov.w	r2, #1
 8012218:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
 801221a:	f245 5338 	movw	r3, #21816	; 0x5538
 801221e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012222:	681b      	ldr	r3, [r3, #0]
 8012224:	693a      	ldr	r2, [r7, #16]
 8012226:	429a      	cmp	r2, r3
 8012228:	d130      	bne.n	801228c <mem_malloc+0x17c>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
 801222a:	e010      	b.n	801224e <mem_malloc+0x13e>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
 801222c:	f245 5330 	movw	r3, #21808	; 0x5530
 8012230:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012234:	681a      	ldr	r2, [r3, #0]
 8012236:	f245 5338 	movw	r3, #21816	; 0x5538
 801223a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801223e:	681b      	ldr	r3, [r3, #0]
 8012240:	881b      	ldrh	r3, [r3, #0]
 8012242:	18d2      	adds	r2, r2, r3
 8012244:	f245 5338 	movw	r3, #21816	; 0x5538
 8012248:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801224c:	601a      	str	r2, [r3, #0]
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
 801224e:	f245 5338 	movw	r3, #21816	; 0x5538
 8012252:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012256:	681b      	ldr	r3, [r3, #0]
 8012258:	791b      	ldrb	r3, [r3, #4]
 801225a:	2b00      	cmp	r3, #0
 801225c:	d00b      	beq.n	8012276 <mem_malloc+0x166>
 801225e:	f245 5338 	movw	r3, #21816	; 0x5538
 8012262:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012266:	681a      	ldr	r2, [r3, #0]
 8012268:	f245 5334 	movw	r3, #21812	; 0x5534
 801226c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012270:	681b      	ldr	r3, [r3, #0]
 8012272:	429a      	cmp	r2, r3
 8012274:	d1da      	bne.n	801222c <mem_malloc+0x11c>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 8012276:	f245 5338 	movw	r3, #21816	; 0x5538
 801227a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801227e:	681a      	ldr	r2, [r3, #0]
 8012280:	f245 5334 	movw	r3, #21812	; 0x5534
 8012284:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012288:	681b      	ldr	r3, [r3, #0]
 801228a:	429a      	cmp	r2, r3
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 801228c:	693b      	ldr	r3, [r7, #16]
 801228e:	f103 0308 	add.w	r3, r3, #8
 8012292:	e011      	b.n	80122b8 <mem_malloc+0x1a8>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
 8012294:	f245 5330 	movw	r3, #21808	; 0x5530
 8012298:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801229c:	681a      	ldr	r2, [r3, #0]
 801229e:	8afb      	ldrh	r3, [r7, #22]
 80122a0:	18d3      	adds	r3, r2, r3
 80122a2:	881b      	ldrh	r3, [r3, #0]
 80122a4:	82fb      	strh	r3, [r7, #22]
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
 80122a6:	8afa      	ldrh	r2, [r7, #22]
 80122a8:	88fb      	ldrh	r3, [r7, #6]
 80122aa:	f5c3 4380 	rsb	r3, r3, #16384	; 0x4000
 80122ae:	429a      	cmp	r2, r3
 80122b0:	f6ff af5b 	blt.w	801216a <mem_malloc+0x5a>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
 80122b4:	f04f 0300 	mov.w	r3, #0
}
 80122b8:	4618      	mov	r0, r3
 80122ba:	f107 071c 	add.w	r7, r7, #28
 80122be:	46bd      	mov	sp, r7
 80122c0:	bc80      	pop	{r7}
 80122c2:	4770      	bx	lr

080122c4 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
 80122c4:	b580      	push	{r7, lr}
 80122c6:	b084      	sub	sp, #16
 80122c8:	af00      	add	r7, sp, #0
 80122ca:	4602      	mov	r2, r0
 80122cc:	460b      	mov	r3, r1
 80122ce:	80fa      	strh	r2, [r7, #6]
 80122d0:	80bb      	strh	r3, [r7, #4]
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
 80122d2:	88fb      	ldrh	r3, [r7, #6]
 80122d4:	88ba      	ldrh	r2, [r7, #4]
 80122d6:	fb02 f303 	mul.w	r3, r2, r3
 80122da:	b29b      	uxth	r3, r3
 80122dc:	4618      	mov	r0, r3
 80122de:	f7ff ff17 	bl	8012110 <mem_malloc>
 80122e2:	60f8      	str	r0, [r7, #12]
  if (p) {
 80122e4:	68fb      	ldr	r3, [r7, #12]
 80122e6:	2b00      	cmp	r3, #0
 80122e8:	d009      	beq.n	80122fe <mem_calloc+0x3a>
    /* zero the memory */
    memset(p, 0, count * size);
 80122ea:	88fb      	ldrh	r3, [r7, #6]
 80122ec:	88ba      	ldrh	r2, [r7, #4]
 80122ee:	fb02 f303 	mul.w	r3, r2, r3
 80122f2:	68f8      	ldr	r0, [r7, #12]
 80122f4:	f04f 0100 	mov.w	r1, #0
 80122f8:	461a      	mov	r2, r3
 80122fa:	f011 faf9 	bl	80238f0 <memset>
  }
  return p;
 80122fe:	68fb      	ldr	r3, [r7, #12]
}
 8012300:	4618      	mov	r0, r3
 8012302:	f107 0710 	add.w	r7, r7, #16
 8012306:	46bd      	mov	sp, r7
 8012308:	bd80      	pop	{r7, pc}
 801230a:	bf00      	nop

0801230c <Periodic_Timer_CallBack>:
 * @return DAVEApp_SUCCESS on success error code otherwise

*/

void Periodic_Timer_CallBack()
{
 801230c:	b580      	push	{r7, lr}
 801230e:	af00      	add	r7, sp, #0
  LwIP_Periodic_Timer_CallBack(NULL);
 8012310:	f04f 0000 	mov.w	r0, #0
 8012314:	f000 f936 	bl	8012584 <LwIP_Periodic_Timer_CallBack>
}
 8012318:	bd80      	pop	{r7, pc}
 801231a:	bf00      	nop

0801231c <Ethernetwait_Timer_CallBack>:

void  Ethernetwait_Timer_CallBack(void* Temp)
{
 801231c:	b480      	push	{r7}
 801231e:	b083      	sub	sp, #12
 8012320:	af00      	add	r7, sp, #0
 8012322:	6078      	str	r0, [r7, #4]
    EthernetTimer = FALSE;
 8012324:	f246 63f6 	movw	r3, #26358	; 0x66f6
 8012328:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801232c:	f04f 0200 	mov.w	r2, #0
 8012330:	701a      	strb	r2, [r3, #0]
}
 8012332:	f107 070c 	add.w	r7, r7, #12
 8012336:	46bd      	mov	sp, r7
 8012338:	bc80      	pop	{r7}
 801233a:	4770      	bx	lr

0801233c <OneShotTimerCallback>:

void OneShotTimerCallback(u32 count)
{
 801233c:	b580      	push	{r7, lr}
 801233e:	b084      	sub	sp, #16
 8012340:	af00      	add	r7, sp, #0
 8012342:	6078      	str	r0, [r7, #4]
#if !NO_SYS
  RTOS001_TaskDelay(count);
#else
  handle_t TimerId;
  status_t Status = 10;
 8012344:	f04f 030a 	mov.w	r3, #10
 8012348:	60fb      	str	r3, [r7, #12]
    EthernetTimer = TRUE;
 801234a:	f246 63f6 	movw	r3, #26358	; 0x66f6
 801234e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012352:	f04f 0201 	mov.w	r2, #1
 8012356:	701a      	strb	r2, [r3, #0]
  TimerId = SYSTM001_CreateTimer(count,SYSTM001_ONE_SHOT, Ethernetwait_Timer_CallBack,NULL);
 8012358:	6878      	ldr	r0, [r7, #4]
 801235a:	f04f 0100 	mov.w	r1, #0
 801235e:	f242 321d 	movw	r2, #8989	; 0x231d
 8012362:	f6c0 0201 	movt	r2, #2049	; 0x801
 8012366:	f04f 0300 	mov.w	r3, #0
 801236a:	f7f1 ffb9 	bl	80042e0 <SYSTM001_CreateTimer>
 801236e:	60b8      	str	r0, [r7, #8]
      if(TimerId != 0)
 8012370:	68bb      	ldr	r3, [r7, #8]
 8012372:	2b00      	cmp	r3, #0
 8012374:	d012      	beq.n	801239c <OneShotTimerCallback+0x60>
      {
        Status = SYSTM001_StartTimer(TimerId);
 8012376:	68b8      	ldr	r0, [r7, #8]
 8012378:	f7f2 f882 	bl	8004480 <SYSTM001_StartTimer>
 801237c:	60f8      	str	r0, [r7, #12]
        if(Status == DAVEApp_SUCCESS)
 801237e:	68fb      	ldr	r3, [r7, #12]
 8012380:	2b00      	cmp	r3, #0
 8012382:	d108      	bne.n	8012396 <OneShotTimerCallback+0x5a>
        {
          while(EthernetTimer);
 8012384:	bf00      	nop
 8012386:	f246 63f6 	movw	r3, #26358	; 0x66f6
 801238a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801238e:	781b      	ldrb	r3, [r3, #0]
 8012390:	b2db      	uxtb	r3, r3
 8012392:	2b00      	cmp	r3, #0
 8012394:	d1f7      	bne.n	8012386 <OneShotTimerCallback+0x4a>
        }
				SYSTM001_DeleteTimer(TimerId);
 8012396:	68b8      	ldr	r0, [r7, #8]
 8012398:	f7f2 f914 	bl	80045c4 <SYSTM001_DeleteTimer>
      }
 #endif
    return ;
 801239c:	bf00      	nop
}
 801239e:	f107 0710 	add.w	r7, r7, #16
 80123a2:	46bd      	mov	sp, r7
 80123a4:	bd80      	pop	{r7, pc}
 80123a6:	bf00      	nop

080123a8 <PeriodicTimerCallback>:

void PeriodicTimerCallback(u32 count, synopGMACdevice *synopGMACdev)
{
 80123a8:	b480      	push	{r7}
 80123aa:	b083      	sub	sp, #12
 80123ac:	af00      	add	r7, sp, #0
 80123ae:	6078      	str	r0, [r7, #4]
 80123b0:	6039      	str	r1, [r7, #0]
                                         synopGMAC_cable_unplug_function,
                                         synopGMACdev); 
    /* Start the Timer */
   RTOS001_StartTimer(Eth_TimerHandle);
#endif
    return ;
 80123b2:	bf00      	nop
}
 80123b4:	f107 070c 	add.w	r7, r7, #12
 80123b8:	46bd      	mov	sp, r7
 80123ba:	bc80      	pop	{r7}
 80123bc:	4770      	bx	lr
 80123be:	bf00      	nop

080123c0 <DeletePeriodicTimer>:

void DeletePeriodicTimer()
{
 80123c0:	b580      	push	{r7, lr}
 80123c2:	af00      	add	r7, sp, #0
#if !NO_SYS
  RTOS001_DeleteTimer(Eth_TimerHandle);
#else
  SYSTM001_DeleteTimer(Eth_TimerHandle);
 80123c4:	f246 5348 	movw	r3, #25928	; 0x6548
 80123c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80123cc:	681b      	ldr	r3, [r3, #0]
 80123ce:	4618      	mov	r0, r3
 80123d0:	f7f2 f8f8 	bl	80045c4 <SYSTM001_DeleteTimer>
#endif

}
 80123d4:	bd80      	pop	{r7, pc}
 80123d6:	bf00      	nop

080123d8 <lwIPStack_init>:
//void lwipProcessTimers(void);

status_t lwIPStack_init(void)
{
 80123d8:	b590      	push	{r4, r7, lr}
 80123da:	b089      	sub	sp, #36	; 0x24
 80123dc:	af04      	add	r7, sp, #16
	extern int GWpos1;
	extern int GWpos2;
	extern int GWpos3;
	extern int GWpos4;

	IP4_ADDR(&ipaddr, IPpos1, IPpos2, IPpos3, IPpos4);
 80123de:	f246 63e0 	movw	r3, #26336	; 0x66e0
 80123e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80123e6:	681b      	ldr	r3, [r3, #0]
 80123e8:	ea4f 6203 	mov.w	r2, r3, lsl #24
 80123ec:	f246 63e2 	movw	r3, #26338	; 0x66e2
 80123f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80123f4:	681b      	ldr	r3, [r3, #0]
 80123f6:	b2db      	uxtb	r3, r3
 80123f8:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80123fc:	431a      	orrs	r2, r3
 80123fe:	f246 63e4 	movw	r3, #26340	; 0x66e4
 8012402:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012406:	681b      	ldr	r3, [r3, #0]
 8012408:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801240c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8012410:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8012414:	431a      	orrs	r2, r3
 8012416:	f246 63e6 	movw	r3, #26342	; 0x66e6
 801241a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801241e:	681b      	ldr	r3, [r3, #0]
 8012420:	b2db      	uxtb	r3, r3
 8012422:	4313      	orrs	r3, r2
 8012424:	4618      	mov	r0, r3
 8012426:	f006 febf 	bl	80191a8 <htonl>
 801242a:	4603      	mov	r3, r0
 801242c:	60bb      	str	r3, [r7, #8]
    IP4_ADDR(&netmask, Netpos1, Netpos2, Netpos3, Netpos4);
 801242e:	f246 63e8 	movw	r3, #26344	; 0x66e8
 8012432:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012436:	681b      	ldr	r3, [r3, #0]
 8012438:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801243c:	f246 63ea 	movw	r3, #26346	; 0x66ea
 8012440:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012444:	681b      	ldr	r3, [r3, #0]
 8012446:	b2db      	uxtb	r3, r3
 8012448:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801244c:	431a      	orrs	r2, r3
 801244e:	f246 63ec 	movw	r3, #26348	; 0x66ec
 8012452:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012456:	681b      	ldr	r3, [r3, #0]
 8012458:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801245c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8012460:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8012464:	431a      	orrs	r2, r3
 8012466:	f640 53dc 	movw	r3, #3548	; 0xddc
 801246a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801246e:	681b      	ldr	r3, [r3, #0]
 8012470:	b2db      	uxtb	r3, r3
 8012472:	4313      	orrs	r3, r2
 8012474:	4618      	mov	r0, r3
 8012476:	f006 fe97 	bl	80191a8 <htonl>
 801247a:	4603      	mov	r3, r0
 801247c:	607b      	str	r3, [r7, #4]
    IP4_ADDR(&gw, GWpos1, GWpos2, GWpos3, GWpos4);
 801247e:	f246 63ee 	movw	r3, #26350	; 0x66ee
 8012482:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012486:	681b      	ldr	r3, [r3, #0]
 8012488:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801248c:	f246 63f0 	movw	r3, #26352	; 0x66f0
 8012490:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012494:	681b      	ldr	r3, [r3, #0]
 8012496:	b2db      	uxtb	r3, r3
 8012498:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801249c:	431a      	orrs	r2, r3
 801249e:	f246 63f2 	movw	r3, #26354	; 0x66f2
 80124a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80124a6:	681b      	ldr	r3, [r3, #0]
 80124a8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80124ac:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80124b0:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80124b4:	431a      	orrs	r2, r3
 80124b6:	f246 63f4 	movw	r3, #26356	; 0x66f4
 80124ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80124be:	681b      	ldr	r3, [r3, #0]
 80124c0:	b2db      	uxtb	r3, r3
 80124c2:	4313      	orrs	r3, r2
 80124c4:	4618      	mov	r0, r3
 80124c6:	f006 fe6f 	bl	80191a8 <htonl>
 80124ca:	4603      	mov	r3, r0
 80124cc:	603b      	str	r3, [r7, #0]
#endif
	
	PHY_RegisterTimerCallback(OneShotTimerCallback);
 80124ce:	f242 303d 	movw	r0, #9021	; 0x233d
 80124d2:	f6c0 0001 	movt	r0, #2049	; 0x801
 80124d6:	f008 fa63 	bl	801a9a0 <PHY_RegisterTimerCallback>
	synopGMAC_RegisterOneShotTimerCallback(OneShotTimerCallback);	
 80124da:	f242 303d 	movw	r0, #9021	; 0x233d
 80124de:	f6c0 0001 	movt	r0, #2049	; 0x801
 80124e2:	f008 fa95 	bl	801aa10 <synopGMAC_RegisterOneShotTimerCallback>
	synopGMAC_RegisterPeriodicTimerCallback(PeriodicTimerCallback);	
 80124e6:	f242 30a9 	movw	r0, #9129	; 0x23a9
 80124ea:	f6c0 0001 	movt	r0, #2049	; 0x801
 80124ee:	f00c fa9f 	bl	801ea30 <synopGMAC_RegisterPeriodicTimerCallback>
	synopGMAC_RegisterDeleteTimerCallback(DeletePeriodicTimer);
 80124f2:	f242 30c1 	movw	r0, #9153	; 0x23c1
 80124f6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80124fa:	f00c faa9 	bl	801ea50 <synopGMAC_RegisterDeleteTimerCallback>

#if NO_SYS
  /* Initialize the LwIP stack */
  /* <<<DD_LWIP_PORT_1_2>>> */
//  SysTick_Config(50000);
  lwip_init();
 80124fe:	f7ff fbf9 	bl	8011cf4 <lwip_init>
#if ENABLE_HTTP
  httpd_init() ;
 8012502:	f7f0 fd97 	bl	8003034 <httpd_init>
  /* Call this function to start a new TCP/IP thread */
  tcpip_init(NULL, NULL);
#endif

  /* Add a new network interface */
  netif_add(&netif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init,
 8012506:	f107 0108 	add.w	r1, r7, #8
 801250a:	f107 0204 	add.w	r2, r7, #4
 801250e:	463c      	mov	r4, r7
 8012510:	f04f 0300 	mov.w	r3, #0
 8012514:	9300      	str	r3, [sp, #0]
 8012516:	f241 2391 	movw	r3, #4753	; 0x1291
 801251a:	f6c0 0301 	movt	r3, #2049	; 0x801
 801251e:	9301      	str	r3, [sp, #4]
 8012520:	f241 0359 	movw	r3, #4185	; 0x1059
 8012524:	f6c0 0301 	movt	r3, #2049	; 0x801
 8012528:	9302      	str	r3, [sp, #8]
 801252a:	f246 5010 	movw	r0, #25872	; 0x6510
 801252e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8012532:	4623      	mov	r3, r4
 8012534:	f000 f8c0 	bl	80126b8 <netif_add>
      &ethernet_input);

  /* Registers the default network interface.*/
  netif_set_default(&netif);
 8012538:	f246 5010 	movw	r0, #25872	; 0x6510
 801253c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8012540:	f000 fa56 	bl	80129f0 <netif_set_default>
#if LWIP_NETIF_STATUS_CALLBACK
	netif_set_status_callback(&netif, StatusCallback);
#endif

  /* When the netif is fully configured this function must be called.*/
  netif_set_up(&netif);
 8012544:	f246 5010 	movw	r0, #25872	; 0x6510
 8012548:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801254c:	f000 fa60 	bl	8012a10 <netif_set_up>

  TimerId = SYSTM001_CreateTimer(250, SYSTM001_PERIODIC, Periodic_Timer_CallBack, NULL);
 8012550:	f04f 00fa 	mov.w	r0, #250	; 0xfa
 8012554:	f04f 0101 	mov.w	r1, #1
 8012558:	f242 320d 	movw	r2, #8973	; 0x230d
 801255c:	f6c0 0201 	movt	r2, #2049	; 0x801
 8012560:	f04f 0300 	mov.w	r3, #0
 8012564:	f7f1 febc 	bl	80042e0 <SYSTM001_CreateTimer>
 8012568:	60f8      	str	r0, [r7, #12]
  if(TimerId != 0)
 801256a:	68fb      	ldr	r3, [r7, #12]
 801256c:	2b00      	cmp	r3, #0
 801256e:	d002      	beq.n	8012576 <lwIPStack_init+0x19e>
  {
  	  SYSTM001_StartTimer(TimerId);
 8012570:	68f8      	ldr	r0, [r7, #12]
 8012572:	f7f1 ff85 	bl	8004480 <SYSTM001_StartTimer>
  sys_sem_signal(lwIPStackSem);

  sys_thread_stop(0);
#endif
  /* TODO: Add code for initialization of TCP applications */
  return DAVEApp_SUCCESS;
 8012576:	f04f 0300 	mov.w	r3, #0
}
 801257a:	4618      	mov	r0, r3
 801257c:	f107 0714 	add.w	r7, r7, #20
 8012580:	46bd      	mov	sp, r7
 8012582:	bd90      	pop	{r4, r7, pc}

08012584 <LwIP_Periodic_Timer_CallBack>:
}
#endif

// To be called by user at an interval of 250 microseconds
void LwIP_Periodic_Timer_CallBack(void* Temp)	
{
 8012584:	b580      	push	{r7, lr}
 8012586:	b082      	sub	sp, #8
 8012588:	af00      	add	r7, sp, #0
 801258a:	6078      	str	r0, [r7, #4]
    lwip250mStimer += 250;
 801258c:	f246 5344 	movw	r3, #25924	; 0x6544
 8012590:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012594:	681b      	ldr	r3, [r3, #0]
 8012596:	f103 02fa 	add.w	r2, r3, #250	; 0xfa
 801259a:	f246 5344 	movw	r3, #25924	; 0x6544
 801259e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80125a2:	601a      	str	r2, [r3, #0]
#if LWIP_TCP
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
 80125a4:	f246 5344 	movw	r3, #25924	; 0x6544
 80125a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80125ac:	681a      	ldr	r2, [r3, #0]
 80125ae:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 80125b2:	f2c1 0362 	movt	r3, #4194	; 0x1062
 80125b6:	fba3 1302 	umull	r1, r3, r3, r2
 80125ba:	ea4f 1313 	mov.w	r3, r3, lsr #4
 80125be:	f04f 01fa 	mov.w	r1, #250	; 0xfa
 80125c2:	fb01 f303 	mul.w	r3, r1, r3
 80125c6:	1ad3      	subs	r3, r2, r3
 80125c8:	2b00      	cmp	r3, #0
 80125ca:	d101      	bne.n	80125d0 <LwIP_Periodic_Timer_CallBack+0x4c>
 80125cc:	f001 f86a 	bl	80136a4 <tcp_tmr>
#endif
    if( (lwip250mStimer % ARP_TMR_INTERVAL) == 0 ) { etharp_tmr(); }
 80125d0:	f246 5344 	movw	r3, #25924	; 0x6544
 80125d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80125d8:	681a      	ldr	r2, [r3, #0]
 80125da:	f241 7359 	movw	r3, #5977	; 0x1759
 80125de:	f2cd 13b7 	movt	r3, #53687	; 0xd1b7
 80125e2:	fba3 1302 	umull	r1, r3, r3, r2
 80125e6:	ea4f 3313 	mov.w	r3, r3, lsr #12
 80125ea:	f241 3188 	movw	r1, #5000	; 0x1388
 80125ee:	fb01 f303 	mul.w	r3, r1, r3
 80125f2:	1ad3      	subs	r3, r2, r3
 80125f4:	2b00      	cmp	r3, #0
 80125f6:	d101      	bne.n	80125fc <LwIP_Periodic_Timer_CallBack+0x78>
 80125f8:	f7fd fd48 	bl	801008c <etharp_tmr>
#if IP_REASSEMBLY
    if( (lwip250mStimer % IP_TMR_INTERVAL) == 0 ) { ip_reass_tmr(); }
 80125fc:	f246 5344 	movw	r3, #25924	; 0x6544
 8012600:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012604:	681a      	ldr	r2, [r3, #0]
 8012606:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 801260a:	f2c1 0362 	movt	r3, #4194	; 0x1062
 801260e:	fba3 1302 	umull	r1, r3, r3, r2
 8012612:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8012616:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 801261a:	fb01 f303 	mul.w	r3, r1, r3
 801261e:	1ad3      	subs	r3, r2, r3
 8012620:	2b00      	cmp	r3, #0
 8012622:	d101      	bne.n	8012628 <LwIP_Periodic_Timer_CallBack+0xa4>
 8012624:	f007 facc 	bl	8019bc0 <ip_reass_tmr>
#endif
#if LWIP_AUTOIP
    if( (lwip250mStimer % AUTOIP_TMR_INTERVAL ) == 0 ) { autoip_tmr(); }
#endif
#if LWIP_IGMP
    if( (lwip250mStimer % IGMP_TMR_INTERVAL ) == 0 ) { igmp_tmr(); } 
 8012628:	f246 5344 	movw	r3, #25924	; 0x6544
 801262c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012630:	681a      	ldr	r2, [r3, #0]
 8012632:	f248 531f 	movw	r3, #34079	; 0x851f
 8012636:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 801263a:	fba3 1302 	umull	r1, r3, r3, r2
 801263e:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8012642:	f04f 0164 	mov.w	r1, #100	; 0x64
 8012646:	fb01 f303 	mul.w	r3, r1, r3
 801264a:	1ad3      	subs	r3, r2, r3
 801264c:	2b00      	cmp	r3, #0
 801264e:	d101      	bne.n	8012654 <LwIP_Periodic_Timer_CallBack+0xd0>
 8012650:	f006 fa7c 	bl	8018b4c <igmp_tmr>
#if LWIP_DHCP
    if( (lwip250mStimer % DHCP_FINE_TIMER_MSECS ) == 0 ) { dhcp_fine_tmr(); }
    if( (lwip250mStimer % (DHCP_COARSE_TIMER_SECS*1000) ) == 0 ) { dhcp_coarse_tmr(); }
#endif
#if LWIP_DNS
    if( (lwip250mStimer % DNS_TMR_INTERVAL) == 0 ) { dns_tmr(); }
 8012654:	f246 5344 	movw	r3, #25924	; 0x6544
 8012658:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801265c:	681a      	ldr	r2, [r3, #0]
 801265e:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 8012662:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8012666:	fba3 1302 	umull	r1, r3, r3, r2
 801266a:	ea4f 1393 	mov.w	r3, r3, lsr #6
 801266e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8012672:	fb01 f303 	mul.w	r3, r1, r3
 8012676:	1ad3      	subs	r3, r2, r3
 8012678:	2b00      	cmp	r3, #0
 801267a:	d101      	bne.n	8012680 <LwIP_Periodic_Timer_CallBack+0xfc>
 801267c:	f7fe feec 	bl	8011458 <dns_tmr>
#endif

}
 8012680:	f107 0708 	add.w	r7, r7, #8
 8012684:	46bd      	mov	sp, r7
 8012686:	bd80      	pop	{r7, pc}

08012688 <lwIPStack_UnInit>:
 * @param [in] None
 *
 * @return DAVEApp_SUCCESS on success error code otherwise
 */
status_t lwIPStack_UnInit(void)
{
 8012688:	b580      	push	{r7, lr}
 801268a:	b082      	sub	sp, #8
 801268c:	af00      	add	r7, sp, #0
  status_t Status = lwIP_UNINIT_ERROR;
 801268e:	f04f 0302 	mov.w	r3, #2
 8012692:	607b      	str	r3, [r7, #4]
#endif

  /* Disconnect netif */
  // netif_set_down(&netif); // added to test link/status callback when set down is called
  /* Remove the network interface */
  netif_remove(&netif);
 8012694:	f246 5010 	movw	r0, #25872	; 0x6510
 8012698:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801269c:	f000 f896 	bl	80127cc <netif_remove>

  /* Close Ethernet Interface */
  Status = Eth_CloseNetworkInterface();
 80126a0:	f00b fab6 	bl	801dc10 <Eth_CloseNetworkInterface>
 80126a4:	6078      	str	r0, [r7, #4]
  if (Status != DAVEApp_SUCCESS)
  {
    DBG002_WARNING(GID_LWIP, lwIP_UNINIT_ERROR, 0, NULL);
  }
  /* Exit from the Ethernet Interface */
  Eth_ExitNetworkInterface();
 80126a6:	f00b f90f 	bl	801d8c8 <Eth_ExitNetworkInterface>

  return DAVEApp_SUCCESS;
 80126aa:	f04f 0300 	mov.w	r3, #0
}
 80126ae:	4618      	mov	r0, r3
 80126b0:	f107 0708 	add.w	r7, r7, #8
 80126b4:	46bd      	mov	sp, r7
 80126b6:	bd80      	pop	{r7, pc}

080126b8 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
 80126b8:	b580      	push	{r7, lr}
 80126ba:	b084      	sub	sp, #16
 80126bc:	af00      	add	r7, sp, #0
 80126be:	60f8      	str	r0, [r7, #12]
 80126c0:	60b9      	str	r1, [r7, #8]
 80126c2:	607a      	str	r2, [r7, #4]
 80126c4:	603b      	str	r3, [r7, #0]
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
 80126c6:	68fb      	ldr	r3, [r7, #12]
 80126c8:	f04f 0200 	mov.w	r2, #0
 80126cc:	605a      	str	r2, [r3, #4]
  netif->netmask.addr = 0;
 80126ce:	68fb      	ldr	r3, [r7, #12]
 80126d0:	f04f 0200 	mov.w	r2, #0
 80126d4:	609a      	str	r2, [r3, #8]
  netif->gw.addr = 0;
 80126d6:	68fb      	ldr	r3, [r7, #12]
 80126d8:	f04f 0200 	mov.w	r2, #0
 80126dc:	60da      	str	r2, [r3, #12]
  netif->flags = 0;
 80126de:	68fb      	ldr	r3, [r7, #12]
 80126e0:	f04f 0200 	mov.w	r2, #0
 80126e4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
#endif /* LWIP_NETIF_LINK_CALLBACK */
#if LWIP_IGMP
  netif->igmp_mac_filter = NULL;
 80126e8:	68fb      	ldr	r3, [r7, #12]
 80126ea:	f04f 0200 	mov.w	r2, #0
 80126ee:	631a      	str	r2, [r3, #48]	; 0x30
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 80126f0:	68fb      	ldr	r3, [r7, #12]
 80126f2:	69ba      	ldr	r2, [r7, #24]
 80126f4:	61da      	str	r2, [r3, #28]
  netif->num = netifnum++;
 80126f6:	f245 5350 	movw	r3, #21840	; 0x5550
 80126fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80126fe:	781b      	ldrb	r3, [r3, #0]
 8012700:	68fa      	ldr	r2, [r7, #12]
 8012702:	4619      	mov	r1, r3
 8012704:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
 8012708:	f103 0301 	add.w	r3, r3, #1
 801270c:	b2da      	uxtb	r2, r3
 801270e:	f245 5350 	movw	r3, #21840	; 0x5550
 8012712:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012716:	701a      	strb	r2, [r3, #0]
  netif->input = input;
 8012718:	68fb      	ldr	r3, [r7, #12]
 801271a:	6a3a      	ldr	r2, [r7, #32]
 801271c:	611a      	str	r2, [r3, #16]
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
 801271e:	68f8      	ldr	r0, [r7, #12]
 8012720:	68b9      	ldr	r1, [r7, #8]
 8012722:	687a      	ldr	r2, [r7, #4]
 8012724:	683b      	ldr	r3, [r7, #0]
 8012726:	f000 f839 	bl	801279c <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 801272a:	69fb      	ldr	r3, [r7, #28]
 801272c:	68f8      	ldr	r0, [r7, #12]
 801272e:	4798      	blx	r3
 8012730:	4603      	mov	r3, r0
 8012732:	2b00      	cmp	r3, #0
 8012734:	d002      	beq.n	801273c <netif_add+0x84>
    return NULL;
 8012736:	f04f 0300 	mov.w	r3, #0
 801273a:	e029      	b.n	8012790 <netif_add+0xd8>
  }

  /* add this netif to the list */
  netif->next = netif_list;
 801273c:	f246 534c 	movw	r3, #25932	; 0x654c
 8012740:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012744:	681a      	ldr	r2, [r3, #0]
 8012746:	68fb      	ldr	r3, [r7, #12]
 8012748:	601a      	str	r2, [r3, #0]
  netif_list = netif;
 801274a:	f246 534c 	movw	r3, #25932	; 0x654c
 801274e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012752:	68fa      	ldr	r2, [r7, #12]
 8012754:	601a      	str	r2, [r3, #0]
  snmp_inc_iflist();

#if LWIP_IGMP
  netif->flags |= NETIF_FLAG_IGMP; // to add device to multicast group
 8012756:	68fb      	ldr	r3, [r7, #12]
 8012758:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801275c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8012760:	b2da      	uxtb	r2, r3
 8012762:	68fb      	ldr	r3, [r7, #12]
 8012764:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  /* start IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
 8012768:	68fb      	ldr	r3, [r7, #12]
 801276a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801276e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012772:	2b00      	cmp	r3, #0
 8012774:	d002      	beq.n	801277c <netif_add+0xc4>
    igmp_start( netif);
 8012776:	68f8      	ldr	r0, [r7, #12]
 8012778:	f005 feca 	bl	8018510 <igmp_start>
  }
#endif /* LWIP_IGMP */

#if (IP_SOF_BROADCAST || LWIP_BROADCAST_PING)
  netif->flags |= NETIF_FLAG_BROADCAST; // to enable broadcast
 801277c:	68fb      	ldr	r3, [r7, #12]
 801277e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8012782:	f043 0302 	orr.w	r3, r3, #2
 8012786:	b2da      	uxtb	r2, r3
 8012788:	68fb      	ldr	r3, [r7, #12]
 801278a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 801278e:	68fb      	ldr	r3, [r7, #12]
}
 8012790:	4618      	mov	r0, r3
 8012792:	f107 0710 	add.w	r7, r7, #16
 8012796:	46bd      	mov	sp, r7
 8012798:	bd80      	pop	{r7, pc}
 801279a:	bf00      	nop

0801279c <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
 801279c:	b580      	push	{r7, lr}
 801279e:	b084      	sub	sp, #16
 80127a0:	af00      	add	r7, sp, #0
 80127a2:	60f8      	str	r0, [r7, #12]
 80127a4:	60b9      	str	r1, [r7, #8]
 80127a6:	607a      	str	r2, [r7, #4]
 80127a8:	603b      	str	r3, [r7, #0]
  netif_set_ipaddr(netif, ipaddr);
 80127aa:	68f8      	ldr	r0, [r7, #12]
 80127ac:	68b9      	ldr	r1, [r7, #8]
 80127ae:	f000 f89b 	bl	80128e8 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
 80127b2:	68f8      	ldr	r0, [r7, #12]
 80127b4:	6879      	ldr	r1, [r7, #4]
 80127b6:	f000 f907 	bl	80129c8 <netif_set_netmask>
  netif_set_gw(netif, gw);
 80127ba:	68f8      	ldr	r0, [r7, #12]
 80127bc:	6839      	ldr	r1, [r7, #0]
 80127be:	f000 f8ef 	bl	80129a0 <netif_set_gw>
}
 80127c2:	f107 0710 	add.w	r7, r7, #16
 80127c6:	46bd      	mov	sp, r7
 80127c8:	bd80      	pop	{r7, pc}
 80127ca:	bf00      	nop

080127cc <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
 80127cc:	b580      	push	{r7, lr}
 80127ce:	b084      	sub	sp, #16
 80127d0:	af00      	add	r7, sp, #0
 80127d2:	6078      	str	r0, [r7, #4]
  if ( netif == NULL ) return;
 80127d4:	687b      	ldr	r3, [r7, #4]
 80127d6:	2b00      	cmp	r3, #0
 80127d8:	d040      	beq.n	801285c <netif_remove+0x90>

#if LWIP_IGMP
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
 80127da:	687b      	ldr	r3, [r7, #4]
 80127dc:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 80127e0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80127e4:	2b00      	cmp	r3, #0
 80127e6:	d002      	beq.n	80127ee <netif_remove+0x22>
    igmp_stop( netif);
 80127e8:	6878      	ldr	r0, [r7, #4]
 80127ea:	f005 fec5 	bl	8018578 <igmp_stop>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
 80127ee:	f246 534c 	movw	r3, #25932	; 0x654c
 80127f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80127f6:	681a      	ldr	r2, [r3, #0]
 80127f8:	687b      	ldr	r3, [r7, #4]
 80127fa:	429a      	cmp	r2, r3
 80127fc:	d107      	bne.n	801280e <netif_remove+0x42>
    netif_list = netif->next;
 80127fe:	687b      	ldr	r3, [r7, #4]
 8012800:	681a      	ldr	r2, [r3, #0]
 8012802:	f246 534c 	movw	r3, #25932	; 0x654c
 8012806:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801280a:	601a      	str	r2, [r3, #0]
 801280c:	e019      	b.n	8012842 <netif_remove+0x76>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 801280e:	f246 534c 	movw	r3, #25932	; 0x654c
 8012812:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012816:	681b      	ldr	r3, [r3, #0]
 8012818:	60fb      	str	r3, [r7, #12]
 801281a:	e00c      	b.n	8012836 <netif_remove+0x6a>
      if (tmpNetif->next == netif) {
 801281c:	68fb      	ldr	r3, [r7, #12]
 801281e:	681a      	ldr	r2, [r3, #0]
 8012820:	687b      	ldr	r3, [r7, #4]
 8012822:	429a      	cmp	r2, r3
 8012824:	d104      	bne.n	8012830 <netif_remove+0x64>
        tmpNetif->next = netif->next;
 8012826:	687b      	ldr	r3, [r7, #4]
 8012828:	681a      	ldr	r2, [r3, #0]
 801282a:	68fb      	ldr	r3, [r7, #12]
 801282c:	601a      	str	r2, [r3, #0]
        snmp_dec_iflist();
        break;
 801282e:	e005      	b.n	801283c <netif_remove+0x70>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 8012830:	68fb      	ldr	r3, [r7, #12]
 8012832:	681b      	ldr	r3, [r3, #0]
 8012834:	60fb      	str	r3, [r7, #12]
 8012836:	68fb      	ldr	r3, [r7, #12]
 8012838:	2b00      	cmp	r3, #0
 801283a:	d1ef      	bne.n	801281c <netif_remove+0x50>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
 801283c:	68fb      	ldr	r3, [r7, #12]
 801283e:	2b00      	cmp	r3, #0
 8012840:	d00e      	beq.n	8012860 <netif_remove+0x94>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
 8012842:	f246 5350 	movw	r3, #25936	; 0x6550
 8012846:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801284a:	681a      	ldr	r2, [r3, #0]
 801284c:	687b      	ldr	r3, [r7, #4]
 801284e:	429a      	cmp	r2, r3
 8012850:	d107      	bne.n	8012862 <netif_remove+0x96>
    /* reset default netif */
    netif_set_default(NULL);
 8012852:	f04f 0000 	mov.w	r0, #0
 8012856:	f000 f8cb 	bl	80129f0 <netif_set_default>
 801285a:	e002      	b.n	8012862 <netif_remove+0x96>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
 801285c:	bf00      	nop
 801285e:	e000      	b.n	8012862 <netif_remove+0x96>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
 8012860:	bf00      	nop
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 8012862:	f107 0710 	add.w	r7, r7, #16
 8012866:	46bd      	mov	sp, r7
 8012868:	bd80      	pop	{r7, pc}
 801286a:	bf00      	nop

0801286c <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
 801286c:	b480      	push	{r7}
 801286e:	b085      	sub	sp, #20
 8012870:	af00      	add	r7, sp, #0
 8012872:	6078      	str	r0, [r7, #4]
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
 8012874:	687b      	ldr	r3, [r7, #4]
 8012876:	2b00      	cmp	r3, #0
 8012878:	d102      	bne.n	8012880 <netif_find+0x14>
    return NULL;
 801287a:	f04f 0300 	mov.w	r3, #0
 801287e:	e02d      	b.n	80128dc <netif_find+0x70>
  }

  num = name[2] - '0';
 8012880:	687b      	ldr	r3, [r7, #4]
 8012882:	f103 0302 	add.w	r3, r3, #2
 8012886:	781b      	ldrb	r3, [r3, #0]
 8012888:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 801288c:	72fb      	strb	r3, [r7, #11]

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 801288e:	f246 534c 	movw	r3, #25932	; 0x654c
 8012892:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012896:	681b      	ldr	r3, [r3, #0]
 8012898:	60fb      	str	r3, [r7, #12]
 801289a:	e01a      	b.n	80128d2 <netif_find+0x66>
    if (num == netif->num &&
 801289c:	68fb      	ldr	r3, [r7, #12]
 801289e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80128a2:	7afa      	ldrb	r2, [r7, #11]
 80128a4:	429a      	cmp	r2, r3
 80128a6:	d111      	bne.n	80128cc <netif_find+0x60>
       name[0] == netif->name[0] &&
 80128a8:	687b      	ldr	r3, [r7, #4]
 80128aa:	781a      	ldrb	r2, [r3, #0]
 80128ac:	68fb      	ldr	r3, [r7, #12]
 80128ae:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
 80128b2:	429a      	cmp	r2, r3
 80128b4:	d10a      	bne.n	80128cc <netif_find+0x60>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
 80128b6:	687b      	ldr	r3, [r7, #4]
 80128b8:	f103 0301 	add.w	r3, r3, #1
 80128bc:	781a      	ldrb	r2, [r3, #0]
 80128be:	68fb      	ldr	r3, [r7, #12]
 80128c0:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
 80128c4:	429a      	cmp	r2, r3
 80128c6:	d101      	bne.n	80128cc <netif_find+0x60>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
 80128c8:	68fb      	ldr	r3, [r7, #12]
 80128ca:	e007      	b.n	80128dc <netif_find+0x70>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 80128cc:	68fb      	ldr	r3, [r7, #12]
 80128ce:	681b      	ldr	r3, [r3, #0]
 80128d0:	60fb      	str	r3, [r7, #12]
 80128d2:	68fb      	ldr	r3, [r7, #12]
 80128d4:	2b00      	cmp	r3, #0
 80128d6:	d1e1      	bne.n	801289c <netif_find+0x30>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
 80128d8:	f04f 0300 	mov.w	r3, #0
}
 80128dc:	4618      	mov	r0, r3
 80128de:	f107 0714 	add.w	r7, r7, #20
 80128e2:	46bd      	mov	sp, r7
 80128e4:	bc80      	pop	{r7}
 80128e6:	4770      	bx	lr

080128e8 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
 80128e8:	b580      	push	{r7, lr}
 80128ea:	b086      	sub	sp, #24
 80128ec:	af00      	add	r7, sp, #0
 80128ee:	6078      	str	r0, [r7, #4]
 80128f0:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
 80128f2:	683b      	ldr	r3, [r7, #0]
 80128f4:	681a      	ldr	r2, [r3, #0]
 80128f6:	687b      	ldr	r3, [r7, #4]
 80128f8:	685b      	ldr	r3, [r3, #4]
 80128fa:	429a      	cmp	r2, r3
 80128fc:	d041      	beq.n	8012982 <netif_set_ipaddr+0x9a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 80128fe:	f246 5354 	movw	r3, #25940	; 0x6554
 8012902:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012906:	681b      	ldr	r3, [r3, #0]
 8012908:	617b      	str	r3, [r7, #20]
    while (pcb != NULL) {
 801290a:	e013      	b.n	8012934 <netif_set_ipaddr+0x4c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 801290c:	697b      	ldr	r3, [r7, #20]
 801290e:	681a      	ldr	r2, [r3, #0]
 8012910:	687b      	ldr	r3, [r7, #4]
 8012912:	685b      	ldr	r3, [r3, #4]
 8012914:	429a      	cmp	r2, r3
 8012916:	d10a      	bne.n	801292e <netif_set_ipaddr+0x46>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 8012918:	697b      	ldr	r3, [r7, #20]
 801291a:	68db      	ldr	r3, [r3, #12]
 801291c:	60fb      	str	r3, [r7, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 801291e:	6978      	ldr	r0, [r7, #20]
 8012920:	f04f 0101 	mov.w	r1, #1
 8012924:	f000 ffb8 	bl	8013898 <tcp_abandon>
        pcb = next;
 8012928:	68fb      	ldr	r3, [r7, #12]
 801292a:	617b      	str	r3, [r7, #20]
 801292c:	e002      	b.n	8012934 <netif_set_ipaddr+0x4c>
      } else {
        pcb = pcb->next;
 801292e:	697b      	ldr	r3, [r7, #20]
 8012930:	68db      	ldr	r3, [r3, #12]
 8012932:	617b      	str	r3, [r7, #20]
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 8012934:	697b      	ldr	r3, [r7, #20]
 8012936:	2b00      	cmp	r3, #0
 8012938:	d1e8      	bne.n	801290c <netif_set_ipaddr+0x24>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 801293a:	f246 535c 	movw	r3, #25948	; 0x655c
 801293e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012942:	681b      	ldr	r3, [r3, #0]
 8012944:	613b      	str	r3, [r7, #16]
 8012946:	e019      	b.n	801297c <netif_set_ipaddr+0x94>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 8012948:	693b      	ldr	r3, [r7, #16]
 801294a:	2b00      	cmp	r3, #0
 801294c:	d013      	beq.n	8012976 <netif_set_ipaddr+0x8e>
 801294e:	693b      	ldr	r3, [r7, #16]
 8012950:	681b      	ldr	r3, [r3, #0]
 8012952:	2b00      	cmp	r3, #0
 8012954:	d00f      	beq.n	8012976 <netif_set_ipaddr+0x8e>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
 8012956:	693b      	ldr	r3, [r7, #16]
 8012958:	681a      	ldr	r2, [r3, #0]
 801295a:	687b      	ldr	r3, [r7, #4]
 801295c:	685b      	ldr	r3, [r3, #4]
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 801295e:	429a      	cmp	r2, r3
 8012960:	d109      	bne.n	8012976 <netif_set_ipaddr+0x8e>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 8012962:	683b      	ldr	r3, [r7, #0]
 8012964:	2b00      	cmp	r3, #0
 8012966:	d002      	beq.n	801296e <netif_set_ipaddr+0x86>
 8012968:	683b      	ldr	r3, [r7, #0]
 801296a:	681b      	ldr	r3, [r3, #0]
 801296c:	e001      	b.n	8012972 <netif_set_ipaddr+0x8a>
 801296e:	f04f 0300 	mov.w	r3, #0
 8012972:	693a      	ldr	r2, [r7, #16]
 8012974:	6013      	str	r3, [r2, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8012976:	693b      	ldr	r3, [r7, #16]
 8012978:	68db      	ldr	r3, [r3, #12]
 801297a:	613b      	str	r3, [r7, #16]
 801297c:	693b      	ldr	r3, [r7, #16]
 801297e:	2b00      	cmp	r3, #0
 8012980:	d1e2      	bne.n	8012948 <netif_set_ipaddr+0x60>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8012982:	683b      	ldr	r3, [r7, #0]
 8012984:	2b00      	cmp	r3, #0
 8012986:	d002      	beq.n	801298e <netif_set_ipaddr+0xa6>
 8012988:	683b      	ldr	r3, [r7, #0]
 801298a:	681b      	ldr	r3, [r3, #0]
 801298c:	e001      	b.n	8012992 <netif_set_ipaddr+0xaa>
 801298e:	f04f 0300 	mov.w	r3, #0
 8012992:	687a      	ldr	r2, [r7, #4]
 8012994:	6053      	str	r3, [r2, #4]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
 8012996:	f107 0718 	add.w	r7, r7, #24
 801299a:	46bd      	mov	sp, r7
 801299c:	bd80      	pop	{r7, pc}
 801299e:	bf00      	nop

080129a0 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
 80129a0:	b480      	push	{r7}
 80129a2:	b083      	sub	sp, #12
 80129a4:	af00      	add	r7, sp, #0
 80129a6:	6078      	str	r0, [r7, #4]
 80129a8:	6039      	str	r1, [r7, #0]
  ip_addr_set(&(netif->gw), gw);
 80129aa:	683b      	ldr	r3, [r7, #0]
 80129ac:	2b00      	cmp	r3, #0
 80129ae:	d002      	beq.n	80129b6 <netif_set_gw+0x16>
 80129b0:	683b      	ldr	r3, [r7, #0]
 80129b2:	681b      	ldr	r3, [r3, #0]
 80129b4:	e001      	b.n	80129ba <netif_set_gw+0x1a>
 80129b6:	f04f 0300 	mov.w	r3, #0
 80129ba:	687a      	ldr	r2, [r7, #4]
 80129bc:	60d3      	str	r3, [r2, #12]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
 80129be:	f107 070c 	add.w	r7, r7, #12
 80129c2:	46bd      	mov	sp, r7
 80129c4:	bc80      	pop	{r7}
 80129c6:	4770      	bx	lr

080129c8 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
 80129c8:	b480      	push	{r7}
 80129ca:	b083      	sub	sp, #12
 80129cc:	af00      	add	r7, sp, #0
 80129ce:	6078      	str	r0, [r7, #4]
 80129d0:	6039      	str	r1, [r7, #0]
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 80129d2:	683b      	ldr	r3, [r7, #0]
 80129d4:	2b00      	cmp	r3, #0
 80129d6:	d002      	beq.n	80129de <netif_set_netmask+0x16>
 80129d8:	683b      	ldr	r3, [r7, #0]
 80129da:	681b      	ldr	r3, [r3, #0]
 80129dc:	e001      	b.n	80129e2 <netif_set_netmask+0x1a>
 80129de:	f04f 0300 	mov.w	r3, #0
 80129e2:	687a      	ldr	r2, [r7, #4]
 80129e4:	6093      	str	r3, [r2, #8]
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
 80129e6:	f107 070c 	add.w	r7, r7, #12
 80129ea:	46bd      	mov	sp, r7
 80129ec:	bc80      	pop	{r7}
 80129ee:	4770      	bx	lr

080129f0 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 80129f0:	b480      	push	{r7}
 80129f2:	b083      	sub	sp, #12
 80129f4:	af00      	add	r7, sp, #0
 80129f6:	6078      	str	r0, [r7, #4]
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 80129f8:	f246 5350 	movw	r3, #25936	; 0x6550
 80129fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012a00:	687a      	ldr	r2, [r7, #4]
 8012a02:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 8012a04:	f107 070c 	add.w	r7, r7, #12
 8012a08:	46bd      	mov	sp, r7
 8012a0a:	bc80      	pop	{r7}
 8012a0c:	4770      	bx	lr
 8012a0e:	bf00      	nop

08012a10 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 8012a10:	b580      	push	{r7, lr}
 8012a12:	b082      	sub	sp, #8
 8012a14:	af00      	add	r7, sp, #0
 8012a16:	6078      	str	r0, [r7, #4]
  if ( !(netif->flags & NETIF_FLAG_UP )) {
 8012a18:	687b      	ldr	r3, [r7, #4]
 8012a1a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8012a1e:	f003 0301 	and.w	r3, r3, #1
 8012a22:	2b00      	cmp	r3, #0
 8012a24:	d112      	bne.n	8012a4c <netif_set_up+0x3c>
    netif->flags |= NETIF_FLAG_UP;
 8012a26:	687b      	ldr	r3, [r7, #4]
 8012a28:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8012a2c:	f043 0301 	orr.w	r3, r3, #1
 8012a30:	b2da      	uxtb	r2, r3
 8012a32:	687b      	ldr	r3, [r7, #4]
 8012a34:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    }
#endif /* LWIP_ARP */

#if LWIP_IGMP
    /* resend IGMP memberships */
    if (netif->flags & NETIF_FLAG_IGMP) {
 8012a38:	687b      	ldr	r3, [r7, #4]
 8012a3a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8012a3e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012a42:	2b00      	cmp	r3, #0
 8012a44:	d002      	beq.n	8012a4c <netif_set_up+0x3c>
      igmp_report_groups( netif);
 8012a46:	6878      	ldr	r0, [r7, #4]
 8012a48:	f005 fde2 	bl	8018610 <igmp_report_groups>
    }
#endif /* LWIP_IGMP */
  }
}
 8012a4c:	f107 0708 	add.w	r7, r7, #8
 8012a50:	46bd      	mov	sp, r7
 8012a52:	bd80      	pop	{r7, pc}

08012a54 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
 8012a54:	b480      	push	{r7}
 8012a56:	b083      	sub	sp, #12
 8012a58:	af00      	add	r7, sp, #0
 8012a5a:	6078      	str	r0, [r7, #4]
  if ( netif->flags & NETIF_FLAG_UP )
 8012a5c:	687b      	ldr	r3, [r7, #4]
 8012a5e:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8012a62:	f003 0301 	and.w	r3, r3, #1
 8012a66:	2b00      	cmp	r3, #0
 8012a68:	d008      	beq.n	8012a7c <netif_set_down+0x28>
    {
      netif->flags &= ~NETIF_FLAG_UP;
 8012a6a:	687b      	ldr	r3, [r7, #4]
 8012a6c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8012a70:	f023 0301 	bic.w	r3, r3, #1
 8012a74:	b2da      	uxtb	r2, r3
 8012a76:	687b      	ldr	r3, [r7, #4]
 8012a78:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
 8012a7c:	f107 070c 	add.w	r7, r7, #12
 8012a80:	46bd      	mov	sp, r7
 8012a82:	bc80      	pop	{r7}
 8012a84:	4770      	bx	lr
 8012a86:	bf00      	nop

08012a88 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
 8012a88:	b480      	push	{r7}
 8012a8a:	b083      	sub	sp, #12
 8012a8c:	af00      	add	r7, sp, #0
 8012a8e:	6078      	str	r0, [r7, #4]
  return (netif->flags & NETIF_FLAG_UP)?1:0;
 8012a90:	687b      	ldr	r3, [r7, #4]
 8012a92:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8012a96:	f003 0301 	and.w	r3, r3, #1
 8012a9a:	2b00      	cmp	r3, #0
 8012a9c:	bf0c      	ite	eq
 8012a9e:	2300      	moveq	r3, #0
 8012aa0:	2301      	movne	r3, #1
 8012aa2:	b2db      	uxtb	r3, r3
}
 8012aa4:	4618      	mov	r0, r3
 8012aa6:	f107 070c 	add.w	r7, r7, #12
 8012aaa:	46bd      	mov	sp, r7
 8012aac:	bc80      	pop	{r7}
 8012aae:	4770      	bx	lr

08012ab0 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 8012ab0:	b580      	push	{r7, lr}
 8012ab2:	b088      	sub	sp, #32
 8012ab4:	af00      	add	r7, sp, #0
 8012ab6:	4613      	mov	r3, r2
 8012ab8:	4602      	mov	r2, r0
 8012aba:	71fa      	strb	r2, [r7, #7]
 8012abc:	460a      	mov	r2, r1
 8012abe:	80ba      	strh	r2, [r7, #4]
 8012ac0:	71bb      	strb	r3, [r7, #6]
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
 8012ac2:	f04f 0300 	mov.w	r3, #0
 8012ac6:	82fb      	strh	r3, [r7, #22]
  switch (layer) {
 8012ac8:	79fb      	ldrb	r3, [r7, #7]
 8012aca:	2b03      	cmp	r3, #3
 8012acc:	d817      	bhi.n	8012afe <pbuf_alloc+0x4e>
 8012ace:	a201      	add	r2, pc, #4	; (adr r2, 8012ad4 <pbuf_alloc+0x24>)
 8012ad0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012ad4:	08012ae5 	.word	0x08012ae5
 8012ad8:	08012aed 	.word	0x08012aed
 8012adc:	08012af5 	.word	0x08012af5
 8012ae0:	08012b05 	.word	0x08012b05
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
 8012ae4:	8afb      	ldrh	r3, [r7, #22]
 8012ae6:	f103 0314 	add.w	r3, r3, #20
 8012aea:	82fb      	strh	r3, [r7, #22]
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
 8012aec:	8afb      	ldrh	r3, [r7, #22]
 8012aee:	f103 0314 	add.w	r3, r3, #20
 8012af2:	82fb      	strh	r3, [r7, #22]
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
 8012af4:	8afb      	ldrh	r3, [r7, #22]
 8012af6:	f103 030e 	add.w	r3, r3, #14
 8012afa:	82fb      	strh	r3, [r7, #22]
    break;
 8012afc:	e003      	b.n	8012b06 <pbuf_alloc+0x56>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
 8012afe:	f04f 0300 	mov.w	r3, #0
 8012b02:	e0f8      	b.n	8012cf6 <pbuf_alloc+0x246>
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
 8012b04:	bf00      	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
 8012b06:	79bb      	ldrb	r3, [r7, #6]
 8012b08:	2b03      	cmp	r3, #3
 8012b0a:	f200 80e8 	bhi.w	8012cde <pbuf_alloc+0x22e>
 8012b0e:	a201      	add	r2, pc, #4	; (adr r2, 8012b14 <pbuf_alloc+0x64>)
 8012b10:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012b14:	08012c31 	.word	0x08012c31
 8012b18:	08012c9b 	.word	0x08012c9b
 8012b1c:	08012c9b 	.word	0x08012c9b
 8012b20:	08012b25 	.word	0x08012b25
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = memp_malloc(MEMP_PBUF_POOL);
 8012b24:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8012b28:	f6c0 0302 	movt	r3, #2050	; 0x802
 8012b2c:	8a5b      	ldrh	r3, [r3, #18]
 8012b2e:	4618      	mov	r0, r3
 8012b30:	f7ff faee 	bl	8012110 <mem_malloc>
 8012b34:	61f8      	str	r0, [r7, #28]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 8012b36:	69fb      	ldr	r3, [r7, #28]
 8012b38:	2b00      	cmp	r3, #0
 8012b3a:	d102      	bne.n	8012b42 <pbuf_alloc+0x92>
      PBUF_POOL_IS_EMPTY();
      return NULL;
 8012b3c:	f04f 0300 	mov.w	r3, #0
 8012b40:	e0d9      	b.n	8012cf6 <pbuf_alloc+0x246>
    }
    p->type = type;
 8012b42:	69fb      	ldr	r3, [r7, #28]
 8012b44:	79ba      	ldrb	r2, [r7, #6]
 8012b46:	731a      	strb	r2, [r3, #12]
    p->next = NULL;
 8012b48:	69fb      	ldr	r3, [r7, #28]
 8012b4a:	f04f 0200 	mov.w	r2, #0
 8012b4e:	601a      	str	r2, [r3, #0]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8012b50:	8afb      	ldrh	r3, [r7, #22]
 8012b52:	f103 0310 	add.w	r3, r3, #16
 8012b56:	69fa      	ldr	r2, [r7, #28]
 8012b58:	18d3      	adds	r3, r2, r3
 8012b5a:	f103 0303 	add.w	r3, r3, #3
 8012b5e:	f023 0303 	bic.w	r3, r3, #3
 8012b62:	461a      	mov	r2, r3
 8012b64:	69fb      	ldr	r3, [r7, #28]
 8012b66:	605a      	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 8012b68:	69fb      	ldr	r3, [r7, #28]
 8012b6a:	88ba      	ldrh	r2, [r7, #4]
 8012b6c:	811a      	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8012b6e:	8afb      	ldrh	r3, [r7, #22]
 8012b70:	f103 0303 	add.w	r3, r3, #3
 8012b74:	f023 0303 	bic.w	r3, r3, #3
 8012b78:	f5c3 63bb 	rsb	r3, r3, #1496	; 0x5d8
 8012b7c:	f103 0304 	add.w	r3, r3, #4
 8012b80:	88ba      	ldrh	r2, [r7, #4]
 8012b82:	4293      	cmp	r3, r2
 8012b84:	bfa8      	it	ge
 8012b86:	4613      	movge	r3, r2
 8012b88:	b29a      	uxth	r2, r3
 8012b8a:	69fb      	ldr	r3, [r7, #28]
 8012b8c:	815a      	strh	r2, [r3, #10]
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 8012b8e:	69fb      	ldr	r3, [r7, #28]
 8012b90:	f04f 0201 	mov.w	r2, #1
 8012b94:	81da      	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
 8012b96:	69fb      	ldr	r3, [r7, #28]
 8012b98:	61bb      	str	r3, [r7, #24]
    /* remaining length to be allocated */
    rem_len = length - p->len;
 8012b9a:	88ba      	ldrh	r2, [r7, #4]
 8012b9c:	69fb      	ldr	r3, [r7, #28]
 8012b9e:	895b      	ldrh	r3, [r3, #10]
 8012ba0:	1ad3      	subs	r3, r2, r3
 8012ba2:	613b      	str	r3, [r7, #16]
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8012ba4:	e040      	b.n	8012c28 <pbuf_alloc+0x178>
      q = memp_malloc(MEMP_PBUF_POOL);
 8012ba6:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8012baa:	f6c0 0302 	movt	r3, #2050	; 0x802
 8012bae:	8a5b      	ldrh	r3, [r3, #18]
 8012bb0:	4618      	mov	r0, r3
 8012bb2:	f7ff faad 	bl	8012110 <mem_malloc>
 8012bb6:	60f8      	str	r0, [r7, #12]
      if (q == NULL) {
 8012bb8:	68fb      	ldr	r3, [r7, #12]
 8012bba:	2b00      	cmp	r3, #0
 8012bbc:	d105      	bne.n	8012bca <pbuf_alloc+0x11a>
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
 8012bbe:	69f8      	ldr	r0, [r7, #28]
 8012bc0:	f000 f97e 	bl	8012ec0 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
 8012bc4:	f04f 0300 	mov.w	r3, #0
 8012bc8:	e095      	b.n	8012cf6 <pbuf_alloc+0x246>
      }
      q->type = type;
 8012bca:	68fb      	ldr	r3, [r7, #12]
 8012bcc:	79ba      	ldrb	r2, [r7, #6]
 8012bce:	731a      	strb	r2, [r3, #12]
      q->flags = 0;
 8012bd0:	68fb      	ldr	r3, [r7, #12]
 8012bd2:	f04f 0200 	mov.w	r2, #0
 8012bd6:	735a      	strb	r2, [r3, #13]
      q->next = NULL;
 8012bd8:	68fb      	ldr	r3, [r7, #12]
 8012bda:	f04f 0200 	mov.w	r2, #0
 8012bde:	601a      	str	r2, [r3, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
 8012be0:	69bb      	ldr	r3, [r7, #24]
 8012be2:	68fa      	ldr	r2, [r7, #12]
 8012be4:	601a      	str	r2, [r3, #0]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 8012be6:	693b      	ldr	r3, [r7, #16]
 8012be8:	b29a      	uxth	r2, r3
 8012bea:	68fb      	ldr	r3, [r7, #12]
 8012bec:	811a      	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8012bee:	693b      	ldr	r3, [r7, #16]
 8012bf0:	b29a      	uxth	r2, r3
 8012bf2:	f240 53db 	movw	r3, #1499	; 0x5db
 8012bf6:	429a      	cmp	r2, r3
 8012bf8:	d802      	bhi.n	8012c00 <pbuf_alloc+0x150>
 8012bfa:	693b      	ldr	r3, [r7, #16]
 8012bfc:	b29b      	uxth	r3, r3
 8012bfe:	e001      	b.n	8012c04 <pbuf_alloc+0x154>
 8012c00:	f240 53dc 	movw	r3, #1500	; 0x5dc
 8012c04:	68fa      	ldr	r2, [r7, #12]
 8012c06:	8153      	strh	r3, [r2, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8012c08:	68fb      	ldr	r3, [r7, #12]
 8012c0a:	f103 0210 	add.w	r2, r3, #16
 8012c0e:	68fb      	ldr	r3, [r7, #12]
 8012c10:	605a      	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 8012c12:	68fb      	ldr	r3, [r7, #12]
 8012c14:	f04f 0201 	mov.w	r2, #1
 8012c18:	81da      	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 8012c1a:	68fb      	ldr	r3, [r7, #12]
 8012c1c:	895b      	ldrh	r3, [r3, #10]
 8012c1e:	693a      	ldr	r2, [r7, #16]
 8012c20:	1ad3      	subs	r3, r2, r3
 8012c22:	613b      	str	r3, [r7, #16]
      /* remember this pbuf for linkage in next iteration */
      r = q;
 8012c24:	68fb      	ldr	r3, [r7, #12]
 8012c26:	61bb      	str	r3, [r7, #24]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8012c28:	693b      	ldr	r3, [r7, #16]
 8012c2a:	2b00      	cmp	r3, #0
 8012c2c:	dcbb      	bgt.n	8012ba6 <pbuf_alloc+0xf6>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
 8012c2e:	e059      	b.n	8012ce4 <pbuf_alloc+0x234>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 8012c30:	8afb      	ldrh	r3, [r7, #22]
 8012c32:	f103 0313 	add.w	r3, r3, #19
 8012c36:	b29b      	uxth	r3, r3
 8012c38:	f023 0303 	bic.w	r3, r3, #3
 8012c3c:	b29a      	uxth	r2, r3
 8012c3e:	88bb      	ldrh	r3, [r7, #4]
 8012c40:	f103 0303 	add.w	r3, r3, #3
 8012c44:	b29b      	uxth	r3, r3
 8012c46:	f023 0303 	bic.w	r3, r3, #3
 8012c4a:	b29b      	uxth	r3, r3
 8012c4c:	18d3      	adds	r3, r2, r3
 8012c4e:	b29b      	uxth	r3, r3
 8012c50:	4618      	mov	r0, r3
 8012c52:	f7ff fa5d 	bl	8012110 <mem_malloc>
 8012c56:	61f8      	str	r0, [r7, #28]
    if (p == NULL) {
 8012c58:	69fb      	ldr	r3, [r7, #28]
 8012c5a:	2b00      	cmp	r3, #0
 8012c5c:	d102      	bne.n	8012c64 <pbuf_alloc+0x1b4>
      return NULL;
 8012c5e:	f04f 0300 	mov.w	r3, #0
 8012c62:	e048      	b.n	8012cf6 <pbuf_alloc+0x246>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8012c64:	8afb      	ldrh	r3, [r7, #22]
 8012c66:	f103 0310 	add.w	r3, r3, #16
 8012c6a:	69fa      	ldr	r2, [r7, #28]
 8012c6c:	18d3      	adds	r3, r2, r3
 8012c6e:	f103 0303 	add.w	r3, r3, #3
 8012c72:	f023 0303 	bic.w	r3, r3, #3
 8012c76:	461a      	mov	r2, r3
 8012c78:	69fb      	ldr	r3, [r7, #28]
 8012c7a:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
 8012c7c:	69fb      	ldr	r3, [r7, #28]
 8012c7e:	88ba      	ldrh	r2, [r7, #4]
 8012c80:	811a      	strh	r2, [r3, #8]
 8012c82:	69fb      	ldr	r3, [r7, #28]
 8012c84:	891a      	ldrh	r2, [r3, #8]
 8012c86:	69fb      	ldr	r3, [r7, #28]
 8012c88:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
 8012c8a:	69fb      	ldr	r3, [r7, #28]
 8012c8c:	f04f 0200 	mov.w	r2, #0
 8012c90:	601a      	str	r2, [r3, #0]
    p->type = type;
 8012c92:	69fb      	ldr	r3, [r7, #28]
 8012c94:	79ba      	ldrb	r2, [r7, #6]
 8012c96:	731a      	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
 8012c98:	e024      	b.n	8012ce4 <pbuf_alloc+0x234>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
 8012c9a:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8012c9e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8012ca2:	8a1b      	ldrh	r3, [r3, #16]
 8012ca4:	4618      	mov	r0, r3
 8012ca6:	f7ff fa33 	bl	8012110 <mem_malloc>
 8012caa:	61f8      	str	r0, [r7, #28]
    if (p == NULL) {
 8012cac:	69fb      	ldr	r3, [r7, #28]
 8012cae:	2b00      	cmp	r3, #0
 8012cb0:	d102      	bne.n	8012cb8 <pbuf_alloc+0x208>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
 8012cb2:	f04f 0300 	mov.w	r3, #0
 8012cb6:	e01e      	b.n	8012cf6 <pbuf_alloc+0x246>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 8012cb8:	69fb      	ldr	r3, [r7, #28]
 8012cba:	f04f 0200 	mov.w	r2, #0
 8012cbe:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
 8012cc0:	69fb      	ldr	r3, [r7, #28]
 8012cc2:	88ba      	ldrh	r2, [r7, #4]
 8012cc4:	811a      	strh	r2, [r3, #8]
 8012cc6:	69fb      	ldr	r3, [r7, #28]
 8012cc8:	891a      	ldrh	r2, [r3, #8]
 8012cca:	69fb      	ldr	r3, [r7, #28]
 8012ccc:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
 8012cce:	69fb      	ldr	r3, [r7, #28]
 8012cd0:	f04f 0200 	mov.w	r2, #0
 8012cd4:	601a      	str	r2, [r3, #0]
    p->type = type;
 8012cd6:	69fb      	ldr	r3, [r7, #28]
 8012cd8:	79ba      	ldrb	r2, [r7, #6]
 8012cda:	731a      	strb	r2, [r3, #12]
    break;
 8012cdc:	e002      	b.n	8012ce4 <pbuf_alloc+0x234>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
 8012cde:	f04f 0300 	mov.w	r3, #0
 8012ce2:	e008      	b.n	8012cf6 <pbuf_alloc+0x246>
  }
  /* set reference count */
  p->ref = 1;
 8012ce4:	69fb      	ldr	r3, [r7, #28]
 8012ce6:	f04f 0201 	mov.w	r2, #1
 8012cea:	81da      	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
 8012cec:	69fb      	ldr	r3, [r7, #28]
 8012cee:	f04f 0200 	mov.w	r2, #0
 8012cf2:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 8012cf4:	69fb      	ldr	r3, [r7, #28]
}
 8012cf6:	4618      	mov	r0, r3
 8012cf8:	f107 0720 	add.w	r7, r7, #32
 8012cfc:	46bd      	mov	sp, r7
 8012cfe:	bd80      	pop	{r7, pc}

08012d00 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 8012d00:	b580      	push	{r7, lr}
 8012d02:	b086      	sub	sp, #24
 8012d04:	af00      	add	r7, sp, #0
 8012d06:	6078      	str	r0, [r7, #4]
 8012d08:	460b      	mov	r3, r1
 8012d0a:	807b      	strh	r3, [r7, #2]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8012d0c:	687b      	ldr	r3, [r7, #4]
 8012d0e:	7b1b      	ldrb	r3, [r3, #12]
 8012d10:	2b03      	cmp	r3, #3
 8012d12:	d006      	beq.n	8012d22 <pbuf_realloc+0x22>
 8012d14:	687b      	ldr	r3, [r7, #4]
 8012d16:	7b1b      	ldrb	r3, [r3, #12]
 8012d18:	2b01      	cmp	r3, #1
 8012d1a:	d002      	beq.n	8012d22 <pbuf_realloc+0x22>
 8012d1c:	687b      	ldr	r3, [r7, #4]
 8012d1e:	7b1b      	ldrb	r3, [r3, #12]
 8012d20:	2b00      	cmp	r3, #0
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 8012d22:	687b      	ldr	r3, [r7, #4]
 8012d24:	891b      	ldrh	r3, [r3, #8]
 8012d26:	887a      	ldrh	r2, [r7, #2]
 8012d28:	429a      	cmp	r2, r3
 8012d2a:	d24a      	bcs.n	8012dc2 <pbuf_realloc+0xc2>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
 8012d2c:	887a      	ldrh	r2, [r7, #2]
 8012d2e:	687b      	ldr	r3, [r7, #4]
 8012d30:	891b      	ldrh	r3, [r3, #8]
 8012d32:	1ad3      	subs	r3, r2, r3
 8012d34:	60fb      	str	r3, [r7, #12]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 8012d36:	887b      	ldrh	r3, [r7, #2]
 8012d38:	827b      	strh	r3, [r7, #18]
  q = p;
 8012d3a:	687b      	ldr	r3, [r7, #4]
 8012d3c:	617b      	str	r3, [r7, #20]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 8012d3e:	e00f      	b.n	8012d60 <pbuf_realloc+0x60>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 8012d40:	697b      	ldr	r3, [r7, #20]
 8012d42:	895b      	ldrh	r3, [r3, #10]
 8012d44:	8a7a      	ldrh	r2, [r7, #18]
 8012d46:	1ad3      	subs	r3, r2, r3
 8012d48:	827b      	strh	r3, [r7, #18]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 8012d4a:	697b      	ldr	r3, [r7, #20]
 8012d4c:	891a      	ldrh	r2, [r3, #8]
 8012d4e:	68fb      	ldr	r3, [r7, #12]
 8012d50:	b29b      	uxth	r3, r3
 8012d52:	18d3      	adds	r3, r2, r3
 8012d54:	b29a      	uxth	r2, r3
 8012d56:	697b      	ldr	r3, [r7, #20]
 8012d58:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 8012d5a:	697b      	ldr	r3, [r7, #20]
 8012d5c:	681b      	ldr	r3, [r3, #0]
 8012d5e:	617b      	str	r3, [r7, #20]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 8012d60:	697b      	ldr	r3, [r7, #20]
 8012d62:	895b      	ldrh	r3, [r3, #10]
 8012d64:	8a7a      	ldrh	r2, [r7, #18]
 8012d66:	429a      	cmp	r2, r3
 8012d68:	d8ea      	bhi.n	8012d40 <pbuf_realloc+0x40>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 8012d6a:	697b      	ldr	r3, [r7, #20]
 8012d6c:	7b1b      	ldrb	r3, [r3, #12]
 8012d6e:	2b00      	cmp	r3, #0
 8012d70:	d112      	bne.n	8012d98 <pbuf_realloc+0x98>
 8012d72:	697b      	ldr	r3, [r7, #20]
 8012d74:	895b      	ldrh	r3, [r3, #10]
 8012d76:	8a7a      	ldrh	r2, [r7, #18]
 8012d78:	429a      	cmp	r2, r3
 8012d7a:	d00d      	beq.n	8012d98 <pbuf_realloc+0x98>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
 8012d7c:	697b      	ldr	r3, [r7, #20]
 8012d7e:	685b      	ldr	r3, [r3, #4]
 8012d80:	461a      	mov	r2, r3
 8012d82:	697b      	ldr	r3, [r7, #20]
 8012d84:	1ad3      	subs	r3, r2, r3
 8012d86:	b29a      	uxth	r2, r3
 8012d88:	8a7b      	ldrh	r3, [r7, #18]
 8012d8a:	18d3      	adds	r3, r2, r3
 8012d8c:	b29b      	uxth	r3, r3
 8012d8e:	6978      	ldr	r0, [r7, #20]
 8012d90:	4619      	mov	r1, r3
 8012d92:	f7ff f8d1 	bl	8011f38 <mem_realloc>
 8012d96:	6178      	str	r0, [r7, #20]
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 8012d98:	697b      	ldr	r3, [r7, #20]
 8012d9a:	8a7a      	ldrh	r2, [r7, #18]
 8012d9c:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 8012d9e:	697b      	ldr	r3, [r7, #20]
 8012da0:	895a      	ldrh	r2, [r3, #10]
 8012da2:	697b      	ldr	r3, [r7, #20]
 8012da4:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 8012da6:	697b      	ldr	r3, [r7, #20]
 8012da8:	681b      	ldr	r3, [r3, #0]
 8012daa:	2b00      	cmp	r3, #0
 8012dac:	d004      	beq.n	8012db8 <pbuf_realloc+0xb8>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 8012dae:	697b      	ldr	r3, [r7, #20]
 8012db0:	681b      	ldr	r3, [r3, #0]
 8012db2:	4618      	mov	r0, r3
 8012db4:	f000 f884 	bl	8012ec0 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 8012db8:	697b      	ldr	r3, [r7, #20]
 8012dba:	f04f 0200 	mov.w	r2, #0
 8012dbe:	601a      	str	r2, [r3, #0]
 8012dc0:	e000      	b.n	8012dc4 <pbuf_realloc+0xc4>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
 8012dc2:	bf00      	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
 8012dc4:	f107 0718 	add.w	r7, r7, #24
 8012dc8:	46bd      	mov	sp, r7
 8012dca:	bd80      	pop	{r7, pc}

08012dcc <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 8012dcc:	b480      	push	{r7}
 8012dce:	b085      	sub	sp, #20
 8012dd0:	af00      	add	r7, sp, #0
 8012dd2:	6078      	str	r0, [r7, #4]
 8012dd4:	460b      	mov	r3, r1
 8012dd6:	807b      	strh	r3, [r7, #2]
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
 8012dd8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012ddc:	2b00      	cmp	r3, #0
 8012dde:	d002      	beq.n	8012de6 <pbuf_header+0x1a>
 8012de0:	687b      	ldr	r3, [r7, #4]
 8012de2:	2b00      	cmp	r3, #0
 8012de4:	d102      	bne.n	8012dec <pbuf_header+0x20>
    return 0;
 8012de6:	f04f 0300 	mov.w	r3, #0
 8012dea:	e062      	b.n	8012eb2 <pbuf_header+0xe6>
 
  if (header_size_increment < 0){
 8012dec:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012df0:	2b00      	cmp	r3, #0
 8012df2:	da0b      	bge.n	8012e0c <pbuf_header+0x40>
    increment_magnitude = -header_size_increment;
 8012df4:	887b      	ldrh	r3, [r7, #2]
 8012df6:	f1c3 0300 	rsb	r3, r3, #0
 8012dfa:	81fb      	strh	r3, [r7, #14]
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8012dfc:	687b      	ldr	r3, [r7, #4]
 8012dfe:	895b      	ldrh	r3, [r3, #10]
 8012e00:	89fa      	ldrh	r2, [r7, #14]
 8012e02:	429a      	cmp	r2, r3
 8012e04:	d904      	bls.n	8012e10 <pbuf_header+0x44>
 8012e06:	f04f 0301 	mov.w	r3, #1
 8012e0a:	e052      	b.n	8012eb2 <pbuf_header+0xe6>
  } else {
    increment_magnitude = header_size_increment;
 8012e0c:	887b      	ldrh	r3, [r7, #2]
 8012e0e:	81fb      	strh	r3, [r7, #14]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 8012e10:	687b      	ldr	r3, [r7, #4]
 8012e12:	7b1b      	ldrb	r3, [r3, #12]
 8012e14:	81bb      	strh	r3, [r7, #12]
  /* remember current payload pointer */
  payload = p->payload;
 8012e16:	687b      	ldr	r3, [r7, #4]
 8012e18:	685b      	ldr	r3, [r3, #4]
 8012e1a:	60bb      	str	r3, [r7, #8]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8012e1c:	89bb      	ldrh	r3, [r7, #12]
 8012e1e:	2b00      	cmp	r3, #0
 8012e20:	d002      	beq.n	8012e28 <pbuf_header+0x5c>
 8012e22:	89bb      	ldrh	r3, [r7, #12]
 8012e24:	2b03      	cmp	r3, #3
 8012e26:	d115      	bne.n	8012e54 <pbuf_header+0x88>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 8012e28:	687b      	ldr	r3, [r7, #4]
 8012e2a:	685a      	ldr	r2, [r3, #4]
 8012e2c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012e30:	f1c3 0300 	rsb	r3, r3, #0
 8012e34:	18d2      	adds	r2, r2, r3
 8012e36:	687b      	ldr	r3, [r7, #4]
 8012e38:	605a      	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8012e3a:	687b      	ldr	r3, [r7, #4]
 8012e3c:	685a      	ldr	r2, [r3, #4]
 8012e3e:	687b      	ldr	r3, [r7, #4]
 8012e40:	f103 0310 	add.w	r3, r3, #16
 8012e44:	429a      	cmp	r2, r3
 8012e46:	d224      	bcs.n	8012e92 <pbuf_header+0xc6>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 8012e48:	687b      	ldr	r3, [r7, #4]
 8012e4a:	68ba      	ldr	r2, [r7, #8]
 8012e4c:	605a      	str	r2, [r3, #4]
      /* bail out unsuccesfully */
      return 1;
 8012e4e:	f04f 0301 	mov.w	r3, #1
 8012e52:	e02e      	b.n	8012eb2 <pbuf_header+0xe6>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8012e54:	89bb      	ldrh	r3, [r7, #12]
 8012e56:	2b02      	cmp	r3, #2
 8012e58:	d002      	beq.n	8012e60 <pbuf_header+0x94>
 8012e5a:	89bb      	ldrh	r3, [r7, #12]
 8012e5c:	2b01      	cmp	r3, #1
 8012e5e:	d115      	bne.n	8012e8c <pbuf_header+0xc0>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8012e60:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012e64:	2b00      	cmp	r3, #0
 8012e66:	da0e      	bge.n	8012e86 <pbuf_header+0xba>
 8012e68:	687b      	ldr	r3, [r7, #4]
 8012e6a:	895b      	ldrh	r3, [r3, #10]
 8012e6c:	89fa      	ldrh	r2, [r7, #14]
 8012e6e:	429a      	cmp	r2, r3
 8012e70:	d809      	bhi.n	8012e86 <pbuf_header+0xba>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 8012e72:	687b      	ldr	r3, [r7, #4]
 8012e74:	685a      	ldr	r2, [r3, #4]
 8012e76:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012e7a:	f1c3 0300 	rsb	r3, r3, #0
 8012e7e:	18d2      	adds	r2, r2, r3
 8012e80:	687b      	ldr	r3, [r7, #4]
 8012e82:	605a      	str	r2, [r3, #4]
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8012e84:	e005      	b.n	8012e92 <pbuf_header+0xc6>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
 8012e86:	f04f 0301 	mov.w	r3, #1
 8012e8a:	e012      	b.n	8012eb2 <pbuf_header+0xe6>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 8012e8c:	f04f 0301 	mov.w	r3, #1
 8012e90:	e00f      	b.n	8012eb2 <pbuf_header+0xe6>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8012e92:	687b      	ldr	r3, [r7, #4]
 8012e94:	895a      	ldrh	r2, [r3, #10]
 8012e96:	887b      	ldrh	r3, [r7, #2]
 8012e98:	18d3      	adds	r3, r2, r3
 8012e9a:	b29a      	uxth	r2, r3
 8012e9c:	687b      	ldr	r3, [r7, #4]
 8012e9e:	815a      	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
 8012ea0:	687b      	ldr	r3, [r7, #4]
 8012ea2:	891a      	ldrh	r2, [r3, #8]
 8012ea4:	887b      	ldrh	r3, [r7, #2]
 8012ea6:	18d3      	adds	r3, r2, r3
 8012ea8:	b29a      	uxth	r2, r3
 8012eaa:	687b      	ldr	r3, [r7, #4]
 8012eac:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 8012eae:	f04f 0300 	mov.w	r3, #0
}
 8012eb2:	4618      	mov	r0, r3
 8012eb4:	f107 0714 	add.w	r7, r7, #20
 8012eb8:	46bd      	mov	sp, r7
 8012eba:	bc80      	pop	{r7}
 8012ebc:	4770      	bx	lr
 8012ebe:	bf00      	nop

08012ec0 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8012ec0:	b580      	push	{r7, lr}
 8012ec2:	b086      	sub	sp, #24
 8012ec4:	af00      	add	r7, sp, #0
 8012ec6:	6078      	str	r0, [r7, #4]
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8012ec8:	687b      	ldr	r3, [r7, #4]
 8012eca:	2b00      	cmp	r3, #0
 8012ecc:	d102      	bne.n	8012ed4 <pbuf_free+0x14>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 8012ece:	f04f 0300 	mov.w	r3, #0
 8012ed2:	e043      	b.n	8012f5c <pbuf_free+0x9c>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 8012ed4:	687b      	ldr	r3, [r7, #4]
 8012ed6:	7b1b      	ldrb	r3, [r3, #12]
 8012ed8:	2b00      	cmp	r3, #0
 8012eda:	d006      	beq.n	8012eea <pbuf_free+0x2a>
 8012edc:	687b      	ldr	r3, [r7, #4]
 8012ede:	7b1b      	ldrb	r3, [r3, #12]
 8012ee0:	2b01      	cmp	r3, #1
 8012ee2:	d002      	beq.n	8012eea <pbuf_free+0x2a>
 8012ee4:	687b      	ldr	r3, [r7, #4]
 8012ee6:	7b1b      	ldrb	r3, [r3, #12]
 8012ee8:	2b02      	cmp	r3, #2
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
 8012eea:	f04f 0300 	mov.w	r3, #0
 8012eee:	75fb      	strb	r3, [r7, #23]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8012ef0:	e030      	b.n	8012f54 <pbuf_free+0x94>
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 8012ef2:	687b      	ldr	r3, [r7, #4]
 8012ef4:	89db      	ldrh	r3, [r3, #14]
 8012ef6:	f103 33ff 	add.w	r3, r3, #4294967295
 8012efa:	b29a      	uxth	r2, r3
 8012efc:	687b      	ldr	r3, [r7, #4]
 8012efe:	81da      	strh	r2, [r3, #14]
 8012f00:	687b      	ldr	r3, [r7, #4]
 8012f02:	89db      	ldrh	r3, [r3, #14]
 8012f04:	82bb      	strh	r3, [r7, #20]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8012f06:	8abb      	ldrh	r3, [r7, #20]
 8012f08:	2b00      	cmp	r3, #0
 8012f0a:	d120      	bne.n	8012f4e <pbuf_free+0x8e>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 8012f0c:	687b      	ldr	r3, [r7, #4]
 8012f0e:	681b      	ldr	r3, [r3, #0]
 8012f10:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 8012f12:	687b      	ldr	r3, [r7, #4]
 8012f14:	7b1b      	ldrb	r3, [r3, #12]
 8012f16:	81fb      	strh	r3, [r7, #14]
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
 8012f18:	89fb      	ldrh	r3, [r7, #14]
 8012f1a:	2b03      	cmp	r3, #3
 8012f1c:	d103      	bne.n	8012f26 <pbuf_free+0x66>
        memp_free(MEMP_PBUF_POOL, p);
 8012f1e:	6878      	ldr	r0, [r7, #4]
 8012f20:	f7fe ffca 	bl	8011eb8 <mem_free>
 8012f24:	e00c      	b.n	8012f40 <pbuf_free+0x80>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
 8012f26:	89fb      	ldrh	r3, [r7, #14]
 8012f28:	2b01      	cmp	r3, #1
 8012f2a:	d002      	beq.n	8012f32 <pbuf_free+0x72>
 8012f2c:	89fb      	ldrh	r3, [r7, #14]
 8012f2e:	2b02      	cmp	r3, #2
 8012f30:	d103      	bne.n	8012f3a <pbuf_free+0x7a>
        memp_free(MEMP_PBUF, p);
 8012f32:	6878      	ldr	r0, [r7, #4]
 8012f34:	f7fe ffc0 	bl	8011eb8 <mem_free>
 8012f38:	e002      	b.n	8012f40 <pbuf_free+0x80>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
 8012f3a:	6878      	ldr	r0, [r7, #4]
 8012f3c:	f7fe ffbc 	bl	8011eb8 <mem_free>
      }
      count++;
 8012f40:	7dfb      	ldrb	r3, [r7, #23]
 8012f42:	f103 0301 	add.w	r3, r3, #1
 8012f46:	75fb      	strb	r3, [r7, #23]
      /* proceed to next pbuf */
      p = q;
 8012f48:	693b      	ldr	r3, [r7, #16]
 8012f4a:	607b      	str	r3, [r7, #4]
 8012f4c:	e002      	b.n	8012f54 <pbuf_free+0x94>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
 8012f4e:	f04f 0300 	mov.w	r3, #0
 8012f52:	607b      	str	r3, [r7, #4]
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8012f54:	687b      	ldr	r3, [r7, #4]
 8012f56:	2b00      	cmp	r3, #0
 8012f58:	d1cb      	bne.n	8012ef2 <pbuf_free+0x32>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 8012f5a:	7dfb      	ldrb	r3, [r7, #23]
}
 8012f5c:	4618      	mov	r0, r3
 8012f5e:	f107 0718 	add.w	r7, r7, #24
 8012f62:	46bd      	mov	sp, r7
 8012f64:	bd80      	pop	{r7, pc}
 8012f66:	bf00      	nop

08012f68 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
 8012f68:	b480      	push	{r7}
 8012f6a:	b085      	sub	sp, #20
 8012f6c:	af00      	add	r7, sp, #0
 8012f6e:	6078      	str	r0, [r7, #4]
  u8_t len;

  len = 0;
 8012f70:	f04f 0300 	mov.w	r3, #0
 8012f74:	73fb      	strb	r3, [r7, #15]
  while (p != NULL) {
 8012f76:	e006      	b.n	8012f86 <pbuf_clen+0x1e>
    ++len;
 8012f78:	7bfb      	ldrb	r3, [r7, #15]
 8012f7a:	f103 0301 	add.w	r3, r3, #1
 8012f7e:	73fb      	strb	r3, [r7, #15]
    p = p->next;
 8012f80:	687b      	ldr	r3, [r7, #4]
 8012f82:	681b      	ldr	r3, [r3, #0]
 8012f84:	607b      	str	r3, [r7, #4]
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 8012f86:	687b      	ldr	r3, [r7, #4]
 8012f88:	2b00      	cmp	r3, #0
 8012f8a:	d1f5      	bne.n	8012f78 <pbuf_clen+0x10>
    ++len;
    p = p->next;
  }
  return len;
 8012f8c:	7bfb      	ldrb	r3, [r7, #15]
}
 8012f8e:	4618      	mov	r0, r3
 8012f90:	f107 0714 	add.w	r7, r7, #20
 8012f94:	46bd      	mov	sp, r7
 8012f96:	bc80      	pop	{r7}
 8012f98:	4770      	bx	lr
 8012f9a:	bf00      	nop

08012f9c <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 8012f9c:	b480      	push	{r7}
 8012f9e:	b083      	sub	sp, #12
 8012fa0:	af00      	add	r7, sp, #0
 8012fa2:	6078      	str	r0, [r7, #4]
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8012fa4:	687b      	ldr	r3, [r7, #4]
 8012fa6:	2b00      	cmp	r3, #0
 8012fa8:	d006      	beq.n	8012fb8 <pbuf_ref+0x1c>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
 8012faa:	687b      	ldr	r3, [r7, #4]
 8012fac:	89db      	ldrh	r3, [r3, #14]
 8012fae:	f103 0301 	add.w	r3, r3, #1
 8012fb2:	b29a      	uxth	r2, r3
 8012fb4:	687b      	ldr	r3, [r7, #4]
 8012fb6:	81da      	strh	r2, [r3, #14]
    SYS_ARCH_UNPROTECT(old_level);
  }
}
 8012fb8:	f107 070c 	add.w	r7, r7, #12
 8012fbc:	46bd      	mov	sp, r7
 8012fbe:	bc80      	pop	{r7}
 8012fc0:	4770      	bx	lr
 8012fc2:	bf00      	nop

08012fc4 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 8012fc4:	b480      	push	{r7}
 8012fc6:	b085      	sub	sp, #20
 8012fc8:	af00      	add	r7, sp, #0
 8012fca:	6078      	str	r0, [r7, #4]
 8012fcc:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8012fce:	687b      	ldr	r3, [r7, #4]
 8012fd0:	2b00      	cmp	r3, #0
 8012fd2:	d01f      	beq.n	8013014 <pbuf_cat+0x50>
 8012fd4:	683b      	ldr	r3, [r7, #0]
 8012fd6:	2b00      	cmp	r3, #0
 8012fd8:	d01c      	beq.n	8013014 <pbuf_cat+0x50>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8012fda:	687b      	ldr	r3, [r7, #4]
 8012fdc:	60fb      	str	r3, [r7, #12]
 8012fde:	e00a      	b.n	8012ff6 <pbuf_cat+0x32>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 8012fe0:	68fb      	ldr	r3, [r7, #12]
 8012fe2:	891a      	ldrh	r2, [r3, #8]
 8012fe4:	683b      	ldr	r3, [r7, #0]
 8012fe6:	891b      	ldrh	r3, [r3, #8]
 8012fe8:	18d3      	adds	r3, r2, r3
 8012fea:	b29a      	uxth	r2, r3
 8012fec:	68fb      	ldr	r3, [r7, #12]
 8012fee:	811a      	strh	r2, [r3, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8012ff0:	68fb      	ldr	r3, [r7, #12]
 8012ff2:	681b      	ldr	r3, [r3, #0]
 8012ff4:	60fb      	str	r3, [r7, #12]
 8012ff6:	68fb      	ldr	r3, [r7, #12]
 8012ff8:	681b      	ldr	r3, [r3, #0]
 8012ffa:	2b00      	cmp	r3, #0
 8012ffc:	d1f0      	bne.n	8012fe0 <pbuf_cat+0x1c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 8012ffe:	68fb      	ldr	r3, [r7, #12]
 8013000:	891a      	ldrh	r2, [r3, #8]
 8013002:	683b      	ldr	r3, [r7, #0]
 8013004:	891b      	ldrh	r3, [r3, #8]
 8013006:	18d3      	adds	r3, r2, r3
 8013008:	b29a      	uxth	r2, r3
 801300a:	68fb      	ldr	r3, [r7, #12]
 801300c:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 801300e:	68fb      	ldr	r3, [r7, #12]
 8013010:	683a      	ldr	r2, [r7, #0]
 8013012:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 8013014:	f107 0714 	add.w	r7, r7, #20
 8013018:	46bd      	mov	sp, r7
 801301a:	bc80      	pop	{r7}
 801301c:	4770      	bx	lr
 801301e:	bf00      	nop

08013020 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 8013020:	b580      	push	{r7, lr}
 8013022:	b082      	sub	sp, #8
 8013024:	af00      	add	r7, sp, #0
 8013026:	6078      	str	r0, [r7, #4]
 8013028:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 801302a:	6878      	ldr	r0, [r7, #4]
 801302c:	6839      	ldr	r1, [r7, #0]
 801302e:	f7ff ffc9 	bl	8012fc4 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 8013032:	6838      	ldr	r0, [r7, #0]
 8013034:	f7ff ffb2 	bl	8012f9c <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 8013038:	f107 0708 	add.w	r7, r7, #8
 801303c:	46bd      	mov	sp, r7
 801303e:	bd80      	pop	{r7, pc}

08013040 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 8013040:	b580      	push	{r7, lr}
 8013042:	b084      	sub	sp, #16
 8013044:	af00      	add	r7, sp, #0
 8013046:	6078      	str	r0, [r7, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
 8013048:	f04f 0301 	mov.w	r3, #1
 801304c:	73fb      	strb	r3, [r7, #15]
  /* tail */
  q = p->next;
 801304e:	687b      	ldr	r3, [r7, #4]
 8013050:	681b      	ldr	r3, [r3, #0]
 8013052:	60bb      	str	r3, [r7, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
 8013054:	68bb      	ldr	r3, [r7, #8]
 8013056:	2b00      	cmp	r3, #0
 8013058:	d014      	beq.n	8013084 <pbuf_dechain+0x44>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
 801305a:	687b      	ldr	r3, [r7, #4]
 801305c:	891a      	ldrh	r2, [r3, #8]
 801305e:	687b      	ldr	r3, [r7, #4]
 8013060:	895b      	ldrh	r3, [r3, #10]
 8013062:	1ad3      	subs	r3, r2, r3
 8013064:	b29a      	uxth	r2, r3
 8013066:	68bb      	ldr	r3, [r7, #8]
 8013068:	811a      	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
 801306a:	687b      	ldr	r3, [r7, #4]
 801306c:	f04f 0200 	mov.w	r2, #0
 8013070:	601a      	str	r2, [r3, #0]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 8013072:	687b      	ldr	r3, [r7, #4]
 8013074:	895a      	ldrh	r2, [r3, #10]
 8013076:	687b      	ldr	r3, [r7, #4]
 8013078:	811a      	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 801307a:	68b8      	ldr	r0, [r7, #8]
 801307c:	f7ff ff20 	bl	8012ec0 <pbuf_free>
 8013080:	4603      	mov	r3, r0
 8013082:	73fb      	strb	r3, [r7, #15]
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
 8013084:	7bfb      	ldrb	r3, [r7, #15]
 8013086:	2b00      	cmp	r3, #0
 8013088:	d101      	bne.n	801308e <pbuf_dechain+0x4e>
 801308a:	68bb      	ldr	r3, [r7, #8]
 801308c:	e001      	b.n	8013092 <pbuf_dechain+0x52>
 801308e:	f04f 0300 	mov.w	r3, #0
}
 8013092:	4618      	mov	r0, r3
 8013094:	f107 0710 	add.w	r7, r7, #16
 8013098:	46bd      	mov	sp, r7
 801309a:	bd80      	pop	{r7, pc}

0801309c <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 801309c:	b580      	push	{r7, lr}
 801309e:	b084      	sub	sp, #16
 80130a0:	af00      	add	r7, sp, #0
 80130a2:	6078      	str	r0, [r7, #4]
 80130a4:	6039      	str	r1, [r7, #0]
  u16_t offset_to=0, offset_from=0, len;
 80130a6:	f04f 0300 	mov.w	r3, #0
 80130aa:	81fb      	strh	r3, [r7, #14]
 80130ac:	f04f 0300 	mov.w	r3, #0
 80130b0:	81bb      	strh	r3, [r7, #12]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80130b2:	687b      	ldr	r3, [r7, #4]
 80130b4:	2b00      	cmp	r3, #0
 80130b6:	d008      	beq.n	80130ca <pbuf_copy+0x2e>
 80130b8:	683b      	ldr	r3, [r7, #0]
 80130ba:	2b00      	cmp	r3, #0
 80130bc:	d005      	beq.n	80130ca <pbuf_copy+0x2e>
 80130be:	687b      	ldr	r3, [r7, #4]
 80130c0:	891a      	ldrh	r2, [r3, #8]
 80130c2:	683b      	ldr	r3, [r7, #0]
 80130c4:	891b      	ldrh	r3, [r3, #8]
 80130c6:	429a      	cmp	r2, r3
 80130c8:	d202      	bcs.n	80130d0 <pbuf_copy+0x34>
 80130ca:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 80130ce:	e067      	b.n	80131a0 <pbuf_copy+0x104>
  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 80130d0:	687b      	ldr	r3, [r7, #4]
 80130d2:	895b      	ldrh	r3, [r3, #10]
 80130d4:	461a      	mov	r2, r3
 80130d6:	89fb      	ldrh	r3, [r7, #14]
 80130d8:	1ad2      	subs	r2, r2, r3
 80130da:	683b      	ldr	r3, [r7, #0]
 80130dc:	895b      	ldrh	r3, [r3, #10]
 80130de:	4619      	mov	r1, r3
 80130e0:	89bb      	ldrh	r3, [r7, #12]
 80130e2:	1acb      	subs	r3, r1, r3
 80130e4:	429a      	cmp	r2, r3
 80130e6:	db05      	blt.n	80130f4 <pbuf_copy+0x58>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 80130e8:	683b      	ldr	r3, [r7, #0]
 80130ea:	895a      	ldrh	r2, [r3, #10]
 80130ec:	89bb      	ldrh	r3, [r7, #12]
 80130ee:	1ad3      	subs	r3, r2, r3
 80130f0:	817b      	strh	r3, [r7, #10]
 80130f2:	e004      	b.n	80130fe <pbuf_copy+0x62>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 80130f4:	687b      	ldr	r3, [r7, #4]
 80130f6:	895a      	ldrh	r2, [r3, #10]
 80130f8:	89fb      	ldrh	r3, [r7, #14]
 80130fa:	1ad3      	subs	r3, r2, r3
 80130fc:	817b      	strh	r3, [r7, #10]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 80130fe:	687b      	ldr	r3, [r7, #4]
 8013100:	685a      	ldr	r2, [r3, #4]
 8013102:	89fb      	ldrh	r3, [r7, #14]
 8013104:	18d1      	adds	r1, r2, r3
 8013106:	683b      	ldr	r3, [r7, #0]
 8013108:	685a      	ldr	r2, [r3, #4]
 801310a:	89bb      	ldrh	r3, [r7, #12]
 801310c:	18d2      	adds	r2, r2, r3
 801310e:	897b      	ldrh	r3, [r7, #10]
 8013110:	4608      	mov	r0, r1
 8013112:	4611      	mov	r1, r2
 8013114:	461a      	mov	r2, r3
 8013116:	f010 fa7d 	bl	8023614 <memcpy>
    offset_to += len;
 801311a:	89fa      	ldrh	r2, [r7, #14]
 801311c:	897b      	ldrh	r3, [r7, #10]
 801311e:	18d3      	adds	r3, r2, r3
 8013120:	81fb      	strh	r3, [r7, #14]
    offset_from += len;
 8013122:	89ba      	ldrh	r2, [r7, #12]
 8013124:	897b      	ldrh	r3, [r7, #10]
 8013126:	18d3      	adds	r3, r2, r3
 8013128:	81bb      	strh	r3, [r7, #12]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
 801312a:	687b      	ldr	r3, [r7, #4]
 801312c:	895b      	ldrh	r3, [r3, #10]
 801312e:	89fa      	ldrh	r2, [r7, #14]
 8013130:	429a      	cmp	r2, r3
 8013132:	d105      	bne.n	8013140 <pbuf_copy+0xa4>
      /* on to next p_to (if any) */
      offset_to = 0;
 8013134:	f04f 0300 	mov.w	r3, #0
 8013138:	81fb      	strh	r3, [r7, #14]
      p_to = p_to->next;
 801313a:	687b      	ldr	r3, [r7, #4]
 801313c:	681b      	ldr	r3, [r3, #0]
 801313e:	607b      	str	r3, [r7, #4]
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 8013140:	683b      	ldr	r3, [r7, #0]
 8013142:	895b      	ldrh	r3, [r3, #10]
 8013144:	89ba      	ldrh	r2, [r7, #12]
 8013146:	429a      	cmp	r2, r3
 8013148:	d305      	bcc.n	8013156 <pbuf_copy+0xba>
      /* on to next p_from (if any) */
      offset_from = 0;
 801314a:	f04f 0300 	mov.w	r3, #0
 801314e:	81bb      	strh	r3, [r7, #12]
      p_from = p_from->next;
 8013150:	683b      	ldr	r3, [r7, #0]
 8013152:	681b      	ldr	r3, [r3, #0]
 8013154:	603b      	str	r3, [r7, #0]
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8013156:	683b      	ldr	r3, [r7, #0]
 8013158:	2b00      	cmp	r3, #0
 801315a:	d00c      	beq.n	8013176 <pbuf_copy+0xda>
 801315c:	683b      	ldr	r3, [r7, #0]
 801315e:	895a      	ldrh	r2, [r3, #10]
 8013160:	683b      	ldr	r3, [r7, #0]
 8013162:	891b      	ldrh	r3, [r3, #8]
 8013164:	429a      	cmp	r2, r3
 8013166:	d106      	bne.n	8013176 <pbuf_copy+0xda>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8013168:	683b      	ldr	r3, [r7, #0]
 801316a:	681b      	ldr	r3, [r3, #0]
 801316c:	2b00      	cmp	r3, #0
 801316e:	d002      	beq.n	8013176 <pbuf_copy+0xda>
 8013170:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8013174:	e014      	b.n	80131a0 <pbuf_copy+0x104>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8013176:	687b      	ldr	r3, [r7, #4]
 8013178:	2b00      	cmp	r3, #0
 801317a:	d00c      	beq.n	8013196 <pbuf_copy+0xfa>
 801317c:	687b      	ldr	r3, [r7, #4]
 801317e:	895a      	ldrh	r2, [r3, #10]
 8013180:	687b      	ldr	r3, [r7, #4]
 8013182:	891b      	ldrh	r3, [r3, #8]
 8013184:	429a      	cmp	r2, r3
 8013186:	d106      	bne.n	8013196 <pbuf_copy+0xfa>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8013188:	687b      	ldr	r3, [r7, #4]
 801318a:	681b      	ldr	r3, [r3, #0]
 801318c:	2b00      	cmp	r3, #0
 801318e:	d002      	beq.n	8013196 <pbuf_copy+0xfa>
 8013190:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8013194:	e004      	b.n	80131a0 <pbuf_copy+0x104>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 8013196:	683b      	ldr	r3, [r7, #0]
 8013198:	2b00      	cmp	r3, #0
 801319a:	d199      	bne.n	80130d0 <pbuf_copy+0x34>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 801319c:	f04f 0300 	mov.w	r3, #0
 80131a0:	b25b      	sxtb	r3, r3
}
 80131a2:	4618      	mov	r0, r3
 80131a4:	f107 0710 	add.w	r7, r7, #16
 80131a8:	46bd      	mov	sp, r7
 80131aa:	bd80      	pop	{r7, pc}

080131ac <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 80131ac:	b580      	push	{r7, lr}
 80131ae:	b088      	sub	sp, #32
 80131b0:	af00      	add	r7, sp, #0
 80131b2:	60f8      	str	r0, [r7, #12]
 80131b4:	60b9      	str	r1, [r7, #8]
 80131b6:	80fa      	strh	r2, [r7, #6]
 80131b8:	80bb      	strh	r3, [r7, #4]
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 80131ba:	f04f 0300 	mov.w	r3, #0
 80131be:	82fb      	strh	r3, [r7, #22]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 80131c0:	68fb      	ldr	r3, [r7, #12]
 80131c2:	2b00      	cmp	r3, #0
 80131c4:	d102      	bne.n	80131cc <pbuf_copy_partial+0x20>
 80131c6:	f04f 0300 	mov.w	r3, #0
 80131ca:	e053      	b.n	8013274 <pbuf_copy_partial+0xc8>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 80131cc:	68bb      	ldr	r3, [r7, #8]
 80131ce:	2b00      	cmp	r3, #0
 80131d0:	d102      	bne.n	80131d8 <pbuf_copy_partial+0x2c>
 80131d2:	f04f 0300 	mov.w	r3, #0
 80131d6:	e04d      	b.n	8013274 <pbuf_copy_partial+0xc8>

  left = 0;
 80131d8:	f04f 0300 	mov.w	r3, #0
 80131dc:	837b      	strh	r3, [r7, #26]

  if((buf == NULL) || (dataptr == NULL)) {
 80131de:	68fb      	ldr	r3, [r7, #12]
 80131e0:	2b00      	cmp	r3, #0
 80131e2:	d002      	beq.n	80131ea <pbuf_copy_partial+0x3e>
 80131e4:	68bb      	ldr	r3, [r7, #8]
 80131e6:	2b00      	cmp	r3, #0
 80131e8:	d102      	bne.n	80131f0 <pbuf_copy_partial+0x44>
    return 0;
 80131ea:	f04f 0300 	mov.w	r3, #0
 80131ee:	e041      	b.n	8013274 <pbuf_copy_partial+0xc8>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 80131f0:	68fb      	ldr	r3, [r7, #12]
 80131f2:	61fb      	str	r3, [r7, #28]
 80131f4:	e037      	b.n	8013266 <pbuf_copy_partial+0xba>
    if ((offset != 0) && (offset >= p->len)) {
 80131f6:	88bb      	ldrh	r3, [r7, #4]
 80131f8:	2b00      	cmp	r3, #0
 80131fa:	d00a      	beq.n	8013212 <pbuf_copy_partial+0x66>
 80131fc:	69fb      	ldr	r3, [r7, #28]
 80131fe:	895b      	ldrh	r3, [r3, #10]
 8013200:	88ba      	ldrh	r2, [r7, #4]
 8013202:	429a      	cmp	r2, r3
 8013204:	d305      	bcc.n	8013212 <pbuf_copy_partial+0x66>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 8013206:	69fb      	ldr	r3, [r7, #28]
 8013208:	895b      	ldrh	r3, [r3, #10]
 801320a:	88ba      	ldrh	r2, [r7, #4]
 801320c:	1ad3      	subs	r3, r2, r3
 801320e:	80bb      	strh	r3, [r7, #4]
 8013210:	e026      	b.n	8013260 <pbuf_copy_partial+0xb4>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 8013212:	69fb      	ldr	r3, [r7, #28]
 8013214:	895a      	ldrh	r2, [r3, #10]
 8013216:	88bb      	ldrh	r3, [r7, #4]
 8013218:	1ad3      	subs	r3, r2, r3
 801321a:	833b      	strh	r3, [r7, #24]
      if (buf_copy_len > len)
 801321c:	8b3a      	ldrh	r2, [r7, #24]
 801321e:	88fb      	ldrh	r3, [r7, #6]
 8013220:	429a      	cmp	r2, r3
 8013222:	d901      	bls.n	8013228 <pbuf_copy_partial+0x7c>
          buf_copy_len = len;
 8013224:	88fb      	ldrh	r3, [r7, #6]
 8013226:	833b      	strh	r3, [r7, #24]
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8013228:	8b7b      	ldrh	r3, [r7, #26]
 801322a:	68ba      	ldr	r2, [r7, #8]
 801322c:	18d1      	adds	r1, r2, r3
 801322e:	69fb      	ldr	r3, [r7, #28]
 8013230:	685a      	ldr	r2, [r3, #4]
 8013232:	88bb      	ldrh	r3, [r7, #4]
 8013234:	18d2      	adds	r2, r2, r3
 8013236:	8b3b      	ldrh	r3, [r7, #24]
 8013238:	4608      	mov	r0, r1
 801323a:	4611      	mov	r1, r2
 801323c:	461a      	mov	r2, r3
 801323e:	f010 f9e9 	bl	8023614 <memcpy>
      copied_total += buf_copy_len;
 8013242:	8afa      	ldrh	r2, [r7, #22]
 8013244:	8b3b      	ldrh	r3, [r7, #24]
 8013246:	18d3      	adds	r3, r2, r3
 8013248:	82fb      	strh	r3, [r7, #22]
      left += buf_copy_len;
 801324a:	8b7a      	ldrh	r2, [r7, #26]
 801324c:	8b3b      	ldrh	r3, [r7, #24]
 801324e:	18d3      	adds	r3, r2, r3
 8013250:	837b      	strh	r3, [r7, #26]
      len -= buf_copy_len;
 8013252:	88fa      	ldrh	r2, [r7, #6]
 8013254:	8b3b      	ldrh	r3, [r7, #24]
 8013256:	1ad3      	subs	r3, r2, r3
 8013258:	80fb      	strh	r3, [r7, #6]
      offset = 0;
 801325a:	f04f 0300 	mov.w	r3, #0
 801325e:	80bb      	strh	r3, [r7, #4]
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8013260:	69fb      	ldr	r3, [r7, #28]
 8013262:	681b      	ldr	r3, [r3, #0]
 8013264:	61fb      	str	r3, [r7, #28]
 8013266:	88fb      	ldrh	r3, [r7, #6]
 8013268:	2b00      	cmp	r3, #0
 801326a:	d002      	beq.n	8013272 <pbuf_copy_partial+0xc6>
 801326c:	69fb      	ldr	r3, [r7, #28]
 801326e:	2b00      	cmp	r3, #0
 8013270:	d1c1      	bne.n	80131f6 <pbuf_copy_partial+0x4a>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
 8013272:	8afb      	ldrh	r3, [r7, #22]
}
 8013274:	4618      	mov	r0, r3
 8013276:	f107 0720 	add.w	r7, r7, #32
 801327a:	46bd      	mov	sp, r7
 801327c:	bd80      	pop	{r7, pc}
 801327e:	bf00      	nop

08013280 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 8013280:	b580      	push	{r7, lr}
 8013282:	b088      	sub	sp, #32
 8013284:	af00      	add	r7, sp, #0
 8013286:	60f8      	str	r0, [r7, #12]
 8013288:	60b9      	str	r1, [r7, #8]
 801328a:	4613      	mov	r3, r2
 801328c:	80fb      	strh	r3, [r7, #6]
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
 801328e:	88fb      	ldrh	r3, [r7, #6]
 8013290:	833b      	strh	r3, [r7, #24]
  u16_t copied_total = 0;
 8013292:	f04f 0300 	mov.w	r3, #0
 8013296:	82fb      	strh	r3, [r7, #22]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 8013298:	68fb      	ldr	r3, [r7, #12]
 801329a:	2b00      	cmp	r3, #0
 801329c:	d102      	bne.n	80132a4 <pbuf_take+0x24>
 801329e:	f04f 0300 	mov.w	r3, #0
 80132a2:	e03b      	b.n	801331c <pbuf_take+0x9c>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 80132a4:	68bb      	ldr	r3, [r7, #8]
 80132a6:	2b00      	cmp	r3, #0
 80132a8:	d102      	bne.n	80132b0 <pbuf_take+0x30>
 80132aa:	f04f 0300 	mov.w	r3, #0
 80132ae:	e035      	b.n	801331c <pbuf_take+0x9c>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 80132b0:	68fb      	ldr	r3, [r7, #12]
 80132b2:	2b00      	cmp	r3, #0
 80132b4:	d007      	beq.n	80132c6 <pbuf_take+0x46>
 80132b6:	68bb      	ldr	r3, [r7, #8]
 80132b8:	2b00      	cmp	r3, #0
 80132ba:	d004      	beq.n	80132c6 <pbuf_take+0x46>
 80132bc:	68fb      	ldr	r3, [r7, #12]
 80132be:	891b      	ldrh	r3, [r3, #8]
 80132c0:	88fa      	ldrh	r2, [r7, #6]
 80132c2:	429a      	cmp	r2, r3
 80132c4:	d902      	bls.n	80132cc <pbuf_take+0x4c>
    return ERR_ARG;
 80132c6:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 80132ca:	e027      	b.n	801331c <pbuf_take+0x9c>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 80132cc:	68fb      	ldr	r3, [r7, #12]
 80132ce:	61fb      	str	r3, [r7, #28]
 80132d0:	e01f      	b.n	8013312 <pbuf_take+0x92>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    buf_copy_len = total_copy_len;
 80132d2:	8b3b      	ldrh	r3, [r7, #24]
 80132d4:	837b      	strh	r3, [r7, #26]
    if (buf_copy_len > p->len) {
 80132d6:	69fb      	ldr	r3, [r7, #28]
 80132d8:	895b      	ldrh	r3, [r3, #10]
 80132da:	8b7a      	ldrh	r2, [r7, #26]
 80132dc:	429a      	cmp	r2, r3
 80132de:	d902      	bls.n	80132e6 <pbuf_take+0x66>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 80132e0:	69fb      	ldr	r3, [r7, #28]
 80132e2:	895b      	ldrh	r3, [r3, #10]
 80132e4:	837b      	strh	r3, [r7, #26]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 80132e6:	69fb      	ldr	r3, [r7, #28]
 80132e8:	6859      	ldr	r1, [r3, #4]
 80132ea:	8afb      	ldrh	r3, [r7, #22]
 80132ec:	68ba      	ldr	r2, [r7, #8]
 80132ee:	18d2      	adds	r2, r2, r3
 80132f0:	8b7b      	ldrh	r3, [r7, #26]
 80132f2:	4608      	mov	r0, r1
 80132f4:	4611      	mov	r1, r2
 80132f6:	461a      	mov	r2, r3
 80132f8:	f010 f98c 	bl	8023614 <memcpy>
    total_copy_len -= buf_copy_len;
 80132fc:	8b3a      	ldrh	r2, [r7, #24]
 80132fe:	8b7b      	ldrh	r3, [r7, #26]
 8013300:	1ad3      	subs	r3, r2, r3
 8013302:	833b      	strh	r3, [r7, #24]
    copied_total += buf_copy_len;
 8013304:	8afa      	ldrh	r2, [r7, #22]
 8013306:	8b7b      	ldrh	r3, [r7, #26]
 8013308:	18d3      	adds	r3, r2, r3
 801330a:	82fb      	strh	r3, [r7, #22]
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 801330c:	69fb      	ldr	r3, [r7, #28]
 801330e:	681b      	ldr	r3, [r3, #0]
 8013310:	61fb      	str	r3, [r7, #28]
 8013312:	8b3b      	ldrh	r3, [r7, #24]
 8013314:	2b00      	cmp	r3, #0
 8013316:	d1dc      	bne.n	80132d2 <pbuf_take+0x52>
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
 8013318:	f04f 0300 	mov.w	r3, #0
 801331c:	b25b      	sxtb	r3, r3
}
 801331e:	4618      	mov	r0, r3
 8013320:	f107 0720 	add.w	r7, r7, #32
 8013324:	46bd      	mov	sp, r7
 8013326:	bd80      	pop	{r7, pc}

08013328 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 8013328:	b580      	push	{r7, lr}
 801332a:	b084      	sub	sp, #16
 801332c:	af00      	add	r7, sp, #0
 801332e:	6078      	str	r0, [r7, #4]
 8013330:	460b      	mov	r3, r1
 8013332:	70fb      	strb	r3, [r7, #3]
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
 8013334:	687b      	ldr	r3, [r7, #4]
 8013336:	681b      	ldr	r3, [r3, #0]
 8013338:	2b00      	cmp	r3, #0
 801333a:	d101      	bne.n	8013340 <pbuf_coalesce+0x18>
    return p;
 801333c:	687b      	ldr	r3, [r7, #4]
 801333e:	e018      	b.n	8013372 <pbuf_coalesce+0x4a>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
 8013340:	687b      	ldr	r3, [r7, #4]
 8013342:	891b      	ldrh	r3, [r3, #8]
 8013344:	78fa      	ldrb	r2, [r7, #3]
 8013346:	4610      	mov	r0, r2
 8013348:	4619      	mov	r1, r3
 801334a:	f04f 0200 	mov.w	r2, #0
 801334e:	f7ff fbaf 	bl	8012ab0 <pbuf_alloc>
 8013352:	60f8      	str	r0, [r7, #12]
  if (q == NULL) {
 8013354:	68fb      	ldr	r3, [r7, #12]
 8013356:	2b00      	cmp	r3, #0
 8013358:	d101      	bne.n	801335e <pbuf_coalesce+0x36>
    /* @todo: what do we do now? */
    return p;
 801335a:	687b      	ldr	r3, [r7, #4]
 801335c:	e009      	b.n	8013372 <pbuf_coalesce+0x4a>
  }
  err = pbuf_copy(q, p);
 801335e:	68f8      	ldr	r0, [r7, #12]
 8013360:	6879      	ldr	r1, [r7, #4]
 8013362:	f7ff fe9b 	bl	801309c <pbuf_copy>
 8013366:	4603      	mov	r3, r0
 8013368:	72fb      	strb	r3, [r7, #11]
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  pbuf_free(p);
 801336a:	6878      	ldr	r0, [r7, #4]
 801336c:	f7ff fda8 	bl	8012ec0 <pbuf_free>
  return q;
 8013370:	68fb      	ldr	r3, [r7, #12]
}
 8013372:	4618      	mov	r0, r3
 8013374:	f107 0710 	add.w	r7, r7, #16
 8013378:	46bd      	mov	sp, r7
 801337a:	bd80      	pop	{r7, pc}

0801337c <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 801337c:	b590      	push	{r4, r7, lr}
 801337e:	b089      	sub	sp, #36	; 0x24
 8013380:	af00      	add	r7, sp, #0
 8013382:	6078      	str	r0, [r7, #4]
 8013384:	6039      	str	r1, [r7, #0]
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
 8013386:	f04f 0300 	mov.w	r3, #0
 801338a:	75fb      	strb	r3, [r7, #23]

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
 801338c:	687b      	ldr	r3, [r7, #4]
 801338e:	685b      	ldr	r3, [r3, #4]
 8013390:	613b      	str	r3, [r7, #16]
  proto = IPH_PROTO(iphdr);
 8013392:	693b      	ldr	r3, [r7, #16]
 8013394:	891b      	ldrh	r3, [r3, #8]
 8013396:	b29b      	uxth	r3, r3
 8013398:	4618      	mov	r0, r3
 801339a:	f005 fef5 	bl	8019188 <ntohs>
 801339e:	4603      	mov	r3, r0
 80133a0:	b29b      	uxth	r3, r3
 80133a2:	b2db      	uxtb	r3, r3
 80133a4:	81fb      	strh	r3, [r7, #14]

  prev = NULL;
 80133a6:	f04f 0300 	mov.w	r3, #0
 80133aa:	61bb      	str	r3, [r7, #24]
  pcb = raw_pcbs;
 80133ac:	f245 5354 	movw	r3, #21844	; 0x5554
 80133b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80133b4:	681b      	ldr	r3, [r3, #0]
 80133b6:	61fb      	str	r3, [r7, #28]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 80133b8:	e037      	b.n	801342a <raw_input+0xae>
    if (pcb->protocol == proto) {
 80133ba:	69fb      	ldr	r3, [r7, #28]
 80133bc:	7c1b      	ldrb	r3, [r3, #16]
 80133be:	461a      	mov	r2, r3
 80133c0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80133c4:	429a      	cmp	r2, r3
 80133c6:	d12b      	bne.n	8013420 <raw_input+0xa4>
      /* broadcast filter? */
      if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&(iphdr->dest), inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
 80133c8:	69fb      	ldr	r3, [r7, #28]
 80133ca:	695b      	ldr	r3, [r3, #20]
 80133cc:	2b00      	cmp	r3, #0
 80133ce:	d027      	beq.n	8013420 <raw_input+0xa4>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
 80133d0:	69fb      	ldr	r3, [r7, #28]
 80133d2:	695c      	ldr	r4, [r3, #20]
 80133d4:	69fb      	ldr	r3, [r7, #28]
 80133d6:	699a      	ldr	r2, [r3, #24]
 80133d8:	693b      	ldr	r3, [r7, #16]
 80133da:	f103 030c 	add.w	r3, r3, #12
 80133de:	4610      	mov	r0, r2
 80133e0:	69f9      	ldr	r1, [r7, #28]
 80133e2:	687a      	ldr	r2, [r7, #4]
 80133e4:	47a0      	blx	r4
 80133e6:	4603      	mov	r3, r0
 80133e8:	2b00      	cmp	r3, #0
 80133ea:	d019      	beq.n	8013420 <raw_input+0xa4>
            /* receive function ate the packet */
            p = NULL;
 80133ec:	f04f 0300 	mov.w	r3, #0
 80133f0:	607b      	str	r3, [r7, #4]
            eaten = 1;
 80133f2:	f04f 0301 	mov.w	r3, #1
 80133f6:	75fb      	strb	r3, [r7, #23]
            if (prev != NULL) {
 80133f8:	69bb      	ldr	r3, [r7, #24]
 80133fa:	2b00      	cmp	r3, #0
 80133fc:	d010      	beq.n	8013420 <raw_input+0xa4>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 80133fe:	69fb      	ldr	r3, [r7, #28]
 8013400:	68da      	ldr	r2, [r3, #12]
 8013402:	69bb      	ldr	r3, [r7, #24]
 8013404:	60da      	str	r2, [r3, #12]
              pcb->next = raw_pcbs;
 8013406:	f245 5354 	movw	r3, #21844	; 0x5554
 801340a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801340e:	681a      	ldr	r2, [r3, #0]
 8013410:	69fb      	ldr	r3, [r7, #28]
 8013412:	60da      	str	r2, [r3, #12]
              raw_pcbs = pcb;
 8013414:	f245 5354 	movw	r3, #21844	; 0x5554
 8013418:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801341c:	69fa      	ldr	r2, [r7, #28]
 801341e:	601a      	str	r2, [r3, #0]
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
 8013420:	69fb      	ldr	r3, [r7, #28]
 8013422:	61bb      	str	r3, [r7, #24]
    pcb = pcb->next;
 8013424:	69fb      	ldr	r3, [r7, #28]
 8013426:	68db      	ldr	r3, [r3, #12]
 8013428:	61fb      	str	r3, [r7, #28]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 801342a:	7dfb      	ldrb	r3, [r7, #23]
 801342c:	2b00      	cmp	r3, #0
 801342e:	d102      	bne.n	8013436 <raw_input+0xba>
 8013430:	69fb      	ldr	r3, [r7, #28]
 8013432:	2b00      	cmp	r3, #0
 8013434:	d1c1      	bne.n	80133ba <raw_input+0x3e>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
 8013436:	7dfb      	ldrb	r3, [r7, #23]
}
 8013438:	4618      	mov	r0, r3
 801343a:	f107 0724 	add.w	r7, r7, #36	; 0x24
 801343e:	46bd      	mov	sp, r7
 8013440:	bd90      	pop	{r4, r7, pc}
 8013442:	bf00      	nop

08013444 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
 8013444:	b480      	push	{r7}
 8013446:	b083      	sub	sp, #12
 8013448:	af00      	add	r7, sp, #0
 801344a:	6078      	str	r0, [r7, #4]
 801344c:	6039      	str	r1, [r7, #0]
  ip_addr_set(&pcb->local_ip, ipaddr);
 801344e:	683b      	ldr	r3, [r7, #0]
 8013450:	2b00      	cmp	r3, #0
 8013452:	d002      	beq.n	801345a <raw_bind+0x16>
 8013454:	683b      	ldr	r3, [r7, #0]
 8013456:	681b      	ldr	r3, [r3, #0]
 8013458:	e001      	b.n	801345e <raw_bind+0x1a>
 801345a:	f04f 0300 	mov.w	r3, #0
 801345e:	687a      	ldr	r2, [r7, #4]
 8013460:	6013      	str	r3, [r2, #0]
  return ERR_OK;
 8013462:	f04f 0300 	mov.w	r3, #0
 8013466:	b25b      	sxtb	r3, r3
}
 8013468:	4618      	mov	r0, r3
 801346a:	f107 070c 	add.w	r7, r7, #12
 801346e:	46bd      	mov	sp, r7
 8013470:	bc80      	pop	{r7}
 8013472:	4770      	bx	lr

08013474 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
 8013474:	b480      	push	{r7}
 8013476:	b083      	sub	sp, #12
 8013478:	af00      	add	r7, sp, #0
 801347a:	6078      	str	r0, [r7, #4]
 801347c:	6039      	str	r1, [r7, #0]
  ip_addr_set(&pcb->remote_ip, ipaddr);
 801347e:	683b      	ldr	r3, [r7, #0]
 8013480:	2b00      	cmp	r3, #0
 8013482:	d002      	beq.n	801348a <raw_connect+0x16>
 8013484:	683b      	ldr	r3, [r7, #0]
 8013486:	681b      	ldr	r3, [r3, #0]
 8013488:	e001      	b.n	801348e <raw_connect+0x1a>
 801348a:	f04f 0300 	mov.w	r3, #0
 801348e:	687a      	ldr	r2, [r7, #4]
 8013490:	6053      	str	r3, [r2, #4]
  return ERR_OK;
 8013492:	f04f 0300 	mov.w	r3, #0
 8013496:	b25b      	sxtb	r3, r3
}
 8013498:	4618      	mov	r0, r3
 801349a:	f107 070c 	add.w	r7, r7, #12
 801349e:	46bd      	mov	sp, r7
 80134a0:	bc80      	pop	{r7}
 80134a2:	4770      	bx	lr

080134a4 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
 80134a4:	b480      	push	{r7}
 80134a6:	b085      	sub	sp, #20
 80134a8:	af00      	add	r7, sp, #0
 80134aa:	60f8      	str	r0, [r7, #12]
 80134ac:	60b9      	str	r1, [r7, #8]
 80134ae:	607a      	str	r2, [r7, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
 80134b0:	68fb      	ldr	r3, [r7, #12]
 80134b2:	68ba      	ldr	r2, [r7, #8]
 80134b4:	615a      	str	r2, [r3, #20]
  pcb->recv_arg = recv_arg;
 80134b6:	68fb      	ldr	r3, [r7, #12]
 80134b8:	687a      	ldr	r2, [r7, #4]
 80134ba:	619a      	str	r2, [r3, #24]
}
 80134bc:	f107 0714 	add.w	r7, r7, #20
 80134c0:	46bd      	mov	sp, r7
 80134c2:	bc80      	pop	{r7}
 80134c4:	4770      	bx	lr
 80134c6:	bf00      	nop

080134c8 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
 80134c8:	b580      	push	{r7, lr}
 80134ca:	b08c      	sub	sp, #48	; 0x30
 80134cc:	af04      	add	r7, sp, #16
 80134ce:	60f8      	str	r0, [r7, #12]
 80134d0:	60b9      	str	r1, [r7, #8]
 80134d2:	607a      	str	r2, [r7, #4]
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
 80134d4:	68b8      	ldr	r0, [r7, #8]
 80134d6:	f04f 0114 	mov.w	r1, #20
 80134da:	f7ff fc77 	bl	8012dcc <pbuf_header>
 80134de:	4603      	mov	r3, r0
 80134e0:	2b00      	cmp	r3, #0
 80134e2:	d013      	beq.n	801350c <raw_sendto+0x44>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 80134e4:	f04f 0001 	mov.w	r0, #1
 80134e8:	f04f 0100 	mov.w	r1, #0
 80134ec:	f04f 0200 	mov.w	r2, #0
 80134f0:	f7ff fade 	bl	8012ab0 <pbuf_alloc>
 80134f4:	61b8      	str	r0, [r7, #24]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 80134f6:	69bb      	ldr	r3, [r7, #24]
 80134f8:	2b00      	cmp	r3, #0
 80134fa:	d102      	bne.n	8013502 <raw_sendto+0x3a>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
 80134fc:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8013500:	e049      	b.n	8013596 <raw_sendto+0xce>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
 8013502:	69b8      	ldr	r0, [r7, #24]
 8013504:	68b9      	ldr	r1, [r7, #8]
 8013506:	f7ff fd8b 	bl	8013020 <pbuf_chain>
 801350a:	e00c      	b.n	8013526 <raw_sendto+0x5e>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
 801350c:	68bb      	ldr	r3, [r7, #8]
 801350e:	61bb      	str	r3, [r7, #24]
    if(pbuf_header(q, -IP_HLEN)) {
 8013510:	69b8      	ldr	r0, [r7, #24]
 8013512:	f06f 0113 	mvn.w	r1, #19
 8013516:	f7ff fc59 	bl	8012dcc <pbuf_header>
 801351a:	4603      	mov	r3, r0
 801351c:	2b00      	cmp	r3, #0
 801351e:	d002      	beq.n	8013526 <raw_sendto+0x5e>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
 8013520:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8013524:	e037      	b.n	8013596 <raw_sendto+0xce>
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
 8013526:	6878      	ldr	r0, [r7, #4]
 8013528:	f005 ffde 	bl	80194e8 <ip_route>
 801352c:	6178      	str	r0, [r7, #20]
 801352e:	697b      	ldr	r3, [r7, #20]
 8013530:	2b00      	cmp	r3, #0
 8013532:	d109      	bne.n	8013548 <raw_sendto+0x80>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
 8013534:	69ba      	ldr	r2, [r7, #24]
 8013536:	68bb      	ldr	r3, [r7, #8]
 8013538:	429a      	cmp	r2, r3
 801353a:	d002      	beq.n	8013542 <raw_sendto+0x7a>
      pbuf_free(q);
 801353c:	69b8      	ldr	r0, [r7, #24]
 801353e:	f7ff fcbf 	bl	8012ec0 <pbuf_free>
    }
    return ERR_RTE;
 8013542:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 8013546:	e026      	b.n	8013596 <raw_sendto+0xce>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
 8013548:	68fb      	ldr	r3, [r7, #12]
 801354a:	2b00      	cmp	r3, #0
 801354c:	d003      	beq.n	8013556 <raw_sendto+0x8e>
 801354e:	68fb      	ldr	r3, [r7, #12]
 8013550:	681b      	ldr	r3, [r3, #0]
 8013552:	2b00      	cmp	r3, #0
 8013554:	d104      	bne.n	8013560 <raw_sendto+0x98>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 8013556:	697b      	ldr	r3, [r7, #20]
 8013558:	f103 0304 	add.w	r3, r3, #4
 801355c:	61fb      	str	r3, [r7, #28]
 801355e:	e001      	b.n	8013564 <raw_sendto+0x9c>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 8013560:	68fb      	ldr	r3, [r7, #12]
 8013562:	61fb      	str	r3, [r7, #28]
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 8013564:	68fb      	ldr	r3, [r7, #12]
 8013566:	7adb      	ldrb	r3, [r3, #11]
 8013568:	68fa      	ldr	r2, [r7, #12]
 801356a:	7a91      	ldrb	r1, [r2, #10]
 801356c:	68fa      	ldr	r2, [r7, #12]
 801356e:	7c12      	ldrb	r2, [r2, #16]
 8013570:	9100      	str	r1, [sp, #0]
 8013572:	9201      	str	r2, [sp, #4]
 8013574:	697a      	ldr	r2, [r7, #20]
 8013576:	9202      	str	r2, [sp, #8]
 8013578:	69b8      	ldr	r0, [r7, #24]
 801357a:	69f9      	ldr	r1, [r7, #28]
 801357c:	687a      	ldr	r2, [r7, #4]
 801357e:	f006 f979 	bl	8019874 <ip_output_if>
 8013582:	4603      	mov	r3, r0
 8013584:	74fb      	strb	r3, [r7, #19]
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
 8013586:	69ba      	ldr	r2, [r7, #24]
 8013588:	68bb      	ldr	r3, [r7, #8]
 801358a:	429a      	cmp	r2, r3
 801358c:	d002      	beq.n	8013594 <raw_sendto+0xcc>
    /* free the header */
    pbuf_free(q);
 801358e:	69b8      	ldr	r0, [r7, #24]
 8013590:	f7ff fc96 	bl	8012ec0 <pbuf_free>
  }
  return err;
 8013594:	7cfb      	ldrb	r3, [r7, #19]
 8013596:	b25b      	sxtb	r3, r3
}
 8013598:	4618      	mov	r0, r3
 801359a:	f107 0720 	add.w	r7, r7, #32
 801359e:	46bd      	mov	sp, r7
 80135a0:	bd80      	pop	{r7, pc}
 80135a2:	bf00      	nop

080135a4 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
 80135a4:	b580      	push	{r7, lr}
 80135a6:	b082      	sub	sp, #8
 80135a8:	af00      	add	r7, sp, #0
 80135aa:	6078      	str	r0, [r7, #4]
 80135ac:	6039      	str	r1, [r7, #0]
  return raw_sendto(pcb, p, &pcb->remote_ip);
 80135ae:	687b      	ldr	r3, [r7, #4]
 80135b0:	f103 0304 	add.w	r3, r3, #4
 80135b4:	6878      	ldr	r0, [r7, #4]
 80135b6:	6839      	ldr	r1, [r7, #0]
 80135b8:	461a      	mov	r2, r3
 80135ba:	f7ff ff85 	bl	80134c8 <raw_sendto>
 80135be:	4603      	mov	r3, r0
}
 80135c0:	4618      	mov	r0, r3
 80135c2:	f107 0708 	add.w	r7, r7, #8
 80135c6:	46bd      	mov	sp, r7
 80135c8:	bd80      	pop	{r7, pc}
 80135ca:	bf00      	nop

080135cc <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 80135cc:	b580      	push	{r7, lr}
 80135ce:	b084      	sub	sp, #16
 80135d0:	af00      	add	r7, sp, #0
 80135d2:	6078      	str	r0, [r7, #4]
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 80135d4:	f245 5354 	movw	r3, #21844	; 0x5554
 80135d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80135dc:	681a      	ldr	r2, [r3, #0]
 80135de:	687b      	ldr	r3, [r7, #4]
 80135e0:	429a      	cmp	r2, r3
 80135e2:	d10b      	bne.n	80135fc <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 80135e4:	f245 5354 	movw	r3, #21844	; 0x5554
 80135e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80135ec:	681b      	ldr	r3, [r3, #0]
 80135ee:	68da      	ldr	r2, [r3, #12]
 80135f0:	f245 5354 	movw	r3, #21844	; 0x5554
 80135f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80135f8:	601a      	str	r2, [r3, #0]
 80135fa:	e019      	b.n	8013630 <raw_remove+0x64>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 80135fc:	f245 5354 	movw	r3, #21844	; 0x5554
 8013600:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013604:	681b      	ldr	r3, [r3, #0]
 8013606:	60fb      	str	r3, [r7, #12]
 8013608:	e00f      	b.n	801362a <raw_remove+0x5e>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 801360a:	68fb      	ldr	r3, [r7, #12]
 801360c:	68db      	ldr	r3, [r3, #12]
 801360e:	2b00      	cmp	r3, #0
 8013610:	d008      	beq.n	8013624 <raw_remove+0x58>
 8013612:	68fb      	ldr	r3, [r7, #12]
 8013614:	68da      	ldr	r2, [r3, #12]
 8013616:	687b      	ldr	r3, [r7, #4]
 8013618:	429a      	cmp	r2, r3
 801361a:	d103      	bne.n	8013624 <raw_remove+0x58>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 801361c:	687b      	ldr	r3, [r7, #4]
 801361e:	68da      	ldr	r2, [r3, #12]
 8013620:	68fb      	ldr	r3, [r7, #12]
 8013622:	60da      	str	r2, [r3, #12]
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8013624:	68fb      	ldr	r3, [r7, #12]
 8013626:	68db      	ldr	r3, [r3, #12]
 8013628:	60fb      	str	r3, [r7, #12]
 801362a:	68fb      	ldr	r3, [r7, #12]
 801362c:	2b00      	cmp	r3, #0
 801362e:	d1ec      	bne.n	801360a <raw_remove+0x3e>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 8013630:	6878      	ldr	r0, [r7, #4]
 8013632:	f7fe fc41 	bl	8011eb8 <mem_free>
}
 8013636:	f107 0710 	add.w	r7, r7, #16
 801363a:	46bd      	mov	sp, r7
 801363c:	bd80      	pop	{r7, pc}
 801363e:	bf00      	nop

08013640 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
 8013640:	b580      	push	{r7, lr}
 8013642:	b084      	sub	sp, #16
 8013644:	af00      	add	r7, sp, #0
 8013646:	4603      	mov	r3, r0
 8013648:	71fb      	strb	r3, [r7, #7]
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
 801364a:	f246 73d4 	movw	r3, #26580	; 0x67d4
 801364e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013652:	881b      	ldrh	r3, [r3, #0]
 8013654:	4618      	mov	r0, r3
 8013656:	f7fe fd5b 	bl	8012110 <mem_malloc>
 801365a:	60f8      	str	r0, [r7, #12]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
 801365c:	68fb      	ldr	r3, [r7, #12]
 801365e:	2b00      	cmp	r3, #0
 8013660:	d01a      	beq.n	8013698 <raw_new+0x58>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
 8013662:	68f8      	ldr	r0, [r7, #12]
 8013664:	f04f 0100 	mov.w	r1, #0
 8013668:	f04f 021c 	mov.w	r2, #28
 801366c:	f010 f940 	bl	80238f0 <memset>
    pcb->protocol = proto;
 8013670:	68fb      	ldr	r3, [r7, #12]
 8013672:	79fa      	ldrb	r2, [r7, #7]
 8013674:	741a      	strb	r2, [r3, #16]
    pcb->ttl = RAW_TTL;
 8013676:	68fb      	ldr	r3, [r7, #12]
 8013678:	f04f 02ff 	mov.w	r2, #255	; 0xff
 801367c:	72da      	strb	r2, [r3, #11]
    pcb->next = raw_pcbs;
 801367e:	f245 5354 	movw	r3, #21844	; 0x5554
 8013682:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013686:	681a      	ldr	r2, [r3, #0]
 8013688:	68fb      	ldr	r3, [r7, #12]
 801368a:	60da      	str	r2, [r3, #12]
    raw_pcbs = pcb;
 801368c:	f245 5354 	movw	r3, #21844	; 0x5554
 8013690:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013694:	68fa      	ldr	r2, [r7, #12]
 8013696:	601a      	str	r2, [r3, #0]
  }
  return pcb;
 8013698:	68fb      	ldr	r3, [r7, #12]
}
 801369a:	4618      	mov	r0, r3
 801369c:	f107 0710 	add.w	r7, r7, #16
 80136a0:	46bd      	mov	sp, r7
 80136a2:	bd80      	pop	{r7, pc}

080136a4 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
 80136a4:	b580      	push	{r7, lr}
 80136a6:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 80136a8:	f000 fee8 	bl	801447c <tcp_fasttmr>

  if (++tcp_timer & 1) {
 80136ac:	f245 5358 	movw	r3, #21848	; 0x5558
 80136b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80136b4:	781b      	ldrb	r3, [r3, #0]
 80136b6:	f103 0301 	add.w	r3, r3, #1
 80136ba:	b2da      	uxtb	r2, r3
 80136bc:	f245 5358 	movw	r3, #21848	; 0x5558
 80136c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80136c4:	701a      	strb	r2, [r3, #0]
 80136c6:	f245 5358 	movw	r3, #21848	; 0x5558
 80136ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80136ce:	781b      	ldrb	r3, [r3, #0]
 80136d0:	f003 0301 	and.w	r3, r3, #1
 80136d4:	2b00      	cmp	r3, #0
 80136d6:	d001      	beq.n	80136dc <tcp_tmr+0x38>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 80136d8:	f000 fcae 	bl	8014038 <tcp_slowtmr>
  }
}
 80136dc:	bd80      	pop	{r7, pc}
 80136de:	bf00      	nop

080136e0 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 80136e0:	b580      	push	{r7, lr}
 80136e2:	b084      	sub	sp, #16
 80136e4:	af00      	add	r7, sp, #0
 80136e6:	6078      	str	r0, [r7, #4]
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
 80136e8:	687b      	ldr	r3, [r7, #4]
 80136ea:	7c1b      	ldrb	r3, [r3, #16]
 80136ec:	2b07      	cmp	r3, #7
 80136ee:	f200 80b6 	bhi.w	801385e <tcp_close+0x17e>
 80136f2:	a201      	add	r2, pc, #4	; (adr r2, 80136f8 <tcp_close+0x18>)
 80136f4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80136f8:	08013719 	.word	0x08013719
 80136fc:	080137bb 	.word	0x080137bb
 8013700:	080137dd 	.word	0x080137dd
 8013704:	080137ff 	.word	0x080137ff
 8013708:	0801381f 	.word	0x0801381f
 801370c:	0801385f 	.word	0x0801385f
 8013710:	0801385f 	.word	0x0801385f
 8013714:	0801383f 	.word	0x0801383f
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
 8013718:	f04f 0300 	mov.w	r3, #0
 801371c:	73fb      	strb	r3, [r7, #15]
    TCP_RMV(&tcp_bound_pcbs, pcb);
 801371e:	f246 5364 	movw	r3, #25956	; 0x6564
 8013722:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013726:	681a      	ldr	r2, [r3, #0]
 8013728:	687b      	ldr	r3, [r7, #4]
 801372a:	429a      	cmp	r2, r3
 801372c:	d10b      	bne.n	8013746 <tcp_close+0x66>
 801372e:	f246 5364 	movw	r3, #25956	; 0x6564
 8013732:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013736:	681b      	ldr	r3, [r3, #0]
 8013738:	68da      	ldr	r2, [r3, #12]
 801373a:	f246 5364 	movw	r3, #25956	; 0x6564
 801373e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013742:	601a      	str	r2, [r3, #0]
 8013744:	e02e      	b.n	80137a4 <tcp_close+0xc4>
 8013746:	f246 5364 	movw	r3, #25956	; 0x6564
 801374a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801374e:	681a      	ldr	r2, [r3, #0]
 8013750:	f246 5360 	movw	r3, #25952	; 0x6560
 8013754:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013758:	601a      	str	r2, [r3, #0]
 801375a:	e01c      	b.n	8013796 <tcp_close+0xb6>
 801375c:	f246 5360 	movw	r3, #25952	; 0x6560
 8013760:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013764:	681b      	ldr	r3, [r3, #0]
 8013766:	68da      	ldr	r2, [r3, #12]
 8013768:	687b      	ldr	r3, [r7, #4]
 801376a:	429a      	cmp	r2, r3
 801376c:	d108      	bne.n	8013780 <tcp_close+0xa0>
 801376e:	f246 5360 	movw	r3, #25952	; 0x6560
 8013772:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013776:	681b      	ldr	r3, [r3, #0]
 8013778:	687a      	ldr	r2, [r7, #4]
 801377a:	68d2      	ldr	r2, [r2, #12]
 801377c:	60da      	str	r2, [r3, #12]
 801377e:	e011      	b.n	80137a4 <tcp_close+0xc4>
 8013780:	f246 5360 	movw	r3, #25952	; 0x6560
 8013784:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013788:	681b      	ldr	r3, [r3, #0]
 801378a:	68da      	ldr	r2, [r3, #12]
 801378c:	f246 5360 	movw	r3, #25952	; 0x6560
 8013790:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013794:	601a      	str	r2, [r3, #0]
 8013796:	f246 5360 	movw	r3, #25952	; 0x6560
 801379a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801379e:	681b      	ldr	r3, [r3, #0]
 80137a0:	2b00      	cmp	r3, #0
 80137a2:	d1db      	bne.n	801375c <tcp_close+0x7c>
 80137a4:	687b      	ldr	r3, [r7, #4]
 80137a6:	f04f 0200 	mov.w	r2, #0
 80137aa:	60da      	str	r2, [r3, #12]
    memp_free(MEMP_TCP_PCB, pcb);
 80137ac:	6878      	ldr	r0, [r7, #4]
 80137ae:	f7fe fb83 	bl	8011eb8 <mem_free>
    pcb = NULL;
 80137b2:	f04f 0300 	mov.w	r3, #0
 80137b6:	607b      	str	r3, [r7, #4]
    break;
 80137b8:	e05d      	b.n	8013876 <tcp_close+0x196>
  case LISTEN:
    err = ERR_OK;
 80137ba:	f04f 0300 	mov.w	r3, #0
 80137be:	73fb      	strb	r3, [r7, #15]
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
 80137c0:	f246 505c 	movw	r0, #25948	; 0x655c
 80137c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80137c8:	6879      	ldr	r1, [r7, #4]
 80137ca:	f001 f8e3 	bl	8014994 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 80137ce:	6878      	ldr	r0, [r7, #4]
 80137d0:	f7fe fb72 	bl	8011eb8 <mem_free>
    pcb = NULL;
 80137d4:	f04f 0300 	mov.w	r3, #0
 80137d8:	607b      	str	r3, [r7, #4]
    break;
 80137da:	e04c      	b.n	8013876 <tcp_close+0x196>
  case SYN_SENT:
    err = ERR_OK;
 80137dc:	f04f 0300 	mov.w	r3, #0
 80137e0:	73fb      	strb	r3, [r7, #15]
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 80137e2:	f246 5054 	movw	r0, #25940	; 0x6554
 80137e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80137ea:	6879      	ldr	r1, [r7, #4]
 80137ec:	f001 f8d2 	bl	8014994 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 80137f0:	6878      	ldr	r0, [r7, #4]
 80137f2:	f7fe fb61 	bl	8011eb8 <mem_free>
    pcb = NULL;
 80137f6:	f04f 0300 	mov.w	r3, #0
 80137fa:	607b      	str	r3, [r7, #4]
    snmp_inc_tcpattemptfails();
    break;
 80137fc:	e03b      	b.n	8013876 <tcp_close+0x196>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
 80137fe:	6878      	ldr	r0, [r7, #4]
 8013800:	f04f 0101 	mov.w	r1, #1
 8013804:	f003 f990 	bl	8016b28 <tcp_send_ctrl>
 8013808:	4603      	mov	r3, r0
 801380a:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
 801380c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8013810:	2b00      	cmp	r3, #0
 8013812:	d12b      	bne.n	801386c <tcp_close+0x18c>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 8013814:	687b      	ldr	r3, [r7, #4]
 8013816:	f04f 0205 	mov.w	r2, #5
 801381a:	741a      	strb	r2, [r3, #16]
    }
    break;
 801381c:	e026      	b.n	801386c <tcp_close+0x18c>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
 801381e:	6878      	ldr	r0, [r7, #4]
 8013820:	f04f 0101 	mov.w	r1, #1
 8013824:	f003 f980 	bl	8016b28 <tcp_send_ctrl>
 8013828:	4603      	mov	r3, r0
 801382a:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
 801382c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8013830:	2b00      	cmp	r3, #0
 8013832:	d11d      	bne.n	8013870 <tcp_close+0x190>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
 8013834:	687b      	ldr	r3, [r7, #4]
 8013836:	f04f 0205 	mov.w	r2, #5
 801383a:	741a      	strb	r2, [r3, #16]
    }
    break;
 801383c:	e018      	b.n	8013870 <tcp_close+0x190>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
 801383e:	6878      	ldr	r0, [r7, #4]
 8013840:	f04f 0101 	mov.w	r1, #1
 8013844:	f003 f970 	bl	8016b28 <tcp_send_ctrl>
 8013848:	4603      	mov	r3, r0
 801384a:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
 801384c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8013850:	2b00      	cmp	r3, #0
 8013852:	d10f      	bne.n	8013874 <tcp_close+0x194>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 8013854:	687b      	ldr	r3, [r7, #4]
 8013856:	f04f 0209 	mov.w	r2, #9
 801385a:	741a      	strb	r2, [r3, #16]
    }
    break;
 801385c:	e00a      	b.n	8013874 <tcp_close+0x194>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
 801385e:	f04f 0300 	mov.w	r3, #0
 8013862:	73fb      	strb	r3, [r7, #15]
    pcb = NULL;
 8013864:	f04f 0300 	mov.w	r3, #0
 8013868:	607b      	str	r3, [r7, #4]
    break;
 801386a:	e004      	b.n	8013876 <tcp_close+0x196>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
 801386c:	bf00      	nop
 801386e:	e002      	b.n	8013876 <tcp_close+0x196>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
 8013870:	bf00      	nop
 8013872:	e000      	b.n	8013876 <tcp_close+0x196>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
 8013874:	bf00      	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
 8013876:	687b      	ldr	r3, [r7, #4]
 8013878:	2b00      	cmp	r3, #0
 801387a:	d006      	beq.n	801388a <tcp_close+0x1aa>
 801387c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8013880:	2b00      	cmp	r3, #0
 8013882:	d102      	bne.n	801388a <tcp_close+0x1aa>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
 8013884:	6878      	ldr	r0, [r7, #4]
 8013886:	f003 fcef 	bl	8017268 <tcp_output>
  }
  return err;
 801388a:	7bfb      	ldrb	r3, [r7, #15]
 801388c:	b25b      	sxtb	r3, r3
}
 801388e:	4618      	mov	r0, r3
 8013890:	f107 0710 	add.w	r7, r7, #16
 8013894:	46bd      	mov	sp, r7
 8013896:	bd80      	pop	{r7, pc}

08013898 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 8013898:	b580      	push	{r7, lr}
 801389a:	b08c      	sub	sp, #48	; 0x30
 801389c:	af02      	add	r7, sp, #8
 801389e:	6078      	str	r0, [r7, #4]
 80138a0:	6039      	str	r1, [r7, #0]

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 80138a2:	687b      	ldr	r3, [r7, #4]
 80138a4:	7c1b      	ldrb	r3, [r3, #16]
 80138a6:	2b0a      	cmp	r3, #10
 80138a8:	d10a      	bne.n	80138c0 <tcp_abandon+0x28>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 80138aa:	f246 5068 	movw	r0, #25960	; 0x6568
 80138ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80138b2:	6879      	ldr	r1, [r7, #4]
 80138b4:	f001 f86e 	bl	8014994 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 80138b8:	6878      	ldr	r0, [r7, #4]
 80138ba:	f7fe fafd 	bl	8011eb8 <mem_free>
 80138be:	e059      	b.n	8013974 <tcp_abandon+0xdc>
  } else {
    seqno = pcb->snd_nxt;
 80138c0:	687b      	ldr	r3, [r7, #4]
 80138c2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80138c4:	627b      	str	r3, [r7, #36]	; 0x24
    ackno = pcb->rcv_nxt;
 80138c6:	687b      	ldr	r3, [r7, #4]
 80138c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80138ca:	623b      	str	r3, [r7, #32]
    ip_addr_set(&local_ip, &(pcb->local_ip));
 80138cc:	687b      	ldr	r3, [r7, #4]
 80138ce:	2b00      	cmp	r3, #0
 80138d0:	d002      	beq.n	80138d8 <tcp_abandon+0x40>
 80138d2:	687b      	ldr	r3, [r7, #4]
 80138d4:	681b      	ldr	r3, [r3, #0]
 80138d6:	e001      	b.n	80138dc <tcp_abandon+0x44>
 80138d8:	f04f 0300 	mov.w	r3, #0
 80138dc:	60fb      	str	r3, [r7, #12]
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
 80138de:	687b      	ldr	r3, [r7, #4]
 80138e0:	f103 0304 	add.w	r3, r3, #4
 80138e4:	2b00      	cmp	r3, #0
 80138e6:	d002      	beq.n	80138ee <tcp_abandon+0x56>
 80138e8:	687b      	ldr	r3, [r7, #4]
 80138ea:	685b      	ldr	r3, [r3, #4]
 80138ec:	e001      	b.n	80138f2 <tcp_abandon+0x5a>
 80138ee:	f04f 0300 	mov.w	r3, #0
 80138f2:	613b      	str	r3, [r7, #16]
    local_port = pcb->local_port;
 80138f4:	687b      	ldr	r3, [r7, #4]
 80138f6:	8b1b      	ldrh	r3, [r3, #24]
 80138f8:	83fb      	strh	r3, [r7, #30]
    remote_port = pcb->remote_port;
 80138fa:	687b      	ldr	r3, [r7, #4]
 80138fc:	8c1b      	ldrh	r3, [r3, #32]
 80138fe:	83bb      	strh	r3, [r7, #28]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 8013900:	687b      	ldr	r3, [r7, #4]
 8013902:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8013906:	61bb      	str	r3, [r7, #24]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 8013908:	687b      	ldr	r3, [r7, #4]
 801390a:	695b      	ldr	r3, [r3, #20]
 801390c:	617b      	str	r3, [r7, #20]
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 801390e:	f246 5054 	movw	r0, #25940	; 0x6554
 8013912:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013916:	6879      	ldr	r1, [r7, #4]
 8013918:	f001 f83c 	bl	8014994 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
 801391c:	687b      	ldr	r3, [r7, #4]
 801391e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8013920:	2b00      	cmp	r3, #0
 8013922:	d004      	beq.n	801392e <tcp_abandon+0x96>
      tcp_segs_free(pcb->unacked);
 8013924:	687b      	ldr	r3, [r7, #4]
 8013926:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8013928:	4618      	mov	r0, r3
 801392a:	f000 fe05 	bl	8014538 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 801392e:	687b      	ldr	r3, [r7, #4]
 8013930:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8013932:	2b00      	cmp	r3, #0
 8013934:	d004      	beq.n	8013940 <tcp_abandon+0xa8>
      tcp_segs_free(pcb->unsent);
 8013936:	687b      	ldr	r3, [r7, #4]
 8013938:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801393a:	4618      	mov	r0, r3
 801393c:	f000 fdfc 	bl	8014538 <tcp_segs_free>
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
 8013940:	6878      	ldr	r0, [r7, #4]
 8013942:	f7fe fab9 	bl	8011eb8 <mem_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 8013946:	69bb      	ldr	r3, [r7, #24]
 8013948:	2b00      	cmp	r3, #0
 801394a:	d004      	beq.n	8013956 <tcp_abandon+0xbe>
 801394c:	69bb      	ldr	r3, [r7, #24]
 801394e:	6978      	ldr	r0, [r7, #20]
 8013950:	f06f 0104 	mvn.w	r1, #4
 8013954:	4798      	blx	r3
    if (reset) {
 8013956:	683b      	ldr	r3, [r7, #0]
 8013958:	2b00      	cmp	r3, #0
 801395a:	d00b      	beq.n	8013974 <tcp_abandon+0xdc>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
 801395c:	f107 020c 	add.w	r2, r7, #12
 8013960:	f107 0310 	add.w	r3, r7, #16
 8013964:	8bf9      	ldrh	r1, [r7, #30]
 8013966:	9100      	str	r1, [sp, #0]
 8013968:	8bb9      	ldrh	r1, [r7, #28]
 801396a:	9101      	str	r1, [sp, #4]
 801396c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801396e:	6a39      	ldr	r1, [r7, #32]
 8013970:	f003 fea0 	bl	80176b4 <tcp_rst>
    }
  }
}
 8013974:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8013978:	46bd      	mov	sp, r7
 801397a:	bd80      	pop	{r7, pc}

0801397c <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
 801397c:	b580      	push	{r7, lr}
 801397e:	b086      	sub	sp, #24
 8013980:	af00      	add	r7, sp, #0
 8013982:	60f8      	str	r0, [r7, #12]
 8013984:	60b9      	str	r1, [r7, #8]
 8013986:	4613      	mov	r3, r2
 8013988:	80fb      	strh	r3, [r7, #6]
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 801398a:	68fb      	ldr	r3, [r7, #12]
 801398c:	7c1b      	ldrb	r3, [r3, #16]
 801398e:	2b00      	cmp	r3, #0
 8013990:	d002      	beq.n	8013998 <tcp_bind+0x1c>
 8013992:	f04f 03f3 	mov.w	r3, #243	; 0xf3
 8013996:	e0b9      	b.n	8013b0c <tcp_bind+0x190>

  if (port == 0) {
 8013998:	88fb      	ldrh	r3, [r7, #6]
 801399a:	2b00      	cmp	r3, #0
 801399c:	d103      	bne.n	80139a6 <tcp_bind+0x2a>
    port = tcp_new_port();
 801399e:	f000 f9ef 	bl	8013d80 <tcp_new_port>
 80139a2:	4603      	mov	r3, r0
 80139a4:	80fb      	strh	r3, [r7, #6]
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
 80139a6:	f246 535c 	movw	r3, #25948	; 0x655c
 80139aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80139ae:	681b      	ldr	r3, [r3, #0]
 80139b0:	617b      	str	r3, [r7, #20]
 80139b2:	e01e      	b.n	80139f2 <tcp_bind+0x76>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
 80139b4:	697b      	ldr	r3, [r7, #20]
 80139b6:	8b1b      	ldrh	r3, [r3, #24]
 80139b8:	88fa      	ldrh	r2, [r7, #6]
 80139ba:	429a      	cmp	r2, r3
 80139bc:	d116      	bne.n	80139ec <tcp_bind+0x70>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
 80139be:	697b      	ldr	r3, [r7, #20]
 80139c0:	2b00      	cmp	r3, #0
 80139c2:	d010      	beq.n	80139e6 <tcp_bind+0x6a>
 80139c4:	697b      	ldr	r3, [r7, #20]
 80139c6:	681b      	ldr	r3, [r3, #0]
 80139c8:	2b00      	cmp	r3, #0
 80139ca:	d00c      	beq.n	80139e6 <tcp_bind+0x6a>
 80139cc:	68bb      	ldr	r3, [r7, #8]
 80139ce:	2b00      	cmp	r3, #0
 80139d0:	d009      	beq.n	80139e6 <tcp_bind+0x6a>
          ip_addr_isany(ipaddr) ||
 80139d2:	68bb      	ldr	r3, [r7, #8]
 80139d4:	681b      	ldr	r3, [r3, #0]
 80139d6:	2b00      	cmp	r3, #0
 80139d8:	d005      	beq.n	80139e6 <tcp_bind+0x6a>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 80139da:	697b      	ldr	r3, [r7, #20]
 80139dc:	681a      	ldr	r2, [r3, #0]
 80139de:	68bb      	ldr	r3, [r7, #8]
 80139e0:	681b      	ldr	r3, [r3, #0]
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
 80139e2:	429a      	cmp	r2, r3
 80139e4:	d102      	bne.n	80139ec <tcp_bind+0x70>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
 80139e6:	f04f 03f5 	mov.w	r3, #245	; 0xf5
 80139ea:	e08f      	b.n	8013b0c <tcp_bind+0x190>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
 80139ec:	697b      	ldr	r3, [r7, #20]
 80139ee:	68db      	ldr	r3, [r3, #12]
 80139f0:	617b      	str	r3, [r7, #20]
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
 80139f2:	697b      	ldr	r3, [r7, #20]
 80139f4:	2b00      	cmp	r3, #0
 80139f6:	d1dd      	bne.n	80139b4 <tcp_bind+0x38>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
 80139f8:	f246 5354 	movw	r3, #25940	; 0x6554
 80139fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013a00:	681b      	ldr	r3, [r3, #0]
 8013a02:	617b      	str	r3, [r7, #20]
 8013a04:	e01e      	b.n	8013a44 <tcp_bind+0xc8>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
 8013a06:	697b      	ldr	r3, [r7, #20]
 8013a08:	8b1b      	ldrh	r3, [r3, #24]
 8013a0a:	88fa      	ldrh	r2, [r7, #6]
 8013a0c:	429a      	cmp	r2, r3
 8013a0e:	d116      	bne.n	8013a3e <tcp_bind+0xc2>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
 8013a10:	697b      	ldr	r3, [r7, #20]
 8013a12:	2b00      	cmp	r3, #0
 8013a14:	d010      	beq.n	8013a38 <tcp_bind+0xbc>
 8013a16:	697b      	ldr	r3, [r7, #20]
 8013a18:	681b      	ldr	r3, [r3, #0]
 8013a1a:	2b00      	cmp	r3, #0
 8013a1c:	d00c      	beq.n	8013a38 <tcp_bind+0xbc>
 8013a1e:	68bb      	ldr	r3, [r7, #8]
 8013a20:	2b00      	cmp	r3, #0
 8013a22:	d009      	beq.n	8013a38 <tcp_bind+0xbc>
          ip_addr_isany(ipaddr) ||
 8013a24:	68bb      	ldr	r3, [r7, #8]
 8013a26:	681b      	ldr	r3, [r3, #0]
 8013a28:	2b00      	cmp	r3, #0
 8013a2a:	d005      	beq.n	8013a38 <tcp_bind+0xbc>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 8013a2c:	697b      	ldr	r3, [r7, #20]
 8013a2e:	681a      	ldr	r2, [r3, #0]
 8013a30:	68bb      	ldr	r3, [r7, #8]
 8013a32:	681b      	ldr	r3, [r3, #0]
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
 8013a34:	429a      	cmp	r2, r3
 8013a36:	d102      	bne.n	8013a3e <tcp_bind+0xc2>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
 8013a38:	f04f 03f5 	mov.w	r3, #245	; 0xf5
 8013a3c:	e066      	b.n	8013b0c <tcp_bind+0x190>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
 8013a3e:	697b      	ldr	r3, [r7, #20]
 8013a40:	68db      	ldr	r3, [r3, #12]
 8013a42:	617b      	str	r3, [r7, #20]
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
 8013a44:	697b      	ldr	r3, [r7, #20]
 8013a46:	2b00      	cmp	r3, #0
 8013a48:	d1dd      	bne.n	8013a06 <tcp_bind+0x8a>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8013a4a:	f246 5364 	movw	r3, #25956	; 0x6564
 8013a4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013a52:	681b      	ldr	r3, [r3, #0]
 8013a54:	617b      	str	r3, [r7, #20]
 8013a56:	e01e      	b.n	8013a96 <tcp_bind+0x11a>
    if (cpcb->local_port == port) {
 8013a58:	697b      	ldr	r3, [r7, #20]
 8013a5a:	8b1b      	ldrh	r3, [r3, #24]
 8013a5c:	88fa      	ldrh	r2, [r7, #6]
 8013a5e:	429a      	cmp	r2, r3
 8013a60:	d116      	bne.n	8013a90 <tcp_bind+0x114>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
 8013a62:	697b      	ldr	r3, [r7, #20]
 8013a64:	2b00      	cmp	r3, #0
 8013a66:	d010      	beq.n	8013a8a <tcp_bind+0x10e>
 8013a68:	697b      	ldr	r3, [r7, #20]
 8013a6a:	681b      	ldr	r3, [r3, #0]
 8013a6c:	2b00      	cmp	r3, #0
 8013a6e:	d00c      	beq.n	8013a8a <tcp_bind+0x10e>
 8013a70:	68bb      	ldr	r3, [r7, #8]
 8013a72:	2b00      	cmp	r3, #0
 8013a74:	d009      	beq.n	8013a8a <tcp_bind+0x10e>
          ip_addr_isany(ipaddr) ||
 8013a76:	68bb      	ldr	r3, [r7, #8]
 8013a78:	681b      	ldr	r3, [r3, #0]
 8013a7a:	2b00      	cmp	r3, #0
 8013a7c:	d005      	beq.n	8013a8a <tcp_bind+0x10e>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 8013a7e:	697b      	ldr	r3, [r7, #20]
 8013a80:	681a      	ldr	r2, [r3, #0]
 8013a82:	68bb      	ldr	r3, [r7, #8]
 8013a84:	681b      	ldr	r3, [r3, #0]
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
 8013a86:	429a      	cmp	r2, r3
 8013a88:	d102      	bne.n	8013a90 <tcp_bind+0x114>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
 8013a8a:	f04f 03f5 	mov.w	r3, #245	; 0xf5
 8013a8e:	e03d      	b.n	8013b0c <tcp_bind+0x190>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8013a90:	697b      	ldr	r3, [r7, #20]
 8013a92:	68db      	ldr	r3, [r3, #12]
 8013a94:	617b      	str	r3, [r7, #20]
 8013a96:	697b      	ldr	r3, [r7, #20]
 8013a98:	2b00      	cmp	r3, #0
 8013a9a:	d1dd      	bne.n	8013a58 <tcp_bind+0xdc>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8013a9c:	f246 5368 	movw	r3, #25960	; 0x6568
 8013aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013aa4:	681b      	ldr	r3, [r3, #0]
 8013aa6:	617b      	str	r3, [r7, #20]
 8013aa8:	e010      	b.n	8013acc <tcp_bind+0x150>
    if (cpcb->local_port == port) {
 8013aaa:	697b      	ldr	r3, [r7, #20]
 8013aac:	8b1b      	ldrh	r3, [r3, #24]
 8013aae:	88fa      	ldrh	r2, [r7, #6]
 8013ab0:	429a      	cmp	r2, r3
 8013ab2:	d108      	bne.n	8013ac6 <tcp_bind+0x14a>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 8013ab4:	697b      	ldr	r3, [r7, #20]
 8013ab6:	681a      	ldr	r2, [r3, #0]
 8013ab8:	68bb      	ldr	r3, [r7, #8]
 8013aba:	681b      	ldr	r3, [r3, #0]
 8013abc:	429a      	cmp	r2, r3
 8013abe:	d102      	bne.n	8013ac6 <tcp_bind+0x14a>
        return ERR_USE;
 8013ac0:	f04f 03f5 	mov.w	r3, #245	; 0xf5
 8013ac4:	e022      	b.n	8013b0c <tcp_bind+0x190>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 8013ac6:	697b      	ldr	r3, [r7, #20]
 8013ac8:	68db      	ldr	r3, [r3, #12]
 8013aca:	617b      	str	r3, [r7, #20]
 8013acc:	697b      	ldr	r3, [r7, #20]
 8013ace:	2b00      	cmp	r3, #0
 8013ad0:	d1eb      	bne.n	8013aaa <tcp_bind+0x12e>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
 8013ad2:	68bb      	ldr	r3, [r7, #8]
 8013ad4:	2b00      	cmp	r3, #0
 8013ad6:	d007      	beq.n	8013ae8 <tcp_bind+0x16c>
 8013ad8:	68bb      	ldr	r3, [r7, #8]
 8013ada:	681b      	ldr	r3, [r3, #0]
 8013adc:	2b00      	cmp	r3, #0
 8013ade:	d003      	beq.n	8013ae8 <tcp_bind+0x16c>
    pcb->local_ip = *ipaddr;
 8013ae0:	68fb      	ldr	r3, [r7, #12]
 8013ae2:	68ba      	ldr	r2, [r7, #8]
 8013ae4:	6810      	ldr	r0, [r2, #0]
 8013ae6:	6018      	str	r0, [r3, #0]
  }
  pcb->local_port = port;
 8013ae8:	68fb      	ldr	r3, [r7, #12]
 8013aea:	88fa      	ldrh	r2, [r7, #6]
 8013aec:	831a      	strh	r2, [r3, #24]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8013aee:	f246 5364 	movw	r3, #25956	; 0x6564
 8013af2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013af6:	681a      	ldr	r2, [r3, #0]
 8013af8:	68fb      	ldr	r3, [r7, #12]
 8013afa:	60da      	str	r2, [r3, #12]
 8013afc:	f246 5364 	movw	r3, #25956	; 0x6564
 8013b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013b04:	68fa      	ldr	r2, [r7, #12]
 8013b06:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 8013b08:	f04f 0300 	mov.w	r3, #0
 8013b0c:	b25b      	sxtb	r3, r3
}
 8013b0e:	4618      	mov	r0, r3
 8013b10:	f107 0718 	add.w	r7, r7, #24
 8013b14:	46bd      	mov	sp, r7
 8013b16:	bd80      	pop	{r7, pc}

08013b18 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
 8013b18:	b480      	push	{r7}
 8013b1a:	b085      	sub	sp, #20
 8013b1c:	af00      	add	r7, sp, #0
 8013b1e:	60f8      	str	r0, [r7, #12]
 8013b20:	60b9      	str	r1, [r7, #8]
 8013b22:	4613      	mov	r3, r2
 8013b24:	71fb      	strb	r3, [r7, #7]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
 8013b26:	f04f 03fb 	mov.w	r3, #251	; 0xfb
 8013b2a:	b25b      	sxtb	r3, r3
}
 8013b2c:	4618      	mov	r0, r3
 8013b2e:	f107 0714 	add.w	r7, r7, #20
 8013b32:	46bd      	mov	sp, r7
 8013b34:	bc80      	pop	{r7}
 8013b36:	4770      	bx	lr

08013b38 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 8013b38:	b580      	push	{r7, lr}
 8013b3a:	b084      	sub	sp, #16
 8013b3c:	af00      	add	r7, sp, #0
 8013b3e:	6078      	str	r0, [r7, #4]
 8013b40:	460b      	mov	r3, r1
 8013b42:	70fb      	strb	r3, [r7, #3]
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8013b44:	687b      	ldr	r3, [r7, #4]
 8013b46:	7c1b      	ldrb	r3, [r3, #16]
 8013b48:	2b00      	cmp	r3, #0
 8013b4a:	d002      	beq.n	8013b52 <tcp_listen_with_backlog+0x1a>
 8013b4c:	f04f 0300 	mov.w	r3, #0
 8013b50:	e09b      	b.n	8013c8a <tcp_listen_with_backlog+0x152>

  /* already listening? */
  if (pcb->state == LISTEN) {
 8013b52:	687b      	ldr	r3, [r7, #4]
 8013b54:	7c1b      	ldrb	r3, [r3, #16]
 8013b56:	2b01      	cmp	r3, #1
 8013b58:	d101      	bne.n	8013b5e <tcp_listen_with_backlog+0x26>
    return pcb;
 8013b5a:	687b      	ldr	r3, [r7, #4]
 8013b5c:	e095      	b.n	8013c8a <tcp_listen_with_backlog+0x152>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
 8013b5e:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8013b62:	f6c0 0302 	movt	r3, #2050	; 0x802
 8013b66:	88db      	ldrh	r3, [r3, #6]
 8013b68:	4618      	mov	r0, r3
 8013b6a:	f7fe fad1 	bl	8012110 <mem_malloc>
 8013b6e:	60f8      	str	r0, [r7, #12]
  if (lpcb == NULL) {
 8013b70:	68fb      	ldr	r3, [r7, #12]
 8013b72:	2b00      	cmp	r3, #0
 8013b74:	d102      	bne.n	8013b7c <tcp_listen_with_backlog+0x44>
    return NULL;
 8013b76:	f04f 0300 	mov.w	r3, #0
 8013b7a:	e086      	b.n	8013c8a <tcp_listen_with_backlog+0x152>
  }
  lpcb->callback_arg = pcb->callback_arg;
 8013b7c:	687b      	ldr	r3, [r7, #4]
 8013b7e:	695a      	ldr	r2, [r3, #20]
 8013b80:	68fb      	ldr	r3, [r7, #12]
 8013b82:	615a      	str	r2, [r3, #20]
  lpcb->local_port = pcb->local_port;
 8013b84:	687b      	ldr	r3, [r7, #4]
 8013b86:	8b1a      	ldrh	r2, [r3, #24]
 8013b88:	68fb      	ldr	r3, [r7, #12]
 8013b8a:	831a      	strh	r2, [r3, #24]
  lpcb->state = LISTEN;
 8013b8c:	68fb      	ldr	r3, [r7, #12]
 8013b8e:	f04f 0201 	mov.w	r2, #1
 8013b92:	741a      	strb	r2, [r3, #16]
  lpcb->so_options = pcb->so_options;
 8013b94:	687b      	ldr	r3, [r7, #4]
 8013b96:	891a      	ldrh	r2, [r3, #8]
 8013b98:	68fb      	ldr	r3, [r7, #12]
 8013b9a:	811a      	strh	r2, [r3, #8]
  lpcb->so_options |= SOF_ACCEPTCONN;
 8013b9c:	68fb      	ldr	r3, [r7, #12]
 8013b9e:	891b      	ldrh	r3, [r3, #8]
 8013ba0:	f043 0302 	orr.w	r3, r3, #2
 8013ba4:	b29a      	uxth	r2, r3
 8013ba6:	68fb      	ldr	r3, [r7, #12]
 8013ba8:	811a      	strh	r2, [r3, #8]
  lpcb->ttl = pcb->ttl;
 8013baa:	687b      	ldr	r3, [r7, #4]
 8013bac:	7ada      	ldrb	r2, [r3, #11]
 8013bae:	68fb      	ldr	r3, [r7, #12]
 8013bb0:	72da      	strb	r2, [r3, #11]
  lpcb->tos = pcb->tos;
 8013bb2:	687b      	ldr	r3, [r7, #4]
 8013bb4:	7a9a      	ldrb	r2, [r3, #10]
 8013bb6:	68fb      	ldr	r3, [r7, #12]
 8013bb8:	729a      	strb	r2, [r3, #10]
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
 8013bba:	687b      	ldr	r3, [r7, #4]
 8013bbc:	2b00      	cmp	r3, #0
 8013bbe:	d002      	beq.n	8013bc6 <tcp_listen_with_backlog+0x8e>
 8013bc0:	687b      	ldr	r3, [r7, #4]
 8013bc2:	681b      	ldr	r3, [r3, #0]
 8013bc4:	e001      	b.n	8013bca <tcp_listen_with_backlog+0x92>
 8013bc6:	f04f 0300 	mov.w	r3, #0
 8013bca:	68fa      	ldr	r2, [r7, #12]
 8013bcc:	6013      	str	r3, [r2, #0]
  TCP_RMV(&tcp_bound_pcbs, pcb);
 8013bce:	f246 5364 	movw	r3, #25956	; 0x6564
 8013bd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013bd6:	681a      	ldr	r2, [r3, #0]
 8013bd8:	687b      	ldr	r3, [r7, #4]
 8013bda:	429a      	cmp	r2, r3
 8013bdc:	d10b      	bne.n	8013bf6 <tcp_listen_with_backlog+0xbe>
 8013bde:	f246 5364 	movw	r3, #25956	; 0x6564
 8013be2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013be6:	681b      	ldr	r3, [r3, #0]
 8013be8:	68da      	ldr	r2, [r3, #12]
 8013bea:	f246 5364 	movw	r3, #25956	; 0x6564
 8013bee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013bf2:	601a      	str	r2, [r3, #0]
 8013bf4:	e02e      	b.n	8013c54 <tcp_listen_with_backlog+0x11c>
 8013bf6:	f246 5364 	movw	r3, #25956	; 0x6564
 8013bfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013bfe:	681a      	ldr	r2, [r3, #0]
 8013c00:	f246 5360 	movw	r3, #25952	; 0x6560
 8013c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c08:	601a      	str	r2, [r3, #0]
 8013c0a:	e01c      	b.n	8013c46 <tcp_listen_with_backlog+0x10e>
 8013c0c:	f246 5360 	movw	r3, #25952	; 0x6560
 8013c10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c14:	681b      	ldr	r3, [r3, #0]
 8013c16:	68da      	ldr	r2, [r3, #12]
 8013c18:	687b      	ldr	r3, [r7, #4]
 8013c1a:	429a      	cmp	r2, r3
 8013c1c:	d108      	bne.n	8013c30 <tcp_listen_with_backlog+0xf8>
 8013c1e:	f246 5360 	movw	r3, #25952	; 0x6560
 8013c22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c26:	681b      	ldr	r3, [r3, #0]
 8013c28:	687a      	ldr	r2, [r7, #4]
 8013c2a:	68d2      	ldr	r2, [r2, #12]
 8013c2c:	60da      	str	r2, [r3, #12]
 8013c2e:	e011      	b.n	8013c54 <tcp_listen_with_backlog+0x11c>
 8013c30:	f246 5360 	movw	r3, #25952	; 0x6560
 8013c34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c38:	681b      	ldr	r3, [r3, #0]
 8013c3a:	68da      	ldr	r2, [r3, #12]
 8013c3c:	f246 5360 	movw	r3, #25952	; 0x6560
 8013c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c44:	601a      	str	r2, [r3, #0]
 8013c46:	f246 5360 	movw	r3, #25952	; 0x6560
 8013c4a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c4e:	681b      	ldr	r3, [r3, #0]
 8013c50:	2b00      	cmp	r3, #0
 8013c52:	d1db      	bne.n	8013c0c <tcp_listen_with_backlog+0xd4>
 8013c54:	687b      	ldr	r3, [r7, #4]
 8013c56:	f04f 0200 	mov.w	r2, #0
 8013c5a:	60da      	str	r2, [r3, #12]
  memp_free(MEMP_TCP_PCB, pcb);
 8013c5c:	6878      	ldr	r0, [r7, #4]
 8013c5e:	f7fe f92b 	bl	8011eb8 <mem_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 8013c62:	68fa      	ldr	r2, [r7, #12]
 8013c64:	f643 3319 	movw	r3, #15129	; 0x3b19
 8013c68:	f6c0 0301 	movt	r3, #2049	; 0x801
 8013c6c:	61d3      	str	r3, [r2, #28]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
 8013c6e:	f246 535c 	movw	r3, #25948	; 0x655c
 8013c72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c76:	681a      	ldr	r2, [r3, #0]
 8013c78:	68fb      	ldr	r3, [r7, #12]
 8013c7a:	60da      	str	r2, [r3, #12]
 8013c7c:	f246 535c 	movw	r3, #25948	; 0x655c
 8013c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013c84:	68fa      	ldr	r2, [r7, #12]
 8013c86:	601a      	str	r2, [r3, #0]
  return (struct tcp_pcb *)lpcb;
 8013c88:	68fb      	ldr	r3, [r7, #12]
}
 8013c8a:	4618      	mov	r0, r3
 8013c8c:	f107 0710 	add.w	r7, r7, #16
 8013c90:	46bd      	mov	sp, r7
 8013c92:	bd80      	pop	{r7, pc}

08013c94 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 8013c94:	b480      	push	{r7}
 8013c96:	b085      	sub	sp, #20
 8013c98:	af00      	add	r7, sp, #0
 8013c9a:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8013c9c:	687b      	ldr	r3, [r7, #4]
 8013c9e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8013ca0:	687b      	ldr	r3, [r7, #4]
 8013ca2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8013ca4:	18d3      	adds	r3, r2, r3
 8013ca6:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8013ca8:	687b      	ldr	r3, [r7, #4]
 8013caa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8013cac:	687b      	ldr	r3, [r7, #4]
 8013cae:	8f19      	ldrh	r1, [r3, #56]	; 0x38
 8013cb0:	f240 53a6 	movw	r3, #1446	; 0x5a6
 8013cb4:	4299      	cmp	r1, r3
 8013cb6:	d802      	bhi.n	8013cbe <tcp_update_rcv_ann_wnd+0x2a>
 8013cb8:	687b      	ldr	r3, [r7, #4]
 8013cba:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8013cbc:	e001      	b.n	8013cc2 <tcp_update_rcv_ann_wnd+0x2e>
 8013cbe:	f240 53a6 	movw	r3, #1446	; 0x5a6
 8013cc2:	18d3      	adds	r3, r2, r3
 8013cc4:	68fa      	ldr	r2, [r7, #12]
 8013cc6:	1ad3      	subs	r3, r2, r3
 8013cc8:	2b00      	cmp	r3, #0
 8013cca:	db08      	blt.n	8013cde <tcp_update_rcv_ann_wnd+0x4a>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 8013ccc:	687b      	ldr	r3, [r7, #4]
 8013cce:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8013cd0:	687b      	ldr	r3, [r7, #4]
 8013cd2:	855a      	strh	r2, [r3, #42]	; 0x2a
    return new_right_edge - pcb->rcv_ann_right_edge;
 8013cd4:	687b      	ldr	r3, [r7, #4]
 8013cd6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013cd8:	68fa      	ldr	r2, [r7, #12]
 8013cda:	1ad3      	subs	r3, r2, r3
 8013cdc:	e017      	b.n	8013d0e <tcp_update_rcv_ann_wnd+0x7a>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8013cde:	687b      	ldr	r3, [r7, #4]
 8013ce0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8013ce2:	687b      	ldr	r3, [r7, #4]
 8013ce4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013ce6:	1ad3      	subs	r3, r2, r3
 8013ce8:	2b00      	cmp	r3, #0
 8013cea:	dd04      	ble.n	8013cf6 <tcp_update_rcv_ann_wnd+0x62>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 8013cec:	687b      	ldr	r3, [r7, #4]
 8013cee:	f04f 0200 	mov.w	r2, #0
 8013cf2:	855a      	strh	r2, [r3, #42]	; 0x2a
 8013cf4:	e009      	b.n	8013d0a <tcp_update_rcv_ann_wnd+0x76>
    } else {
      /* keep the right edge of window constant */
      pcb->rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 8013cf6:	687b      	ldr	r3, [r7, #4]
 8013cf8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013cfa:	b29a      	uxth	r2, r3
 8013cfc:	687b      	ldr	r3, [r7, #4]
 8013cfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013d00:	b29b      	uxth	r3, r3
 8013d02:	1ad3      	subs	r3, r2, r3
 8013d04:	b29a      	uxth	r2, r3
 8013d06:	687b      	ldr	r3, [r7, #4]
 8013d08:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
    return 0;
 8013d0a:	f04f 0300 	mov.w	r3, #0
  }
}
 8013d0e:	4618      	mov	r0, r3
 8013d10:	f107 0714 	add.w	r7, r7, #20
 8013d14:	46bd      	mov	sp, r7
 8013d16:	bc80      	pop	{r7}
 8013d18:	4770      	bx	lr
 8013d1a:	bf00      	nop

08013d1c <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8013d1c:	b580      	push	{r7, lr}
 8013d1e:	b084      	sub	sp, #16
 8013d20:	af00      	add	r7, sp, #0
 8013d22:	6078      	str	r0, [r7, #4]
 8013d24:	460b      	mov	r3, r1
 8013d26:	807b      	strh	r3, [r7, #2]
  int wnd_inflation;

  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 8013d28:	687b      	ldr	r3, [r7, #4]
 8013d2a:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8013d2c:	887b      	ldrh	r3, [r7, #2]
 8013d2e:	18d3      	adds	r3, r2, r3
 8013d30:	b29a      	uxth	r2, r3
 8013d32:	687b      	ldr	r3, [r7, #4]
 8013d34:	851a      	strh	r2, [r3, #40]	; 0x28
  if (pcb->rcv_wnd > TCP_WND)
 8013d36:	687b      	ldr	r3, [r7, #4]
 8013d38:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8013d3a:	f640 334c 	movw	r3, #2892	; 0xb4c
 8013d3e:	429a      	cmp	r2, r3
 8013d40:	d903      	bls.n	8013d4a <tcp_recved+0x2e>
    pcb->rcv_wnd = TCP_WND;
 8013d42:	687b      	ldr	r3, [r7, #4]
 8013d44:	f640 324c 	movw	r2, #2892	; 0xb4c
 8013d48:	851a      	strh	r2, [r3, #40]	; 0x28

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 8013d4a:	6878      	ldr	r0, [r7, #4]
 8013d4c:	f7ff ffa2 	bl	8013c94 <tcp_update_rcv_ann_wnd>
 8013d50:	4603      	mov	r3, r0
 8013d52:	60fb      	str	r3, [r7, #12]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/2), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) 
 8013d54:	68fa      	ldr	r2, [r7, #12]
 8013d56:	f240 23d2 	movw	r3, #722	; 0x2d2
 8013d5a:	429a      	cmp	r2, r3
 8013d5c:	dd0b      	ble.n	8013d76 <tcp_recved+0x5a>
    tcp_ack_now(pcb);
 8013d5e:	687b      	ldr	r3, [r7, #4]
 8013d60:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8013d64:	f043 0302 	orr.w	r3, r3, #2
 8013d68:	b2da      	uxtb	r2, r3
 8013d6a:	687b      	ldr	r3, [r7, #4]
 8013d6c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8013d70:	6878      	ldr	r0, [r7, #4]
 8013d72:	f003 fa79 	bl	8017268 <tcp_output>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 8013d76:	f107 0710 	add.w	r7, r7, #16
 8013d7a:	46bd      	mov	sp, r7
 8013d7c:	bd80      	pop	{r7, pc}
 8013d7e:	bf00      	nop

08013d80 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 8013d80:	b480      	push	{r7}
 8013d82:	b083      	sub	sp, #12
 8013d84:	af00      	add	r7, sp, #0
 8013d86:	e004      	b.n	8013d92 <tcp_new_port+0x12>
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
 8013d88:	bf00      	nop
 8013d8a:	e002      	b.n	8013d92 <tcp_new_port+0x12>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
 8013d8c:	bf00      	nop
 8013d8e:	e000      	b.n	8013d92 <tcp_new_port+0x12>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
 8013d90:	bf00      	nop
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
 8013d92:	f246 7328 	movw	r3, #26408	; 0x6728
 8013d96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013d9a:	881b      	ldrh	r3, [r3, #0]
 8013d9c:	f103 0301 	add.w	r3, r3, #1
 8013da0:	b29a      	uxth	r2, r3
 8013da2:	f246 7328 	movw	r3, #26408	; 0x6728
 8013da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013daa:	801a      	strh	r2, [r3, #0]
 8013dac:	f246 7328 	movw	r3, #26408	; 0x6728
 8013db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013db4:	881b      	ldrh	r3, [r3, #0]
 8013db6:	b29b      	uxth	r3, r3
 8013db8:	b21b      	sxth	r3, r3
 8013dba:	2b00      	cmp	r3, #0
 8013dbc:	da06      	bge.n	8013dcc <tcp_new_port+0x4c>
    port = TCP_LOCAL_PORT_RANGE_START;
 8013dbe:	f246 7328 	movw	r3, #26408	; 0x6728
 8013dc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013dc6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013dca:	801a      	strh	r2, [r3, #0]
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8013dcc:	f246 5354 	movw	r3, #25940	; 0x6554
 8013dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013dd4:	681b      	ldr	r3, [r3, #0]
 8013dd6:	607b      	str	r3, [r7, #4]
 8013dd8:	e00b      	b.n	8013df2 <tcp_new_port+0x72>
    if (pcb->local_port == port) {
 8013dda:	687b      	ldr	r3, [r7, #4]
 8013ddc:	8b1a      	ldrh	r2, [r3, #24]
 8013dde:	f246 7328 	movw	r3, #26408	; 0x6728
 8013de2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013de6:	881b      	ldrh	r3, [r3, #0]
 8013de8:	429a      	cmp	r2, r3
 8013dea:	d0cd      	beq.n	8013d88 <tcp_new_port+0x8>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8013dec:	687b      	ldr	r3, [r7, #4]
 8013dee:	68db      	ldr	r3, [r3, #12]
 8013df0:	607b      	str	r3, [r7, #4]
 8013df2:	687b      	ldr	r3, [r7, #4]
 8013df4:	2b00      	cmp	r3, #0
 8013df6:	d1f0      	bne.n	8013dda <tcp_new_port+0x5a>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8013df8:	f246 5368 	movw	r3, #25960	; 0x6568
 8013dfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e00:	681b      	ldr	r3, [r3, #0]
 8013e02:	607b      	str	r3, [r7, #4]
 8013e04:	e00b      	b.n	8013e1e <tcp_new_port+0x9e>
    if (pcb->local_port == port) {
 8013e06:	687b      	ldr	r3, [r7, #4]
 8013e08:	8b1a      	ldrh	r2, [r3, #24]
 8013e0a:	f246 7328 	movw	r3, #26408	; 0x6728
 8013e0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e12:	881b      	ldrh	r3, [r3, #0]
 8013e14:	429a      	cmp	r2, r3
 8013e16:	d0b9      	beq.n	8013d8c <tcp_new_port+0xc>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8013e18:	687b      	ldr	r3, [r7, #4]
 8013e1a:	68db      	ldr	r3, [r3, #12]
 8013e1c:	607b      	str	r3, [r7, #4]
 8013e1e:	687b      	ldr	r3, [r7, #4]
 8013e20:	2b00      	cmp	r3, #0
 8013e22:	d1f0      	bne.n	8013e06 <tcp_new_port+0x86>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
 8013e24:	f246 535c 	movw	r3, #25948	; 0x655c
 8013e28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e2c:	681b      	ldr	r3, [r3, #0]
 8013e2e:	607b      	str	r3, [r7, #4]
 8013e30:	e00b      	b.n	8013e4a <tcp_new_port+0xca>
    if (pcb->local_port == port) {
 8013e32:	687b      	ldr	r3, [r7, #4]
 8013e34:	8b1a      	ldrh	r2, [r3, #24]
 8013e36:	f246 7328 	movw	r3, #26408	; 0x6728
 8013e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e3e:	881b      	ldrh	r3, [r3, #0]
 8013e40:	429a      	cmp	r2, r3
 8013e42:	d0a5      	beq.n	8013d90 <tcp_new_port+0x10>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
 8013e44:	687b      	ldr	r3, [r7, #4]
 8013e46:	68db      	ldr	r3, [r3, #12]
 8013e48:	607b      	str	r3, [r7, #4]
 8013e4a:	687b      	ldr	r3, [r7, #4]
 8013e4c:	2b00      	cmp	r3, #0
 8013e4e:	d1f0      	bne.n	8013e32 <tcp_new_port+0xb2>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
 8013e50:	f246 7328 	movw	r3, #26408	; 0x6728
 8013e54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e58:	881b      	ldrh	r3, [r3, #0]
}
 8013e5a:	4618      	mov	r0, r3
 8013e5c:	f107 070c 	add.w	r7, r7, #12
 8013e60:	46bd      	mov	sp, r7
 8013e62:	bc80      	pop	{r7}
 8013e64:	4770      	bx	lr
 8013e66:	bf00      	nop

08013e68 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
 8013e68:	b580      	push	{r7, lr}
 8013e6a:	b088      	sub	sp, #32
 8013e6c:	af02      	add	r7, sp, #8
 8013e6e:	60f8      	str	r0, [r7, #12]
 8013e70:	60b9      	str	r1, [r7, #8]
 8013e72:	603b      	str	r3, [r7, #0]
 8013e74:	4613      	mov	r3, r2
 8013e76:	80fb      	strh	r3, [r7, #6]
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 8013e78:	68fb      	ldr	r3, [r7, #12]
 8013e7a:	7c1b      	ldrb	r3, [r3, #16]
 8013e7c:	2b00      	cmp	r3, #0
 8013e7e:	d002      	beq.n	8013e86 <tcp_connect+0x1e>
 8013e80:	f04f 03f3 	mov.w	r3, #243	; 0xf3
 8013e84:	e0d2      	b.n	801402c <tcp_connect+0x1c4>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
 8013e86:	68bb      	ldr	r3, [r7, #8]
 8013e88:	2b00      	cmp	r3, #0
 8013e8a:	d00d      	beq.n	8013ea8 <tcp_connect+0x40>
    pcb->remote_ip = *ipaddr;
 8013e8c:	68fb      	ldr	r3, [r7, #12]
 8013e8e:	68ba      	ldr	r2, [r7, #8]
 8013e90:	f103 0304 	add.w	r3, r3, #4
 8013e94:	6810      	ldr	r0, [r2, #0]
 8013e96:	6018      	str	r0, [r3, #0]
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
 8013e98:	68fb      	ldr	r3, [r7, #12]
 8013e9a:	88fa      	ldrh	r2, [r7, #6]
 8013e9c:	841a      	strh	r2, [r3, #32]
  if (pcb->local_port == 0) {
 8013e9e:	68fb      	ldr	r3, [r7, #12]
 8013ea0:	8b1b      	ldrh	r3, [r3, #24]
 8013ea2:	2b00      	cmp	r3, #0
 8013ea4:	d003      	beq.n	8013eae <tcp_connect+0x46>
 8013ea6:	e008      	b.n	8013eba <tcp_connect+0x52>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
 8013ea8:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8013eac:	e0be      	b.n	801402c <tcp_connect+0x1c4>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
 8013eae:	f7ff ff67 	bl	8013d80 <tcp_new_port>
 8013eb2:	4603      	mov	r3, r0
 8013eb4:	461a      	mov	r2, r3
 8013eb6:	68fb      	ldr	r3, [r7, #12]
 8013eb8:	831a      	strh	r2, [r3, #24]
  }
  iss = tcp_next_iss();
 8013eba:	f000 fdd5 	bl	8014a68 <tcp_next_iss>
 8013ebe:	6178      	str	r0, [r7, #20]
  pcb->rcv_nxt = 0;
 8013ec0:	68fb      	ldr	r3, [r7, #12]
 8013ec2:	f04f 0200 	mov.w	r2, #0
 8013ec6:	625a      	str	r2, [r3, #36]	; 0x24
  pcb->snd_nxt = iss;
 8013ec8:	68fb      	ldr	r3, [r7, #12]
 8013eca:	697a      	ldr	r2, [r7, #20]
 8013ecc:	659a      	str	r2, [r3, #88]	; 0x58
  pcb->lastack = iss - 1;
 8013ece:	697b      	ldr	r3, [r7, #20]
 8013ed0:	f103 32ff 	add.w	r2, r3, #4294967295
 8013ed4:	68fb      	ldr	r3, [r7, #12]
 8013ed6:	64da      	str	r2, [r3, #76]	; 0x4c
  pcb->snd_lbb = iss - 1;
 8013ed8:	697b      	ldr	r3, [r7, #20]
 8013eda:	f103 32ff 	add.w	r2, r3, #4294967295
 8013ede:	68fb      	ldr	r3, [r7, #12]
 8013ee0:	669a      	str	r2, [r3, #104]	; 0x68
  pcb->rcv_wnd = TCP_WND;
 8013ee2:	68fb      	ldr	r3, [r7, #12]
 8013ee4:	f640 324c 	movw	r2, #2892	; 0xb4c
 8013ee8:	851a      	strh	r2, [r3, #40]	; 0x28
  pcb->rcv_ann_wnd = TCP_WND;
 8013eea:	68fb      	ldr	r3, [r7, #12]
 8013eec:	f640 324c 	movw	r2, #2892	; 0xb4c
 8013ef0:	855a      	strh	r2, [r3, #42]	; 0x2a
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8013ef2:	68fb      	ldr	r3, [r7, #12]
 8013ef4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8013ef6:	68fb      	ldr	r3, [r7, #12]
 8013ef8:	62da      	str	r2, [r3, #44]	; 0x2c
  pcb->snd_wnd = TCP_WND;
 8013efa:	68fb      	ldr	r3, [r7, #12]
 8013efc:	f640 324c 	movw	r2, #2892	; 0xb4c
 8013f00:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8013f04:	68fb      	ldr	r3, [r7, #12]
 8013f06:	f44f 7206 	mov.w	r2, #536	; 0x218
 8013f0a:	871a      	strh	r2, [r3, #56]	; 0x38
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
 8013f0c:	68fb      	ldr	r3, [r7, #12]
 8013f0e:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8013f10:	4618      	mov	r0, r3
 8013f12:	68b9      	ldr	r1, [r7, #8]
 8013f14:	f000 fdc4 	bl	8014aa0 <tcp_eff_send_mss>
 8013f18:	4603      	mov	r3, r0
 8013f1a:	461a      	mov	r2, r3
 8013f1c:	68fb      	ldr	r3, [r7, #12]
 8013f1e:	871a      	strh	r2, [r3, #56]	; 0x38
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 8013f20:	68fb      	ldr	r3, [r7, #12]
 8013f22:	f04f 0201 	mov.w	r2, #1
 8013f26:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
  pcb->ssthresh = pcb->mss * 10;
 8013f2a:	68fb      	ldr	r3, [r7, #12]
 8013f2c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8013f2e:	461a      	mov	r2, r3
 8013f30:	ea4f 0282 	mov.w	r2, r2, lsl #2
 8013f34:	18d3      	adds	r3, r2, r3
 8013f36:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8013f3a:	b29a      	uxth	r2, r3
 8013f3c:	68fb      	ldr	r3, [r7, #12]
 8013f3e:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
  pcb->state = SYN_SENT;
 8013f42:	68fb      	ldr	r3, [r7, #12]
 8013f44:	f04f 0202 	mov.w	r2, #2
 8013f48:	741a      	strb	r2, [r3, #16]
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
 8013f4a:	68fb      	ldr	r3, [r7, #12]
 8013f4c:	683a      	ldr	r2, [r7, #0]
 8013f4e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
 8013f52:	f246 5364 	movw	r3, #25956	; 0x6564
 8013f56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f5a:	681a      	ldr	r2, [r3, #0]
 8013f5c:	68fb      	ldr	r3, [r7, #12]
 8013f5e:	429a      	cmp	r2, r3
 8013f60:	d10b      	bne.n	8013f7a <tcp_connect+0x112>
 8013f62:	f246 5364 	movw	r3, #25956	; 0x6564
 8013f66:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f6a:	681b      	ldr	r3, [r3, #0]
 8013f6c:	68da      	ldr	r2, [r3, #12]
 8013f6e:	f246 5364 	movw	r3, #25956	; 0x6564
 8013f72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f76:	601a      	str	r2, [r3, #0]
 8013f78:	e02e      	b.n	8013fd8 <tcp_connect+0x170>
 8013f7a:	f246 5364 	movw	r3, #25956	; 0x6564
 8013f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f82:	681a      	ldr	r2, [r3, #0]
 8013f84:	f246 5360 	movw	r3, #25952	; 0x6560
 8013f88:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f8c:	601a      	str	r2, [r3, #0]
 8013f8e:	e01c      	b.n	8013fca <tcp_connect+0x162>
 8013f90:	f246 5360 	movw	r3, #25952	; 0x6560
 8013f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013f98:	681b      	ldr	r3, [r3, #0]
 8013f9a:	68da      	ldr	r2, [r3, #12]
 8013f9c:	68fb      	ldr	r3, [r7, #12]
 8013f9e:	429a      	cmp	r2, r3
 8013fa0:	d108      	bne.n	8013fb4 <tcp_connect+0x14c>
 8013fa2:	f246 5360 	movw	r3, #25952	; 0x6560
 8013fa6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013faa:	681b      	ldr	r3, [r3, #0]
 8013fac:	68fa      	ldr	r2, [r7, #12]
 8013fae:	68d2      	ldr	r2, [r2, #12]
 8013fb0:	60da      	str	r2, [r3, #12]
 8013fb2:	e011      	b.n	8013fd8 <tcp_connect+0x170>
 8013fb4:	f246 5360 	movw	r3, #25952	; 0x6560
 8013fb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013fbc:	681b      	ldr	r3, [r3, #0]
 8013fbe:	68da      	ldr	r2, [r3, #12]
 8013fc0:	f246 5360 	movw	r3, #25952	; 0x6560
 8013fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013fc8:	601a      	str	r2, [r3, #0]
 8013fca:	f246 5360 	movw	r3, #25952	; 0x6560
 8013fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013fd2:	681b      	ldr	r3, [r3, #0]
 8013fd4:	2b00      	cmp	r3, #0
 8013fd6:	d1db      	bne.n	8013f90 <tcp_connect+0x128>
 8013fd8:	68fb      	ldr	r3, [r7, #12]
 8013fda:	f04f 0200 	mov.w	r2, #0
 8013fde:	60da      	str	r2, [r3, #12]
  TCP_REG(&tcp_active_pcbs, pcb);
 8013fe0:	f246 5354 	movw	r3, #25940	; 0x6554
 8013fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013fe8:	681a      	ldr	r2, [r3, #0]
 8013fea:	68fb      	ldr	r3, [r7, #12]
 8013fec:	60da      	str	r2, [r3, #12]
 8013fee:	f246 5354 	movw	r3, #25940	; 0x6554
 8013ff2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013ff6:	68fa      	ldr	r2, [r7, #12]
 8013ff8:	601a      	str	r2, [r3, #0]

  snmp_inc_tcpactiveopens();
  
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
 8013ffa:	f04f 0300 	mov.w	r3, #0
 8013ffe:	9300      	str	r3, [sp, #0]
 8014000:	f04f 0301 	mov.w	r3, #1
 8014004:	9301      	str	r3, [sp, #4]
 8014006:	68f8      	ldr	r0, [r7, #12]
 8014008:	f04f 0100 	mov.w	r1, #0
 801400c:	f04f 0200 	mov.w	r2, #0
 8014010:	f04f 0302 	mov.w	r3, #2
 8014014:	f002 fdd6 	bl	8016bc4 <tcp_enqueue>
 8014018:	4603      	mov	r3, r0
 801401a:	74fb      	strb	r3, [r7, #19]
#if LWIP_TCP_TIMESTAMPS
                    | TF_SEG_OPTS_TS
#endif
                    );
  if (ret == ERR_OK) { 
 801401c:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8014020:	2b00      	cmp	r3, #0
 8014022:	d102      	bne.n	801402a <tcp_connect+0x1c2>
    tcp_output(pcb);
 8014024:	68f8      	ldr	r0, [r7, #12]
 8014026:	f003 f91f 	bl	8017268 <tcp_output>
  }
  return ret;
 801402a:	7cfb      	ldrb	r3, [r7, #19]
 801402c:	b25b      	sxtb	r3, r3
} 
 801402e:	4618      	mov	r0, r3
 8014030:	f107 0718 	add.w	r7, r7, #24
 8014034:	46bd      	mov	sp, r7
 8014036:	bd80      	pop	{r7, pc}

08014038 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 8014038:	b5b0      	push	{r4, r5, r7, lr}
 801403a:	b088      	sub	sp, #32
 801403c:	af02      	add	r7, sp, #8
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 801403e:	f04f 0300 	mov.w	r3, #0
 8014042:	737b      	strb	r3, [r7, #13]

  ++tcp_ticks;
 8014044:	f246 5358 	movw	r3, #25944	; 0x6558
 8014048:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801404c:	681b      	ldr	r3, [r3, #0]
 801404e:	f103 0201 	add.w	r2, r3, #1
 8014052:	f246 5358 	movw	r3, #25944	; 0x6558
 8014056:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801405a:	601a      	str	r2, [r3, #0]

  /* Steps through all of the active PCBs. */
  prev = NULL;
 801405c:	f04f 0300 	mov.w	r3, #0
 8014060:	613b      	str	r3, [r7, #16]
  pcb = tcp_active_pcbs;
 8014062:	f246 5354 	movw	r3, #25940	; 0x6554
 8014066:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801406a:	681b      	ldr	r3, [r3, #0]
 801406c:	617b      	str	r3, [r7, #20]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 801406e:	e1bb      	b.n	80143e8 <tcp_slowtmr+0x3b0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
 8014070:	f04f 0300 	mov.w	r3, #0
 8014074:	73fb      	strb	r3, [r7, #15]
    pcb_reset = 0;
 8014076:	f04f 0300 	mov.w	r3, #0
 801407a:	73bb      	strb	r3, [r7, #14]

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 801407c:	697b      	ldr	r3, [r7, #20]
 801407e:	7c1b      	ldrb	r3, [r3, #16]
 8014080:	2b02      	cmp	r3, #2
 8014082:	d109      	bne.n	8014098 <tcp_slowtmr+0x60>
 8014084:	697b      	ldr	r3, [r7, #20]
 8014086:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 801408a:	2b06      	cmp	r3, #6
 801408c:	d104      	bne.n	8014098 <tcp_slowtmr+0x60>
      ++pcb_remove;
 801408e:	7bfb      	ldrb	r3, [r7, #15]
 8014090:	f103 0301 	add.w	r3, r3, #1
 8014094:	73fb      	strb	r3, [r7, #15]
 8014096:	e0a1      	b.n	80141dc <tcp_slowtmr+0x1a4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 8014098:	697b      	ldr	r3, [r7, #20]
 801409a:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 801409e:	2b0c      	cmp	r3, #12
 80140a0:	d104      	bne.n	80140ac <tcp_slowtmr+0x74>
      ++pcb_remove;
 80140a2:	7bfb      	ldrb	r3, [r7, #15]
 80140a4:	f103 0301 	add.w	r3, r3, #1
 80140a8:	73fb      	strb	r3, [r7, #15]
 80140aa:	e097      	b.n	80141dc <tcp_slowtmr+0x1a4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 80140ac:	697b      	ldr	r3, [r7, #20]
 80140ae:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80140b2:	2b00      	cmp	r3, #0
 80140b4:	d02d      	beq.n	8014112 <tcp_slowtmr+0xda>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 80140b6:	697b      	ldr	r3, [r7, #20]
 80140b8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 80140bc:	f103 0201 	add.w	r2, r3, #1
 80140c0:	697b      	ldr	r3, [r7, #20]
 80140c2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 80140c6:	697b      	ldr	r3, [r7, #20]
 80140c8:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 80140cc:	697b      	ldr	r3, [r7, #20]
 80140ce:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80140d2:	f103 31ff 	add.w	r1, r3, #4294967295
 80140d6:	f646 0370 	movw	r3, #26736	; 0x6870
 80140da:	f6c0 0302 	movt	r3, #2050	; 0x802
 80140de:	5c5b      	ldrb	r3, [r3, r1]
 80140e0:	429a      	cmp	r2, r3
 80140e2:	d37b      	bcc.n	80141dc <tcp_slowtmr+0x1a4>
          pcb->persist_cnt = 0;
 80140e4:	697b      	ldr	r3, [r7, #20]
 80140e6:	f04f 0200 	mov.w	r2, #0
 80140ea:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 80140ee:	697b      	ldr	r3, [r7, #20]
 80140f0:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80140f4:	2b06      	cmp	r3, #6
 80140f6:	d808      	bhi.n	801410a <tcp_slowtmr+0xd2>
            pcb->persist_backoff++;
 80140f8:	697b      	ldr	r3, [r7, #20]
 80140fa:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80140fe:	f103 0301 	add.w	r3, r3, #1
 8014102:	b2da      	uxtb	r2, r3
 8014104:	697b      	ldr	r3, [r7, #20]
 8014106:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
          }
          tcp_zero_window_probe(pcb);
 801410a:	6978      	ldr	r0, [r7, #20]
 801410c:	f003 fc68 	bl	80179e0 <tcp_zero_window_probe>
 8014110:	e064      	b.n	80141dc <tcp_slowtmr+0x1a4>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
 8014112:	697b      	ldr	r3, [r7, #20]
 8014114:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8014116:	b21b      	sxth	r3, r3
 8014118:	2b00      	cmp	r3, #0
 801411a:	db06      	blt.n	801412a <tcp_slowtmr+0xf2>
          ++pcb->rtime;
 801411c:	697b      	ldr	r3, [r7, #20]
 801411e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8014120:	f103 0301 	add.w	r3, r3, #1
 8014124:	b29a      	uxth	r2, r3
 8014126:	697b      	ldr	r3, [r7, #20]
 8014128:	86da      	strh	r2, [r3, #54]	; 0x36

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 801412a:	697b      	ldr	r3, [r7, #20]
 801412c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801412e:	2b00      	cmp	r3, #0
 8014130:	d054      	beq.n	80141dc <tcp_slowtmr+0x1a4>
 8014132:	697b      	ldr	r3, [r7, #20]
 8014134:	8eda      	ldrh	r2, [r3, #54]	; 0x36
 8014136:	697b      	ldr	r3, [r7, #20]
 8014138:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 801413c:	b212      	sxth	r2, r2
 801413e:	b21b      	sxth	r3, r3
 8014140:	429a      	cmp	r2, r3
 8014142:	db4b      	blt.n	80141dc <tcp_slowtmr+0x1a4>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
 8014144:	697b      	ldr	r3, [r7, #20]
 8014146:	7c1b      	ldrb	r3, [r3, #16]
 8014148:	2b02      	cmp	r3, #2
 801414a:	d01b      	beq.n	8014184 <tcp_slowtmr+0x14c>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 801414c:	697b      	ldr	r3, [r7, #20]
 801414e:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8014152:	b21b      	sxth	r3, r3
 8014154:	ea4f 03e3 	mov.w	r3, r3, asr #3
 8014158:	b29b      	uxth	r3, r3
 801415a:	b21a      	sxth	r2, r3
 801415c:	697b      	ldr	r3, [r7, #20]
 801415e:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8014162:	b21b      	sxth	r3, r3
 8014164:	18d2      	adds	r2, r2, r3
 8014166:	697b      	ldr	r3, [r7, #20]
 8014168:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 801416c:	4619      	mov	r1, r3
 801416e:	f646 0360 	movw	r3, #26720	; 0x6860
 8014172:	f6c0 0302 	movt	r3, #2050	; 0x802
 8014176:	5c5b      	ldrb	r3, [r3, r1]
 8014178:	fa02 f303 	lsl.w	r3, r2, r3
 801417c:	b29a      	uxth	r2, r3
 801417e:	697b      	ldr	r3, [r7, #20]
 8014180:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 8014184:	697b      	ldr	r3, [r7, #20]
 8014186:	f04f 0200 	mov.w	r2, #0
 801418a:	86da      	strh	r2, [r3, #54]	; 0x36

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 801418c:	697b      	ldr	r3, [r7, #20]
 801418e:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 8014192:	697b      	ldr	r3, [r7, #20]
 8014194:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 8014198:	429a      	cmp	r2, r3
 801419a:	bf38      	it	cc
 801419c:	4613      	movcc	r3, r2
 801419e:	817b      	strh	r3, [r7, #10]
          pcb->ssthresh = eff_wnd >> 1;
 80141a0:	897b      	ldrh	r3, [r7, #10]
 80141a2:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80141a6:	b29a      	uxth	r2, r3
 80141a8:	697b      	ldr	r3, [r7, #20]
 80141aa:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
          if (pcb->ssthresh < pcb->mss) {
 80141ae:	697b      	ldr	r3, [r7, #20]
 80141b0:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 80141b4:	697b      	ldr	r3, [r7, #20]
 80141b6:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80141b8:	429a      	cmp	r2, r3
 80141ba:	d207      	bcs.n	80141cc <tcp_slowtmr+0x194>
            pcb->ssthresh = pcb->mss * 2;
 80141bc:	697b      	ldr	r3, [r7, #20]
 80141be:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80141c0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80141c4:	b29a      	uxth	r2, r3
 80141c6:	697b      	ldr	r3, [r7, #20]
 80141c8:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
          }
          pcb->cwnd = pcb->mss;
 80141cc:	697b      	ldr	r3, [r7, #20]
 80141ce:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 80141d0:	697b      	ldr	r3, [r7, #20]
 80141d2:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 80141d6:	6978      	ldr	r0, [r7, #20]
 80141d8:	f003 faf2 	bl	80177c0 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 80141dc:	697b      	ldr	r3, [r7, #20]
 80141de:	7c1b      	ldrb	r3, [r3, #16]
 80141e0:	2b06      	cmp	r3, #6
 80141e2:	d10d      	bne.n	8014200 <tcp_slowtmr+0x1c8>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 80141e4:	f246 5358 	movw	r3, #25944	; 0x6558
 80141e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80141ec:	681a      	ldr	r2, [r3, #0]
 80141ee:	697b      	ldr	r3, [r7, #20]
 80141f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80141f2:	1ad3      	subs	r3, r2, r3
 80141f4:	2b28      	cmp	r3, #40	; 0x28
 80141f6:	d903      	bls.n	8014200 <tcp_slowtmr+0x1c8>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 80141f8:	7bfb      	ldrb	r3, [r7, #15]
 80141fa:	f103 0301 	add.w	r3, r3, #1
 80141fe:	73fb      	strb	r3, [r7, #15]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
 8014200:	697b      	ldr	r3, [r7, #20]
 8014202:	891b      	ldrh	r3, [r3, #8]
 8014204:	f003 0308 	and.w	r3, r3, #8
 8014208:	2b00      	cmp	r3, #0
 801420a:	d055      	beq.n	80142b8 <tcp_slowtmr+0x280>
       ((pcb->state == ESTABLISHED) || 
 801420c:	697b      	ldr	r3, [r7, #20]
 801420e:	7c1b      	ldrb	r3, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
 8014210:	2b04      	cmp	r3, #4
 8014212:	d003      	beq.n	801421c <tcp_slowtmr+0x1e4>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
 8014214:	697b      	ldr	r3, [r7, #20]
 8014216:	7c1b      	ldrb	r3, [r3, #16]
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
 8014218:	2b07      	cmp	r3, #7
 801421a:	d14d      	bne.n	80142b8 <tcp_slowtmr+0x280>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
 801421c:	f246 5358 	movw	r3, #25944	; 0x6558
 8014220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014224:	681a      	ldr	r2, [r3, #0]
 8014226:	697b      	ldr	r3, [r7, #20]
 8014228:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801422a:	1ad1      	subs	r1, r2, r3
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
 801422c:	697b      	ldr	r3, [r7, #20]
 801422e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8014232:	f503 2224 	add.w	r2, r3, #671744	; 0xa4000
 8014236:	f602 42b8 	addw	r2, r2, #3256	; 0xcb8
 801423a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 801423e:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8014242:	fba3 0302 	umull	r0, r3, r3, r2
 8014246:	ea4f 1353 	mov.w	r3, r3, lsr #5
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
 801424a:	4299      	cmp	r1, r3
 801424c:	d908      	bls.n	8014260 <tcp_slowtmr+0x228>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        ++pcb_remove;
 801424e:	7bfb      	ldrb	r3, [r7, #15]
 8014250:	f103 0301 	add.w	r3, r3, #1
 8014254:	73fb      	strb	r3, [r7, #15]
        ++pcb_reset;
 8014256:	7bbb      	ldrb	r3, [r7, #14]
 8014258:	f103 0301 	add.w	r3, r3, #1
 801425c:	73bb      	strb	r3, [r7, #14]
 801425e:	e02b      	b.n	80142b8 <tcp_slowtmr+0x280>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 8014260:	f246 5358 	movw	r3, #25944	; 0x6558
 8014264:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014268:	681a      	ldr	r2, [r3, #0]
 801426a:	697b      	ldr	r3, [r7, #20]
 801426c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801426e:	1ad2      	subs	r2, r2, r3
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
 8014270:	697b      	ldr	r3, [r7, #20]
 8014272:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 8014276:	697b      	ldr	r3, [r7, #20]
 8014278:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
 801427c:	4618      	mov	r0, r3
 801427e:	f242 43f8 	movw	r3, #9464	; 0x24f8
 8014282:	f2c0 0301 	movt	r3, #1
 8014286:	fb03 f300 	mul.w	r3, r3, r0
 801428a:	18c9      	adds	r1, r1, r3
              / TCP_SLOW_INTERVAL)
 801428c:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 8014290:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8014294:	fba3 0301 	umull	r0, r3, r3, r1
 8014298:	ea4f 1353 	mov.w	r3, r3, lsr #5
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 801429c:	429a      	cmp	r2, r3
 801429e:	d90b      	bls.n	80142b8 <tcp_slowtmr+0x280>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
 80142a0:	6978      	ldr	r0, [r7, #20]
 80142a2:	f003 fb67 	bl	8017974 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 80142a6:	697b      	ldr	r3, [r7, #20]
 80142a8:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
 80142ac:	f103 0301 	add.w	r3, r3, #1
 80142b0:	b2da      	uxtb	r2, r3
 80142b2:	697b      	ldr	r3, [r7, #20]
 80142b4:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 80142b8:	697b      	ldr	r3, [r7, #20]
 80142ba:	7c1b      	ldrb	r3, [r3, #16]
 80142bc:	2b03      	cmp	r3, #3
 80142be:	d10d      	bne.n	80142dc <tcp_slowtmr+0x2a4>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 80142c0:	f246 5358 	movw	r3, #25944	; 0x6558
 80142c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142c8:	681a      	ldr	r2, [r3, #0]
 80142ca:	697b      	ldr	r3, [r7, #20]
 80142cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80142ce:	1ad3      	subs	r3, r2, r3
 80142d0:	2b28      	cmp	r3, #40	; 0x28
 80142d2:	d903      	bls.n	80142dc <tcp_slowtmr+0x2a4>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 80142d4:	7bfb      	ldrb	r3, [r7, #15]
 80142d6:	f103 0301 	add.w	r3, r3, #1
 80142da:	73fb      	strb	r3, [r7, #15]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 80142dc:	697b      	ldr	r3, [r7, #20]
 80142de:	7c1b      	ldrb	r3, [r3, #16]
 80142e0:	2b09      	cmp	r3, #9
 80142e2:	d10d      	bne.n	8014300 <tcp_slowtmr+0x2c8>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 80142e4:	f246 5358 	movw	r3, #25944	; 0x6558
 80142e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80142ec:	681a      	ldr	r2, [r3, #0]
 80142ee:	697b      	ldr	r3, [r7, #20]
 80142f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80142f2:	1ad3      	subs	r3, r2, r3
 80142f4:	2bf0      	cmp	r3, #240	; 0xf0
 80142f6:	d903      	bls.n	8014300 <tcp_slowtmr+0x2c8>
        ++pcb_remove;
 80142f8:	7bfb      	ldrb	r3, [r7, #15]
 80142fa:	f103 0301 	add.w	r3, r3, #1
 80142fe:	73fb      	strb	r3, [r7, #15]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8014300:	7bfb      	ldrb	r3, [r7, #15]
 8014302:	2b00      	cmp	r3, #0
 8014304:	d03b      	beq.n	801437e <tcp_slowtmr+0x346>
      tcp_pcb_purge(pcb);      
 8014306:	6978      	ldr	r0, [r7, #20]
 8014308:	f000 fb10 	bl	801492c <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 801430c:	693b      	ldr	r3, [r7, #16]
 801430e:	2b00      	cmp	r3, #0
 8014310:	d004      	beq.n	801431c <tcp_slowtmr+0x2e4>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 8014312:	697b      	ldr	r3, [r7, #20]
 8014314:	68da      	ldr	r2, [r3, #12]
 8014316:	693b      	ldr	r3, [r7, #16]
 8014318:	60da      	str	r2, [r3, #12]
 801431a:	e006      	b.n	801432a <tcp_slowtmr+0x2f2>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
 801431c:	697b      	ldr	r3, [r7, #20]
 801431e:	68da      	ldr	r2, [r3, #12]
 8014320:	f246 5354 	movw	r3, #25940	; 0x6554
 8014324:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014328:	601a      	str	r2, [r3, #0]
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
 801432a:	697b      	ldr	r3, [r7, #20]
 801432c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8014330:	2b00      	cmp	r3, #0
 8014332:	d008      	beq.n	8014346 <tcp_slowtmr+0x30e>
 8014334:	697b      	ldr	r3, [r7, #20]
 8014336:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801433a:	697a      	ldr	r2, [r7, #20]
 801433c:	6952      	ldr	r2, [r2, #20]
 801433e:	4610      	mov	r0, r2
 8014340:	f06f 0104 	mvn.w	r1, #4
 8014344:	4798      	blx	r3
      if (pcb_reset) {
 8014346:	7bbb      	ldrb	r3, [r7, #14]
 8014348:	2b00      	cmp	r3, #0
 801434a:	d00f      	beq.n	801436c <tcp_slowtmr+0x334>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 801434c:	697b      	ldr	r3, [r7, #20]
 801434e:	6d98      	ldr	r0, [r3, #88]	; 0x58
 8014350:	697b      	ldr	r3, [r7, #20]
 8014352:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8014354:	697a      	ldr	r2, [r7, #20]
 8014356:	697b      	ldr	r3, [r7, #20]
 8014358:	f103 0304 	add.w	r3, r3, #4
          pcb->local_port, pcb->remote_port);
 801435c:	697c      	ldr	r4, [r7, #20]
        tcp_active_pcbs = pcb->next;
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 801435e:	8b25      	ldrh	r5, [r4, #24]
          pcb->local_port, pcb->remote_port);
 8014360:	697c      	ldr	r4, [r7, #20]
        tcp_active_pcbs = pcb->next;
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8014362:	8c24      	ldrh	r4, [r4, #32]
 8014364:	9500      	str	r5, [sp, #0]
 8014366:	9401      	str	r4, [sp, #4]
 8014368:	f003 f9a4 	bl	80176b4 <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      pcb2 = pcb->next;
 801436c:	697b      	ldr	r3, [r7, #20]
 801436e:	68db      	ldr	r3, [r3, #12]
 8014370:	607b      	str	r3, [r7, #4]
      memp_free(MEMP_TCP_PCB, pcb);
 8014372:	6978      	ldr	r0, [r7, #20]
 8014374:	f7fd fda0 	bl	8011eb8 <mem_free>
      pcb = pcb2;
 8014378:	687b      	ldr	r3, [r7, #4]
 801437a:	617b      	str	r3, [r7, #20]
 801437c:	e034      	b.n	80143e8 <tcp_slowtmr+0x3b0>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
 801437e:	697b      	ldr	r3, [r7, #20]
 8014380:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8014384:	f103 0301 	add.w	r3, r3, #1
 8014388:	b2da      	uxtb	r2, r3
 801438a:	697b      	ldr	r3, [r7, #20]
 801438c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      if (pcb->polltmr >= pcb->pollinterval) {
 8014390:	697b      	ldr	r3, [r7, #20]
 8014392:	f893 2034 	ldrb.w	r2, [r3, #52]	; 0x34
 8014396:	697b      	ldr	r3, [r7, #20]
 8014398:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 801439c:	429a      	cmp	r2, r3
 801439e:	d31e      	bcc.n	80143de <tcp_slowtmr+0x3a6>
        pcb->polltmr = 0;
 80143a0:	697b      	ldr	r3, [r7, #20]
 80143a2:	f04f 0200 	mov.w	r2, #0
 80143a6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
 80143aa:	697b      	ldr	r3, [r7, #20]
 80143ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80143b0:	2b00      	cmp	r3, #0
 80143b2:	d00a      	beq.n	80143ca <tcp_slowtmr+0x392>
 80143b4:	697b      	ldr	r3, [r7, #20]
 80143b6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80143ba:	697a      	ldr	r2, [r7, #20]
 80143bc:	6952      	ldr	r2, [r2, #20]
 80143be:	4610      	mov	r0, r2
 80143c0:	6979      	ldr	r1, [r7, #20]
 80143c2:	4798      	blx	r3
 80143c4:	4603      	mov	r3, r0
 80143c6:	737b      	strb	r3, [r7, #13]
 80143c8:	e002      	b.n	80143d0 <tcp_slowtmr+0x398>
 80143ca:	f04f 0300 	mov.w	r3, #0
 80143ce:	737b      	strb	r3, [r7, #13]
        if (err == ERR_OK) {
 80143d0:	f997 300d 	ldrsb.w	r3, [r7, #13]
 80143d4:	2b00      	cmp	r3, #0
 80143d6:	d102      	bne.n	80143de <tcp_slowtmr+0x3a6>
          tcp_output(pcb);
 80143d8:	6978      	ldr	r0, [r7, #20]
 80143da:	f002 ff45 	bl	8017268 <tcp_output>
        }
      }
      
      prev = pcb;
 80143de:	697b      	ldr	r3, [r7, #20]
 80143e0:	613b      	str	r3, [r7, #16]
      pcb = pcb->next;
 80143e2:	697b      	ldr	r3, [r7, #20]
 80143e4:	68db      	ldr	r3, [r3, #12]
 80143e6:	617b      	str	r3, [r7, #20]
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 80143e8:	697b      	ldr	r3, [r7, #20]
 80143ea:	2b00      	cmp	r3, #0
 80143ec:	f47f ae40 	bne.w	8014070 <tcp_slowtmr+0x38>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
 80143f0:	f04f 0300 	mov.w	r3, #0
 80143f4:	613b      	str	r3, [r7, #16]
  pcb = tcp_tw_pcbs;
 80143f6:	f246 5368 	movw	r3, #25960	; 0x6568
 80143fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80143fe:	681b      	ldr	r3, [r3, #0]
 8014400:	617b      	str	r3, [r7, #20]
  while (pcb != NULL) {
 8014402:	e033      	b.n	801446c <tcp_slowtmr+0x434>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
 8014404:	f04f 0300 	mov.w	r3, #0
 8014408:	73fb      	strb	r3, [r7, #15]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 801440a:	f246 5358 	movw	r3, #25944	; 0x6558
 801440e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014412:	681a      	ldr	r2, [r3, #0]
 8014414:	697b      	ldr	r3, [r7, #20]
 8014416:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014418:	1ad3      	subs	r3, r2, r3
 801441a:	2bf0      	cmp	r3, #240	; 0xf0
 801441c:	d903      	bls.n	8014426 <tcp_slowtmr+0x3ee>
      ++pcb_remove;
 801441e:	7bfb      	ldrb	r3, [r7, #15]
 8014420:	f103 0301 	add.w	r3, r3, #1
 8014424:	73fb      	strb	r3, [r7, #15]
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8014426:	7bfb      	ldrb	r3, [r7, #15]
 8014428:	2b00      	cmp	r3, #0
 801442a:	d01a      	beq.n	8014462 <tcp_slowtmr+0x42a>
      tcp_pcb_purge(pcb);      
 801442c:	6978      	ldr	r0, [r7, #20]
 801442e:	f000 fa7d 	bl	801492c <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 8014432:	693b      	ldr	r3, [r7, #16]
 8014434:	2b00      	cmp	r3, #0
 8014436:	d004      	beq.n	8014442 <tcp_slowtmr+0x40a>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
 8014438:	697b      	ldr	r3, [r7, #20]
 801443a:	68da      	ldr	r2, [r3, #12]
 801443c:	693b      	ldr	r3, [r7, #16]
 801443e:	60da      	str	r2, [r3, #12]
 8014440:	e006      	b.n	8014450 <tcp_slowtmr+0x418>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
 8014442:	697b      	ldr	r3, [r7, #20]
 8014444:	68da      	ldr	r2, [r3, #12]
 8014446:	f246 5368 	movw	r3, #25960	; 0x6568
 801444a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801444e:	601a      	str	r2, [r3, #0]
      }
      pcb2 = pcb->next;
 8014450:	697b      	ldr	r3, [r7, #20]
 8014452:	68db      	ldr	r3, [r3, #12]
 8014454:	607b      	str	r3, [r7, #4]
      memp_free(MEMP_TCP_PCB, pcb);
 8014456:	6978      	ldr	r0, [r7, #20]
 8014458:	f7fd fd2e 	bl	8011eb8 <mem_free>
      pcb = pcb2;
 801445c:	687b      	ldr	r3, [r7, #4]
 801445e:	617b      	str	r3, [r7, #20]
 8014460:	e004      	b.n	801446c <tcp_slowtmr+0x434>
    } else {
      prev = pcb;
 8014462:	697b      	ldr	r3, [r7, #20]
 8014464:	613b      	str	r3, [r7, #16]
      pcb = pcb->next;
 8014466:	697b      	ldr	r3, [r7, #20]
 8014468:	68db      	ldr	r3, [r3, #12]
 801446a:	617b      	str	r3, [r7, #20]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 801446c:	697b      	ldr	r3, [r7, #20]
 801446e:	2b00      	cmp	r3, #0
 8014470:	d1c8      	bne.n	8014404 <tcp_slowtmr+0x3cc>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 8014472:	f107 0718 	add.w	r7, r7, #24
 8014476:	46bd      	mov	sp, r7
 8014478:	bdb0      	pop	{r4, r5, r7, pc}
 801447a:	bf00      	nop

0801447c <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 801447c:	b590      	push	{r4, r7, lr}
 801447e:	b083      	sub	sp, #12
 8014480:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8014482:	f246 5354 	movw	r3, #25940	; 0x6554
 8014486:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801448a:	681b      	ldr	r3, [r3, #0]
 801448c:	607b      	str	r3, [r7, #4]
 801448e:	e04b      	b.n	8014528 <tcp_fasttmr+0xac>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 8014490:	687b      	ldr	r3, [r7, #4]
 8014492:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014494:	2b00      	cmp	r3, #0
 8014496:	d028      	beq.n	80144ea <tcp_fasttmr+0x6e>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
 8014498:	687b      	ldr	r3, [r7, #4]
 801449a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801449e:	2b00      	cmp	r3, #0
 80144a0:	d00f      	beq.n	80144c2 <tcp_fasttmr+0x46>
 80144a2:	687b      	ldr	r3, [r7, #4]
 80144a4:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 80144a8:	687b      	ldr	r3, [r7, #4]
 80144aa:	695a      	ldr	r2, [r3, #20]
 80144ac:	687b      	ldr	r3, [r7, #4]
 80144ae:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80144b0:	4610      	mov	r0, r2
 80144b2:	6879      	ldr	r1, [r7, #4]
 80144b4:	461a      	mov	r2, r3
 80144b6:	f04f 0300 	mov.w	r3, #0
 80144ba:	47a0      	blx	r4
 80144bc:	4603      	mov	r3, r0
 80144be:	70fb      	strb	r3, [r7, #3]
 80144c0:	e00b      	b.n	80144da <tcp_fasttmr+0x5e>
 80144c2:	687b      	ldr	r3, [r7, #4]
 80144c4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80144c6:	f04f 0000 	mov.w	r0, #0
 80144ca:	6879      	ldr	r1, [r7, #4]
 80144cc:	461a      	mov	r2, r3
 80144ce:	f04f 0300 	mov.w	r3, #0
 80144d2:	f000 f87b 	bl	80145cc <tcp_recv_null>
 80144d6:	4603      	mov	r3, r0
 80144d8:	70fb      	strb	r3, [r7, #3]
      if (err == ERR_OK) {
 80144da:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80144de:	2b00      	cmp	r3, #0
 80144e0:	d103      	bne.n	80144ea <tcp_fasttmr+0x6e>
        pcb->refused_data = NULL;
 80144e2:	687b      	ldr	r3, [r7, #4]
 80144e4:	f04f 0200 	mov.w	r2, #0
 80144e8:	67da      	str	r2, [r3, #124]	; 0x7c
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
 80144ea:	687b      	ldr	r3, [r7, #4]
 80144ec:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80144f0:	f003 0301 	and.w	r3, r3, #1
 80144f4:	2b00      	cmp	r3, #0
 80144f6:	d014      	beq.n	8014522 <tcp_fasttmr+0xa6>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
 80144f8:	687b      	ldr	r3, [r7, #4]
 80144fa:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80144fe:	f043 0302 	orr.w	r3, r3, #2
 8014502:	b2da      	uxtb	r2, r3
 8014504:	687b      	ldr	r3, [r7, #4]
 8014506:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 801450a:	6878      	ldr	r0, [r7, #4]
 801450c:	f002 feac 	bl	8017268 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8014510:	687b      	ldr	r3, [r7, #4]
 8014512:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8014516:	f023 0303 	bic.w	r3, r3, #3
 801451a:	b2da      	uxtb	r2, r3
 801451c:	687b      	ldr	r3, [r7, #4]
 801451e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8014522:	687b      	ldr	r3, [r7, #4]
 8014524:	68db      	ldr	r3, [r3, #12]
 8014526:	607b      	str	r3, [r7, #4]
 8014528:	687b      	ldr	r3, [r7, #4]
 801452a:	2b00      	cmp	r3, #0
 801452c:	d1b0      	bne.n	8014490 <tcp_fasttmr+0x14>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
 801452e:	f107 070c 	add.w	r7, r7, #12
 8014532:	46bd      	mov	sp, r7
 8014534:	bd90      	pop	{r4, r7, pc}
 8014536:	bf00      	nop

08014538 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
 8014538:	b580      	push	{r7, lr}
 801453a:	b084      	sub	sp, #16
 801453c:	af00      	add	r7, sp, #0
 801453e:	6078      	str	r0, [r7, #4]
  u8_t count = 0;
 8014540:	f04f 0300 	mov.w	r3, #0
 8014544:	73fb      	strb	r3, [r7, #15]
  struct tcp_seg *next;
  while (seg != NULL) {
 8014546:	e00c      	b.n	8014562 <tcp_segs_free+0x2a>
    next = seg->next;
 8014548:	687b      	ldr	r3, [r7, #4]
 801454a:	681b      	ldr	r3, [r3, #0]
 801454c:	60bb      	str	r3, [r7, #8]
    count += tcp_seg_free(seg);
 801454e:	6878      	ldr	r0, [r7, #4]
 8014550:	f000 f810 	bl	8014574 <tcp_seg_free>
 8014554:	4603      	mov	r3, r0
 8014556:	461a      	mov	r2, r3
 8014558:	7bfb      	ldrb	r3, [r7, #15]
 801455a:	18d3      	adds	r3, r2, r3
 801455c:	73fb      	strb	r3, [r7, #15]
    seg = next;
 801455e:	68bb      	ldr	r3, [r7, #8]
 8014560:	607b      	str	r3, [r7, #4]
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
 8014562:	687b      	ldr	r3, [r7, #4]
 8014564:	2b00      	cmp	r3, #0
 8014566:	d1ef      	bne.n	8014548 <tcp_segs_free+0x10>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
 8014568:	7bfb      	ldrb	r3, [r7, #15]
}
 801456a:	4618      	mov	r0, r3
 801456c:	f107 0710 	add.w	r7, r7, #16
 8014570:	46bd      	mov	sp, r7
 8014572:	bd80      	pop	{r7, pc}

08014574 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
 8014574:	b580      	push	{r7, lr}
 8014576:	b084      	sub	sp, #16
 8014578:	af00      	add	r7, sp, #0
 801457a:	6078      	str	r0, [r7, #4]
  u8_t count = 0;
 801457c:	f04f 0300 	mov.w	r3, #0
 8014580:	73fb      	strb	r3, [r7, #15]
  
  if (seg != NULL) {
 8014582:	687b      	ldr	r3, [r7, #4]
 8014584:	2b00      	cmp	r3, #0
 8014586:	d00d      	beq.n	80145a4 <tcp_seg_free+0x30>
    if (seg->p != NULL) {
 8014588:	687b      	ldr	r3, [r7, #4]
 801458a:	685b      	ldr	r3, [r3, #4]
 801458c:	2b00      	cmp	r3, #0
 801458e:	d006      	beq.n	801459e <tcp_seg_free+0x2a>
      count = pbuf_free(seg->p);
 8014590:	687b      	ldr	r3, [r7, #4]
 8014592:	685b      	ldr	r3, [r3, #4]
 8014594:	4618      	mov	r0, r3
 8014596:	f7fe fc93 	bl	8012ec0 <pbuf_free>
 801459a:	4603      	mov	r3, r0
 801459c:	73fb      	strb	r3, [r7, #15]
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 801459e:	6878      	ldr	r0, [r7, #4]
 80145a0:	f7fd fc8a 	bl	8011eb8 <mem_free>
  }
  return count;
 80145a4:	7bfb      	ldrb	r3, [r7, #15]
}
 80145a6:	4618      	mov	r0, r3
 80145a8:	f107 0710 	add.w	r7, r7, #16
 80145ac:	46bd      	mov	sp, r7
 80145ae:	bd80      	pop	{r7, pc}

080145b0 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
 80145b0:	b480      	push	{r7}
 80145b2:	b083      	sub	sp, #12
 80145b4:	af00      	add	r7, sp, #0
 80145b6:	6078      	str	r0, [r7, #4]
 80145b8:	460b      	mov	r3, r1
 80145ba:	70fb      	strb	r3, [r7, #3]
  pcb->prio = prio;
 80145bc:	687b      	ldr	r3, [r7, #4]
 80145be:	78fa      	ldrb	r2, [r7, #3]
 80145c0:	745a      	strb	r2, [r3, #17]
}
 80145c2:	f107 070c 	add.w	r7, r7, #12
 80145c6:	46bd      	mov	sp, r7
 80145c8:	bc80      	pop	{r7}
 80145ca:	4770      	bx	lr

080145cc <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 80145cc:	b580      	push	{r7, lr}
 80145ce:	b084      	sub	sp, #16
 80145d0:	af00      	add	r7, sp, #0
 80145d2:	60f8      	str	r0, [r7, #12]
 80145d4:	60b9      	str	r1, [r7, #8]
 80145d6:	607a      	str	r2, [r7, #4]
 80145d8:	70fb      	strb	r3, [r7, #3]
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
 80145da:	687b      	ldr	r3, [r7, #4]
 80145dc:	2b00      	cmp	r3, #0
 80145de:	d009      	beq.n	80145f4 <tcp_recv_null+0x28>
    tcp_recved(pcb, p->tot_len);
 80145e0:	687b      	ldr	r3, [r7, #4]
 80145e2:	891b      	ldrh	r3, [r3, #8]
 80145e4:	68b8      	ldr	r0, [r7, #8]
 80145e6:	4619      	mov	r1, r3
 80145e8:	f7ff fb98 	bl	8013d1c <tcp_recved>
    pbuf_free(p);
 80145ec:	6878      	ldr	r0, [r7, #4]
 80145ee:	f7fe fc67 	bl	8012ec0 <pbuf_free>
 80145f2:	e008      	b.n	8014606 <tcp_recv_null+0x3a>
  } else if (err == ERR_OK) {
 80145f4:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80145f8:	2b00      	cmp	r3, #0
 80145fa:	d104      	bne.n	8014606 <tcp_recv_null+0x3a>
    return tcp_close(pcb);
 80145fc:	68b8      	ldr	r0, [r7, #8]
 80145fe:	f7ff f86f 	bl	80136e0 <tcp_close>
 8014602:	4603      	mov	r3, r0
 8014604:	e001      	b.n	801460a <tcp_recv_null+0x3e>
  }
  return ERR_OK;
 8014606:	f04f 0300 	mov.w	r3, #0
 801460a:	b25b      	sxtb	r3, r3
}
 801460c:	4618      	mov	r0, r3
 801460e:	f107 0710 	add.w	r7, r7, #16
 8014612:	46bd      	mov	sp, r7
 8014614:	bd80      	pop	{r7, pc}
 8014616:	bf00      	nop

08014618 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 8014618:	b580      	push	{r7, lr}
 801461a:	b086      	sub	sp, #24
 801461c:	af00      	add	r7, sp, #0
 801461e:	4603      	mov	r3, r0
 8014620:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
 8014622:	f04f 037f 	mov.w	r3, #127	; 0x7f
 8014626:	72fb      	strb	r3, [r7, #11]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
 8014628:	f04f 0300 	mov.w	r3, #0
 801462c:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 801462e:	f04f 0300 	mov.w	r3, #0
 8014632:	613b      	str	r3, [r7, #16]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8014634:	f246 5354 	movw	r3, #25940	; 0x6554
 8014638:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801463c:	681b      	ldr	r3, [r3, #0]
 801463e:	617b      	str	r3, [r7, #20]
 8014640:	e025      	b.n	801468e <tcp_kill_prio+0x76>
    if (pcb->prio <= prio &&
 8014642:	697b      	ldr	r3, [r7, #20]
 8014644:	7c5b      	ldrb	r3, [r3, #17]
 8014646:	79fa      	ldrb	r2, [r7, #7]
 8014648:	429a      	cmp	r2, r3
 801464a:	d31d      	bcc.n	8014688 <tcp_kill_prio+0x70>
       pcb->prio <= mprio &&
 801464c:	697b      	ldr	r3, [r7, #20]
 801464e:	7c5b      	ldrb	r3, [r3, #17]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
 8014650:	7afa      	ldrb	r2, [r7, #11]
 8014652:	429a      	cmp	r2, r3
 8014654:	d318      	bcc.n	8014688 <tcp_kill_prio+0x70>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8014656:	f246 5358 	movw	r3, #25944	; 0x6558
 801465a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801465e:	681a      	ldr	r2, [r3, #0]
 8014660:	697b      	ldr	r3, [r7, #20]
 8014662:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014664:	1ad2      	subs	r2, r2, r3
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
 8014666:	68fb      	ldr	r3, [r7, #12]
 8014668:	429a      	cmp	r2, r3
 801466a:	d30d      	bcc.n	8014688 <tcp_kill_prio+0x70>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
 801466c:	f246 5358 	movw	r3, #25944	; 0x6558
 8014670:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014674:	681a      	ldr	r2, [r3, #0]
 8014676:	697b      	ldr	r3, [r7, #20]
 8014678:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801467a:	1ad3      	subs	r3, r2, r3
 801467c:	60fb      	str	r3, [r7, #12]
      inactive = pcb;
 801467e:	697b      	ldr	r3, [r7, #20]
 8014680:	613b      	str	r3, [r7, #16]
      mprio = pcb->prio;
 8014682:	697b      	ldr	r3, [r7, #20]
 8014684:	7c5b      	ldrb	r3, [r3, #17]
 8014686:	72fb      	strb	r3, [r7, #11]
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8014688:	697b      	ldr	r3, [r7, #20]
 801468a:	68db      	ldr	r3, [r3, #12]
 801468c:	617b      	str	r3, [r7, #20]
 801468e:	697b      	ldr	r3, [r7, #20]
 8014690:	2b00      	cmp	r3, #0
 8014692:	d1d6      	bne.n	8014642 <tcp_kill_prio+0x2a>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
 8014694:	693b      	ldr	r3, [r7, #16]
 8014696:	2b00      	cmp	r3, #0
 8014698:	d004      	beq.n	80146a4 <tcp_kill_prio+0x8c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 801469a:	6938      	ldr	r0, [r7, #16]
 801469c:	f04f 0101 	mov.w	r1, #1
 80146a0:	f7ff f8fa 	bl	8013898 <tcp_abandon>
  }      
}
 80146a4:	f107 0718 	add.w	r7, r7, #24
 80146a8:	46bd      	mov	sp, r7
 80146aa:	bd80      	pop	{r7, pc}

080146ac <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 80146ac:	b580      	push	{r7, lr}
 80146ae:	b084      	sub	sp, #16
 80146b0:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 80146b2:	f04f 0300 	mov.w	r3, #0
 80146b6:	607b      	str	r3, [r7, #4]
  inactive = NULL;
 80146b8:	f04f 0300 	mov.w	r3, #0
 80146bc:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80146be:	f246 5368 	movw	r3, #25960	; 0x6568
 80146c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80146c6:	681b      	ldr	r3, [r3, #0]
 80146c8:	60fb      	str	r3, [r7, #12]
 80146ca:	e018      	b.n	80146fe <tcp_kill_timewait+0x52>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80146cc:	f246 5358 	movw	r3, #25944	; 0x6558
 80146d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80146d4:	681a      	ldr	r2, [r3, #0]
 80146d6:	68fb      	ldr	r3, [r7, #12]
 80146d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80146da:	1ad2      	subs	r2, r2, r3
 80146dc:	687b      	ldr	r3, [r7, #4]
 80146de:	429a      	cmp	r2, r3
 80146e0:	d30a      	bcc.n	80146f8 <tcp_kill_timewait+0x4c>
      inactivity = tcp_ticks - pcb->tmr;
 80146e2:	f246 5358 	movw	r3, #25944	; 0x6558
 80146e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80146ea:	681a      	ldr	r2, [r3, #0]
 80146ec:	68fb      	ldr	r3, [r7, #12]
 80146ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80146f0:	1ad3      	subs	r3, r2, r3
 80146f2:	607b      	str	r3, [r7, #4]
      inactive = pcb;
 80146f4:	68fb      	ldr	r3, [r7, #12]
 80146f6:	60bb      	str	r3, [r7, #8]
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 80146f8:	68fb      	ldr	r3, [r7, #12]
 80146fa:	68db      	ldr	r3, [r3, #12]
 80146fc:	60fb      	str	r3, [r7, #12]
 80146fe:	68fb      	ldr	r3, [r7, #12]
 8014700:	2b00      	cmp	r3, #0
 8014702:	d1e3      	bne.n	80146cc <tcp_kill_timewait+0x20>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
 8014704:	68bb      	ldr	r3, [r7, #8]
 8014706:	2b00      	cmp	r3, #0
 8014708:	d004      	beq.n	8014714 <tcp_kill_timewait+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 801470a:	68b8      	ldr	r0, [r7, #8]
 801470c:	f04f 0101 	mov.w	r1, #1
 8014710:	f7ff f8c2 	bl	8013898 <tcp_abandon>
  }      
}
 8014714:	f107 0710 	add.w	r7, r7, #16
 8014718:	46bd      	mov	sp, r7
 801471a:	bd80      	pop	{r7, pc}

0801471c <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 801471c:	b580      	push	{r7, lr}
 801471e:	b084      	sub	sp, #16
 8014720:	af00      	add	r7, sp, #0
 8014722:	4603      	mov	r3, r0
 8014724:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
 8014726:	f246 73d4 	movw	r3, #26580	; 0x67d4
 801472a:	f6c0 0302 	movt	r3, #2050	; 0x802
 801472e:	889b      	ldrh	r3, [r3, #4]
 8014730:	4618      	mov	r0, r3
 8014732:	f7fd fced 	bl	8012110 <mem_malloc>
 8014736:	60f8      	str	r0, [r7, #12]
  if (pcb == NULL) {
 8014738:	68fb      	ldr	r3, [r7, #12]
 801473a:	2b00      	cmp	r3, #0
 801473c:	d11a      	bne.n	8014774 <tcp_alloc+0x58>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 801473e:	f7ff ffb5 	bl	80146ac <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
 8014742:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8014746:	f6c0 0302 	movt	r3, #2050	; 0x802
 801474a:	889b      	ldrh	r3, [r3, #4]
 801474c:	4618      	mov	r0, r3
 801474e:	f7fd fcdf 	bl	8012110 <mem_malloc>
 8014752:	60f8      	str	r0, [r7, #12]
    if (pcb == NULL) {
 8014754:	68fb      	ldr	r3, [r7, #12]
 8014756:	2b00      	cmp	r3, #0
 8014758:	d10c      	bne.n	8014774 <tcp_alloc+0x58>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
 801475a:	79fb      	ldrb	r3, [r7, #7]
 801475c:	4618      	mov	r0, r3
 801475e:	f7ff ff5b 	bl	8014618 <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
 8014762:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8014766:	f6c0 0302 	movt	r3, #2050	; 0x802
 801476a:	889b      	ldrh	r3, [r3, #4]
 801476c:	4618      	mov	r0, r3
 801476e:	f7fd fccf 	bl	8012110 <mem_malloc>
 8014772:	60f8      	str	r0, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 8014774:	68fb      	ldr	r3, [r7, #12]
 8014776:	2b00      	cmp	r3, #0
 8014778:	d06e      	beq.n	8014858 <tcp_alloc+0x13c>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 801477a:	68f8      	ldr	r0, [r7, #12]
 801477c:	f04f 0100 	mov.w	r1, #0
 8014780:	f04f 02a0 	mov.w	r2, #160	; 0xa0
 8014784:	f00f f8b4 	bl	80238f0 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
 8014788:	68fb      	ldr	r3, [r7, #12]
 801478a:	f04f 0240 	mov.w	r2, #64	; 0x40
 801478e:	745a      	strb	r2, [r3, #17]
    pcb->snd_buf = TCP_SND_BUF;
 8014790:	68fb      	ldr	r3, [r7, #12]
 8014792:	f640 324c 	movw	r2, #2892	; 0xb4c
 8014796:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
    pcb->snd_queuelen = 0;
 801479a:	68fb      	ldr	r3, [r7, #12]
 801479c:	f04f 0200 	mov.w	r2, #0
 80147a0:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
    pcb->rcv_wnd = TCP_WND;
 80147a4:	68fb      	ldr	r3, [r7, #12]
 80147a6:	f640 324c 	movw	r2, #2892	; 0xb4c
 80147aa:	851a      	strh	r2, [r3, #40]	; 0x28
    pcb->rcv_ann_wnd = TCP_WND;
 80147ac:	68fb      	ldr	r3, [r7, #12]
 80147ae:	f640 324c 	movw	r2, #2892	; 0xb4c
 80147b2:	855a      	strh	r2, [r3, #42]	; 0x2a
    pcb->tos = 0;
 80147b4:	68fb      	ldr	r3, [r7, #12]
 80147b6:	f04f 0200 	mov.w	r2, #0
 80147ba:	729a      	strb	r2, [r3, #10]
    pcb->ttl = TCP_TTL;
 80147bc:	68fb      	ldr	r3, [r7, #12]
 80147be:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80147c2:	72da      	strb	r2, [r3, #11]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 80147c4:	68fb      	ldr	r3, [r7, #12]
 80147c6:	f44f 7206 	mov.w	r2, #536	; 0x218
 80147ca:	871a      	strh	r2, [r3, #56]	; 0x38
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 80147cc:	68fb      	ldr	r3, [r7, #12]
 80147ce:	f04f 0206 	mov.w	r2, #6
 80147d2:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
    pcb->sa = 0;
 80147d6:	68fb      	ldr	r3, [r7, #12]
 80147d8:	f04f 0200 	mov.w	r2, #0
 80147dc:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 80147e0:	68fb      	ldr	r3, [r7, #12]
 80147e2:	f04f 0206 	mov.w	r2, #6
 80147e6:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
    pcb->rtime = -1;
 80147ea:	68fb      	ldr	r3, [r7, #12]
 80147ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80147f0:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->cwnd = 1;
 80147f2:	68fb      	ldr	r3, [r7, #12]
 80147f4:	f04f 0201 	mov.w	r2, #1
 80147f8:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    iss = tcp_next_iss();
 80147fc:	f000 f934 	bl	8014a68 <tcp_next_iss>
 8014800:	60b8      	str	r0, [r7, #8]
    pcb->snd_wl2 = iss;
 8014802:	68fb      	ldr	r3, [r7, #12]
 8014804:	68ba      	ldr	r2, [r7, #8]
 8014806:	665a      	str	r2, [r3, #100]	; 0x64
    pcb->snd_nxt = iss;
 8014808:	68fb      	ldr	r3, [r7, #12]
 801480a:	68ba      	ldr	r2, [r7, #8]
 801480c:	659a      	str	r2, [r3, #88]	; 0x58
    pcb->lastack = iss;
 801480e:	68fb      	ldr	r3, [r7, #12]
 8014810:	68ba      	ldr	r2, [r7, #8]
 8014812:	64da      	str	r2, [r3, #76]	; 0x4c
    pcb->snd_lbb = iss;   
 8014814:	68fb      	ldr	r3, [r7, #12]
 8014816:	68ba      	ldr	r2, [r7, #8]
 8014818:	669a      	str	r2, [r3, #104]	; 0x68
    pcb->tmr = tcp_ticks;
 801481a:	f246 5358 	movw	r3, #25944	; 0x6558
 801481e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014822:	681a      	ldr	r2, [r3, #0]
 8014824:	68fb      	ldr	r3, [r7, #12]
 8014826:	631a      	str	r2, [r3, #48]	; 0x30

    pcb->polltmr = 0;
 8014828:	68fb      	ldr	r3, [r7, #12]
 801482a:	f04f 0200 	mov.w	r2, #0
 801482e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 8014832:	68fa      	ldr	r2, [r7, #12]
 8014834:	f244 53cd 	movw	r3, #17869	; 0x45cd
 8014838:	f6c0 0301 	movt	r3, #2049	; 0x801
 801483c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 8014840:	68fa      	ldr	r2, [r7, #12]
 8014842:	f44f 435d 	mov.w	r3, #56576	; 0xdd00
 8014846:	f2c0 036d 	movt	r3, #109	; 0x6d
 801484a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 801484e:	68fb      	ldr	r3, [r7, #12]
 8014850:	f04f 0200 	mov.w	r2, #0
 8014854:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d
  }
  return pcb;
 8014858:	68fb      	ldr	r3, [r7, #12]
}
 801485a:	4618      	mov	r0, r3
 801485c:	f107 0710 	add.w	r7, r7, #16
 8014860:	46bd      	mov	sp, r7
 8014862:	bd80      	pop	{r7, pc}

08014864 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 8014864:	b580      	push	{r7, lr}
 8014866:	af00      	add	r7, sp, #0
  return tcp_alloc(TCP_PRIO_NORMAL);
 8014868:	f04f 0040 	mov.w	r0, #64	; 0x40
 801486c:	f7ff ff56 	bl	801471c <tcp_alloc>
 8014870:	4603      	mov	r3, r0
}
 8014872:	4618      	mov	r0, r3
 8014874:	bd80      	pop	{r7, pc}
 8014876:	bf00      	nop

08014878 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
 8014878:	b480      	push	{r7}
 801487a:	b083      	sub	sp, #12
 801487c:	af00      	add	r7, sp, #0
 801487e:	6078      	str	r0, [r7, #4]
 8014880:	6039      	str	r1, [r7, #0]
  pcb->callback_arg = arg;
 8014882:	687b      	ldr	r3, [r7, #4]
 8014884:	683a      	ldr	r2, [r7, #0]
 8014886:	615a      	str	r2, [r3, #20]
}
 8014888:	f107 070c 	add.w	r7, r7, #12
 801488c:	46bd      	mov	sp, r7
 801488e:	bc80      	pop	{r7}
 8014890:	4770      	bx	lr
 8014892:	bf00      	nop

08014894 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
 8014894:	b480      	push	{r7}
 8014896:	b083      	sub	sp, #12
 8014898:	af00      	add	r7, sp, #0
 801489a:	6078      	str	r0, [r7, #4]
 801489c:	6039      	str	r1, [r7, #0]
  pcb->recv = recv;
 801489e:	687b      	ldr	r3, [r7, #4]
 80148a0:	683a      	ldr	r2, [r7, #0]
 80148a2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 80148a6:	f107 070c 	add.w	r7, r7, #12
 80148aa:	46bd      	mov	sp, r7
 80148ac:	bc80      	pop	{r7}
 80148ae:	4770      	bx	lr

080148b0 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
 80148b0:	b480      	push	{r7}
 80148b2:	b083      	sub	sp, #12
 80148b4:	af00      	add	r7, sp, #0
 80148b6:	6078      	str	r0, [r7, #4]
 80148b8:	6039      	str	r1, [r7, #0]
  pcb->sent = sent;
 80148ba:	687b      	ldr	r3, [r7, #4]
 80148bc:	683a      	ldr	r2, [r7, #0]
 80148be:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 80148c2:	f107 070c 	add.w	r7, r7, #12
 80148c6:	46bd      	mov	sp, r7
 80148c8:	bc80      	pop	{r7}
 80148ca:	4770      	bx	lr

080148cc <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
 80148cc:	b480      	push	{r7}
 80148ce:	b083      	sub	sp, #12
 80148d0:	af00      	add	r7, sp, #0
 80148d2:	6078      	str	r0, [r7, #4]
 80148d4:	6039      	str	r1, [r7, #0]
  pcb->errf = errf;
 80148d6:	687b      	ldr	r3, [r7, #4]
 80148d8:	683a      	ldr	r2, [r7, #0]
 80148da:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
 80148de:	f107 070c 	add.w	r7, r7, #12
 80148e2:	46bd      	mov	sp, r7
 80148e4:	bc80      	pop	{r7}
 80148e6:	4770      	bx	lr

080148e8 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
 80148e8:	b480      	push	{r7}
 80148ea:	b083      	sub	sp, #12
 80148ec:	af00      	add	r7, sp, #0
 80148ee:	6078      	str	r0, [r7, #4]
 80148f0:	6039      	str	r1, [r7, #0]
  pcb->accept = accept;
 80148f2:	687b      	ldr	r3, [r7, #4]
 80148f4:	683a      	ldr	r2, [r7, #0]
 80148f6:	61da      	str	r2, [r3, #28]
}
 80148f8:	f107 070c 	add.w	r7, r7, #12
 80148fc:	46bd      	mov	sp, r7
 80148fe:	bc80      	pop	{r7}
 8014900:	4770      	bx	lr
 8014902:	bf00      	nop

08014904 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
 8014904:	b480      	push	{r7}
 8014906:	b085      	sub	sp, #20
 8014908:	af00      	add	r7, sp, #0
 801490a:	60f8      	str	r0, [r7, #12]
 801490c:	60b9      	str	r1, [r7, #8]
 801490e:	4613      	mov	r3, r2
 8014910:	71fb      	strb	r3, [r7, #7]
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 8014912:	68fb      	ldr	r3, [r7, #12]
 8014914:	68ba      	ldr	r2, [r7, #8]
 8014916:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 801491a:	68fb      	ldr	r3, [r7, #12]
 801491c:	79fa      	ldrb	r2, [r7, #7]
 801491e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
}
 8014922:	f107 0714 	add.w	r7, r7, #20
 8014926:	46bd      	mov	sp, r7
 8014928:	bc80      	pop	{r7}
 801492a:	4770      	bx	lr

0801492c <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 801492c:	b580      	push	{r7, lr}
 801492e:	b082      	sub	sp, #8
 8014930:	af00      	add	r7, sp, #0
 8014932:	6078      	str	r0, [r7, #4]
  if (pcb->state != CLOSED &&
 8014934:	687b      	ldr	r3, [r7, #4]
 8014936:	7c1b      	ldrb	r3, [r3, #16]
 8014938:	2b00      	cmp	r3, #0
 801493a:	d026      	beq.n	801498a <tcp_pcb_purge+0x5e>
     pcb->state != TIME_WAIT &&
 801493c:	687b      	ldr	r3, [r7, #4]
 801493e:	7c1b      	ldrb	r3, [r3, #16]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8014940:	2b0a      	cmp	r3, #10
 8014942:	d022      	beq.n	801498a <tcp_pcb_purge+0x5e>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
 8014944:	687b      	ldr	r3, [r7, #4]
 8014946:	7c1b      	ldrb	r3, [r3, #16]
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
 8014948:	2b01      	cmp	r3, #1
 801494a:	d01e      	beq.n	801498a <tcp_pcb_purge+0x5e>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 801494c:	687b      	ldr	r3, [r7, #4]
 801494e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014950:	2b00      	cmp	r3, #0
 8014952:	d008      	beq.n	8014966 <tcp_pcb_purge+0x3a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8014954:	687b      	ldr	r3, [r7, #4]
 8014956:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014958:	4618      	mov	r0, r3
 801495a:	f7fe fab1 	bl	8012ec0 <pbuf_free>
      pcb->refused_data = NULL;
 801495e:	687b      	ldr	r3, [r7, #4]
 8014960:	f04f 0200 	mov.w	r2, #0
 8014964:	67da      	str	r2, [r3, #124]	; 0x7c
    pcb->rtime = -1;

    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
 8014966:	687b      	ldr	r3, [r7, #4]
 8014968:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801496a:	4618      	mov	r0, r3
 801496c:	f7ff fde4 	bl	8014538 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 8014970:	687b      	ldr	r3, [r7, #4]
 8014972:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8014974:	4618      	mov	r0, r3
 8014976:	f7ff fddf 	bl	8014538 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 801497a:	687b      	ldr	r3, [r7, #4]
 801497c:	f04f 0200 	mov.w	r2, #0
 8014980:	675a      	str	r2, [r3, #116]	; 0x74
 8014982:	687b      	ldr	r3, [r7, #4]
 8014984:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8014986:	687b      	ldr	r3, [r7, #4]
 8014988:	679a      	str	r2, [r3, #120]	; 0x78
  }
}
 801498a:	f107 0708 	add.w	r7, r7, #8
 801498e:	46bd      	mov	sp, r7
 8014990:	bd80      	pop	{r7, pc}
 8014992:	bf00      	nop

08014994 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8014994:	b580      	push	{r7, lr}
 8014996:	b082      	sub	sp, #8
 8014998:	af00      	add	r7, sp, #0
 801499a:	6078      	str	r0, [r7, #4]
 801499c:	6039      	str	r1, [r7, #0]
  TCP_RMV(pcblist, pcb);
 801499e:	687b      	ldr	r3, [r7, #4]
 80149a0:	681a      	ldr	r2, [r3, #0]
 80149a2:	683b      	ldr	r3, [r7, #0]
 80149a4:	429a      	cmp	r2, r3
 80149a6:	d105      	bne.n	80149b4 <tcp_pcb_remove+0x20>
 80149a8:	687b      	ldr	r3, [r7, #4]
 80149aa:	681b      	ldr	r3, [r3, #0]
 80149ac:	68da      	ldr	r2, [r3, #12]
 80149ae:	687b      	ldr	r3, [r7, #4]
 80149b0:	601a      	str	r2, [r3, #0]
 80149b2:	e02b      	b.n	8014a0c <tcp_pcb_remove+0x78>
 80149b4:	687b      	ldr	r3, [r7, #4]
 80149b6:	681a      	ldr	r2, [r3, #0]
 80149b8:	f246 5360 	movw	r3, #25952	; 0x6560
 80149bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80149c0:	601a      	str	r2, [r3, #0]
 80149c2:	e01c      	b.n	80149fe <tcp_pcb_remove+0x6a>
 80149c4:	f246 5360 	movw	r3, #25952	; 0x6560
 80149c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80149cc:	681b      	ldr	r3, [r3, #0]
 80149ce:	68da      	ldr	r2, [r3, #12]
 80149d0:	683b      	ldr	r3, [r7, #0]
 80149d2:	429a      	cmp	r2, r3
 80149d4:	d108      	bne.n	80149e8 <tcp_pcb_remove+0x54>
 80149d6:	f246 5360 	movw	r3, #25952	; 0x6560
 80149da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80149de:	681b      	ldr	r3, [r3, #0]
 80149e0:	683a      	ldr	r2, [r7, #0]
 80149e2:	68d2      	ldr	r2, [r2, #12]
 80149e4:	60da      	str	r2, [r3, #12]
 80149e6:	e011      	b.n	8014a0c <tcp_pcb_remove+0x78>
 80149e8:	f246 5360 	movw	r3, #25952	; 0x6560
 80149ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80149f0:	681b      	ldr	r3, [r3, #0]
 80149f2:	68da      	ldr	r2, [r3, #12]
 80149f4:	f246 5360 	movw	r3, #25952	; 0x6560
 80149f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80149fc:	601a      	str	r2, [r3, #0]
 80149fe:	f246 5360 	movw	r3, #25952	; 0x6560
 8014a02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014a06:	681b      	ldr	r3, [r3, #0]
 8014a08:	2b00      	cmp	r3, #0
 8014a0a:	d1db      	bne.n	80149c4 <tcp_pcb_remove+0x30>
 8014a0c:	683b      	ldr	r3, [r7, #0]
 8014a0e:	f04f 0200 	mov.w	r2, #0
 8014a12:	60da      	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
 8014a14:	6838      	ldr	r0, [r7, #0]
 8014a16:	f7ff ff89 	bl	801492c <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8014a1a:	683b      	ldr	r3, [r7, #0]
 8014a1c:	7c1b      	ldrb	r3, [r3, #16]
 8014a1e:	2b0a      	cmp	r3, #10
 8014a20:	d016      	beq.n	8014a50 <tcp_pcb_remove+0xbc>
     pcb->state != LISTEN &&
 8014a22:	683b      	ldr	r3, [r7, #0]
 8014a24:	7c1b      	ldrb	r3, [r3, #16]
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8014a26:	2b01      	cmp	r3, #1
 8014a28:	d012      	beq.n	8014a50 <tcp_pcb_remove+0xbc>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8014a2a:	683b      	ldr	r3, [r7, #0]
 8014a2c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8014a30:	f003 0301 	and.w	r3, r3, #1

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
 8014a34:	2b00      	cmp	r3, #0
 8014a36:	d00b      	beq.n	8014a50 <tcp_pcb_remove+0xbc>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
 8014a38:	683b      	ldr	r3, [r7, #0]
 8014a3a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8014a3e:	f043 0302 	orr.w	r3, r3, #2
 8014a42:	b2da      	uxtb	r2, r3
 8014a44:	683b      	ldr	r3, [r7, #0]
 8014a46:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    tcp_output(pcb);
 8014a4a:	6838      	ldr	r0, [r7, #0]
 8014a4c:	f002 fc0c 	bl	8017268 <tcp_output>
  }

  if (pcb->state != LISTEN) {
 8014a50:	683b      	ldr	r3, [r7, #0]
 8014a52:	7c1b      	ldrb	r3, [r3, #16]
 8014a54:	2b01      	cmp	r3, #1
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8014a56:	683b      	ldr	r3, [r7, #0]
 8014a58:	f04f 0200 	mov.w	r2, #0
 8014a5c:	741a      	strb	r2, [r3, #16]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 8014a5e:	f107 0708 	add.w	r7, r7, #8
 8014a62:	46bd      	mov	sp, r7
 8014a64:	bd80      	pop	{r7, pc}
 8014a66:	bf00      	nop

08014a68 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
 8014a68:	b480      	push	{r7}
 8014a6a:	af00      	add	r7, sp, #0
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 8014a6c:	f246 7324 	movw	r3, #26404	; 0x6724
 8014a70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014a74:	681a      	ldr	r2, [r3, #0]
 8014a76:	f246 5358 	movw	r3, #25944	; 0x6558
 8014a7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014a7e:	681b      	ldr	r3, [r3, #0]
 8014a80:	18d2      	adds	r2, r2, r3
 8014a82:	f246 7324 	movw	r3, #26404	; 0x6724
 8014a86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014a8a:	601a      	str	r2, [r3, #0]
  return iss;
 8014a8c:	f246 7324 	movw	r3, #26404	; 0x6724
 8014a90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014a94:	681b      	ldr	r3, [r3, #0]
}
 8014a96:	4618      	mov	r0, r3
 8014a98:	46bd      	mov	sp, r7
 8014a9a:	bc80      	pop	{r7}
 8014a9c:	4770      	bx	lr
 8014a9e:	bf00      	nop

08014aa0 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
 8014aa0:	b580      	push	{r7, lr}
 8014aa2:	b084      	sub	sp, #16
 8014aa4:	af00      	add	r7, sp, #0
 8014aa6:	4603      	mov	r3, r0
 8014aa8:	6039      	str	r1, [r7, #0]
 8014aaa:	80fb      	strh	r3, [r7, #6]
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 8014aac:	6838      	ldr	r0, [r7, #0]
 8014aae:	f004 fd1b 	bl	80194e8 <ip_route>
 8014ab2:	60f8      	str	r0, [r7, #12]
  if ((outif != NULL) && (outif->mtu != 0)) {
 8014ab4:	68fb      	ldr	r3, [r7, #12]
 8014ab6:	2b00      	cmp	r3, #0
 8014ab8:	d00e      	beq.n	8014ad8 <tcp_eff_send_mss+0x38>
 8014aba:	68fb      	ldr	r3, [r7, #12]
 8014abc:	8c1b      	ldrh	r3, [r3, #32]
 8014abe:	2b00      	cmp	r3, #0
 8014ac0:	d00a      	beq.n	8014ad8 <tcp_eff_send_mss+0x38>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 8014ac2:	68fb      	ldr	r3, [r7, #12]
 8014ac4:	8c1b      	ldrh	r3, [r3, #32]
 8014ac6:	f1a3 0328 	sub.w	r3, r3, #40	; 0x28
 8014aca:	817b      	strh	r3, [r7, #10]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_enqueue(), and don't support
     * IP options
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 8014acc:	897a      	ldrh	r2, [r7, #10]
 8014ace:	88fb      	ldrh	r3, [r7, #6]
 8014ad0:	429a      	cmp	r2, r3
 8014ad2:	bf38      	it	cc
 8014ad4:	4613      	movcc	r3, r2
 8014ad6:	80fb      	strh	r3, [r7, #6]
  }
  return sendmss;
 8014ad8:	88fb      	ldrh	r3, [r7, #6]
}
 8014ada:	4618      	mov	r0, r3
 8014adc:	f107 0710 	add.w	r7, r7, #16
 8014ae0:	46bd      	mov	sp, r7
 8014ae2:	bd80      	pop	{r7, pc}

08014ae4 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
 8014ae4:	b480      	push	{r7}
 8014ae6:	b083      	sub	sp, #12
 8014ae8:	af00      	add	r7, sp, #0
 8014aea:	4603      	mov	r3, r0
 8014aec:	71fb      	strb	r3, [r7, #7]
  return tcp_state_str[s];
 8014aee:	79fa      	ldrb	r2, [r7, #7]
 8014af0:	f246 63f8 	movw	r3, #26360	; 0x66f8
 8014af4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014af8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
}
 8014afc:	4618      	mov	r0, r3
 8014afe:	f107 070c 	add.w	r7, r7, #12
 8014b02:	46bd      	mov	sp, r7
 8014b04:	bc80      	pop	{r7}
 8014b06:	4770      	bx	lr

08014b08 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8014b08:	b5b0      	push	{r4, r5, r7, lr}
 8014b0a:	b088      	sub	sp, #32
 8014b0c:	af02      	add	r7, sp, #8
 8014b0e:	6078      	str	r0, [r7, #4]
 8014b10:	6039      	str	r1, [r7, #0]
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
 8014b12:	687b      	ldr	r3, [r7, #4]
 8014b14:	685a      	ldr	r2, [r3, #4]
 8014b16:	f245 5374 	movw	r3, #21876	; 0x5574
 8014b1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b1e:	601a      	str	r2, [r3, #0]
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8014b20:	687b      	ldr	r3, [r7, #4]
 8014b22:	685c      	ldr	r4, [r3, #4]
 8014b24:	f245 5374 	movw	r3, #21876	; 0x5574
 8014b28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b2c:	681b      	ldr	r3, [r3, #0]
 8014b2e:	881b      	ldrh	r3, [r3, #0]
 8014b30:	b29b      	uxth	r3, r3
 8014b32:	4618      	mov	r0, r3
 8014b34:	f004 fb28 	bl	8019188 <ntohs>
 8014b38:	4603      	mov	r3, r0
 8014b3a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8014b3e:	b29b      	uxth	r3, r3
 8014b40:	f003 030f 	and.w	r3, r3, #15
 8014b44:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014b48:	18e2      	adds	r2, r4, r3
 8014b4a:	f245 5370 	movw	r3, #21872	; 0x5570
 8014b4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b52:	601a      	str	r2, [r3, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8014b54:	f245 5374 	movw	r3, #21876	; 0x5574
 8014b58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014b5c:	681b      	ldr	r3, [r3, #0]
 8014b5e:	881b      	ldrh	r3, [r3, #0]
 8014b60:	b29b      	uxth	r3, r3
 8014b62:	4618      	mov	r0, r3
 8014b64:	f004 fb10 	bl	8019188 <ntohs>
 8014b68:	4603      	mov	r3, r0
 8014b6a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8014b6e:	b29b      	uxth	r3, r3
 8014b70:	f003 030f 	and.w	r3, r3, #15
 8014b74:	b29b      	uxth	r3, r3
 8014b76:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014b7a:	b29b      	uxth	r3, r3
 8014b7c:	f1c3 0300 	rsb	r3, r3, #0
 8014b80:	b29b      	uxth	r3, r3
 8014b82:	b29b      	uxth	r3, r3
 8014b84:	b21b      	sxth	r3, r3
 8014b86:	6878      	ldr	r0, [r7, #4]
 8014b88:	4619      	mov	r1, r3
 8014b8a:	f7fe f91f 	bl	8012dcc <pbuf_header>
 8014b8e:	4603      	mov	r3, r0
 8014b90:	2b00      	cmp	r3, #0
 8014b92:	d103      	bne.n	8014b9c <tcp_input+0x94>
 8014b94:	687b      	ldr	r3, [r7, #4]
 8014b96:	891b      	ldrh	r3, [r3, #8]
 8014b98:	2b13      	cmp	r3, #19
 8014b9a:	d803      	bhi.n	8014ba4 <tcp_input+0x9c>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
 8014b9c:	6878      	ldr	r0, [r7, #4]
 8014b9e:	f7fe f98f 	bl	8012ec0 <pbuf_free>
    return;
 8014ba2:	e362      	b.n	801526a <tcp_input+0x762>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
 8014ba4:	f245 5374 	movw	r3, #21876	; 0x5574
 8014ba8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014bac:	681b      	ldr	r3, [r3, #0]
 8014bae:	f103 0310 	add.w	r3, r3, #16
 8014bb2:	4618      	mov	r0, r3
 8014bb4:	6839      	ldr	r1, [r7, #0]
 8014bb6:	f004 ffbd 	bl	8019b34 <ip_addr_isbroadcast>
 8014bba:	4603      	mov	r3, r0
 8014bbc:	2b00      	cmp	r3, #0
 8014bbe:	d112      	bne.n	8014be6 <tcp_input+0xde>
      ip_addr_ismulticast(&(iphdr->dest))) {
 8014bc0:	f245 5374 	movw	r3, #21876	; 0x5574
 8014bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014bc8:	681b      	ldr	r3, [r3, #0]
 8014bca:	691c      	ldr	r4, [r3, #16]
 8014bcc:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8014bd0:	f004 fb08 	bl	80191e4 <ntohl>
 8014bd4:	4603      	mov	r3, r0
 8014bd6:	401c      	ands	r4, r3
 8014bd8:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8014bdc:	f004 fb02 	bl	80191e4 <ntohl>
 8014be0:	4603      	mov	r3, r0
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
 8014be2:	429c      	cmp	r4, r3
 8014be4:	d103      	bne.n	8014bee <tcp_input+0xe6>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
 8014be6:	6878      	ldr	r0, [r7, #4]
 8014be8:	f7fe f96a 	bl	8012ec0 <pbuf_free>
    return;
 8014bec:	e33d      	b.n	801526a <tcp_input+0x762>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
 8014bee:	f245 5370 	movw	r3, #21872	; 0x5570
 8014bf2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014bf6:	681b      	ldr	r3, [r3, #0]
 8014bf8:	899b      	ldrh	r3, [r3, #12]
 8014bfa:	b29b      	uxth	r3, r3
 8014bfc:	4618      	mov	r0, r3
 8014bfe:	f004 fac3 	bl	8019188 <ntohs>
 8014c02:	4603      	mov	r3, r0
 8014c04:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8014c08:	b29b      	uxth	r3, r3
 8014c0a:	72bb      	strb	r3, [r7, #10]
  if(pbuf_header(p, -(hdrlen * 4))){
 8014c0c:	7abb      	ldrb	r3, [r7, #10]
 8014c0e:	b29b      	uxth	r3, r3
 8014c10:	461a      	mov	r2, r3
 8014c12:	ea4f 3282 	mov.w	r2, r2, lsl #14
 8014c16:	1ad3      	subs	r3, r2, r3
 8014c18:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8014c1c:	b29b      	uxth	r3, r3
 8014c1e:	b29b      	uxth	r3, r3
 8014c20:	b21b      	sxth	r3, r3
 8014c22:	6878      	ldr	r0, [r7, #4]
 8014c24:	4619      	mov	r1, r3
 8014c26:	f7fe f8d1 	bl	8012dcc <pbuf_header>
 8014c2a:	4603      	mov	r3, r0
 8014c2c:	2b00      	cmp	r3, #0
 8014c2e:	d003      	beq.n	8014c38 <tcp_input+0x130>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
 8014c30:	6878      	ldr	r0, [r7, #4]
 8014c32:	f7fe f945 	bl	8012ec0 <pbuf_free>
    return;
 8014c36:	e318      	b.n	801526a <tcp_input+0x762>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 8014c38:	f245 5370 	movw	r3, #21872	; 0x5570
 8014c3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014c40:	681c      	ldr	r4, [r3, #0]
 8014c42:	f245 5370 	movw	r3, #21872	; 0x5570
 8014c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014c4a:	681b      	ldr	r3, [r3, #0]
 8014c4c:	881b      	ldrh	r3, [r3, #0]
 8014c4e:	b29b      	uxth	r3, r3
 8014c50:	4618      	mov	r0, r3
 8014c52:	f004 fa99 	bl	8019188 <ntohs>
 8014c56:	4603      	mov	r3, r0
 8014c58:	8023      	strh	r3, [r4, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 8014c5a:	f245 5370 	movw	r3, #21872	; 0x5570
 8014c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014c62:	681c      	ldr	r4, [r3, #0]
 8014c64:	f245 5370 	movw	r3, #21872	; 0x5570
 8014c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014c6c:	681b      	ldr	r3, [r3, #0]
 8014c6e:	885b      	ldrh	r3, [r3, #2]
 8014c70:	b29b      	uxth	r3, r3
 8014c72:	4618      	mov	r0, r3
 8014c74:	f004 fa88 	bl	8019188 <ntohs>
 8014c78:	4603      	mov	r3, r0
 8014c7a:	8063      	strh	r3, [r4, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8014c7c:	f245 5370 	movw	r3, #21872	; 0x5570
 8014c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014c84:	681c      	ldr	r4, [r3, #0]
 8014c86:	f245 5370 	movw	r3, #21872	; 0x5570
 8014c8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014c8e:	681b      	ldr	r3, [r3, #0]
 8014c90:	685b      	ldr	r3, [r3, #4]
 8014c92:	4618      	mov	r0, r3
 8014c94:	f004 faa6 	bl	80191e4 <ntohl>
 8014c98:	4603      	mov	r3, r0
 8014c9a:	6063      	str	r3, [r4, #4]
 8014c9c:	6862      	ldr	r2, [r4, #4]
 8014c9e:	f245 5378 	movw	r3, #21880	; 0x5578
 8014ca2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014ca6:	601a      	str	r2, [r3, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8014ca8:	f245 5370 	movw	r3, #21872	; 0x5570
 8014cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014cb0:	681c      	ldr	r4, [r3, #0]
 8014cb2:	f245 5370 	movw	r3, #21872	; 0x5570
 8014cb6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014cba:	681b      	ldr	r3, [r3, #0]
 8014cbc:	689b      	ldr	r3, [r3, #8]
 8014cbe:	4618      	mov	r0, r3
 8014cc0:	f004 fa90 	bl	80191e4 <ntohl>
 8014cc4:	4603      	mov	r3, r0
 8014cc6:	60a3      	str	r3, [r4, #8]
 8014cc8:	68a2      	ldr	r2, [r4, #8]
 8014cca:	f245 537c 	movw	r3, #21884	; 0x557c
 8014cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014cd2:	601a      	str	r2, [r3, #0]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8014cd4:	f245 5370 	movw	r3, #21872	; 0x5570
 8014cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014cdc:	681c      	ldr	r4, [r3, #0]
 8014cde:	f245 5370 	movw	r3, #21872	; 0x5570
 8014ce2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014ce6:	681b      	ldr	r3, [r3, #0]
 8014ce8:	89db      	ldrh	r3, [r3, #14]
 8014cea:	b29b      	uxth	r3, r3
 8014cec:	4618      	mov	r0, r3
 8014cee:	f004 fa4b 	bl	8019188 <ntohs>
 8014cf2:	4603      	mov	r3, r0
 8014cf4:	81e3      	strh	r3, [r4, #14]

  flags = TCPH_FLAGS(tcphdr);
 8014cf6:	f245 5370 	movw	r3, #21872	; 0x5570
 8014cfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014cfe:	681b      	ldr	r3, [r3, #0]
 8014d00:	899b      	ldrh	r3, [r3, #12]
 8014d02:	b29b      	uxth	r3, r3
 8014d04:	4618      	mov	r0, r3
 8014d06:	f004 fa3f 	bl	8019188 <ntohs>
 8014d0a:	4603      	mov	r3, r0
 8014d0c:	b2db      	uxtb	r3, r3
 8014d0e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8014d12:	b2da      	uxtb	r2, r3
 8014d14:	f245 5380 	movw	r3, #21888	; 0x5580
 8014d18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d1c:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8014d1e:	687b      	ldr	r3, [r7, #4]
 8014d20:	891a      	ldrh	r2, [r3, #8]
 8014d22:	f245 5380 	movw	r3, #21888	; 0x5580
 8014d26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d2a:	781b      	ldrb	r3, [r3, #0]
 8014d2c:	f003 0303 	and.w	r3, r3, #3
 8014d30:	2b00      	cmp	r3, #0
 8014d32:	bf0c      	ite	eq
 8014d34:	2300      	moveq	r3, #0
 8014d36:	2301      	movne	r3, #1
 8014d38:	b2db      	uxtb	r3, r3
 8014d3a:	18d3      	adds	r3, r2, r3
 8014d3c:	b29a      	uxth	r2, r3
 8014d3e:	f245 5382 	movw	r3, #21890	; 0x5582
 8014d42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d46:	801a      	strh	r2, [r3, #0]

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 8014d48:	f04f 0300 	mov.w	r3, #0
 8014d4c:	613b      	str	r3, [r7, #16]

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8014d4e:	f246 5354 	movw	r3, #25940	; 0x6554
 8014d52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d56:	681b      	ldr	r3, [r3, #0]
 8014d58:	617b      	str	r3, [r7, #20]
 8014d5a:	e043      	b.n	8014de4 <tcp_input+0x2dc>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 8014d5c:	697b      	ldr	r3, [r7, #20]
 8014d5e:	8c1a      	ldrh	r2, [r3, #32]
 8014d60:	f245 5370 	movw	r3, #21872	; 0x5570
 8014d64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d68:	681b      	ldr	r3, [r3, #0]
 8014d6a:	881b      	ldrh	r3, [r3, #0]
 8014d6c:	b29b      	uxth	r3, r3
 8014d6e:	429a      	cmp	r2, r3
 8014d70:	d133      	bne.n	8014dda <tcp_input+0x2d2>
       pcb->local_port == tcphdr->dest &&
 8014d72:	697b      	ldr	r3, [r7, #20]
 8014d74:	8b1a      	ldrh	r2, [r3, #24]
 8014d76:	f245 5370 	movw	r3, #21872	; 0x5570
 8014d7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d7e:	681b      	ldr	r3, [r3, #0]
 8014d80:	885b      	ldrh	r3, [r3, #2]
 8014d82:	b29b      	uxth	r3, r3
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 8014d84:	429a      	cmp	r2, r3
 8014d86:	d128      	bne.n	8014dda <tcp_input+0x2d2>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8014d88:	697b      	ldr	r3, [r7, #20]
 8014d8a:	685a      	ldr	r2, [r3, #4]
 8014d8c:	f245 5374 	movw	r3, #21876	; 0x5574
 8014d90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014d94:	681b      	ldr	r3, [r3, #0]
 8014d96:	68db      	ldr	r3, [r3, #12]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
 8014d98:	429a      	cmp	r2, r3
 8014d9a:	d11e      	bne.n	8014dda <tcp_input+0x2d2>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
 8014d9c:	697b      	ldr	r3, [r7, #20]
 8014d9e:	681a      	ldr	r2, [r3, #0]
 8014da0:	f245 5374 	movw	r3, #21876	; 0x5574
 8014da4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014da8:	681b      	ldr	r3, [r3, #0]
 8014daa:	691b      	ldr	r3, [r3, #16]
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8014dac:	429a      	cmp	r2, r3
 8014dae:	d114      	bne.n	8014dda <tcp_input+0x2d2>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
 8014db0:	693b      	ldr	r3, [r7, #16]
 8014db2:	2b00      	cmp	r3, #0
 8014db4:	d01a      	beq.n	8014dec <tcp_input+0x2e4>
        prev->next = pcb->next;
 8014db6:	697b      	ldr	r3, [r7, #20]
 8014db8:	68da      	ldr	r2, [r3, #12]
 8014dba:	693b      	ldr	r3, [r7, #16]
 8014dbc:	60da      	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
 8014dbe:	f246 5354 	movw	r3, #25940	; 0x6554
 8014dc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014dc6:	681a      	ldr	r2, [r3, #0]
 8014dc8:	697b      	ldr	r3, [r7, #20]
 8014dca:	60da      	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
 8014dcc:	f246 5354 	movw	r3, #25940	; 0x6554
 8014dd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014dd4:	697a      	ldr	r2, [r7, #20]
 8014dd6:	601a      	str	r2, [r3, #0]
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 8014dd8:	e008      	b.n	8014dec <tcp_input+0x2e4>
    }
    prev = pcb;
 8014dda:	697b      	ldr	r3, [r7, #20]
 8014ddc:	613b      	str	r3, [r7, #16]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8014dde:	697b      	ldr	r3, [r7, #20]
 8014de0:	68db      	ldr	r3, [r3, #12]
 8014de2:	617b      	str	r3, [r7, #20]
 8014de4:	697b      	ldr	r3, [r7, #20]
 8014de6:	2b00      	cmp	r3, #0
 8014de8:	d1b8      	bne.n	8014d5c <tcp_input+0x254>
 8014dea:	e000      	b.n	8014dee <tcp_input+0x2e6>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 8014dec:	bf00      	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
 8014dee:	697b      	ldr	r3, [r7, #20]
 8014df0:	2b00      	cmp	r3, #0
 8014df2:	f040 8087 	bne.w	8014f04 <tcp_input+0x3fc>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8014df6:	f246 5368 	movw	r3, #25960	; 0x6568
 8014dfa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014dfe:	681b      	ldr	r3, [r3, #0]
 8014e00:	617b      	str	r3, [r7, #20]
 8014e02:	e033      	b.n	8014e6c <tcp_input+0x364>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 8014e04:	697b      	ldr	r3, [r7, #20]
 8014e06:	8c1a      	ldrh	r2, [r3, #32]
 8014e08:	f245 5370 	movw	r3, #21872	; 0x5570
 8014e0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e10:	681b      	ldr	r3, [r3, #0]
 8014e12:	881b      	ldrh	r3, [r3, #0]
 8014e14:	b29b      	uxth	r3, r3
 8014e16:	429a      	cmp	r2, r3
 8014e18:	d125      	bne.n	8014e66 <tcp_input+0x35e>
         pcb->local_port == tcphdr->dest &&
 8014e1a:	697b      	ldr	r3, [r7, #20]
 8014e1c:	8b1a      	ldrh	r2, [r3, #24]
 8014e1e:	f245 5370 	movw	r3, #21872	; 0x5570
 8014e22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e26:	681b      	ldr	r3, [r3, #0]
 8014e28:	885b      	ldrh	r3, [r3, #2]
 8014e2a:	b29b      	uxth	r3, r3
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 8014e2c:	429a      	cmp	r2, r3
 8014e2e:	d11a      	bne.n	8014e66 <tcp_input+0x35e>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8014e30:	697b      	ldr	r3, [r7, #20]
 8014e32:	685a      	ldr	r2, [r3, #4]
 8014e34:	f245 5374 	movw	r3, #21876	; 0x5574
 8014e38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e3c:	681b      	ldr	r3, [r3, #0]
 8014e3e:	68db      	ldr	r3, [r3, #12]
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
 8014e40:	429a      	cmp	r2, r3
 8014e42:	d110      	bne.n	8014e66 <tcp_input+0x35e>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
 8014e44:	697b      	ldr	r3, [r7, #20]
 8014e46:	681a      	ldr	r2, [r3, #0]
 8014e48:	f245 5374 	movw	r3, #21876	; 0x5574
 8014e4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e50:	681b      	ldr	r3, [r3, #0]
 8014e52:	691b      	ldr	r3, [r3, #16]
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
 8014e54:	429a      	cmp	r2, r3
 8014e56:	d106      	bne.n	8014e66 <tcp_input+0x35e>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
 8014e58:	6978      	ldr	r0, [r7, #20]
 8014e5a:	f000 fb19 	bl	8015490 <tcp_timewait_input>
        pbuf_free(p);
 8014e5e:	6878      	ldr	r0, [r7, #4]
 8014e60:	f7fe f82e 	bl	8012ec0 <pbuf_free>
        return;
 8014e64:	e201      	b.n	801526a <tcp_input+0x762>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8014e66:	697b      	ldr	r3, [r7, #20]
 8014e68:	68db      	ldr	r3, [r3, #12]
 8014e6a:	617b      	str	r3, [r7, #20]
 8014e6c:	697b      	ldr	r3, [r7, #20]
 8014e6e:	2b00      	cmp	r3, #0
 8014e70:	d1c8      	bne.n	8014e04 <tcp_input+0x2fc>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
 8014e72:	f04f 0300 	mov.w	r3, #0
 8014e76:	613b      	str	r3, [r7, #16]
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8014e78:	f246 535c 	movw	r3, #25948	; 0x655c
 8014e7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014e80:	681b      	ldr	r3, [r3, #0]
 8014e82:	60fb      	str	r3, [r7, #12]
 8014e84:	e03b      	b.n	8014efe <tcp_input+0x3f6>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
 8014e86:	68fb      	ldr	r3, [r7, #12]
 8014e88:	2b00      	cmp	r3, #0
 8014e8a:	d00d      	beq.n	8014ea8 <tcp_input+0x3a0>
 8014e8c:	68fb      	ldr	r3, [r7, #12]
 8014e8e:	681b      	ldr	r3, [r3, #0]
 8014e90:	2b00      	cmp	r3, #0
 8014e92:	d009      	beq.n	8014ea8 <tcp_input+0x3a0>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
 8014e94:	68fb      	ldr	r3, [r7, #12]
 8014e96:	681a      	ldr	r2, [r3, #0]
 8014e98:	f245 5374 	movw	r3, #21876	; 0x5574
 8014e9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014ea0:	681b      	ldr	r3, [r3, #0]
 8014ea2:	691b      	ldr	r3, [r3, #16]

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
 8014ea4:	429a      	cmp	r2, r3
 8014ea6:	d125      	bne.n	8014ef4 <tcp_input+0x3ec>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
 8014ea8:	68fb      	ldr	r3, [r7, #12]
 8014eaa:	8b1a      	ldrh	r2, [r3, #24]
 8014eac:	f245 5370 	movw	r3, #21872	; 0x5570
 8014eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014eb4:	681b      	ldr	r3, [r3, #0]
 8014eb6:	885b      	ldrh	r3, [r3, #2]
 8014eb8:	b29b      	uxth	r3, r3
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
 8014eba:	429a      	cmp	r2, r3
 8014ebc:	d11a      	bne.n	8014ef4 <tcp_input+0x3ec>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
 8014ebe:	693b      	ldr	r3, [r7, #16]
 8014ec0:	2b00      	cmp	r3, #0
 8014ec2:	d010      	beq.n	8014ee6 <tcp_input+0x3de>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8014ec4:	68fb      	ldr	r3, [r7, #12]
 8014ec6:	68da      	ldr	r2, [r3, #12]
 8014ec8:	693b      	ldr	r3, [r7, #16]
 8014eca:	60da      	str	r2, [r3, #12]
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
 8014ecc:	f246 535c 	movw	r3, #25948	; 0x655c
 8014ed0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014ed4:	681a      	ldr	r2, [r3, #0]
 8014ed6:	68fb      	ldr	r3, [r7, #12]
 8014ed8:	60da      	str	r2, [r3, #12]
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
 8014eda:	f246 535c 	movw	r3, #25948	; 0x655c
 8014ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014ee2:	68fa      	ldr	r2, [r7, #12]
 8014ee4:	601a      	str	r2, [r3, #0]
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
 8014ee6:	68f8      	ldr	r0, [r7, #12]
 8014ee8:	f000 f9c4 	bl	8015274 <tcp_listen_input>
        pbuf_free(p);
 8014eec:	6878      	ldr	r0, [r7, #4]
 8014eee:	f7fd ffe7 	bl	8012ec0 <pbuf_free>
        return;
 8014ef2:	e1ba      	b.n	801526a <tcp_input+0x762>
      }
      prev = (struct tcp_pcb *)lpcb;
 8014ef4:	68fb      	ldr	r3, [r7, #12]
 8014ef6:	613b      	str	r3, [r7, #16]
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8014ef8:	68fb      	ldr	r3, [r7, #12]
 8014efa:	68db      	ldr	r3, [r3, #12]
 8014efc:	60fb      	str	r3, [r7, #12]
 8014efe:	68fb      	ldr	r3, [r7, #12]
 8014f00:	2b00      	cmp	r3, #0
 8014f02:	d1c0      	bne.n	8014e86 <tcp_input+0x37e>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
 8014f04:	697b      	ldr	r3, [r7, #20]
 8014f06:	2b00      	cmp	r3, #0
 8014f08:	f000 816b 	beq.w	80151e2 <tcp_input+0x6da>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8014f0c:	f245 535c 	movw	r3, #21852	; 0x555c
 8014f10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f14:	f04f 0200 	mov.w	r2, #0
 8014f18:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 8014f1a:	687b      	ldr	r3, [r7, #4]
 8014f1c:	891a      	ldrh	r2, [r3, #8]
 8014f1e:	f245 535c 	movw	r3, #21852	; 0x555c
 8014f22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f26:	819a      	strh	r2, [r3, #12]
    inseg.dataptr = p->payload;
 8014f28:	687b      	ldr	r3, [r7, #4]
 8014f2a:	685a      	ldr	r2, [r3, #4]
 8014f2c:	f245 535c 	movw	r3, #21852	; 0x555c
 8014f30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f34:	609a      	str	r2, [r3, #8]
    inseg.p = p;
 8014f36:	f245 535c 	movw	r3, #21852	; 0x555c
 8014f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f3e:	687a      	ldr	r2, [r7, #4]
 8014f40:	605a      	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
 8014f42:	f245 5370 	movw	r3, #21872	; 0x5570
 8014f46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f4a:	681a      	ldr	r2, [r3, #0]
 8014f4c:	f245 535c 	movw	r3, #21852	; 0x555c
 8014f50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f54:	611a      	str	r2, [r3, #16]

    recv_data = NULL;
 8014f56:	f245 5388 	movw	r3, #21896	; 0x5588
 8014f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f5e:	f04f 0200 	mov.w	r2, #0
 8014f62:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 8014f64:	f245 5384 	movw	r3, #21892	; 0x5584
 8014f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014f6c:	f04f 0200 	mov.w	r2, #0
 8014f70:	701a      	strb	r2, [r3, #0]

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 8014f72:	697b      	ldr	r3, [r7, #20]
 8014f74:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014f76:	2b00      	cmp	r3, #0
 8014f78:	d02d      	beq.n	8014fd6 <tcp_input+0x4ce>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
 8014f7a:	697b      	ldr	r3, [r7, #20]
 8014f7c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8014f80:	2b00      	cmp	r3, #0
 8014f82:	d00f      	beq.n	8014fa4 <tcp_input+0x49c>
 8014f84:	697b      	ldr	r3, [r7, #20]
 8014f86:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8014f8a:	697b      	ldr	r3, [r7, #20]
 8014f8c:	695a      	ldr	r2, [r3, #20]
 8014f8e:	697b      	ldr	r3, [r7, #20]
 8014f90:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014f92:	4610      	mov	r0, r2
 8014f94:	6979      	ldr	r1, [r7, #20]
 8014f96:	461a      	mov	r2, r3
 8014f98:	f04f 0300 	mov.w	r3, #0
 8014f9c:	47a0      	blx	r4
 8014f9e:	4603      	mov	r3, r0
 8014fa0:	72fb      	strb	r3, [r7, #11]
 8014fa2:	e00b      	b.n	8014fbc <tcp_input+0x4b4>
 8014fa4:	697b      	ldr	r3, [r7, #20]
 8014fa6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8014fa8:	f04f 0000 	mov.w	r0, #0
 8014fac:	6979      	ldr	r1, [r7, #20]
 8014fae:	461a      	mov	r2, r3
 8014fb0:	f04f 0300 	mov.w	r3, #0
 8014fb4:	f7ff fb0a 	bl	80145cc <tcp_recv_null>
 8014fb8:	4603      	mov	r3, r0
 8014fba:	72fb      	strb	r3, [r7, #11]
      if (err == ERR_OK) {
 8014fbc:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8014fc0:	2b00      	cmp	r3, #0
 8014fc2:	d104      	bne.n	8014fce <tcp_input+0x4c6>
        pcb->refused_data = NULL;
 8014fc4:	697b      	ldr	r3, [r7, #20]
 8014fc6:	f04f 0200 	mov.w	r2, #0
 8014fca:	67da      	str	r2, [r3, #124]	; 0x7c
 8014fcc:	e003      	b.n	8014fd6 <tcp_input+0x4ce>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
 8014fce:	6878      	ldr	r0, [r7, #4]
 8014fd0:	f7fd ff76 	bl	8012ec0 <pbuf_free>
        return;
 8014fd4:	e149      	b.n	801526a <tcp_input+0x762>
      }
    }
    tcp_input_pcb = pcb;
 8014fd6:	f246 536c 	movw	r3, #25964	; 0x656c
 8014fda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8014fde:	697a      	ldr	r2, [r7, #20]
 8014fe0:	601a      	str	r2, [r3, #0]
    err = tcp_process(pcb);
 8014fe2:	6978      	ldr	r0, [r7, #20]
 8014fe4:	f000 fae6 	bl	80155b4 <tcp_process>
 8014fe8:	4603      	mov	r3, r0
 8014fea:	72fb      	strb	r3, [r7, #11]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 8014fec:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8014ff0:	f113 0f05 	cmn.w	r3, #5
 8014ff4:	f000 80d7 	beq.w	80151a6 <tcp_input+0x69e>
      if (recv_flags & TF_RESET) {
 8014ff8:	f245 5384 	movw	r3, #21892	; 0x5584
 8014ffc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015000:	781b      	ldrb	r3, [r3, #0]
 8015002:	f003 0308 	and.w	r3, r3, #8
 8015006:	2b00      	cmp	r3, #0
 8015008:	d018      	beq.n	801503c <tcp_input+0x534>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 801500a:	697b      	ldr	r3, [r7, #20]
 801500c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8015010:	2b00      	cmp	r3, #0
 8015012:	d008      	beq.n	8015026 <tcp_input+0x51e>
 8015014:	697b      	ldr	r3, [r7, #20]
 8015016:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 801501a:	697a      	ldr	r2, [r7, #20]
 801501c:	6952      	ldr	r2, [r2, #20]
 801501e:	4610      	mov	r0, r2
 8015020:	f06f 0105 	mvn.w	r1, #5
 8015024:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8015026:	f246 5054 	movw	r0, #25940	; 0x6554
 801502a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801502e:	6979      	ldr	r1, [r7, #20]
 8015030:	f7ff fcb0 	bl	8014994 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8015034:	6978      	ldr	r0, [r7, #20]
 8015036:	f7fc ff3f 	bl	8011eb8 <mem_free>
 801503a:	e0b4      	b.n	80151a6 <tcp_input+0x69e>
      } else if (recv_flags & TF_CLOSED) {
 801503c:	f245 5384 	movw	r3, #21892	; 0x5584
 8015040:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015044:	781b      	ldrb	r3, [r3, #0]
 8015046:	f003 0310 	and.w	r3, r3, #16
 801504a:	2b00      	cmp	r3, #0
 801504c:	d00a      	beq.n	8015064 <tcp_input+0x55c>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 801504e:	f246 5054 	movw	r0, #25940	; 0x6554
 8015052:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015056:	6979      	ldr	r1, [r7, #20]
 8015058:	f7ff fc9c 	bl	8014994 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 801505c:	6978      	ldr	r0, [r7, #20]
 801505e:	f7fc ff2b 	bl	8011eb8 <mem_free>
 8015062:	e0a0      	b.n	80151a6 <tcp_input+0x69e>
      } else {
        err = ERR_OK;
 8015064:	f04f 0300 	mov.w	r3, #0
 8015068:	72fb      	strb	r3, [r7, #11]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 801506a:	697b      	ldr	r3, [r7, #20]
 801506c:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 8015070:	2b00      	cmp	r3, #0
 8015072:	d015      	beq.n	80150a0 <tcp_input+0x598>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 8015074:	697b      	ldr	r3, [r7, #20]
 8015076:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801507a:	2b00      	cmp	r3, #0
 801507c:	d00d      	beq.n	801509a <tcp_input+0x592>
 801507e:	697b      	ldr	r3, [r7, #20]
 8015080:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8015084:	697a      	ldr	r2, [r7, #20]
 8015086:	6951      	ldr	r1, [r2, #20]
 8015088:	697a      	ldr	r2, [r7, #20]
 801508a:	f8b2 206c 	ldrh.w	r2, [r2, #108]	; 0x6c
 801508e:	4608      	mov	r0, r1
 8015090:	6979      	ldr	r1, [r7, #20]
 8015092:	4798      	blx	r3
 8015094:	4603      	mov	r3, r0
 8015096:	72fb      	strb	r3, [r7, #11]
 8015098:	e002      	b.n	80150a0 <tcp_input+0x598>
 801509a:	f04f 0300 	mov.w	r3, #0
 801509e:	72fb      	strb	r3, [r7, #11]
        }
      
        if (recv_data != NULL) {
 80150a0:	f245 5388 	movw	r3, #21896	; 0x5588
 80150a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150a8:	681b      	ldr	r3, [r3, #0]
 80150aa:	2b00      	cmp	r3, #0
 80150ac:	d049      	beq.n	8015142 <tcp_input+0x63a>
          if(flags & TCP_PSH) {
 80150ae:	f245 5380 	movw	r3, #21888	; 0x5580
 80150b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150b6:	781b      	ldrb	r3, [r3, #0]
 80150b8:	f003 0308 	and.w	r3, r3, #8
 80150bc:	2b00      	cmp	r3, #0
 80150be:	d00e      	beq.n	80150de <tcp_input+0x5d6>
            recv_data->flags |= PBUF_FLAG_PUSH;
 80150c0:	f245 5388 	movw	r3, #21896	; 0x5588
 80150c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150c8:	681a      	ldr	r2, [r3, #0]
 80150ca:	f245 5388 	movw	r3, #21896	; 0x5588
 80150ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150d2:	681b      	ldr	r3, [r3, #0]
 80150d4:	7b5b      	ldrb	r3, [r3, #13]
 80150d6:	f043 0301 	orr.w	r3, r3, #1
 80150da:	b2db      	uxtb	r3, r3
 80150dc:	7353      	strb	r3, [r2, #13]
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 80150de:	697b      	ldr	r3, [r7, #20]
 80150e0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80150e4:	2b00      	cmp	r3, #0
 80150e6:	d012      	beq.n	801510e <tcp_input+0x606>
 80150e8:	697b      	ldr	r3, [r7, #20]
 80150ea:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 80150ee:	697b      	ldr	r3, [r7, #20]
 80150f0:	695a      	ldr	r2, [r3, #20]
 80150f2:	f245 5388 	movw	r3, #21896	; 0x5588
 80150f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80150fa:	681b      	ldr	r3, [r3, #0]
 80150fc:	4610      	mov	r0, r2
 80150fe:	6979      	ldr	r1, [r7, #20]
 8015100:	461a      	mov	r2, r3
 8015102:	f04f 0300 	mov.w	r3, #0
 8015106:	47a0      	blx	r4
 8015108:	4603      	mov	r3, r0
 801510a:	72fb      	strb	r3, [r7, #11]
 801510c:	e00e      	b.n	801512c <tcp_input+0x624>
 801510e:	f245 5388 	movw	r3, #21896	; 0x5588
 8015112:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015116:	681b      	ldr	r3, [r3, #0]
 8015118:	f04f 0000 	mov.w	r0, #0
 801511c:	6979      	ldr	r1, [r7, #20]
 801511e:	461a      	mov	r2, r3
 8015120:	f04f 0300 	mov.w	r3, #0
 8015124:	f7ff fa52 	bl	80145cc <tcp_recv_null>
 8015128:	4603      	mov	r3, r0
 801512a:	72fb      	strb	r3, [r7, #11]

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 801512c:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8015130:	2b00      	cmp	r3, #0
 8015132:	d006      	beq.n	8015142 <tcp_input+0x63a>
            pcb->refused_data = recv_data;
 8015134:	f245 5388 	movw	r3, #21896	; 0x5588
 8015138:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801513c:	681a      	ldr	r2, [r3, #0]
 801513e:	697b      	ldr	r3, [r7, #20]
 8015140:	67da      	str	r2, [r3, #124]	; 0x7c
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 8015142:	f245 5384 	movw	r3, #21892	; 0x5584
 8015146:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801514a:	781b      	ldrb	r3, [r3, #0]
 801514c:	f003 0320 	and.w	r3, r3, #32
 8015150:	2b00      	cmp	r3, #0
 8015152:	d01e      	beq.n	8015192 <tcp_input+0x68a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
 8015154:	697b      	ldr	r3, [r7, #20]
 8015156:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 801515a:	2b00      	cmp	r3, #0
 801515c:	d00e      	beq.n	801517c <tcp_input+0x674>
 801515e:	697b      	ldr	r3, [r7, #20]
 8015160:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
 8015164:	697b      	ldr	r3, [r7, #20]
 8015166:	695b      	ldr	r3, [r3, #20]
 8015168:	4618      	mov	r0, r3
 801516a:	6979      	ldr	r1, [r7, #20]
 801516c:	f04f 0200 	mov.w	r2, #0
 8015170:	f04f 0300 	mov.w	r3, #0
 8015174:	47a0      	blx	r4
 8015176:	4603      	mov	r3, r0
 8015178:	72fb      	strb	r3, [r7, #11]
 801517a:	e00a      	b.n	8015192 <tcp_input+0x68a>
 801517c:	f04f 0000 	mov.w	r0, #0
 8015180:	6979      	ldr	r1, [r7, #20]
 8015182:	f04f 0200 	mov.w	r2, #0
 8015186:	f04f 0300 	mov.w	r3, #0
 801518a:	f7ff fa1f 	bl	80145cc <tcp_recv_null>
 801518e:	4603      	mov	r3, r0
 8015190:	72fb      	strb	r3, [r7, #11]
        }

        tcp_input_pcb = NULL;
 8015192:	f246 536c 	movw	r3, #25964	; 0x656c
 8015196:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801519a:	f04f 0200 	mov.w	r2, #0
 801519e:	601a      	str	r2, [r3, #0]
        /* Try to send something out. */
        tcp_output(pcb);
 80151a0:	6978      	ldr	r0, [r7, #20]
 80151a2:	f002 f861 	bl	8017268 <tcp_output>
        tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */
      }
    }
    tcp_input_pcb = NULL;
 80151a6:	f246 536c 	movw	r3, #25964	; 0x656c
 80151aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80151ae:	f04f 0200 	mov.w	r2, #0
 80151b2:	601a      	str	r2, [r3, #0]


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 80151b4:	f245 535c 	movw	r3, #21852	; 0x555c
 80151b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80151bc:	685b      	ldr	r3, [r3, #4]
 80151be:	2b00      	cmp	r3, #0
 80151c0:	d053      	beq.n	801526a <tcp_input+0x762>
    {
      pbuf_free(inseg.p);
 80151c2:	f245 535c 	movw	r3, #21852	; 0x555c
 80151c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80151ca:	685b      	ldr	r3, [r3, #4]
 80151cc:	4618      	mov	r0, r3
 80151ce:	f7fd fe77 	bl	8012ec0 <pbuf_free>
      inseg.p = NULL;
 80151d2:	f245 535c 	movw	r3, #21852	; 0x555c
 80151d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80151da:	f04f 0200 	mov.w	r2, #0
 80151de:	605a      	str	r2, [r3, #4]
 80151e0:	e043      	b.n	801526a <tcp_input+0x762>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 80151e2:	f245 5370 	movw	r3, #21872	; 0x5570
 80151e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80151ea:	681b      	ldr	r3, [r3, #0]
 80151ec:	899b      	ldrh	r3, [r3, #12]
 80151ee:	b29b      	uxth	r3, r3
 80151f0:	4618      	mov	r0, r3
 80151f2:	f003 ffc9 	bl	8019188 <ntohs>
 80151f6:	4603      	mov	r3, r0
 80151f8:	f003 0304 	and.w	r3, r3, #4
 80151fc:	2b00      	cmp	r3, #0
 80151fe:	d131      	bne.n	8015264 <tcp_input+0x75c>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 8015200:	f245 537c 	movw	r3, #21884	; 0x557c
 8015204:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015208:	6818      	ldr	r0, [r3, #0]
 801520a:	f245 5382 	movw	r3, #21890	; 0x5582
 801520e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015212:	881b      	ldrh	r3, [r3, #0]
 8015214:	461a      	mov	r2, r3
 8015216:	f245 5378 	movw	r3, #21880	; 0x5578
 801521a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801521e:	681b      	ldr	r3, [r3, #0]
 8015220:	18d1      	adds	r1, r2, r3
        &(iphdr->dest), &(iphdr->src),
 8015222:	f245 5374 	movw	r3, #21876	; 0x5574
 8015226:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801522a:	681b      	ldr	r3, [r3, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 801522c:	f103 0210 	add.w	r2, r3, #16
        &(iphdr->dest), &(iphdr->src),
 8015230:	f245 5374 	movw	r3, #21876	; 0x5574
 8015234:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015238:	681b      	ldr	r3, [r3, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 801523a:	f103 040c 	add.w	r4, r3, #12
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
 801523e:	f245 5370 	movw	r3, #21872	; 0x5570
 8015242:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015246:	681b      	ldr	r3, [r3, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 8015248:	885b      	ldrh	r3, [r3, #2]
 801524a:	b29d      	uxth	r5, r3
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
 801524c:	f245 5370 	movw	r3, #21872	; 0x5570
 8015250:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015254:	681b      	ldr	r3, [r3, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 8015256:	881b      	ldrh	r3, [r3, #0]
 8015258:	b29b      	uxth	r3, r3
 801525a:	9500      	str	r5, [sp, #0]
 801525c:	9301      	str	r3, [sp, #4]
 801525e:	4623      	mov	r3, r4
 8015260:	f002 fa28 	bl	80176b4 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
 8015264:	6878      	ldr	r0, [r7, #4]
 8015266:	f7fd fe2b 	bl	8012ec0 <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
 801526a:	f107 0718 	add.w	r7, r7, #24
 801526e:	46bd      	mov	sp, r7
 8015270:	bdb0      	pop	{r4, r5, r7, pc}
 8015272:	bf00      	nop

08015274 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 8015274:	b5b0      	push	{r4, r5, r7, lr}
 8015276:	b086      	sub	sp, #24
 8015278:	af02      	add	r7, sp, #8
 801527a:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  err_t rc;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 801527c:	f245 5380 	movw	r3, #21888	; 0x5580
 8015280:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015284:	781b      	ldrb	r3, [r3, #0]
 8015286:	f003 0310 	and.w	r3, r3, #16
 801528a:	2b00      	cmp	r3, #0
 801528c:	d034      	beq.n	80152f8 <tcp_listen_input+0x84>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
 801528e:	f245 537c 	movw	r3, #21884	; 0x557c
 8015292:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015296:	681b      	ldr	r3, [r3, #0]
 8015298:	f103 0001 	add.w	r0, r3, #1
 801529c:	f245 5382 	movw	r3, #21890	; 0x5582
 80152a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152a4:	881b      	ldrh	r3, [r3, #0]
 80152a6:	461a      	mov	r2, r3
 80152a8:	f245 5378 	movw	r3, #21880	; 0x5578
 80152ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152b0:	681b      	ldr	r3, [r3, #0]
 80152b2:	18d1      	adds	r1, r2, r3
      &(iphdr->dest), &(iphdr->src),
 80152b4:	f245 5374 	movw	r3, #21876	; 0x5574
 80152b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152bc:	681b      	ldr	r3, [r3, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
 80152be:	f103 0210 	add.w	r2, r3, #16
      &(iphdr->dest), &(iphdr->src),
 80152c2:	f245 5374 	movw	r3, #21876	; 0x5574
 80152c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152ca:	681b      	ldr	r3, [r3, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
 80152cc:	f103 040c 	add.w	r4, r3, #12
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
 80152d0:	f245 5370 	movw	r3, #21872	; 0x5570
 80152d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152d8:	681b      	ldr	r3, [r3, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
 80152da:	885b      	ldrh	r3, [r3, #2]
 80152dc:	b29d      	uxth	r5, r3
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
 80152de:	f245 5370 	movw	r3, #21872	; 0x5570
 80152e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80152e6:	681b      	ldr	r3, [r3, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
 80152e8:	881b      	ldrh	r3, [r3, #0]
 80152ea:	b29b      	uxth	r3, r3
 80152ec:	9500      	str	r5, [sp, #0]
 80152ee:	9301      	str	r3, [sp, #4]
 80152f0:	4623      	mov	r3, r4
 80152f2:	f002 f9df 	bl	80176b4 <tcp_rst>
 80152f6:	e0c2      	b.n	801547e <tcp_listen_input+0x20a>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 80152f8:	f245 5380 	movw	r3, #21888	; 0x5580
 80152fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015300:	781b      	ldrb	r3, [r3, #0]
 8015302:	f003 0302 	and.w	r3, r3, #2
 8015306:	2b00      	cmp	r3, #0
 8015308:	f000 80b9 	beq.w	801547e <tcp_listen_input+0x20a>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 801530c:	687b      	ldr	r3, [r7, #4]
 801530e:	7c5b      	ldrb	r3, [r3, #17]
 8015310:	4618      	mov	r0, r3
 8015312:	f7ff fa03 	bl	801471c <tcp_alloc>
 8015316:	60f8      	str	r0, [r7, #12]
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 8015318:	68fb      	ldr	r3, [r7, #12]
 801531a:	2b00      	cmp	r3, #0
 801531c:	d102      	bne.n	8015324 <tcp_listen_input+0xb0>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
 801531e:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8015322:	e0ae      	b.n	8015482 <tcp_listen_input+0x20e>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
 8015324:	f245 5374 	movw	r3, #21876	; 0x5574
 8015328:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801532c:	681b      	ldr	r3, [r3, #0]
 801532e:	f103 0310 	add.w	r3, r3, #16
 8015332:	2b00      	cmp	r3, #0
 8015334:	d006      	beq.n	8015344 <tcp_listen_input+0xd0>
 8015336:	f245 5374 	movw	r3, #21876	; 0x5574
 801533a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801533e:	681b      	ldr	r3, [r3, #0]
 8015340:	691b      	ldr	r3, [r3, #16]
 8015342:	e001      	b.n	8015348 <tcp_listen_input+0xd4>
 8015344:	f04f 0300 	mov.w	r3, #0
 8015348:	68fa      	ldr	r2, [r7, #12]
 801534a:	6013      	str	r3, [r2, #0]
    npcb->local_port = pcb->local_port;
 801534c:	687b      	ldr	r3, [r7, #4]
 801534e:	8b1a      	ldrh	r2, [r3, #24]
 8015350:	68fb      	ldr	r3, [r7, #12]
 8015352:	831a      	strh	r2, [r3, #24]
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
 8015354:	f245 5374 	movw	r3, #21876	; 0x5574
 8015358:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801535c:	681b      	ldr	r3, [r3, #0]
 801535e:	f103 030c 	add.w	r3, r3, #12
 8015362:	2b00      	cmp	r3, #0
 8015364:	d006      	beq.n	8015374 <tcp_listen_input+0x100>
 8015366:	f245 5374 	movw	r3, #21876	; 0x5574
 801536a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801536e:	681b      	ldr	r3, [r3, #0]
 8015370:	68db      	ldr	r3, [r3, #12]
 8015372:	e001      	b.n	8015378 <tcp_listen_input+0x104>
 8015374:	f04f 0300 	mov.w	r3, #0
 8015378:	68fa      	ldr	r2, [r7, #12]
 801537a:	6053      	str	r3, [r2, #4]
    npcb->remote_port = tcphdr->src;
 801537c:	f245 5370 	movw	r3, #21872	; 0x5570
 8015380:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015384:	681b      	ldr	r3, [r3, #0]
 8015386:	881b      	ldrh	r3, [r3, #0]
 8015388:	b29a      	uxth	r2, r3
 801538a:	68fb      	ldr	r3, [r7, #12]
 801538c:	841a      	strh	r2, [r3, #32]
    npcb->state = SYN_RCVD;
 801538e:	68fb      	ldr	r3, [r7, #12]
 8015390:	f04f 0203 	mov.w	r2, #3
 8015394:	741a      	strb	r2, [r3, #16]
    npcb->rcv_nxt = seqno + 1;
 8015396:	f245 5378 	movw	r3, #21880	; 0x5578
 801539a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801539e:	681b      	ldr	r3, [r3, #0]
 80153a0:	f103 0201 	add.w	r2, r3, #1
 80153a4:	68fb      	ldr	r3, [r7, #12]
 80153a6:	625a      	str	r2, [r3, #36]	; 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 80153a8:	68fb      	ldr	r3, [r7, #12]
 80153aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80153ac:	68fb      	ldr	r3, [r7, #12]
 80153ae:	62da      	str	r2, [r3, #44]	; 0x2c
    npcb->snd_wnd = tcphdr->wnd;
 80153b0:	f245 5370 	movw	r3, #21872	; 0x5570
 80153b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80153b8:	681b      	ldr	r3, [r3, #0]
 80153ba:	89db      	ldrh	r3, [r3, #14]
 80153bc:	b29a      	uxth	r2, r3
 80153be:	68fb      	ldr	r3, [r7, #12]
 80153c0:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
    npcb->ssthresh = npcb->snd_wnd;
 80153c4:	68fb      	ldr	r3, [r7, #12]
 80153c6:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 80153ca:	68fb      	ldr	r3, [r7, #12]
 80153cc:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 80153d0:	f245 5378 	movw	r3, #21880	; 0x5578
 80153d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80153d8:	681b      	ldr	r3, [r3, #0]
 80153da:	f103 32ff 	add.w	r2, r3, #4294967295
 80153de:	68fb      	ldr	r3, [r7, #12]
 80153e0:	661a      	str	r2, [r3, #96]	; 0x60
    npcb->callback_arg = pcb->callback_arg;
 80153e2:	687b      	ldr	r3, [r7, #4]
 80153e4:	695a      	ldr	r2, [r3, #20]
 80153e6:	68fb      	ldr	r3, [r7, #12]
 80153e8:	615a      	str	r2, [r3, #20]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 80153ea:	687b      	ldr	r3, [r7, #4]
 80153ec:	69da      	ldr	r2, [r3, #28]
 80153ee:	68fb      	ldr	r3, [r7, #12]
 80153f0:	61da      	str	r2, [r3, #28]
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
 80153f2:	687b      	ldr	r3, [r7, #4]
 80153f4:	891a      	ldrh	r2, [r3, #8]
 80153f6:	f240 1399 	movw	r3, #409	; 0x199
 80153fa:	4013      	ands	r3, r2
 80153fc:	b29a      	uxth	r2, r3
 80153fe:	68fb      	ldr	r3, [r7, #12]
 8015400:	811a      	strh	r2, [r3, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
 8015402:	f246 5354 	movw	r3, #25940	; 0x6554
 8015406:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801540a:	681a      	ldr	r2, [r3, #0]
 801540c:	68fb      	ldr	r3, [r7, #12]
 801540e:	60da      	str	r2, [r3, #12]
 8015410:	f246 5354 	movw	r3, #25940	; 0x6554
 8015414:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015418:	68fa      	ldr	r2, [r7, #12]
 801541a:	601a      	str	r2, [r3, #0]

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 801541c:	68f8      	ldr	r0, [r7, #12]
 801541e:	f001 fa69 	bl	80168f4 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 8015422:	68fb      	ldr	r3, [r7, #12]
 8015424:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 8015426:	68fb      	ldr	r3, [r7, #12]
 8015428:	f103 0304 	add.w	r3, r3, #4
 801542c:	4610      	mov	r0, r2
 801542e:	4619      	mov	r1, r3
 8015430:	f7ff fb36 	bl	8014aa0 <tcp_eff_send_mss>
 8015434:	4603      	mov	r3, r0
 8015436:	461a      	mov	r2, r3
 8015438:	68fb      	ldr	r3, [r7, #12]
 801543a:	871a      	strh	r2, [r3, #56]	; 0x38
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, TF_SEG_OPTS_MSS
 801543c:	f04f 0300 	mov.w	r3, #0
 8015440:	9300      	str	r3, [sp, #0]
 8015442:	f04f 0301 	mov.w	r3, #1
 8015446:	9301      	str	r3, [sp, #4]
 8015448:	68f8      	ldr	r0, [r7, #12]
 801544a:	f04f 0100 	mov.w	r1, #0
 801544e:	f04f 0200 	mov.w	r2, #0
 8015452:	f04f 0312 	mov.w	r3, #18
 8015456:	f001 fbb5 	bl	8016bc4 <tcp_enqueue>
 801545a:	4603      	mov	r3, r0
 801545c:	72fb      	strb	r3, [r7, #11]
#if LWIP_TCP_TIMESTAMPS
      /* and maybe include the TIMESTAMP option */
     | (npcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0)
#endif
      );
    if (rc != ERR_OK) {
 801545e:	f997 300b 	ldrsb.w	r3, [r7, #11]
 8015462:	2b00      	cmp	r3, #0
 8015464:	d006      	beq.n	8015474 <tcp_listen_input+0x200>
      tcp_abandon(npcb, 0);
 8015466:	68f8      	ldr	r0, [r7, #12]
 8015468:	f04f 0100 	mov.w	r1, #0
 801546c:	f7fe fa14 	bl	8013898 <tcp_abandon>
      return rc;
 8015470:	7afb      	ldrb	r3, [r7, #11]
 8015472:	e006      	b.n	8015482 <tcp_listen_input+0x20e>
    }
    return tcp_output(npcb);
 8015474:	68f8      	ldr	r0, [r7, #12]
 8015476:	f001 fef7 	bl	8017268 <tcp_output>
 801547a:	4603      	mov	r3, r0
 801547c:	e001      	b.n	8015482 <tcp_listen_input+0x20e>
  }
  return ERR_OK;
 801547e:	f04f 0300 	mov.w	r3, #0
 8015482:	b25b      	sxtb	r3, r3
}
 8015484:	4618      	mov	r0, r3
 8015486:	f107 0710 	add.w	r7, r7, #16
 801548a:	46bd      	mov	sp, r7
 801548c:	bdb0      	pop	{r4, r5, r7, pc}
 801548e:	bf00      	nop

08015490 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
 8015490:	b5b0      	push	{r4, r5, r7, lr}
 8015492:	b084      	sub	sp, #16
 8015494:	af02      	add	r7, sp, #8
 8015496:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
 8015498:	f245 5380 	movw	r3, #21888	; 0x5580
 801549c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80154a0:	781b      	ldrb	r3, [r3, #0]
 80154a2:	f003 0304 	and.w	r3, r3, #4
 80154a6:	2b00      	cmp	r3, #0
 80154a8:	d002      	beq.n	80154b0 <tcp_timewait_input+0x20>
    return ERR_OK;
 80154aa:	f04f 0300 	mov.w	r3, #0
 80154ae:	e07b      	b.n	80155a8 <tcp_timewait_input+0x118>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 80154b0:	f245 5380 	movw	r3, #21888	; 0x5580
 80154b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80154b8:	781b      	ldrb	r3, [r3, #0]
 80154ba:	f003 0302 	and.w	r3, r3, #2
 80154be:	2b00      	cmp	r3, #0
 80154c0:	d04b      	beq.n	801555a <tcp_timewait_input+0xca>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 80154c2:	f245 5378 	movw	r3, #21880	; 0x5578
 80154c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80154ca:	681a      	ldr	r2, [r3, #0]
 80154cc:	687b      	ldr	r3, [r7, #4]
 80154ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80154d0:	1ad3      	subs	r3, r2, r3
 80154d2:	2b00      	cmp	r3, #0
 80154d4:	db51      	blt.n	801557a <tcp_timewait_input+0xea>
 80154d6:	f245 5378 	movw	r3, #21880	; 0x5578
 80154da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80154de:	681a      	ldr	r2, [r3, #0]
 80154e0:	687b      	ldr	r3, [r7, #4]
 80154e2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80154e4:	687b      	ldr	r3, [r7, #4]
 80154e6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80154e8:	18cb      	adds	r3, r1, r3
 80154ea:	1ad3      	subs	r3, r2, r3
 80154ec:	2b00      	cmp	r3, #0
 80154ee:	dc44      	bgt.n	801557a <tcp_timewait_input+0xea>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 80154f0:	f245 537c 	movw	r3, #21884	; 0x557c
 80154f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80154f8:	6818      	ldr	r0, [r3, #0]
 80154fa:	f245 5382 	movw	r3, #21890	; 0x5582
 80154fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015502:	881b      	ldrh	r3, [r3, #0]
 8015504:	461a      	mov	r2, r3
 8015506:	f245 5378 	movw	r3, #21880	; 0x5578
 801550a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801550e:	681b      	ldr	r3, [r3, #0]
 8015510:	18d1      	adds	r1, r2, r3
 8015512:	f245 5374 	movw	r3, #21876	; 0x5574
 8015516:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801551a:	681b      	ldr	r3, [r3, #0]
 801551c:	f103 0210 	add.w	r2, r3, #16
 8015520:	f245 5374 	movw	r3, #21876	; 0x5574
 8015524:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015528:	681b      	ldr	r3, [r3, #0]
 801552a:	f103 040c 	add.w	r4, r3, #12
        tcphdr->dest, tcphdr->src);
 801552e:	f245 5370 	movw	r3, #21872	; 0x5570
 8015532:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015536:	681b      	ldr	r3, [r3, #0]
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 8015538:	885b      	ldrh	r3, [r3, #2]
 801553a:	b29d      	uxth	r5, r3
        tcphdr->dest, tcphdr->src);
 801553c:	f245 5370 	movw	r3, #21872	; 0x5570
 8015540:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015544:	681b      	ldr	r3, [r3, #0]
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 8015546:	881b      	ldrh	r3, [r3, #0]
 8015548:	b29b      	uxth	r3, r3
 801554a:	9500      	str	r5, [sp, #0]
 801554c:	9301      	str	r3, [sp, #4]
 801554e:	4623      	mov	r3, r4
 8015550:	f002 f8b0 	bl	80176b4 <tcp_rst>
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
 8015554:	f04f 0300 	mov.w	r3, #0
 8015558:	e026      	b.n	80155a8 <tcp_timewait_input+0x118>
    }
  } else if (flags & TCP_FIN) {
 801555a:	f245 5380 	movw	r3, #21888	; 0x5580
 801555e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015562:	781b      	ldrb	r3, [r3, #0]
 8015564:	f003 0301 	and.w	r3, r3, #1
 8015568:	2b00      	cmp	r3, #0
 801556a:	d006      	beq.n	801557a <tcp_timewait_input+0xea>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 801556c:	f246 5358 	movw	r3, #25944	; 0x6558
 8015570:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015574:	681a      	ldr	r2, [r3, #0]
 8015576:	687b      	ldr	r3, [r7, #4]
 8015578:	631a      	str	r2, [r3, #48]	; 0x30
  }

  if ((tcplen > 0))  {
 801557a:	f245 5382 	movw	r3, #21890	; 0x5582
 801557e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015582:	881b      	ldrh	r3, [r3, #0]
 8015584:	2b00      	cmp	r3, #0
 8015586:	d00d      	beq.n	80155a4 <tcp_timewait_input+0x114>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 8015588:	687b      	ldr	r3, [r7, #4]
 801558a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801558e:	f043 0302 	orr.w	r3, r3, #2
 8015592:	b2da      	uxtb	r2, r3
 8015594:	687b      	ldr	r3, [r7, #4]
 8015596:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    return tcp_output(pcb);
 801559a:	6878      	ldr	r0, [r7, #4]
 801559c:	f001 fe64 	bl	8017268 <tcp_output>
 80155a0:	4603      	mov	r3, r0
 80155a2:	e001      	b.n	80155a8 <tcp_timewait_input+0x118>
  }
  return ERR_OK;
 80155a4:	f04f 0300 	mov.w	r3, #0
 80155a8:	b25b      	sxtb	r3, r3
}
 80155aa:	4618      	mov	r0, r3
 80155ac:	f107 0708 	add.w	r7, r7, #8
 80155b0:	46bd      	mov	sp, r7
 80155b2:	bdb0      	pop	{r4, r5, r7, pc}

080155b4 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 80155b4:	b5b0      	push	{r4, r5, r7, lr}
 80155b6:	b088      	sub	sp, #32
 80155b8:	af02      	add	r7, sp, #8
 80155ba:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 80155bc:	f04f 0300 	mov.w	r3, #0
 80155c0:	75fb      	strb	r3, [r7, #23]
  err_t err;

  err = ERR_OK;
 80155c2:	f04f 0300 	mov.w	r3, #0
 80155c6:	75bb      	strb	r3, [r7, #22]

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 80155c8:	f245 5380 	movw	r3, #21888	; 0x5580
 80155cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80155d0:	781b      	ldrb	r3, [r3, #0]
 80155d2:	f003 0304 	and.w	r3, r3, #4
 80155d6:	2b00      	cmp	r3, #0
 80155d8:	d04b      	beq.n	8015672 <tcp_process+0xbe>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 80155da:	687b      	ldr	r3, [r7, #4]
 80155dc:	7c1b      	ldrb	r3, [r3, #16]
 80155de:	2b02      	cmp	r3, #2
 80155e0:	d10c      	bne.n	80155fc <tcp_process+0x48>
      if (ackno == pcb->snd_nxt) {
 80155e2:	687b      	ldr	r3, [r7, #4]
 80155e4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80155e6:	f245 537c 	movw	r3, #21884	; 0x557c
 80155ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80155ee:	681b      	ldr	r3, [r3, #0]
 80155f0:	429a      	cmp	r2, r3
 80155f2:	d11d      	bne.n	8015630 <tcp_process+0x7c>
        acceptable = 1;
 80155f4:	f04f 0301 	mov.w	r3, #1
 80155f8:	75fb      	strb	r3, [r7, #23]
 80155fa:	e019      	b.n	8015630 <tcp_process+0x7c>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 80155fc:	f245 5378 	movw	r3, #21880	; 0x5578
 8015600:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015604:	681a      	ldr	r2, [r3, #0]
 8015606:	687b      	ldr	r3, [r7, #4]
 8015608:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801560a:	1ad3      	subs	r3, r2, r3
 801560c:	2b00      	cmp	r3, #0
 801560e:	db0f      	blt.n	8015630 <tcp_process+0x7c>
 8015610:	f245 5378 	movw	r3, #21880	; 0x5578
 8015614:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015618:	681a      	ldr	r2, [r3, #0]
 801561a:	687b      	ldr	r3, [r7, #4]
 801561c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801561e:	687b      	ldr	r3, [r7, #4]
 8015620:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8015622:	18cb      	adds	r3, r1, r3
 8015624:	1ad3      	subs	r3, r2, r3
 8015626:	2b00      	cmp	r3, #0
 8015628:	dc02      	bgt.n	8015630 <tcp_process+0x7c>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
 801562a:	f04f 0301 	mov.w	r3, #1
 801562e:	75fb      	strb	r3, [r7, #23]
      }
    }

    if (acceptable) {
 8015630:	7dfb      	ldrb	r3, [r7, #23]
 8015632:	2b00      	cmp	r3, #0
 8015634:	d019      	beq.n	801566a <tcp_process+0xb6>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 8015636:	f245 5384 	movw	r3, #21892	; 0x5584
 801563a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801563e:	781b      	ldrb	r3, [r3, #0]
 8015640:	f043 0308 	orr.w	r3, r3, #8
 8015644:	b2da      	uxtb	r2, r3
 8015646:	f245 5384 	movw	r3, #21892	; 0x5584
 801564a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801564e:	701a      	strb	r2, [r3, #0]
      pcb->flags &= ~TF_ACK_DELAY;
 8015650:	687b      	ldr	r3, [r7, #4]
 8015652:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8015656:	f023 0301 	bic.w	r3, r3, #1
 801565a:	b2da      	uxtb	r2, r3
 801565c:	687b      	ldr	r3, [r7, #4]
 801565e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
      return ERR_RST;
 8015662:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 8015666:	f000 bc0e 	b.w	8015e86 <tcp_process+0x8d2>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
 801566a:	f04f 0300 	mov.w	r3, #0
 801566e:	f000 bc0a 	b.w	8015e86 <tcp_process+0x8d2>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 8015672:	f245 5380 	movw	r3, #21888	; 0x5580
 8015676:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801567a:	781b      	ldrb	r3, [r3, #0]
 801567c:	f003 0302 	and.w	r3, r3, #2
 8015680:	2b00      	cmp	r3, #0
 8015682:	d016      	beq.n	80156b2 <tcp_process+0xfe>
 8015684:	687b      	ldr	r3, [r7, #4]
 8015686:	7c1b      	ldrb	r3, [r3, #16]
 8015688:	2b02      	cmp	r3, #2
 801568a:	d012      	beq.n	80156b2 <tcp_process+0xfe>
 801568c:	687b      	ldr	r3, [r7, #4]
 801568e:	7c1b      	ldrb	r3, [r3, #16]
 8015690:	2b03      	cmp	r3, #3
 8015692:	d00e      	beq.n	80156b2 <tcp_process+0xfe>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 8015694:	687b      	ldr	r3, [r7, #4]
 8015696:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801569a:	f043 0302 	orr.w	r3, r3, #2
 801569e:	b2da      	uxtb	r2, r3
 80156a0:	687b      	ldr	r3, [r7, #4]
 80156a2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 80156a6:	6878      	ldr	r0, [r7, #4]
 80156a8:	f001 fdde 	bl	8017268 <tcp_output>
    return ERR_OK;
 80156ac:	f04f 0300 	mov.w	r3, #0
 80156b0:	e3e9      	b.n	8015e86 <tcp_process+0x8d2>
  }
  
  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
 80156b2:	f246 5358 	movw	r3, #25944	; 0x6558
 80156b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80156ba:	681a      	ldr	r2, [r3, #0]
 80156bc:	687b      	ldr	r3, [r7, #4]
 80156be:	631a      	str	r2, [r3, #48]	; 0x30
  pcb->keep_cnt_sent = 0;
 80156c0:	687b      	ldr	r3, [r7, #4]
 80156c2:	f04f 0200 	mov.w	r2, #0
 80156c6:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d

  tcp_parseopt(pcb);
 80156ca:	6878      	ldr	r0, [r7, #4]
 80156cc:	f001 f912 	bl	80168f4 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 80156d0:	687b      	ldr	r3, [r7, #4]
 80156d2:	7c1b      	ldrb	r3, [r3, #16]
 80156d4:	f1a3 0302 	sub.w	r3, r3, #2
 80156d8:	2b07      	cmp	r3, #7
 80156da:	f200 83c3 	bhi.w	8015e64 <tcp_process+0x8b0>
 80156de:	a201      	add	r2, pc, #4	; (adr r2, 80156e4 <tcp_process+0x130>)
 80156e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80156e4:	08015705 	.word	0x08015705
 80156e8:	08015913 	.word	0x08015913
 80156ec:	08015ab1 	.word	0x08015ab1
 80156f0:	08015aed 	.word	0x08015aed
 80156f4:	08015c4f 	.word	0x08015c4f
 80156f8:	08015ab1 	.word	0x08015ab1
 80156fc:	08015d39 	.word	0x08015d39
 8015700:	08015e1f 	.word	0x08015e1f
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 8015704:	f245 5380 	movw	r3, #21888	; 0x5580
 8015708:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801570c:	781b      	ldrb	r3, [r3, #0]
 801570e:	f003 0310 	and.w	r3, r3, #16
 8015712:	2b00      	cmp	r3, #0
 8015714:	f000 80c0 	beq.w	8015898 <tcp_process+0x2e4>
 8015718:	f245 5380 	movw	r3, #21888	; 0x5580
 801571c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015720:	781b      	ldrb	r3, [r3, #0]
 8015722:	f003 0302 	and.w	r3, r3, #2
 8015726:	2b00      	cmp	r3, #0
 8015728:	f000 80b6 	beq.w	8015898 <tcp_process+0x2e4>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 801572c:	687b      	ldr	r3, [r7, #4]
 801572e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8015730:	691b      	ldr	r3, [r3, #16]
 8015732:	685b      	ldr	r3, [r3, #4]
 8015734:	4618      	mov	r0, r3
 8015736:	f003 fd55 	bl	80191e4 <ntohl>
 801573a:	4603      	mov	r3, r0
 801573c:	f103 0201 	add.w	r2, r3, #1
 8015740:	f245 537c 	movw	r3, #21884	; 0x557c
 8015744:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015748:	681b      	ldr	r3, [r3, #0]
 801574a:	429a      	cmp	r2, r3
 801574c:	f040 80a4 	bne.w	8015898 <tcp_process+0x2e4>
      pcb->snd_buf++;
 8015750:	687b      	ldr	r3, [r7, #4]
 8015752:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8015756:	f103 0301 	add.w	r3, r3, #1
 801575a:	b29a      	uxth	r2, r3
 801575c:	687b      	ldr	r3, [r7, #4]
 801575e:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
      pcb->rcv_nxt = seqno + 1;
 8015762:	f245 5378 	movw	r3, #21880	; 0x5578
 8015766:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801576a:	681b      	ldr	r3, [r3, #0]
 801576c:	f103 0201 	add.w	r2, r3, #1
 8015770:	687b      	ldr	r3, [r7, #4]
 8015772:	625a      	str	r2, [r3, #36]	; 0x24
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8015774:	687b      	ldr	r3, [r7, #4]
 8015776:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8015778:	687b      	ldr	r3, [r7, #4]
 801577a:	62da      	str	r2, [r3, #44]	; 0x2c
      pcb->lastack = ackno;
 801577c:	f245 537c 	movw	r3, #21884	; 0x557c
 8015780:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015784:	681a      	ldr	r2, [r3, #0]
 8015786:	687b      	ldr	r3, [r7, #4]
 8015788:	64da      	str	r2, [r3, #76]	; 0x4c
      pcb->snd_wnd = tcphdr->wnd;
 801578a:	f245 5370 	movw	r3, #21872	; 0x5570
 801578e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015792:	681b      	ldr	r3, [r3, #0]
 8015794:	89db      	ldrh	r3, [r3, #14]
 8015796:	b29a      	uxth	r2, r3
 8015798:	687b      	ldr	r3, [r7, #4]
 801579a:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 801579e:	f245 5378 	movw	r3, #21880	; 0x5578
 80157a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80157a6:	681b      	ldr	r3, [r3, #0]
 80157a8:	f103 32ff 	add.w	r2, r3, #4294967295
 80157ac:	687b      	ldr	r3, [r7, #4]
 80157ae:	661a      	str	r2, [r3, #96]	; 0x60
      pcb->state = ESTABLISHED;
 80157b0:	687b      	ldr	r3, [r7, #4]
 80157b2:	f04f 0204 	mov.w	r2, #4
 80157b6:	741a      	strb	r2, [r3, #16]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 80157b8:	687b      	ldr	r3, [r7, #4]
 80157ba:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 80157bc:	687b      	ldr	r3, [r7, #4]
 80157be:	f103 0304 	add.w	r3, r3, #4
 80157c2:	4610      	mov	r0, r2
 80157c4:	4619      	mov	r1, r3
 80157c6:	f7ff f96b 	bl	8014aa0 <tcp_eff_send_mss>
 80157ca:	4603      	mov	r3, r0
 80157cc:	461a      	mov	r2, r3
 80157ce:	687b      	ldr	r3, [r7, #4]
 80157d0:	871a      	strh	r2, [r3, #56]	; 0x38
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 80157d2:	687b      	ldr	r3, [r7, #4]
 80157d4:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80157d6:	461a      	mov	r2, r3
 80157d8:	ea4f 0282 	mov.w	r2, r2, lsl #2
 80157dc:	18d3      	adds	r3, r2, r3
 80157de:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80157e2:	b29a      	uxth	r2, r3
 80157e4:	687b      	ldr	r3, [r7, #4]
 80157e6:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80157ea:	687b      	ldr	r3, [r7, #4]
 80157ec:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 80157f0:	2b01      	cmp	r3, #1
 80157f2:	d105      	bne.n	8015800 <tcp_process+0x24c>
 80157f4:	687b      	ldr	r3, [r7, #4]
 80157f6:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80157f8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80157fc:	b29b      	uxth	r3, r3
 80157fe:	e001      	b.n	8015804 <tcp_process+0x250>
 8015800:	687b      	ldr	r3, [r7, #4]
 8015802:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8015804:	687a      	ldr	r2, [r7, #4]
 8015806:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 801580a:	687b      	ldr	r3, [r7, #4]
 801580c:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 8015810:	f103 33ff 	add.w	r3, r3, #4294967295
 8015814:	b29a      	uxth	r2, r3
 8015816:	687b      	ldr	r3, [r7, #4]
 8015818:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 801581c:	687b      	ldr	r3, [r7, #4]
 801581e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8015820:	613b      	str	r3, [r7, #16]
      pcb->unacked = rseg->next;
 8015822:	693b      	ldr	r3, [r7, #16]
 8015824:	681a      	ldr	r2, [r3, #0]
 8015826:	687b      	ldr	r3, [r7, #4]
 8015828:	679a      	str	r2, [r3, #120]	; 0x78

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 801582a:	687b      	ldr	r3, [r7, #4]
 801582c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801582e:	2b00      	cmp	r3, #0
 8015830:	d104      	bne.n	801583c <tcp_process+0x288>
        pcb->rtime = -1;
 8015832:	687b      	ldr	r3, [r7, #4]
 8015834:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8015838:	86da      	strh	r2, [r3, #54]	; 0x36
 801583a:	e008      	b.n	801584e <tcp_process+0x29a>
      else {
        pcb->rtime = 0;
 801583c:	687b      	ldr	r3, [r7, #4]
 801583e:	f04f 0200 	mov.w	r2, #0
 8015842:	86da      	strh	r2, [r3, #54]	; 0x36
        pcb->nrtx = 0;
 8015844:	687b      	ldr	r3, [r7, #4]
 8015846:	f04f 0200 	mov.w	r2, #0
 801584a:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
      }

      tcp_seg_free(rseg);
 801584e:	6938      	ldr	r0, [r7, #16]
 8015850:	f7fe fe90 	bl	8014574 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 8015854:	687b      	ldr	r3, [r7, #4]
 8015856:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801585a:	2b00      	cmp	r3, #0
 801585c:	d00c      	beq.n	8015878 <tcp_process+0x2c4>
 801585e:	687b      	ldr	r3, [r7, #4]
 8015860:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8015864:	687a      	ldr	r2, [r7, #4]
 8015866:	6952      	ldr	r2, [r2, #20]
 8015868:	4610      	mov	r0, r2
 801586a:	6879      	ldr	r1, [r7, #4]
 801586c:	f04f 0200 	mov.w	r2, #0
 8015870:	4798      	blx	r3
 8015872:	4603      	mov	r3, r0
 8015874:	75bb      	strb	r3, [r7, #22]
 8015876:	e002      	b.n	801587e <tcp_process+0x2ca>
 8015878:	f04f 0300 	mov.w	r3, #0
 801587c:	75bb      	strb	r3, [r7, #22]
      tcp_ack_now(pcb);
 801587e:	687b      	ldr	r3, [r7, #4]
 8015880:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8015884:	f043 0302 	orr.w	r3, r3, #2
 8015888:	b2da      	uxtb	r2, r3
 801588a:	687b      	ldr	r3, [r7, #4]
 801588c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8015890:	6878      	ldr	r0, [r7, #4]
 8015892:	f001 fce9 	bl	8017268 <tcp_output>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
 8015896:	e2e7      	b.n	8015e68 <tcp_process+0x8b4>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
 8015898:	f245 5380 	movw	r3, #21888	; 0x5580
 801589c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80158a0:	781b      	ldrb	r3, [r3, #0]
 80158a2:	f003 0310 	and.w	r3, r3, #16
 80158a6:	2b00      	cmp	r3, #0
 80158a8:	f000 82de 	beq.w	8015e68 <tcp_process+0x8b4>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 80158ac:	f245 537c 	movw	r3, #21884	; 0x557c
 80158b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80158b4:	6818      	ldr	r0, [r3, #0]
 80158b6:	f245 5382 	movw	r3, #21890	; 0x5582
 80158ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80158be:	881b      	ldrh	r3, [r3, #0]
 80158c0:	461a      	mov	r2, r3
 80158c2:	f245 5378 	movw	r3, #21880	; 0x5578
 80158c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80158ca:	681b      	ldr	r3, [r3, #0]
 80158cc:	18d1      	adds	r1, r2, r3
 80158ce:	f245 5374 	movw	r3, #21876	; 0x5574
 80158d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80158d6:	681b      	ldr	r3, [r3, #0]
 80158d8:	f103 0210 	add.w	r2, r3, #16
 80158dc:	f245 5374 	movw	r3, #21876	; 0x5574
 80158e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80158e4:	681b      	ldr	r3, [r3, #0]
 80158e6:	f103 040c 	add.w	r4, r3, #12
        tcphdr->dest, tcphdr->src);
 80158ea:	f245 5370 	movw	r3, #21872	; 0x5570
 80158ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80158f2:	681b      	ldr	r3, [r3, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 80158f4:	885b      	ldrh	r3, [r3, #2]
 80158f6:	b29d      	uxth	r5, r3
        tcphdr->dest, tcphdr->src);
 80158f8:	f245 5370 	movw	r3, #21872	; 0x5570
 80158fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015900:	681b      	ldr	r3, [r3, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 8015902:	881b      	ldrh	r3, [r3, #0]
 8015904:	b29b      	uxth	r3, r3
 8015906:	9500      	str	r5, [sp, #0]
 8015908:	9301      	str	r3, [sp, #4]
 801590a:	4623      	mov	r3, r4
 801590c:	f001 fed2 	bl	80176b4 <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
 8015910:	e2aa      	b.n	8015e68 <tcp_process+0x8b4>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 8015912:	f245 5380 	movw	r3, #21888	; 0x5580
 8015916:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801591a:	781b      	ldrb	r3, [r3, #0]
 801591c:	f003 0310 	and.w	r3, r3, #16
 8015920:	2b00      	cmp	r3, #0
 8015922:	f000 80ab 	beq.w	8015a7c <tcp_process+0x4c8>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8015926:	687b      	ldr	r3, [r7, #4]
 8015928:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801592a:	ea6f 0203 	mvn.w	r2, r3
 801592e:	f245 537c 	movw	r3, #21884	; 0x557c
 8015932:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015936:	681b      	ldr	r3, [r3, #0]
 8015938:	18d3      	adds	r3, r2, r3
 801593a:	2b00      	cmp	r3, #0
 801593c:	db69      	blt.n	8015a12 <tcp_process+0x45e>
 801593e:	f245 537c 	movw	r3, #21884	; 0x557c
 8015942:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015946:	681a      	ldr	r2, [r3, #0]
 8015948:	687b      	ldr	r3, [r7, #4]
 801594a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801594c:	1ad3      	subs	r3, r2, r3
 801594e:	2b00      	cmp	r3, #0
 8015950:	dc5f      	bgt.n	8015a12 <tcp_process+0x45e>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 8015952:	687b      	ldr	r3, [r7, #4]
 8015954:	f04f 0204 	mov.w	r2, #4
 8015958:	741a      	strb	r2, [r3, #16]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 801595a:	687b      	ldr	r3, [r7, #4]
 801595c:	69db      	ldr	r3, [r3, #28]
 801595e:	2b00      	cmp	r3, #0
 8015960:	d00b      	beq.n	801597a <tcp_process+0x3c6>
 8015962:	687b      	ldr	r3, [r7, #4]
 8015964:	69db      	ldr	r3, [r3, #28]
 8015966:	687a      	ldr	r2, [r7, #4]
 8015968:	6952      	ldr	r2, [r2, #20]
 801596a:	4610      	mov	r0, r2
 801596c:	6879      	ldr	r1, [r7, #4]
 801596e:	f04f 0200 	mov.w	r2, #0
 8015972:	4798      	blx	r3
 8015974:	4603      	mov	r3, r0
 8015976:	75bb      	strb	r3, [r7, #22]
 8015978:	e002      	b.n	8015980 <tcp_process+0x3cc>
 801597a:	f04f 0300 	mov.w	r3, #0
 801597e:	75bb      	strb	r3, [r7, #22]
        if (err != ERR_OK) {
 8015980:	f997 3016 	ldrsb.w	r3, [r7, #22]
 8015984:	2b00      	cmp	r3, #0
 8015986:	d007      	beq.n	8015998 <tcp_process+0x3e4>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
 8015988:	6878      	ldr	r0, [r7, #4]
 801598a:	f04f 0101 	mov.w	r1, #1
 801598e:	f7fd ff83 	bl	8013898 <tcp_abandon>
          return ERR_ABRT;
 8015992:	f04f 03fb 	mov.w	r3, #251	; 0xfb
 8015996:	e276      	b.n	8015e86 <tcp_process+0x8d2>
        }
        old_cwnd = pcb->cwnd;
 8015998:	687b      	ldr	r3, [r7, #4]
 801599a:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801599e:	81fb      	strh	r3, [r7, #14]
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 80159a0:	6878      	ldr	r0, [r7, #4]
 80159a2:	f000 fa77 	bl	8015e94 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
 80159a6:	687b      	ldr	r3, [r7, #4]
 80159a8:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 80159ac:	2b00      	cmp	r3, #0
 80159ae:	d008      	beq.n	80159c2 <tcp_process+0x40e>
          pcb->acked--;
 80159b0:	687b      	ldr	r3, [r7, #4]
 80159b2:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 80159b6:	f103 33ff 	add.w	r3, r3, #4294967295
 80159ba:	b29a      	uxth	r2, r3
 80159bc:	687b      	ldr	r3, [r7, #4]
 80159be:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80159c2:	89fb      	ldrh	r3, [r7, #14]
 80159c4:	2b01      	cmp	r3, #1
 80159c6:	d105      	bne.n	80159d4 <tcp_process+0x420>
 80159c8:	687b      	ldr	r3, [r7, #4]
 80159ca:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80159cc:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80159d0:	b29b      	uxth	r3, r3
 80159d2:	e001      	b.n	80159d8 <tcp_process+0x424>
 80159d4:	687b      	ldr	r3, [r7, #4]
 80159d6:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80159d8:	687a      	ldr	r2, [r7, #4]
 80159da:	f8a2 3052 	strh.w	r3, [r2, #82]	; 0x52

        if (recv_flags & TF_GOT_FIN) {
 80159de:	f245 5384 	movw	r3, #21892	; 0x5584
 80159e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80159e6:	781b      	ldrb	r3, [r3, #0]
 80159e8:	f003 0320 	and.w	r3, r3, #32
 80159ec:	2b00      	cmp	r3, #0
 80159ee:	d043      	beq.n	8015a78 <tcp_process+0x4c4>
          tcp_ack_now(pcb);
 80159f0:	687b      	ldr	r3, [r7, #4]
 80159f2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80159f6:	f043 0302 	orr.w	r3, r3, #2
 80159fa:	b2da      	uxtb	r2, r3
 80159fc:	687b      	ldr	r3, [r7, #4]
 80159fe:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8015a02:	6878      	ldr	r0, [r7, #4]
 8015a04:	f001 fc30 	bl	8017268 <tcp_output>
          pcb->state = CLOSE_WAIT;
 8015a08:	687b      	ldr	r3, [r7, #4]
 8015a0a:	f04f 0207 	mov.w	r2, #7
 8015a0e:	741a      	strb	r2, [r3, #16]
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8015a10:	e032      	b.n	8015a78 <tcp_process+0x4c4>
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 8015a12:	f245 537c 	movw	r3, #21884	; 0x557c
 8015a16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a1a:	6818      	ldr	r0, [r3, #0]
 8015a1c:	f245 5382 	movw	r3, #21890	; 0x5582
 8015a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a24:	881b      	ldrh	r3, [r3, #0]
 8015a26:	461a      	mov	r2, r3
 8015a28:	f245 5378 	movw	r3, #21880	; 0x5578
 8015a2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a30:	681b      	ldr	r3, [r3, #0]
 8015a32:	18d1      	adds	r1, r2, r3
 8015a34:	f245 5374 	movw	r3, #21876	; 0x5574
 8015a38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a3c:	681b      	ldr	r3, [r3, #0]
 8015a3e:	f103 0210 	add.w	r2, r3, #16
 8015a42:	f245 5374 	movw	r3, #21876	; 0x5574
 8015a46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a4a:	681b      	ldr	r3, [r3, #0]
 8015a4c:	f103 040c 	add.w	r4, r3, #12
                tcphdr->dest, tcphdr->src);
 8015a50:	f245 5370 	movw	r3, #21872	; 0x5570
 8015a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a58:	681b      	ldr	r3, [r3, #0]
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 8015a5a:	885b      	ldrh	r3, [r3, #2]
 8015a5c:	b29d      	uxth	r5, r3
                tcphdr->dest, tcphdr->src);
 8015a5e:	f245 5370 	movw	r3, #21872	; 0x5570
 8015a62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a66:	681b      	ldr	r3, [r3, #0]
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
 8015a68:	881b      	ldrh	r3, [r3, #0]
 8015a6a:	b29b      	uxth	r3, r3
 8015a6c:	9500      	str	r5, [sp, #0]
 8015a6e:	9301      	str	r3, [sp, #4]
 8015a70:	4623      	mov	r3, r4
 8015a72:	f001 fe1f 	bl	80176b4 <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 8015a76:	e1f9      	b.n	8015e6c <tcp_process+0x8b8>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8015a78:	bf00      	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 8015a7a:	e1f7      	b.n	8015e6c <tcp_process+0x8b8>
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 8015a7c:	f245 5380 	movw	r3, #21888	; 0x5580
 8015a80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015a84:	781b      	ldrb	r3, [r3, #0]
 8015a86:	f003 0302 	and.w	r3, r3, #2
 8015a8a:	2b00      	cmp	r3, #0
 8015a8c:	f000 81ee 	beq.w	8015e6c <tcp_process+0x8b8>
 8015a90:	687b      	ldr	r3, [r7, #4]
 8015a92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8015a94:	f103 32ff 	add.w	r2, r3, #4294967295
 8015a98:	f245 5378 	movw	r3, #21880	; 0x5578
 8015a9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015aa0:	681b      	ldr	r3, [r3, #0]
 8015aa2:	429a      	cmp	r2, r3
 8015aa4:	f040 81e2 	bne.w	8015e6c <tcp_process+0x8b8>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
 8015aa8:	6878      	ldr	r0, [r7, #4]
 8015aaa:	f001 febf 	bl	801782c <tcp_rexmit>
    }
    break;
 8015aae:	e1dd      	b.n	8015e6c <tcp_process+0x8b8>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 8015ab0:	6878      	ldr	r0, [r7, #4]
 8015ab2:	f000 f9ef 	bl	8015e94 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 8015ab6:	f245 5384 	movw	r3, #21892	; 0x5584
 8015aba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015abe:	781b      	ldrb	r3, [r3, #0]
 8015ac0:	f003 0320 	and.w	r3, r3, #32
 8015ac4:	2b00      	cmp	r3, #0
 8015ac6:	f000 81d3 	beq.w	8015e70 <tcp_process+0x8bc>
      tcp_ack_now(pcb);
 8015aca:	687b      	ldr	r3, [r7, #4]
 8015acc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8015ad0:	f043 0302 	orr.w	r3, r3, #2
 8015ad4:	b2da      	uxtb	r2, r3
 8015ad6:	687b      	ldr	r3, [r7, #4]
 8015ad8:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8015adc:	6878      	ldr	r0, [r7, #4]
 8015ade:	f001 fbc3 	bl	8017268 <tcp_output>
      pcb->state = CLOSE_WAIT;
 8015ae2:	687b      	ldr	r3, [r7, #4]
 8015ae4:	f04f 0207 	mov.w	r2, #7
 8015ae8:	741a      	strb	r2, [r3, #16]
    }
    break;
 8015aea:	e1c1      	b.n	8015e70 <tcp_process+0x8bc>
  case FIN_WAIT_1:
    tcp_receive(pcb);
 8015aec:	6878      	ldr	r0, [r7, #4]
 8015aee:	f000 f9d1 	bl	8015e94 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8015af2:	f245 5384 	movw	r3, #21892	; 0x5584
 8015af6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015afa:	781b      	ldrb	r3, [r3, #0]
 8015afc:	f003 0320 	and.w	r3, r3, #32
 8015b00:	2b00      	cmp	r3, #0
 8015b02:	f000 808b 	beq.w	8015c1c <tcp_process+0x668>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8015b06:	f245 5380 	movw	r3, #21888	; 0x5580
 8015b0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b0e:	781b      	ldrb	r3, [r3, #0]
 8015b10:	f003 0310 	and.w	r3, r3, #16
 8015b14:	2b00      	cmp	r3, #0
 8015b16:	d070      	beq.n	8015bfa <tcp_process+0x646>
 8015b18:	687b      	ldr	r3, [r7, #4]
 8015b1a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8015b1c:	f245 537c 	movw	r3, #21884	; 0x557c
 8015b20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b24:	681b      	ldr	r3, [r3, #0]
 8015b26:	429a      	cmp	r2, r3
 8015b28:	d167      	bne.n	8015bfa <tcp_process+0x646>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 8015b2a:	687b      	ldr	r3, [r7, #4]
 8015b2c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8015b30:	f043 0302 	orr.w	r3, r3, #2
 8015b34:	b2da      	uxtb	r2, r3
 8015b36:	687b      	ldr	r3, [r7, #4]
 8015b38:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8015b3c:	6878      	ldr	r0, [r7, #4]
 8015b3e:	f001 fb93 	bl	8017268 <tcp_output>
        tcp_pcb_purge(pcb);
 8015b42:	6878      	ldr	r0, [r7, #4]
 8015b44:	f7fe fef2 	bl	801492c <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
 8015b48:	f246 5354 	movw	r3, #25940	; 0x6554
 8015b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b50:	681a      	ldr	r2, [r3, #0]
 8015b52:	687b      	ldr	r3, [r7, #4]
 8015b54:	429a      	cmp	r2, r3
 8015b56:	d10b      	bne.n	8015b70 <tcp_process+0x5bc>
 8015b58:	f246 5354 	movw	r3, #25940	; 0x6554
 8015b5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b60:	681b      	ldr	r3, [r3, #0]
 8015b62:	68da      	ldr	r2, [r3, #12]
 8015b64:	f246 5354 	movw	r3, #25940	; 0x6554
 8015b68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b6c:	601a      	str	r2, [r3, #0]
 8015b6e:	e02e      	b.n	8015bce <tcp_process+0x61a>
 8015b70:	f246 5354 	movw	r3, #25940	; 0x6554
 8015b74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b78:	681a      	ldr	r2, [r3, #0]
 8015b7a:	f246 5360 	movw	r3, #25952	; 0x6560
 8015b7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b82:	601a      	str	r2, [r3, #0]
 8015b84:	e01c      	b.n	8015bc0 <tcp_process+0x60c>
 8015b86:	f246 5360 	movw	r3, #25952	; 0x6560
 8015b8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015b8e:	681b      	ldr	r3, [r3, #0]
 8015b90:	68da      	ldr	r2, [r3, #12]
 8015b92:	687b      	ldr	r3, [r7, #4]
 8015b94:	429a      	cmp	r2, r3
 8015b96:	d108      	bne.n	8015baa <tcp_process+0x5f6>
 8015b98:	f246 5360 	movw	r3, #25952	; 0x6560
 8015b9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015ba0:	681b      	ldr	r3, [r3, #0]
 8015ba2:	687a      	ldr	r2, [r7, #4]
 8015ba4:	68d2      	ldr	r2, [r2, #12]
 8015ba6:	60da      	str	r2, [r3, #12]
 8015ba8:	e011      	b.n	8015bce <tcp_process+0x61a>
 8015baa:	f246 5360 	movw	r3, #25952	; 0x6560
 8015bae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015bb2:	681b      	ldr	r3, [r3, #0]
 8015bb4:	68da      	ldr	r2, [r3, #12]
 8015bb6:	f246 5360 	movw	r3, #25952	; 0x6560
 8015bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015bbe:	601a      	str	r2, [r3, #0]
 8015bc0:	f246 5360 	movw	r3, #25952	; 0x6560
 8015bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015bc8:	681b      	ldr	r3, [r3, #0]
 8015bca:	2b00      	cmp	r3, #0
 8015bcc:	d1db      	bne.n	8015b86 <tcp_process+0x5d2>
 8015bce:	687b      	ldr	r3, [r7, #4]
 8015bd0:	f04f 0200 	mov.w	r2, #0
 8015bd4:	60da      	str	r2, [r3, #12]
        pcb->state = TIME_WAIT;
 8015bd6:	687b      	ldr	r3, [r7, #4]
 8015bd8:	f04f 020a 	mov.w	r2, #10
 8015bdc:	741a      	strb	r2, [r3, #16]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8015bde:	f246 5368 	movw	r3, #25960	; 0x6568
 8015be2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015be6:	681a      	ldr	r2, [r3, #0]
 8015be8:	687b      	ldr	r3, [r7, #4]
 8015bea:	60da      	str	r2, [r3, #12]
 8015bec:	f246 5368 	movw	r3, #25960	; 0x6568
 8015bf0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015bf4:	687a      	ldr	r2, [r7, #4]
 8015bf6:	601a      	str	r2, [r3, #0]
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 8015bf8:	e13c      	b.n	8015e74 <tcp_process+0x8c0>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 8015bfa:	687b      	ldr	r3, [r7, #4]
 8015bfc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8015c00:	f043 0302 	orr.w	r3, r3, #2
 8015c04:	b2da      	uxtb	r2, r3
 8015c06:	687b      	ldr	r3, [r7, #4]
 8015c08:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8015c0c:	6878      	ldr	r0, [r7, #4]
 8015c0e:	f001 fb2b 	bl	8017268 <tcp_output>
        pcb->state = CLOSING;
 8015c12:	687b      	ldr	r3, [r7, #4]
 8015c14:	f04f 0208 	mov.w	r2, #8
 8015c18:	741a      	strb	r2, [r3, #16]
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 8015c1a:	e12b      	b.n	8015e74 <tcp_process+0x8c0>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8015c1c:	f245 5380 	movw	r3, #21888	; 0x5580
 8015c20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015c24:	781b      	ldrb	r3, [r3, #0]
 8015c26:	f003 0310 	and.w	r3, r3, #16
 8015c2a:	2b00      	cmp	r3, #0
 8015c2c:	f000 8122 	beq.w	8015e74 <tcp_process+0x8c0>
 8015c30:	687b      	ldr	r3, [r7, #4]
 8015c32:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8015c34:	f245 537c 	movw	r3, #21884	; 0x557c
 8015c38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015c3c:	681b      	ldr	r3, [r3, #0]
 8015c3e:	429a      	cmp	r2, r3
 8015c40:	f040 8118 	bne.w	8015e74 <tcp_process+0x8c0>
      pcb->state = FIN_WAIT_2;
 8015c44:	687b      	ldr	r3, [r7, #4]
 8015c46:	f04f 0206 	mov.w	r2, #6
 8015c4a:	741a      	strb	r2, [r3, #16]
    }
    break;
 8015c4c:	e112      	b.n	8015e74 <tcp_process+0x8c0>
  case FIN_WAIT_2:
    tcp_receive(pcb);
 8015c4e:	6878      	ldr	r0, [r7, #4]
 8015c50:	f000 f920 	bl	8015e94 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8015c54:	f245 5384 	movw	r3, #21892	; 0x5584
 8015c58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015c5c:	781b      	ldrb	r3, [r3, #0]
 8015c5e:	f003 0320 	and.w	r3, r3, #32
 8015c62:	2b00      	cmp	r3, #0
 8015c64:	f000 8108 	beq.w	8015e78 <tcp_process+0x8c4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 8015c68:	687b      	ldr	r3, [r7, #4]
 8015c6a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8015c6e:	f043 0302 	orr.w	r3, r3, #2
 8015c72:	b2da      	uxtb	r2, r3
 8015c74:	687b      	ldr	r3, [r7, #4]
 8015c76:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8015c7a:	6878      	ldr	r0, [r7, #4]
 8015c7c:	f001 faf4 	bl	8017268 <tcp_output>
      tcp_pcb_purge(pcb);
 8015c80:	6878      	ldr	r0, [r7, #4]
 8015c82:	f7fe fe53 	bl	801492c <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
 8015c86:	f246 5354 	movw	r3, #25940	; 0x6554
 8015c8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015c8e:	681a      	ldr	r2, [r3, #0]
 8015c90:	687b      	ldr	r3, [r7, #4]
 8015c92:	429a      	cmp	r2, r3
 8015c94:	d10b      	bne.n	8015cae <tcp_process+0x6fa>
 8015c96:	f246 5354 	movw	r3, #25940	; 0x6554
 8015c9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015c9e:	681b      	ldr	r3, [r3, #0]
 8015ca0:	68da      	ldr	r2, [r3, #12]
 8015ca2:	f246 5354 	movw	r3, #25940	; 0x6554
 8015ca6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015caa:	601a      	str	r2, [r3, #0]
 8015cac:	e02e      	b.n	8015d0c <tcp_process+0x758>
 8015cae:	f246 5354 	movw	r3, #25940	; 0x6554
 8015cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015cb6:	681a      	ldr	r2, [r3, #0]
 8015cb8:	f246 5360 	movw	r3, #25952	; 0x6560
 8015cbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015cc0:	601a      	str	r2, [r3, #0]
 8015cc2:	e01c      	b.n	8015cfe <tcp_process+0x74a>
 8015cc4:	f246 5360 	movw	r3, #25952	; 0x6560
 8015cc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015ccc:	681b      	ldr	r3, [r3, #0]
 8015cce:	68da      	ldr	r2, [r3, #12]
 8015cd0:	687b      	ldr	r3, [r7, #4]
 8015cd2:	429a      	cmp	r2, r3
 8015cd4:	d108      	bne.n	8015ce8 <tcp_process+0x734>
 8015cd6:	f246 5360 	movw	r3, #25952	; 0x6560
 8015cda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015cde:	681b      	ldr	r3, [r3, #0]
 8015ce0:	687a      	ldr	r2, [r7, #4]
 8015ce2:	68d2      	ldr	r2, [r2, #12]
 8015ce4:	60da      	str	r2, [r3, #12]
 8015ce6:	e011      	b.n	8015d0c <tcp_process+0x758>
 8015ce8:	f246 5360 	movw	r3, #25952	; 0x6560
 8015cec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015cf0:	681b      	ldr	r3, [r3, #0]
 8015cf2:	68da      	ldr	r2, [r3, #12]
 8015cf4:	f246 5360 	movw	r3, #25952	; 0x6560
 8015cf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015cfc:	601a      	str	r2, [r3, #0]
 8015cfe:	f246 5360 	movw	r3, #25952	; 0x6560
 8015d02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d06:	681b      	ldr	r3, [r3, #0]
 8015d08:	2b00      	cmp	r3, #0
 8015d0a:	d1db      	bne.n	8015cc4 <tcp_process+0x710>
 8015d0c:	687b      	ldr	r3, [r7, #4]
 8015d0e:	f04f 0200 	mov.w	r2, #0
 8015d12:	60da      	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
 8015d14:	687b      	ldr	r3, [r7, #4]
 8015d16:	f04f 020a 	mov.w	r2, #10
 8015d1a:	741a      	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
 8015d1c:	f246 5368 	movw	r3, #25960	; 0x6568
 8015d20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d24:	681a      	ldr	r2, [r3, #0]
 8015d26:	687b      	ldr	r3, [r7, #4]
 8015d28:	60da      	str	r2, [r3, #12]
 8015d2a:	f246 5368 	movw	r3, #25960	; 0x6568
 8015d2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d32:	687a      	ldr	r2, [r7, #4]
 8015d34:	601a      	str	r2, [r3, #0]
    }
    break;
 8015d36:	e09f      	b.n	8015e78 <tcp_process+0x8c4>
  case CLOSING:
    tcp_receive(pcb);
 8015d38:	6878      	ldr	r0, [r7, #4]
 8015d3a:	f000 f8ab 	bl	8015e94 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8015d3e:	f245 5380 	movw	r3, #21888	; 0x5580
 8015d42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d46:	781b      	ldrb	r3, [r3, #0]
 8015d48:	f003 0310 	and.w	r3, r3, #16
 8015d4c:	2b00      	cmp	r3, #0
 8015d4e:	f000 8095 	beq.w	8015e7c <tcp_process+0x8c8>
 8015d52:	687b      	ldr	r3, [r7, #4]
 8015d54:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8015d56:	f245 537c 	movw	r3, #21884	; 0x557c
 8015d5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d5e:	681b      	ldr	r3, [r3, #0]
 8015d60:	429a      	cmp	r2, r3
 8015d62:	f040 808b 	bne.w	8015e7c <tcp_process+0x8c8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 8015d66:	6878      	ldr	r0, [r7, #4]
 8015d68:	f7fe fde0 	bl	801492c <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
 8015d6c:	f246 5354 	movw	r3, #25940	; 0x6554
 8015d70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d74:	681a      	ldr	r2, [r3, #0]
 8015d76:	687b      	ldr	r3, [r7, #4]
 8015d78:	429a      	cmp	r2, r3
 8015d7a:	d10b      	bne.n	8015d94 <tcp_process+0x7e0>
 8015d7c:	f246 5354 	movw	r3, #25940	; 0x6554
 8015d80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d84:	681b      	ldr	r3, [r3, #0]
 8015d86:	68da      	ldr	r2, [r3, #12]
 8015d88:	f246 5354 	movw	r3, #25940	; 0x6554
 8015d8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d90:	601a      	str	r2, [r3, #0]
 8015d92:	e02e      	b.n	8015df2 <tcp_process+0x83e>
 8015d94:	f246 5354 	movw	r3, #25940	; 0x6554
 8015d98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015d9c:	681a      	ldr	r2, [r3, #0]
 8015d9e:	f246 5360 	movw	r3, #25952	; 0x6560
 8015da2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015da6:	601a      	str	r2, [r3, #0]
 8015da8:	e01c      	b.n	8015de4 <tcp_process+0x830>
 8015daa:	f246 5360 	movw	r3, #25952	; 0x6560
 8015dae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015db2:	681b      	ldr	r3, [r3, #0]
 8015db4:	68da      	ldr	r2, [r3, #12]
 8015db6:	687b      	ldr	r3, [r7, #4]
 8015db8:	429a      	cmp	r2, r3
 8015dba:	d108      	bne.n	8015dce <tcp_process+0x81a>
 8015dbc:	f246 5360 	movw	r3, #25952	; 0x6560
 8015dc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015dc4:	681b      	ldr	r3, [r3, #0]
 8015dc6:	687a      	ldr	r2, [r7, #4]
 8015dc8:	68d2      	ldr	r2, [r2, #12]
 8015dca:	60da      	str	r2, [r3, #12]
 8015dcc:	e011      	b.n	8015df2 <tcp_process+0x83e>
 8015dce:	f246 5360 	movw	r3, #25952	; 0x6560
 8015dd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015dd6:	681b      	ldr	r3, [r3, #0]
 8015dd8:	68da      	ldr	r2, [r3, #12]
 8015dda:	f246 5360 	movw	r3, #25952	; 0x6560
 8015dde:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015de2:	601a      	str	r2, [r3, #0]
 8015de4:	f246 5360 	movw	r3, #25952	; 0x6560
 8015de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015dec:	681b      	ldr	r3, [r3, #0]
 8015dee:	2b00      	cmp	r3, #0
 8015df0:	d1db      	bne.n	8015daa <tcp_process+0x7f6>
 8015df2:	687b      	ldr	r3, [r7, #4]
 8015df4:	f04f 0200 	mov.w	r2, #0
 8015df8:	60da      	str	r2, [r3, #12]
      pcb->state = TIME_WAIT;
 8015dfa:	687b      	ldr	r3, [r7, #4]
 8015dfc:	f04f 020a 	mov.w	r2, #10
 8015e00:	741a      	strb	r2, [r3, #16]
      TCP_REG(&tcp_tw_pcbs, pcb);
 8015e02:	f246 5368 	movw	r3, #25960	; 0x6568
 8015e06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015e0a:	681a      	ldr	r2, [r3, #0]
 8015e0c:	687b      	ldr	r3, [r7, #4]
 8015e0e:	60da      	str	r2, [r3, #12]
 8015e10:	f246 5368 	movw	r3, #25960	; 0x6568
 8015e14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015e18:	687a      	ldr	r2, [r7, #4]
 8015e1a:	601a      	str	r2, [r3, #0]
    }
    break;
 8015e1c:	e02e      	b.n	8015e7c <tcp_process+0x8c8>
  case LAST_ACK:
    tcp_receive(pcb);
 8015e1e:	6878      	ldr	r0, [r7, #4]
 8015e20:	f000 f838 	bl	8015e94 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8015e24:	f245 5380 	movw	r3, #21888	; 0x5580
 8015e28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015e2c:	781b      	ldrb	r3, [r3, #0]
 8015e2e:	f003 0310 	and.w	r3, r3, #16
 8015e32:	2b00      	cmp	r3, #0
 8015e34:	d024      	beq.n	8015e80 <tcp_process+0x8cc>
 8015e36:	687b      	ldr	r3, [r7, #4]
 8015e38:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8015e3a:	f245 537c 	movw	r3, #21884	; 0x557c
 8015e3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015e42:	681b      	ldr	r3, [r3, #0]
 8015e44:	429a      	cmp	r2, r3
 8015e46:	d11b      	bne.n	8015e80 <tcp_process+0x8cc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 8015e48:	f245 5384 	movw	r3, #21892	; 0x5584
 8015e4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015e50:	781b      	ldrb	r3, [r3, #0]
 8015e52:	f043 0310 	orr.w	r3, r3, #16
 8015e56:	b2da      	uxtb	r2, r3
 8015e58:	f245 5384 	movw	r3, #21892	; 0x5584
 8015e5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015e60:	701a      	strb	r2, [r3, #0]
    }
    break;
 8015e62:	e00d      	b.n	8015e80 <tcp_process+0x8cc>
  default:
    break;
 8015e64:	bf00      	nop
 8015e66:	e00c      	b.n	8015e82 <tcp_process+0x8ce>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
 8015e68:	bf00      	nop
 8015e6a:	e00a      	b.n	8015e82 <tcp_process+0x8ce>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 8015e6c:	bf00      	nop
 8015e6e:	e008      	b.n	8015e82 <tcp_process+0x8ce>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
 8015e70:	bf00      	nop
 8015e72:	e006      	b.n	8015e82 <tcp_process+0x8ce>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 8015e74:	bf00      	nop
 8015e76:	e004      	b.n	8015e82 <tcp_process+0x8ce>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
 8015e78:	bf00      	nop
 8015e7a:	e002      	b.n	8015e82 <tcp_process+0x8ce>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
 8015e7c:	bf00      	nop
 8015e7e:	e000      	b.n	8015e82 <tcp_process+0x8ce>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
 8015e80:	bf00      	nop
  default:
    break;
  }
  return ERR_OK;
 8015e82:	f04f 0300 	mov.w	r3, #0
 8015e86:	b25b      	sxtb	r3, r3
}
 8015e88:	4618      	mov	r0, r3
 8015e8a:	f107 0718 	add.w	r7, r7, #24
 8015e8e:	46bd      	mov	sp, r7
 8015e90:	bdb0      	pop	{r4, r5, r7, pc}
 8015e92:	bf00      	nop

08015e94 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 8015e94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015e96:	b08b      	sub	sp, #44	; 0x2c
 8015e98:	af00      	add	r7, sp, #0
 8015e9a:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
 8015e9c:	f04f 0300 	mov.w	r3, #0
 8015ea0:	61bb      	str	r3, [r7, #24]

  if (flags & TCP_ACK) {
 8015ea2:	f245 5380 	movw	r3, #21888	; 0x5580
 8015ea6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015eaa:	781b      	ldrb	r3, [r3, #0]
 8015eac:	f003 0310 	and.w	r3, r3, #16
 8015eb0:	2b00      	cmp	r3, #0
 8015eb2:	f000 82dd 	beq.w	8016470 <tcp_receive+0x5dc>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 8015eb6:	687b      	ldr	r3, [r7, #4]
 8015eb8:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8015ebc:	461a      	mov	r2, r3
 8015ebe:	687b      	ldr	r3, [r7, #4]
 8015ec0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8015ec2:	18d3      	adds	r3, r2, r3
 8015ec4:	617b      	str	r3, [r7, #20]

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8015ec6:	687b      	ldr	r3, [r7, #4]
 8015ec8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8015eca:	f245 5378 	movw	r3, #21880	; 0x5578
 8015ece:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015ed2:	681b      	ldr	r3, [r3, #0]
 8015ed4:	1ad3      	subs	r3, r2, r3
 8015ed6:	2b00      	cmp	r3, #0
 8015ed8:	db27      	blt.n	8015f2a <tcp_receive+0x96>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8015eda:	687b      	ldr	r3, [r7, #4]
 8015edc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8015ede:	f245 5378 	movw	r3, #21880	; 0x5578
 8015ee2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015ee6:	681b      	ldr	r3, [r3, #0]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 8015ee8:	429a      	cmp	r2, r3
 8015eea:	d109      	bne.n	8015f00 <tcp_receive+0x6c>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8015eec:	687b      	ldr	r3, [r7, #4]
 8015eee:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8015ef0:	f245 537c 	movw	r3, #21884	; 0x557c
 8015ef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015ef8:	681b      	ldr	r3, [r3, #0]
 8015efa:	1ad3      	subs	r3, r2, r3
 8015efc:	2b00      	cmp	r3, #0
 8015efe:	db14      	blt.n	8015f2a <tcp_receive+0x96>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 8015f00:	687b      	ldr	r3, [r7, #4]
 8015f02:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8015f04:	f245 537c 	movw	r3, #21884	; 0x557c
 8015f08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015f0c:	681b      	ldr	r3, [r3, #0]
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8015f0e:	429a      	cmp	r2, r3
 8015f10:	d132      	bne.n	8015f78 <tcp_receive+0xe4>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 8015f12:	f245 5370 	movw	r3, #21872	; 0x5570
 8015f16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015f1a:	681b      	ldr	r3, [r3, #0]
 8015f1c:	89db      	ldrh	r3, [r3, #14]
 8015f1e:	b29a      	uxth	r2, r3
 8015f20:	687b      	ldr	r3, [r7, #4]
 8015f22:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8015f26:	429a      	cmp	r2, r3
 8015f28:	d926      	bls.n	8015f78 <tcp_receive+0xe4>
      pcb->snd_wnd = tcphdr->wnd;
 8015f2a:	f245 5370 	movw	r3, #21872	; 0x5570
 8015f2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015f32:	681b      	ldr	r3, [r3, #0]
 8015f34:	89db      	ldrh	r3, [r3, #14]
 8015f36:	b29a      	uxth	r2, r3
 8015f38:	687b      	ldr	r3, [r7, #4]
 8015f3a:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c
      pcb->snd_wl1 = seqno;
 8015f3e:	f245 5378 	movw	r3, #21880	; 0x5578
 8015f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015f46:	681a      	ldr	r2, [r3, #0]
 8015f48:	687b      	ldr	r3, [r7, #4]
 8015f4a:	661a      	str	r2, [r3, #96]	; 0x60
      pcb->snd_wl2 = ackno;
 8015f4c:	f245 537c 	movw	r3, #21884	; 0x557c
 8015f50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015f54:	681a      	ldr	r2, [r3, #0]
 8015f56:	687b      	ldr	r3, [r7, #4]
 8015f58:	665a      	str	r2, [r3, #100]	; 0x64
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
 8015f5a:	687b      	ldr	r3, [r7, #4]
 8015f5c:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8015f60:	2b00      	cmp	r3, #0
 8015f62:	d009      	beq.n	8015f78 <tcp_receive+0xe4>
 8015f64:	687b      	ldr	r3, [r7, #4]
 8015f66:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 8015f6a:	2b00      	cmp	r3, #0
 8015f6c:	d004      	beq.n	8015f78 <tcp_receive+0xe4>
          pcb->persist_backoff = 0;
 8015f6e:	687b      	ldr	r3, [r7, #4]
 8015f70:	f04f 0200 	mov.w	r2, #0
 8015f74:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 8015f78:	f245 537c 	movw	r3, #21884	; 0x557c
 8015f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015f80:	681a      	ldr	r2, [r3, #0]
 8015f82:	687b      	ldr	r3, [r7, #4]
 8015f84:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8015f86:	1ad3      	subs	r3, r2, r3
 8015f88:	2b00      	cmp	r3, #0
 8015f8a:	dc66      	bgt.n	801605a <tcp_receive+0x1c6>
      pcb->acked = 0;
 8015f8c:	687b      	ldr	r3, [r7, #4]
 8015f8e:	f04f 0200 	mov.w	r2, #0
 8015f92:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
      /* Clause 2 */
      if (tcplen == 0) {
 8015f96:	f245 5382 	movw	r3, #21890	; 0x5582
 8015f9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015f9e:	881b      	ldrh	r3, [r3, #0]
 8015fa0:	2b00      	cmp	r3, #0
 8015fa2:	d150      	bne.n	8016046 <tcp_receive+0x1b2>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 8015fa4:	687b      	ldr	r3, [r7, #4]
 8015fa6:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8015fa8:	687b      	ldr	r3, [r7, #4]
 8015faa:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8015fae:	18d2      	adds	r2, r2, r3
 8015fb0:	697b      	ldr	r3, [r7, #20]
 8015fb2:	429a      	cmp	r2, r3
 8015fb4:	d147      	bne.n	8016046 <tcp_receive+0x1b2>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 8015fb6:	687b      	ldr	r3, [r7, #4]
 8015fb8:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8015fba:	b21b      	sxth	r3, r3
 8015fbc:	2b00      	cmp	r3, #0
 8015fbe:	db42      	blt.n	8016046 <tcp_receive+0x1b2>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 8015fc0:	687b      	ldr	r3, [r7, #4]
 8015fc2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8015fc4:	f245 537c 	movw	r3, #21884	; 0x557c
 8015fc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015fcc:	681b      	ldr	r3, [r3, #0]
 8015fce:	429a      	cmp	r2, r3
 8015fd0:	d139      	bne.n	8016046 <tcp_receive+0x1b2>
              found_dupack = 1;
 8015fd2:	f04f 0301 	mov.w	r3, #1
 8015fd6:	61bb      	str	r3, [r7, #24]
              if (pcb->dupacks + 1 > pcb->dupacks)
 8015fd8:	687b      	ldr	r3, [r7, #4]
 8015fda:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8015fde:	f103 0201 	add.w	r2, r3, #1
 8015fe2:	687b      	ldr	r3, [r7, #4]
 8015fe4:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8015fe8:	429a      	cmp	r2, r3
 8015fea:	dd08      	ble.n	8015ffe <tcp_receive+0x16a>
                ++pcb->dupacks;
 8015fec:	687b      	ldr	r3, [r7, #4]
 8015fee:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8015ff2:	f103 0301 	add.w	r3, r3, #1
 8015ff6:	b2da      	uxtb	r2, r3
 8015ff8:	687b      	ldr	r3, [r7, #4]
 8015ffa:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
              if (pcb->dupacks > 3) {
 8015ffe:	687b      	ldr	r3, [r7, #4]
 8016000:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8016004:	2b03      	cmp	r3, #3
 8016006:	d916      	bls.n	8016036 <tcp_receive+0x1a2>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8016008:	687b      	ldr	r3, [r7, #4]
 801600a:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 801600e:	687b      	ldr	r3, [r7, #4]
 8016010:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8016012:	18d3      	adds	r3, r2, r3
 8016014:	b29a      	uxth	r2, r3
 8016016:	687b      	ldr	r3, [r7, #4]
 8016018:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801601c:	429a      	cmp	r2, r3
 801601e:	d912      	bls.n	8016046 <tcp_receive+0x1b2>
                  pcb->cwnd += pcb->mss;
 8016020:	687b      	ldr	r3, [r7, #4]
 8016022:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 8016026:	687b      	ldr	r3, [r7, #4]
 8016028:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801602a:	18d3      	adds	r3, r2, r3
 801602c:	b29a      	uxth	r2, r3
 801602e:	687b      	ldr	r3, [r7, #4]
 8016030:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
 8016034:	e007      	b.n	8016046 <tcp_receive+0x1b2>
                }
              } else if (pcb->dupacks == 3) {
 8016036:	687b      	ldr	r3, [r7, #4]
 8016038:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 801603c:	2b03      	cmp	r3, #3
 801603e:	d102      	bne.n	8016046 <tcp_receive+0x1b2>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
 8016040:	6878      	ldr	r0, [r7, #4]
 8016042:	f001 fc3b 	bl	80178bc <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 8016046:	69bb      	ldr	r3, [r7, #24]
 8016048:	2b00      	cmp	r3, #0
 801604a:	f040 8175 	bne.w	8016338 <tcp_receive+0x4a4>
        pcb->dupacks = 0;
 801604e:	687b      	ldr	r3, [r7, #4]
 8016050:	f04f 0200 	mov.w	r2, #0
 8016054:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8016058:	e16e      	b.n	8016338 <tcp_receive+0x4a4>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 801605a:	687b      	ldr	r3, [r7, #4]
 801605c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801605e:	ea6f 0203 	mvn.w	r2, r3
 8016062:	f245 537c 	movw	r3, #21884	; 0x557c
 8016066:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801606a:	681b      	ldr	r3, [r3, #0]
 801606c:	18d3      	adds	r3, r2, r3
 801606e:	2b00      	cmp	r3, #0
 8016070:	f2c0 811b 	blt.w	80162aa <tcp_receive+0x416>
 8016074:	f245 537c 	movw	r3, #21884	; 0x557c
 8016078:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801607c:	681a      	ldr	r2, [r3, #0]
 801607e:	687b      	ldr	r3, [r7, #4]
 8016080:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8016082:	1ad3      	subs	r3, r2, r3
 8016084:	2b00      	cmp	r3, #0
 8016086:	f300 8110 	bgt.w	80162aa <tcp_receive+0x416>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 801608a:	687b      	ldr	r3, [r7, #4]
 801608c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8016090:	f003 0304 	and.w	r3, r3, #4
 8016094:	2b00      	cmp	r3, #0
 8016096:	d00e      	beq.n	80160b6 <tcp_receive+0x222>
        pcb->flags &= ~TF_INFR;
 8016098:	687b      	ldr	r3, [r7, #4]
 801609a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801609e:	f023 0304 	bic.w	r3, r3, #4
 80160a2:	b2da      	uxtb	r2, r3
 80160a4:	687b      	ldr	r3, [r7, #4]
 80160a6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
        pcb->cwnd = pcb->ssthresh;
 80160aa:	687b      	ldr	r3, [r7, #4]
 80160ac:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 80160b0:	687b      	ldr	r3, [r7, #4]
 80160b2:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 80160b6:	687b      	ldr	r3, [r7, #4]
 80160b8:	f04f 0200 	mov.w	r2, #0
 80160bc:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80160c0:	687b      	ldr	r3, [r7, #4]
 80160c2:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80160c6:	b21b      	sxth	r3, r3
 80160c8:	ea4f 03e3 	mov.w	r3, r3, asr #3
 80160cc:	b29b      	uxth	r3, r3
 80160ce:	b29a      	uxth	r2, r3
 80160d0:	687b      	ldr	r3, [r7, #4]
 80160d2:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 80160d6:	b29b      	uxth	r3, r3
 80160d8:	18d3      	adds	r3, r2, r3
 80160da:	b29b      	uxth	r3, r3
 80160dc:	b29a      	uxth	r2, r3
 80160de:	687b      	ldr	r3, [r7, #4]
 80160e0:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 80160e4:	f245 537c 	movw	r3, #21884	; 0x557c
 80160e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80160ec:	681b      	ldr	r3, [r3, #0]
 80160ee:	b29a      	uxth	r2, r3
 80160f0:	687b      	ldr	r3, [r7, #4]
 80160f2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80160f4:	b29b      	uxth	r3, r3
 80160f6:	1ad3      	subs	r3, r2, r3
 80160f8:	b29a      	uxth	r2, r3
 80160fa:	687b      	ldr	r3, [r7, #4]
 80160fc:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c

      pcb->snd_buf += pcb->acked;
 8016100:	687b      	ldr	r3, [r7, #4]
 8016102:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 8016106:	687b      	ldr	r3, [r7, #4]
 8016108:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 801610c:	18d3      	adds	r3, r2, r3
 801610e:	b29a      	uxth	r2, r3
 8016110:	687b      	ldr	r3, [r7, #4]
 8016112:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 8016116:	687b      	ldr	r3, [r7, #4]
 8016118:	f04f 0200 	mov.w	r2, #0
 801611c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
      pcb->lastack = ackno;
 8016120:	f245 537c 	movw	r3, #21884	; 0x557c
 8016124:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016128:	681a      	ldr	r2, [r3, #0]
 801612a:	687b      	ldr	r3, [r7, #4]
 801612c:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 801612e:	687b      	ldr	r3, [r7, #4]
 8016130:	7c1b      	ldrb	r3, [r3, #16]
 8016132:	2b03      	cmp	r3, #3
 8016134:	d97b      	bls.n	801622e <tcp_receive+0x39a>
        if (pcb->cwnd < pcb->ssthresh) {
 8016136:	687b      	ldr	r3, [r7, #4]
 8016138:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 801613c:	687b      	ldr	r3, [r7, #4]
 801613e:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 8016142:	429a      	cmp	r2, r3
 8016144:	d216      	bcs.n	8016174 <tcp_receive+0x2e0>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8016146:	687b      	ldr	r3, [r7, #4]
 8016148:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 801614c:	687b      	ldr	r3, [r7, #4]
 801614e:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8016150:	18d3      	adds	r3, r2, r3
 8016152:	b29a      	uxth	r2, r3
 8016154:	687b      	ldr	r3, [r7, #4]
 8016156:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801615a:	429a      	cmp	r2, r3
 801615c:	d967      	bls.n	801622e <tcp_receive+0x39a>
            pcb->cwnd += pcb->mss;
 801615e:	687b      	ldr	r3, [r7, #4]
 8016160:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 8016164:	687b      	ldr	r3, [r7, #4]
 8016166:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8016168:	18d3      	adds	r3, r2, r3
 801616a:	b29a      	uxth	r2, r3
 801616c:	687b      	ldr	r3, [r7, #4]
 801616e:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 8016172:	e05c      	b.n	801622e <tcp_receive+0x39a>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 8016174:	687b      	ldr	r3, [r7, #4]
 8016176:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 801617a:	687b      	ldr	r3, [r7, #4]
 801617c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801617e:	6879      	ldr	r1, [r7, #4]
 8016180:	8f09      	ldrh	r1, [r1, #56]	; 0x38
 8016182:	fb01 f103 	mul.w	r1, r1, r3
 8016186:	687b      	ldr	r3, [r7, #4]
 8016188:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801618c:	fb91 f3f3 	sdiv	r3, r1, r3
 8016190:	b29b      	uxth	r3, r3
 8016192:	18d3      	adds	r3, r2, r3
 8016194:	827b      	strh	r3, [r7, #18]
          if (new_cwnd > pcb->cwnd) {
 8016196:	687b      	ldr	r3, [r7, #4]
 8016198:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801619c:	8a7a      	ldrh	r2, [r7, #18]
 801619e:	429a      	cmp	r2, r3
 80161a0:	d945      	bls.n	801622e <tcp_receive+0x39a>
            pcb->cwnd = new_cwnd;
 80161a2:	687b      	ldr	r3, [r7, #4]
 80161a4:	8a7a      	ldrh	r2, [r7, #18]
 80161a6:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 80161aa:	e040      	b.n	801622e <tcp_receive+0x39a>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 80161ac:	687b      	ldr	r3, [r7, #4]
 80161ae:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80161b0:	60fb      	str	r3, [r7, #12]
        pcb->unacked = pcb->unacked->next;
 80161b2:	687b      	ldr	r3, [r7, #4]
 80161b4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80161b6:	681a      	ldr	r2, [r3, #0]
 80161b8:	687b      	ldr	r3, [r7, #4]
 80161ba:	679a      	str	r2, [r3, #120]	; 0x78

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80161bc:	68fb      	ldr	r3, [r7, #12]
 80161be:	685b      	ldr	r3, [r3, #4]
 80161c0:	4618      	mov	r0, r3
 80161c2:	f7fc fed1 	bl	8012f68 <pbuf_clen>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 80161c6:	687b      	ldr	r3, [r7, #4]
 80161c8:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 80161cc:	2b00      	cmp	r3, #0
 80161ce:	d014      	beq.n	80161fa <tcp_receive+0x366>
 80161d0:	68fb      	ldr	r3, [r7, #12]
 80161d2:	691b      	ldr	r3, [r3, #16]
 80161d4:	899b      	ldrh	r3, [r3, #12]
 80161d6:	b29b      	uxth	r3, r3
 80161d8:	4618      	mov	r0, r3
 80161da:	f002 ffd5 	bl	8019188 <ntohs>
 80161de:	4603      	mov	r3, r0
 80161e0:	f003 0301 	and.w	r3, r3, #1
 80161e4:	2b00      	cmp	r3, #0
 80161e6:	d008      	beq.n	80161fa <tcp_receive+0x366>
          pcb->acked--;
 80161e8:	687b      	ldr	r3, [r7, #4]
 80161ea:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 80161ee:	f103 33ff 	add.w	r3, r3, #4294967295
 80161f2:	b29a      	uxth	r2, r3
 80161f4:	687b      	ldr	r3, [r7, #4]
 80161f6:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
 80161fa:	687b      	ldr	r3, [r7, #4]
 80161fc:	f8b3 4070 	ldrh.w	r4, [r3, #112]	; 0x70
 8016200:	68fb      	ldr	r3, [r7, #12]
 8016202:	685b      	ldr	r3, [r3, #4]
 8016204:	4618      	mov	r0, r3
 8016206:	f7fc feaf 	bl	8012f68 <pbuf_clen>
 801620a:	4603      	mov	r3, r0
 801620c:	1ae3      	subs	r3, r4, r3
 801620e:	b29a      	uxth	r2, r3
 8016210:	687b      	ldr	r3, [r7, #4]
 8016212:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
        tcp_seg_free(next);
 8016216:	68f8      	ldr	r0, [r7, #12]
 8016218:	f7fe f9ac 	bl	8014574 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
 801621c:	687b      	ldr	r3, [r7, #4]
 801621e:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 8016222:	2b00      	cmp	r3, #0
 8016224:	d004      	beq.n	8016230 <tcp_receive+0x39c>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 8016226:	687b      	ldr	r3, [r7, #4]
 8016228:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801622a:	2b00      	cmp	r3, #0
 801622c:	e000      	b.n	8016230 <tcp_receive+0x39c>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 801622e:	bf00      	nop
 8016230:	687b      	ldr	r3, [r7, #4]
 8016232:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8016234:	2b00      	cmp	r3, #0
 8016236:	d025      	beq.n	8016284 <tcp_receive+0x3f0>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8016238:	687b      	ldr	r3, [r7, #4]
 801623a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801623c:	691b      	ldr	r3, [r3, #16]
 801623e:	685b      	ldr	r3, [r3, #4]
 8016240:	4618      	mov	r0, r3
 8016242:	f002 ffcf 	bl	80191e4 <ntohl>
 8016246:	4604      	mov	r4, r0
 8016248:	687b      	ldr	r3, [r7, #4]
 801624a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801624c:	899b      	ldrh	r3, [r3, #12]
 801624e:	461d      	mov	r5, r3
 8016250:	687b      	ldr	r3, [r7, #4]
 8016252:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8016254:	691b      	ldr	r3, [r3, #16]
 8016256:	899b      	ldrh	r3, [r3, #12]
 8016258:	b29b      	uxth	r3, r3
 801625a:	4618      	mov	r0, r3
 801625c:	f002 ff94 	bl	8019188 <ntohs>
 8016260:	4603      	mov	r3, r0
 8016262:	f003 0303 	and.w	r3, r3, #3
 8016266:	2b00      	cmp	r3, #0
 8016268:	bf0c      	ite	eq
 801626a:	2300      	moveq	r3, #0
 801626c:	2301      	movne	r3, #1
 801626e:	b2db      	uxtb	r3, r3
 8016270:	18eb      	adds	r3, r5, r3
 8016272:	18e2      	adds	r2, r4, r3
 8016274:	f245 537c 	movw	r3, #21884	; 0x557c
 8016278:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801627c:	681b      	ldr	r3, [r3, #0]
 801627e:	1ad3      	subs	r3, r2, r3
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 8016280:	2b00      	cmp	r3, #0
 8016282:	dd93      	ble.n	80161ac <tcp_receive+0x318>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 8016284:	687b      	ldr	r3, [r7, #4]
 8016286:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8016288:	2b00      	cmp	r3, #0
 801628a:	d104      	bne.n	8016296 <tcp_receive+0x402>
        pcb->rtime = -1;
 801628c:	687b      	ldr	r3, [r7, #4]
 801628e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8016292:	86da      	strh	r2, [r3, #54]	; 0x36
 8016294:	e003      	b.n	801629e <tcp_receive+0x40a>
      else
        pcb->rtime = 0;
 8016296:	687b      	ldr	r3, [r7, #4]
 8016298:	f04f 0200 	mov.w	r2, #0
 801629c:	86da      	strh	r2, [r3, #54]	; 0x36

      pcb->polltmr = 0;
 801629e:	687b      	ldr	r3, [r7, #4]
 80162a0:	f04f 0200 	mov.w	r2, #0
 80162a4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 80162a8:	e046      	b.n	8016338 <tcp_receive+0x4a4>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 80162aa:	687b      	ldr	r3, [r7, #4]
 80162ac:	f04f 0200 	mov.w	r2, #0
 80162b0:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 80162b4:	e040      	b.n	8016338 <tcp_receive+0x4a4>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 80162b6:	687b      	ldr	r3, [r7, #4]
 80162b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80162ba:	60fb      	str	r3, [r7, #12]
      pcb->unsent = pcb->unsent->next;
 80162bc:	687b      	ldr	r3, [r7, #4]
 80162be:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80162c0:	681a      	ldr	r2, [r3, #0]
 80162c2:	687b      	ldr	r3, [r7, #4]
 80162c4:	675a      	str	r2, [r3, #116]	; 0x74
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80162c6:	68fb      	ldr	r3, [r7, #12]
 80162c8:	685b      	ldr	r3, [r3, #4]
 80162ca:	4618      	mov	r0, r3
 80162cc:	f7fc fe4c 	bl	8012f68 <pbuf_clen>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 80162d0:	687b      	ldr	r3, [r7, #4]
 80162d2:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 80162d6:	2b00      	cmp	r3, #0
 80162d8:	d014      	beq.n	8016304 <tcp_receive+0x470>
 80162da:	68fb      	ldr	r3, [r7, #12]
 80162dc:	691b      	ldr	r3, [r3, #16]
 80162de:	899b      	ldrh	r3, [r3, #12]
 80162e0:	b29b      	uxth	r3, r3
 80162e2:	4618      	mov	r0, r3
 80162e4:	f002 ff50 	bl	8019188 <ntohs>
 80162e8:	4603      	mov	r3, r0
 80162ea:	f003 0301 	and.w	r3, r3, #1
 80162ee:	2b00      	cmp	r3, #0
 80162f0:	d008      	beq.n	8016304 <tcp_receive+0x470>
        pcb->acked--;
 80162f2:	687b      	ldr	r3, [r7, #4]
 80162f4:	f8b3 306c 	ldrh.w	r3, [r3, #108]	; 0x6c
 80162f8:	f103 33ff 	add.w	r3, r3, #4294967295
 80162fc:	b29a      	uxth	r2, r3
 80162fe:	687b      	ldr	r3, [r7, #4]
 8016300:	f8a3 206c 	strh.w	r2, [r3, #108]	; 0x6c
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
 8016304:	687b      	ldr	r3, [r7, #4]
 8016306:	f8b3 4070 	ldrh.w	r4, [r3, #112]	; 0x70
 801630a:	68fb      	ldr	r3, [r7, #12]
 801630c:	685b      	ldr	r3, [r3, #4]
 801630e:	4618      	mov	r0, r3
 8016310:	f7fc fe2a 	bl	8012f68 <pbuf_clen>
 8016314:	4603      	mov	r3, r0
 8016316:	1ae3      	subs	r3, r4, r3
 8016318:	b29a      	uxth	r2, r3
 801631a:	687b      	ldr	r3, [r7, #4]
 801631c:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
      tcp_seg_free(next);
 8016320:	68f8      	ldr	r0, [r7, #12]
 8016322:	f7fe f927 	bl	8014574 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
 8016326:	687b      	ldr	r3, [r7, #4]
 8016328:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 801632c:	2b00      	cmp	r3, #0
 801632e:	d004      	beq.n	801633a <tcp_receive+0x4a6>
        LWIP_ASSERT("tcp_receive: valid queue length",
 8016330:	687b      	ldr	r3, [r7, #4]
 8016332:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8016334:	2b00      	cmp	r3, #0
 8016336:	e000      	b.n	801633a <tcp_receive+0x4a6>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8016338:	bf00      	nop
 801633a:	687b      	ldr	r3, [r7, #4]
 801633c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801633e:	2b00      	cmp	r3, #0
 8016340:	d02f      	beq.n	80163a2 <tcp_receive+0x50e>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8016342:	f245 537c 	movw	r3, #21884	; 0x557c
 8016346:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801634a:	681c      	ldr	r4, [r3, #0]
 801634c:	687b      	ldr	r3, [r7, #4]
 801634e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016350:	691b      	ldr	r3, [r3, #16]
 8016352:	685b      	ldr	r3, [r3, #4]
 8016354:	4618      	mov	r0, r3
 8016356:	f002 ff45 	bl	80191e4 <ntohl>
 801635a:	4605      	mov	r5, r0
 801635c:	687b      	ldr	r3, [r7, #4]
 801635e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016360:	899b      	ldrh	r3, [r3, #12]
 8016362:	461e      	mov	r6, r3
 8016364:	687b      	ldr	r3, [r7, #4]
 8016366:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016368:	691b      	ldr	r3, [r3, #16]
 801636a:	899b      	ldrh	r3, [r3, #12]
 801636c:	b29b      	uxth	r3, r3
 801636e:	4618      	mov	r0, r3
 8016370:	f002 ff0a 	bl	8019188 <ntohs>
 8016374:	4603      	mov	r3, r0
 8016376:	f003 0303 	and.w	r3, r3, #3
 801637a:	2b00      	cmp	r3, #0
 801637c:	bf0c      	ite	eq
 801637e:	2300      	moveq	r3, #0
 8016380:	2301      	movne	r3, #1
 8016382:	b2db      	uxtb	r3, r3
 8016384:	18f3      	adds	r3, r6, r3
 8016386:	18eb      	adds	r3, r5, r3
 8016388:	1ae3      	subs	r3, r4, r3
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 801638a:	2b00      	cmp	r3, #0
 801638c:	db09      	blt.n	80163a2 <tcp_receive+0x50e>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 801638e:	f245 537c 	movw	r3, #21884	; 0x557c
 8016392:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016396:	681a      	ldr	r2, [r3, #0]
 8016398:	687b      	ldr	r3, [r7, #4]
 801639a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801639c:	1ad3      	subs	r3, r2, r3
 801639e:	2b00      	cmp	r3, #0
 80163a0:	dd89      	ble.n	80162b6 <tcp_receive+0x422>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 80163a2:	687b      	ldr	r3, [r7, #4]
 80163a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80163a6:	2b00      	cmp	r3, #0
 80163a8:	d062      	beq.n	8016470 <tcp_receive+0x5dc>
 80163aa:	687b      	ldr	r3, [r7, #4]
 80163ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80163ae:	f245 537c 	movw	r3, #21884	; 0x557c
 80163b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80163b6:	681b      	ldr	r3, [r3, #0]
 80163b8:	1ad3      	subs	r3, r2, r3
 80163ba:	2b00      	cmp	r3, #0
 80163bc:	da58      	bge.n	8016470 <tcp_receive+0x5dc>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 80163be:	f246 5358 	movw	r3, #25944	; 0x6558
 80163c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80163c6:	681b      	ldr	r3, [r3, #0]
 80163c8:	b29a      	uxth	r2, r3
 80163ca:	687b      	ldr	r3, [r7, #4]
 80163cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80163ce:	b29b      	uxth	r3, r3
 80163d0:	1ad3      	subs	r3, r2, r3
 80163d2:	b29b      	uxth	r3, r3
 80163d4:	83fb      	strh	r3, [r7, #30]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 80163d6:	8bfa      	ldrh	r2, [r7, #30]
 80163d8:	687b      	ldr	r3, [r7, #4]
 80163da:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80163de:	b21b      	sxth	r3, r3
 80163e0:	ea4f 03e3 	mov.w	r3, r3, asr #3
 80163e4:	b29b      	uxth	r3, r3
 80163e6:	b29b      	uxth	r3, r3
 80163e8:	1ad3      	subs	r3, r2, r3
 80163ea:	b29b      	uxth	r3, r3
 80163ec:	83fb      	strh	r3, [r7, #30]
      pcb->sa += m;
 80163ee:	687b      	ldr	r3, [r7, #4]
 80163f0:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 80163f4:	b29a      	uxth	r2, r3
 80163f6:	8bfb      	ldrh	r3, [r7, #30]
 80163f8:	18d3      	adds	r3, r2, r3
 80163fa:	b29b      	uxth	r3, r3
 80163fc:	b29a      	uxth	r2, r3
 80163fe:	687b      	ldr	r3, [r7, #4]
 8016400:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
      if (m < 0) {
 8016404:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8016408:	2b00      	cmp	r3, #0
 801640a:	da04      	bge.n	8016416 <tcp_receive+0x582>
        m = -m;
 801640c:	8bfb      	ldrh	r3, [r7, #30]
 801640e:	f1c3 0300 	rsb	r3, r3, #0
 8016412:	b29b      	uxth	r3, r3
 8016414:	83fb      	strh	r3, [r7, #30]
      }
      m = m - (pcb->sv >> 2);
 8016416:	8bfa      	ldrh	r2, [r7, #30]
 8016418:	687b      	ldr	r3, [r7, #4]
 801641a:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 801641e:	b21b      	sxth	r3, r3
 8016420:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8016424:	b29b      	uxth	r3, r3
 8016426:	b29b      	uxth	r3, r3
 8016428:	1ad3      	subs	r3, r2, r3
 801642a:	b29b      	uxth	r3, r3
 801642c:	83fb      	strh	r3, [r7, #30]
      pcb->sv += m;
 801642e:	687b      	ldr	r3, [r7, #4]
 8016430:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 8016434:	b29a      	uxth	r2, r3
 8016436:	8bfb      	ldrh	r3, [r7, #30]
 8016438:	18d3      	adds	r3, r2, r3
 801643a:	b29b      	uxth	r3, r3
 801643c:	b29a      	uxth	r2, r3
 801643e:	687b      	ldr	r3, [r7, #4]
 8016440:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8016444:	687b      	ldr	r3, [r7, #4]
 8016446:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 801644a:	b21b      	sxth	r3, r3
 801644c:	ea4f 03e3 	mov.w	r3, r3, asr #3
 8016450:	b29b      	uxth	r3, r3
 8016452:	b29a      	uxth	r2, r3
 8016454:	687b      	ldr	r3, [r7, #4]
 8016456:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 801645a:	b29b      	uxth	r3, r3
 801645c:	18d3      	adds	r3, r2, r3
 801645e:	b29b      	uxth	r3, r3
 8016460:	b29a      	uxth	r2, r3
 8016462:	687b      	ldr	r3, [r7, #4]
 8016464:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 8016468:	687b      	ldr	r3, [r7, #4]
 801646a:	f04f 0200 	mov.w	r2, #0
 801646e:	63da      	str	r2, [r3, #60]	; 0x3c
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
 8016470:	f245 5382 	movw	r3, #21890	; 0x5582
 8016474:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016478:	881b      	ldrh	r3, [r3, #0]
 801647a:	2b00      	cmp	r3, #0
 801647c:	f000 8211 	beq.w	80168a2 <tcp_receive+0xa0e>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 8016480:	687b      	ldr	r3, [r7, #4]
 8016482:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8016484:	f245 5378 	movw	r3, #21880	; 0x5578
 8016488:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801648c:	681b      	ldr	r3, [r3, #0]
 801648e:	ea6f 0303 	mvn.w	r3, r3
 8016492:	18d3      	adds	r3, r2, r3
 8016494:	2b00      	cmp	r3, #0
 8016496:	f2c0 809a 	blt.w	80165ce <tcp_receive+0x73a>
 801649a:	687b      	ldr	r3, [r7, #4]
 801649c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801649e:	f245 5382 	movw	r3, #21890	; 0x5582
 80164a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80164a6:	881b      	ldrh	r3, [r3, #0]
 80164a8:	4619      	mov	r1, r3
 80164aa:	f245 5378 	movw	r3, #21880	; 0x5578
 80164ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80164b2:	681b      	ldr	r3, [r3, #0]
 80164b4:	18cb      	adds	r3, r1, r3
 80164b6:	1ad3      	subs	r3, r2, r3
 80164b8:	f103 0301 	add.w	r3, r3, #1
 80164bc:	2b00      	cmp	r3, #0
 80164be:	f300 8086 	bgt.w	80165ce <tcp_receive+0x73a>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 80164c2:	687b      	ldr	r3, [r7, #4]
 80164c4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80164c6:	f245 5378 	movw	r3, #21880	; 0x5578
 80164ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80164ce:	681b      	ldr	r3, [r3, #0]
 80164d0:	1ad3      	subs	r3, r2, r3
 80164d2:	623b      	str	r3, [r7, #32]
      p = inseg.p;
 80164d4:	f245 535c 	movw	r3, #21852	; 0x555c
 80164d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80164dc:	685b      	ldr	r3, [r3, #4]
 80164de:	627b      	str	r3, [r7, #36]	; 0x24
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 80164e0:	f245 535c 	movw	r3, #21852	; 0x555c
 80164e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80164e8:	685b      	ldr	r3, [r3, #4]
 80164ea:	895b      	ldrh	r3, [r3, #10]
 80164ec:	461a      	mov	r2, r3
 80164ee:	6a3b      	ldr	r3, [r7, #32]
 80164f0:	429a      	cmp	r2, r3
 80164f2:	da2b      	bge.n	801654c <tcp_receive+0x6b8>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 80164f4:	f245 535c 	movw	r3, #21852	; 0x555c
 80164f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80164fc:	685b      	ldr	r3, [r3, #4]
 80164fe:	891a      	ldrh	r2, [r3, #8]
 8016500:	6a3b      	ldr	r3, [r7, #32]
 8016502:	b29b      	uxth	r3, r3
 8016504:	1ad3      	subs	r3, r2, r3
 8016506:	817b      	strh	r3, [r7, #10]
        while (p->len < off) {
 8016508:	e00e      	b.n	8016528 <tcp_receive+0x694>
          off -= p->len;
 801650a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801650c:	895b      	ldrh	r3, [r3, #10]
 801650e:	6a3a      	ldr	r2, [r7, #32]
 8016510:	1ad3      	subs	r3, r2, r3
 8016512:	623b      	str	r3, [r7, #32]
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 8016514:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016516:	897a      	ldrh	r2, [r7, #10]
 8016518:	811a      	strh	r2, [r3, #8]
          p->len = 0;
 801651a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801651c:	f04f 0200 	mov.w	r2, #0
 8016520:	815a      	strh	r2, [r3, #10]
          p = p->next;
 8016522:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016524:	681b      	ldr	r3, [r3, #0]
 8016526:	627b      	str	r3, [r7, #36]	; 0x24
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 8016528:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801652a:	895b      	ldrh	r3, [r3, #10]
 801652c:	461a      	mov	r2, r3
 801652e:	6a3b      	ldr	r3, [r7, #32]
 8016530:	429a      	cmp	r2, r3
 8016532:	dbea      	blt.n	801650a <tcp_receive+0x676>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
 8016534:	6a3b      	ldr	r3, [r7, #32]
 8016536:	b29b      	uxth	r3, r3
 8016538:	f1c3 0300 	rsb	r3, r3, #0
 801653c:	b29b      	uxth	r3, r3
 801653e:	b29b      	uxth	r3, r3
 8016540:	b21b      	sxth	r3, r3
 8016542:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8016544:	4619      	mov	r1, r3
 8016546:	f7fc fc41 	bl	8012dcc <pbuf_header>
 801654a:	e00f      	b.n	801656c <tcp_receive+0x6d8>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 801654c:	f245 535c 	movw	r3, #21852	; 0x555c
 8016550:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016554:	685a      	ldr	r2, [r3, #4]
 8016556:	6a3b      	ldr	r3, [r7, #32]
 8016558:	b29b      	uxth	r3, r3
 801655a:	f1c3 0300 	rsb	r3, r3, #0
 801655e:	b29b      	uxth	r3, r3
 8016560:	b29b      	uxth	r3, r3
 8016562:	b21b      	sxth	r3, r3
 8016564:	4610      	mov	r0, r2
 8016566:	4619      	mov	r1, r3
 8016568:	f7fc fc30 	bl	8012dcc <pbuf_header>
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
 801656c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801656e:	685a      	ldr	r2, [r3, #4]
 8016570:	f245 535c 	movw	r3, #21852	; 0x555c
 8016574:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016578:	609a      	str	r2, [r3, #8]
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 801657a:	f245 535c 	movw	r3, #21852	; 0x555c
 801657e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016582:	899a      	ldrh	r2, [r3, #12]
 8016584:	f245 5378 	movw	r3, #21880	; 0x5578
 8016588:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801658c:	681b      	ldr	r3, [r3, #0]
 801658e:	b299      	uxth	r1, r3
 8016590:	687b      	ldr	r3, [r7, #4]
 8016592:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016594:	b29b      	uxth	r3, r3
 8016596:	1acb      	subs	r3, r1, r3
 8016598:	b29b      	uxth	r3, r3
 801659a:	18d3      	adds	r3, r2, r3
 801659c:	b29a      	uxth	r2, r3
 801659e:	f245 535c 	movw	r3, #21852	; 0x555c
 80165a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80165a6:	819a      	strh	r2, [r3, #12]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 80165a8:	f245 535c 	movw	r3, #21852	; 0x555c
 80165ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80165b0:	691a      	ldr	r2, [r3, #16]
 80165b2:	687b      	ldr	r3, [r7, #4]
 80165b4:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80165b6:	f245 5378 	movw	r3, #21880	; 0x5578
 80165ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80165be:	6019      	str	r1, [r3, #0]
 80165c0:	f245 5378 	movw	r3, #21880	; 0x5578
 80165c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80165c8:	681b      	ldr	r3, [r3, #0]
 80165ca:	6053      	str	r3, [r2, #4]
 80165cc:	e015      	b.n	80165fa <tcp_receive+0x766>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 80165ce:	f245 5378 	movw	r3, #21880	; 0x5578
 80165d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80165d6:	681a      	ldr	r2, [r3, #0]
 80165d8:	687b      	ldr	r3, [r7, #4]
 80165da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80165dc:	1ad3      	subs	r3, r2, r3
 80165de:	2b00      	cmp	r3, #0
 80165e0:	da0b      	bge.n	80165fa <tcp_receive+0x766>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 80165e2:	687b      	ldr	r3, [r7, #4]
 80165e4:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80165e8:	f043 0302 	orr.w	r3, r3, #2
 80165ec:	b2da      	uxtb	r2, r3
 80165ee:	687b      	ldr	r3, [r7, #4]
 80165f0:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 80165f4:	6878      	ldr	r0, [r7, #4]
 80165f6:	f000 fe37 	bl	8017268 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 80165fa:	f245 5378 	movw	r3, #21880	; 0x5578
 80165fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016602:	681a      	ldr	r2, [r3, #0]
 8016604:	687b      	ldr	r3, [r7, #4]
 8016606:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016608:	1ad3      	subs	r3, r2, r3
 801660a:	2b00      	cmp	r3, #0
 801660c:	f2c0 8145 	blt.w	801689a <tcp_receive+0xa06>
 8016610:	f245 5378 	movw	r3, #21880	; 0x5578
 8016614:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016618:	681a      	ldr	r2, [r3, #0]
 801661a:	687b      	ldr	r3, [r7, #4]
 801661c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801661e:	687b      	ldr	r3, [r7, #4]
 8016620:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8016622:	18cb      	adds	r3, r1, r3
 8016624:	1ad3      	subs	r3, r2, r3
 8016626:	f103 0301 	add.w	r3, r3, #1
 801662a:	2b00      	cmp	r3, #0
 801662c:	f300 8135 	bgt.w	801689a <tcp_receive+0xa06>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 8016630:	687b      	ldr	r3, [r7, #4]
 8016632:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8016634:	f245 5378 	movw	r3, #21880	; 0x5578
 8016638:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801663c:	681b      	ldr	r3, [r3, #0]
 801663e:	429a      	cmp	r2, r3
 8016640:	f040 8126 	bne.w	8016890 <tcp_receive+0x9fc>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 8016644:	f245 535c 	movw	r3, #21852	; 0x555c
 8016648:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801664c:	899c      	ldrh	r4, [r3, #12]
 801664e:	f245 535c 	movw	r3, #21852	; 0x555c
 8016652:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016656:	691b      	ldr	r3, [r3, #16]
 8016658:	899b      	ldrh	r3, [r3, #12]
 801665a:	b29b      	uxth	r3, r3
 801665c:	4618      	mov	r0, r3
 801665e:	f002 fd93 	bl	8019188 <ntohs>
 8016662:	4603      	mov	r3, r0
 8016664:	f003 0303 	and.w	r3, r3, #3
 8016668:	2b00      	cmp	r3, #0
 801666a:	bf0c      	ite	eq
 801666c:	2300      	moveq	r3, #0
 801666e:	2301      	movne	r3, #1
 8016670:	b2db      	uxtb	r3, r3
 8016672:	18e3      	adds	r3, r4, r3
 8016674:	b29a      	uxth	r2, r3
 8016676:	f245 5382 	movw	r3, #21890	; 0x5582
 801667a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801667e:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
 8016680:	687b      	ldr	r3, [r7, #4]
 8016682:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8016684:	f245 5382 	movw	r3, #21890	; 0x5582
 8016688:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801668c:	881b      	ldrh	r3, [r3, #0]
 801668e:	429a      	cmp	r2, r3
 8016690:	f080 8086 	bcs.w	80167a0 <tcp_receive+0x90c>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U32_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8016694:	f245 535c 	movw	r3, #21852	; 0x555c
 8016698:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801669c:	691b      	ldr	r3, [r3, #16]
 801669e:	899b      	ldrh	r3, [r3, #12]
 80166a0:	b29b      	uxth	r3, r3
 80166a2:	4618      	mov	r0, r3
 80166a4:	f002 fd70 	bl	8019188 <ntohs>
 80166a8:	4603      	mov	r3, r0
 80166aa:	f003 0301 	and.w	r3, r3, #1
 80166ae:	2b00      	cmp	r3, #0
 80166b0:	d027      	beq.n	8016702 <tcp_receive+0x86e>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 80166b2:	f245 535c 	movw	r3, #21852	; 0x555c
 80166b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80166ba:	691c      	ldr	r4, [r3, #16]
 80166bc:	f245 535c 	movw	r3, #21852	; 0x555c
 80166c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80166c4:	691b      	ldr	r3, [r3, #16]
 80166c6:	899b      	ldrh	r3, [r3, #12]
 80166c8:	b29d      	uxth	r5, r3
 80166ca:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 80166ce:	f002 fd43 	bl	8019158 <htons>
 80166d2:	4603      	mov	r3, r0
 80166d4:	402b      	ands	r3, r5
 80166d6:	b29d      	uxth	r5, r3
 80166d8:	f245 535c 	movw	r3, #21852	; 0x555c
 80166dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80166e0:	691b      	ldr	r3, [r3, #16]
 80166e2:	899b      	ldrh	r3, [r3, #12]
 80166e4:	b29b      	uxth	r3, r3
 80166e6:	4618      	mov	r0, r3
 80166e8:	f002 fd4e 	bl	8019188 <ntohs>
 80166ec:	4603      	mov	r3, r0
 80166ee:	f003 033e 	and.w	r3, r3, #62	; 0x3e
 80166f2:	b29b      	uxth	r3, r3
 80166f4:	4618      	mov	r0, r3
 80166f6:	f002 fd2f 	bl	8019158 <htons>
 80166fa:	4603      	mov	r3, r0
 80166fc:	432b      	orrs	r3, r5
 80166fe:	b29b      	uxth	r3, r3
 8016700:	81a3      	strh	r3, [r4, #12]
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 8016702:	687b      	ldr	r3, [r7, #4]
 8016704:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8016706:	f245 535c 	movw	r3, #21852	; 0x555c
 801670a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801670e:	819a      	strh	r2, [r3, #12]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8016710:	f245 535c 	movw	r3, #21852	; 0x555c
 8016714:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016718:	691b      	ldr	r3, [r3, #16]
 801671a:	899b      	ldrh	r3, [r3, #12]
 801671c:	b29b      	uxth	r3, r3
 801671e:	4618      	mov	r0, r3
 8016720:	f002 fd32 	bl	8019188 <ntohs>
 8016724:	4603      	mov	r3, r0
 8016726:	f003 0302 	and.w	r3, r3, #2
 801672a:	2b00      	cmp	r3, #0
 801672c:	d00c      	beq.n	8016748 <tcp_receive+0x8b4>
            inseg.len -= 1;
 801672e:	f245 535c 	movw	r3, #21852	; 0x555c
 8016732:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016736:	899b      	ldrh	r3, [r3, #12]
 8016738:	f103 33ff 	add.w	r3, r3, #4294967295
 801673c:	b29a      	uxth	r2, r3
 801673e:	f245 535c 	movw	r3, #21852	; 0x555c
 8016742:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016746:	819a      	strh	r2, [r3, #12]
          }
          pbuf_realloc(inseg.p, inseg.len);
 8016748:	f245 535c 	movw	r3, #21852	; 0x555c
 801674c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016750:	685a      	ldr	r2, [r3, #4]
 8016752:	f245 535c 	movw	r3, #21852	; 0x555c
 8016756:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801675a:	899b      	ldrh	r3, [r3, #12]
 801675c:	4610      	mov	r0, r2
 801675e:	4619      	mov	r1, r3
 8016760:	f7fc face 	bl	8012d00 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8016764:	f245 535c 	movw	r3, #21852	; 0x555c
 8016768:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801676c:	899c      	ldrh	r4, [r3, #12]
 801676e:	f245 535c 	movw	r3, #21852	; 0x555c
 8016772:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016776:	691b      	ldr	r3, [r3, #16]
 8016778:	899b      	ldrh	r3, [r3, #12]
 801677a:	b29b      	uxth	r3, r3
 801677c:	4618      	mov	r0, r3
 801677e:	f002 fd03 	bl	8019188 <ntohs>
 8016782:	4603      	mov	r3, r0
 8016784:	f003 0303 	and.w	r3, r3, #3
 8016788:	2b00      	cmp	r3, #0
 801678a:	bf0c      	ite	eq
 801678c:	2300      	moveq	r3, #0
 801678e:	2301      	movne	r3, #1
 8016790:	b2db      	uxtb	r3, r3
 8016792:	18e3      	adds	r3, r4, r3
 8016794:	b29a      	uxth	r2, r3
 8016796:	f245 5382 	movw	r3, #21890	; 0x5582
 801679a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801679e:	801a      	strh	r2, [r3, #0]
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 80167a0:	f245 5382 	movw	r3, #21890	; 0x5582
 80167a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80167a8:	881b      	ldrh	r3, [r3, #0]
 80167aa:	461a      	mov	r2, r3
 80167ac:	f245 5378 	movw	r3, #21880	; 0x5578
 80167b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80167b4:	681b      	ldr	r3, [r3, #0]
 80167b6:	18d2      	adds	r2, r2, r3
 80167b8:	687b      	ldr	r3, [r7, #4]
 80167ba:	625a      	str	r2, [r3, #36]	; 0x24

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 80167bc:	687b      	ldr	r3, [r7, #4]
 80167be:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 80167c0:	f245 5382 	movw	r3, #21890	; 0x5582
 80167c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80167c8:	881b      	ldrh	r3, [r3, #0]
 80167ca:	1ad3      	subs	r3, r2, r3
 80167cc:	b29a      	uxth	r2, r3
 80167ce:	687b      	ldr	r3, [r7, #4]
 80167d0:	851a      	strh	r2, [r3, #40]	; 0x28

        tcp_update_rcv_ann_wnd(pcb);
 80167d2:	6878      	ldr	r0, [r7, #4]
 80167d4:	f7fd fa5e 	bl	8013c94 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 80167d8:	f245 535c 	movw	r3, #21852	; 0x555c
 80167dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80167e0:	685b      	ldr	r3, [r3, #4]
 80167e2:	891b      	ldrh	r3, [r3, #8]
 80167e4:	2b00      	cmp	r3, #0
 80167e6:	d010      	beq.n	801680a <tcp_receive+0x976>
          recv_data = inseg.p;
 80167e8:	f245 535c 	movw	r3, #21852	; 0x555c
 80167ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80167f0:	685a      	ldr	r2, [r3, #4]
 80167f2:	f245 5388 	movw	r3, #21896	; 0x5588
 80167f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80167fa:	601a      	str	r2, [r3, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 80167fc:	f245 535c 	movw	r3, #21852	; 0x555c
 8016800:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016804:	f04f 0200 	mov.w	r2, #0
 8016808:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 801680a:	f245 535c 	movw	r3, #21852	; 0x555c
 801680e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016812:	691b      	ldr	r3, [r3, #16]
 8016814:	899b      	ldrh	r3, [r3, #12]
 8016816:	b29b      	uxth	r3, r3
 8016818:	4618      	mov	r0, r3
 801681a:	f002 fcb5 	bl	8019188 <ntohs>
 801681e:	4603      	mov	r3, r0
 8016820:	f003 0301 	and.w	r3, r3, #1
 8016824:	2b00      	cmp	r3, #0
 8016826:	d00c      	beq.n	8016842 <tcp_receive+0x9ae>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 8016828:	f245 5384 	movw	r3, #21892	; 0x5584
 801682c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016830:	781b      	ldrb	r3, [r3, #0]
 8016832:	f043 0320 	orr.w	r3, r3, #32
 8016836:	b2da      	uxtb	r2, r3
 8016838:	f245 5384 	movw	r3, #21892	; 0x5584
 801683c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016840:	701a      	strb	r2, [r3, #0]
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 8016842:	687b      	ldr	r3, [r7, #4]
 8016844:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8016848:	f003 0301 	and.w	r3, r3, #1
 801684c:	2b00      	cmp	r3, #0
 801684e:	d015      	beq.n	801687c <tcp_receive+0x9e8>
 8016850:	687b      	ldr	r3, [r7, #4]
 8016852:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8016856:	f023 0301 	bic.w	r3, r3, #1
 801685a:	b2da      	uxtb	r2, r3
 801685c:	687b      	ldr	r3, [r7, #4]
 801685e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8016862:	687b      	ldr	r3, [r7, #4]
 8016864:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8016868:	f043 0302 	orr.w	r3, r3, #2
 801686c:	b2da      	uxtb	r2, r3
 801686e:	687b      	ldr	r3, [r7, #4]
 8016870:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 8016874:	6878      	ldr	r0, [r7, #4]
 8016876:	f000 fcf7 	bl	8017268 <tcp_output>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 801687a:	e037      	b.n	80168ec <tcp_receive+0xa58>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 801687c:	687b      	ldr	r3, [r7, #4]
 801687e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8016882:	f043 0301 	orr.w	r3, r3, #1
 8016886:	b2da      	uxtb	r2, r3
 8016888:	687b      	ldr	r3, [r7, #4]
 801688a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 801688e:	e02d      	b.n	80168ec <tcp_receive+0xa58>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 8016890:	6878      	ldr	r0, [r7, #4]
 8016892:	f000 fc9f 	bl	80171d4 <tcp_send_empty_ack>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 8016896:	bf00      	nop
 8016898:	e028      	b.n	80168ec <tcp_receive+0xa58>
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
 801689a:	6878      	ldr	r0, [r7, #4]
 801689c:	f000 fc9a 	bl	80171d4 <tcp_send_empty_ack>
 80168a0:	e024      	b.n	80168ec <tcp_receive+0xa58>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 80168a2:	f245 5378 	movw	r3, #21880	; 0x5578
 80168a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80168aa:	681a      	ldr	r2, [r3, #0]
 80168ac:	687b      	ldr	r3, [r7, #4]
 80168ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80168b0:	1ad3      	subs	r3, r2, r3
 80168b2:	2b00      	cmp	r3, #0
 80168b4:	db0e      	blt.n	80168d4 <tcp_receive+0xa40>
 80168b6:	f245 5378 	movw	r3, #21880	; 0x5578
 80168ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80168be:	681a      	ldr	r2, [r3, #0]
 80168c0:	687b      	ldr	r3, [r7, #4]
 80168c2:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80168c4:	687b      	ldr	r3, [r7, #4]
 80168c6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80168c8:	18cb      	adds	r3, r1, r3
 80168ca:	1ad3      	subs	r3, r2, r3
 80168cc:	f103 0301 	add.w	r3, r3, #1
 80168d0:	2b00      	cmp	r3, #0
 80168d2:	dd0b      	ble.n	80168ec <tcp_receive+0xa58>
      tcp_ack_now(pcb);
 80168d4:	687b      	ldr	r3, [r7, #4]
 80168d6:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80168da:	f043 0302 	orr.w	r3, r3, #2
 80168de:	b2da      	uxtb	r2, r3
 80168e0:	687b      	ldr	r3, [r7, #4]
 80168e2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
 80168e6:	6878      	ldr	r0, [r7, #4]
 80168e8:	f000 fcbe 	bl	8017268 <tcp_output>
    }
  }
}
 80168ec:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 80168f0:	46bd      	mov	sp, r7
 80168f2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080168f4 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 80168f4:	b580      	push	{r7, lr}
 80168f6:	b086      	sub	sp, #24
 80168f8:	af00      	add	r7, sp, #0
 80168fa:	6078      	str	r0, [r7, #4]
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 80168fc:	f245 5370 	movw	r3, #21872	; 0x5570
 8016900:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016904:	681b      	ldr	r3, [r3, #0]
 8016906:	f103 0314 	add.w	r3, r3, #20
 801690a:	613b      	str	r3, [r7, #16]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 801690c:	f245 5370 	movw	r3, #21872	; 0x5570
 8016910:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016914:	681b      	ldr	r3, [r3, #0]
 8016916:	899b      	ldrh	r3, [r3, #12]
 8016918:	b29b      	uxth	r3, r3
 801691a:	4618      	mov	r0, r3
 801691c:	f002 fc34 	bl	8019188 <ntohs>
 8016920:	4603      	mov	r3, r0
 8016922:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8016926:	b29b      	uxth	r3, r3
 8016928:	2b05      	cmp	r3, #5
 801692a:	d978      	bls.n	8016a1e <tcp_parseopt+0x12a>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 801692c:	f245 5370 	movw	r3, #21872	; 0x5570
 8016930:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016934:	681b      	ldr	r3, [r3, #0]
 8016936:	899b      	ldrh	r3, [r3, #12]
 8016938:	b29b      	uxth	r3, r3
 801693a:	4618      	mov	r0, r3
 801693c:	f002 fc24 	bl	8019188 <ntohs>
 8016940:	4603      	mov	r3, r0
 8016942:	ea4f 3313 	mov.w	r3, r3, lsr #12
 8016946:	b29b      	uxth	r3, r3
 8016948:	f1a3 0305 	sub.w	r3, r3, #5
 801694c:	b29b      	uxth	r3, r3
 801694e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8016952:	81fb      	strh	r3, [r7, #14]
    for (c = 0; c < max_c; ) {
 8016954:	f04f 0300 	mov.w	r3, #0
 8016958:	82fb      	strh	r3, [r7, #22]
 801695a:	e056      	b.n	8016a0a <tcp_parseopt+0x116>
      opt = opts[c];
 801695c:	8afb      	ldrh	r3, [r7, #22]
 801695e:	693a      	ldr	r2, [r7, #16]
 8016960:	18d3      	adds	r3, r2, r3
 8016962:	781b      	ldrb	r3, [r3, #0]
 8016964:	737b      	strb	r3, [r7, #13]
      switch (opt) {
 8016966:	7b7b      	ldrb	r3, [r7, #13]
 8016968:	2b01      	cmp	r3, #1
 801696a:	d004      	beq.n	8016976 <tcp_parseopt+0x82>
 801696c:	2b02      	cmp	r3, #2
 801696e:	d007      	beq.n	8016980 <tcp_parseopt+0x8c>
 8016970:	2b00      	cmp	r3, #0
 8016972:	d04f      	beq.n	8016a14 <tcp_parseopt+0x120>
 8016974:	e037      	b.n	80169e6 <tcp_parseopt+0xf2>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
 8016976:	8afb      	ldrh	r3, [r7, #22]
 8016978:	f103 0301 	add.w	r3, r3, #1
 801697c:	82fb      	strh	r3, [r7, #22]
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
 801697e:	e044      	b.n	8016a0a <tcp_parseopt+0x116>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 8016980:	8afb      	ldrh	r3, [r7, #22]
 8016982:	f103 0301 	add.w	r3, r3, #1
 8016986:	693a      	ldr	r2, [r7, #16]
 8016988:	18d3      	adds	r3, r2, r3
 801698a:	781b      	ldrb	r3, [r3, #0]
 801698c:	2b04      	cmp	r3, #4
 801698e:	d143      	bne.n	8016a18 <tcp_parseopt+0x124>
 8016990:	8afb      	ldrh	r3, [r7, #22]
 8016992:	f103 0204 	add.w	r2, r3, #4
 8016996:	89fb      	ldrh	r3, [r7, #14]
 8016998:	429a      	cmp	r2, r3
 801699a:	dc3d      	bgt.n	8016a18 <tcp_parseopt+0x124>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 801699c:	8afb      	ldrh	r3, [r7, #22]
 801699e:	f103 0302 	add.w	r3, r3, #2
 80169a2:	693a      	ldr	r2, [r7, #16]
 80169a4:	18d3      	adds	r3, r2, r3
 80169a6:	781b      	ldrb	r3, [r3, #0]
 80169a8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80169ac:	b29a      	uxth	r2, r3
 80169ae:	8afb      	ldrh	r3, [r7, #22]
 80169b0:	f103 0303 	add.w	r3, r3, #3
 80169b4:	6939      	ldr	r1, [r7, #16]
 80169b6:	18cb      	adds	r3, r1, r3
 80169b8:	781b      	ldrb	r3, [r3, #0]
 80169ba:	4313      	orrs	r3, r2
 80169bc:	b29b      	uxth	r3, r3
 80169be:	817b      	strh	r3, [r7, #10]
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 80169c0:	897a      	ldrh	r2, [r7, #10]
 80169c2:	f240 53a6 	movw	r3, #1446	; 0x5a6
 80169c6:	429a      	cmp	r2, r3
 80169c8:	d804      	bhi.n	80169d4 <tcp_parseopt+0xe0>
 80169ca:	897b      	ldrh	r3, [r7, #10]
 80169cc:	2b00      	cmp	r3, #0
 80169ce:	d001      	beq.n	80169d4 <tcp_parseopt+0xe0>
 80169d0:	897b      	ldrh	r3, [r7, #10]
 80169d2:	e001      	b.n	80169d8 <tcp_parseopt+0xe4>
 80169d4:	f240 53a6 	movw	r3, #1446	; 0x5a6
 80169d8:	687a      	ldr	r2, [r7, #4]
 80169da:	8713      	strh	r3, [r2, #56]	; 0x38
        /* Advance to next option */
        c += 0x04;
 80169dc:	8afb      	ldrh	r3, [r7, #22]
 80169de:	f103 0304 	add.w	r3, r3, #4
 80169e2:	82fb      	strh	r3, [r7, #22]
        break;
 80169e4:	e011      	b.n	8016a0a <tcp_parseopt+0x116>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 80169e6:	8afb      	ldrh	r3, [r7, #22]
 80169e8:	f103 0301 	add.w	r3, r3, #1
 80169ec:	693a      	ldr	r2, [r7, #16]
 80169ee:	18d3      	adds	r3, r2, r3
 80169f0:	781b      	ldrb	r3, [r3, #0]
 80169f2:	2b00      	cmp	r3, #0
 80169f4:	d012      	beq.n	8016a1c <tcp_parseopt+0x128>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 80169f6:	8afb      	ldrh	r3, [r7, #22]
 80169f8:	f103 0301 	add.w	r3, r3, #1
 80169fc:	693a      	ldr	r2, [r7, #16]
 80169fe:	18d3      	adds	r3, r2, r3
 8016a00:	781b      	ldrb	r3, [r3, #0]
 8016a02:	461a      	mov	r2, r3
 8016a04:	8afb      	ldrh	r3, [r7, #22]
 8016a06:	18d3      	adds	r3, r2, r3
 8016a08:	82fb      	strh	r3, [r7, #22]
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
 8016a0a:	8afa      	ldrh	r2, [r7, #22]
 8016a0c:	89fb      	ldrh	r3, [r7, #14]
 8016a0e:	429a      	cmp	r2, r3
 8016a10:	d3a4      	bcc.n	801695c <tcp_parseopt+0x68>
 8016a12:	e004      	b.n	8016a1e <tcp_parseopt+0x12a>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
 8016a14:	bf00      	nop
 8016a16:	e002      	b.n	8016a1e <tcp_parseopt+0x12a>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
 8016a18:	bf00      	nop
 8016a1a:	e000      	b.n	8016a1e <tcp_parseopt+0x12a>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
 8016a1c:	bf00      	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
 8016a1e:	f107 0718 	add.w	r7, r7, #24
 8016a22:	46bd      	mov	sp, r7
 8016a24:	bd80      	pop	{r7, pc}
 8016a26:	bf00      	nop

08016a28 <tcp_output_set_header>:
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);

static struct tcp_hdr *
tcp_output_set_header(struct tcp_pcb *pcb, struct pbuf *p, int optlen,
                      u32_t seqno_be /* already in network byte order */)
{
 8016a28:	b590      	push	{r4, r7, lr}
 8016a2a:	b087      	sub	sp, #28
 8016a2c:	af00      	add	r7, sp, #0
 8016a2e:	60f8      	str	r0, [r7, #12]
 8016a30:	60b9      	str	r1, [r7, #8]
 8016a32:	607a      	str	r2, [r7, #4]
 8016a34:	603b      	str	r3, [r7, #0]
  struct tcp_hdr *tcphdr = p->payload;
 8016a36:	68bb      	ldr	r3, [r7, #8]
 8016a38:	685b      	ldr	r3, [r3, #4]
 8016a3a:	617b      	str	r3, [r7, #20]
  tcphdr->src = htons(pcb->local_port);
 8016a3c:	68fb      	ldr	r3, [r7, #12]
 8016a3e:	8b1b      	ldrh	r3, [r3, #24]
 8016a40:	4618      	mov	r0, r3
 8016a42:	f002 fb89 	bl	8019158 <htons>
 8016a46:	4603      	mov	r3, r0
 8016a48:	461a      	mov	r2, r3
 8016a4a:	697b      	ldr	r3, [r7, #20]
 8016a4c:	801a      	strh	r2, [r3, #0]
  tcphdr->dest = htons(pcb->remote_port);
 8016a4e:	68fb      	ldr	r3, [r7, #12]
 8016a50:	8c1b      	ldrh	r3, [r3, #32]
 8016a52:	4618      	mov	r0, r3
 8016a54:	f002 fb80 	bl	8019158 <htons>
 8016a58:	4603      	mov	r3, r0
 8016a5a:	461a      	mov	r2, r3
 8016a5c:	697b      	ldr	r3, [r7, #20]
 8016a5e:	805a      	strh	r2, [r3, #2]
  tcphdr->seqno = seqno_be;
 8016a60:	697b      	ldr	r3, [r7, #20]
 8016a62:	683a      	ldr	r2, [r7, #0]
 8016a64:	605a      	str	r2, [r3, #4]
  tcphdr->ackno = htonl(pcb->rcv_nxt);
 8016a66:	68fb      	ldr	r3, [r7, #12]
 8016a68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016a6a:	4618      	mov	r0, r3
 8016a6c:	f002 fb9c 	bl	80191a8 <htonl>
 8016a70:	4602      	mov	r2, r0
 8016a72:	697b      	ldr	r3, [r7, #20]
 8016a74:	609a      	str	r2, [r3, #8]
  TCPH_FLAGS_SET(tcphdr, TCP_ACK);
 8016a76:	697b      	ldr	r3, [r7, #20]
 8016a78:	899b      	ldrh	r3, [r3, #12]
 8016a7a:	b29c      	uxth	r4, r3
 8016a7c:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 8016a80:	f002 fb6a 	bl	8019158 <htons>
 8016a84:	4603      	mov	r3, r0
 8016a86:	4023      	ands	r3, r4
 8016a88:	b29c      	uxth	r4, r3
 8016a8a:	f04f 0010 	mov.w	r0, #16
 8016a8e:	f002 fb63 	bl	8019158 <htons>
 8016a92:	4603      	mov	r3, r0
 8016a94:	4323      	orrs	r3, r4
 8016a96:	b29a      	uxth	r2, r3
 8016a98:	697b      	ldr	r3, [r7, #20]
 8016a9a:	819a      	strh	r2, [r3, #12]
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8016a9c:	68fb      	ldr	r3, [r7, #12]
 8016a9e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8016aa0:	4618      	mov	r0, r3
 8016aa2:	f002 fb59 	bl	8019158 <htons>
 8016aa6:	4603      	mov	r3, r0
 8016aa8:	461a      	mov	r2, r3
 8016aaa:	697b      	ldr	r3, [r7, #20]
 8016aac:	81da      	strh	r2, [r3, #14]
  tcphdr->urgp = 0;
 8016aae:	697b      	ldr	r3, [r7, #20]
 8016ab0:	f04f 0200 	mov.w	r2, #0
 8016ab4:	749a      	strb	r2, [r3, #18]
 8016ab6:	f04f 0200 	mov.w	r2, #0
 8016aba:	74da      	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, (5 + optlen / 4));
 8016abc:	687b      	ldr	r3, [r7, #4]
 8016abe:	2b00      	cmp	r3, #0
 8016ac0:	da01      	bge.n	8016ac6 <tcp_output_set_header+0x9e>
 8016ac2:	f103 0303 	add.w	r3, r3, #3
 8016ac6:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8016aca:	b29b      	uxth	r3, r3
 8016acc:	f103 0305 	add.w	r3, r3, #5
 8016ad0:	b29b      	uxth	r3, r3
 8016ad2:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8016ad6:	b29c      	uxth	r4, r3
 8016ad8:	697b      	ldr	r3, [r7, #20]
 8016ada:	899b      	ldrh	r3, [r3, #12]
 8016adc:	b29b      	uxth	r3, r3
 8016ade:	4618      	mov	r0, r3
 8016ae0:	f002 fb52 	bl	8019188 <ntohs>
 8016ae4:	4603      	mov	r3, r0
 8016ae6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8016aea:	b29b      	uxth	r3, r3
 8016aec:	4323      	orrs	r3, r4
 8016aee:	b29b      	uxth	r3, r3
 8016af0:	4618      	mov	r0, r3
 8016af2:	f002 fb31 	bl	8019158 <htons>
 8016af6:	4603      	mov	r3, r0
 8016af8:	461a      	mov	r2, r3
 8016afa:	697b      	ldr	r3, [r7, #20]
 8016afc:	819a      	strh	r2, [r3, #12]
  tcphdr->chksum = 0;
 8016afe:	697b      	ldr	r3, [r7, #20]
 8016b00:	f04f 0200 	mov.w	r2, #0
 8016b04:	741a      	strb	r2, [r3, #16]
 8016b06:	f04f 0200 	mov.w	r2, #0
 8016b0a:	745a      	strb	r2, [r3, #17]

  /* If we're sending a packet, update the announced right window edge */
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8016b0c:	68fb      	ldr	r3, [r7, #12]
 8016b0e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8016b10:	68fb      	ldr	r3, [r7, #12]
 8016b12:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8016b14:	18d2      	adds	r2, r2, r3
 8016b16:	68fb      	ldr	r3, [r7, #12]
 8016b18:	62da      	str	r2, [r3, #44]	; 0x2c

  return tcphdr;
 8016b1a:	697b      	ldr	r3, [r7, #20]
}
 8016b1c:	4618      	mov	r0, r3
 8016b1e:	f107 071c 	add.w	r7, r7, #28
 8016b22:	46bd      	mov	sp, r7
 8016b24:	bd90      	pop	{r4, r7, pc}
 8016b26:	bf00      	nop

08016b28 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
 8016b28:	b580      	push	{r7, lr}
 8016b2a:	b084      	sub	sp, #16
 8016b2c:	af02      	add	r7, sp, #8
 8016b2e:	6078      	str	r0, [r7, #4]
 8016b30:	460b      	mov	r3, r1
 8016b32:	70fb      	strb	r3, [r7, #3]
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, 0);
 8016b34:	78fb      	ldrb	r3, [r7, #3]
 8016b36:	f04f 0201 	mov.w	r2, #1
 8016b3a:	9200      	str	r2, [sp, #0]
 8016b3c:	f04f 0200 	mov.w	r2, #0
 8016b40:	9201      	str	r2, [sp, #4]
 8016b42:	6878      	ldr	r0, [r7, #4]
 8016b44:	f04f 0100 	mov.w	r1, #0
 8016b48:	f04f 0200 	mov.w	r2, #0
 8016b4c:	f000 f83a 	bl	8016bc4 <tcp_enqueue>
 8016b50:	4603      	mov	r3, r0
}
 8016b52:	4618      	mov	r0, r3
 8016b54:	f107 0708 	add.w	r7, r7, #8
 8016b58:	46bd      	mov	sp, r7
 8016b5a:	bd80      	pop	{r7, pc}

08016b5c <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
 8016b5c:	b580      	push	{r7, lr}
 8016b5e:	b086      	sub	sp, #24
 8016b60:	af02      	add	r7, sp, #8
 8016b62:	60f8      	str	r0, [r7, #12]
 8016b64:	60b9      	str	r1, [r7, #8]
 8016b66:	80fa      	strh	r2, [r7, #6]
 8016b68:	717b      	strb	r3, [r7, #5]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
 8016b6a:	68fb      	ldr	r3, [r7, #12]
 8016b6c:	7c1b      	ldrb	r3, [r3, #16]
 8016b6e:	2b04      	cmp	r3, #4
 8016b70:	d00b      	beq.n	8016b8a <tcp_write+0x2e>
     pcb->state == CLOSE_WAIT ||
 8016b72:	68fb      	ldr	r3, [r7, #12]
 8016b74:	7c1b      	ldrb	r3, [r3, #16]
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
 8016b76:	2b07      	cmp	r3, #7
 8016b78:	d007      	beq.n	8016b8a <tcp_write+0x2e>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
 8016b7a:	68fb      	ldr	r3, [r7, #12]
 8016b7c:	7c1b      	ldrb	r3, [r3, #16]
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
 8016b7e:	2b02      	cmp	r3, #2
 8016b80:	d003      	beq.n	8016b8a <tcp_write+0x2e>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
 8016b82:	68fb      	ldr	r3, [r7, #12]
 8016b84:	7c1b      	ldrb	r3, [r3, #16]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
 8016b86:	2b03      	cmp	r3, #3
 8016b88:	d114      	bne.n	8016bb4 <tcp_write+0x58>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
 8016b8a:	88fb      	ldrh	r3, [r7, #6]
 8016b8c:	2b00      	cmp	r3, #0
 8016b8e:	d00e      	beq.n	8016bae <tcp_write+0x52>
#if LWIP_TCP_TIMESTAMPS
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 
                         pcb->flags & TF_TIMESTAMP ? TF_SEG_OPTS_TS : 0);
#else
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, 0);
 8016b90:	88fb      	ldrh	r3, [r7, #6]
 8016b92:	797a      	ldrb	r2, [r7, #5]
 8016b94:	9200      	str	r2, [sp, #0]
 8016b96:	f04f 0200 	mov.w	r2, #0
 8016b9a:	9201      	str	r2, [sp, #4]
 8016b9c:	68f8      	ldr	r0, [r7, #12]
 8016b9e:	68b9      	ldr	r1, [r7, #8]
 8016ba0:	461a      	mov	r2, r3
 8016ba2:	f04f 0300 	mov.w	r3, #0
 8016ba6:	f000 f80d 	bl	8016bc4 <tcp_enqueue>
 8016baa:	4603      	mov	r3, r0
 8016bac:	e004      	b.n	8016bb8 <tcp_write+0x5c>
#endif
    }
    return ERR_OK;
 8016bae:	f04f 0300 	mov.w	r3, #0
 8016bb2:	e001      	b.n	8016bb8 <tcp_write+0x5c>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 8016bb4:	f04f 03f8 	mov.w	r3, #248	; 0xf8
 8016bb8:	b25b      	sxtb	r3, r3
  }
}
 8016bba:	4618      	mov	r0, r3
 8016bbc:	f107 0710 	add.w	r7, r7, #16
 8016bc0:	46bd      	mov	sp, r7
 8016bc2:	bd80      	pop	{r7, pc}

08016bc4 <tcp_enqueue>:
 * @param optflags options to include in segment later on (see definition of struct tcp_seg)
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
            u8_t flags, u8_t apiflags, u8_t optflags)
{
 8016bc4:	b5b0      	push	{r4, r5, r7, lr}
 8016bc6:	b08e      	sub	sp, #56	; 0x38
 8016bc8:	af00      	add	r7, sp, #0
 8016bca:	60f8      	str	r0, [r7, #12]
 8016bcc:	60b9      	str	r1, [r7, #8]
 8016bce:	80fa      	strh	r2, [r7, #6]
 8016bd0:	717b      	strb	r3, [r7, #5]
  u8_t optlen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
               (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: packet needs payload, options, or SYN/FIN (programmer violates API)",
 8016bd2:	88fb      	ldrh	r3, [r7, #6]
 8016bd4:	2b00      	cmp	r3, #0
 8016bd6:	d10b      	bne.n	8016bf0 <tcp_enqueue+0x2c>
 8016bd8:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 8016bdc:	2b00      	cmp	r3, #0
 8016bde:	d107      	bne.n	8016bf0 <tcp_enqueue+0x2c>
 8016be0:	797b      	ldrb	r3, [r7, #5]
 8016be2:	f003 0303 	and.w	r3, r3, #3
 8016be6:	2b00      	cmp	r3, #0
 8016be8:	d102      	bne.n	8016bf0 <tcp_enqueue+0x2c>
 8016bea:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 8016bee:	e2ea      	b.n	80171c6 <tcp_enqueue+0x602>
             ((len != 0) || (optflags != 0) || ((flags & (TCP_SYN | TCP_FIN)) != 0)),
             return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: len != 0 || arg == NULL (programmer violates API)", 
 8016bf0:	88fb      	ldrh	r3, [r7, #6]
 8016bf2:	2b00      	cmp	r3, #0
 8016bf4:	d105      	bne.n	8016c02 <tcp_enqueue+0x3e>
 8016bf6:	68bb      	ldr	r3, [r7, #8]
 8016bf8:	2b00      	cmp	r3, #0
 8016bfa:	d002      	beq.n	8016c02 <tcp_enqueue+0x3e>
 8016bfc:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 8016c00:	e2e1      	b.n	80171c6 <tcp_enqueue+0x602>
             ((len != 0) || (arg == NULL)), return ERR_ARG;);

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 8016c02:	68fb      	ldr	r3, [r7, #12]
 8016c04:	f8b3 306e 	ldrh.w	r3, [r3, #110]	; 0x6e
 8016c08:	88fa      	ldrh	r2, [r7, #6]
 8016c0a:	429a      	cmp	r2, r3
 8016c0c:	d90b      	bls.n	8016c26 <tcp_enqueue+0x62>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
 8016c0e:	68fb      	ldr	r3, [r7, #12]
 8016c10:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8016c14:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8016c18:	b2da      	uxtb	r2, r3
 8016c1a:	68fb      	ldr	r3, [r7, #12]
 8016c1c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    return ERR_MEM;
 8016c20:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8016c24:	e2cf      	b.n	80171c6 <tcp_enqueue+0x602>
  }
  left = len;
 8016c26:	88fb      	ldrh	r3, [r7, #6]
 8016c28:	84fb      	strh	r3, [r7, #38]	; 0x26
  ptr = arg;
 8016c2a:	68bb      	ldr	r3, [r7, #8]
 8016c2c:	623b      	str	r3, [r7, #32]

  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 8016c2e:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 8016c32:	f003 0301 	and.w	r3, r3, #1
 8016c36:	2b00      	cmp	r3, #0
 8016c38:	d002      	beq.n	8016c40 <tcp_enqueue+0x7c>
 8016c3a:	f04f 0204 	mov.w	r2, #4
 8016c3e:	e001      	b.n	8016c44 <tcp_enqueue+0x80>
 8016c40:	f04f 0200 	mov.w	r2, #0
 8016c44:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 8016c48:	f003 0302 	and.w	r3, r3, #2
 8016c4c:	2b00      	cmp	r3, #0
 8016c4e:	d002      	beq.n	8016c56 <tcp_enqueue+0x92>
 8016c50:	f04f 030c 	mov.w	r3, #12
 8016c54:	e001      	b.n	8016c5a <tcp_enqueue+0x96>
 8016c56:	f04f 0300 	mov.w	r3, #0
 8016c5a:	18d3      	adds	r3, r2, r3
 8016c5c:	777b      	strb	r3, [r7, #29]

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
 8016c5e:	68fb      	ldr	r3, [r7, #12]
 8016c60:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8016c62:	62bb      	str	r3, [r7, #40]	; 0x28

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
 8016c64:	68fb      	ldr	r3, [r7, #12]
 8016c66:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 8016c6a:	83fb      	strh	r3, [r7, #30]
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8016c6c:	8bfb      	ldrh	r3, [r7, #30]
 8016c6e:	2b0b      	cmp	r3, #11
 8016c70:	d804      	bhi.n	8016c7c <tcp_enqueue+0xb8>
 8016c72:	8bfa      	ldrh	r2, [r7, #30]
 8016c74:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8016c78:	429a      	cmp	r2, r3
 8016c7a:	d90b      	bls.n	8016c94 <tcp_enqueue+0xd0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_WARNING,
      ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
 8016c7c:	68fb      	ldr	r3, [r7, #12]
 8016c7e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8016c82:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8016c86:	b2da      	uxtb	r2, r3
 8016c88:	68fb      	ldr	r3, [r7, #12]
 8016c8a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    return ERR_MEM;
 8016c8e:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8016c92:	e298      	b.n	80171c6 <tcp_enqueue+0x602>
  }
  if (queuelen != 0) {
 8016c94:	8bfb      	ldrh	r3, [r7, #30]
 8016c96:	2b00      	cmp	r3, #0
 8016c98:	d003      	beq.n	8016ca2 <tcp_enqueue+0xde>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
 8016c9a:	68fb      	ldr	r3, [r7, #12]
 8016c9c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8016c9e:	2b00      	cmp	r3, #0
 8016ca0:	e002      	b.n	8016ca8 <tcp_enqueue+0xe4>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
 8016ca2:	68fb      	ldr	r3, [r7, #12]
 8016ca4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8016ca6:	2b00      	cmp	r3, #0
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
 8016ca8:	f04f 0300 	mov.w	r3, #0
 8016cac:	637b      	str	r3, [r7, #52]	; 0x34
 8016cae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cb0:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016cb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016cb4:	633b      	str	r3, [r7, #48]	; 0x30
  seglen = 0;
 8016cb6:	f04f 0300 	mov.w	r3, #0
 8016cba:	84bb      	strh	r3, [r7, #36]	; 0x24
  while (queue == NULL || left > 0) {
 8016cbc:	e12a      	b.n	8016f14 <tcp_enqueue+0x350>
    /* The segment length (including options) should be at most the MSS */
    seglen = left > (pcb->mss - optlen) ? (pcb->mss - optlen) : left;
 8016cbe:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8016cc0:	68fb      	ldr	r3, [r7, #12]
 8016cc2:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8016cc4:	4619      	mov	r1, r3
 8016cc6:	7f7b      	ldrb	r3, [r7, #29]
 8016cc8:	1acb      	subs	r3, r1, r3
 8016cca:	429a      	cmp	r2, r3
 8016ccc:	bfb8      	it	lt
 8016cce:	4613      	movlt	r3, r2
 8016cd0:	84bb      	strh	r3, [r7, #36]	; 0x24

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
 8016cd2:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8016cd6:	f6c0 0302 	movt	r3, #2050	; 0x802
 8016cda:	891b      	ldrh	r3, [r3, #8]
 8016cdc:	4618      	mov	r0, r3
 8016cde:	f7fb fa17 	bl	8012110 <mem_malloc>
 8016ce2:	6378      	str	r0, [r7, #52]	; 0x34
    if (seg == NULL) {
 8016ce4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016ce6:	2b00      	cmp	r3, #0
 8016ce8:	f000 824b 	beq.w	8017182 <tcp_enqueue+0x5be>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                  ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
 8016cec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cee:	f04f 0200 	mov.w	r2, #0
 8016cf2:	601a      	str	r2, [r3, #0]
    seg->p = NULL;
 8016cf4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016cf6:	f04f 0200 	mov.w	r2, #0
 8016cfa:	605a      	str	r2, [r3, #4]

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 8016cfc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016cfe:	2b00      	cmp	r3, #0
 8016d00:	d102      	bne.n	8016d08 <tcp_enqueue+0x144>
      queue = seg;
 8016d02:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d04:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016d06:	e002      	b.n	8016d0e <tcp_enqueue+0x14a>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
      useg->next = seg;
 8016d08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d0a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016d0c:	601a      	str	r2, [r3, #0]
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
 8016d0e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d10:	633b      	str	r3, [r7, #48]	; 0x30

    /* If copy is set, memory should be allocated
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied.  */
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 8016d12:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8016d16:	f003 0301 	and.w	r3, r3, #1
 8016d1a:	2b00      	cmp	r3, #0
 8016d1c:	d031      	beq.n	8016d82 <tcp_enqueue+0x1be>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
 8016d1e:	7f7b      	ldrb	r3, [r7, #29]
 8016d20:	b29a      	uxth	r2, r3
 8016d22:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016d24:	18d3      	adds	r3, r2, r3
 8016d26:	b29b      	uxth	r3, r3
 8016d28:	f04f 0000 	mov.w	r0, #0
 8016d2c:	4619      	mov	r1, r3
 8016d2e:	f04f 0200 	mov.w	r2, #0
 8016d32:	f7fb febd 	bl	8012ab0 <pbuf_alloc>
 8016d36:	4602      	mov	r2, r0
 8016d38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d3a:	605a      	str	r2, [r3, #4]
 8016d3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d3e:	685b      	ldr	r3, [r3, #4]
 8016d40:	2b00      	cmp	r3, #0
 8016d42:	f000 8220 	beq.w	8017186 <tcp_enqueue+0x5c2>
                    ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen + optlen));
      queuelen += pbuf_clen(seg->p);
 8016d46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d48:	685b      	ldr	r3, [r3, #4]
 8016d4a:	4618      	mov	r0, r3
 8016d4c:	f7fc f90c 	bl	8012f68 <pbuf_clen>
 8016d50:	4603      	mov	r3, r0
 8016d52:	461a      	mov	r2, r3
 8016d54:	8bfb      	ldrh	r3, [r7, #30]
 8016d56:	18d3      	adds	r3, r2, r3
 8016d58:	83fb      	strh	r3, [r7, #30]
      if (arg != NULL) {
 8016d5a:	68bb      	ldr	r3, [r7, #8]
 8016d5c:	2b00      	cmp	r3, #0
 8016d5e:	d00a      	beq.n	8016d76 <tcp_enqueue+0x1b2>
        MEMCPY((char *)seg->p->payload + optlen, ptr, seglen);
 8016d60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d62:	685b      	ldr	r3, [r3, #4]
 8016d64:	685a      	ldr	r2, [r3, #4]
 8016d66:	7f7b      	ldrb	r3, [r7, #29]
 8016d68:	18d2      	adds	r2, r2, r3
 8016d6a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016d6c:	4610      	mov	r0, r2
 8016d6e:	6a39      	ldr	r1, [r7, #32]
 8016d70:	461a      	mov	r2, r3
 8016d72:	f00c fc4f 	bl	8023614 <memcpy>
      }
      seg->dataptr = seg->p->payload;
 8016d76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d78:	685b      	ldr	r3, [r3, #4]
 8016d7a:	685a      	ldr	r2, [r3, #4]
 8016d7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d7e:	609a      	str	r2, [r3, #8]
 8016d80:	e046      	b.n	8016e10 <tcp_enqueue+0x24c>
    }
    /* do not copy data */
    else {
      /* First, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8016d82:	7f7b      	ldrb	r3, [r7, #29]
 8016d84:	b29b      	uxth	r3, r3
 8016d86:	f04f 0000 	mov.w	r0, #0
 8016d8a:	4619      	mov	r1, r3
 8016d8c:	f04f 0200 	mov.w	r2, #0
 8016d90:	f7fb fe8e 	bl	8012ab0 <pbuf_alloc>
 8016d94:	4602      	mov	r2, r0
 8016d96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d98:	605a      	str	r2, [r3, #4]
 8016d9a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d9c:	685b      	ldr	r3, [r3, #4]
 8016d9e:	2b00      	cmp	r3, #0
 8016da0:	f000 81f3 	beq.w	801718a <tcp_enqueue+0x5c6>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      queuelen += pbuf_clen(seg->p);
 8016da4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016da6:	685b      	ldr	r3, [r3, #4]
 8016da8:	4618      	mov	r0, r3
 8016daa:	f7fc f8dd 	bl	8012f68 <pbuf_clen>
 8016dae:	4603      	mov	r3, r0
 8016db0:	461a      	mov	r2, r3
 8016db2:	8bfb      	ldrh	r3, [r7, #30]
 8016db4:	18d3      	adds	r3, r2, r3
 8016db6:	83fb      	strh	r3, [r7, #30]
      /* Second, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if (left > 0) {
 8016db8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8016dba:	2b00      	cmp	r3, #0
 8016dbc:	d028      	beq.n	8016e10 <tcp_enqueue+0x24c>
        if ((p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 8016dbe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016dc0:	f04f 0003 	mov.w	r0, #3
 8016dc4:	4619      	mov	r1, r3
 8016dc6:	f04f 0201 	mov.w	r2, #1
 8016dca:	f7fb fe71 	bl	8012ab0 <pbuf_alloc>
 8016dce:	6178      	str	r0, [r7, #20]
 8016dd0:	697b      	ldr	r3, [r7, #20]
 8016dd2:	2b00      	cmp	r3, #0
 8016dd4:	d109      	bne.n	8016dea <tcp_enqueue+0x226>
          /* If allocation fails, we have to deallocate the header pbuf as well. */
          pbuf_free(seg->p);
 8016dd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016dd8:	685b      	ldr	r3, [r3, #4]
 8016dda:	4618      	mov	r0, r3
 8016ddc:	f7fc f870 	bl	8012ec0 <pbuf_free>
          seg->p = NULL;
 8016de0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016de2:	f04f 0200 	mov.w	r2, #0
 8016de6:	605a      	str	r2, [r3, #4]
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                      ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
 8016de8:	e1d4      	b.n	8017194 <tcp_enqueue+0x5d0>
        }
        ++queuelen;
 8016dea:	8bfb      	ldrh	r3, [r7, #30]
 8016dec:	f103 0301 	add.w	r3, r3, #1
 8016df0:	83fb      	strh	r3, [r7, #30]
        /* reference the non-volatile payload data */
        p->payload = ptr;
 8016df2:	697b      	ldr	r3, [r7, #20]
 8016df4:	6a3a      	ldr	r2, [r7, #32]
 8016df6:	605a      	str	r2, [r3, #4]
        seg->dataptr = ptr;
 8016df8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016dfa:	6a3a      	ldr	r2, [r7, #32]
 8016dfc:	609a      	str	r2, [r3, #8]

        /* Concatenate the headers and data pbufs together. */
        pbuf_cat(seg->p/*header*/, p/*data*/);
 8016dfe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e00:	685b      	ldr	r3, [r3, #4]
 8016e02:	4618      	mov	r0, r3
 8016e04:	6979      	ldr	r1, [r7, #20]
 8016e06:	f7fc f8dd 	bl	8012fc4 <pbuf_cat>
        p = NULL;
 8016e0a:	f04f 0300 	mov.w	r3, #0
 8016e0e:	617b      	str	r3, [r7, #20]
      }
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8016e10:	8bfb      	ldrh	r3, [r7, #30]
 8016e12:	2b0c      	cmp	r3, #12
 8016e14:	f200 81be 	bhi.w	8017194 <tcp_enqueue+0x5d0>
 8016e18:	8bfa      	ldrh	r2, [r7, #30]
 8016e1a:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 8016e1e:	429a      	cmp	r2, r3
 8016e20:	f200 81b8 	bhi.w	8017194 <tcp_enqueue+0x5d0>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
 8016e24:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e26:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8016e28:	819a      	strh	r2, [r3, #12]

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
 8016e2a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e2c:	685b      	ldr	r3, [r3, #4]
 8016e2e:	4618      	mov	r0, r3
 8016e30:	f04f 0114 	mov.w	r1, #20
 8016e34:	f7fb ffca 	bl	8012dcc <pbuf_header>
 8016e38:	4603      	mov	r3, r0
 8016e3a:	2b00      	cmp	r3, #0
 8016e3c:	f040 81a7 	bne.w	801718e <tcp_enqueue+0x5ca>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
 8016e40:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e42:	685b      	ldr	r3, [r3, #4]
 8016e44:	685a      	ldr	r2, [r3, #4]
 8016e46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e48:	611a      	str	r2, [r3, #16]
    seg->tcphdr->src = htons(pcb->local_port);
 8016e4a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e4c:	691c      	ldr	r4, [r3, #16]
 8016e4e:	68fb      	ldr	r3, [r7, #12]
 8016e50:	8b1b      	ldrh	r3, [r3, #24]
 8016e52:	4618      	mov	r0, r3
 8016e54:	f002 f980 	bl	8019158 <htons>
 8016e58:	4603      	mov	r3, r0
 8016e5a:	8023      	strh	r3, [r4, #0]
    seg->tcphdr->dest = htons(pcb->remote_port);
 8016e5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e5e:	691c      	ldr	r4, [r3, #16]
 8016e60:	68fb      	ldr	r3, [r7, #12]
 8016e62:	8c1b      	ldrh	r3, [r3, #32]
 8016e64:	4618      	mov	r0, r3
 8016e66:	f002 f977 	bl	8019158 <htons>
 8016e6a:	4603      	mov	r3, r0
 8016e6c:	8063      	strh	r3, [r4, #2]
    seg->tcphdr->seqno = htonl(seqno);
 8016e6e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e70:	691c      	ldr	r4, [r3, #16]
 8016e72:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8016e74:	f002 f998 	bl	80191a8 <htonl>
 8016e78:	4603      	mov	r3, r0
 8016e7a:	6063      	str	r3, [r4, #4]
    seg->tcphdr->urgp = 0;
 8016e7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e7e:	691b      	ldr	r3, [r3, #16]
 8016e80:	f04f 0200 	mov.w	r2, #0
 8016e84:	749a      	strb	r2, [r3, #18]
 8016e86:	f04f 0200 	mov.w	r2, #0
 8016e8a:	74da      	strb	r2, [r3, #19]
    TCPH_FLAGS_SET(seg->tcphdr, flags);
 8016e8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e8e:	691c      	ldr	r4, [r3, #16]
 8016e90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e92:	691b      	ldr	r3, [r3, #16]
 8016e94:	899b      	ldrh	r3, [r3, #12]
 8016e96:	b29d      	uxth	r5, r3
 8016e98:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 8016e9c:	f002 f95c 	bl	8019158 <htons>
 8016ea0:	4603      	mov	r3, r0
 8016ea2:	402b      	ands	r3, r5
 8016ea4:	b29d      	uxth	r5, r3
 8016ea6:	797b      	ldrb	r3, [r7, #5]
 8016ea8:	b29b      	uxth	r3, r3
 8016eaa:	4618      	mov	r0, r3
 8016eac:	f002 f954 	bl	8019158 <htons>
 8016eb0:	4603      	mov	r3, r0
 8016eb2:	432b      	orrs	r3, r5
 8016eb4:	b29b      	uxth	r3, r3
 8016eb6:	81a3      	strh	r3, [r4, #12]
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    seg->flags = optflags;
 8016eb8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016eba:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8016ebe:	739a      	strb	r2, [r3, #14]

    /* Set the length of the header */
    TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
 8016ec0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016ec2:	691c      	ldr	r4, [r3, #16]
 8016ec4:	7f7b      	ldrb	r3, [r7, #29]
 8016ec6:	ea4f 0393 	mov.w	r3, r3, lsr #2
 8016eca:	b2db      	uxtb	r3, r3
 8016ecc:	f103 0305 	add.w	r3, r3, #5
 8016ed0:	b29b      	uxth	r3, r3
 8016ed2:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8016ed6:	b29d      	uxth	r5, r3
 8016ed8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016eda:	691b      	ldr	r3, [r3, #16]
 8016edc:	899b      	ldrh	r3, [r3, #12]
 8016ede:	b29b      	uxth	r3, r3
 8016ee0:	4618      	mov	r0, r3
 8016ee2:	f002 f951 	bl	8019188 <ntohs>
 8016ee6:	4603      	mov	r3, r0
 8016ee8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8016eec:	b29b      	uxth	r3, r3
 8016eee:	432b      	orrs	r3, r5
 8016ef0:	b29b      	uxth	r3, r3
 8016ef2:	4618      	mov	r0, r3
 8016ef4:	f002 f930 	bl	8019158 <htons>
 8016ef8:	4603      	mov	r3, r0
 8016efa:	81a3      	strh	r3, [r4, #12]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
 8016efc:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8016efe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016f00:	1ad3      	subs	r3, r2, r3
 8016f02:	84fb      	strh	r3, [r7, #38]	; 0x26
    seqno += seglen;
 8016f04:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016f06:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016f08:	18d3      	adds	r3, r2, r3
 8016f0a:	62bb      	str	r3, [r7, #40]	; 0x28
    ptr = (void *)((u8_t *)ptr + seglen);
 8016f0c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016f0e:	6a3a      	ldr	r2, [r7, #32]
 8016f10:	18d3      	adds	r3, r2, r3
 8016f12:	623b      	str	r3, [r7, #32]

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
 8016f14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f16:	2b00      	cmp	r3, #0
 8016f18:	f43f aed1 	beq.w	8016cbe <tcp_enqueue+0xfa>
 8016f1c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8016f1e:	2b00      	cmp	r3, #0
 8016f20:	f47f aecd 	bne.w	8016cbe <tcp_enqueue+0xfa>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
 8016f24:	68fb      	ldr	r3, [r7, #12]
 8016f26:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016f28:	2b00      	cmp	r3, #0
 8016f2a:	d103      	bne.n	8016f34 <tcp_enqueue+0x370>
    useg = NULL;
 8016f2c:	f04f 0300 	mov.w	r3, #0
 8016f30:	633b      	str	r3, [r7, #48]	; 0x30
 8016f32:	e00a      	b.n	8016f4a <tcp_enqueue+0x386>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8016f34:	68fb      	ldr	r3, [r7, #12]
 8016f36:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8016f38:	633b      	str	r3, [r7, #48]	; 0x30
 8016f3a:	e002      	b.n	8016f42 <tcp_enqueue+0x37e>
 8016f3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016f3e:	681b      	ldr	r3, [r3, #0]
 8016f40:	633b      	str	r3, [r7, #48]	; 0x30
 8016f42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016f44:	681b      	ldr	r3, [r3, #0]
 8016f46:	2b00      	cmp	r3, #0
 8016f48:	d1f8      	bne.n	8016f3c <tcp_enqueue+0x378>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
 8016f4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016f4c:	2b00      	cmp	r3, #0
 8016f4e:	f000 80b6 	beq.w	80170be <tcp_enqueue+0x4fa>
    TCP_TCPLEN(useg) != 0 &&
 8016f52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016f54:	899b      	ldrh	r3, [r3, #12]
 8016f56:	461c      	mov	r4, r3
 8016f58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016f5a:	691b      	ldr	r3, [r3, #16]
 8016f5c:	899b      	ldrh	r3, [r3, #12]
 8016f5e:	b29b      	uxth	r3, r3
 8016f60:	4618      	mov	r0, r3
 8016f62:	f002 f911 	bl	8019188 <ntohs>
 8016f66:	4603      	mov	r3, r0
 8016f68:	f003 0303 	and.w	r3, r3, #3
 8016f6c:	2b00      	cmp	r3, #0
 8016f6e:	bf0c      	ite	eq
 8016f70:	2300      	moveq	r3, #0
 8016f72:	2301      	movne	r3, #1
 8016f74:	b2db      	uxtb	r3, r3
 8016f76:	18e3      	adds	r3, r4, r3
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
 8016f78:	2b00      	cmp	r3, #0
 8016f7a:	f000 80a0 	beq.w	80170be <tcp_enqueue+0x4fa>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
 8016f7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016f80:	691b      	ldr	r3, [r3, #16]
 8016f82:	899b      	ldrh	r3, [r3, #12]
 8016f84:	b29b      	uxth	r3, r3
 8016f86:	4618      	mov	r0, r3
 8016f88:	f002 f8fe 	bl	8019188 <ntohs>
 8016f8c:	4603      	mov	r3, r0
 8016f8e:	f003 0303 	and.w	r3, r3, #3
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
 8016f92:	2b00      	cmp	r3, #0
 8016f94:	f040 8093 	bne.w	80170be <tcp_enqueue+0x4fa>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
 8016f98:	797b      	ldrb	r3, [r7, #5]
 8016f9a:	f003 0303 	and.w	r3, r3, #3

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
 8016f9e:	2b00      	cmp	r3, #0
 8016fa0:	d003      	beq.n	8016faa <tcp_enqueue+0x3e6>
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
 8016fa2:	797b      	ldrb	r3, [r7, #5]
 8016fa4:	2b01      	cmp	r3, #1
 8016fa6:	f040 808a 	bne.w	80170be <tcp_enqueue+0x4fa>
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
 8016faa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016fac:	899b      	ldrh	r3, [r3, #12]
 8016fae:	461a      	mov	r2, r3
 8016fb0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016fb2:	899b      	ldrh	r3, [r3, #12]
 8016fb4:	18d2      	adds	r2, r2, r3
 8016fb6:	68fb      	ldr	r3, [r7, #12]
 8016fb8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
 8016fba:	429a      	cmp	r2, r3
 8016fbc:	dc7f      	bgt.n	80170be <tcp_enqueue+0x4fa>
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
 8016fbe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016fc0:	7b9a      	ldrb	r2, [r3, #14]
 8016fc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016fc4:	7b9b      	ldrb	r3, [r3, #14]
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
 8016fc6:	429a      	cmp	r2, r3
 8016fc8:	d179      	bne.n	80170be <tcp_enqueue+0x4fa>
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
    /* segments are consecutive */
    (ntohl(useg->tcphdr->seqno) + useg->len == ntohl(queue->tcphdr->seqno)) ) {
 8016fca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016fcc:	691b      	ldr	r3, [r3, #16]
 8016fce:	685b      	ldr	r3, [r3, #4]
 8016fd0:	4618      	mov	r0, r3
 8016fd2:	f002 f907 	bl	80191e4 <ntohl>
 8016fd6:	4602      	mov	r2, r0
 8016fd8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016fda:	899b      	ldrh	r3, [r3, #12]
 8016fdc:	18d4      	adds	r4, r2, r3
 8016fde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016fe0:	691b      	ldr	r3, [r3, #16]
 8016fe2:	685b      	ldr	r3, [r3, #4]
 8016fe4:	4618      	mov	r0, r3
 8016fe6:	f002 f8fd 	bl	80191e4 <ntohl>
 8016fea:	4603      	mov	r3, r0
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    (!(flags & (TCP_SYN | TCP_FIN)) || (flags == TCP_FIN)) &&
    /* fit within max seg size */
    (useg->len + queue->len <= pcb->mss) &&
    /* only concatenate segments with the same options */
    (useg->flags == queue->flags) &&
 8016fec:	429c      	cmp	r4, r3
 8016fee:	d166      	bne.n	80170be <tcp_enqueue+0x4fa>
    /* segments are consecutive */
    (ntohl(useg->tcphdr->seqno) + useg->len == ntohl(queue->tcphdr->seqno)) ) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -(TCP_HLEN + optlen))) {
 8016ff0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ff2:	685a      	ldr	r2, [r3, #4]
 8016ff4:	7f7b      	ldrb	r3, [r7, #29]
 8016ff6:	b299      	uxth	r1, r3
 8016ff8:	f64f 73ec 	movw	r3, #65516	; 0xffec
 8016ffc:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8017000:	1a5b      	subs	r3, r3, r1
 8017002:	b29b      	uxth	r3, r3
 8017004:	b29b      	uxth	r3, r3
 8017006:	b21b      	sxth	r3, r3
 8017008:	4610      	mov	r0, r2
 801700a:	4619      	mov	r1, r3
 801700c:	f7fb fede 	bl	8012dcc <pbuf_header>
 8017010:	4603      	mov	r3, r0
 8017012:	2b00      	cmp	r3, #0
 8017014:	f040 80bd 	bne.w	8017192 <tcp_enqueue+0x5ce>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    if (queue->p->len == 0) {
 8017018:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801701a:	685b      	ldr	r3, [r3, #4]
 801701c:	895b      	ldrh	r3, [r3, #10]
 801701e:	2b00      	cmp	r3, #0
 8017020:	d112      	bne.n	8017048 <tcp_enqueue+0x484>
      /* free the first (header-only) pbuf if it is now empty (contained only headers) */
      struct pbuf *old_q = queue->p;
 8017022:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017024:	685b      	ldr	r3, [r3, #4]
 8017026:	61bb      	str	r3, [r7, #24]
      queue->p = queue->p->next;
 8017028:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801702a:	685b      	ldr	r3, [r3, #4]
 801702c:	681a      	ldr	r2, [r3, #0]
 801702e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017030:	605a      	str	r2, [r3, #4]
      old_q->next = NULL;
 8017032:	69bb      	ldr	r3, [r7, #24]
 8017034:	f04f 0200 	mov.w	r2, #0
 8017038:	601a      	str	r2, [r3, #0]
      queuelen--;
 801703a:	8bfb      	ldrh	r3, [r7, #30]
 801703c:	f103 33ff 	add.w	r3, r3, #4294967295
 8017040:	83fb      	strh	r3, [r7, #30]
      pbuf_free(old_q);
 8017042:	69b8      	ldr	r0, [r7, #24]
 8017044:	f7fb ff3c 	bl	8012ec0 <pbuf_free>
    }
    if (flags & TCP_FIN) {
 8017048:	797b      	ldrb	r3, [r7, #5]
 801704a:	f003 0301 	and.w	r3, r3, #1
 801704e:	2b00      	cmp	r3, #0
 8017050:	d011      	beq.n	8017076 <tcp_enqueue+0x4b2>
      /* the new segment contains only FIN, no data -> put the FIN into the last segment */
      LWIP_ASSERT("FIN enqueued together with data", queue->p == NULL && queue->len == 0);
 8017052:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017054:	685b      	ldr	r3, [r3, #4]
 8017056:	2b00      	cmp	r3, #0
      TCPH_SET_FLAG(useg->tcphdr, TCP_FIN);
 8017058:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801705a:	691c      	ldr	r4, [r3, #16]
 801705c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801705e:	691b      	ldr	r3, [r3, #16]
 8017060:	899b      	ldrh	r3, [r3, #12]
 8017062:	b29d      	uxth	r5, r3
 8017064:	f04f 0001 	mov.w	r0, #1
 8017068:	f002 f876 	bl	8019158 <htons>
 801706c:	4603      	mov	r3, r0
 801706e:	432b      	orrs	r3, r5
 8017070:	b29b      	uxth	r3, r3
 8017072:	81a3      	strh	r3, [r4, #12]
 8017074:	e016      	b.n	80170a4 <tcp_enqueue+0x4e0>
    } else {
      LWIP_ASSERT("zero-length pbuf", (queue->p != NULL) && (queue->p->len > 0));
 8017076:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017078:	685b      	ldr	r3, [r3, #4]
 801707a:	2b00      	cmp	r3, #0
      pbuf_cat(useg->p, queue->p);
 801707c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801707e:	685a      	ldr	r2, [r3, #4]
 8017080:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017082:	685b      	ldr	r3, [r3, #4]
 8017084:	4610      	mov	r0, r2
 8017086:	4619      	mov	r1, r3
 8017088:	f7fb ff9c 	bl	8012fc4 <pbuf_cat>
      useg->len += queue->len;
 801708c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801708e:	899a      	ldrh	r2, [r3, #12]
 8017090:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8017092:	899b      	ldrh	r3, [r3, #12]
 8017094:	18d3      	adds	r3, r2, r3
 8017096:	b29a      	uxth	r2, r3
 8017098:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801709a:	819a      	strh	r2, [r3, #12]
      useg->next = queue->next;
 801709c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801709e:	681a      	ldr	r2, [r3, #0]
 80170a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80170a2:	601a      	str	r2, [r3, #0]
    }

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
 80170a4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80170a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80170a8:	429a      	cmp	r2, r3
 80170aa:	d104      	bne.n	80170b6 <tcp_enqueue+0x4f2>
      seg = useg;
 80170ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80170ae:	637b      	str	r3, [r7, #52]	; 0x34
      seglen = useg->len;
 80170b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80170b2:	899b      	ldrh	r3, [r3, #12]
 80170b4:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    memp_free(MEMP_TCP_SEG, queue);
 80170b6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80170b8:	f7fa fefe 	bl	8011eb8 <mem_free>
 80170bc:	e009      	b.n	80170d2 <tcp_enqueue+0x50e>
  }
  else {
    /* empty list */
    if (useg == NULL) {
 80170be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80170c0:	2b00      	cmp	r3, #0
 80170c2:	d103      	bne.n	80170cc <tcp_enqueue+0x508>
      /* initialize list with this segment */
      pcb->unsent = queue;
 80170c4:	68fb      	ldr	r3, [r7, #12]
 80170c6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80170c8:	675a      	str	r2, [r3, #116]	; 0x74
 80170ca:	e002      	b.n	80170d2 <tcp_enqueue+0x50e>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
 80170cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80170ce:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80170d0:	601a      	str	r2, [r3, #0]
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 80170d2:	797b      	ldrb	r3, [r7, #5]
 80170d4:	f003 0302 	and.w	r3, r3, #2
 80170d8:	2b00      	cmp	r3, #0
 80170da:	d104      	bne.n	80170e6 <tcp_enqueue+0x522>
 80170dc:	797b      	ldrb	r3, [r7, #5]
 80170de:	f003 0301 	and.w	r3, r3, #1
 80170e2:	2b00      	cmp	r3, #0
 80170e4:	d003      	beq.n	80170ee <tcp_enqueue+0x52a>
    ++len;
 80170e6:	88fb      	ldrh	r3, [r7, #6]
 80170e8:	f103 0301 	add.w	r3, r3, #1
 80170ec:	80fb      	strh	r3, [r7, #6]
  }
  if (flags & TCP_FIN) {
 80170ee:	797b      	ldrb	r3, [r7, #5]
 80170f0:	f003 0301 	and.w	r3, r3, #1
 80170f4:	2b00      	cmp	r3, #0
 80170f6:	d008      	beq.n	801710a <tcp_enqueue+0x546>
    pcb->flags |= TF_FIN;
 80170f8:	68fb      	ldr	r3, [r7, #12]
 80170fa:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80170fe:	f043 0320 	orr.w	r3, r3, #32
 8017102:	b2da      	uxtb	r2, r3
 8017104:	68fb      	ldr	r3, [r7, #12]
 8017106:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
  pcb->snd_lbb += len;
 801710a:	68fb      	ldr	r3, [r7, #12]
 801710c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 801710e:	88fb      	ldrh	r3, [r7, #6]
 8017110:	18d2      	adds	r2, r2, r3
 8017112:	68fb      	ldr	r3, [r7, #12]
 8017114:	669a      	str	r2, [r3, #104]	; 0x68

  pcb->snd_buf -= len;
 8017116:	68fb      	ldr	r3, [r7, #12]
 8017118:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 801711c:	88fb      	ldrh	r3, [r7, #6]
 801711e:	1ad3      	subs	r3, r2, r3
 8017120:	b29a      	uxth	r2, r3
 8017122:	68fb      	ldr	r3, [r7, #12]
 8017124:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
 8017128:	68fb      	ldr	r3, [r7, #12]
 801712a:	8bfa      	ldrh	r2, [r7, #30]
 801712c:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 8017130:	68fb      	ldr	r3, [r7, #12]
 8017132:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 8017136:	2b00      	cmp	r3, #0
 8017138:	d002      	beq.n	8017140 <tcp_enqueue+0x57c>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
 801713a:	68fb      	ldr	r3, [r7, #12]
 801713c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 801713e:	2b00      	cmp	r3, #0
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 8017140:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017142:	2b00      	cmp	r3, #0
 8017144:	d01a      	beq.n	801717c <tcp_enqueue+0x5b8>
 8017146:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8017148:	2b00      	cmp	r3, #0
 801714a:	d017      	beq.n	801717c <tcp_enqueue+0x5b8>
 801714c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801714e:	691b      	ldr	r3, [r3, #16]
 8017150:	2b00      	cmp	r3, #0
 8017152:	d013      	beq.n	801717c <tcp_enqueue+0x5b8>
 8017154:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8017158:	f003 0302 	and.w	r3, r3, #2
 801715c:	2b00      	cmp	r3, #0
 801715e:	d10d      	bne.n	801717c <tcp_enqueue+0x5b8>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 8017160:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017162:	691c      	ldr	r4, [r3, #16]
 8017164:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017166:	691b      	ldr	r3, [r3, #16]
 8017168:	899b      	ldrh	r3, [r3, #12]
 801716a:	b29d      	uxth	r5, r3
 801716c:	f04f 0008 	mov.w	r0, #8
 8017170:	f001 fff2 	bl	8019158 <htons>
 8017174:	4603      	mov	r3, r0
 8017176:	432b      	orrs	r3, r5
 8017178:	b29b      	uxth	r3, r3
 801717a:	81a3      	strh	r3, [r4, #12]
  }

  return ERR_OK;
 801717c:	f04f 0300 	mov.w	r3, #0
 8017180:	e021      	b.n	80171c6 <tcp_enqueue+0x602>
    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                  ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
 8017182:	bf00      	nop
 8017184:	e006      	b.n	8017194 <tcp_enqueue+0x5d0>
     * ROM or other static memory, and need not be copied.  */
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen + optlen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
 8017186:	bf00      	nop
 8017188:	e004      	b.n	8017194 <tcp_enqueue+0x5d0>
    else {
      /* First, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, 
                    ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
 801718a:	bf00      	nop
 801718c:	e002      	b.n	8017194 <tcp_enqueue+0x5d0>

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
 801718e:	bf00      	nop
 8017190:	e000      	b.n	8017194 <tcp_enqueue+0x5d0>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -(TCP_HLEN + optlen))) {
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      TCP_STATS_INC(tcp.err);
      goto memerr;
 8017192:	bf00      	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 8017194:	68fb      	ldr	r3, [r7, #12]
 8017196:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801719a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 801719e:	b2da      	uxtb	r2, r3
 80171a0:	68fb      	ldr	r3, [r7, #12]
 80171a2:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
 80171a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80171a8:	2b00      	cmp	r3, #0
 80171aa:	d002      	beq.n	80171b2 <tcp_enqueue+0x5ee>
    tcp_segs_free(queue);
 80171ac:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80171ae:	f7fd f9c3 	bl	8014538 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 80171b2:	68fb      	ldr	r3, [r7, #12]
 80171b4:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
 80171b8:	2b00      	cmp	r3, #0
 80171ba:	d002      	beq.n	80171c2 <tcp_enqueue+0x5fe>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
 80171bc:	68fb      	ldr	r3, [r7, #12]
 80171be:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80171c0:	2b00      	cmp	r3, #0
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 80171c2:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80171c6:	b25b      	sxtb	r3, r3
}
 80171c8:	4618      	mov	r0, r3
 80171ca:	f107 0738 	add.w	r7, r7, #56	; 0x38
 80171ce:	46bd      	mov	sp, r7
 80171d0:	bdb0      	pop	{r4, r5, r7, pc}
 80171d2:	bf00      	nop

080171d4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 80171d4:	b590      	push	{r4, r7, lr}
 80171d6:	b087      	sub	sp, #28
 80171d8:	af02      	add	r7, sp, #8
 80171da:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
#if (LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP)
  struct tcp_hdr *tcphdr;
#endif
  u8_t optlen = 0;
 80171dc:	f04f 0300 	mov.w	r3, #0
 80171e0:	73fb      	strb	r3, [r7, #15]
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif
  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen, PBUF_RAM);
 80171e2:	7bfb      	ldrb	r3, [r7, #15]
 80171e4:	b29b      	uxth	r3, r3
 80171e6:	f103 0314 	add.w	r3, r3, #20
 80171ea:	b29b      	uxth	r3, r3
 80171ec:	f04f 0001 	mov.w	r0, #1
 80171f0:	4619      	mov	r1, r3
 80171f2:	f04f 0200 	mov.w	r2, #0
 80171f6:	f7fb fc5b 	bl	8012ab0 <pbuf_alloc>
 80171fa:	60b8      	str	r0, [r7, #8]
  if (p == NULL) {
 80171fc:	68bb      	ldr	r3, [r7, #8]
 80171fe:	2b00      	cmp	r3, #0
 8017200:	d102      	bne.n	8017208 <tcp_send_empty_ack+0x34>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 8017202:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 8017206:	e028      	b.n	801725a <tcp_send_empty_ack+0x86>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8017208:	687b      	ldr	r3, [r7, #4]
 801720a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801720e:	f023 0303 	bic.w	r3, r3, #3
 8017212:	b2da      	uxtb	r2, r3
 8017214:	687b      	ldr	r3, [r7, #4]
 8017216:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

#if (LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP)
  tcphdr = tcp_output_set_header(pcb, p, optlen, htonl(pcb->snd_nxt));
#else
  tcp_output_set_header(pcb, p, optlen, htonl(pcb->snd_nxt));
 801721a:	7bfc      	ldrb	r4, [r7, #15]
 801721c:	687b      	ldr	r3, [r7, #4]
 801721e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8017220:	4618      	mov	r0, r3
 8017222:	f001 ffc1 	bl	80191a8 <htonl>
 8017226:	4603      	mov	r3, r0
 8017228:	6878      	ldr	r0, [r7, #4]
 801722a:	68b9      	ldr	r1, [r7, #8]
 801722c:	4622      	mov	r2, r4
 801722e:	f7ff fbfb 	bl	8016a28 <tcp_output_set_header>
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8017232:	6879      	ldr	r1, [r7, #4]
 8017234:	687b      	ldr	r3, [r7, #4]
 8017236:	f103 0204 	add.w	r2, r3, #4
 801723a:	687b      	ldr	r3, [r7, #4]
 801723c:	7adb      	ldrb	r3, [r3, #11]
 801723e:	6878      	ldr	r0, [r7, #4]
 8017240:	7a80      	ldrb	r0, [r0, #10]
 8017242:	9000      	str	r0, [sp, #0]
 8017244:	f04f 0006 	mov.w	r0, #6
 8017248:	9001      	str	r0, [sp, #4]
 801724a:	68b8      	ldr	r0, [r7, #8]
 801724c:	f002 fc4c 	bl	8019ae8 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 8017250:	68b8      	ldr	r0, [r7, #8]
 8017252:	f7fb fe35 	bl	8012ec0 <pbuf_free>

  return ERR_OK;
 8017256:	f04f 0300 	mov.w	r3, #0
 801725a:	b25b      	sxtb	r3, r3
}
 801725c:	4618      	mov	r0, r3
 801725e:	f107 0714 	add.w	r7, r7, #20
 8017262:	46bd      	mov	sp, r7
 8017264:	bd90      	pop	{r4, r7, pc}
 8017266:	bf00      	nop

08017268 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 8017268:	b5b0      	push	{r4, r5, r7, lr}
 801726a:	b088      	sub	sp, #32
 801726c:	af00      	add	r7, sp, #0
 801726e:	6078      	str	r0, [r7, #4]

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 8017270:	f246 536c 	movw	r3, #25964	; 0x656c
 8017274:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017278:	681a      	ldr	r2, [r3, #0]
 801727a:	687b      	ldr	r3, [r7, #4]
 801727c:	429a      	cmp	r2, r3
 801727e:	d102      	bne.n	8017286 <tcp_output+0x1e>
    return ERR_OK;
 8017280:	f04f 0300 	mov.w	r3, #0
 8017284:	e161      	b.n	801754a <tcp_output+0x2e2>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 8017286:	687b      	ldr	r3, [r7, #4]
 8017288:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 801728c:	687b      	ldr	r3, [r7, #4]
 801728e:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8017292:	429a      	cmp	r2, r3
 8017294:	bf38      	it	cc
 8017296:	4613      	movcc	r3, r2
 8017298:	b29b      	uxth	r3, r3
 801729a:	613b      	str	r3, [r7, #16]

  seg = pcb->unsent;
 801729c:	687b      	ldr	r3, [r7, #4]
 801729e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80172a0:	61fb      	str	r3, [r7, #28]
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 80172a2:	687b      	ldr	r3, [r7, #4]
 80172a4:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80172a8:	f003 0302 	and.w	r3, r3, #2
 80172ac:	2b00      	cmp	r3, #0
 80172ae:	d017      	beq.n	80172e0 <tcp_output+0x78>
 80172b0:	69fb      	ldr	r3, [r7, #28]
 80172b2:	2b00      	cmp	r3, #0
 80172b4:	d00f      	beq.n	80172d6 <tcp_output+0x6e>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 80172b6:	69fb      	ldr	r3, [r7, #28]
 80172b8:	691b      	ldr	r3, [r3, #16]
 80172ba:	685b      	ldr	r3, [r3, #4]
 80172bc:	4618      	mov	r0, r3
 80172be:	f001 ff91 	bl	80191e4 <ntohl>
 80172c2:	4602      	mov	r2, r0
 80172c4:	687b      	ldr	r3, [r7, #4]
 80172c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80172c8:	1ad2      	subs	r2, r2, r3
 80172ca:	69fb      	ldr	r3, [r7, #28]
 80172cc:	899b      	ldrh	r3, [r3, #12]
 80172ce:	18d2      	adds	r2, r2, r3
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
 80172d0:	693b      	ldr	r3, [r7, #16]
 80172d2:	429a      	cmp	r2, r3
 80172d4:	d904      	bls.n	80172e0 <tcp_output+0x78>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 80172d6:	6878      	ldr	r0, [r7, #4]
 80172d8:	f7ff ff7c 	bl	80171d4 <tcp_send_empty_ack>
 80172dc:	4603      	mov	r3, r0
 80172de:	e134      	b.n	801754a <tcp_output+0x2e2>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 80172e0:	687b      	ldr	r3, [r7, #4]
 80172e2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80172e4:	61bb      	str	r3, [r7, #24]
  if (useg != NULL) {
 80172e6:	69bb      	ldr	r3, [r7, #24]
 80172e8:	2b00      	cmp	r3, #0
 80172ea:	f000 80e9 	beq.w	80174c0 <tcp_output+0x258>
    for (; useg->next != NULL; useg = useg->next);
 80172ee:	e002      	b.n	80172f6 <tcp_output+0x8e>
 80172f0:	69bb      	ldr	r3, [r7, #24]
 80172f2:	681b      	ldr	r3, [r3, #0]
 80172f4:	61bb      	str	r3, [r7, #24]
 80172f6:	69bb      	ldr	r3, [r7, #24]
 80172f8:	681b      	ldr	r3, [r3, #0]
 80172fa:	2b00      	cmp	r3, #0
 80172fc:	d1f8      	bne.n	80172f0 <tcp_output+0x88>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 80172fe:	e0df      	b.n	80174c0 <tcp_output+0x258>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
 8017300:	69fb      	ldr	r3, [r7, #28]
 8017302:	691b      	ldr	r3, [r3, #16]
 8017304:	899b      	ldrh	r3, [r3, #12]
 8017306:	b29b      	uxth	r3, r3
 8017308:	4618      	mov	r0, r3
 801730a:	f001 ff3d 	bl	8019188 <ntohs>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 801730e:	687b      	ldr	r3, [r7, #4]
 8017310:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8017312:	2b00      	cmp	r3, #0
 8017314:	d016      	beq.n	8017344 <tcp_output+0xdc>
 8017316:	687b      	ldr	r3, [r7, #4]
 8017318:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801731c:	f003 0344 	and.w	r3, r3, #68	; 0x44
 8017320:	2b00      	cmp	r3, #0
 8017322:	d10f      	bne.n	8017344 <tcp_output+0xdc>
 8017324:	687b      	ldr	r3, [r7, #4]
 8017326:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8017328:	2b00      	cmp	r3, #0
 801732a:	d00e      	beq.n	801734a <tcp_output+0xe2>
 801732c:	687b      	ldr	r3, [r7, #4]
 801732e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8017330:	681b      	ldr	r3, [r3, #0]
 8017332:	2b00      	cmp	r3, #0
 8017334:	d106      	bne.n	8017344 <tcp_output+0xdc>
 8017336:	687b      	ldr	r3, [r7, #4]
 8017338:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801733a:	899a      	ldrh	r2, [r3, #12]
 801733c:	687b      	ldr	r3, [r7, #4]
 801733e:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8017340:	429a      	cmp	r2, r3
 8017342:	d302      	bcc.n	801734a <tcp_output+0xe2>
 8017344:	f04f 0301 	mov.w	r3, #1
 8017348:	e001      	b.n	801734e <tcp_output+0xe6>
 801734a:	f04f 0300 	mov.w	r3, #0
 801734e:	2b00      	cmp	r3, #0
 8017350:	d107      	bne.n	8017362 <tcp_output+0xfa>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
 8017352:	687b      	ldr	r3, [r7, #4]
 8017354:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8017358:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 801735c:	2b00      	cmp	r3, #0
 801735e:	f000 80c4 	beq.w	80174ea <tcp_output+0x282>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 8017362:	69fb      	ldr	r3, [r7, #28]
 8017364:	681a      	ldr	r2, [r3, #0]
 8017366:	687b      	ldr	r3, [r7, #4]
 8017368:	675a      	str	r2, [r3, #116]	; 0x74

    if (pcb->state != SYN_SENT) {
 801736a:	687b      	ldr	r3, [r7, #4]
 801736c:	7c1b      	ldrb	r3, [r3, #16]
 801736e:	2b02      	cmp	r3, #2
 8017370:	d016      	beq.n	80173a0 <tcp_output+0x138>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 8017372:	69fb      	ldr	r3, [r7, #28]
 8017374:	691c      	ldr	r4, [r3, #16]
 8017376:	69fb      	ldr	r3, [r7, #28]
 8017378:	691b      	ldr	r3, [r3, #16]
 801737a:	899b      	ldrh	r3, [r3, #12]
 801737c:	b29d      	uxth	r5, r3
 801737e:	f04f 0010 	mov.w	r0, #16
 8017382:	f001 fee9 	bl	8019158 <htons>
 8017386:	4603      	mov	r3, r0
 8017388:	432b      	orrs	r3, r5
 801738a:	b29b      	uxth	r3, r3
 801738c:	81a3      	strh	r3, [r4, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 801738e:	687b      	ldr	r3, [r7, #4]
 8017390:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8017394:	f023 0303 	bic.w	r3, r3, #3
 8017398:	b2da      	uxtb	r2, r3
 801739a:	687b      	ldr	r3, [r7, #4]
 801739c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    }

    tcp_output_segment(seg, pcb);
 80173a0:	69f8      	ldr	r0, [r7, #28]
 80173a2:	6879      	ldr	r1, [r7, #4]
 80173a4:	f000 f8d8 	bl	8017558 <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80173a8:	69fb      	ldr	r3, [r7, #28]
 80173aa:	691b      	ldr	r3, [r3, #16]
 80173ac:	685b      	ldr	r3, [r3, #4]
 80173ae:	4618      	mov	r0, r3
 80173b0:	f001 ff18 	bl	80191e4 <ntohl>
 80173b4:	4604      	mov	r4, r0
 80173b6:	69fb      	ldr	r3, [r7, #28]
 80173b8:	899b      	ldrh	r3, [r3, #12]
 80173ba:	461d      	mov	r5, r3
 80173bc:	69fb      	ldr	r3, [r7, #28]
 80173be:	691b      	ldr	r3, [r3, #16]
 80173c0:	899b      	ldrh	r3, [r3, #12]
 80173c2:	b29b      	uxth	r3, r3
 80173c4:	4618      	mov	r0, r3
 80173c6:	f001 fedf 	bl	8019188 <ntohs>
 80173ca:	4603      	mov	r3, r0
 80173cc:	f003 0303 	and.w	r3, r3, #3
 80173d0:	2b00      	cmp	r3, #0
 80173d2:	bf0c      	ite	eq
 80173d4:	2300      	moveq	r3, #0
 80173d6:	2301      	movne	r3, #1
 80173d8:	b2db      	uxtb	r3, r3
 80173da:	18eb      	adds	r3, r5, r3
 80173dc:	18e3      	adds	r3, r4, r3
 80173de:	60fb      	str	r3, [r7, #12]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80173e0:	687b      	ldr	r3, [r7, #4]
 80173e2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80173e4:	68fb      	ldr	r3, [r7, #12]
 80173e6:	1ad3      	subs	r3, r2, r3
 80173e8:	2b00      	cmp	r3, #0
 80173ea:	da02      	bge.n	80173f2 <tcp_output+0x18a>
      pcb->snd_nxt = snd_nxt;
 80173ec:	687b      	ldr	r3, [r7, #4]
 80173ee:	68fa      	ldr	r2, [r7, #12]
 80173f0:	659a      	str	r2, [r3, #88]	; 0x58
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 80173f2:	69fb      	ldr	r3, [r7, #28]
 80173f4:	899b      	ldrh	r3, [r3, #12]
 80173f6:	461c      	mov	r4, r3
 80173f8:	69fb      	ldr	r3, [r7, #28]
 80173fa:	691b      	ldr	r3, [r3, #16]
 80173fc:	899b      	ldrh	r3, [r3, #12]
 80173fe:	b29b      	uxth	r3, r3
 8017400:	4618      	mov	r0, r3
 8017402:	f001 fec1 	bl	8019188 <ntohs>
 8017406:	4603      	mov	r3, r0
 8017408:	f003 0303 	and.w	r3, r3, #3
 801740c:	2b00      	cmp	r3, #0
 801740e:	bf0c      	ite	eq
 8017410:	2300      	moveq	r3, #0
 8017412:	2301      	movne	r3, #1
 8017414:	b2db      	uxtb	r3, r3
 8017416:	18e3      	adds	r3, r4, r3
 8017418:	2b00      	cmp	r3, #0
 801741a:	dd4b      	ble.n	80174b4 <tcp_output+0x24c>
      seg->next = NULL;
 801741c:	69fb      	ldr	r3, [r7, #28]
 801741e:	f04f 0200 	mov.w	r2, #0
 8017422:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 8017424:	687b      	ldr	r3, [r7, #4]
 8017426:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8017428:	2b00      	cmp	r3, #0
 801742a:	d105      	bne.n	8017438 <tcp_output+0x1d0>
        pcb->unacked = seg;
 801742c:	687b      	ldr	r3, [r7, #4]
 801742e:	69fa      	ldr	r2, [r7, #28]
 8017430:	679a      	str	r2, [r3, #120]	; 0x78
        useg = seg;
 8017432:	69fb      	ldr	r3, [r7, #28]
 8017434:	61bb      	str	r3, [r7, #24]
 8017436:	e040      	b.n	80174ba <tcp_output+0x252>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
 8017438:	69fb      	ldr	r3, [r7, #28]
 801743a:	691b      	ldr	r3, [r3, #16]
 801743c:	685b      	ldr	r3, [r3, #4]
 801743e:	4618      	mov	r0, r3
 8017440:	f001 fed0 	bl	80191e4 <ntohl>
 8017444:	4604      	mov	r4, r0
 8017446:	69bb      	ldr	r3, [r7, #24]
 8017448:	691b      	ldr	r3, [r3, #16]
 801744a:	685b      	ldr	r3, [r3, #4]
 801744c:	4618      	mov	r0, r3
 801744e:	f001 fec9 	bl	80191e4 <ntohl>
 8017452:	4603      	mov	r3, r0
 8017454:	1ae3      	subs	r3, r4, r3
 8017456:	2b00      	cmp	r3, #0
 8017458:	da25      	bge.n	80174a6 <tcp_output+0x23e>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 801745a:	687b      	ldr	r3, [r7, #4]
 801745c:	f103 0378 	add.w	r3, r3, #120	; 0x78
 8017460:	617b      	str	r3, [r7, #20]
          while (*cur_seg &&
 8017462:	e002      	b.n	801746a <tcp_output+0x202>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 8017464:	697b      	ldr	r3, [r7, #20]
 8017466:	681b      	ldr	r3, [r3, #0]
 8017468:	617b      	str	r3, [r7, #20]
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 801746a:	697b      	ldr	r3, [r7, #20]
 801746c:	681b      	ldr	r3, [r3, #0]
 801746e:	2b00      	cmp	r3, #0
 8017470:	d011      	beq.n	8017496 <tcp_output+0x22e>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8017472:	697b      	ldr	r3, [r7, #20]
 8017474:	681b      	ldr	r3, [r3, #0]
 8017476:	691b      	ldr	r3, [r3, #16]
 8017478:	685b      	ldr	r3, [r3, #4]
 801747a:	4618      	mov	r0, r3
 801747c:	f001 feb2 	bl	80191e4 <ntohl>
 8017480:	4604      	mov	r4, r0
 8017482:	69fb      	ldr	r3, [r7, #28]
 8017484:	691b      	ldr	r3, [r3, #16]
 8017486:	685b      	ldr	r3, [r3, #4]
 8017488:	4618      	mov	r0, r3
 801748a:	f001 feab 	bl	80191e4 <ntohl>
 801748e:	4603      	mov	r3, r0
 8017490:	1ae3      	subs	r3, r4, r3
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 8017492:	2b00      	cmp	r3, #0
 8017494:	dbe6      	blt.n	8017464 <tcp_output+0x1fc>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 8017496:	697b      	ldr	r3, [r7, #20]
 8017498:	681a      	ldr	r2, [r3, #0]
 801749a:	69fb      	ldr	r3, [r7, #28]
 801749c:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
 801749e:	697b      	ldr	r3, [r7, #20]
 80174a0:	69fa      	ldr	r2, [r7, #28]
 80174a2:	601a      	str	r2, [r3, #0]
 80174a4:	e009      	b.n	80174ba <tcp_output+0x252>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 80174a6:	69bb      	ldr	r3, [r7, #24]
 80174a8:	69fa      	ldr	r2, [r7, #28]
 80174aa:	601a      	str	r2, [r3, #0]
          useg = useg->next;
 80174ac:	69bb      	ldr	r3, [r7, #24]
 80174ae:	681b      	ldr	r3, [r3, #0]
 80174b0:	61bb      	str	r3, [r7, #24]
 80174b2:	e002      	b.n	80174ba <tcp_output+0x252>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 80174b4:	69f8      	ldr	r0, [r7, #28]
 80174b6:	f7fd f85d 	bl	8014574 <tcp_seg_free>
    }
    seg = pcb->unsent;
 80174ba:	687b      	ldr	r3, [r7, #4]
 80174bc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80174be:	61fb      	str	r3, [r7, #28]
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 80174c0:	69fb      	ldr	r3, [r7, #28]
 80174c2:	2b00      	cmp	r3, #0
 80174c4:	d012      	beq.n	80174ec <tcp_output+0x284>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 80174c6:	69fb      	ldr	r3, [r7, #28]
 80174c8:	691b      	ldr	r3, [r3, #16]
 80174ca:	685b      	ldr	r3, [r3, #4]
 80174cc:	4618      	mov	r0, r3
 80174ce:	f001 fe89 	bl	80191e4 <ntohl>
 80174d2:	4602      	mov	r2, r0
 80174d4:	687b      	ldr	r3, [r7, #4]
 80174d6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80174d8:	1ad2      	subs	r2, r2, r3
 80174da:	69fb      	ldr	r3, [r7, #28]
 80174dc:	899b      	ldrh	r3, [r3, #12]
 80174de:	18d2      	adds	r2, r2, r3
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 80174e0:	693b      	ldr	r3, [r7, #16]
 80174e2:	429a      	cmp	r2, r3
 80174e4:	f67f af0c 	bls.w	8017300 <tcp_output+0x98>
 80174e8:	e000      	b.n	80174ec <tcp_output+0x284>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
 80174ea:	bf00      	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
 80174ec:	69fb      	ldr	r3, [r7, #28]
 80174ee:	2b00      	cmp	r3, #0
 80174f0:	d020      	beq.n	8017534 <tcp_output+0x2cc>
 80174f2:	687b      	ldr	r3, [r7, #4]
 80174f4:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 80174f8:	2b00      	cmp	r3, #0
 80174fa:	d11b      	bne.n	8017534 <tcp_output+0x2cc>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
 80174fc:	69fb      	ldr	r3, [r7, #28]
 80174fe:	691b      	ldr	r3, [r3, #16]
 8017500:	685b      	ldr	r3, [r3, #4]
 8017502:	4618      	mov	r0, r3
 8017504:	f001 fe6e 	bl	80191e4 <ntohl>
 8017508:	4602      	mov	r2, r0
 801750a:	687b      	ldr	r3, [r7, #4]
 801750c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801750e:	1ad2      	subs	r2, r2, r3
 8017510:	69fb      	ldr	r3, [r7, #28]
 8017512:	899b      	ldrh	r3, [r3, #12]
 8017514:	18d2      	adds	r2, r2, r3
 8017516:	687b      	ldr	r3, [r7, #4]
 8017518:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
 801751c:	429a      	cmp	r2, r3
 801751e:	d909      	bls.n	8017534 <tcp_output+0x2cc>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
 8017520:	687b      	ldr	r3, [r7, #4]
 8017522:	f04f 0200 	mov.w	r2, #0
 8017526:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    pcb->persist_backoff = 1;
 801752a:	687b      	ldr	r3, [r7, #4]
 801752c:	f04f 0201 	mov.w	r2, #1
 8017530:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
 8017534:	687b      	ldr	r3, [r7, #4]
 8017536:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801753a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801753e:	b2da      	uxtb	r2, r3
 8017540:	687b      	ldr	r3, [r7, #4]
 8017542:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  return ERR_OK;
 8017546:	f04f 0300 	mov.w	r3, #0
 801754a:	b25b      	sxtb	r3, r3
}
 801754c:	4618      	mov	r0, r3
 801754e:	f107 0720 	add.w	r7, r7, #32
 8017552:	46bd      	mov	sp, r7
 8017554:	bdb0      	pop	{r4, r5, r7, pc}
 8017556:	bf00      	nop

08017558 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
 8017558:	b590      	push	{r4, r7, lr}
 801755a:	b089      	sub	sp, #36	; 0x24
 801755c:	af02      	add	r7, sp, #8
 801755e:	6078      	str	r0, [r7, #4]
 8017560:	6039      	str	r1, [r7, #0]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 8017562:	687b      	ldr	r3, [r7, #4]
 8017564:	691c      	ldr	r4, [r3, #16]
 8017566:	683b      	ldr	r3, [r7, #0]
 8017568:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801756a:	4618      	mov	r0, r3
 801756c:	f001 fe1c 	bl	80191a8 <htonl>
 8017570:	4603      	mov	r3, r0
 8017572:	60a3      	str	r3, [r4, #8]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 8017574:	687b      	ldr	r3, [r7, #4]
 8017576:	691c      	ldr	r4, [r3, #16]
 8017578:	683b      	ldr	r3, [r7, #0]
 801757a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 801757c:	4618      	mov	r0, r3
 801757e:	f001 fdeb 	bl	8019158 <htons>
 8017582:	4603      	mov	r3, r0
 8017584:	81e3      	strh	r3, [r4, #14]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8017586:	683b      	ldr	r3, [r7, #0]
 8017588:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801758a:	683b      	ldr	r3, [r7, #0]
 801758c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 801758e:	18d2      	adds	r2, r2, r3
 8017590:	683b      	ldr	r3, [r7, #0]
 8017592:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(seg->tcphdr + 1);
 8017594:	687b      	ldr	r3, [r7, #4]
 8017596:	691b      	ldr	r3, [r3, #16]
 8017598:	f103 0314 	add.w	r3, r3, #20
 801759c:	617b      	str	r3, [r7, #20]
  if (seg->flags & TF_SEG_OPTS_MSS) {
 801759e:	687b      	ldr	r3, [r7, #4]
 80175a0:	7b9b      	ldrb	r3, [r3, #14]
 80175a2:	f003 0301 	and.w	r3, r3, #1
 80175a6:	2b00      	cmp	r3, #0
 80175a8:	d00c      	beq.n	80175c4 <tcp_output_segment+0x6c>
    TCP_BUILD_MSS_OPTION(*opts);
 80175aa:	f240 50a6 	movw	r0, #1446	; 0x5a6
 80175ae:	f2c0 2004 	movt	r0, #516	; 0x204
 80175b2:	f001 fdf9 	bl	80191a8 <htonl>
 80175b6:	4602      	mov	r2, r0
 80175b8:	697b      	ldr	r3, [r7, #20]
 80175ba:	601a      	str	r2, [r3, #0]
    opts += 1;
 80175bc:	697b      	ldr	r3, [r7, #20]
 80175be:	f103 0304 	add.w	r3, r3, #4
 80175c2:	617b      	str	r3, [r7, #20]
  }
#endif

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 80175c4:	683b      	ldr	r3, [r7, #0]
 80175c6:	2b00      	cmp	r3, #0
 80175c8:	d003      	beq.n	80175d2 <tcp_output_segment+0x7a>
 80175ca:	683b      	ldr	r3, [r7, #0]
 80175cc:	681b      	ldr	r3, [r3, #0]
 80175ce:	2b00      	cmp	r3, #0
 80175d0:	d115      	bne.n	80175fe <tcp_output_segment+0xa6>
    netif = ip_route(&(pcb->remote_ip));
 80175d2:	683b      	ldr	r3, [r7, #0]
 80175d4:	f103 0304 	add.w	r3, r3, #4
 80175d8:	4618      	mov	r0, r3
 80175da:	f001 ff85 	bl	80194e8 <ip_route>
 80175de:	6138      	str	r0, [r7, #16]
    if (netif == NULL) {
 80175e0:	693b      	ldr	r3, [r7, #16]
 80175e2:	2b00      	cmp	r3, #0
 80175e4:	d061      	beq.n	80176aa <tcp_output_segment+0x152>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
 80175e6:	693b      	ldr	r3, [r7, #16]
 80175e8:	f103 0304 	add.w	r3, r3, #4
 80175ec:	2b00      	cmp	r3, #0
 80175ee:	d002      	beq.n	80175f6 <tcp_output_segment+0x9e>
 80175f0:	693b      	ldr	r3, [r7, #16]
 80175f2:	685b      	ldr	r3, [r3, #4]
 80175f4:	e001      	b.n	80175fa <tcp_output_segment+0xa2>
 80175f6:	f04f 0300 	mov.w	r3, #0
 80175fa:	683a      	ldr	r2, [r7, #0]
 80175fc:	6013      	str	r3, [r2, #0]
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
 80175fe:	683b      	ldr	r3, [r7, #0]
 8017600:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8017602:	b21b      	sxth	r3, r3
 8017604:	f1b3 3fff 	cmp.w	r3, #4294967295
 8017608:	d103      	bne.n	8017612 <tcp_output_segment+0xba>
    pcb->rtime = 0;
 801760a:	683b      	ldr	r3, [r7, #0]
 801760c:	f04f 0200 	mov.w	r2, #0
 8017610:	86da      	strh	r2, [r3, #54]	; 0x36

  if (pcb->rttest == 0) {
 8017612:	683b      	ldr	r3, [r7, #0]
 8017614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8017616:	2b00      	cmp	r3, #0
 8017618:	d10f      	bne.n	801763a <tcp_output_segment+0xe2>
    pcb->rttest = tcp_ticks;
 801761a:	f246 5358 	movw	r3, #25944	; 0x6558
 801761e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017622:	681a      	ldr	r2, [r3, #0]
 8017624:	683b      	ldr	r3, [r7, #0]
 8017626:	63da      	str	r2, [r3, #60]	; 0x3c
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 8017628:	687b      	ldr	r3, [r7, #4]
 801762a:	691b      	ldr	r3, [r3, #16]
 801762c:	685b      	ldr	r3, [r3, #4]
 801762e:	4618      	mov	r0, r3
 8017630:	f001 fdd8 	bl	80191e4 <ntohl>
 8017634:	4602      	mov	r2, r0
 8017636:	683b      	ldr	r3, [r7, #0]
 8017638:	641a      	str	r2, [r3, #64]	; 0x40
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 801763a:	687b      	ldr	r3, [r7, #4]
 801763c:	691b      	ldr	r3, [r3, #16]
 801763e:	461a      	mov	r2, r3
 8017640:	687b      	ldr	r3, [r7, #4]
 8017642:	685b      	ldr	r3, [r3, #4]
 8017644:	685b      	ldr	r3, [r3, #4]
 8017646:	1ad3      	subs	r3, r2, r3
 8017648:	81fb      	strh	r3, [r7, #14]

  seg->p->len -= len;
 801764a:	687b      	ldr	r3, [r7, #4]
 801764c:	685b      	ldr	r3, [r3, #4]
 801764e:	687a      	ldr	r2, [r7, #4]
 8017650:	6852      	ldr	r2, [r2, #4]
 8017652:	8951      	ldrh	r1, [r2, #10]
 8017654:	89fa      	ldrh	r2, [r7, #14]
 8017656:	1a8a      	subs	r2, r1, r2
 8017658:	b292      	uxth	r2, r2
 801765a:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
 801765c:	687b      	ldr	r3, [r7, #4]
 801765e:	685b      	ldr	r3, [r3, #4]
 8017660:	687a      	ldr	r2, [r7, #4]
 8017662:	6852      	ldr	r2, [r2, #4]
 8017664:	8911      	ldrh	r1, [r2, #8]
 8017666:	89fa      	ldrh	r2, [r7, #14]
 8017668:	1a8a      	subs	r2, r1, r2
 801766a:	b292      	uxth	r2, r2
 801766c:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
 801766e:	687b      	ldr	r3, [r7, #4]
 8017670:	685b      	ldr	r3, [r3, #4]
 8017672:	687a      	ldr	r2, [r7, #4]
 8017674:	6912      	ldr	r2, [r2, #16]
 8017676:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
 8017678:	687b      	ldr	r3, [r7, #4]
 801767a:	691b      	ldr	r3, [r3, #16]
 801767c:	f04f 0200 	mov.w	r2, #0
 8017680:	741a      	strb	r2, [r3, #16]
 8017682:	f04f 0200 	mov.w	r2, #0
 8017686:	745a      	strb	r2, [r3, #17]

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 8017688:	687b      	ldr	r3, [r7, #4]
 801768a:	6858      	ldr	r0, [r3, #4]
 801768c:	6839      	ldr	r1, [r7, #0]
 801768e:	683b      	ldr	r3, [r7, #0]
 8017690:	f103 0204 	add.w	r2, r3, #4
 8017694:	683b      	ldr	r3, [r7, #0]
 8017696:	7adb      	ldrb	r3, [r3, #11]
 8017698:	683c      	ldr	r4, [r7, #0]
 801769a:	7aa4      	ldrb	r4, [r4, #10]
 801769c:	9400      	str	r4, [sp, #0]
 801769e:	f04f 0406 	mov.w	r4, #6
 80176a2:	9401      	str	r4, [sp, #4]
 80176a4:	f002 fa20 	bl	8019ae8 <ip_output>
 80176a8:	e000      	b.n	80176ac <tcp_output_segment+0x154>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
 80176aa:	bf00      	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
 80176ac:	f107 071c 	add.w	r7, r7, #28
 80176b0:	46bd      	mov	sp, r7
 80176b2:	bd90      	pop	{r4, r7, pc}

080176b4 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 80176b4:	b590      	push	{r4, r7, lr}
 80176b6:	b089      	sub	sp, #36	; 0x24
 80176b8:	af02      	add	r7, sp, #8
 80176ba:	60f8      	str	r0, [r7, #12]
 80176bc:	60b9      	str	r1, [r7, #8]
 80176be:	607a      	str	r2, [r7, #4]
 80176c0:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 80176c2:	f04f 0001 	mov.w	r0, #1
 80176c6:	f04f 0114 	mov.w	r1, #20
 80176ca:	f04f 0200 	mov.w	r2, #0
 80176ce:	f7fb f9ef 	bl	8012ab0 <pbuf_alloc>
 80176d2:	6178      	str	r0, [r7, #20]
  if (p == NULL) {
 80176d4:	697b      	ldr	r3, [r7, #20]
 80176d6:	2b00      	cmp	r3, #0
 80176d8:	d06c      	beq.n	80177b4 <tcp_rst+0x100>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
 80176da:	697b      	ldr	r3, [r7, #20]
 80176dc:	685b      	ldr	r3, [r3, #4]
 80176de:	613b      	str	r3, [r7, #16]
  tcphdr->src = htons(local_port);
 80176e0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80176e2:	4618      	mov	r0, r3
 80176e4:	f001 fd38 	bl	8019158 <htons>
 80176e8:	4603      	mov	r3, r0
 80176ea:	461a      	mov	r2, r3
 80176ec:	693b      	ldr	r3, [r7, #16]
 80176ee:	801a      	strh	r2, [r3, #0]
  tcphdr->dest = htons(remote_port);
 80176f0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80176f2:	4618      	mov	r0, r3
 80176f4:	f001 fd30 	bl	8019158 <htons>
 80176f8:	4603      	mov	r3, r0
 80176fa:	461a      	mov	r2, r3
 80176fc:	693b      	ldr	r3, [r7, #16]
 80176fe:	805a      	strh	r2, [r3, #2]
  tcphdr->seqno = htonl(seqno);
 8017700:	68f8      	ldr	r0, [r7, #12]
 8017702:	f001 fd51 	bl	80191a8 <htonl>
 8017706:	4602      	mov	r2, r0
 8017708:	693b      	ldr	r3, [r7, #16]
 801770a:	605a      	str	r2, [r3, #4]
  tcphdr->ackno = htonl(ackno);
 801770c:	68b8      	ldr	r0, [r7, #8]
 801770e:	f001 fd4b 	bl	80191a8 <htonl>
 8017712:	4602      	mov	r2, r0
 8017714:	693b      	ldr	r3, [r7, #16]
 8017716:	609a      	str	r2, [r3, #8]
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
 8017718:	693b      	ldr	r3, [r7, #16]
 801771a:	899b      	ldrh	r3, [r3, #12]
 801771c:	b29c      	uxth	r4, r3
 801771e:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 8017722:	f001 fd19 	bl	8019158 <htons>
 8017726:	4603      	mov	r3, r0
 8017728:	4023      	ands	r3, r4
 801772a:	b29c      	uxth	r4, r3
 801772c:	f04f 0014 	mov.w	r0, #20
 8017730:	f001 fd12 	bl	8019158 <htons>
 8017734:	4603      	mov	r3, r0
 8017736:	4323      	orrs	r3, r4
 8017738:	b29a      	uxth	r2, r3
 801773a:	693b      	ldr	r3, [r7, #16]
 801773c:	819a      	strh	r2, [r3, #12]
  tcphdr->wnd = htons(TCP_WND);
 801773e:	f640 304c 	movw	r0, #2892	; 0xb4c
 8017742:	f001 fd09 	bl	8019158 <htons>
 8017746:	4603      	mov	r3, r0
 8017748:	461a      	mov	r2, r3
 801774a:	693b      	ldr	r3, [r7, #16]
 801774c:	81da      	strh	r2, [r3, #14]
  tcphdr->urgp = 0;
 801774e:	693b      	ldr	r3, [r7, #16]
 8017750:	f04f 0200 	mov.w	r2, #0
 8017754:	749a      	strb	r2, [r3, #18]
 8017756:	f04f 0200 	mov.w	r2, #0
 801775a:	74da      	strb	r2, [r3, #19]
  TCPH_HDRLEN_SET(tcphdr, 5);
 801775c:	693b      	ldr	r3, [r7, #16]
 801775e:	899b      	ldrh	r3, [r3, #12]
 8017760:	b29b      	uxth	r3, r3
 8017762:	4618      	mov	r0, r3
 8017764:	f001 fd10 	bl	8019188 <ntohs>
 8017768:	4603      	mov	r3, r0
 801776a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801776e:	b29b      	uxth	r3, r3
 8017770:	f443 43a0 	orr.w	r3, r3, #20480	; 0x5000
 8017774:	b29b      	uxth	r3, r3
 8017776:	4618      	mov	r0, r3
 8017778:	f001 fcee 	bl	8019158 <htons>
 801777c:	4603      	mov	r3, r0
 801777e:	461a      	mov	r2, r3
 8017780:	693b      	ldr	r3, [r7, #16]
 8017782:	819a      	strh	r2, [r3, #12]

  tcphdr->chksum = 0;
 8017784:	693b      	ldr	r3, [r7, #16]
 8017786:	f04f 0200 	mov.w	r2, #0
 801778a:	741a      	strb	r2, [r3, #16]
 801778c:	f04f 0200 	mov.w	r2, #0
 8017790:	745a      	strb	r2, [r3, #17]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 8017792:	f04f 0300 	mov.w	r3, #0
 8017796:	9300      	str	r3, [sp, #0]
 8017798:	f04f 0306 	mov.w	r3, #6
 801779c:	9301      	str	r3, [sp, #4]
 801779e:	6978      	ldr	r0, [r7, #20]
 80177a0:	6879      	ldr	r1, [r7, #4]
 80177a2:	683a      	ldr	r2, [r7, #0]
 80177a4:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80177a8:	f002 f99e 	bl	8019ae8 <ip_output>
  pbuf_free(p);
 80177ac:	6978      	ldr	r0, [r7, #20]
 80177ae:	f7fb fb87 	bl	8012ec0 <pbuf_free>
 80177b2:	e000      	b.n	80177b6 <tcp_rst+0x102>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
 80177b4:	bf00      	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 80177b6:	f107 071c 	add.w	r7, r7, #28
 80177ba:	46bd      	mov	sp, r7
 80177bc:	bd90      	pop	{r4, r7, pc}
 80177be:	bf00      	nop

080177c0 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 80177c0:	b580      	push	{r7, lr}
 80177c2:	b084      	sub	sp, #16
 80177c4:	af00      	add	r7, sp, #0
 80177c6:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 80177c8:	687b      	ldr	r3, [r7, #4]
 80177ca:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80177cc:	2b00      	cmp	r3, #0
 80177ce:	d027      	beq.n	8017820 <tcp_rexmit_rto+0x60>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 80177d0:	687b      	ldr	r3, [r7, #4]
 80177d2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80177d4:	60fb      	str	r3, [r7, #12]
 80177d6:	e002      	b.n	80177de <tcp_rexmit_rto+0x1e>
 80177d8:	68fb      	ldr	r3, [r7, #12]
 80177da:	681b      	ldr	r3, [r3, #0]
 80177dc:	60fb      	str	r3, [r7, #12]
 80177de:	68fb      	ldr	r3, [r7, #12]
 80177e0:	681b      	ldr	r3, [r3, #0]
 80177e2:	2b00      	cmp	r3, #0
 80177e4:	d1f8      	bne.n	80177d8 <tcp_rexmit_rto+0x18>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 80177e6:	687b      	ldr	r3, [r7, #4]
 80177e8:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80177ea:	68fb      	ldr	r3, [r7, #12]
 80177ec:	601a      	str	r2, [r3, #0]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 80177ee:	687b      	ldr	r3, [r7, #4]
 80177f0:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80177f2:	687b      	ldr	r3, [r7, #4]
 80177f4:	675a      	str	r2, [r3, #116]	; 0x74
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 80177f6:	687b      	ldr	r3, [r7, #4]
 80177f8:	f04f 0200 	mov.w	r2, #0
 80177fc:	679a      	str	r2, [r3, #120]	; 0x78

  /* increment number of retransmissions */
  ++pcb->nrtx;
 80177fe:	687b      	ldr	r3, [r7, #4]
 8017800:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 8017804:	f103 0301 	add.w	r3, r3, #1
 8017808:	b2da      	uxtb	r2, r3
 801780a:	687b      	ldr	r3, [r7, #4]
 801780c:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8017810:	687b      	ldr	r3, [r7, #4]
 8017812:	f04f 0200 	mov.w	r2, #0
 8017816:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Do the actual retransmission */
  tcp_output(pcb);
 8017818:	6878      	ldr	r0, [r7, #4]
 801781a:	f7ff fd25 	bl	8017268 <tcp_output>
 801781e:	e000      	b.n	8017822 <tcp_rexmit_rto+0x62>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
 8017820:	bf00      	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 8017822:	f107 0710 	add.w	r7, r7, #16
 8017826:	46bd      	mov	sp, r7
 8017828:	bd80      	pop	{r7, pc}
 801782a:	bf00      	nop

0801782c <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 801782c:	b590      	push	{r4, r7, lr}
 801782e:	b085      	sub	sp, #20
 8017830:	af00      	add	r7, sp, #0
 8017832:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 8017834:	687b      	ldr	r3, [r7, #4]
 8017836:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8017838:	2b00      	cmp	r3, #0
 801783a:	d039      	beq.n	80178b0 <tcp_rexmit+0x84>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
 801783c:	687b      	ldr	r3, [r7, #4]
 801783e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8017840:	60bb      	str	r3, [r7, #8]
  pcb->unacked = seg->next;
 8017842:	68bb      	ldr	r3, [r7, #8]
 8017844:	681a      	ldr	r2, [r3, #0]
 8017846:	687b      	ldr	r3, [r7, #4]
 8017848:	679a      	str	r2, [r3, #120]	; 0x78

  cur_seg = &(pcb->unsent);
 801784a:	687b      	ldr	r3, [r7, #4]
 801784c:	f103 0374 	add.w	r3, r3, #116	; 0x74
 8017850:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 8017852:	e002      	b.n	801785a <tcp_rexmit+0x2e>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 8017854:	68fb      	ldr	r3, [r7, #12]
 8017856:	681b      	ldr	r3, [r3, #0]
 8017858:	60fb      	str	r3, [r7, #12]
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 801785a:	68fb      	ldr	r3, [r7, #12]
 801785c:	681b      	ldr	r3, [r3, #0]
 801785e:	2b00      	cmp	r3, #0
 8017860:	d011      	beq.n	8017886 <tcp_rexmit+0x5a>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 8017862:	68fb      	ldr	r3, [r7, #12]
 8017864:	681b      	ldr	r3, [r3, #0]
 8017866:	691b      	ldr	r3, [r3, #16]
 8017868:	685b      	ldr	r3, [r3, #4]
 801786a:	4618      	mov	r0, r3
 801786c:	f001 fcba 	bl	80191e4 <ntohl>
 8017870:	4604      	mov	r4, r0
 8017872:	68bb      	ldr	r3, [r7, #8]
 8017874:	691b      	ldr	r3, [r3, #16]
 8017876:	685b      	ldr	r3, [r3, #4]
 8017878:	4618      	mov	r0, r3
 801787a:	f001 fcb3 	bl	80191e4 <ntohl>
 801787e:	4603      	mov	r3, r0
 8017880:	1ae3      	subs	r3, r4, r3
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 8017882:	2b00      	cmp	r3, #0
 8017884:	dbe6      	blt.n	8017854 <tcp_rexmit+0x28>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 8017886:	68fb      	ldr	r3, [r7, #12]
 8017888:	681a      	ldr	r2, [r3, #0]
 801788a:	68bb      	ldr	r3, [r7, #8]
 801788c:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
 801788e:	68fb      	ldr	r3, [r7, #12]
 8017890:	68ba      	ldr	r2, [r7, #8]
 8017892:	601a      	str	r2, [r3, #0]

  ++pcb->nrtx;
 8017894:	687b      	ldr	r3, [r7, #4]
 8017896:	f893 304a 	ldrb.w	r3, [r3, #74]	; 0x4a
 801789a:	f103 0301 	add.w	r3, r3, #1
 801789e:	b2da      	uxtb	r2, r3
 80178a0:	687b      	ldr	r3, [r7, #4]
 80178a2:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 80178a6:	687b      	ldr	r3, [r7, #4]
 80178a8:	f04f 0200 	mov.w	r2, #0
 80178ac:	63da      	str	r2, [r3, #60]	; 0x3c
 80178ae:	e000      	b.n	80178b2 <tcp_rexmit+0x86>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
 80178b0:	bf00      	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
 80178b2:	f107 0714 	add.w	r7, r7, #20
 80178b6:	46bd      	mov	sp, r7
 80178b8:	bd90      	pop	{r4, r7, pc}
 80178ba:	bf00      	nop

080178bc <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 80178bc:	b580      	push	{r7, lr}
 80178be:	b082      	sub	sp, #8
 80178c0:	af00      	add	r7, sp, #0
 80178c2:	6078      	str	r0, [r7, #4]
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 80178c4:	687b      	ldr	r3, [r7, #4]
 80178c6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80178c8:	2b00      	cmp	r3, #0
 80178ca:	d04e      	beq.n	801796a <tcp_rexmit_fast+0xae>
 80178cc:	687b      	ldr	r3, [r7, #4]
 80178ce:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 80178d2:	f003 0304 	and.w	r3, r3, #4
 80178d6:	2b00      	cmp	r3, #0
 80178d8:	d147      	bne.n	801796a <tcp_rexmit_fast+0xae>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 80178da:	6878      	ldr	r0, [r7, #4]
 80178dc:	f7ff ffa6 	bl	801782c <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd)
 80178e0:	687b      	ldr	r3, [r7, #4]
 80178e2:	f8b3 2052 	ldrh.w	r2, [r3, #82]	; 0x52
 80178e6:	687b      	ldr	r3, [r7, #4]
 80178e8:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 80178ec:	429a      	cmp	r2, r3
 80178ee:	d909      	bls.n	8017904 <tcp_rexmit_fast+0x48>
      pcb->ssthresh = pcb->snd_wnd / 2;
 80178f0:	687b      	ldr	r3, [r7, #4]
 80178f2:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 80178f6:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80178fa:	b29a      	uxth	r2, r3
 80178fc:	687b      	ldr	r3, [r7, #4]
 80178fe:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
 8017902:	e008      	b.n	8017916 <tcp_rexmit_fast+0x5a>
    else
      pcb->ssthresh = pcb->cwnd / 2;
 8017904:	687b      	ldr	r3, [r7, #4]
 8017906:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
 801790a:	ea4f 0353 	mov.w	r3, r3, lsr #1
 801790e:	b29a      	uxth	r2, r3
 8017910:	687b      	ldr	r3, [r7, #4]
 8017912:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 8017916:	687b      	ldr	r3, [r7, #4]
 8017918:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 801791c:	461a      	mov	r2, r3
 801791e:	687b      	ldr	r3, [r7, #4]
 8017920:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8017922:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017926:	429a      	cmp	r2, r3
 8017928:	da07      	bge.n	801793a <tcp_rexmit_fast+0x7e>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 801792a:	687b      	ldr	r3, [r7, #4]
 801792c:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801792e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8017932:	b29a      	uxth	r2, r3
 8017934:	687b      	ldr	r3, [r7, #4]
 8017936:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 801793a:	687b      	ldr	r3, [r7, #4]
 801793c:	f8b3 2054 	ldrh.w	r2, [r3, #84]	; 0x54
 8017940:	687b      	ldr	r3, [r7, #4]
 8017942:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8017944:	4619      	mov	r1, r3
 8017946:	ea4f 0141 	mov.w	r1, r1, lsl #1
 801794a:	18cb      	adds	r3, r1, r3
 801794c:	b29b      	uxth	r3, r3
 801794e:	18d3      	adds	r3, r2, r3
 8017950:	b29a      	uxth	r2, r3
 8017952:	687b      	ldr	r3, [r7, #4]
 8017954:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    pcb->flags |= TF_INFR;
 8017958:	687b      	ldr	r3, [r7, #4]
 801795a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 801795e:	f043 0304 	orr.w	r3, r3, #4
 8017962:	b2da      	uxtb	r2, r3
 8017964:	687b      	ldr	r3, [r7, #4]
 8017966:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  } 
}
 801796a:	f107 0708 	add.w	r7, r7, #8
 801796e:	46bd      	mov	sp, r7
 8017970:	bd80      	pop	{r7, pc}
 8017972:	bf00      	nop

08017974 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 8017974:	b580      	push	{r7, lr}
 8017976:	b086      	sub	sp, #24
 8017978:	af02      	add	r7, sp, #8
 801797a:	6078      	str	r0, [r7, #4]
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 801797c:	f04f 0001 	mov.w	r0, #1
 8017980:	f04f 0114 	mov.w	r1, #20
 8017984:	f04f 0200 	mov.w	r2, #0
 8017988:	f7fb f892 	bl	8012ab0 <pbuf_alloc>
 801798c:	60f8      	str	r0, [r7, #12]
   
  if(p == NULL) {
 801798e:	68fb      	ldr	r3, [r7, #12]
 8017990:	2b00      	cmp	r3, #0
 8017992:	d020      	beq.n	80179d6 <tcp_keepalive+0x62>
              (p->len >= sizeof(struct tcp_hdr)));

#if CHECKSUM_GEN_TCP
  tcphdr = tcp_output_set_header(pcb, p, 0, htonl(pcb->snd_nxt - 1));
#else
  tcp_output_set_header(pcb, p, 0, htonl(pcb->snd_nxt - 1));
 8017994:	687b      	ldr	r3, [r7, #4]
 8017996:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8017998:	f103 33ff 	add.w	r3, r3, #4294967295
 801799c:	4618      	mov	r0, r3
 801799e:	f001 fc03 	bl	80191a8 <htonl>
 80179a2:	4603      	mov	r3, r0
 80179a4:	6878      	ldr	r0, [r7, #4]
 80179a6:	68f9      	ldr	r1, [r7, #12]
 80179a8:	f04f 0200 	mov.w	r2, #0
 80179ac:	f7ff f83c 	bl	8016a28 <tcp_output_set_header>
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 80179b0:	6879      	ldr	r1, [r7, #4]
 80179b2:	687b      	ldr	r3, [r7, #4]
 80179b4:	f103 0204 	add.w	r2, r3, #4
 80179b8:	687b      	ldr	r3, [r7, #4]
 80179ba:	7adb      	ldrb	r3, [r3, #11]
 80179bc:	f04f 0000 	mov.w	r0, #0
 80179c0:	9000      	str	r0, [sp, #0]
 80179c2:	f04f 0006 	mov.w	r0, #6
 80179c6:	9001      	str	r0, [sp, #4]
 80179c8:	68f8      	ldr	r0, [r7, #12]
 80179ca:	f002 f88d 	bl	8019ae8 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 80179ce:	68f8      	ldr	r0, [r7, #12]
 80179d0:	f7fb fa76 	bl	8012ec0 <pbuf_free>
 80179d4:	e000      	b.n	80179d8 <tcp_keepalive+0x64>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
 80179d6:	bf00      	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 80179d8:	f107 0710 	add.w	r7, r7, #16
 80179dc:	46bd      	mov	sp, r7
 80179de:	bd80      	pop	{r7, pc}

080179e0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 80179e0:	b590      	push	{r4, r7, lr}
 80179e2:	b089      	sub	sp, #36	; 0x24
 80179e4:	af02      	add	r7, sp, #8
 80179e6:	6078      	str	r0, [r7, #4]
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 80179e8:	687b      	ldr	r3, [r7, #4]
 80179ea:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80179ec:	617b      	str	r3, [r7, #20]

  if(seg == NULL)
 80179ee:	697b      	ldr	r3, [r7, #20]
 80179f0:	2b00      	cmp	r3, #0
 80179f2:	d102      	bne.n	80179fa <tcp_zero_window_probe+0x1a>
    seg = pcb->unsent;
 80179f4:	687b      	ldr	r3, [r7, #4]
 80179f6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80179f8:	617b      	str	r3, [r7, #20]

  if(seg == NULL)
 80179fa:	697b      	ldr	r3, [r7, #20]
 80179fc:	2b00      	cmp	r3, #0
 80179fe:	d066      	beq.n	8017ace <tcp_zero_window_probe+0xee>
    return;

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8017a00:	697b      	ldr	r3, [r7, #20]
 8017a02:	691b      	ldr	r3, [r3, #16]
 8017a04:	899b      	ldrh	r3, [r3, #12]
 8017a06:	b29b      	uxth	r3, r3
 8017a08:	4618      	mov	r0, r3
 8017a0a:	f001 fbbd 	bl	8019188 <ntohs>
 8017a0e:	4603      	mov	r3, r0
 8017a10:	f003 0301 	and.w	r3, r3, #1
 8017a14:	2b00      	cmp	r3, #0
 8017a16:	d006      	beq.n	8017a26 <tcp_zero_window_probe+0x46>
 8017a18:	697b      	ldr	r3, [r7, #20]
 8017a1a:	899b      	ldrh	r3, [r3, #12]
 8017a1c:	2b00      	cmp	r3, #0
 8017a1e:	d102      	bne.n	8017a26 <tcp_zero_window_probe+0x46>
 8017a20:	f04f 0301 	mov.w	r3, #1
 8017a24:	e001      	b.n	8017a2a <tcp_zero_window_probe+0x4a>
 8017a26:	f04f 0300 	mov.w	r3, #0
 8017a2a:	74fb      	strb	r3, [r7, #19]
  len = is_fin ? TCP_HLEN : TCP_HLEN + 1;
 8017a2c:	7cfb      	ldrb	r3, [r7, #19]
 8017a2e:	2b00      	cmp	r3, #0
 8017a30:	d002      	beq.n	8017a38 <tcp_zero_window_probe+0x58>
 8017a32:	f04f 0314 	mov.w	r3, #20
 8017a36:	e001      	b.n	8017a3c <tcp_zero_window_probe+0x5c>
 8017a38:	f04f 0315 	mov.w	r3, #21
 8017a3c:	823b      	strh	r3, [r7, #16]

  p = pbuf_alloc(PBUF_IP, len, PBUF_RAM);
 8017a3e:	8a3b      	ldrh	r3, [r7, #16]
 8017a40:	f04f 0001 	mov.w	r0, #1
 8017a44:	4619      	mov	r1, r3
 8017a46:	f04f 0200 	mov.w	r2, #0
 8017a4a:	f7fb f831 	bl	8012ab0 <pbuf_alloc>
 8017a4e:	60f8      	str	r0, [r7, #12]
  if(p == NULL) {
 8017a50:	68fb      	ldr	r3, [r7, #12]
 8017a52:	2b00      	cmp	r3, #0
 8017a54:	d03d      	beq.n	8017ad2 <tcp_zero_window_probe+0xf2>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = tcp_output_set_header(pcb, p, 0, seg->tcphdr->seqno);
 8017a56:	697b      	ldr	r3, [r7, #20]
 8017a58:	691b      	ldr	r3, [r3, #16]
 8017a5a:	685b      	ldr	r3, [r3, #4]
 8017a5c:	6878      	ldr	r0, [r7, #4]
 8017a5e:	68f9      	ldr	r1, [r7, #12]
 8017a60:	f04f 0200 	mov.w	r2, #0
 8017a64:	f7fe ffe0 	bl	8016a28 <tcp_output_set_header>
 8017a68:	60b8      	str	r0, [r7, #8]

  if (is_fin) {
 8017a6a:	7cfb      	ldrb	r3, [r7, #19]
 8017a6c:	2b00      	cmp	r3, #0
 8017a6e:	d013      	beq.n	8017a98 <tcp_zero_window_probe+0xb8>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8017a70:	68bb      	ldr	r3, [r7, #8]
 8017a72:	899b      	ldrh	r3, [r3, #12]
 8017a74:	b29c      	uxth	r4, r3
 8017a76:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 8017a7a:	f001 fb6d 	bl	8019158 <htons>
 8017a7e:	4603      	mov	r3, r0
 8017a80:	4023      	ands	r3, r4
 8017a82:	b29c      	uxth	r4, r3
 8017a84:	f04f 0011 	mov.w	r0, #17
 8017a88:	f001 fb66 	bl	8019158 <htons>
 8017a8c:	4603      	mov	r3, r0
 8017a8e:	4323      	orrs	r3, r4
 8017a90:	b29a      	uxth	r2, r3
 8017a92:	68bb      	ldr	r3, [r7, #8]
 8017a94:	819a      	strh	r2, [r3, #12]
 8017a96:	e007      	b.n	8017aa8 <tcp_zero_window_probe+0xc8>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
 8017a98:	68fb      	ldr	r3, [r7, #12]
 8017a9a:	685b      	ldr	r3, [r3, #4]
 8017a9c:	f103 0314 	add.w	r3, r3, #20
 8017aa0:	697a      	ldr	r2, [r7, #20]
 8017aa2:	6892      	ldr	r2, [r2, #8]
 8017aa4:	7812      	ldrb	r2, [r2, #0]
 8017aa6:	701a      	strb	r2, [r3, #0]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 8017aa8:	6879      	ldr	r1, [r7, #4]
 8017aaa:	687b      	ldr	r3, [r7, #4]
 8017aac:	f103 0204 	add.w	r2, r3, #4
 8017ab0:	687b      	ldr	r3, [r7, #4]
 8017ab2:	7adb      	ldrb	r3, [r3, #11]
 8017ab4:	f04f 0000 	mov.w	r0, #0
 8017ab8:	9000      	str	r0, [sp, #0]
 8017aba:	f04f 0006 	mov.w	r0, #6
 8017abe:	9001      	str	r0, [sp, #4]
 8017ac0:	68f8      	ldr	r0, [r7, #12]
 8017ac2:	f002 f811 	bl	8019ae8 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 8017ac6:	68f8      	ldr	r0, [r7, #12]
 8017ac8:	f7fb f9fa 	bl	8012ec0 <pbuf_free>
 8017acc:	e002      	b.n	8017ad4 <tcp_zero_window_probe+0xf4>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
 8017ace:	bf00      	nop
 8017ad0:	e000      	b.n	8017ad4 <tcp_zero_window_probe+0xf4>
  len = is_fin ? TCP_HLEN : TCP_HLEN + 1;

  p = pbuf_alloc(PBUF_IP, len, PBUF_RAM);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
 8017ad2:	bf00      	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 8017ad4:	f107 071c 	add.w	r7, r7, #28
 8017ad8:	46bd      	mov	sp, r7
 8017ada:	bd90      	pop	{r4, r7, pc}

08017adc <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8017adc:	b590      	push	{r4, r7, lr}
 8017ade:	b08d      	sub	sp, #52	; 0x34
 8017ae0:	af02      	add	r7, sp, #8
 8017ae2:	6078      	str	r0, [r7, #4]
 8017ae4:	6039      	str	r1, [r7, #0]

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
 8017ae6:	687b      	ldr	r3, [r7, #4]
 8017ae8:	685b      	ldr	r3, [r3, #4]
 8017aea:	617b      	str	r3, [r7, #20]

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 8017aec:	687b      	ldr	r3, [r7, #4]
 8017aee:	891b      	ldrh	r3, [r3, #8]
 8017af0:	461c      	mov	r4, r3
 8017af2:	697b      	ldr	r3, [r7, #20]
 8017af4:	881b      	ldrh	r3, [r3, #0]
 8017af6:	b29b      	uxth	r3, r3
 8017af8:	4618      	mov	r0, r3
 8017afa:	f001 fb45 	bl	8019188 <ntohs>
 8017afe:	4603      	mov	r3, r0
 8017b00:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8017b04:	b29b      	uxth	r3, r3
 8017b06:	f003 030f 	and.w	r3, r3, #15
 8017b0a:	f103 0302 	add.w	r3, r3, #2
 8017b0e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017b12:	429c      	cmp	r4, r3
 8017b14:	db1b      	blt.n	8017b4e <udp_input+0x72>
 8017b16:	697b      	ldr	r3, [r7, #20]
 8017b18:	881b      	ldrh	r3, [r3, #0]
 8017b1a:	b29b      	uxth	r3, r3
 8017b1c:	4618      	mov	r0, r3
 8017b1e:	f001 fb33 	bl	8019188 <ntohs>
 8017b22:	4603      	mov	r3, r0
 8017b24:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8017b28:	b29b      	uxth	r3, r3
 8017b2a:	f003 030f 	and.w	r3, r3, #15
 8017b2e:	b29b      	uxth	r3, r3
 8017b30:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017b34:	b29b      	uxth	r3, r3
 8017b36:	f1c3 0300 	rsb	r3, r3, #0
 8017b3a:	b29b      	uxth	r3, r3
 8017b3c:	b29b      	uxth	r3, r3
 8017b3e:	b21b      	sxth	r3, r3
 8017b40:	6878      	ldr	r0, [r7, #4]
 8017b42:	4619      	mov	r1, r3
 8017b44:	f7fb f942 	bl	8012dcc <pbuf_header>
 8017b48:	4603      	mov	r3, r0
 8017b4a:	2b00      	cmp	r3, #0
 8017b4c:	d003      	beq.n	8017b56 <udp_input+0x7a>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
 8017b4e:	6878      	ldr	r0, [r7, #4]
 8017b50:	f7fb f9b6 	bl	8012ec0 <pbuf_free>
    goto end;
 8017b54:	e102      	b.n	8017d5c <udp_input+0x280>
  }

  udphdr = (struct udp_hdr *)p->payload;
 8017b56:	687b      	ldr	r3, [r7, #4]
 8017b58:	685b      	ldr	r3, [r3, #4]
 8017b5a:	613b      	str	r3, [r7, #16]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&(iphdr->dest), inp);
 8017b5c:	697b      	ldr	r3, [r7, #20]
 8017b5e:	f103 0310 	add.w	r3, r3, #16
 8017b62:	4618      	mov	r0, r3
 8017b64:	6839      	ldr	r1, [r7, #0]
 8017b66:	f001 ffe5 	bl	8019b34 <ip_addr_isbroadcast>
 8017b6a:	4603      	mov	r3, r0
 8017b6c:	73fb      	strb	r3, [r7, #15]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 8017b6e:	693b      	ldr	r3, [r7, #16]
 8017b70:	881b      	ldrh	r3, [r3, #0]
 8017b72:	b29b      	uxth	r3, r3
 8017b74:	4618      	mov	r0, r3
 8017b76:	f001 fb07 	bl	8019188 <ntohs>
 8017b7a:	4603      	mov	r3, r0
 8017b7c:	81bb      	strh	r3, [r7, #12]
  dest = ntohs(udphdr->dest);
 8017b7e:	693b      	ldr	r3, [r7, #16]
 8017b80:	885b      	ldrh	r3, [r3, #2]
 8017b82:	b29b      	uxth	r3, r3
 8017b84:	4618      	mov	r0, r3
 8017b86:	f001 faff 	bl	8019188 <ntohs>
 8017b8a:	4603      	mov	r3, r0
 8017b8c:	817b      	strh	r3, [r7, #10]
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
 8017b8e:	f04f 0300 	mov.w	r3, #0
 8017b92:	623b      	str	r3, [r7, #32]
    local_match = 0;
 8017b94:	f04f 0300 	mov.w	r3, #0
 8017b98:	76fb      	strb	r3, [r7, #27]
    uncon_pcb = NULL;
 8017b9a:	f04f 0300 	mov.w	r3, #0
 8017b9e:	61fb      	str	r3, [r7, #28]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8017ba0:	f246 5370 	movw	r3, #25968	; 0x6570
 8017ba4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017ba8:	681b      	ldr	r3, [r3, #0]
 8017baa:	627b      	str	r3, [r7, #36]	; 0x24
 8017bac:	e068      	b.n	8017c80 <udp_input+0x1a4>
      local_match = 0;
 8017bae:	f04f 0300 	mov.w	r3, #0
 8017bb2:	76fb      	strb	r3, [r7, #27]
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
 8017bb4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017bb6:	8a5b      	ldrh	r3, [r3, #18]
 8017bb8:	897a      	ldrh	r2, [r7, #10]
 8017bba:	429a      	cmp	r2, r3
 8017bbc:	d12f      	bne.n	8017c1e <udp_input+0x142>
 8017bbe:	7bfb      	ldrb	r3, [r7, #15]
 8017bc0:	2b00      	cmp	r3, #0
 8017bc2:	d106      	bne.n	8017bd2 <udp_input+0xf6>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 8017bc4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017bc6:	2b00      	cmp	r3, #0
 8017bc8:	d01b      	beq.n	8017c02 <udp_input+0x126>
 8017bca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017bcc:	681b      	ldr	r3, [r3, #0]
 8017bce:	2b00      	cmp	r3, #0
 8017bd0:	d017      	beq.n	8017c02 <udp_input+0x126>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
 8017bd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017bd4:	681a      	ldr	r2, [r3, #0]
 8017bd6:	697b      	ldr	r3, [r7, #20]
 8017bd8:	691b      	ldr	r3, [r3, #16]
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 8017bda:	429a      	cmp	r2, r3
 8017bdc:	d011      	beq.n	8017c02 <udp_input+0x126>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
 8017bde:	697b      	ldr	r3, [r7, #20]
 8017be0:	691c      	ldr	r4, [r3, #16]
 8017be2:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8017be6:	f001 fafd 	bl	80191e4 <ntohl>
 8017bea:	4603      	mov	r3, r0
 8017bec:	401c      	ands	r4, r3
 8017bee:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8017bf2:	f001 faf7 	bl	80191e4 <ntohl>
 8017bf6:	4603      	mov	r3, r0
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) ||
 8017bf8:	429c      	cmp	r4, r3
 8017bfa:	d002      	beq.n	8017c02 <udp_input+0x126>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
 8017bfc:	7bfb      	ldrb	r3, [r7, #15]
 8017bfe:	2b00      	cmp	r3, #0
 8017c00:	d00d      	beq.n	8017c1e <udp_input+0x142>
#if IP_SOF_BROADCAST_RECV
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
 8017c02:	f04f 0301 	mov.w	r3, #1
 8017c06:	76fb      	strb	r3, [r7, #27]
        if ((uncon_pcb == NULL) && 
 8017c08:	69fb      	ldr	r3, [r7, #28]
 8017c0a:	2b00      	cmp	r3, #0
 8017c0c:	d107      	bne.n	8017c1e <udp_input+0x142>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
 8017c0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c10:	7c1b      	ldrb	r3, [r3, #16]
 8017c12:	f003 0304 	and.w	r3, r3, #4
           (broadcast && (pcb->so_options & SOF_BROADCAST)))) {
#else  /* IP_SOF_BROADCAST_RECV */
           (broadcast))) {
#endif /* IP_SOF_BROADCAST_RECV */
        local_match = 1;
        if ((uncon_pcb == NULL) && 
 8017c16:	2b00      	cmp	r3, #0
 8017c18:	d101      	bne.n	8017c1e <udp_input+0x142>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 8017c1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c1c:	61fb      	str	r3, [r7, #28]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 8017c1e:	7efb      	ldrb	r3, [r7, #27]
 8017c20:	2b00      	cmp	r3, #0
 8017c22:	d028      	beq.n	8017c76 <udp_input+0x19a>
          (pcb->remote_port == src) &&
 8017c24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c26:	8a9b      	ldrh	r3, [r3, #20]
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 8017c28:	89ba      	ldrh	r2, [r7, #12]
 8017c2a:	429a      	cmp	r2, r3
 8017c2c:	d123      	bne.n	8017c76 <udp_input+0x19a>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 8017c2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c30:	f103 0304 	add.w	r3, r3, #4
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
 8017c34:	2b00      	cmp	r3, #0
 8017c36:	d009      	beq.n	8017c4c <udp_input+0x170>
          (ip_addr_isany(&pcb->remote_ip) ||
 8017c38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c3a:	685b      	ldr	r3, [r3, #4]
 8017c3c:	2b00      	cmp	r3, #0
 8017c3e:	d005      	beq.n	8017c4c <udp_input+0x170>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
 8017c40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c42:	685a      	ldr	r2, [r3, #4]
 8017c44:	697b      	ldr	r3, [r7, #20]
 8017c46:	68db      	ldr	r3, [r3, #12]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 8017c48:	429a      	cmp	r2, r3
 8017c4a:	d114      	bne.n	8017c76 <udp_input+0x19a>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 8017c4c:	6a3b      	ldr	r3, [r7, #32]
 8017c4e:	2b00      	cmp	r3, #0
 8017c50:	d01a      	beq.n	8017c88 <udp_input+0x1ac>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 8017c52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c54:	68da      	ldr	r2, [r3, #12]
 8017c56:	6a3b      	ldr	r3, [r7, #32]
 8017c58:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
 8017c5a:	f246 5370 	movw	r3, #25968	; 0x6570
 8017c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017c62:	681a      	ldr	r2, [r3, #0]
 8017c64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c66:	60da      	str	r2, [r3, #12]
          udp_pcbs = pcb;
 8017c68:	f246 5370 	movw	r3, #25968	; 0x6570
 8017c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017c70:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8017c72:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 8017c74:	e008      	b.n	8017c88 <udp_input+0x1ac>
      }
      prev = pcb;
 8017c76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c78:	623b      	str	r3, [r7, #32]
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8017c7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c7c:	68db      	ldr	r3, [r3, #12]
 8017c7e:	627b      	str	r3, [r7, #36]	; 0x24
 8017c80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c82:	2b00      	cmp	r3, #0
 8017c84:	d193      	bne.n	8017bae <udp_input+0xd2>
 8017c86:	e000      	b.n	8017c8a <udp_input+0x1ae>
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 8017c88:	bf00      	nop
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
 8017c8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c8c:	2b00      	cmp	r3, #0
 8017c8e:	d101      	bne.n	8017c94 <udp_input+0x1b8>
      pcb = uncon_pcb;
 8017c90:	69fb      	ldr	r3, [r7, #28]
 8017c92:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
 8017c94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017c96:	2b00      	cmp	r3, #0
 8017c98:	d105      	bne.n	8017ca6 <udp_input+0x1ca>
 8017c9a:	683b      	ldr	r3, [r7, #0]
 8017c9c:	685a      	ldr	r2, [r3, #4]
 8017c9e:	697b      	ldr	r3, [r7, #20]
 8017ca0:	691b      	ldr	r3, [r3, #16]
 8017ca2:	429a      	cmp	r2, r3
 8017ca4:	d157      	bne.n	8017d56 <udp_input+0x27a>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 8017ca6:	6878      	ldr	r0, [r7, #4]
 8017ca8:	f06f 0107 	mvn.w	r1, #7
 8017cac:	f7fb f88e 	bl	8012dcc <pbuf_header>
 8017cb0:	4603      	mov	r3, r0
 8017cb2:	2b00      	cmp	r3, #0
 8017cb4:	d003      	beq.n	8017cbe <udp_input+0x1e2>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
 8017cb6:	6878      	ldr	r0, [r7, #4]
 8017cb8:	f7fb f902 	bl	8012ec0 <pbuf_free>
      goto end;
 8017cbc:	e04e      	b.n	8017d5c <udp_input+0x280>
    }
    if (pcb != NULL) {
 8017cbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017cc0:	2b00      	cmp	r3, #0
 8017cc2:	d015      	beq.n	8017cf0 <udp_input+0x214>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
 8017cc4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017cc6:	69db      	ldr	r3, [r3, #28]
 8017cc8:	2b00      	cmp	r3, #0
 8017cca:	d00d      	beq.n	8017ce8 <udp_input+0x20c>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &iphdr->src, src);
 8017ccc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017cce:	69dc      	ldr	r4, [r3, #28]
 8017cd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017cd2:	6a1a      	ldr	r2, [r3, #32]
 8017cd4:	697b      	ldr	r3, [r7, #20]
 8017cd6:	f103 030c 	add.w	r3, r3, #12
 8017cda:	89b9      	ldrh	r1, [r7, #12]
 8017cdc:	9100      	str	r1, [sp, #0]
 8017cde:	4610      	mov	r0, r2
 8017ce0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8017ce2:	687a      	ldr	r2, [r7, #4]
 8017ce4:	47a0      	blx	r4
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 8017ce6:	e039      	b.n	8017d5c <udp_input+0x280>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &iphdr->src, src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
 8017ce8:	6878      	ldr	r0, [r7, #4]
 8017cea:	f7fb f8e9 	bl	8012ec0 <pbuf_free>
        goto end;
 8017cee:	e035      	b.n	8017d5c <udp_input+0x280>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 8017cf0:	7bfb      	ldrb	r3, [r7, #15]
 8017cf2:	2b00      	cmp	r3, #0
 8017cf4:	d12b      	bne.n	8017d4e <udp_input+0x272>
          !ip_addr_ismulticast(&iphdr->dest)) {
 8017cf6:	697b      	ldr	r3, [r7, #20]
 8017cf8:	691c      	ldr	r4, [r3, #16]
 8017cfa:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8017cfe:	f001 fa71 	bl	80191e4 <ntohl>
 8017d02:	4603      	mov	r3, r0
 8017d04:	401c      	ands	r4, r3
 8017d06:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8017d0a:	f001 fa6b 	bl	80191e4 <ntohl>
 8017d0e:	4603      	mov	r3, r0
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 8017d10:	429c      	cmp	r4, r3
 8017d12:	d01c      	beq.n	8017d4e <udp_input+0x272>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 8017d14:	697b      	ldr	r3, [r7, #20]
 8017d16:	881b      	ldrh	r3, [r3, #0]
 8017d18:	b29b      	uxth	r3, r3
 8017d1a:	4618      	mov	r0, r3
 8017d1c:	f001 fa34 	bl	8019188 <ntohs>
 8017d20:	4603      	mov	r3, r0
 8017d22:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8017d26:	b29b      	uxth	r3, r3
 8017d28:	f003 030f 	and.w	r3, r3, #15
 8017d2c:	f103 0302 	add.w	r3, r3, #2
 8017d30:	b29b      	uxth	r3, r3
 8017d32:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8017d36:	b29b      	uxth	r3, r3
 8017d38:	b29b      	uxth	r3, r3
 8017d3a:	b21b      	sxth	r3, r3
 8017d3c:	6878      	ldr	r0, [r7, #4]
 8017d3e:	4619      	mov	r1, r3
 8017d40:	f7fb f844 	bl	8012dcc <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 8017d44:	6878      	ldr	r0, [r7, #4]
 8017d46:	f04f 0103 	mov.w	r1, #3
 8017d4a:	f000 fb3b 	bl	80183c4 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
 8017d4e:	6878      	ldr	r0, [r7, #4]
 8017d50:	f7fb f8b6 	bl	8012ec0 <pbuf_free>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 8017d54:	e002      	b.n	8017d5c <udp_input+0x280>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
 8017d56:	6878      	ldr	r0, [r7, #4]
 8017d58:	f7fb f8b2 	bl	8012ec0 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
 8017d5c:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 8017d60:	46bd      	mov	sp, r7
 8017d62:	bd90      	pop	{r4, r7, pc}

08017d64 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
 8017d64:	b580      	push	{r7, lr}
 8017d66:	b082      	sub	sp, #8
 8017d68:	af00      	add	r7, sp, #0
 8017d6a:	6078      	str	r0, [r7, #4]
 8017d6c:	6039      	str	r1, [r7, #0]
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 8017d6e:	687b      	ldr	r3, [r7, #4]
 8017d70:	f103 0204 	add.w	r2, r3, #4
 8017d74:	687b      	ldr	r3, [r7, #4]
 8017d76:	8a9b      	ldrh	r3, [r3, #20]
 8017d78:	6878      	ldr	r0, [r7, #4]
 8017d7a:	6839      	ldr	r1, [r7, #0]
 8017d7c:	f000 f806 	bl	8017d8c <udp_sendto>
 8017d80:	4603      	mov	r3, r0
}
 8017d82:	4618      	mov	r0, r3
 8017d84:	f107 0708 	add.w	r7, r7, #8
 8017d88:	46bd      	mov	sp, r7
 8017d8a:	bd80      	pop	{r7, pc}

08017d8c <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
 8017d8c:	b590      	push	{r4, r7, lr}
 8017d8e:	b089      	sub	sp, #36	; 0x24
 8017d90:	af02      	add	r7, sp, #8
 8017d92:	60f8      	str	r0, [r7, #12]
 8017d94:	60b9      	str	r1, [r7, #8]
 8017d96:	607a      	str	r2, [r7, #4]
 8017d98:	807b      	strh	r3, [r7, #2]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
 8017d9a:	687b      	ldr	r3, [r7, #4]
 8017d9c:	681c      	ldr	r4, [r3, #0]
 8017d9e:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8017da2:	f001 fa1f 	bl	80191e4 <ntohl>
 8017da6:	4603      	mov	r3, r0
 8017da8:	401c      	ands	r4, r3
 8017daa:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8017dae:	f001 fa19 	bl	80191e4 <ntohl>
 8017db2:	4603      	mov	r3, r0
 8017db4:	429c      	cmp	r4, r3
 8017db6:	d103      	bne.n	8017dc0 <udp_sendto+0x34>
 8017db8:	68fb      	ldr	r3, [r7, #12]
 8017dba:	f103 0316 	add.w	r3, r3, #22
 8017dbe:	e000      	b.n	8017dc2 <udp_sendto+0x36>
 8017dc0:	687b      	ldr	r3, [r7, #4]
 8017dc2:	4618      	mov	r0, r3
 8017dc4:	f001 fb90 	bl	80194e8 <ip_route>
 8017dc8:	6178      	str	r0, [r7, #20]
#else
  netif = ip_route(dst_ip);
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 8017dca:	697b      	ldr	r3, [r7, #20]
 8017dcc:	2b00      	cmp	r3, #0
 8017dce:	d102      	bne.n	8017dd6 <udp_sendto+0x4a>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 8017dd0:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 8017dd4:	e008      	b.n	8017de8 <udp_sendto+0x5c>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 8017dd6:	887b      	ldrh	r3, [r7, #2]
 8017dd8:	697a      	ldr	r2, [r7, #20]
 8017dda:	9200      	str	r2, [sp, #0]
 8017ddc:	68f8      	ldr	r0, [r7, #12]
 8017dde:	68b9      	ldr	r1, [r7, #8]
 8017de0:	687a      	ldr	r2, [r7, #4]
 8017de2:	f000 f807 	bl	8017df4 <udp_sendto_if>
 8017de6:	4603      	mov	r3, r0
 8017de8:	b25b      	sxtb	r3, r3
}
 8017dea:	4618      	mov	r0, r3
 8017dec:	f107 071c 	add.w	r7, r7, #28
 8017df0:	46bd      	mov	sp, r7
 8017df2:	bd90      	pop	{r4, r7, pc}

08017df4 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
 8017df4:	b580      	push	{r7, lr}
 8017df6:	b08c      	sub	sp, #48	; 0x30
 8017df8:	af04      	add	r7, sp, #16
 8017dfa:	60f8      	str	r0, [r7, #12]
 8017dfc:	60b9      	str	r1, [r7, #8]
 8017dfe:	607a      	str	r2, [r7, #4]
 8017e00:	807b      	strh	r3, [r7, #2]
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 8017e02:	68fb      	ldr	r3, [r7, #12]
 8017e04:	8a5b      	ldrh	r3, [r3, #18]
 8017e06:	2b00      	cmp	r3, #0
 8017e08:	d10f      	bne.n	8017e2a <udp_sendto_if+0x36>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 8017e0a:	68fa      	ldr	r2, [r7, #12]
 8017e0c:	68fb      	ldr	r3, [r7, #12]
 8017e0e:	8a5b      	ldrh	r3, [r3, #18]
 8017e10:	68f8      	ldr	r0, [r7, #12]
 8017e12:	4611      	mov	r1, r2
 8017e14:	461a      	mov	r2, r3
 8017e16:	f000 f88d 	bl	8017f34 <udp_bind>
 8017e1a:	4603      	mov	r3, r0
 8017e1c:	75fb      	strb	r3, [r7, #23]
    if (err != ERR_OK) {
 8017e1e:	f997 3017 	ldrsb.w	r3, [r7, #23]
 8017e22:	2b00      	cmp	r3, #0
 8017e24:	d001      	beq.n	8017e2a <udp_sendto_if+0x36>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 8017e26:	7dfb      	ldrb	r3, [r7, #23]
 8017e28:	e07e      	b.n	8017f28 <udp_sendto_if+0x134>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
 8017e2a:	68b8      	ldr	r0, [r7, #8]
 8017e2c:	f04f 0108 	mov.w	r1, #8
 8017e30:	f7fa ffcc 	bl	8012dcc <pbuf_header>
 8017e34:	4603      	mov	r3, r0
 8017e36:	2b00      	cmp	r3, #0
 8017e38:	d013      	beq.n	8017e62 <udp_sendto_if+0x6e>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8017e3a:	f04f 0001 	mov.w	r0, #1
 8017e3e:	f04f 0108 	mov.w	r1, #8
 8017e42:	f04f 0200 	mov.w	r2, #0
 8017e46:	f7fa fe33 	bl	8012ab0 <pbuf_alloc>
 8017e4a:	61b8      	str	r0, [r7, #24]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 8017e4c:	69bb      	ldr	r3, [r7, #24]
 8017e4e:	2b00      	cmp	r3, #0
 8017e50:	d102      	bne.n	8017e58 <udp_sendto_if+0x64>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 8017e52:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8017e56:	e067      	b.n	8017f28 <udp_sendto_if+0x134>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
 8017e58:	69b8      	ldr	r0, [r7, #24]
 8017e5a:	68b9      	ldr	r1, [r7, #8]
 8017e5c:	f7fb f8e0 	bl	8013020 <pbuf_chain>
 8017e60:	e001      	b.n	8017e66 <udp_sendto_if+0x72>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 8017e62:	68bb      	ldr	r3, [r7, #8]
 8017e64:	61bb      	str	r3, [r7, #24]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
 8017e66:	69bb      	ldr	r3, [r7, #24]
 8017e68:	685b      	ldr	r3, [r3, #4]
 8017e6a:	613b      	str	r3, [r7, #16]
  udphdr->src = htons(pcb->local_port);
 8017e6c:	68fb      	ldr	r3, [r7, #12]
 8017e6e:	8a5b      	ldrh	r3, [r3, #18]
 8017e70:	4618      	mov	r0, r3
 8017e72:	f001 f971 	bl	8019158 <htons>
 8017e76:	4603      	mov	r3, r0
 8017e78:	461a      	mov	r2, r3
 8017e7a:	693b      	ldr	r3, [r7, #16]
 8017e7c:	801a      	strh	r2, [r3, #0]
  udphdr->dest = htons(dst_port);
 8017e7e:	887b      	ldrh	r3, [r7, #2]
 8017e80:	4618      	mov	r0, r3
 8017e82:	f001 f969 	bl	8019158 <htons>
 8017e86:	4603      	mov	r3, r0
 8017e88:	461a      	mov	r2, r3
 8017e8a:	693b      	ldr	r3, [r7, #16]
 8017e8c:	805a      	strh	r2, [r3, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 8017e8e:	693b      	ldr	r3, [r7, #16]
 8017e90:	f04f 0200 	mov.w	r2, #0
 8017e94:	719a      	strb	r2, [r3, #6]
 8017e96:	f04f 0200 	mov.w	r2, #0
 8017e9a:	71da      	strb	r2, [r3, #7]

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 8017e9c:	68fb      	ldr	r3, [r7, #12]
 8017e9e:	2b00      	cmp	r3, #0
 8017ea0:	d003      	beq.n	8017eaa <udp_sendto_if+0xb6>
 8017ea2:	68fb      	ldr	r3, [r7, #12]
 8017ea4:	681b      	ldr	r3, [r3, #0]
 8017ea6:	2b00      	cmp	r3, #0
 8017ea8:	d104      	bne.n	8017eb4 <udp_sendto_if+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 8017eaa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017eac:	f103 0304 	add.w	r3, r3, #4
 8017eb0:	61fb      	str	r3, [r7, #28]
 8017eb2:	e014      	b.n	8017ede <udp_sendto_if+0xea>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 8017eb4:	68fb      	ldr	r3, [r7, #12]
 8017eb6:	681a      	ldr	r2, [r3, #0]
 8017eb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017eba:	685b      	ldr	r3, [r3, #4]
 8017ebc:	429a      	cmp	r2, r3
 8017ebe:	d00c      	beq.n	8017eda <udp_sendto_if+0xe6>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
 8017ec0:	69ba      	ldr	r2, [r7, #24]
 8017ec2:	68bb      	ldr	r3, [r7, #8]
 8017ec4:	429a      	cmp	r2, r3
 8017ec6:	d005      	beq.n	8017ed4 <udp_sendto_if+0xe0>
        /* free the header pbuf */
        pbuf_free(q);
 8017ec8:	69b8      	ldr	r0, [r7, #24]
 8017eca:	f7fa fff9 	bl	8012ec0 <pbuf_free>
        q = NULL;
 8017ece:	f04f 0300 	mov.w	r3, #0
 8017ed2:	61bb      	str	r3, [r7, #24]
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 8017ed4:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8017ed8:	e026      	b.n	8017f28 <udp_sendto_if+0x134>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 8017eda:	68fb      	ldr	r3, [r7, #12]
 8017edc:	61fb      	str	r3, [r7, #28]
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
 8017ede:	69bb      	ldr	r3, [r7, #24]
 8017ee0:	891b      	ldrh	r3, [r3, #8]
 8017ee2:	4618      	mov	r0, r3
 8017ee4:	f001 f938 	bl	8019158 <htons>
 8017ee8:	4603      	mov	r3, r0
 8017eea:	461a      	mov	r2, r3
 8017eec:	693b      	ldr	r3, [r7, #16]
 8017eee:	809a      	strh	r2, [r3, #4]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 8017ef0:	68fb      	ldr	r3, [r7, #12]
 8017ef2:	7adb      	ldrb	r3, [r3, #11]
 8017ef4:	68fa      	ldr	r2, [r7, #12]
 8017ef6:	7a92      	ldrb	r2, [r2, #10]
 8017ef8:	9200      	str	r2, [sp, #0]
 8017efa:	f04f 0211 	mov.w	r2, #17
 8017efe:	9201      	str	r2, [sp, #4]
 8017f00:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017f02:	9202      	str	r2, [sp, #8]
 8017f04:	69b8      	ldr	r0, [r7, #24]
 8017f06:	69f9      	ldr	r1, [r7, #28]
 8017f08:	687a      	ldr	r2, [r7, #4]
 8017f0a:	f001 fcb3 	bl	8019874 <ip_output_if>
 8017f0e:	4603      	mov	r3, r0
 8017f10:	75fb      	strb	r3, [r7, #23]
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 8017f12:	69ba      	ldr	r2, [r7, #24]
 8017f14:	68bb      	ldr	r3, [r7, #8]
 8017f16:	429a      	cmp	r2, r3
 8017f18:	d005      	beq.n	8017f26 <udp_sendto_if+0x132>
    /* free the header pbuf */
    pbuf_free(q);
 8017f1a:	69b8      	ldr	r0, [r7, #24]
 8017f1c:	f7fa ffd0 	bl	8012ec0 <pbuf_free>
    q = NULL;
 8017f20:	f04f 0300 	mov.w	r3, #0
 8017f24:	61bb      	str	r3, [r7, #24]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 8017f26:	7dfb      	ldrb	r3, [r7, #23]
 8017f28:	b25b      	sxtb	r3, r3
}
 8017f2a:	4618      	mov	r0, r3
 8017f2c:	f107 0720 	add.w	r7, r7, #32
 8017f30:	46bd      	mov	sp, r7
 8017f32:	bd80      	pop	{r7, pc}

08017f34 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
 8017f34:	b480      	push	{r7}
 8017f36:	b087      	sub	sp, #28
 8017f38:	af00      	add	r7, sp, #0
 8017f3a:	60f8      	str	r0, [r7, #12]
 8017f3c:	60b9      	str	r1, [r7, #8]
 8017f3e:	4613      	mov	r3, r2
 8017f40:	80fb      	strh	r3, [r7, #6]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 8017f42:	f04f 0300 	mov.w	r3, #0
 8017f46:	74fb      	strb	r3, [r7, #19]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8017f48:	f246 5370 	movw	r3, #25968	; 0x6570
 8017f4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017f50:	681b      	ldr	r3, [r3, #0]
 8017f52:	617b      	str	r3, [r7, #20]
 8017f54:	e009      	b.n	8017f6a <udp_bind+0x36>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 8017f56:	68fa      	ldr	r2, [r7, #12]
 8017f58:	697b      	ldr	r3, [r7, #20]
 8017f5a:	429a      	cmp	r2, r3
 8017f5c:	d102      	bne.n	8017f64 <udp_bind+0x30>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 8017f5e:	f04f 0301 	mov.w	r3, #1
 8017f62:	74fb      	strb	r3, [r7, #19]
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8017f64:	697b      	ldr	r3, [r7, #20]
 8017f66:	68db      	ldr	r3, [r3, #12]
 8017f68:	617b      	str	r3, [r7, #20]
 8017f6a:	697b      	ldr	r3, [r7, #20]
 8017f6c:	2b00      	cmp	r3, #0
 8017f6e:	d1f2      	bne.n	8017f56 <udp_bind+0x22>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 8017f70:	68bb      	ldr	r3, [r7, #8]
 8017f72:	2b00      	cmp	r3, #0
 8017f74:	d002      	beq.n	8017f7c <udp_bind+0x48>
 8017f76:	68bb      	ldr	r3, [r7, #8]
 8017f78:	681b      	ldr	r3, [r3, #0]
 8017f7a:	e001      	b.n	8017f80 <udp_bind+0x4c>
 8017f7c:	f04f 0300 	mov.w	r3, #0
 8017f80:	68fa      	ldr	r2, [r7, #12]
 8017f82:	6013      	str	r3, [r2, #0]

  /* no port specified? */
  if (port == 0) {
 8017f84:	88fb      	ldrh	r3, [r7, #6]
 8017f86:	2b00      	cmp	r3, #0
 8017f88:	d12a      	bne.n	8017fe0 <udp_bind+0xac>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
 8017f8a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8017f8e:	80fb      	strh	r3, [r7, #6]
    ipcb = udp_pcbs;
 8017f90:	f246 5370 	movw	r3, #25968	; 0x6570
 8017f94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017f98:	681b      	ldr	r3, [r3, #0]
 8017f9a:	617b      	str	r3, [r7, #20]
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
 8017f9c:	e012      	b.n	8017fc4 <udp_bind+0x90>
      if (ipcb->local_port == port) {
 8017f9e:	697b      	ldr	r3, [r7, #20]
 8017fa0:	8a5b      	ldrh	r3, [r3, #18]
 8017fa2:	88fa      	ldrh	r2, [r7, #6]
 8017fa4:	429a      	cmp	r2, r3
 8017fa6:	d10a      	bne.n	8017fbe <udp_bind+0x8a>
        /* port is already used by another udp_pcb */
        port++;
 8017fa8:	88fb      	ldrh	r3, [r7, #6]
 8017faa:	f103 0301 	add.w	r3, r3, #1
 8017fae:	80fb      	strh	r3, [r7, #6]
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
 8017fb0:	f246 5370 	movw	r3, #25968	; 0x6570
 8017fb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017fb8:	681b      	ldr	r3, [r3, #0]
 8017fba:	617b      	str	r3, [r7, #20]
 8017fbc:	e002      	b.n	8017fc4 <udp_bind+0x90>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
 8017fbe:	697b      	ldr	r3, [r7, #20]
 8017fc0:	68db      	ldr	r3, [r3, #12]
 8017fc2:	617b      	str	r3, [r7, #20]
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
 8017fc4:	697b      	ldr	r3, [r7, #20]
 8017fc6:	2b00      	cmp	r3, #0
 8017fc8:	d004      	beq.n	8017fd4 <udp_bind+0xa0>
 8017fca:	88fa      	ldrh	r2, [r7, #6]
 8017fcc:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8017fd0:	429a      	cmp	r2, r3
 8017fd2:	d1e4      	bne.n	8017f9e <udp_bind+0x6a>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
 8017fd4:	697b      	ldr	r3, [r7, #20]
 8017fd6:	2b00      	cmp	r3, #0
 8017fd8:	d002      	beq.n	8017fe0 <udp_bind+0xac>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 8017fda:	f04f 03f5 	mov.w	r3, #245	; 0xf5
 8017fde:	e014      	b.n	801800a <udp_bind+0xd6>
    }
  }
  pcb->local_port = port;
 8017fe0:	68fb      	ldr	r3, [r7, #12]
 8017fe2:	88fa      	ldrh	r2, [r7, #6]
 8017fe4:	825a      	strh	r2, [r3, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 8017fe6:	7cfb      	ldrb	r3, [r7, #19]
 8017fe8:	2b00      	cmp	r3, #0
 8017fea:	d10c      	bne.n	8018006 <udp_bind+0xd2>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 8017fec:	f246 5370 	movw	r3, #25968	; 0x6570
 8017ff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017ff4:	681a      	ldr	r2, [r3, #0]
 8017ff6:	68fb      	ldr	r3, [r7, #12]
 8017ff8:	60da      	str	r2, [r3, #12]
    udp_pcbs = pcb;
 8017ffa:	f246 5370 	movw	r3, #25968	; 0x6570
 8017ffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018002:	68fa      	ldr	r2, [r7, #12]
 8018004:	601a      	str	r2, [r3, #0]
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)((ntohl(pcb->local_ip.addr) >> 24) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->local_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
 8018006:	f04f 0300 	mov.w	r3, #0
 801800a:	b25b      	sxtb	r3, r3
}
 801800c:	4618      	mov	r0, r3
 801800e:	f107 071c 	add.w	r7, r7, #28
 8018012:	46bd      	mov	sp, r7
 8018014:	bc80      	pop	{r7}
 8018016:	4770      	bx	lr

08018018 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
 8018018:	b580      	push	{r7, lr}
 801801a:	b086      	sub	sp, #24
 801801c:	af00      	add	r7, sp, #0
 801801e:	60f8      	str	r0, [r7, #12]
 8018020:	60b9      	str	r1, [r7, #8]
 8018022:	4613      	mov	r3, r2
 8018024:	80fb      	strh	r3, [r7, #6]
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 8018026:	68fb      	ldr	r3, [r7, #12]
 8018028:	8a5b      	ldrh	r3, [r3, #18]
 801802a:	2b00      	cmp	r3, #0
 801802c:	d10f      	bne.n	801804e <udp_connect+0x36>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 801802e:	68fa      	ldr	r2, [r7, #12]
 8018030:	68fb      	ldr	r3, [r7, #12]
 8018032:	8a5b      	ldrh	r3, [r3, #18]
 8018034:	68f8      	ldr	r0, [r7, #12]
 8018036:	4611      	mov	r1, r2
 8018038:	461a      	mov	r2, r3
 801803a:	f7ff ff7b 	bl	8017f34 <udp_bind>
 801803e:	4603      	mov	r3, r0
 8018040:	74fb      	strb	r3, [r7, #19]
    if (err != ERR_OK)
 8018042:	f997 3013 	ldrsb.w	r3, [r7, #19]
 8018046:	2b00      	cmp	r3, #0
 8018048:	d001      	beq.n	801804e <udp_connect+0x36>
      return err;
 801804a:	7cfb      	ldrb	r3, [r7, #19]
 801804c:	e036      	b.n	80180bc <udp_connect+0xa4>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 801804e:	68bb      	ldr	r3, [r7, #8]
 8018050:	2b00      	cmp	r3, #0
 8018052:	d002      	beq.n	801805a <udp_connect+0x42>
 8018054:	68bb      	ldr	r3, [r7, #8]
 8018056:	681b      	ldr	r3, [r3, #0]
 8018058:	e001      	b.n	801805e <udp_connect+0x46>
 801805a:	f04f 0300 	mov.w	r3, #0
 801805e:	68fa      	ldr	r2, [r7, #12]
 8018060:	6053      	str	r3, [r2, #4]
  pcb->remote_port = port;
 8018062:	68fb      	ldr	r3, [r7, #12]
 8018064:	88fa      	ldrh	r2, [r7, #6]
 8018066:	829a      	strh	r2, [r3, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 8018068:	68fb      	ldr	r3, [r7, #12]
 801806a:	7c1b      	ldrb	r3, [r3, #16]
 801806c:	f043 0304 	orr.w	r3, r3, #4
 8018070:	b2da      	uxtb	r2, r3
 8018072:	68fb      	ldr	r3, [r7, #12]
 8018074:	741a      	strb	r2, [r3, #16]
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8018076:	f246 5370 	movw	r3, #25968	; 0x6570
 801807a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801807e:	681b      	ldr	r3, [r3, #0]
 8018080:	617b      	str	r3, [r7, #20]
 8018082:	e009      	b.n	8018098 <udp_connect+0x80>
    if (pcb == ipcb) {
 8018084:	68fa      	ldr	r2, [r7, #12]
 8018086:	697b      	ldr	r3, [r7, #20]
 8018088:	429a      	cmp	r2, r3
 801808a:	d102      	bne.n	8018092 <udp_connect+0x7a>
      /* already on the list, just return */
      return ERR_OK;
 801808c:	f04f 0300 	mov.w	r3, #0
 8018090:	e014      	b.n	80180bc <udp_connect+0xa4>
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 16) & 0xff),
               (u16_t)((ntohl(pcb->remote_ip.addr) >> 8) & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8018092:	697b      	ldr	r3, [r7, #20]
 8018094:	68db      	ldr	r3, [r3, #12]
 8018096:	617b      	str	r3, [r7, #20]
 8018098:	697b      	ldr	r3, [r7, #20]
 801809a:	2b00      	cmp	r3, #0
 801809c:	d1f2      	bne.n	8018084 <udp_connect+0x6c>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 801809e:	f246 5370 	movw	r3, #25968	; 0x6570
 80180a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80180a6:	681a      	ldr	r2, [r3, #0]
 80180a8:	68fb      	ldr	r3, [r7, #12]
 80180aa:	60da      	str	r2, [r3, #12]
  udp_pcbs = pcb;
 80180ac:	f246 5370 	movw	r3, #25968	; 0x6570
 80180b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80180b4:	68fa      	ldr	r2, [r7, #12]
 80180b6:	601a      	str	r2, [r3, #0]
  return ERR_OK;
 80180b8:	f04f 0300 	mov.w	r3, #0
 80180bc:	b25b      	sxtb	r3, r3
}
 80180be:	4618      	mov	r0, r3
 80180c0:	f107 0718 	add.w	r7, r7, #24
 80180c4:	46bd      	mov	sp, r7
 80180c6:	bd80      	pop	{r7, pc}

080180c8 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
 80180c8:	b480      	push	{r7}
 80180ca:	b083      	sub	sp, #12
 80180cc:	af00      	add	r7, sp, #0
 80180ce:	6078      	str	r0, [r7, #4]
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
 80180d0:	f646 0378 	movw	r3, #26744	; 0x6878
 80180d4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80180d8:	681a      	ldr	r2, [r3, #0]
 80180da:	687b      	ldr	r3, [r7, #4]
 80180dc:	605a      	str	r2, [r3, #4]
  pcb->remote_port = 0;
 80180de:	687b      	ldr	r3, [r7, #4]
 80180e0:	f04f 0200 	mov.w	r2, #0
 80180e4:	829a      	strh	r2, [r3, #20]
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 80180e6:	687b      	ldr	r3, [r7, #4]
 80180e8:	7c1b      	ldrb	r3, [r3, #16]
 80180ea:	f023 0304 	bic.w	r3, r3, #4
 80180ee:	b2da      	uxtb	r2, r3
 80180f0:	687b      	ldr	r3, [r7, #4]
 80180f2:	741a      	strb	r2, [r3, #16]
}
 80180f4:	f107 070c 	add.w	r7, r7, #12
 80180f8:	46bd      	mov	sp, r7
 80180fa:	bc80      	pop	{r7}
 80180fc:	4770      	bx	lr
 80180fe:	bf00      	nop

08018100 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
 8018100:	b480      	push	{r7}
 8018102:	b085      	sub	sp, #20
 8018104:	af00      	add	r7, sp, #0
 8018106:	60f8      	str	r0, [r7, #12]
 8018108:	60b9      	str	r1, [r7, #8]
 801810a:	607a      	str	r2, [r7, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
 801810c:	68fb      	ldr	r3, [r7, #12]
 801810e:	68ba      	ldr	r2, [r7, #8]
 8018110:	61da      	str	r2, [r3, #28]
  pcb->recv_arg = recv_arg;
 8018112:	68fb      	ldr	r3, [r7, #12]
 8018114:	687a      	ldr	r2, [r7, #4]
 8018116:	621a      	str	r2, [r3, #32]
}
 8018118:	f107 0714 	add.w	r7, r7, #20
 801811c:	46bd      	mov	sp, r7
 801811e:	bc80      	pop	{r7}
 8018120:	4770      	bx	lr
 8018122:	bf00      	nop

08018124 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8018124:	b580      	push	{r7, lr}
 8018126:	b084      	sub	sp, #16
 8018128:	af00      	add	r7, sp, #0
 801812a:	6078      	str	r0, [r7, #4]
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 801812c:	f246 5370 	movw	r3, #25968	; 0x6570
 8018130:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018134:	681a      	ldr	r2, [r3, #0]
 8018136:	687b      	ldr	r3, [r7, #4]
 8018138:	429a      	cmp	r2, r3
 801813a:	d10b      	bne.n	8018154 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 801813c:	f246 5370 	movw	r3, #25968	; 0x6570
 8018140:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018144:	681b      	ldr	r3, [r3, #0]
 8018146:	68da      	ldr	r2, [r3, #12]
 8018148:	f246 5370 	movw	r3, #25968	; 0x6570
 801814c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018150:	601a      	str	r2, [r3, #0]
 8018152:	e019      	b.n	8018188 <udp_remove+0x64>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8018154:	f246 5370 	movw	r3, #25968	; 0x6570
 8018158:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801815c:	681b      	ldr	r3, [r3, #0]
 801815e:	60fb      	str	r3, [r7, #12]
 8018160:	e00f      	b.n	8018182 <udp_remove+0x5e>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8018162:	68fb      	ldr	r3, [r7, #12]
 8018164:	68db      	ldr	r3, [r3, #12]
 8018166:	2b00      	cmp	r3, #0
 8018168:	d008      	beq.n	801817c <udp_remove+0x58>
 801816a:	68fb      	ldr	r3, [r7, #12]
 801816c:	68da      	ldr	r2, [r3, #12]
 801816e:	687b      	ldr	r3, [r7, #4]
 8018170:	429a      	cmp	r2, r3
 8018172:	d103      	bne.n	801817c <udp_remove+0x58>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8018174:	687b      	ldr	r3, [r7, #4]
 8018176:	68da      	ldr	r2, [r3, #12]
 8018178:	68fb      	ldr	r3, [r7, #12]
 801817a:	60da      	str	r2, [r3, #12]
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 801817c:	68fb      	ldr	r3, [r7, #12]
 801817e:	68db      	ldr	r3, [r3, #12]
 8018180:	60fb      	str	r3, [r7, #12]
 8018182:	68fb      	ldr	r3, [r7, #12]
 8018184:	2b00      	cmp	r3, #0
 8018186:	d1ec      	bne.n	8018162 <udp_remove+0x3e>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
 8018188:	6878      	ldr	r0, [r7, #4]
 801818a:	f7f9 fe95 	bl	8011eb8 <mem_free>
}
 801818e:	f107 0710 	add.w	r7, r7, #16
 8018192:	46bd      	mov	sp, r7
 8018194:	bd80      	pop	{r7, pc}
 8018196:	bf00      	nop

08018198 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8018198:	b580      	push	{r7, lr}
 801819a:	b082      	sub	sp, #8
 801819c:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
 801819e:	f246 73d4 	movw	r3, #26580	; 0x67d4
 80181a2:	f6c0 0302 	movt	r3, #2050	; 0x802
 80181a6:	885b      	ldrh	r3, [r3, #2]
 80181a8:	4618      	mov	r0, r3
 80181aa:	f7f9 ffb1 	bl	8012110 <mem_malloc>
 80181ae:	6078      	str	r0, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 80181b0:	687b      	ldr	r3, [r7, #4]
 80181b2:	2b00      	cmp	r3, #0
 80181b4:	d00a      	beq.n	80181cc <udp_new+0x34>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 80181b6:	6878      	ldr	r0, [r7, #4]
 80181b8:	f04f 0100 	mov.w	r1, #0
 80181bc:	f04f 0224 	mov.w	r2, #36	; 0x24
 80181c0:	f00b fb96 	bl	80238f0 <memset>
    pcb->ttl = UDP_TTL;
 80181c4:	687b      	ldr	r3, [r7, #4]
 80181c6:	f04f 02ff 	mov.w	r2, #255	; 0xff
 80181ca:	72da      	strb	r2, [r3, #11]
  }
  return pcb;
 80181cc:	687b      	ldr	r3, [r7, #4]
}
 80181ce:	4618      	mov	r0, r3
 80181d0:	f107 0708 	add.w	r7, r7, #8
 80181d4:	46bd      	mov	sp, r7
 80181d6:	bd80      	pop	{r7, pc}

080181d8 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 80181d8:	b580      	push	{r7, lr}
 80181da:	b08c      	sub	sp, #48	; 0x30
 80181dc:	af04      	add	r7, sp, #16
 80181de:	6078      	str	r0, [r7, #4]
 80181e0:	6039      	str	r1, [r7, #0]

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
 80181e2:	687b      	ldr	r3, [r7, #4]
 80181e4:	685b      	ldr	r3, [r3, #4]
 80181e6:	61fb      	str	r3, [r7, #28]
  hlen = IPH_HL(iphdr) * 4;
 80181e8:	69fb      	ldr	r3, [r7, #28]
 80181ea:	881b      	ldrh	r3, [r3, #0]
 80181ec:	b29b      	uxth	r3, r3
 80181ee:	4618      	mov	r0, r3
 80181f0:	f000 ffca 	bl	8019188 <ntohs>
 80181f4:	4603      	mov	r3, r0
 80181f6:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80181fa:	b29b      	uxth	r3, r3
 80181fc:	f003 030f 	and.w	r3, r3, #15
 8018200:	b29b      	uxth	r3, r3
 8018202:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8018206:	b29b      	uxth	r3, r3
 8018208:	837b      	strh	r3, [r7, #26]
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 801820a:	8b7b      	ldrh	r3, [r7, #26]
 801820c:	f1c3 0300 	rsb	r3, r3, #0
 8018210:	b29b      	uxth	r3, r3
 8018212:	b29b      	uxth	r3, r3
 8018214:	b21b      	sxth	r3, r3
 8018216:	6878      	ldr	r0, [r7, #4]
 8018218:	4619      	mov	r1, r3
 801821a:	f7fa fdd7 	bl	8012dcc <pbuf_header>
 801821e:	4603      	mov	r3, r0
 8018220:	2b00      	cmp	r3, #0
 8018222:	f040 80bb 	bne.w	801839c <icmp_input+0x1c4>
 8018226:	687b      	ldr	r3, [r7, #4]
 8018228:	891b      	ldrh	r3, [r3, #8]
 801822a:	2b03      	cmp	r3, #3
 801822c:	f240 80b6 	bls.w	801839c <icmp_input+0x1c4>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 8018230:	687b      	ldr	r3, [r7, #4]
 8018232:	685b      	ldr	r3, [r3, #4]
 8018234:	781b      	ldrb	r3, [r3, #0]
 8018236:	767b      	strb	r3, [r7, #25]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
 8018238:	7e7b      	ldrb	r3, [r7, #25]
 801823a:	2b08      	cmp	r3, #8
 801823c:	f040 80a9 	bne.w	8018392 <icmp_input+0x1ba>
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8018240:	687b      	ldr	r3, [r7, #4]
 8018242:	891b      	ldrh	r3, [r3, #8]
 8018244:	2b07      	cmp	r3, #7
 8018246:	f240 80a8 	bls.w	801839a <icmp_input+0x1c2>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
 801824a:	6878      	ldr	r0, [r7, #4]
 801824c:	f001 f8ee 	bl	801942c <inet_chksum_pbuf>
 8018250:	4603      	mov	r3, r0
 8018252:	2b00      	cmp	r3, #0
 8018254:	d003      	beq.n	801825e <icmp_input+0x86>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
 8018256:	6878      	ldr	r0, [r7, #4]
 8018258:	f7fa fe32 	bl	8012ec0 <pbuf_free>
 801825c:	e0ae      	b.n	80183bc <icmp_input+0x1e4>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 801825e:	6878      	ldr	r0, [r7, #4]
 8018260:	f04f 0122 	mov.w	r1, #34	; 0x22
 8018264:	f7fa fdb2 	bl	8012dcc <pbuf_header>
 8018268:	4603      	mov	r3, r0
 801826a:	2b00      	cmp	r3, #0
 801826c:	d034      	beq.n	80182d8 <icmp_input+0x100>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
 801826e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018272:	6878      	ldr	r0, [r7, #4]
 8018274:	4619      	mov	r1, r3
 8018276:	f7fa fda9 	bl	8012dcc <pbuf_header>
 801827a:	4603      	mov	r3, r0
 801827c:	2b00      	cmp	r3, #0
 801827e:	f040 8091 	bne.w	80183a4 <icmp_input+0x1cc>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 8018282:	687b      	ldr	r3, [r7, #4]
 8018284:	891b      	ldrh	r3, [r3, #8]
 8018286:	f04f 0002 	mov.w	r0, #2
 801828a:	4619      	mov	r1, r3
 801828c:	f04f 0200 	mov.w	r2, #0
 8018290:	f7fa fc0e 	bl	8012ab0 <pbuf_alloc>
 8018294:	6178      	str	r0, [r7, #20]
      if (r == NULL) {
 8018296:	697b      	ldr	r3, [r7, #20]
 8018298:	2b00      	cmp	r3, #0
 801829a:	f000 8085 	beq.w	80183a8 <icmp_input+0x1d0>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
 801829e:	6978      	ldr	r0, [r7, #20]
 80182a0:	6879      	ldr	r1, [r7, #4]
 80182a2:	f7fa fefb 	bl	801309c <pbuf_copy>
 80182a6:	4603      	mov	r3, r0
 80182a8:	2b00      	cmp	r3, #0
 80182aa:	d17f      	bne.n	80183ac <icmp_input+0x1d4>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = r->payload;
 80182ac:	697b      	ldr	r3, [r7, #20]
 80182ae:	685b      	ldr	r3, [r3, #4]
 80182b0:	61fb      	str	r3, [r7, #28]
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 80182b2:	8b7b      	ldrh	r3, [r7, #26]
 80182b4:	f1c3 0300 	rsb	r3, r3, #0
 80182b8:	b29b      	uxth	r3, r3
 80182ba:	b29b      	uxth	r3, r3
 80182bc:	b21b      	sxth	r3, r3
 80182be:	6978      	ldr	r0, [r7, #20]
 80182c0:	4619      	mov	r1, r3
 80182c2:	f7fa fd83 	bl	8012dcc <pbuf_header>
 80182c6:	4603      	mov	r3, r0
 80182c8:	2b00      	cmp	r3, #0
 80182ca:	d171      	bne.n	80183b0 <icmp_input+0x1d8>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 80182cc:	6878      	ldr	r0, [r7, #4]
 80182ce:	f7fa fdf7 	bl	8012ec0 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
 80182d2:	697b      	ldr	r3, [r7, #20]
 80182d4:	607b      	str	r3, [r7, #4]
 80182d6:	e007      	b.n	80182e8 <icmp_input+0x110>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 80182d8:	6878      	ldr	r0, [r7, #4]
 80182da:	f06f 0121 	mvn.w	r1, #33	; 0x21
 80182de:	f7fa fd75 	bl	8012dcc <pbuf_header>
 80182e2:	4603      	mov	r3, r0
 80182e4:	2b00      	cmp	r3, #0
 80182e6:	d165      	bne.n	80183b4 <icmp_input+0x1dc>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
 80182e8:	687b      	ldr	r3, [r7, #4]
 80182ea:	685b      	ldr	r3, [r3, #4]
 80182ec:	613b      	str	r3, [r7, #16]
    tmpaddr.addr = iphdr->src.addr;
 80182ee:	69fb      	ldr	r3, [r7, #28]
 80182f0:	68db      	ldr	r3, [r3, #12]
 80182f2:	60bb      	str	r3, [r7, #8]
    iphdr->src.addr = iphdr->dest.addr;
 80182f4:	69fb      	ldr	r3, [r7, #28]
 80182f6:	691a      	ldr	r2, [r3, #16]
 80182f8:	69fb      	ldr	r3, [r7, #28]
 80182fa:	60da      	str	r2, [r3, #12]

    // to set source correctly in case a multicast/broadcast ping is received
#if (LWIP_MULTICAST_PING || LWIP_BROADCAST_PING)
    iphdr->src.addr = inp->ip_addr.addr;
 80182fc:	683b      	ldr	r3, [r7, #0]
 80182fe:	685a      	ldr	r2, [r3, #4]
 8018300:	69fb      	ldr	r3, [r7, #28]
 8018302:	60da      	str	r2, [r3, #12]
#endif

    iphdr->dest.addr = tmpaddr.addr;
 8018304:	68ba      	ldr	r2, [r7, #8]
 8018306:	69fb      	ldr	r3, [r7, #28]
 8018308:	611a      	str	r2, [r3, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 801830a:	693b      	ldr	r3, [r7, #16]
 801830c:	f04f 0200 	mov.w	r2, #0
 8018310:	701a      	strb	r2, [r3, #0]
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
    }
 #else
	   iecho->chksum = 0;
 8018312:	693b      	ldr	r3, [r7, #16]
 8018314:	f04f 0200 	mov.w	r2, #0
 8018318:	709a      	strb	r2, [r3, #2]
 801831a:	f04f 0200 	mov.w	r2, #0
 801831e:	70da      	strb	r2, [r3, #3]
 #endif

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 8018320:	69fb      	ldr	r3, [r7, #28]
 8018322:	891b      	ldrh	r3, [r3, #8]
 8018324:	b29b      	uxth	r3, r3
 8018326:	4618      	mov	r0, r3
 8018328:	f000 ff2e 	bl	8019188 <ntohs>
 801832c:	4603      	mov	r3, r0
 801832e:	b29b      	uxth	r3, r3
 8018330:	f063 03ff 	orn	r3, r3, #255	; 0xff
 8018334:	b29b      	uxth	r3, r3
 8018336:	b29b      	uxth	r3, r3
 8018338:	4618      	mov	r0, r3
 801833a:	f000 ff0d 	bl	8019158 <htons>
 801833e:	4603      	mov	r3, r0
 8018340:	461a      	mov	r2, r3
 8018342:	69fb      	ldr	r3, [r7, #28]
 8018344:	811a      	strh	r2, [r3, #8]
    IPH_CHKSUM_SET(iphdr, 0);
 8018346:	69fb      	ldr	r3, [r7, #28]
 8018348:	f04f 0200 	mov.w	r2, #0
 801834c:	729a      	strb	r2, [r3, #10]
 801834e:	f04f 0200 	mov.w	r2, #0
 8018352:	72da      	strb	r2, [r3, #11]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 8018354:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018358:	6878      	ldr	r0, [r7, #4]
 801835a:	4619      	mov	r1, r3
 801835c:	f7fa fd36 	bl	8012dcc <pbuf_header>
 8018360:	4603      	mov	r3, r0
 8018362:	2b00      	cmp	r3, #0
 8018364:	d114      	bne.n	8018390 <icmp_input+0x1b8>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
 8018366:	69fb      	ldr	r3, [r7, #28]
 8018368:	f103 030c 	add.w	r3, r3, #12
 801836c:	f04f 0200 	mov.w	r2, #0
 8018370:	9200      	str	r2, [sp, #0]
 8018372:	f04f 0201 	mov.w	r2, #1
 8018376:	9201      	str	r2, [sp, #4]
 8018378:	683a      	ldr	r2, [r7, #0]
 801837a:	9202      	str	r2, [sp, #8]
 801837c:	6878      	ldr	r0, [r7, #4]
 801837e:	4619      	mov	r1, r3
 8018380:	f04f 0200 	mov.w	r2, #0
 8018384:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8018388:	f001 fa74 	bl	8019874 <ip_output_if>
 801838c:	4603      	mov	r3, r0
 801838e:	73fb      	strb	r3, [r7, #15]
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 8018390:	bf00      	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 8018392:	6878      	ldr	r0, [r7, #4]
 8018394:	f7fa fd94 	bl	8012ec0 <pbuf_free>
 8018398:	e010      	b.n	80183bc <icmp_input+0x1e4>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
 801839a:	bf00      	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
 801839c:	6878      	ldr	r0, [r7, #4]
 801839e:	f7fa fd8f 	bl	8012ec0 <pbuf_free>
 80183a2:	e00b      	b.n	80183bc <icmp_input+0x1e4>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
 80183a4:	bf00      	nop
 80183a6:	e006      	b.n	80183b6 <icmp_input+0x1de>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
 80183a8:	bf00      	nop
 80183aa:	e004      	b.n	80183b6 <icmp_input+0x1de>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
 80183ac:	bf00      	nop
 80183ae:	e002      	b.n	80183b6 <icmp_input+0x1de>
      }
      iphdr = r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 80183b0:	bf00      	nop
 80183b2:	e000      	b.n	80183b6 <icmp_input+0x1de>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 80183b4:	bf00      	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 80183b6:	6878      	ldr	r0, [r7, #4]
 80183b8:	f7fa fd82 	bl	8012ec0 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 80183bc:	f107 0720 	add.w	r7, r7, #32
 80183c0:	46bd      	mov	sp, r7
 80183c2:	bd80      	pop	{r7, pc}

080183c4 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 80183c4:	b580      	push	{r7, lr}
 80183c6:	b082      	sub	sp, #8
 80183c8:	af00      	add	r7, sp, #0
 80183ca:	6078      	str	r0, [r7, #4]
 80183cc:	460b      	mov	r3, r1
 80183ce:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_DUR, t);
 80183d0:	78fb      	ldrb	r3, [r7, #3]
 80183d2:	6878      	ldr	r0, [r7, #4]
 80183d4:	f04f 0103 	mov.w	r1, #3
 80183d8:	461a      	mov	r2, r3
 80183da:	f000 f817 	bl	801840c <icmp_send_response>
}
 80183de:	f107 0708 	add.w	r7, r7, #8
 80183e2:	46bd      	mov	sp, r7
 80183e4:	bd80      	pop	{r7, pc}
 80183e6:	bf00      	nop

080183e8 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 80183e8:	b580      	push	{r7, lr}
 80183ea:	b082      	sub	sp, #8
 80183ec:	af00      	add	r7, sp, #0
 80183ee:	6078      	str	r0, [r7, #4]
 80183f0:	460b      	mov	r3, r1
 80183f2:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_TE, t);
 80183f4:	78fb      	ldrb	r3, [r7, #3]
 80183f6:	6878      	ldr	r0, [r7, #4]
 80183f8:	f04f 010b 	mov.w	r1, #11
 80183fc:	461a      	mov	r2, r3
 80183fe:	f000 f805 	bl	801840c <icmp_send_response>
}
 8018402:	f107 0708 	add.w	r7, r7, #8
 8018406:	46bd      	mov	sp, r7
 8018408:	bd80      	pop	{r7, pc}
 801840a:	bf00      	nop

0801840c <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 801840c:	b580      	push	{r7, lr}
 801840e:	b088      	sub	sp, #32
 8018410:	af02      	add	r7, sp, #8
 8018412:	6078      	str	r0, [r7, #4]
 8018414:	4613      	mov	r3, r2
 8018416:	460a      	mov	r2, r1
 8018418:	70fa      	strb	r2, [r7, #3]
 801841a:	70bb      	strb	r3, [r7, #2]
  struct ip_hdr *iphdr;
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 801841c:	f04f 0001 	mov.w	r0, #1
 8018420:	f04f 0124 	mov.w	r1, #36	; 0x24
 8018424:	f04f 0200 	mov.w	r2, #0
 8018428:	f7fa fb42 	bl	8012ab0 <pbuf_alloc>
 801842c:	6178      	str	r0, [r7, #20]
                 PBUF_RAM);
  if (q == NULL) {
 801842e:	697b      	ldr	r3, [r7, #20]
 8018430:	2b00      	cmp	r3, #0
 8018432:	d04b      	beq.n	80184cc <icmp_send_response+0xc0>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
 8018434:	687b      	ldr	r3, [r7, #4]
 8018436:	685b      	ldr	r3, [r3, #4]
 8018438:	613b      	str	r3, [r7, #16]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = q->payload;
 801843a:	697b      	ldr	r3, [r7, #20]
 801843c:	685b      	ldr	r3, [r3, #4]
 801843e:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
 8018440:	68fb      	ldr	r3, [r7, #12]
 8018442:	78fa      	ldrb	r2, [r7, #3]
 8018444:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 8018446:	68fb      	ldr	r3, [r7, #12]
 8018448:	78ba      	ldrb	r2, [r7, #2]
 801844a:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 801844c:	68fb      	ldr	r3, [r7, #12]
 801844e:	f04f 0200 	mov.w	r2, #0
 8018452:	711a      	strb	r2, [r3, #4]
 8018454:	f04f 0200 	mov.w	r2, #0
 8018458:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 801845a:	68fb      	ldr	r3, [r7, #12]
 801845c:	f04f 0200 	mov.w	r2, #0
 8018460:	719a      	strb	r2, [r3, #6]
 8018462:	f04f 0200 	mov.w	r2, #0
 8018466:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8018468:	697b      	ldr	r3, [r7, #20]
 801846a:	685b      	ldr	r3, [r3, #4]
 801846c:	f103 0208 	add.w	r2, r3, #8
 8018470:	687b      	ldr	r3, [r7, #4]
 8018472:	685b      	ldr	r3, [r3, #4]
 8018474:	4610      	mov	r0, r2
 8018476:	4619      	mov	r1, r3
 8018478:	f04f 021c 	mov.w	r2, #28
 801847c:	f00b f8ca 	bl	8023614 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 8018480:	68fb      	ldr	r3, [r7, #12]
 8018482:	f04f 0200 	mov.w	r2, #0
 8018486:	709a      	strb	r2, [r3, #2]
 8018488:	f04f 0200 	mov.w	r2, #0
 801848c:	70da      	strb	r2, [r3, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 801848e:	697b      	ldr	r3, [r7, #20]
 8018490:	895b      	ldrh	r3, [r3, #10]
 8018492:	68f8      	ldr	r0, [r7, #12]
 8018494:	4619      	mov	r1, r3
 8018496:	f000 ffb5 	bl	8019404 <inet_chksum>
 801849a:	4603      	mov	r3, r0
 801849c:	461a      	mov	r2, r3
 801849e:	68fb      	ldr	r3, [r7, #12]
 80184a0:	805a      	strh	r2, [r3, #2]
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
 80184a2:	693b      	ldr	r3, [r7, #16]
 80184a4:	f103 030c 	add.w	r3, r3, #12
 80184a8:	f04f 0200 	mov.w	r2, #0
 80184ac:	9200      	str	r2, [sp, #0]
 80184ae:	f04f 0201 	mov.w	r2, #1
 80184b2:	9201      	str	r2, [sp, #4]
 80184b4:	6978      	ldr	r0, [r7, #20]
 80184b6:	f04f 0100 	mov.w	r1, #0
 80184ba:	461a      	mov	r2, r3
 80184bc:	f04f 03ff 	mov.w	r3, #255	; 0xff
 80184c0:	f001 fb12 	bl	8019ae8 <ip_output>
  pbuf_free(q);
 80184c4:	6978      	ldr	r0, [r7, #20]
 80184c6:	f7fa fcfb 	bl	8012ec0 <pbuf_free>
 80184ca:	e000      	b.n	80184ce <icmp_send_response+0xc2>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
 80184cc:	bf00      	nop
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
 80184ce:	f107 0718 	add.w	r7, r7, #24
 80184d2:	46bd      	mov	sp, r7
 80184d4:	bd80      	pop	{r7, pc}
 80184d6:	bf00      	nop

080184d8 <igmp_init>:
/**
 * Initialize the IGMP module
 */
void
igmp_init(void)
{
 80184d8:	b580      	push	{r7, lr}
 80184da:	af00      	add	r7, sp, #0
  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_init: initializing\n"));

  IP4_ADDR(&allsystems, 224, 0, 0, 1);
 80184dc:	f04f 0001 	mov.w	r0, #1
 80184e0:	f2ce 0000 	movt	r0, #57344	; 0xe000
 80184e4:	f000 fe60 	bl	80191a8 <htonl>
 80184e8:	4602      	mov	r2, r0
 80184ea:	f245 5390 	movw	r3, #21904	; 0x5590
 80184ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80184f2:	601a      	str	r2, [r3, #0]
  IP4_ADDR(&allrouters, 224, 0, 0, 2);
 80184f4:	f04f 0002 	mov.w	r0, #2
 80184f8:	f2ce 0000 	movt	r0, #57344	; 0xe000
 80184fc:	f000 fe54 	bl	80191a8 <htonl>
 8018500:	4602      	mov	r2, r0
 8018502:	f245 5394 	movw	r3, #21908	; 0x5594
 8018506:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801850a:	601a      	str	r2, [r3, #0]
}
 801850c:	bd80      	pop	{r7, pc}
 801850e:	bf00      	nop

08018510 <igmp_start>:
 *
 * @param netif network interface on which start IGMP processing
 */
err_t
igmp_start(struct netif *netif)
{
 8018510:	b580      	push	{r7, lr}
 8018512:	b084      	sub	sp, #16
 8018514:	af00      	add	r7, sp, #0
 8018516:	6078      	str	r0, [r7, #4]
  struct igmp_group* group;

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: starting IGMP processing on if %p\n", netif));

  group = igmp_lookup_group(netif, &allsystems);
 8018518:	6878      	ldr	r0, [r7, #4]
 801851a:	f245 5190 	movw	r1, #21904	; 0x5590
 801851e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8018522:	f000 f8bd 	bl	80186a0 <igmp_lookup_group>
 8018526:	60f8      	str	r0, [r7, #12]

  if (group != NULL) {
 8018528:	68fb      	ldr	r3, [r7, #12]
 801852a:	2b00      	cmp	r3, #0
 801852c:	d01b      	beq.n	8018566 <igmp_start+0x56>
    group->group_state = IGMP_GROUP_IDLE_MEMBER;
 801852e:	68fb      	ldr	r3, [r7, #12]
 8018530:	f04f 0202 	mov.w	r2, #2
 8018534:	735a      	strb	r2, [r3, #13]
    group->use++;
 8018536:	68fb      	ldr	r3, [r7, #12]
 8018538:	7c1b      	ldrb	r3, [r3, #16]
 801853a:	f103 0301 	add.w	r3, r3, #1
 801853e:	b2da      	uxtb	r2, r3
 8018540:	68fb      	ldr	r3, [r7, #12]
 8018542:	741a      	strb	r2, [r3, #16]

    /* Allow the igmp messages at the MAC level */
    if (netif->igmp_mac_filter != NULL) {
 8018544:	687b      	ldr	r3, [r7, #4]
 8018546:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8018548:	2b00      	cmp	r3, #0
 801854a:	d009      	beq.n	8018560 <igmp_start+0x50>
      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: igmp_mac_filter(ADD "));
      ip_addr_debug_print(IGMP_DEBUG, &allsystems);
      LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
      netif->igmp_mac_filter( netif, &allsystems, IGMP_ADD_MAC_FILTER);
 801854c:	687b      	ldr	r3, [r7, #4]
 801854e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8018550:	6878      	ldr	r0, [r7, #4]
 8018552:	f245 5190 	movw	r1, #21904	; 0x5590
 8018556:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801855a:	f04f 0201 	mov.w	r2, #1
 801855e:	4798      	blx	r3
    }

    return ERR_OK;
 8018560:	f04f 0300 	mov.w	r3, #0
 8018564:	e001      	b.n	801856a <igmp_start+0x5a>
  }

  return ERR_MEM;
 8018566:	f04f 03ff 	mov.w	r3, #255	; 0xff
 801856a:	b25b      	sxtb	r3, r3
}
 801856c:	4618      	mov	r0, r3
 801856e:	f107 0710 	add.w	r7, r7, #16
 8018572:	46bd      	mov	sp, r7
 8018574:	bd80      	pop	{r7, pc}
 8018576:	bf00      	nop

08018578 <igmp_stop>:
 *
 * @param netif network interface on which stop IGMP processing
 */
err_t
igmp_stop(struct netif *netif)
{
 8018578:	b580      	push	{r7, lr}
 801857a:	b086      	sub	sp, #24
 801857c:	af00      	add	r7, sp, #0
 801857e:	6078      	str	r0, [r7, #4]
  struct igmp_group *group = igmp_group_list;
 8018580:	f245 538c 	movw	r3, #21900	; 0x558c
 8018584:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018588:	681b      	ldr	r3, [r3, #0]
 801858a:	617b      	str	r3, [r7, #20]
  struct igmp_group *prev  = NULL;
 801858c:	f04f 0300 	mov.w	r3, #0
 8018590:	613b      	str	r3, [r7, #16]
  struct igmp_group *next;

  /* look for groups joined on this interface further down the list */
  while (group != NULL) {
 8018592:	e031      	b.n	80185f8 <igmp_stop+0x80>
    next = group->next;
 8018594:	697b      	ldr	r3, [r7, #20]
 8018596:	681b      	ldr	r3, [r3, #0]
 8018598:	60fb      	str	r3, [r7, #12]
    /* is it a group joined on this interface? */
    if (group->interface == netif) {
 801859a:	697b      	ldr	r3, [r7, #20]
 801859c:	685a      	ldr	r2, [r3, #4]
 801859e:	687b      	ldr	r3, [r7, #4]
 80185a0:	429a      	cmp	r2, r3
 80185a2:	d125      	bne.n	80185f0 <igmp_stop+0x78>
      /* is it the first group of the list? */
      if (group == igmp_group_list) {
 80185a4:	f245 538c 	movw	r3, #21900	; 0x558c
 80185a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80185ac:	681b      	ldr	r3, [r3, #0]
 80185ae:	697a      	ldr	r2, [r7, #20]
 80185b0:	429a      	cmp	r2, r3
 80185b2:	d105      	bne.n	80185c0 <igmp_stop+0x48>
        igmp_group_list = next;
 80185b4:	f245 538c 	movw	r3, #21900	; 0x558c
 80185b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80185bc:	68fa      	ldr	r2, [r7, #12]
 80185be:	601a      	str	r2, [r3, #0]
      }
      /* is there a "previous" group defined? */
      if (prev != NULL) {
 80185c0:	693b      	ldr	r3, [r7, #16]
 80185c2:	2b00      	cmp	r3, #0
 80185c4:	d002      	beq.n	80185cc <igmp_stop+0x54>
        prev->next = next;
 80185c6:	693b      	ldr	r3, [r7, #16]
 80185c8:	68fa      	ldr	r2, [r7, #12]
 80185ca:	601a      	str	r2, [r3, #0]
      }
      /* disable the group at the MAC level */
      if (netif->igmp_mac_filter != NULL) {
 80185cc:	687b      	ldr	r3, [r7, #4]
 80185ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80185d0:	2b00      	cmp	r3, #0
 80185d2:	d009      	beq.n	80185e8 <igmp_stop+0x70>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_stop: igmp_mac_filter(DEL "));
        ip_addr_debug_print(IGMP_DEBUG, &group->group_address);
        LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
        netif->igmp_mac_filter(netif, &(group->group_address), IGMP_DEL_MAC_FILTER);
 80185d4:	687b      	ldr	r3, [r7, #4]
 80185d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80185d8:	697a      	ldr	r2, [r7, #20]
 80185da:	f102 0208 	add.w	r2, r2, #8
 80185de:	6878      	ldr	r0, [r7, #4]
 80185e0:	4611      	mov	r1, r2
 80185e2:	f04f 0200 	mov.w	r2, #0
 80185e6:	4798      	blx	r3
      }
      /* free group */
      memp_free(MEMP_IGMP_GROUP, group);
 80185e8:	6978      	ldr	r0, [r7, #20]
 80185ea:	f7f9 fc65 	bl	8011eb8 <mem_free>
 80185ee:	e001      	b.n	80185f4 <igmp_stop+0x7c>
    } else {
      /* change the "previous" */
      prev = group;
 80185f0:	697b      	ldr	r3, [r7, #20]
 80185f2:	613b      	str	r3, [r7, #16]
    }
    /* move to "next" */
    group = next;
 80185f4:	68fb      	ldr	r3, [r7, #12]
 80185f6:	617b      	str	r3, [r7, #20]
  struct igmp_group *group = igmp_group_list;
  struct igmp_group *prev  = NULL;
  struct igmp_group *next;

  /* look for groups joined on this interface further down the list */
  while (group != NULL) {
 80185f8:	697b      	ldr	r3, [r7, #20]
 80185fa:	2b00      	cmp	r3, #0
 80185fc:	d1ca      	bne.n	8018594 <igmp_stop+0x1c>
      prev = group;
    }
    /* move to "next" */
    group = next;
  }
  return ERR_OK;
 80185fe:	f04f 0300 	mov.w	r3, #0
 8018602:	b25b      	sxtb	r3, r3
}
 8018604:	4618      	mov	r0, r3
 8018606:	f107 0718 	add.w	r7, r7, #24
 801860a:	46bd      	mov	sp, r7
 801860c:	bd80      	pop	{r7, pc}
 801860e:	bf00      	nop

08018610 <igmp_report_groups>:
 *
 * @param netif network interface on which report IGMP memberships
 */
void
igmp_report_groups( struct netif *netif)
{
 8018610:	b580      	push	{r7, lr}
 8018612:	b084      	sub	sp, #16
 8018614:	af00      	add	r7, sp, #0
 8018616:	6078      	str	r0, [r7, #4]
  struct igmp_group *group = igmp_group_list;
 8018618:	f245 538c 	movw	r3, #21900	; 0x558c
 801861c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018620:	681b      	ldr	r3, [r3, #0]
 8018622:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_report_groups: sending IGMP reports on if %p\n", netif));

  while (group != NULL) {
 8018624:	e00c      	b.n	8018640 <igmp_report_groups+0x30>
    if (group->interface == netif) {
 8018626:	68fb      	ldr	r3, [r7, #12]
 8018628:	685a      	ldr	r2, [r3, #4]
 801862a:	687b      	ldr	r3, [r7, #4]
 801862c:	429a      	cmp	r2, r3
 801862e:	d104      	bne.n	801863a <igmp_report_groups+0x2a>
      igmp_delaying_member( group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 8018630:	68f8      	ldr	r0, [r7, #12]
 8018632:	f04f 0105 	mov.w	r1, #5
 8018636:	f000 fadf 	bl	8018bf8 <igmp_delaying_member>
    }
    group = group->next;
 801863a:	68fb      	ldr	r3, [r7, #12]
 801863c:	681b      	ldr	r3, [r3, #0]
 801863e:	60fb      	str	r3, [r7, #12]
{
  struct igmp_group *group = igmp_group_list;

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_report_groups: sending IGMP reports on if %p\n", netif));

  while (group != NULL) {
 8018640:	68fb      	ldr	r3, [r7, #12]
 8018642:	2b00      	cmp	r3, #0
 8018644:	d1ef      	bne.n	8018626 <igmp_report_groups+0x16>
    if (group->interface == netif) {
      igmp_delaying_member( group, IGMP_JOIN_DELAYING_MEMBER_TMR);
    }
    group = group->next;
  }
}
 8018646:	f107 0710 	add.w	r7, r7, #16
 801864a:	46bd      	mov	sp, r7
 801864c:	bd80      	pop	{r7, pc}
 801864e:	bf00      	nop

08018650 <igmp_lookfor_group>:
 * @return a struct igmp_group* if the group has been found,
 *         NULL if the group wasn't found.
 */
struct igmp_group *
igmp_lookfor_group(struct netif *ifp, struct ip_addr *addr)
{
 8018650:	b480      	push	{r7}
 8018652:	b085      	sub	sp, #20
 8018654:	af00      	add	r7, sp, #0
 8018656:	6078      	str	r0, [r7, #4]
 8018658:	6039      	str	r1, [r7, #0]
  struct igmp_group *group = igmp_group_list;
 801865a:	f245 538c 	movw	r3, #21900	; 0x558c
 801865e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018662:	681b      	ldr	r3, [r3, #0]
 8018664:	60fb      	str	r3, [r7, #12]

  while (group != NULL) {
 8018666:	e00f      	b.n	8018688 <igmp_lookfor_group+0x38>
    if ((group->interface == ifp) && (ip_addr_cmp(&(group->group_address), addr))) {
 8018668:	68fb      	ldr	r3, [r7, #12]
 801866a:	685a      	ldr	r2, [r3, #4]
 801866c:	687b      	ldr	r3, [r7, #4]
 801866e:	429a      	cmp	r2, r3
 8018670:	d107      	bne.n	8018682 <igmp_lookfor_group+0x32>
 8018672:	68fb      	ldr	r3, [r7, #12]
 8018674:	689a      	ldr	r2, [r3, #8]
 8018676:	683b      	ldr	r3, [r7, #0]
 8018678:	681b      	ldr	r3, [r3, #0]
 801867a:	429a      	cmp	r2, r3
 801867c:	d101      	bne.n	8018682 <igmp_lookfor_group+0x32>
      return group;
 801867e:	68fb      	ldr	r3, [r7, #12]
 8018680:	e007      	b.n	8018692 <igmp_lookfor_group+0x42>
    }
    group = group->next;
 8018682:	68fb      	ldr	r3, [r7, #12]
 8018684:	681b      	ldr	r3, [r3, #0]
 8018686:	60fb      	str	r3, [r7, #12]
struct igmp_group *
igmp_lookfor_group(struct netif *ifp, struct ip_addr *addr)
{
  struct igmp_group *group = igmp_group_list;

  while (group != NULL) {
 8018688:	68fb      	ldr	r3, [r7, #12]
 801868a:	2b00      	cmp	r3, #0
 801868c:	d1ec      	bne.n	8018668 <igmp_lookfor_group+0x18>
  }

  /* to be clearer, we return NULL here instead of
   * 'group' (which is also NULL at this point).
   */
  return NULL;
 801868e:	f04f 0300 	mov.w	r3, #0
}
 8018692:	4618      	mov	r0, r3
 8018694:	f107 0714 	add.w	r7, r7, #20
 8018698:	46bd      	mov	sp, r7
 801869a:	bc80      	pop	{r7}
 801869c:	4770      	bx	lr
 801869e:	bf00      	nop

080186a0 <igmp_lookup_group>:
 * @return a struct igmp_group*,
 *         NULL on memory error.
 */
struct igmp_group *
igmp_lookup_group(struct netif *ifp, struct ip_addr *addr)
{
 80186a0:	b580      	push	{r7, lr}
 80186a2:	b084      	sub	sp, #16
 80186a4:	af00      	add	r7, sp, #0
 80186a6:	6078      	str	r0, [r7, #4]
 80186a8:	6039      	str	r1, [r7, #0]
  struct igmp_group *group = igmp_group_list;
 80186aa:	f245 538c 	movw	r3, #21900	; 0x558c
 80186ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80186b2:	681b      	ldr	r3, [r3, #0]
 80186b4:	60fb      	str	r3, [r7, #12]
  
  /* Search if the group already exists */
  group = igmp_lookfor_group(ifp, addr);
 80186b6:	6878      	ldr	r0, [r7, #4]
 80186b8:	6839      	ldr	r1, [r7, #0]
 80186ba:	f7ff ffc9 	bl	8018650 <igmp_lookfor_group>
 80186be:	60f8      	str	r0, [r7, #12]
  if (group != NULL) {
 80186c0:	68fb      	ldr	r3, [r7, #12]
 80186c2:	2b00      	cmp	r3, #0
 80186c4:	d001      	beq.n	80186ca <igmp_lookup_group+0x2a>
    /* Group already exists. */
    return group;
 80186c6:	68fb      	ldr	r3, [r7, #12]
 80186c8:	e036      	b.n	8018738 <igmp_lookup_group+0x98>
  }

  /* Group doesn't exist yet, create a new one */
  group = memp_malloc(MEMP_IGMP_GROUP);
 80186ca:	f246 73d4 	movw	r3, #26580	; 0x67d4
 80186ce:	f6c0 0302 	movt	r3, #2050	; 0x802
 80186d2:	89db      	ldrh	r3, [r3, #14]
 80186d4:	4618      	mov	r0, r3
 80186d6:	f7f9 fd1b 	bl	8012110 <mem_malloc>
 80186da:	60f8      	str	r0, [r7, #12]
  if (group != NULL) {
 80186dc:	68fb      	ldr	r3, [r7, #12]
 80186de:	2b00      	cmp	r3, #0
 80186e0:	d029      	beq.n	8018736 <igmp_lookup_group+0x96>
    group->interface          = ifp;
 80186e2:	68fb      	ldr	r3, [r7, #12]
 80186e4:	687a      	ldr	r2, [r7, #4]
 80186e6:	605a      	str	r2, [r3, #4]
    ip_addr_set(&(group->group_address), addr);
 80186e8:	683b      	ldr	r3, [r7, #0]
 80186ea:	2b00      	cmp	r3, #0
 80186ec:	d002      	beq.n	80186f4 <igmp_lookup_group+0x54>
 80186ee:	683b      	ldr	r3, [r7, #0]
 80186f0:	681b      	ldr	r3, [r3, #0]
 80186f2:	e001      	b.n	80186f8 <igmp_lookup_group+0x58>
 80186f4:	f04f 0300 	mov.w	r3, #0
 80186f8:	68fa      	ldr	r2, [r7, #12]
 80186fa:	6093      	str	r3, [r2, #8]
    group->timer              = 0; /* Not running */
 80186fc:	68fb      	ldr	r3, [r7, #12]
 80186fe:	f04f 0200 	mov.w	r2, #0
 8018702:	81da      	strh	r2, [r3, #14]
    group->group_state        = IGMP_GROUP_NON_MEMBER;
 8018704:	68fb      	ldr	r3, [r7, #12]
 8018706:	f04f 0200 	mov.w	r2, #0
 801870a:	735a      	strb	r2, [r3, #13]
    group->last_reporter_flag = 0;
 801870c:	68fb      	ldr	r3, [r7, #12]
 801870e:	f04f 0200 	mov.w	r2, #0
 8018712:	731a      	strb	r2, [r3, #12]
    group->use                = 0;
 8018714:	68fb      	ldr	r3, [r7, #12]
 8018716:	f04f 0200 	mov.w	r2, #0
 801871a:	741a      	strb	r2, [r3, #16]
    group->next               = igmp_group_list;
 801871c:	f245 538c 	movw	r3, #21900	; 0x558c
 8018720:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018724:	681a      	ldr	r2, [r3, #0]
 8018726:	68fb      	ldr	r3, [r7, #12]
 8018728:	601a      	str	r2, [r3, #0]
    
    igmp_group_list = group;
 801872a:	f245 538c 	movw	r3, #21900	; 0x558c
 801872e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018732:	68fa      	ldr	r2, [r7, #12]
 8018734:	601a      	str	r2, [r3, #0]

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_lookup_group: %sallocated a new group with address ", (group?"":"impossible to ")));
  ip_addr_debug_print(IGMP_DEBUG, addr);
  LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", ifp));

  return group;
 8018736:	68fb      	ldr	r3, [r7, #12]
}
 8018738:	4618      	mov	r0, r3
 801873a:	f107 0710 	add.w	r7, r7, #16
 801873e:	46bd      	mov	sp, r7
 8018740:	bd80      	pop	{r7, pc}
 8018742:	bf00      	nop

08018744 <igmp_remove_group>:
 * @param group the group to remove from the global igmp_group_list
 * @return ERR_OK if group was removed from the list, an err_t otherwise
 */
err_t
igmp_remove_group(struct igmp_group *group)
{
 8018744:	b580      	push	{r7, lr}
 8018746:	b084      	sub	sp, #16
 8018748:	af00      	add	r7, sp, #0
 801874a:	6078      	str	r0, [r7, #4]
  err_t err = ERR_OK;
 801874c:	f04f 0300 	mov.w	r3, #0
 8018750:	73fb      	strb	r3, [r7, #15]

  /* Is it the first group? */
  if (igmp_group_list == group) {
 8018752:	f245 538c 	movw	r3, #21900	; 0x558c
 8018756:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801875a:	681a      	ldr	r2, [r3, #0]
 801875c:	687b      	ldr	r3, [r7, #4]
 801875e:	429a      	cmp	r2, r3
 8018760:	d107      	bne.n	8018772 <igmp_remove_group+0x2e>
    igmp_group_list = group->next;
 8018762:	687b      	ldr	r3, [r7, #4]
 8018764:	681a      	ldr	r2, [r3, #0]
 8018766:	f245 538c 	movw	r3, #21900	; 0x558c
 801876a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801876e:	601a      	str	r2, [r3, #0]
 8018770:	e01c      	b.n	80187ac <igmp_remove_group+0x68>
  } else {
    /* look for group further down the list */
    struct igmp_group *tmpGroup;
    for (tmpGroup = igmp_group_list; tmpGroup != NULL; tmpGroup = tmpGroup->next) {
 8018772:	f245 538c 	movw	r3, #21900	; 0x558c
 8018776:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801877a:	681b      	ldr	r3, [r3, #0]
 801877c:	60bb      	str	r3, [r7, #8]
 801877e:	e00c      	b.n	801879a <igmp_remove_group+0x56>
      if (tmpGroup->next == group) {
 8018780:	68bb      	ldr	r3, [r7, #8]
 8018782:	681a      	ldr	r2, [r3, #0]
 8018784:	687b      	ldr	r3, [r7, #4]
 8018786:	429a      	cmp	r2, r3
 8018788:	d104      	bne.n	8018794 <igmp_remove_group+0x50>
        tmpGroup->next = group->next;
 801878a:	687b      	ldr	r3, [r7, #4]
 801878c:	681a      	ldr	r2, [r3, #0]
 801878e:	68bb      	ldr	r3, [r7, #8]
 8018790:	601a      	str	r2, [r3, #0]
        break;
 8018792:	e005      	b.n	80187a0 <igmp_remove_group+0x5c>
  if (igmp_group_list == group) {
    igmp_group_list = group->next;
  } else {
    /* look for group further down the list */
    struct igmp_group *tmpGroup;
    for (tmpGroup = igmp_group_list; tmpGroup != NULL; tmpGroup = tmpGroup->next) {
 8018794:	68bb      	ldr	r3, [r7, #8]
 8018796:	681b      	ldr	r3, [r3, #0]
 8018798:	60bb      	str	r3, [r7, #8]
 801879a:	68bb      	ldr	r3, [r7, #8]
 801879c:	2b00      	cmp	r3, #0
 801879e:	d1ef      	bne.n	8018780 <igmp_remove_group+0x3c>
        tmpGroup->next = group->next;
        break;
      }
    }
    /* Group not found in the global igmp_group_list */
    if (tmpGroup == NULL)
 80187a0:	68bb      	ldr	r3, [r7, #8]
 80187a2:	2b00      	cmp	r3, #0
 80187a4:	d102      	bne.n	80187ac <igmp_remove_group+0x68>
      err = ERR_ARG;
 80187a6:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 80187aa:	73fb      	strb	r3, [r7, #15]
  }
  /* free group */
  memp_free(MEMP_IGMP_GROUP, group);
 80187ac:	6878      	ldr	r0, [r7, #4]
 80187ae:	f7f9 fb83 	bl	8011eb8 <mem_free>

  return err;
 80187b2:	7bfb      	ldrb	r3, [r7, #15]
 80187b4:	b25b      	sxtb	r3, r3
}
 80187b6:	4618      	mov	r0, r3
 80187b8:	f107 0710 	add.w	r7, r7, #16
 80187bc:	46bd      	mov	sp, r7
 80187be:	bd80      	pop	{r7, pc}

080187c0 <igmp_input>:
 * @param inp network interface on which the packet was received
 * @param dest destination ip address of the igmp packet
 */
void
igmp_input(struct pbuf *p, struct netif *inp, struct ip_addr *dest)
{
 80187c0:	b580      	push	{r7, lr}
 80187c2:	b088      	sub	sp, #32
 80187c4:	af00      	add	r7, sp, #0
 80187c6:	60f8      	str	r0, [r7, #12]
 80187c8:	60b9      	str	r1, [r7, #8]
 80187ca:	607a      	str	r2, [r7, #4]
  struct igmp_msg*   igmp;
  struct igmp_group* group;
  struct igmp_group* groupref;

  /* Note that the length CAN be greater than 8 but only 8 are used - All are included in the checksum */    
  iphdr = p->payload;
 80187cc:	68fb      	ldr	r3, [r7, #12]
 80187ce:	685b      	ldr	r3, [r3, #4]
 80187d0:	617b      	str	r3, [r7, #20]
  if (pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4)) || (p->len < IGMP_MINLEN)) {
 80187d2:	697b      	ldr	r3, [r7, #20]
 80187d4:	881b      	ldrh	r3, [r3, #0]
 80187d6:	b29b      	uxth	r3, r3
 80187d8:	4618      	mov	r0, r3
 80187da:	f000 fcd5 	bl	8019188 <ntohs>
 80187de:	4603      	mov	r3, r0
 80187e0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80187e4:	b29b      	uxth	r3, r3
 80187e6:	f003 030f 	and.w	r3, r3, #15
 80187ea:	b29b      	uxth	r3, r3
 80187ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80187f0:	b29b      	uxth	r3, r3
 80187f2:	f1c3 0300 	rsb	r3, r3, #0
 80187f6:	b29b      	uxth	r3, r3
 80187f8:	b29b      	uxth	r3, r3
 80187fa:	b21b      	sxth	r3, r3
 80187fc:	68f8      	ldr	r0, [r7, #12]
 80187fe:	4619      	mov	r1, r3
 8018800:	f7fa fae4 	bl	8012dcc <pbuf_header>
 8018804:	4603      	mov	r3, r0
 8018806:	2b00      	cmp	r3, #0
 8018808:	d103      	bne.n	8018812 <igmp_input+0x52>
 801880a:	68fb      	ldr	r3, [r7, #12]
 801880c:	895b      	ldrh	r3, [r3, #10]
 801880e:	2b07      	cmp	r3, #7
 8018810:	d803      	bhi.n	801881a <igmp_input+0x5a>
    pbuf_free(p);
 8018812:	68f8      	ldr	r0, [r7, #12]
 8018814:	f7fa fb54 	bl	8012ec0 <pbuf_free>
    IGMP_STATS_INC(igmp.lenerr);
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: length error\n"));
    return;
 8018818:	e092      	b.n	8018940 <igmp_input+0x180>
  LWIP_DEBUGF(IGMP_DEBUG, (" to address "));
  ip_addr_debug_print(IGMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", inp));

  /* Now calculate and check the checksum */
  igmp = (struct igmp_msg *)p->payload;
 801881a:	68fb      	ldr	r3, [r7, #12]
 801881c:	685b      	ldr	r3, [r3, #4]
 801881e:	613b      	str	r3, [r7, #16]
  if (inet_chksum(igmp, p->len)) {
 8018820:	68fb      	ldr	r3, [r7, #12]
 8018822:	895b      	ldrh	r3, [r3, #10]
 8018824:	6938      	ldr	r0, [r7, #16]
 8018826:	4619      	mov	r1, r3
 8018828:	f000 fdec 	bl	8019404 <inet_chksum>
 801882c:	4603      	mov	r3, r0
 801882e:	2b00      	cmp	r3, #0
 8018830:	d003      	beq.n	801883a <igmp_input+0x7a>
    pbuf_free(p);
 8018832:	68f8      	ldr	r0, [r7, #12]
 8018834:	f7fa fb44 	bl	8012ec0 <pbuf_free>
    IGMP_STATS_INC(igmp.chkerr);
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: checksum error\n"));
    return;
 8018838:	e082      	b.n	8018940 <igmp_input+0x180>
  }

  /* Packet is ok so find an existing group */
  group = igmp_lookfor_group(inp, dest); /* use the incoming IP address! */
 801883a:	68b8      	ldr	r0, [r7, #8]
 801883c:	6879      	ldr	r1, [r7, #4]
 801883e:	f7ff ff07 	bl	8018650 <igmp_lookfor_group>
 8018842:	61f8      	str	r0, [r7, #28]
  
  /* If group can be found or create... */
  if (!group) {
 8018844:	69fb      	ldr	r3, [r7, #28]
 8018846:	2b00      	cmp	r3, #0
 8018848:	d103      	bne.n	8018852 <igmp_input+0x92>
    pbuf_free(p);
 801884a:	68f8      	ldr	r0, [r7, #12]
 801884c:	f7fa fb38 	bl	8012ec0 <pbuf_free>
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP frame not for us\n"));
    return;
 8018850:	e076      	b.n	8018940 <igmp_input+0x180>
  }

  /* NOW ACT ON THE INCOMING MESSAGE TYPE... */
  switch (igmp->igmp_msgtype) {
 8018852:	693b      	ldr	r3, [r7, #16]
 8018854:	781b      	ldrb	r3, [r3, #0]
 8018856:	2b11      	cmp	r3, #17
 8018858:	d002      	beq.n	8018860 <igmp_input+0xa0>
 801885a:	2b16      	cmp	r3, #22
 801885c:	d057      	beq.n	801890e <igmp_input+0x14e>
 801885e:	e067      	b.n	8018930 <igmp_input+0x170>
   case IGMP_MEMB_QUERY: {
     /* IGMP_MEMB_QUERY to the "all systems" address ? */
     if ((ip_addr_cmp(dest, &allsystems)) && (igmp->igmp_group_address.addr == 0)) {
 8018860:	687b      	ldr	r3, [r7, #4]
 8018862:	681a      	ldr	r2, [r3, #0]
 8018864:	f245 5390 	movw	r3, #21904	; 0x5590
 8018868:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801886c:	681b      	ldr	r3, [r3, #0]
 801886e:	429a      	cmp	r2, r3
 8018870:	d12d      	bne.n	80188ce <igmp_input+0x10e>
 8018872:	693b      	ldr	r3, [r7, #16]
 8018874:	685b      	ldr	r3, [r3, #4]
 8018876:	2b00      	cmp	r3, #0
 8018878:	d129      	bne.n	80188ce <igmp_input+0x10e>
       /* THIS IS THE GENERAL QUERY */
       LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: General IGMP_MEMB_QUERY on \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));

       if (igmp->igmp_maxresp == 0) {
 801887a:	693b      	ldr	r3, [r7, #16]
 801887c:	785b      	ldrb	r3, [r3, #1]
 801887e:	2b00      	cmp	r3, #0
 8018880:	d103      	bne.n	801888a <igmp_input+0xca>
         IGMP_STATS_INC(igmp.v1_rxed);
         LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\n"));
         igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;
 8018882:	693b      	ldr	r3, [r7, #16]
 8018884:	f04f 020a 	mov.w	r2, #10
 8018888:	705a      	strb	r2, [r3, #1]
       }

       IGMP_STATS_INC(igmp.group_query_rxed);
       groupref = igmp_group_list;
 801888a:	f245 538c 	movw	r3, #21900	; 0x558c
 801888e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018892:	681b      	ldr	r3, [r3, #0]
 8018894:	61bb      	str	r3, [r7, #24]
       while (groupref) {
 8018896:	e016      	b.n	80188c6 <igmp_input+0x106>
         /* Do not send messages on the all systems group address! */
         if ((groupref->interface == inp) && (!(ip_addr_cmp(&(groupref->group_address), &allsystems)))) {
 8018898:	69bb      	ldr	r3, [r7, #24]
 801889a:	685a      	ldr	r2, [r3, #4]
 801889c:	68bb      	ldr	r3, [r7, #8]
 801889e:	429a      	cmp	r2, r3
 80188a0:	d10e      	bne.n	80188c0 <igmp_input+0x100>
 80188a2:	69bb      	ldr	r3, [r7, #24]
 80188a4:	689a      	ldr	r2, [r3, #8]
 80188a6:	f245 5390 	movw	r3, #21904	; 0x5590
 80188aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80188ae:	681b      	ldr	r3, [r3, #0]
 80188b0:	429a      	cmp	r2, r3
 80188b2:	d005      	beq.n	80188c0 <igmp_input+0x100>
           igmp_delaying_member( groupref, igmp->igmp_maxresp);
 80188b4:	693b      	ldr	r3, [r7, #16]
 80188b6:	785b      	ldrb	r3, [r3, #1]
 80188b8:	69b8      	ldr	r0, [r7, #24]
 80188ba:	4619      	mov	r1, r3
 80188bc:	f000 f99c 	bl	8018bf8 <igmp_delaying_member>
         }
         groupref = groupref->next;
 80188c0:	69bb      	ldr	r3, [r7, #24]
 80188c2:	681b      	ldr	r3, [r3, #0]
 80188c4:	61bb      	str	r3, [r7, #24]
         igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;
       }

       IGMP_STATS_INC(igmp.group_query_rxed);
       groupref = igmp_group_list;
       while (groupref) {
 80188c6:	69bb      	ldr	r3, [r7, #24]
 80188c8:	2b00      	cmp	r3, #0
 80188ca:	d1e5      	bne.n	8018898 <igmp_input+0xd8>

  /* NOW ACT ON THE INCOMING MESSAGE TYPE... */
  switch (igmp->igmp_msgtype) {
   case IGMP_MEMB_QUERY: {
     /* IGMP_MEMB_QUERY to the "all systems" address ? */
     if ((ip_addr_cmp(dest, &allsystems)) && (igmp->igmp_group_address.addr == 0)) {
 80188cc:	e01e      	b.n	801890c <igmp_input+0x14c>
         }
         groupref = groupref->next;
       }
     } else {
       /* IGMP_MEMB_QUERY to a specific group ? */
       if (group->group_address.addr != 0) {
 80188ce:	69fb      	ldr	r3, [r7, #28]
 80188d0:	689b      	ldr	r3, [r3, #8]
 80188d2:	2b00      	cmp	r3, #0
 80188d4:	d02d      	beq.n	8018932 <igmp_input+0x172>
         LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_MEMB_QUERY to a specific group "));
         ip_addr_debug_print(IGMP_DEBUG, &group->group_address);
         if (ip_addr_cmp (dest, &allsystems)) {
 80188d6:	687b      	ldr	r3, [r7, #4]
 80188d8:	681a      	ldr	r2, [r3, #0]
 80188da:	f245 5390 	movw	r3, #21904	; 0x5590
 80188de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80188e2:	681b      	ldr	r3, [r3, #0]
 80188e4:	429a      	cmp	r2, r3
 80188e6:	d107      	bne.n	80188f8 <igmp_input+0x138>
           LWIP_DEBUGF(IGMP_DEBUG, (" using \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
           /* we first need to re-lookfor the group since we used dest last time */
           group = igmp_lookfor_group(inp, &igmp->igmp_group_address);
 80188e8:	693b      	ldr	r3, [r7, #16]
 80188ea:	f103 0304 	add.w	r3, r3, #4
 80188ee:	68b8      	ldr	r0, [r7, #8]
 80188f0:	4619      	mov	r1, r3
 80188f2:	f7ff fead 	bl	8018650 <igmp_lookfor_group>
 80188f6:	61f8      	str	r0, [r7, #28]
         } else {
           LWIP_DEBUGF(IGMP_DEBUG, (" with the group address as destination [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
         }

         if (group != NULL) {
 80188f8:	69fb      	ldr	r3, [r7, #28]
 80188fa:	2b00      	cmp	r3, #0
 80188fc:	d019      	beq.n	8018932 <igmp_input+0x172>
           IGMP_STATS_INC(igmp.unicast_query);
           igmp_delaying_member( group, igmp->igmp_maxresp);
 80188fe:	693b      	ldr	r3, [r7, #16]
 8018900:	785b      	ldrb	r3, [r3, #1]
 8018902:	69f8      	ldr	r0, [r7, #28]
 8018904:	4619      	mov	r1, r3
 8018906:	f000 f977 	bl	8018bf8 <igmp_delaying_member>
         }
       }
     }
     break;
 801890a:	e012      	b.n	8018932 <igmp_input+0x172>
 801890c:	e011      	b.n	8018932 <igmp_input+0x172>
   }
   case IGMP_V2_MEMB_REPORT: {
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_V2_MEMB_REPORT\n"));

     IGMP_STATS_INC(igmp.report_rxed);
     if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
 801890e:	69fb      	ldr	r3, [r7, #28]
 8018910:	7b5b      	ldrb	r3, [r3, #13]
 8018912:	2b01      	cmp	r3, #1
 8018914:	d10f      	bne.n	8018936 <igmp_input+0x176>
       /* This is on a specific group we have already looked up */
       group->timer = 0; /* stopped */
 8018916:	69fb      	ldr	r3, [r7, #28]
 8018918:	f04f 0200 	mov.w	r2, #0
 801891c:	81da      	strh	r2, [r3, #14]
       group->group_state = IGMP_GROUP_IDLE_MEMBER;
 801891e:	69fb      	ldr	r3, [r7, #28]
 8018920:	f04f 0202 	mov.w	r2, #2
 8018924:	735a      	strb	r2, [r3, #13]
       group->last_reporter_flag = 0;
 8018926:	69fb      	ldr	r3, [r7, #28]
 8018928:	f04f 0200 	mov.w	r2, #0
 801892c:	731a      	strb	r2, [r3, #12]
     }
     break;
 801892e:	e002      	b.n	8018936 <igmp_input+0x176>
   }
   default: {
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: unexpected msg %d in state %d on group %p on if %p\n",
       igmp->igmp_msgtype, group->group_state, &group, group->interface));
     break;
 8018930:	e002      	b.n	8018938 <igmp_input+0x178>
           IGMP_STATS_INC(igmp.unicast_query);
           igmp_delaying_member( group, igmp->igmp_maxresp);
         }
       }
     }
     break;
 8018932:	bf00      	nop
 8018934:	e000      	b.n	8018938 <igmp_input+0x178>
       /* This is on a specific group we have already looked up */
       group->timer = 0; /* stopped */
       group->group_state = IGMP_GROUP_IDLE_MEMBER;
       group->last_reporter_flag = 0;
     }
     break;
 8018936:	bf00      	nop
       igmp->igmp_msgtype, group->group_state, &group, group->interface));
     break;
   }
  }

  pbuf_free(p);
 8018938:	68f8      	ldr	r0, [r7, #12]
 801893a:	f7fa fac1 	bl	8012ec0 <pbuf_free>
  return;
 801893e:	bf00      	nop
}
 8018940:	f107 0720 	add.w	r7, r7, #32
 8018944:	46bd      	mov	sp, r7
 8018946:	bd80      	pop	{r7, pc}

08018948 <igmp_joingroup>:
 * @param groupaddr the ip address of the group which to join
 * @return ERR_OK if group was joined on the netif(s), an err_t otherwise
 */
err_t
igmp_joingroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr)
{
 8018948:	b590      	push	{r4, r7, lr}
 801894a:	b087      	sub	sp, #28
 801894c:	af00      	add	r7, sp, #0
 801894e:	6078      	str	r0, [r7, #4]
 8018950:	6039      	str	r1, [r7, #0]
  err_t              err = ERR_VAL; /* no matching interface */
 8018952:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8018956:	75fb      	strb	r3, [r7, #23]
  struct igmp_group *group;
  struct netif      *netif;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
 8018958:	683b      	ldr	r3, [r7, #0]
 801895a:	681c      	ldr	r4, [r3, #0]
 801895c:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8018960:	f000 fc40 	bl	80191e4 <ntohl>
 8018964:	4603      	mov	r3, r0
 8018966:	401c      	ands	r4, r3
 8018968:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 801896c:	f000 fc3a 	bl	80191e4 <ntohl>
 8018970:	4603      	mov	r3, r0
 8018972:	429c      	cmp	r4, r3
 8018974:	d002      	beq.n	801897c <igmp_joingroup+0x34>
 8018976:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 801897a:	e064      	b.n	8018a46 <igmp_joingroup+0xfe>
  LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 801897c:	683b      	ldr	r3, [r7, #0]
 801897e:	681a      	ldr	r2, [r3, #0]
 8018980:	f245 5390 	movw	r3, #21904	; 0x5590
 8018984:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018988:	681b      	ldr	r3, [r3, #0]
 801898a:	429a      	cmp	r2, r3
 801898c:	d102      	bne.n	8018994 <igmp_joingroup+0x4c>
 801898e:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8018992:	e058      	b.n	8018a46 <igmp_joingroup+0xfe>

  /* loop through netif's */
  netif = netif_list;
 8018994:	f246 534c 	movw	r3, #25932	; 0x654c
 8018998:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801899c:	681b      	ldr	r3, [r3, #0]
 801899e:	613b      	str	r3, [r7, #16]
  while (netif != NULL) {
 80189a0:	e04d      	b.n	8018a3e <igmp_joingroup+0xf6>
    /* Should we join this interface ? */
    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {
 80189a2:	693b      	ldr	r3, [r7, #16]
 80189a4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 80189a8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80189ac:	2b00      	cmp	r3, #0
 80189ae:	d043      	beq.n	8018a38 <igmp_joingroup+0xf0>
 80189b0:	687b      	ldr	r3, [r7, #4]
 80189b2:	2b00      	cmp	r3, #0
 80189b4:	d009      	beq.n	80189ca <igmp_joingroup+0x82>
 80189b6:	687b      	ldr	r3, [r7, #4]
 80189b8:	681b      	ldr	r3, [r3, #0]
 80189ba:	2b00      	cmp	r3, #0
 80189bc:	d005      	beq.n	80189ca <igmp_joingroup+0x82>
 80189be:	693b      	ldr	r3, [r7, #16]
 80189c0:	685a      	ldr	r2, [r3, #4]
 80189c2:	687b      	ldr	r3, [r7, #4]
 80189c4:	681b      	ldr	r3, [r3, #0]
 80189c6:	429a      	cmp	r2, r3
 80189c8:	d136      	bne.n	8018a38 <igmp_joingroup+0xf0>
      /* find group or create a new one if not found */
      group = igmp_lookup_group(netif, groupaddr);
 80189ca:	6938      	ldr	r0, [r7, #16]
 80189cc:	6839      	ldr	r1, [r7, #0]
 80189ce:	f7ff fe67 	bl	80186a0 <igmp_lookup_group>
 80189d2:	60f8      	str	r0, [r7, #12]

      if (group != NULL) {
 80189d4:	68fb      	ldr	r3, [r7, #12]
 80189d6:	2b00      	cmp	r3, #0
 80189d8:	d02b      	beq.n	8018a32 <igmp_joingroup+0xea>
        /* This should create a new group, check the state to make sure */
        if (group->group_state != IGMP_GROUP_NON_MEMBER) {
 80189da:	68fb      	ldr	r3, [r7, #12]
 80189dc:	7b5b      	ldrb	r3, [r3, #13]
 80189de:	2b00      	cmp	r3, #0
 80189e0:	d11c      	bne.n	8018a1c <igmp_joingroup+0xd4>
          LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: join to new group: "));
          ip_addr_debug_print(IGMP_DEBUG, groupaddr);
          LWIP_DEBUGF(IGMP_DEBUG, ("\n"));

          /* If first use of the group, allow the group at the MAC level */
          if ((group->use==0) && (netif->igmp_mac_filter != NULL)) {
 80189e2:	68fb      	ldr	r3, [r7, #12]
 80189e4:	7c1b      	ldrb	r3, [r3, #16]
 80189e6:	2b00      	cmp	r3, #0
 80189e8:	d10a      	bne.n	8018a00 <igmp_joingroup+0xb8>
 80189ea:	693b      	ldr	r3, [r7, #16]
 80189ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80189ee:	2b00      	cmp	r3, #0
 80189f0:	d006      	beq.n	8018a00 <igmp_joingroup+0xb8>
            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: igmp_mac_filter(ADD "));
            ip_addr_debug_print(IGMP_DEBUG, groupaddr);
            LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
            netif->igmp_mac_filter(netif, groupaddr, IGMP_ADD_MAC_FILTER);
 80189f2:	693b      	ldr	r3, [r7, #16]
 80189f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80189f6:	6938      	ldr	r0, [r7, #16]
 80189f8:	6839      	ldr	r1, [r7, #0]
 80189fa:	f04f 0201 	mov.w	r2, #1
 80189fe:	4798      	blx	r3
          }

          IGMP_STATS_INC(igmp.join_sent);
          igmp_send(group, IGMP_V2_MEMB_REPORT);
 8018a00:	68f8      	ldr	r0, [r7, #12]
 8018a02:	f04f 0116 	mov.w	r1, #22
 8018a06:	f000 f945 	bl	8018c94 <igmp_send>

          igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 8018a0a:	68f8      	ldr	r0, [r7, #12]
 8018a0c:	f04f 0105 	mov.w	r1, #5
 8018a10:	f000 f8d4 	bl	8018bbc <igmp_start_timer>

          /* Need to work out where this timer comes from */
          group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 8018a14:	68fb      	ldr	r3, [r7, #12]
 8018a16:	f04f 0201 	mov.w	r2, #1
 8018a1a:	735a      	strb	r2, [r3, #13]
        }
        /* Increment group use */
        group->use++;
 8018a1c:	68fb      	ldr	r3, [r7, #12]
 8018a1e:	7c1b      	ldrb	r3, [r3, #16]
 8018a20:	f103 0301 	add.w	r3, r3, #1
 8018a24:	b2da      	uxtb	r2, r3
 8018a26:	68fb      	ldr	r3, [r7, #12]
 8018a28:	741a      	strb	r2, [r3, #16]
        /* Join on this interface */
        err = ERR_OK;
 8018a2a:	f04f 0300 	mov.w	r3, #0
 8018a2e:	75fb      	strb	r3, [r7, #23]
 8018a30:	e002      	b.n	8018a38 <igmp_joingroup+0xf0>
      } else {
        /* Return an error even if some network interfaces are joined */
        /** @todo undo any other netif already joined */
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: Not enought memory to join to group\n"));
        return ERR_MEM;
 8018a32:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8018a36:	e006      	b.n	8018a46 <igmp_joingroup+0xfe>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
 8018a38:	693b      	ldr	r3, [r7, #16]
 8018a3a:	681b      	ldr	r3, [r3, #0]
 8018a3c:	613b      	str	r3, [r7, #16]
  LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
  LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);

  /* loop through netif's */
  netif = netif_list;
  while (netif != NULL) {
 8018a3e:	693b      	ldr	r3, [r7, #16]
 8018a40:	2b00      	cmp	r3, #0
 8018a42:	d1ae      	bne.n	80189a2 <igmp_joingroup+0x5a>
    }
    /* proceed to next network interface */
    netif = netif->next;
  }

  return err;
 8018a44:	7dfb      	ldrb	r3, [r7, #23]
 8018a46:	b25b      	sxtb	r3, r3
}
 8018a48:	4618      	mov	r0, r3
 8018a4a:	f107 071c 	add.w	r7, r7, #28
 8018a4e:	46bd      	mov	sp, r7
 8018a50:	bd90      	pop	{r4, r7, pc}
 8018a52:	bf00      	nop

08018a54 <igmp_leavegroup>:
 * @param groupaddr the ip address of the group which to leave
 * @return ERR_OK if group was left on the netif(s), an err_t otherwise
 */
err_t
igmp_leavegroup(struct ip_addr *ifaddr, struct ip_addr *groupaddr)
{
 8018a54:	b590      	push	{r4, r7, lr}
 8018a56:	b087      	sub	sp, #28
 8018a58:	af00      	add	r7, sp, #0
 8018a5a:	6078      	str	r0, [r7, #4]
 8018a5c:	6039      	str	r1, [r7, #0]
  err_t              err = ERR_VAL; /* no matching interface */
 8018a5e:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8018a62:	75fb      	strb	r3, [r7, #23]
  struct igmp_group *group;
  struct netif      *netif;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_leavegroup: attempt to leave non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
 8018a64:	683b      	ldr	r3, [r7, #0]
 8018a66:	681c      	ldr	r4, [r3, #0]
 8018a68:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8018a6c:	f000 fbba 	bl	80191e4 <ntohl>
 8018a70:	4603      	mov	r3, r0
 8018a72:	401c      	ands	r4, r3
 8018a74:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8018a78:	f000 fbb4 	bl	80191e4 <ntohl>
 8018a7c:	4603      	mov	r3, r0
 8018a7e:	429c      	cmp	r4, r3
 8018a80:	d002      	beq.n	8018a88 <igmp_leavegroup+0x34>
 8018a82:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8018a86:	e05b      	b.n	8018b40 <igmp_leavegroup+0xec>
  LWIP_ERROR("igmp_leavegroup: attempt to leave allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 8018a88:	683b      	ldr	r3, [r7, #0]
 8018a8a:	681a      	ldr	r2, [r3, #0]
 8018a8c:	f245 5390 	movw	r3, #21904	; 0x5590
 8018a90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018a94:	681b      	ldr	r3, [r3, #0]
 8018a96:	429a      	cmp	r2, r3
 8018a98:	d102      	bne.n	8018aa0 <igmp_leavegroup+0x4c>
 8018a9a:	f04f 03f7 	mov.w	r3, #247	; 0xf7
 8018a9e:	e04f      	b.n	8018b40 <igmp_leavegroup+0xec>

  /* loop through netif's */
  netif = netif_list;
 8018aa0:	f246 534c 	movw	r3, #25932	; 0x654c
 8018aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018aa8:	681b      	ldr	r3, [r3, #0]
 8018aaa:	613b      	str	r3, [r7, #16]
  while (netif != NULL) {
 8018aac:	e044      	b.n	8018b38 <igmp_leavegroup+0xe4>
    /* Should we leave this interface ? */
    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {
 8018aae:	693b      	ldr	r3, [r7, #16]
 8018ab0:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8018ab4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8018ab8:	2b00      	cmp	r3, #0
 8018aba:	d03a      	beq.n	8018b32 <igmp_leavegroup+0xde>
 8018abc:	687b      	ldr	r3, [r7, #4]
 8018abe:	2b00      	cmp	r3, #0
 8018ac0:	d009      	beq.n	8018ad6 <igmp_leavegroup+0x82>
 8018ac2:	687b      	ldr	r3, [r7, #4]
 8018ac4:	681b      	ldr	r3, [r3, #0]
 8018ac6:	2b00      	cmp	r3, #0
 8018ac8:	d005      	beq.n	8018ad6 <igmp_leavegroup+0x82>
 8018aca:	693b      	ldr	r3, [r7, #16]
 8018acc:	685a      	ldr	r2, [r3, #4]
 8018ace:	687b      	ldr	r3, [r7, #4]
 8018ad0:	681b      	ldr	r3, [r3, #0]
 8018ad2:	429a      	cmp	r2, r3
 8018ad4:	d12d      	bne.n	8018b32 <igmp_leavegroup+0xde>
      /* find group */
      group = igmp_lookfor_group(netif, groupaddr);
 8018ad6:	6938      	ldr	r0, [r7, #16]
 8018ad8:	6839      	ldr	r1, [r7, #0]
 8018ada:	f7ff fdb9 	bl	8018650 <igmp_lookfor_group>
 8018ade:	60f8      	str	r0, [r7, #12]

      if (group != NULL) {
 8018ae0:	68fb      	ldr	r3, [r7, #12]
 8018ae2:	2b00      	cmp	r3, #0
 8018ae4:	d025      	beq.n	8018b32 <igmp_leavegroup+0xde>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: Leaving group: "));
        ip_addr_debug_print(IGMP_DEBUG, groupaddr);
        LWIP_DEBUGF(IGMP_DEBUG, ("\n"));

        /* If there is no other use of the group */
        if (group->use <= 1) {
 8018ae6:	68fb      	ldr	r3, [r7, #12]
 8018ae8:	7c1b      	ldrb	r3, [r3, #16]
 8018aea:	2b01      	cmp	r3, #1
 8018aec:	d817      	bhi.n	8018b1e <igmp_leavegroup+0xca>
          /* If we are the last reporter for this group */
          if (group->last_reporter_flag) {
 8018aee:	68fb      	ldr	r3, [r7, #12]
 8018af0:	7b1b      	ldrb	r3, [r3, #12]
 8018af2:	2b00      	cmp	r3, #0
 8018af4:	d004      	beq.n	8018b00 <igmp_leavegroup+0xac>
            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: sending leaving group\n"));
            IGMP_STATS_INC(igmp.leave_sent);
            igmp_send(group, IGMP_LEAVE_GROUP);
 8018af6:	68f8      	ldr	r0, [r7, #12]
 8018af8:	f04f 0117 	mov.w	r1, #23
 8018afc:	f000 f8ca 	bl	8018c94 <igmp_send>
          }
          
          /* Disable the group at the MAC level */
          if (netif->igmp_mac_filter != NULL) {
 8018b00:	693b      	ldr	r3, [r7, #16]
 8018b02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8018b04:	2b00      	cmp	r3, #0
 8018b06:	d006      	beq.n	8018b16 <igmp_leavegroup+0xc2>
            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: igmp_mac_filter(DEL "));
            ip_addr_debug_print(IGMP_DEBUG, groupaddr);
            LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
            netif->igmp_mac_filter(netif, groupaddr, IGMP_DEL_MAC_FILTER);
 8018b08:	693b      	ldr	r3, [r7, #16]
 8018b0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8018b0c:	6938      	ldr	r0, [r7, #16]
 8018b0e:	6839      	ldr	r1, [r7, #0]
 8018b10:	f04f 0200 	mov.w	r2, #0
 8018b14:	4798      	blx	r3
          LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: remove group: "));
          ip_addr_debug_print(IGMP_DEBUG, groupaddr);
          LWIP_DEBUGF(IGMP_DEBUG, ("\n"));          
          
          /* Free the group */
          igmp_remove_group(group);
 8018b16:	68f8      	ldr	r0, [r7, #12]
 8018b18:	f7ff fe14 	bl	8018744 <igmp_remove_group>
 8018b1c:	e006      	b.n	8018b2c <igmp_leavegroup+0xd8>
        } else {
          /* Decrement group use */
          group->use--;
 8018b1e:	68fb      	ldr	r3, [r7, #12]
 8018b20:	7c1b      	ldrb	r3, [r3, #16]
 8018b22:	f103 33ff 	add.w	r3, r3, #4294967295
 8018b26:	b2da      	uxtb	r2, r3
 8018b28:	68fb      	ldr	r3, [r7, #12]
 8018b2a:	741a      	strb	r2, [r3, #16]
        }
        /* Leave on this interface */
        err = ERR_OK;
 8018b2c:	f04f 0300 	mov.w	r3, #0
 8018b30:	75fb      	strb	r3, [r7, #23]
        /* It's not a fatal error on "leavegroup" */
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: not member of group\n"));
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
 8018b32:	693b      	ldr	r3, [r7, #16]
 8018b34:	681b      	ldr	r3, [r3, #0]
 8018b36:	613b      	str	r3, [r7, #16]
  LWIP_ERROR("igmp_leavegroup: attempt to leave non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
  LWIP_ERROR("igmp_leavegroup: attempt to leave allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);

  /* loop through netif's */
  netif = netif_list;
  while (netif != NULL) {
 8018b38:	693b      	ldr	r3, [r7, #16]
 8018b3a:	2b00      	cmp	r3, #0
 8018b3c:	d1b7      	bne.n	8018aae <igmp_leavegroup+0x5a>
    }
    /* proceed to next network interface */
    netif = netif->next;
  }

  return err;
 8018b3e:	7dfb      	ldrb	r3, [r7, #23]
 8018b40:	b25b      	sxtb	r3, r3
}
 8018b42:	4618      	mov	r0, r3
 8018b44:	f107 071c 	add.w	r7, r7, #28
 8018b48:	46bd      	mov	sp, r7
 8018b4a:	bd90      	pop	{r4, r7, pc}

08018b4c <igmp_tmr>:
 * The igmp timer function (both for NO_SYS=1 and =0)
 * Should be called every IGMP_TMR_INTERVAL milliseconds (100 ms is default).
 */
void
igmp_tmr(void)
{
 8018b4c:	b580      	push	{r7, lr}
 8018b4e:	b082      	sub	sp, #8
 8018b50:	af00      	add	r7, sp, #0
  struct igmp_group *group = igmp_group_list;
 8018b52:	f245 538c 	movw	r3, #21900	; 0x558c
 8018b56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018b5a:	681b      	ldr	r3, [r3, #0]
 8018b5c:	607b      	str	r3, [r7, #4]

  while (group != NULL) {
 8018b5e:	e014      	b.n	8018b8a <igmp_tmr+0x3e>
    if (group->timer != 0) {
 8018b60:	687b      	ldr	r3, [r7, #4]
 8018b62:	89db      	ldrh	r3, [r3, #14]
 8018b64:	2b00      	cmp	r3, #0
 8018b66:	d00d      	beq.n	8018b84 <igmp_tmr+0x38>
      group->timer -= 1;
 8018b68:	687b      	ldr	r3, [r7, #4]
 8018b6a:	89db      	ldrh	r3, [r3, #14]
 8018b6c:	f103 33ff 	add.w	r3, r3, #4294967295
 8018b70:	b29a      	uxth	r2, r3
 8018b72:	687b      	ldr	r3, [r7, #4]
 8018b74:	81da      	strh	r2, [r3, #14]
      if (group->timer == 0) {
 8018b76:	687b      	ldr	r3, [r7, #4]
 8018b78:	89db      	ldrh	r3, [r3, #14]
 8018b7a:	2b00      	cmp	r3, #0
 8018b7c:	d102      	bne.n	8018b84 <igmp_tmr+0x38>
        igmp_timeout(group);
 8018b7e:	6878      	ldr	r0, [r7, #4]
 8018b80:	f000 f80a 	bl	8018b98 <igmp_timeout>
      }
    }
    group = group->next;
 8018b84:	687b      	ldr	r3, [r7, #4]
 8018b86:	681b      	ldr	r3, [r3, #0]
 8018b88:	607b      	str	r3, [r7, #4]
void
igmp_tmr(void)
{
  struct igmp_group *group = igmp_group_list;

  while (group != NULL) {
 8018b8a:	687b      	ldr	r3, [r7, #4]
 8018b8c:	2b00      	cmp	r3, #0
 8018b8e:	d1e7      	bne.n	8018b60 <igmp_tmr+0x14>
        igmp_timeout(group);
      }
    }
    group = group->next;
  }
}
 8018b90:	f107 0708 	add.w	r7, r7, #8
 8018b94:	46bd      	mov	sp, r7
 8018b96:	bd80      	pop	{r7, pc}

08018b98 <igmp_timeout>:
 *
 * @param group an igmp_group for which a timeout is reached
 */
void
igmp_timeout(struct igmp_group *group)
{
 8018b98:	b580      	push	{r7, lr}
 8018b9a:	b082      	sub	sp, #8
 8018b9c:	af00      	add	r7, sp, #0
 8018b9e:	6078      	str	r0, [r7, #4]
  /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */
  if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
 8018ba0:	687b      	ldr	r3, [r7, #4]
 8018ba2:	7b5b      	ldrb	r3, [r3, #13]
 8018ba4:	2b01      	cmp	r3, #1
 8018ba6:	d104      	bne.n	8018bb2 <igmp_timeout+0x1a>
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_timeout: report membership for group with address "));
    ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));
    LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", group->interface));

    igmp_send(group, IGMP_V2_MEMB_REPORT);
 8018ba8:	6878      	ldr	r0, [r7, #4]
 8018baa:	f04f 0116 	mov.w	r1, #22
 8018bae:	f000 f871 	bl	8018c94 <igmp_send>
  }
}
 8018bb2:	f107 0708 	add.w	r7, r7, #8
 8018bb6:	46bd      	mov	sp, r7
 8018bb8:	bd80      	pop	{r7, pc}
 8018bba:	bf00      	nop

08018bbc <igmp_start_timer>:
 * @param max_time the time in multiples of IGMP_TMR_INTERVAL (decrease with
 *        every call to igmp_tmr())
 */
void
igmp_start_timer(struct igmp_group *group, u8_t max_time)
{
 8018bbc:	b480      	push	{r7}
 8018bbe:	b083      	sub	sp, #12
 8018bc0:	af00      	add	r7, sp, #0
 8018bc2:	6078      	str	r0, [r7, #4]
 8018bc4:	460b      	mov	r3, r1
 8018bc6:	70fb      	strb	r3, [r7, #3]
  /**
   * @todo Important !! this should be random 0 -> max_time. Find out how to do this
   */
  group->timer = max_time;
 8018bc8:	78fb      	ldrb	r3, [r7, #3]
 8018bca:	b29a      	uxth	r2, r3
 8018bcc:	687b      	ldr	r3, [r7, #4]
 8018bce:	81da      	strh	r2, [r3, #14]
}
 8018bd0:	f107 070c 	add.w	r7, r7, #12
 8018bd4:	46bd      	mov	sp, r7
 8018bd6:	bc80      	pop	{r7}
 8018bd8:	4770      	bx	lr
 8018bda:	bf00      	nop

08018bdc <igmp_stop_timer>:
 *
 * @param group the igmp_group for which to stop the timer
 */
void
igmp_stop_timer(struct igmp_group *group)
{
 8018bdc:	b480      	push	{r7}
 8018bde:	b083      	sub	sp, #12
 8018be0:	af00      	add	r7, sp, #0
 8018be2:	6078      	str	r0, [r7, #4]
  group->timer = 0;
 8018be4:	687b      	ldr	r3, [r7, #4]
 8018be6:	f04f 0200 	mov.w	r2, #0
 8018bea:	81da      	strh	r2, [r3, #14]
}
 8018bec:	f107 070c 	add.w	r7, r7, #12
 8018bf0:	46bd      	mov	sp, r7
 8018bf2:	bc80      	pop	{r7}
 8018bf4:	4770      	bx	lr
 8018bf6:	bf00      	nop

08018bf8 <igmp_delaying_member>:
 * @param group the igmp_group for which "delaying" membership report
 * @param maxresp query delay
 */
void
igmp_delaying_member( struct igmp_group *group, u8_t maxresp)
{
 8018bf8:	b580      	push	{r7, lr}
 8018bfa:	b082      	sub	sp, #8
 8018bfc:	af00      	add	r7, sp, #0
 8018bfe:	6078      	str	r0, [r7, #4]
 8018c00:	460b      	mov	r3, r1
 8018c02:	70fb      	strb	r3, [r7, #3]
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
 8018c04:	687b      	ldr	r3, [r7, #4]
 8018c06:	7b5b      	ldrb	r3, [r3, #13]
 8018c08:	2b02      	cmp	r3, #2
 8018c0a:	d009      	beq.n	8018c20 <igmp_delaying_member+0x28>
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) && (maxresp > group->timer))) {
 8018c0c:	687b      	ldr	r3, [r7, #4]
 8018c0e:	7b5b      	ldrb	r3, [r3, #13]
 * @param maxresp query delay
 */
void
igmp_delaying_member( struct igmp_group *group, u8_t maxresp)
{
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
 8018c10:	2b01      	cmp	r3, #1
 8018c12:	d111      	bne.n	8018c38 <igmp_delaying_member+0x40>
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) && (maxresp > group->timer))) {
 8018c14:	78fb      	ldrb	r3, [r7, #3]
 8018c16:	b29a      	uxth	r2, r3
 8018c18:	687b      	ldr	r3, [r7, #4]
 8018c1a:	89db      	ldrh	r3, [r3, #14]
 8018c1c:	429a      	cmp	r2, r3
 8018c1e:	d90b      	bls.n	8018c38 <igmp_delaying_member+0x40>
    igmp_start_timer(group, (maxresp)/2);
 8018c20:	78fb      	ldrb	r3, [r7, #3]
 8018c22:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8018c26:	b2db      	uxtb	r3, r3
 8018c28:	6878      	ldr	r0, [r7, #4]
 8018c2a:	4619      	mov	r1, r3
 8018c2c:	f7ff ffc6 	bl	8018bbc <igmp_start_timer>
    group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 8018c30:	687b      	ldr	r3, [r7, #4]
 8018c32:	f04f 0201 	mov.w	r2, #1
 8018c36:	735a      	strb	r2, [r3, #13]
  }
}
 8018c38:	f107 0708 	add.w	r7, r7, #8
 8018c3c:	46bd      	mov	sp, r7
 8018c3e:	bd80      	pop	{r7, pc}

08018c40 <igmp_ip_output_if>:
 *         returns errors returned by netif->output
 */
err_t
igmp_ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
                  u8_t ttl, u8_t proto, struct netif *netif)
{
 8018c40:	b580      	push	{r7, lr}
 8018c42:	b08c      	sub	sp, #48	; 0x30
 8018c44:	af06      	add	r7, sp, #24
 8018c46:	60f8      	str	r0, [r7, #12]
 8018c48:	60b9      	str	r1, [r7, #8]
 8018c4a:	607a      	str	r2, [r7, #4]
 8018c4c:	70fb      	strb	r3, [r7, #3]
  /* This is the "router alert" option */
  u16_t ra[2];
  ra[0] = htons (ROUTER_ALERT);
 8018c4e:	f249 4004 	movw	r0, #37892	; 0x9404
 8018c52:	f000 fa81 	bl	8019158 <htons>
 8018c56:	4603      	mov	r3, r0
 8018c58:	82bb      	strh	r3, [r7, #20]
  ra[1] = 0x0000; /* Router shall examine packet */
 8018c5a:	f04f 0300 	mov.w	r3, #0
 8018c5e:	82fb      	strh	r3, [r7, #22]
  return ip_output_if_opt(p, src, dest, ttl, 0, proto, netif, ra, ROUTER_ALERTLEN);
 8018c60:	78fb      	ldrb	r3, [r7, #3]
 8018c62:	f04f 0200 	mov.w	r2, #0
 8018c66:	9200      	str	r2, [sp, #0]
 8018c68:	f897 2020 	ldrb.w	r2, [r7, #32]
 8018c6c:	9201      	str	r2, [sp, #4]
 8018c6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018c70:	9202      	str	r2, [sp, #8]
 8018c72:	f107 0214 	add.w	r2, r7, #20
 8018c76:	9203      	str	r2, [sp, #12]
 8018c78:	f04f 0204 	mov.w	r2, #4
 8018c7c:	9204      	str	r2, [sp, #16]
 8018c7e:	68f8      	ldr	r0, [r7, #12]
 8018c80:	68b9      	ldr	r1, [r7, #8]
 8018c82:	687a      	ldr	r2, [r7, #4]
 8018c84:	f000 fe16 	bl	80198b4 <ip_output_if_opt>
 8018c88:	4603      	mov	r3, r0
}
 8018c8a:	4618      	mov	r0, r3
 8018c8c:	f107 0718 	add.w	r7, r7, #24
 8018c90:	46bd      	mov	sp, r7
 8018c92:	bd80      	pop	{r7, pc}

08018c94 <igmp_send>:
 * @param group the group to which to send the packet
 * @param type the type of igmp packet to send
 */
void
igmp_send(struct igmp_group *group, u8_t type)
{
 8018c94:	b580      	push	{r7, lr}
 8018c96:	b088      	sub	sp, #32
 8018c98:	af02      	add	r7, sp, #8
 8018c9a:	6078      	str	r0, [r7, #4]
 8018c9c:	460b      	mov	r3, r1
 8018c9e:	70fb      	strb	r3, [r7, #3]
  struct pbuf*     p    = NULL;
 8018ca0:	f04f 0300 	mov.w	r3, #0
 8018ca4:	613b      	str	r3, [r7, #16]
  struct igmp_msg* igmp = NULL;
 8018ca6:	f04f 0300 	mov.w	r3, #0
 8018caa:	60fb      	str	r3, [r7, #12]
  struct ip_addr   src  = {0};
 8018cac:	f04f 0300 	mov.w	r3, #0
 8018cb0:	60bb      	str	r3, [r7, #8]
  struct ip_addr*  dest = NULL;
 8018cb2:	f04f 0300 	mov.w	r3, #0
 8018cb6:	617b      	str	r3, [r7, #20]

  /* IP header + "router alert" option + IGMP header */
  p = pbuf_alloc(PBUF_TRANSPORT, IGMP_MINLEN, PBUF_RAM);
 8018cb8:	f04f 0000 	mov.w	r0, #0
 8018cbc:	f04f 0108 	mov.w	r1, #8
 8018cc0:	f04f 0200 	mov.w	r2, #0
 8018cc4:	f7f9 fef4 	bl	8012ab0 <pbuf_alloc>
 8018cc8:	6138      	str	r0, [r7, #16]
  
  if (p) {
 8018cca:	693b      	ldr	r3, [r7, #16]
 8018ccc:	2b00      	cmp	r3, #0
 8018cce:	d06a      	beq.n	8018da6 <igmp_send+0x112>
    igmp = p->payload;
 8018cd0:	693b      	ldr	r3, [r7, #16]
 8018cd2:	685b      	ldr	r3, [r3, #4]
 8018cd4:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
               (p->len >= sizeof(struct igmp_msg)));
    ip_addr_set(&src, &((group->interface)->ip_addr));
 8018cd6:	687b      	ldr	r3, [r7, #4]
 8018cd8:	685b      	ldr	r3, [r3, #4]
 8018cda:	f103 0304 	add.w	r3, r3, #4
 8018cde:	2b00      	cmp	r3, #0
 8018ce0:	d003      	beq.n	8018cea <igmp_send+0x56>
 8018ce2:	687b      	ldr	r3, [r7, #4]
 8018ce4:	685b      	ldr	r3, [r3, #4]
 8018ce6:	685b      	ldr	r3, [r3, #4]
 8018ce8:	e001      	b.n	8018cee <igmp_send+0x5a>
 8018cea:	f04f 0300 	mov.w	r3, #0
 8018cee:	60bb      	str	r3, [r7, #8]
     
    if (type == IGMP_V2_MEMB_REPORT) {
 8018cf0:	78fb      	ldrb	r3, [r7, #3]
 8018cf2:	2b16      	cmp	r3, #22
 8018cf4:	d114      	bne.n	8018d20 <igmp_send+0x8c>
      dest = &(group->group_address);
 8018cf6:	687b      	ldr	r3, [r7, #4]
 8018cf8:	f103 0308 	add.w	r3, r3, #8
 8018cfc:	617b      	str	r3, [r7, #20]
      IGMP_STATS_INC(igmp.report_sent);
      ip_addr_set(&(igmp->igmp_group_address), &(group->group_address));
 8018cfe:	687b      	ldr	r3, [r7, #4]
 8018d00:	f103 0308 	add.w	r3, r3, #8
 8018d04:	2b00      	cmp	r3, #0
 8018d06:	d002      	beq.n	8018d0e <igmp_send+0x7a>
 8018d08:	687b      	ldr	r3, [r7, #4]
 8018d0a:	689b      	ldr	r3, [r3, #8]
 8018d0c:	e001      	b.n	8018d12 <igmp_send+0x7e>
 8018d0e:	f04f 0300 	mov.w	r3, #0
 8018d12:	68fa      	ldr	r2, [r7, #12]
 8018d14:	6053      	str	r3, [r2, #4]
      group->last_reporter_flag = 1; /* Remember we were the last to report */
 8018d16:	687b      	ldr	r3, [r7, #4]
 8018d18:	f04f 0201 	mov.w	r2, #1
 8018d1c:	731a      	strb	r2, [r3, #12]
 8018d1e:	e013      	b.n	8018d48 <igmp_send+0xb4>
    } else {
      if (type == IGMP_LEAVE_GROUP) {
 8018d20:	78fb      	ldrb	r3, [r7, #3]
 8018d22:	2b17      	cmp	r3, #23
 8018d24:	d110      	bne.n	8018d48 <igmp_send+0xb4>
        dest = &allrouters;
 8018d26:	f245 5394 	movw	r3, #21908	; 0x5594
 8018d2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018d2e:	617b      	str	r3, [r7, #20]
        ip_addr_set(&(igmp->igmp_group_address), &(group->group_address));
 8018d30:	687b      	ldr	r3, [r7, #4]
 8018d32:	f103 0308 	add.w	r3, r3, #8
 8018d36:	2b00      	cmp	r3, #0
 8018d38:	d002      	beq.n	8018d40 <igmp_send+0xac>
 8018d3a:	687b      	ldr	r3, [r7, #4]
 8018d3c:	689b      	ldr	r3, [r3, #8]
 8018d3e:	e001      	b.n	8018d44 <igmp_send+0xb0>
 8018d40:	f04f 0300 	mov.w	r3, #0
 8018d44:	68fa      	ldr	r2, [r7, #12]
 8018d46:	6053      	str	r3, [r2, #4]
      }
    }

    if ((type == IGMP_V2_MEMB_REPORT) || (type == IGMP_LEAVE_GROUP)) {
 8018d48:	78fb      	ldrb	r3, [r7, #3]
 8018d4a:	2b16      	cmp	r3, #22
 8018d4c:	d002      	beq.n	8018d54 <igmp_send+0xc0>
 8018d4e:	78fb      	ldrb	r3, [r7, #3]
 8018d50:	2b17      	cmp	r3, #23
 8018d52:	d125      	bne.n	8018da0 <igmp_send+0x10c>
      igmp->igmp_msgtype  = type;
 8018d54:	68fb      	ldr	r3, [r7, #12]
 8018d56:	78fa      	ldrb	r2, [r7, #3]
 8018d58:	701a      	strb	r2, [r3, #0]
      igmp->igmp_maxresp  = 0;
 8018d5a:	68fb      	ldr	r3, [r7, #12]
 8018d5c:	f04f 0200 	mov.w	r2, #0
 8018d60:	705a      	strb	r2, [r3, #1]
      igmp->igmp_checksum = 0;
 8018d62:	68fb      	ldr	r3, [r7, #12]
 8018d64:	f04f 0200 	mov.w	r2, #0
 8018d68:	709a      	strb	r2, [r3, #2]
 8018d6a:	f04f 0200 	mov.w	r2, #0
 8018d6e:	70da      	strb	r2, [r3, #3]
      igmp->igmp_checksum = inet_chksum( igmp, IGMP_MINLEN);
 8018d70:	68f8      	ldr	r0, [r7, #12]
 8018d72:	f04f 0108 	mov.w	r1, #8
 8018d76:	f000 fb45 	bl	8019404 <inet_chksum>
 8018d7a:	4603      	mov	r3, r0
 8018d7c:	461a      	mov	r2, r3
 8018d7e:	68fb      	ldr	r3, [r7, #12]
 8018d80:	805a      	strh	r2, [r3, #2]

      igmp_ip_output_if(p, &src, dest, IGMP_TTL, IP_PROTO_IGMP, group->interface);
 8018d82:	687b      	ldr	r3, [r7, #4]
 8018d84:	685a      	ldr	r2, [r3, #4]
 8018d86:	f107 0308 	add.w	r3, r7, #8
 8018d8a:	f04f 0102 	mov.w	r1, #2
 8018d8e:	9100      	str	r1, [sp, #0]
 8018d90:	9201      	str	r2, [sp, #4]
 8018d92:	6938      	ldr	r0, [r7, #16]
 8018d94:	4619      	mov	r1, r3
 8018d96:	697a      	ldr	r2, [r7, #20]
 8018d98:	f04f 0301 	mov.w	r3, #1
 8018d9c:	f7ff ff50 	bl	8018c40 <igmp_ip_output_if>
    }

    pbuf_free(p);
 8018da0:	6938      	ldr	r0, [r7, #16]
 8018da2:	f7fa f88d 	bl	8012ec0 <pbuf_free>
  } else {
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_send: not enough memory for igmp_send\n"));
  }
}
 8018da6:	f107 0718 	add.w	r7, r7, #24
 8018daa:	46bd      	mov	sp, r7
 8018dac:	bd80      	pop	{r7, pc}
 8018dae:	bf00      	nop

08018db0 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
 8018db0:	b580      	push	{r7, lr}
 8018db2:	b084      	sub	sp, #16
 8018db4:	af00      	add	r7, sp, #0
 8018db6:	6078      	str	r0, [r7, #4]
  struct in_addr val;

  if (inet_aton(cp, &val)) {
 8018db8:	f107 030c 	add.w	r3, r7, #12
 8018dbc:	6878      	ldr	r0, [r7, #4]
 8018dbe:	4619      	mov	r1, r3
 8018dc0:	f000 f80c 	bl	8018ddc <inet_aton>
 8018dc4:	4603      	mov	r3, r0
 8018dc6:	2b00      	cmp	r3, #0
 8018dc8:	d001      	beq.n	8018dce <inet_addr+0x1e>
    return (val.s_addr);
 8018dca:	68fb      	ldr	r3, [r7, #12]
 8018dcc:	e001      	b.n	8018dd2 <inet_addr+0x22>
  }
  return (INADDR_NONE);
 8018dce:	f04f 33ff 	mov.w	r3, #4294967295
}
 8018dd2:	4618      	mov	r0, r3
 8018dd4:	f107 0710 	add.w	r7, r7, #16
 8018dd8:	46bd      	mov	sp, r7
 8018dda:	bd80      	pop	{r7, pc}

08018ddc <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
 8018ddc:	b580      	push	{r7, lr}
 8018dde:	b08a      	sub	sp, #40	; 0x28
 8018de0:	af00      	add	r7, sp, #0
 8018de2:	6078      	str	r0, [r7, #4]
 8018de4:	6039      	str	r1, [r7, #0]
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 8018de6:	f107 030c 	add.w	r3, r7, #12
 8018dea:	61fb      	str	r3, [r7, #28]

  c = *cp;
 8018dec:	687b      	ldr	r3, [r7, #4]
 8018dee:	781b      	ldrb	r3, [r3, #0]
 8018df0:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 8018df4:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018df8:	2b2f      	cmp	r3, #47	; 0x2f
 8018dfa:	d903      	bls.n	8018e04 <inet_aton+0x28>
 8018dfc:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018e00:	2b39      	cmp	r3, #57	; 0x39
 8018e02:	d902      	bls.n	8018e0a <inet_aton+0x2e>
      return (0);
 8018e04:	f04f 0300 	mov.w	r3, #0
 8018e08:	e11d      	b.n	8019046 <inet_aton+0x26a>
    val = 0;
 8018e0a:	f04f 0300 	mov.w	r3, #0
 8018e0e:	627b      	str	r3, [r7, #36]	; 0x24
    base = 10;
 8018e10:	f04f 030a 	mov.w	r3, #10
 8018e14:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (c == '0') {
 8018e18:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018e1c:	2b30      	cmp	r3, #48	; 0x30
 8018e1e:	d120      	bne.n	8018e62 <inet_aton+0x86>
      c = *++cp;
 8018e20:	687b      	ldr	r3, [r7, #4]
 8018e22:	f103 0301 	add.w	r3, r3, #1
 8018e26:	607b      	str	r3, [r7, #4]
 8018e28:	687b      	ldr	r3, [r7, #4]
 8018e2a:	781b      	ldrb	r3, [r3, #0]
 8018e2c:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
      if (c == 'x' || c == 'X') {
 8018e30:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018e34:	2b78      	cmp	r3, #120	; 0x78
 8018e36:	d003      	beq.n	8018e40 <inet_aton+0x64>
 8018e38:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018e3c:	2b58      	cmp	r3, #88	; 0x58
 8018e3e:	d10c      	bne.n	8018e5a <inet_aton+0x7e>
        base = 16;
 8018e40:	f04f 0310 	mov.w	r3, #16
 8018e44:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        c = *++cp;
 8018e48:	687b      	ldr	r3, [r7, #4]
 8018e4a:	f103 0301 	add.w	r3, r3, #1
 8018e4e:	607b      	str	r3, [r7, #4]
 8018e50:	687b      	ldr	r3, [r7, #4]
 8018e52:	781b      	ldrb	r3, [r3, #0]
 8018e54:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 8018e58:	e003      	b.n	8018e62 <inet_aton+0x86>
      } else
        base = 8;
 8018e5a:	f04f 0308 	mov.w	r3, #8
 8018e5e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    }
    for (;;) {
      if (isdigit(c)) {
 8018e62:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018e66:	2b2f      	cmp	r3, #47	; 0x2f
 8018e68:	d917      	bls.n	8018e9a <inet_aton+0xbe>
 8018e6a:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018e6e:	2b39      	cmp	r3, #57	; 0x39
 8018e70:	d813      	bhi.n	8018e9a <inet_aton+0xbe>
        val = (val * base) + (int)(c - '0');
 8018e72:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8018e76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018e78:	fb02 f203 	mul.w	r2, r2, r3
 8018e7c:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018e80:	18d3      	adds	r3, r2, r3
 8018e82:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8018e86:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8018e88:	687b      	ldr	r3, [r7, #4]
 8018e8a:	f103 0301 	add.w	r3, r3, #1
 8018e8e:	607b      	str	r3, [r7, #4]
 8018e90:	687b      	ldr	r3, [r7, #4]
 8018e92:	781b      	ldrb	r3, [r3, #0]
 8018e94:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
 8018e98:	e7e3      	b.n	8018e62 <inet_aton+0x86>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
 8018e9a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8018e9e:	2b10      	cmp	r3, #16
 8018ea0:	d137      	bne.n	8018f12 <inet_aton+0x136>
 8018ea2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018ea6:	2b2f      	cmp	r3, #47	; 0x2f
 8018ea8:	d903      	bls.n	8018eb2 <inet_aton+0xd6>
 8018eaa:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018eae:	2b39      	cmp	r3, #57	; 0x39
 8018eb0:	d90f      	bls.n	8018ed2 <inet_aton+0xf6>
 8018eb2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018eb6:	2b60      	cmp	r3, #96	; 0x60
 8018eb8:	d903      	bls.n	8018ec2 <inet_aton+0xe6>
 8018eba:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018ebe:	2b66      	cmp	r3, #102	; 0x66
 8018ec0:	d907      	bls.n	8018ed2 <inet_aton+0xf6>
 8018ec2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018ec6:	2b40      	cmp	r3, #64	; 0x40
 8018ec8:	d923      	bls.n	8018f12 <inet_aton+0x136>
 8018eca:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018ece:	2b46      	cmp	r3, #70	; 0x46
 8018ed0:	d81f      	bhi.n	8018f12 <inet_aton+0x136>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
 8018ed2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ed4:	ea4f 1203 	mov.w	r2, r3, lsl #4
 8018ed8:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018edc:	f103 010a 	add.w	r1, r3, #10
 8018ee0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018ee4:	2b60      	cmp	r3, #96	; 0x60
 8018ee6:	d906      	bls.n	8018ef6 <inet_aton+0x11a>
 8018ee8:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018eec:	2b7a      	cmp	r3, #122	; 0x7a
 8018eee:	d802      	bhi.n	8018ef6 <inet_aton+0x11a>
 8018ef0:	f04f 0361 	mov.w	r3, #97	; 0x61
 8018ef4:	e001      	b.n	8018efa <inet_aton+0x11e>
 8018ef6:	f04f 0341 	mov.w	r3, #65	; 0x41
 8018efa:	1acb      	subs	r3, r1, r3
 8018efc:	4313      	orrs	r3, r2
 8018efe:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8018f00:	687b      	ldr	r3, [r7, #4]
 8018f02:	f103 0301 	add.w	r3, r3, #1
 8018f06:	607b      	str	r3, [r7, #4]
 8018f08:	687b      	ldr	r3, [r7, #4]
 8018f0a:	781b      	ldrb	r3, [r3, #0]
 8018f0c:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
      } else
        break;
    }
 8018f10:	e7a7      	b.n	8018e62 <inet_aton+0x86>
    if (c == '.') {
 8018f12:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f16:	2b2e      	cmp	r3, #46	; 0x2e
 8018f18:	d119      	bne.n	8018f4e <inet_aton+0x172>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
 8018f1a:	f107 030c 	add.w	r3, r7, #12
 8018f1e:	f103 030c 	add.w	r3, r3, #12
 8018f22:	69fa      	ldr	r2, [r7, #28]
 8018f24:	429a      	cmp	r2, r3
 8018f26:	d302      	bcc.n	8018f2e <inet_aton+0x152>
        return (0);
 8018f28:	f04f 0300 	mov.w	r3, #0
 8018f2c:	e08b      	b.n	8019046 <inet_aton+0x26a>
      *pp++ = val;
 8018f2e:	69fb      	ldr	r3, [r7, #28]
 8018f30:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018f32:	601a      	str	r2, [r3, #0]
 8018f34:	69fb      	ldr	r3, [r7, #28]
 8018f36:	f103 0304 	add.w	r3, r3, #4
 8018f3a:	61fb      	str	r3, [r7, #28]
      c = *++cp;
 8018f3c:	687b      	ldr	r3, [r7, #4]
 8018f3e:	f103 0301 	add.w	r3, r3, #1
 8018f42:	607b      	str	r3, [r7, #4]
 8018f44:	687b      	ldr	r3, [r7, #4]
 8018f46:	781b      	ldrb	r3, [r3, #0]
 8018f48:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    } else
      break;
  }
 8018f4c:	e752      	b.n	8018df4 <inet_aton+0x18>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
 8018f4e:	bf00      	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c))
 8018f50:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f54:	2b00      	cmp	r3, #0
 8018f56:	d01a      	beq.n	8018f8e <inet_aton+0x1b2>
 8018f58:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f5c:	2b20      	cmp	r3, #32
 8018f5e:	d016      	beq.n	8018f8e <inet_aton+0x1b2>
 8018f60:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f64:	2b0c      	cmp	r3, #12
 8018f66:	d012      	beq.n	8018f8e <inet_aton+0x1b2>
 8018f68:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f6c:	2b0a      	cmp	r3, #10
 8018f6e:	d00e      	beq.n	8018f8e <inet_aton+0x1b2>
 8018f70:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f74:	2b0d      	cmp	r3, #13
 8018f76:	d00a      	beq.n	8018f8e <inet_aton+0x1b2>
 8018f78:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f7c:	2b09      	cmp	r3, #9
 8018f7e:	d006      	beq.n	8018f8e <inet_aton+0x1b2>
 8018f80:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8018f84:	2b0b      	cmp	r3, #11
 8018f86:	d002      	beq.n	8018f8e <inet_aton+0x1b2>
    return (0);
 8018f88:	f04f 0300 	mov.w	r3, #0
 8018f8c:	e05b      	b.n	8019046 <inet_aton+0x26a>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 8018f8e:	69fa      	ldr	r2, [r7, #28]
 8018f90:	f107 030c 	add.w	r3, r7, #12
 8018f94:	1ad3      	subs	r3, r2, r3
 8018f96:	ea4f 03a3 	mov.w	r3, r3, asr #2
 8018f9a:	f103 0301 	add.w	r3, r3, #1
 8018f9e:	2b04      	cmp	r3, #4
 8018fa0:	d846      	bhi.n	8019030 <inet_aton+0x254>
 8018fa2:	a201      	add	r2, pc, #4	; (adr r2, 8018fa8 <inet_aton+0x1cc>)
 8018fa4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018fa8:	08018fbd 	.word	0x08018fbd
 8018fac:	08019031 	.word	0x08019031
 8018fb0:	08018fc3 	.word	0x08018fc3
 8018fb4:	08018fe1 	.word	0x08018fe1
 8018fb8:	08019007 	.word	0x08019007

  case 0:
    return (0);       /* initial nondigit */
 8018fbc:	f04f 0300 	mov.w	r3, #0
 8018fc0:	e041      	b.n	8019046 <inet_aton+0x26a>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
 8018fc2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018fc4:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8018fc8:	429a      	cmp	r2, r3
 8018fca:	d902      	bls.n	8018fd2 <inet_aton+0x1f6>
      return (0);
 8018fcc:	f04f 0300 	mov.w	r3, #0
 8018fd0:	e039      	b.n	8019046 <inet_aton+0x26a>
    val |= parts[0] << 24;
 8018fd2:	68fb      	ldr	r3, [r7, #12]
 8018fd4:	ea4f 6303 	mov.w	r3, r3, lsl #24
 8018fd8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018fda:	4313      	orrs	r3, r2
 8018fdc:	627b      	str	r3, [r7, #36]	; 0x24
    break;
 8018fde:	e027      	b.n	8019030 <inet_aton+0x254>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
 8018fe0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8018fe2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8018fe6:	429a      	cmp	r2, r3
 8018fe8:	d902      	bls.n	8018ff0 <inet_aton+0x214>
      return (0);
 8018fea:	f04f 0300 	mov.w	r3, #0
 8018fee:	e02a      	b.n	8019046 <inet_aton+0x26a>
    val |= (parts[0] << 24) | (parts[1] << 16);
 8018ff0:	68fb      	ldr	r3, [r7, #12]
 8018ff2:	ea4f 6203 	mov.w	r2, r3, lsl #24
 8018ff6:	693b      	ldr	r3, [r7, #16]
 8018ff8:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8018ffc:	4313      	orrs	r3, r2
 8018ffe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8019000:	4313      	orrs	r3, r2
 8019002:	627b      	str	r3, [r7, #36]	; 0x24
    break;
 8019004:	e014      	b.n	8019030 <inet_aton+0x254>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
 8019006:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019008:	2bff      	cmp	r3, #255	; 0xff
 801900a:	d902      	bls.n	8019012 <inet_aton+0x236>
      return (0);
 801900c:	f04f 0300 	mov.w	r3, #0
 8019010:	e019      	b.n	8019046 <inet_aton+0x26a>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 8019012:	68fb      	ldr	r3, [r7, #12]
 8019014:	ea4f 6203 	mov.w	r2, r3, lsl #24
 8019018:	693b      	ldr	r3, [r7, #16]
 801901a:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801901e:	431a      	orrs	r2, r3
 8019020:	697b      	ldr	r3, [r7, #20]
 8019022:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8019026:	4313      	orrs	r3, r2
 8019028:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801902a:	4313      	orrs	r3, r2
 801902c:	627b      	str	r3, [r7, #36]	; 0x24
    break;
 801902e:	bf00      	nop
  }
  if (addr)
 8019030:	683b      	ldr	r3, [r7, #0]
 8019032:	2b00      	cmp	r3, #0
 8019034:	d005      	beq.n	8019042 <inet_aton+0x266>
    addr->s_addr = htonl(val);
 8019036:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8019038:	f000 f8b6 	bl	80191a8 <htonl>
 801903c:	4602      	mov	r2, r0
 801903e:	683b      	ldr	r3, [r7, #0]
 8019040:	601a      	str	r2, [r3, #0]
  return (1);
 8019042:	f04f 0301 	mov.w	r3, #1
}
 8019046:	4618      	mov	r0, r3
 8019048:	f107 0728 	add.w	r7, r7, #40	; 0x28
 801904c:	46bd      	mov	sp, r7
 801904e:	bd80      	pop	{r7, pc}

08019050 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
 8019050:	b480      	push	{r7}
 8019052:	b089      	sub	sp, #36	; 0x24
 8019054:	af00      	add	r7, sp, #0
 8019056:	6078      	str	r0, [r7, #4]
  static char str[16];
  u32_t s_addr = addr.s_addr;
 8019058:	687b      	ldr	r3, [r7, #4]
 801905a:	613b      	str	r3, [r7, #16]
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
 801905c:	f245 5398 	movw	r3, #21912	; 0x5598
 8019060:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019064:	61fb      	str	r3, [r7, #28]
  ap = (u8_t *)&s_addr;
 8019066:	f107 0310 	add.w	r3, r7, #16
 801906a:	61bb      	str	r3, [r7, #24]
  for(n = 0; n < 4; n++) {
 801906c:	f04f 0300 	mov.w	r3, #0
 8019070:	75fb      	strb	r3, [r7, #23]
 8019072:	e05c      	b.n	801912e <inet_ntoa+0xde>
    i = 0;
 8019074:	f04f 0300 	mov.w	r3, #0
 8019078:	75bb      	strb	r3, [r7, #22]
    do {
      rem = *ap % (u8_t)10;
 801907a:	69bb      	ldr	r3, [r7, #24]
 801907c:	781a      	ldrb	r2, [r3, #0]
 801907e:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8019082:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 8019086:	fba3 1302 	umull	r1, r3, r3, r2
 801908a:	ea4f 01d3 	mov.w	r1, r3, lsr #3
 801908e:	460b      	mov	r3, r1
 8019090:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8019094:	185b      	adds	r3, r3, r1
 8019096:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801909a:	1ad3      	subs	r3, r2, r3
 801909c:	757b      	strb	r3, [r7, #21]
      *ap /= (u8_t)10;
 801909e:	69bb      	ldr	r3, [r7, #24]
 80190a0:	781a      	ldrb	r2, [r3, #0]
 80190a2:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 80190a6:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 80190aa:	fba3 1302 	umull	r1, r3, r3, r2
 80190ae:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80190b2:	b2da      	uxtb	r2, r3
 80190b4:	69bb      	ldr	r3, [r7, #24]
 80190b6:	701a      	strb	r2, [r3, #0]
      inv[i++] = '0' + rem;
 80190b8:	7dbb      	ldrb	r3, [r7, #22]
 80190ba:	7d7a      	ldrb	r2, [r7, #21]
 80190bc:	f102 0230 	add.w	r2, r2, #48	; 0x30
 80190c0:	b2d2      	uxtb	r2, r2
 80190c2:	f107 0120 	add.w	r1, r7, #32
 80190c6:	18cb      	adds	r3, r1, r3
 80190c8:	f803 2c14 	strb.w	r2, [r3, #-20]
 80190cc:	7dbb      	ldrb	r3, [r7, #22]
 80190ce:	f103 0301 	add.w	r3, r3, #1
 80190d2:	75bb      	strb	r3, [r7, #22]
    } while(*ap);
 80190d4:	69bb      	ldr	r3, [r7, #24]
 80190d6:	781b      	ldrb	r3, [r3, #0]
 80190d8:	2b00      	cmp	r3, #0
 80190da:	d1ce      	bne.n	801907a <inet_ntoa+0x2a>
    while(i--)
 80190dc:	e00b      	b.n	80190f6 <inet_ntoa+0xa6>
      *rp++ = inv[i];
 80190de:	7dbb      	ldrb	r3, [r7, #22]
 80190e0:	f107 0220 	add.w	r2, r7, #32
 80190e4:	18d3      	adds	r3, r2, r3
 80190e6:	f813 2c14 	ldrb.w	r2, [r3, #-20]
 80190ea:	69fb      	ldr	r3, [r7, #28]
 80190ec:	701a      	strb	r2, [r3, #0]
 80190ee:	69fb      	ldr	r3, [r7, #28]
 80190f0:	f103 0301 	add.w	r3, r3, #1
 80190f4:	61fb      	str	r3, [r7, #28]
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
 80190f6:	7dbb      	ldrb	r3, [r7, #22]
 80190f8:	2b00      	cmp	r3, #0
 80190fa:	bf0c      	ite	eq
 80190fc:	2300      	moveq	r3, #0
 80190fe:	2301      	movne	r3, #1
 8019100:	b2db      	uxtb	r3, r3
 8019102:	7dba      	ldrb	r2, [r7, #22]
 8019104:	f102 32ff 	add.w	r2, r2, #4294967295
 8019108:	75ba      	strb	r2, [r7, #22]
 801910a:	2b00      	cmp	r3, #0
 801910c:	d1e7      	bne.n	80190de <inet_ntoa+0x8e>
      *rp++ = inv[i];
    *rp++ = '.';
 801910e:	69fb      	ldr	r3, [r7, #28]
 8019110:	f04f 022e 	mov.w	r2, #46	; 0x2e
 8019114:	701a      	strb	r2, [r3, #0]
 8019116:	69fb      	ldr	r3, [r7, #28]
 8019118:	f103 0301 	add.w	r3, r3, #1
 801911c:	61fb      	str	r3, [r7, #28]
    ap++;
 801911e:	69bb      	ldr	r3, [r7, #24]
 8019120:	f103 0301 	add.w	r3, r3, #1
 8019124:	61bb      	str	r3, [r7, #24]
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
 8019126:	7dfb      	ldrb	r3, [r7, #23]
 8019128:	f103 0301 	add.w	r3, r3, #1
 801912c:	75fb      	strb	r3, [r7, #23]
 801912e:	7dfb      	ldrb	r3, [r7, #23]
 8019130:	2b03      	cmp	r3, #3
 8019132:	d99f      	bls.n	8019074 <inet_ntoa+0x24>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
 8019134:	69fb      	ldr	r3, [r7, #28]
 8019136:	f103 33ff 	add.w	r3, r3, #4294967295
 801913a:	61fb      	str	r3, [r7, #28]
 801913c:	69fb      	ldr	r3, [r7, #28]
 801913e:	f04f 0200 	mov.w	r2, #0
 8019142:	701a      	strb	r2, [r3, #0]
  return str;
 8019144:	f245 5398 	movw	r3, #21912	; 0x5598
 8019148:	f2c2 0300 	movt	r3, #8192	; 0x2000
}
 801914c:	4618      	mov	r0, r3
 801914e:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8019152:	46bd      	mov	sp, r7
 8019154:	bc80      	pop	{r7}
 8019156:	4770      	bx	lr

08019158 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
 8019158:	b480      	push	{r7}
 801915a:	b083      	sub	sp, #12
 801915c:	af00      	add	r7, sp, #0
 801915e:	4603      	mov	r3, r0
 8019160:	80fb      	strh	r3, [r7, #6]
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
 8019162:	88fb      	ldrh	r3, [r7, #6]
 8019164:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8019168:	b29a      	uxth	r2, r3
 801916a:	88fb      	ldrh	r3, [r7, #6]
 801916c:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8019170:	b29b      	uxth	r3, r3
 8019172:	b29b      	uxth	r3, r3
 8019174:	4313      	orrs	r3, r2
 8019176:	b29b      	uxth	r3, r3
 8019178:	b29b      	uxth	r3, r3
}
 801917a:	4618      	mov	r0, r3
 801917c:	f107 070c 	add.w	r7, r7, #12
 8019180:	46bd      	mov	sp, r7
 8019182:	bc80      	pop	{r7}
 8019184:	4770      	bx	lr
 8019186:	bf00      	nop

08019188 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
 8019188:	b580      	push	{r7, lr}
 801918a:	b082      	sub	sp, #8
 801918c:	af00      	add	r7, sp, #0
 801918e:	4603      	mov	r3, r0
 8019190:	80fb      	strh	r3, [r7, #6]
  return htons(n);
 8019192:	88fb      	ldrh	r3, [r7, #6]
 8019194:	4618      	mov	r0, r3
 8019196:	f7ff ffdf 	bl	8019158 <htons>
 801919a:	4603      	mov	r3, r0
}
 801919c:	4618      	mov	r0, r3
 801919e:	f107 0708 	add.w	r7, r7, #8
 80191a2:	46bd      	mov	sp, r7
 80191a4:	bd80      	pop	{r7, pc}
 80191a6:	bf00      	nop

080191a8 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
 80191a8:	b480      	push	{r7}
 80191aa:	b083      	sub	sp, #12
 80191ac:	af00      	add	r7, sp, #0
 80191ae:	6078      	str	r0, [r7, #4]
  return ((n & 0xff) << 24) |
 80191b0:	687b      	ldr	r3, [r7, #4]
 80191b2:	ea4f 6203 	mov.w	r2, r3, lsl #24
    ((n & 0xff00) << 8) |
 80191b6:	687b      	ldr	r3, [r7, #4]
 80191b8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80191bc:	ea4f 2303 	mov.w	r3, r3, lsl #8
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
 80191c0:	431a      	orrs	r2, r3
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
 80191c2:	687b      	ldr	r3, [r7, #4]
 80191c4:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 80191c8:	ea4f 2313 	mov.w	r3, r3, lsr #8
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
 80191cc:	431a      	orrs	r2, r3
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
 80191ce:	687b      	ldr	r3, [r7, #4]
 80191d0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
 80191d4:	4313      	orrs	r3, r2
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
 80191d6:	4618      	mov	r0, r3
 80191d8:	f107 070c 	add.w	r7, r7, #12
 80191dc:	46bd      	mov	sp, r7
 80191de:	bc80      	pop	{r7}
 80191e0:	4770      	bx	lr
 80191e2:	bf00      	nop

080191e4 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
 80191e4:	b580      	push	{r7, lr}
 80191e6:	b082      	sub	sp, #8
 80191e8:	af00      	add	r7, sp, #0
 80191ea:	6078      	str	r0, [r7, #4]
  return htonl(n);
 80191ec:	6878      	ldr	r0, [r7, #4]
 80191ee:	f7ff ffdb 	bl	80191a8 <htonl>
 80191f2:	4603      	mov	r3, r0
}
 80191f4:	4618      	mov	r0, r3
 80191f6:	f107 0708 	add.w	r7, r7, #8
 80191fa:	46bd      	mov	sp, r7
 80191fc:	bd80      	pop	{r7, pc}
 80191fe:	bf00      	nop

08019200 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
 8019200:	b580      	push	{r7, lr}
 8019202:	b086      	sub	sp, #24
 8019204:	af00      	add	r7, sp, #0
 8019206:	6078      	str	r0, [r7, #4]
 8019208:	460b      	mov	r3, r1
 801920a:	807b      	strh	r3, [r7, #2]
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
 801920c:	f04f 0300 	mov.w	r3, #0
 8019210:	617b      	str	r3, [r7, #20]
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
 8019212:	687b      	ldr	r3, [r7, #4]
 8019214:	613b      	str	r3, [r7, #16]
  while (len > 1) {
 8019216:	e01a      	b.n	801924e <lwip_standard_chksum+0x4e>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
 8019218:	693b      	ldr	r3, [r7, #16]
 801921a:	781b      	ldrb	r3, [r3, #0]
 801921c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8019220:	81fb      	strh	r3, [r7, #14]
    octetptr++;
 8019222:	693b      	ldr	r3, [r7, #16]
 8019224:	f103 0301 	add.w	r3, r3, #1
 8019228:	613b      	str	r3, [r7, #16]
    /* declare second octet as least significant */
    src |= (*octetptr);
 801922a:	693b      	ldr	r3, [r7, #16]
 801922c:	781b      	ldrb	r3, [r3, #0]
 801922e:	461a      	mov	r2, r3
 8019230:	89fb      	ldrh	r3, [r7, #14]
 8019232:	4313      	orrs	r3, r2
 8019234:	81fb      	strh	r3, [r7, #14]
    octetptr++;
 8019236:	693b      	ldr	r3, [r7, #16]
 8019238:	f103 0301 	add.w	r3, r3, #1
 801923c:	613b      	str	r3, [r7, #16]
    acc += src;
 801923e:	89fb      	ldrh	r3, [r7, #14]
 8019240:	697a      	ldr	r2, [r7, #20]
 8019242:	18d3      	adds	r3, r2, r3
 8019244:	617b      	str	r3, [r7, #20]
    len -= 2;
 8019246:	887b      	ldrh	r3, [r7, #2]
 8019248:	f1a3 0302 	sub.w	r3, r3, #2
 801924c:	807b      	strh	r3, [r7, #2]
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
 801924e:	887b      	ldrh	r3, [r7, #2]
 8019250:	2b01      	cmp	r3, #1
 8019252:	d8e1      	bhi.n	8019218 <lwip_standard_chksum+0x18>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
 8019254:	887b      	ldrh	r3, [r7, #2]
 8019256:	2b00      	cmp	r3, #0
 8019258:	d008      	beq.n	801926c <lwip_standard_chksum+0x6c>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
 801925a:	693b      	ldr	r3, [r7, #16]
 801925c:	781b      	ldrb	r3, [r3, #0]
 801925e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8019262:	81fb      	strh	r3, [r7, #14]
    acc += src;
 8019264:	89fb      	ldrh	r3, [r7, #14]
 8019266:	697a      	ldr	r2, [r7, #20]
 8019268:	18d3      	adds	r3, r2, r3
 801926a:	617b      	str	r3, [r7, #20]
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
 801926c:	697b      	ldr	r3, [r7, #20]
 801926e:	ea4f 4213 	mov.w	r2, r3, lsr #16
 8019272:	697b      	ldr	r3, [r7, #20]
 8019274:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8019278:	ea4f 4313 	mov.w	r3, r3, lsr #16
 801927c:	18d3      	adds	r3, r2, r3
 801927e:	617b      	str	r3, [r7, #20]
  if ((acc & 0xffff0000UL) != 0) {
 8019280:	697b      	ldr	r3, [r7, #20]
 8019282:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8019286:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801928a:	2b00      	cmp	r3, #0
 801928c:	d009      	beq.n	80192a2 <lwip_standard_chksum+0xa2>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
 801928e:	697b      	ldr	r3, [r7, #20]
 8019290:	ea4f 4213 	mov.w	r2, r3, lsr #16
 8019294:	697b      	ldr	r3, [r7, #20]
 8019296:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801929a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 801929e:	18d3      	adds	r3, r2, r3
 80192a0:	617b      	str	r3, [r7, #20]
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
 80192a2:	697b      	ldr	r3, [r7, #20]
 80192a4:	b29b      	uxth	r3, r3
 80192a6:	4618      	mov	r0, r3
 80192a8:	f7ff ff56 	bl	8019158 <htons>
 80192ac:	4603      	mov	r3, r0
}
 80192ae:	4618      	mov	r0, r3
 80192b0:	f107 0718 	add.w	r7, r7, #24
 80192b4:	46bd      	mov	sp, r7
 80192b6:	bd80      	pop	{r7, pc}

080192b8 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
 80192b8:	b580      	push	{r7, lr}
 80192ba:	b088      	sub	sp, #32
 80192bc:	af00      	add	r7, sp, #0
 80192be:	60f8      	str	r0, [r7, #12]
 80192c0:	60b9      	str	r1, [r7, #8]
 80192c2:	607a      	str	r2, [r7, #4]
 80192c4:	70fb      	strb	r3, [r7, #3]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 80192c6:	f04f 0300 	mov.w	r3, #0
 80192ca:	61fb      	str	r3, [r7, #28]
  swapped = 0;
 80192cc:	f04f 0300 	mov.w	r3, #0
 80192d0:	75fb      	strb	r3, [r7, #23]
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 80192d2:	68fb      	ldr	r3, [r7, #12]
 80192d4:	61bb      	str	r3, [r7, #24]
 80192d6:	e031      	b.n	801933c <inet_chksum_pseudo+0x84>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 80192d8:	69bb      	ldr	r3, [r7, #24]
 80192da:	685a      	ldr	r2, [r3, #4]
 80192dc:	69bb      	ldr	r3, [r7, #24]
 80192de:	895b      	ldrh	r3, [r3, #10]
 80192e0:	4610      	mov	r0, r2
 80192e2:	4619      	mov	r1, r3
 80192e4:	f7ff ff8c 	bl	8019200 <lwip_standard_chksum>
 80192e8:	4603      	mov	r3, r0
 80192ea:	69fa      	ldr	r2, [r7, #28]
 80192ec:	18d3      	adds	r3, r2, r3
 80192ee:	61fb      	str	r3, [r7, #28]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 80192f0:	69fb      	ldr	r3, [r7, #28]
 80192f2:	ea4f 4213 	mov.w	r2, r3, lsr #16
 80192f6:	69fb      	ldr	r3, [r7, #28]
 80192f8:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80192fc:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8019300:	18d3      	adds	r3, r2, r3
 8019302:	61fb      	str	r3, [r7, #28]
    if (q->len % 2 != 0) {
 8019304:	69bb      	ldr	r3, [r7, #24]
 8019306:	895b      	ldrh	r3, [r3, #10]
 8019308:	f003 0301 	and.w	r3, r3, #1
 801930c:	b29b      	uxth	r3, r3
 801930e:	2b00      	cmp	r3, #0
 8019310:	d011      	beq.n	8019336 <inet_chksum_pseudo+0x7e>
      swapped = 1 - swapped;
 8019312:	7dfb      	ldrb	r3, [r7, #23]
 8019314:	f1c3 0301 	rsb	r3, r3, #1
 8019318:	75fb      	strb	r3, [r7, #23]
      acc = SWAP_BYTES_IN_WORD(acc);
 801931a:	69fb      	ldr	r3, [r7, #28]
 801931c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8019320:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8019324:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8019328:	69fa      	ldr	r2, [r7, #28]
 801932a:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 801932e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8019332:	4313      	orrs	r3, r2
 8019334:	61fb      	str	r3, [r7, #28]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 8019336:	69bb      	ldr	r3, [r7, #24]
 8019338:	681b      	ldr	r3, [r3, #0]
 801933a:	61bb      	str	r3, [r7, #24]
 801933c:	69bb      	ldr	r3, [r7, #24]
 801933e:	2b00      	cmp	r3, #0
 8019340:	d1ca      	bne.n	80192d8 <inet_chksum_pseudo+0x20>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8019342:	7dfb      	ldrb	r3, [r7, #23]
 8019344:	2b00      	cmp	r3, #0
 8019346:	d00d      	beq.n	8019364 <inet_chksum_pseudo+0xac>
    acc = SWAP_BYTES_IN_WORD(acc);
 8019348:	69fb      	ldr	r3, [r7, #28]
 801934a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801934e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8019352:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8019356:	69fa      	ldr	r2, [r7, #28]
 8019358:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 801935c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8019360:	4313      	orrs	r3, r2
 8019362:	61fb      	str	r3, [r7, #28]
  }
  acc += (src->addr & 0xffffUL);
 8019364:	68bb      	ldr	r3, [r7, #8]
 8019366:	681b      	ldr	r3, [r3, #0]
 8019368:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801936c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8019370:	69fa      	ldr	r2, [r7, #28]
 8019372:	18d3      	adds	r3, r2, r3
 8019374:	61fb      	str	r3, [r7, #28]
  acc += ((src->addr >> 16) & 0xffffUL);
 8019376:	68bb      	ldr	r3, [r7, #8]
 8019378:	681b      	ldr	r3, [r3, #0]
 801937a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 801937e:	69fa      	ldr	r2, [r7, #28]
 8019380:	18d3      	adds	r3, r2, r3
 8019382:	61fb      	str	r3, [r7, #28]
  acc += (dest->addr & 0xffffUL);
 8019384:	687b      	ldr	r3, [r7, #4]
 8019386:	681b      	ldr	r3, [r3, #0]
 8019388:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801938c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8019390:	69fa      	ldr	r2, [r7, #28]
 8019392:	18d3      	adds	r3, r2, r3
 8019394:	61fb      	str	r3, [r7, #28]
  acc += ((dest->addr >> 16) & 0xffffUL);
 8019396:	687b      	ldr	r3, [r7, #4]
 8019398:	681b      	ldr	r3, [r3, #0]
 801939a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 801939e:	69fa      	ldr	r2, [r7, #28]
 80193a0:	18d3      	adds	r3, r2, r3
 80193a2:	61fb      	str	r3, [r7, #28]
  acc += (u32_t)htons((u16_t)proto);
 80193a4:	78fb      	ldrb	r3, [r7, #3]
 80193a6:	b29b      	uxth	r3, r3
 80193a8:	4618      	mov	r0, r3
 80193aa:	f7ff fed5 	bl	8019158 <htons>
 80193ae:	4603      	mov	r3, r0
 80193b0:	69fa      	ldr	r2, [r7, #28]
 80193b2:	18d3      	adds	r3, r2, r3
 80193b4:	61fb      	str	r3, [r7, #28]
  acc += (u32_t)htons(proto_len);
 80193b6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80193b8:	4618      	mov	r0, r3
 80193ba:	f7ff fecd 	bl	8019158 <htons>
 80193be:	4603      	mov	r3, r0
 80193c0:	69fa      	ldr	r2, [r7, #28]
 80193c2:	18d3      	adds	r3, r2, r3
 80193c4:	61fb      	str	r3, [r7, #28]

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 80193c6:	69fb      	ldr	r3, [r7, #28]
 80193c8:	ea4f 4213 	mov.w	r2, r3, lsr #16
 80193cc:	69fb      	ldr	r3, [r7, #28]
 80193ce:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80193d2:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80193d6:	18d3      	adds	r3, r2, r3
 80193d8:	61fb      	str	r3, [r7, #28]
  acc = FOLD_U32T(acc);
 80193da:	69fb      	ldr	r3, [r7, #28]
 80193dc:	ea4f 4213 	mov.w	r2, r3, lsr #16
 80193e0:	69fb      	ldr	r3, [r7, #28]
 80193e2:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80193e6:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80193ea:	18d3      	adds	r3, r2, r3
 80193ec:	61fb      	str	r3, [r7, #28]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 80193ee:	69fb      	ldr	r3, [r7, #28]
 80193f0:	b29b      	uxth	r3, r3
 80193f2:	ea6f 0303 	mvn.w	r3, r3
 80193f6:	b29b      	uxth	r3, r3
}
 80193f8:	4618      	mov	r0, r3
 80193fa:	f107 0720 	add.w	r7, r7, #32
 80193fe:	46bd      	mov	sp, r7
 8019400:	bd80      	pop	{r7, pc}
 8019402:	bf00      	nop

08019404 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 8019404:	b580      	push	{r7, lr}
 8019406:	b082      	sub	sp, #8
 8019408:	af00      	add	r7, sp, #0
 801940a:	6078      	str	r0, [r7, #4]
 801940c:	460b      	mov	r3, r1
 801940e:	807b      	strh	r3, [r7, #2]
  return ~LWIP_CHKSUM(dataptr, len);
 8019410:	887b      	ldrh	r3, [r7, #2]
 8019412:	6878      	ldr	r0, [r7, #4]
 8019414:	4619      	mov	r1, r3
 8019416:	f7ff fef3 	bl	8019200 <lwip_standard_chksum>
 801941a:	4603      	mov	r3, r0
 801941c:	ea6f 0303 	mvn.w	r3, r3
 8019420:	b29b      	uxth	r3, r3
}
 8019422:	4618      	mov	r0, r3
 8019424:	f107 0708 	add.w	r7, r7, #8
 8019428:	46bd      	mov	sp, r7
 801942a:	bd80      	pop	{r7, pc}

0801942c <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 801942c:	b580      	push	{r7, lr}
 801942e:	b086      	sub	sp, #24
 8019430:	af00      	add	r7, sp, #0
 8019432:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 8019434:	f04f 0300 	mov.w	r3, #0
 8019438:	617b      	str	r3, [r7, #20]
  swapped = 0;
 801943a:	f04f 0300 	mov.w	r3, #0
 801943e:	73fb      	strb	r3, [r7, #15]
  for(q = p; q != NULL; q = q->next) {
 8019440:	687b      	ldr	r3, [r7, #4]
 8019442:	613b      	str	r3, [r7, #16]
 8019444:	e031      	b.n	80194aa <inet_chksum_pbuf+0x7e>
    acc += LWIP_CHKSUM(q->payload, q->len);
 8019446:	693b      	ldr	r3, [r7, #16]
 8019448:	685a      	ldr	r2, [r3, #4]
 801944a:	693b      	ldr	r3, [r7, #16]
 801944c:	895b      	ldrh	r3, [r3, #10]
 801944e:	4610      	mov	r0, r2
 8019450:	4619      	mov	r1, r3
 8019452:	f7ff fed5 	bl	8019200 <lwip_standard_chksum>
 8019456:	4603      	mov	r3, r0
 8019458:	697a      	ldr	r2, [r7, #20]
 801945a:	18d3      	adds	r3, r2, r3
 801945c:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 801945e:	697b      	ldr	r3, [r7, #20]
 8019460:	ea4f 4213 	mov.w	r2, r3, lsr #16
 8019464:	697b      	ldr	r3, [r7, #20]
 8019466:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801946a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 801946e:	18d3      	adds	r3, r2, r3
 8019470:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 8019472:	693b      	ldr	r3, [r7, #16]
 8019474:	895b      	ldrh	r3, [r3, #10]
 8019476:	f003 0301 	and.w	r3, r3, #1
 801947a:	b29b      	uxth	r3, r3
 801947c:	2b00      	cmp	r3, #0
 801947e:	d011      	beq.n	80194a4 <inet_chksum_pbuf+0x78>
      swapped = 1 - swapped;
 8019480:	7bfb      	ldrb	r3, [r7, #15]
 8019482:	f1c3 0301 	rsb	r3, r3, #1
 8019486:	73fb      	strb	r3, [r7, #15]
      acc = SWAP_BYTES_IN_WORD(acc);
 8019488:	697b      	ldr	r3, [r7, #20]
 801948a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801948e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8019492:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8019496:	697a      	ldr	r2, [r7, #20]
 8019498:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 801949c:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80194a0:	4313      	orrs	r3, r2
 80194a2:	617b      	str	r3, [r7, #20]
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 80194a4:	693b      	ldr	r3, [r7, #16]
 80194a6:	681b      	ldr	r3, [r3, #0]
 80194a8:	613b      	str	r3, [r7, #16]
 80194aa:	693b      	ldr	r3, [r7, #16]
 80194ac:	2b00      	cmp	r3, #0
 80194ae:	d1ca      	bne.n	8019446 <inet_chksum_pbuf+0x1a>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 80194b0:	7bfb      	ldrb	r3, [r7, #15]
 80194b2:	2b00      	cmp	r3, #0
 80194b4:	d00d      	beq.n	80194d2 <inet_chksum_pbuf+0xa6>
    acc = SWAP_BYTES_IN_WORD(acc);
 80194b6:	697b      	ldr	r3, [r7, #20]
 80194b8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80194bc:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80194c0:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80194c4:	697a      	ldr	r2, [r7, #20]
 80194c6:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 80194ca:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80194ce:	4313      	orrs	r3, r2
 80194d0:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 80194d2:	697b      	ldr	r3, [r7, #20]
 80194d4:	b29b      	uxth	r3, r3
 80194d6:	ea6f 0303 	mvn.w	r3, r3
 80194da:	b29b      	uxth	r3, r3
}
 80194dc:	4618      	mov	r0, r3
 80194de:	f107 0718 	add.w	r7, r7, #24
 80194e2:	46bd      	mov	sp, r7
 80194e4:	bd80      	pop	{r7, pc}
 80194e6:	bf00      	nop

080194e8 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
 80194e8:	b580      	push	{r7, lr}
 80194ea:	b084      	sub	sp, #16
 80194ec:	af00      	add	r7, sp, #0
 80194ee:	6078      	str	r0, [r7, #4]
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
 80194f0:	f246 534c 	movw	r3, #25932	; 0x654c
 80194f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80194f8:	681b      	ldr	r3, [r3, #0]
 80194fa:	60fb      	str	r3, [r7, #12]
 80194fc:	e014      	b.n	8019528 <ip_route+0x40>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 80194fe:	68f8      	ldr	r0, [r7, #12]
 8019500:	f7f9 fac2 	bl	8012a88 <netif_is_up>
 8019504:	4603      	mov	r3, r0
 8019506:	2b00      	cmp	r3, #0
 8019508:	d00b      	beq.n	8019522 <ip_route+0x3a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 801950a:	687b      	ldr	r3, [r7, #4]
 801950c:	681a      	ldr	r2, [r3, #0]
 801950e:	68fb      	ldr	r3, [r7, #12]
 8019510:	685b      	ldr	r3, [r3, #4]
 8019512:	405a      	eors	r2, r3
 8019514:	68fb      	ldr	r3, [r7, #12]
 8019516:	689b      	ldr	r3, [r3, #8]
 8019518:	4013      	ands	r3, r2
 801951a:	2b00      	cmp	r3, #0
 801951c:	d101      	bne.n	8019522 <ip_route+0x3a>
        /* return netif on which to forward IP packet */
        return netif;
 801951e:	68fb      	ldr	r3, [r7, #12]
 8019520:	e01f      	b.n	8019562 <ip_route+0x7a>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
 8019522:	68fb      	ldr	r3, [r7, #12]
 8019524:	681b      	ldr	r3, [r3, #0]
 8019526:	60fb      	str	r3, [r7, #12]
 8019528:	68fb      	ldr	r3, [r7, #12]
 801952a:	2b00      	cmp	r3, #0
 801952c:	d1e7      	bne.n	80194fe <ip_route+0x16>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 801952e:	f246 5350 	movw	r3, #25936	; 0x6550
 8019532:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019536:	681b      	ldr	r3, [r3, #0]
 8019538:	2b00      	cmp	r3, #0
 801953a:	d00a      	beq.n	8019552 <ip_route+0x6a>
 801953c:	f246 5350 	movw	r3, #25936	; 0x6550
 8019540:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019544:	681b      	ldr	r3, [r3, #0]
 8019546:	4618      	mov	r0, r3
 8019548:	f7f9 fa9e 	bl	8012a88 <netif_is_up>
 801954c:	4603      	mov	r3, r0
 801954e:	2b00      	cmp	r3, #0
 8019550:	d102      	bne.n	8019558 <ip_route+0x70>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
 8019552:	f04f 0300 	mov.w	r3, #0
 8019556:	e004      	b.n	8019562 <ip_route+0x7a>
  }
  /* no matching netif found, use default netif */
  return netif_default;
 8019558:	f246 5350 	movw	r3, #25936	; 0x6550
 801955c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019560:	681b      	ldr	r3, [r3, #0]
}
 8019562:	4618      	mov	r0, r3
 8019564:	f107 0710 	add.w	r7, r7, #16
 8019568:	46bd      	mov	sp, r7
 801956a:	bd80      	pop	{r7, pc}

0801956c <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 801956c:	b590      	push	{r4, r7, lr}
 801956e:	b087      	sub	sp, #28
 8019570:	af00      	add	r7, sp, #0
 8019572:	6078      	str	r0, [r7, #4]
 8019574:	6039      	str	r1, [r7, #0]

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
 8019576:	687b      	ldr	r3, [r7, #4]
 8019578:	685b      	ldr	r3, [r3, #4]
 801957a:	617b      	str	r3, [r7, #20]
  if (IPH_V(iphdr) != 4) {
 801957c:	697b      	ldr	r3, [r7, #20]
 801957e:	881b      	ldrh	r3, [r3, #0]
 8019580:	b29b      	uxth	r3, r3
 8019582:	4618      	mov	r0, r3
 8019584:	f7ff fe00 	bl	8019188 <ntohs>
 8019588:	4603      	mov	r3, r0
 801958a:	ea4f 3313 	mov.w	r3, r3, lsr #12
 801958e:	b29b      	uxth	r3, r3
 8019590:	2b04      	cmp	r3, #4
 8019592:	d005      	beq.n	80195a0 <ip_input+0x34>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 8019594:	6878      	ldr	r0, [r7, #4]
 8019596:	f7f9 fc93 	bl	8012ec0 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
 801959a:	f04f 0300 	mov.w	r3, #0
 801959e:	e163      	b.n	8019868 <ip_input+0x2fc>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
 80195a0:	697b      	ldr	r3, [r7, #20]
 80195a2:	881b      	ldrh	r3, [r3, #0]
 80195a4:	b29b      	uxth	r3, r3
 80195a6:	4618      	mov	r0, r3
 80195a8:	f7ff fdee 	bl	8019188 <ntohs>
 80195ac:	4603      	mov	r3, r0
 80195ae:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80195b2:	b29b      	uxth	r3, r3
 80195b4:	f003 030f 	and.w	r3, r3, #15
 80195b8:	817b      	strh	r3, [r7, #10]
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
 80195ba:	897b      	ldrh	r3, [r7, #10]
 80195bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80195c0:	817b      	strh	r3, [r7, #10]
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 80195c2:	697b      	ldr	r3, [r7, #20]
 80195c4:	885b      	ldrh	r3, [r3, #2]
 80195c6:	b29b      	uxth	r3, r3
 80195c8:	4618      	mov	r0, r3
 80195ca:	f7ff fddd 	bl	8019188 <ntohs>
 80195ce:	4603      	mov	r3, r0
 80195d0:	813b      	strh	r3, [r7, #8]

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 80195d2:	687b      	ldr	r3, [r7, #4]
 80195d4:	895b      	ldrh	r3, [r3, #10]
 80195d6:	897a      	ldrh	r2, [r7, #10]
 80195d8:	429a      	cmp	r2, r3
 80195da:	d804      	bhi.n	80195e6 <ip_input+0x7a>
 80195dc:	687b      	ldr	r3, [r7, #4]
 80195de:	891b      	ldrh	r3, [r3, #8]
 80195e0:	893a      	ldrh	r2, [r7, #8]
 80195e2:	429a      	cmp	r2, r3
 80195e4:	d905      	bls.n	80195f2 <ip_input+0x86>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 80195e6:	6878      	ldr	r0, [r7, #4]
 80195e8:	f7f9 fc6a 	bl	8012ec0 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
 80195ec:	f04f 0300 	mov.w	r3, #0
 80195f0:	e13a      	b.n	8019868 <ip_input+0x2fc>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 80195f2:	893b      	ldrh	r3, [r7, #8]
 80195f4:	6878      	ldr	r0, [r7, #4]
 80195f6:	4619      	mov	r1, r3
 80195f8:	f7f9 fb82 	bl	8012d00 <pbuf_realloc>

  /* match packet against an interface, i.e. is this packet for us? */
#if LWIP_IGMP
  if (ip_addr_ismulticast(&(iphdr->dest))) {
 80195fc:	697b      	ldr	r3, [r7, #20]
 80195fe:	691c      	ldr	r4, [r3, #16]
 8019600:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 8019604:	f7ff fdee 	bl	80191e4 <ntohl>
 8019608:	4603      	mov	r3, r0
 801960a:	401c      	ands	r4, r3
 801960c:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8019610:	f7ff fde8 	bl	80191e4 <ntohl>
 8019614:	4603      	mov	r3, r0
 8019616:	429c      	cmp	r4, r3
 8019618:	d117      	bne.n	801964a <ip_input+0xde>
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, &(iphdr->dest)))) {
 801961a:	683b      	ldr	r3, [r7, #0]
 801961c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8019620:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8019624:	2b00      	cmp	r3, #0
 8019626:	d00c      	beq.n	8019642 <ip_input+0xd6>
 8019628:	697b      	ldr	r3, [r7, #20]
 801962a:	f103 0310 	add.w	r3, r3, #16
 801962e:	6838      	ldr	r0, [r7, #0]
 8019630:	4619      	mov	r1, r3
 8019632:	f7ff f80d 	bl	8018650 <igmp_lookfor_group>
 8019636:	4603      	mov	r3, r0
 8019638:	2b00      	cmp	r3, #0
 801963a:	d002      	beq.n	8019642 <ip_input+0xd6>
      netif = inp;
 801963c:	683b      	ldr	r3, [r7, #0]
 801963e:	613b      	str	r3, [r7, #16]
 8019640:	e041      	b.n	80196c6 <ip_input+0x15a>
    } else {
      netif = NULL;
 8019642:	f04f 0300 	mov.w	r3, #0
 8019646:	613b      	str	r3, [r7, #16]
 8019648:	e03d      	b.n	80196c6 <ip_input+0x15a>
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 801964a:	f04f 0301 	mov.w	r3, #1
 801964e:	60fb      	str	r3, [r7, #12]
    netif = inp;
 8019650:	683b      	ldr	r3, [r7, #0]
 8019652:	613b      	str	r3, [r7, #16]
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 8019654:	6938      	ldr	r0, [r7, #16]
 8019656:	f7f9 fa17 	bl	8012a88 <netif_is_up>
 801965a:	4603      	mov	r3, r0
 801965c:	2b00      	cmp	r3, #0
 801965e:	d018      	beq.n	8019692 <ip_input+0x126>
 8019660:	693b      	ldr	r3, [r7, #16]
 8019662:	f103 0304 	add.w	r3, r3, #4
 8019666:	2b00      	cmp	r3, #0
 8019668:	d013      	beq.n	8019692 <ip_input+0x126>
 801966a:	693b      	ldr	r3, [r7, #16]
 801966c:	685b      	ldr	r3, [r3, #4]
 801966e:	2b00      	cmp	r3, #0
 8019670:	d00f      	beq.n	8019692 <ip_input+0x126>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
 8019672:	697b      	ldr	r3, [r7, #20]
 8019674:	691a      	ldr	r2, [r3, #16]
 8019676:	693b      	ldr	r3, [r7, #16]
 8019678:	685b      	ldr	r3, [r3, #4]
 801967a:	429a      	cmp	r2, r3
 801967c:	d023      	beq.n	80196c6 <ip_input+0x15a>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
 801967e:	697b      	ldr	r3, [r7, #20]
 8019680:	f103 0310 	add.w	r3, r3, #16
 8019684:	4618      	mov	r0, r3
 8019686:	6939      	ldr	r1, [r7, #16]
 8019688:	f000 fa54 	bl	8019b34 <ip_addr_isbroadcast>
 801968c:	4603      	mov	r3, r0
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
 801968e:	2b00      	cmp	r3, #0
 8019690:	d119      	bne.n	80196c6 <ip_input+0x15a>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
 8019692:	68fb      	ldr	r3, [r7, #12]
 8019694:	2b00      	cmp	r3, #0
 8019696:	d009      	beq.n	80196ac <ip_input+0x140>
        first = 0;
 8019698:	f04f 0300 	mov.w	r3, #0
 801969c:	60fb      	str	r3, [r7, #12]
        netif = netif_list;
 801969e:	f246 534c 	movw	r3, #25932	; 0x654c
 80196a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80196a6:	681b      	ldr	r3, [r3, #0]
 80196a8:	613b      	str	r3, [r7, #16]
 80196aa:	e002      	b.n	80196b2 <ip_input+0x146>
      } else {
        netif = netif->next;
 80196ac:	693b      	ldr	r3, [r7, #16]
 80196ae:	681b      	ldr	r3, [r3, #0]
 80196b0:	613b      	str	r3, [r7, #16]
      }
      if (netif == inp) {
 80196b2:	693a      	ldr	r2, [r7, #16]
 80196b4:	683b      	ldr	r3, [r7, #0]
 80196b6:	429a      	cmp	r2, r3
 80196b8:	d102      	bne.n	80196c0 <ip_input+0x154>
        netif = netif->next;
 80196ba:	693b      	ldr	r3, [r7, #16]
 80196bc:	681b      	ldr	r3, [r3, #0]
 80196be:	613b      	str	r3, [r7, #16]
      }
    } while(netif != NULL);
 80196c0:	693b      	ldr	r3, [r7, #16]
 80196c2:	2b00      	cmp	r3, #0
 80196c4:	d1c6      	bne.n	8019654 <ip_input+0xe8>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && (iphdr->src.addr != 0))
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
 80196c6:	697b      	ldr	r3, [r7, #20]
 80196c8:	f103 030c 	add.w	r3, r3, #12
 80196cc:	4618      	mov	r0, r3
 80196ce:	6839      	ldr	r1, [r7, #0]
 80196d0:	f000 fa30 	bl	8019b34 <ip_addr_isbroadcast>
 80196d4:	4603      	mov	r3, r0
 80196d6:	2b00      	cmp	r3, #0
 80196d8:	d10e      	bne.n	80196f8 <ip_input+0x18c>
         (ip_addr_ismulticast(&(iphdr->src)))) {
 80196da:	697b      	ldr	r3, [r7, #20]
 80196dc:	68dc      	ldr	r4, [r3, #12]
 80196de:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 80196e2:	f7ff fd7f 	bl	80191e4 <ntohl>
 80196e6:	4603      	mov	r3, r0
 80196e8:	401c      	ands	r4, r3
 80196ea:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 80196ee:	f7ff fd79 	bl	80191e4 <ntohl>
 80196f2:	4603      	mov	r3, r0
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && (iphdr->src.addr != 0))
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
 80196f4:	429c      	cmp	r4, r3
 80196f6:	d105      	bne.n	8019704 <ip_input+0x198>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 80196f8:	6878      	ldr	r0, [r7, #4]
 80196fa:	f7f9 fbe1 	bl	8012ec0 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
 80196fe:	f04f 0300 	mov.w	r3, #0
 8019702:	e0b1      	b.n	8019868 <ip_input+0x2fc>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 8019704:	693b      	ldr	r3, [r7, #16]
 8019706:	2b00      	cmp	r3, #0
 8019708:	d105      	bne.n	8019716 <ip_input+0x1aa>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
 801970a:	6878      	ldr	r0, [r7, #4]
 801970c:	f7f9 fbd8 	bl	8012ec0 <pbuf_free>
    return ERR_OK;
 8019710:	f04f 0300 	mov.w	r3, #0
 8019714:	e0a8      	b.n	8019868 <ip_input+0x2fc>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
 8019716:	697b      	ldr	r3, [r7, #20]
 8019718:	88db      	ldrh	r3, [r3, #6]
 801971a:	b29c      	uxth	r4, r3
 801971c:	f643 70ff 	movw	r0, #16383	; 0x3fff
 8019720:	f7ff fd1a 	bl	8019158 <htons>
 8019724:	4603      	mov	r3, r0
 8019726:	4023      	ands	r3, r4
 8019728:	b29b      	uxth	r3, r3
 801972a:	2b00      	cmp	r3, #0
 801972c:	d00c      	beq.n	8019748 <ip_input+0x1dc>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 801972e:	6878      	ldr	r0, [r7, #4]
 8019730:	f000 fcca 	bl	801a0c8 <ip_reass>
 8019734:	6078      	str	r0, [r7, #4]
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 8019736:	687b      	ldr	r3, [r7, #4]
 8019738:	2b00      	cmp	r3, #0
 801973a:	d102      	bne.n	8019742 <ip_input+0x1d6>
      return ERR_OK;
 801973c:	f04f 0300 	mov.w	r3, #0
 8019740:	e092      	b.n	8019868 <ip_input+0x2fc>
    }
    iphdr = p->payload;
 8019742:	687b      	ldr	r3, [r7, #4]
 8019744:	685b      	ldr	r3, [r3, #4]
 8019746:	617b      	str	r3, [r7, #20]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 8019748:	f246 5374 	movw	r3, #25972	; 0x6574
 801974c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019750:	683a      	ldr	r2, [r7, #0]
 8019752:	601a      	str	r2, [r3, #0]
  current_header = iphdr;
 8019754:	f246 5378 	movw	r3, #25976	; 0x6578
 8019758:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801975c:	697a      	ldr	r2, [r7, #20]
 801975e:	601a      	str	r2, [r3, #0]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 8019760:	6878      	ldr	r0, [r7, #4]
 8019762:	6839      	ldr	r1, [r7, #0]
 8019764:	f7f9 fe0a 	bl	801337c <raw_input>
 8019768:	4603      	mov	r3, r0
 801976a:	2b00      	cmp	r3, #0
 801976c:	d16c      	bne.n	8019848 <ip_input+0x2dc>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
 801976e:	697b      	ldr	r3, [r7, #20]
 8019770:	891b      	ldrh	r3, [r3, #8]
 8019772:	b29b      	uxth	r3, r3
 8019774:	4618      	mov	r0, r3
 8019776:	f7ff fd07 	bl	8019188 <ntohs>
 801977a:	4603      	mov	r3, r0
 801977c:	b2db      	uxtb	r3, r3
 801977e:	f103 33ff 	add.w	r3, r3, #4294967295
 8019782:	2b10      	cmp	r3, #16
 8019784:	d83c      	bhi.n	8019800 <ip_input+0x294>
 8019786:	a201      	add	r2, pc, #4	; (adr r2, 801978c <ip_input+0x220>)
 8019788:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801978c:	080197e5 	.word	0x080197e5
 8019790:	080197ef 	.word	0x080197ef
 8019794:	08019801 	.word	0x08019801
 8019798:	08019801 	.word	0x08019801
 801979c:	08019801 	.word	0x08019801
 80197a0:	080197db 	.word	0x080197db
 80197a4:	08019801 	.word	0x08019801
 80197a8:	08019801 	.word	0x08019801
 80197ac:	08019801 	.word	0x08019801
 80197b0:	08019801 	.word	0x08019801
 80197b4:	08019801 	.word	0x08019801
 80197b8:	08019801 	.word	0x08019801
 80197bc:	08019801 	.word	0x08019801
 80197c0:	08019801 	.word	0x08019801
 80197c4:	08019801 	.word	0x08019801
 80197c8:	08019801 	.word	0x08019801
 80197cc:	080197d1 	.word	0x080197d1
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 80197d0:	6878      	ldr	r0, [r7, #4]
 80197d2:	6839      	ldr	r1, [r7, #0]
 80197d4:	f7fe f982 	bl	8017adc <udp_input>
      break;
 80197d8:	e036      	b.n	8019848 <ip_input+0x2dc>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 80197da:	6878      	ldr	r0, [r7, #4]
 80197dc:	6839      	ldr	r1, [r7, #0]
 80197de:	f7fb f993 	bl	8014b08 <tcp_input>
      break;
 80197e2:	e031      	b.n	8019848 <ip_input+0x2dc>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 80197e4:	6878      	ldr	r0, [r7, #4]
 80197e6:	6839      	ldr	r1, [r7, #0]
 80197e8:	f7fe fcf6 	bl	80181d8 <icmp_input>
      break;
 80197ec:	e02c      	b.n	8019848 <ip_input+0x2dc>
#endif /* LWIP_ICMP */
#if LWIP_IGMP
    case IP_PROTO_IGMP:
      igmp_input(p,inp,&(iphdr->dest));
 80197ee:	697b      	ldr	r3, [r7, #20]
 80197f0:	f103 0310 	add.w	r3, r3, #16
 80197f4:	6878      	ldr	r0, [r7, #4]
 80197f6:	6839      	ldr	r1, [r7, #0]
 80197f8:	461a      	mov	r2, r3
 80197fa:	f7fe ffe1 	bl	80187c0 <igmp_input>
      break;
 80197fe:	e023      	b.n	8019848 <ip_input+0x2dc>
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
 8019800:	697b      	ldr	r3, [r7, #20]
 8019802:	f103 0310 	add.w	r3, r3, #16
 8019806:	4618      	mov	r0, r3
 8019808:	6839      	ldr	r1, [r7, #0]
 801980a:	f000 f993 	bl	8019b34 <ip_addr_isbroadcast>
 801980e:	4603      	mov	r3, r0
 8019810:	2b00      	cmp	r3, #0
 8019812:	d116      	bne.n	8019842 <ip_input+0x2d6>
          !ip_addr_ismulticast(&(iphdr->dest))) {
 8019814:	697b      	ldr	r3, [r7, #20]
 8019816:	691c      	ldr	r4, [r3, #16]
 8019818:	f04f 4070 	mov.w	r0, #4026531840	; 0xf0000000
 801981c:	f7ff fce2 	bl	80191e4 <ntohl>
 8019820:	4603      	mov	r3, r0
 8019822:	401c      	ands	r4, r3
 8019824:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 8019828:	f7ff fcdc 	bl	80191e4 <ntohl>
 801982c:	4603      	mov	r3, r0
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
 801982e:	429c      	cmp	r4, r3
 8019830:	d007      	beq.n	8019842 <ip_input+0x2d6>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
 8019832:	687b      	ldr	r3, [r7, #4]
 8019834:	697a      	ldr	r2, [r7, #20]
 8019836:	605a      	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8019838:	6878      	ldr	r0, [r7, #4]
 801983a:	f04f 0102 	mov.w	r1, #2
 801983e:	f7fe fdc1 	bl	80183c4 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 8019842:	6878      	ldr	r0, [r7, #4]
 8019844:	f7f9 fb3c 	bl	8012ec0 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 8019848:	f246 5374 	movw	r3, #25972	; 0x6574
 801984c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019850:	f04f 0200 	mov.w	r2, #0
 8019854:	601a      	str	r2, [r3, #0]
  current_header = NULL;
 8019856:	f246 5378 	movw	r3, #25976	; 0x6578
 801985a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801985e:	f04f 0200 	mov.w	r2, #0
 8019862:	601a      	str	r2, [r3, #0]

  return ERR_OK;
 8019864:	f04f 0300 	mov.w	r3, #0
 8019868:	b25b      	sxtb	r3, r3
}
 801986a:	4618      	mov	r0, r3
 801986c:	f107 071c 	add.w	r7, r7, #28
 8019870:	46bd      	mov	sp, r7
 8019872:	bd90      	pop	{r4, r7, pc}

08019874 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 8019874:	b580      	push	{r7, lr}
 8019876:	b08a      	sub	sp, #40	; 0x28
 8019878:	af06      	add	r7, sp, #24
 801987a:	60f8      	str	r0, [r7, #12]
 801987c:	60b9      	str	r1, [r7, #8]
 801987e:	607a      	str	r2, [r7, #4]
 8019880:	70fb      	strb	r3, [r7, #3]
#if IP_OPTIONS_SEND
  return ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 8019882:	78fb      	ldrb	r3, [r7, #3]
 8019884:	7e3a      	ldrb	r2, [r7, #24]
 8019886:	9200      	str	r2, [sp, #0]
 8019888:	7f3a      	ldrb	r2, [r7, #28]
 801988a:	9201      	str	r2, [sp, #4]
 801988c:	6a3a      	ldr	r2, [r7, #32]
 801988e:	9202      	str	r2, [sp, #8]
 8019890:	f04f 0200 	mov.w	r2, #0
 8019894:	9203      	str	r2, [sp, #12]
 8019896:	f04f 0200 	mov.w	r2, #0
 801989a:	9204      	str	r2, [sp, #16]
 801989c:	68f8      	ldr	r0, [r7, #12]
 801989e:	68b9      	ldr	r1, [r7, #8]
 80198a0:	687a      	ldr	r2, [r7, #4]
 80198a2:	f000 f807 	bl	80198b4 <ip_output_if_opt>
 80198a6:	4603      	mov	r3, r0
}
 80198a8:	4618      	mov	r0, r3
 80198aa:	f107 0710 	add.w	r7, r7, #16
 80198ae:	46bd      	mov	sp, r7
 80198b0:	bd80      	pop	{r7, pc}
 80198b2:	bf00      	nop

080198b4 <ip_output_if_opt>:
 * @ param optlen length of ip_options
 */
err_t ip_output_if_opt(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
       u16_t optlen)
{
 80198b4:	b590      	push	{r4, r7, lr}
 80198b6:	b087      	sub	sp, #28
 80198b8:	af00      	add	r7, sp, #0
 80198ba:	60f8      	str	r0, [r7, #12]
 80198bc:	60b9      	str	r1, [r7, #8]
 80198be:	607a      	str	r2, [r7, #4]
 80198c0:	70fb      	strb	r3, [r7, #3]
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 80198c2:	687b      	ldr	r3, [r7, #4]
 80198c4:	2b00      	cmp	r3, #0
 80198c6:	f000 80ea 	beq.w	8019a9e <ip_output_if_opt+0x1ea>
    u16_t ip_hlen = IP_HLEN;
 80198ca:	f04f 0314 	mov.w	r3, #20
 80198ce:	82fb      	strh	r3, [r7, #22]
#if IP_OPTIONS_SEND
    u16_t optlen_aligned = 0;
 80198d0:	f04f 0300 	mov.w	r3, #0
 80198d4:	82bb      	strh	r3, [r7, #20]
    if (optlen != 0) {
 80198d6:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80198d8:	2b00      	cmp	r3, #0
 80198da:	d02f      	beq.n	801993c <ip_output_if_opt+0x88>
      /* round up to a multiple of 4 */
      optlen_aligned = ((optlen + 3) & ~3);
 80198dc:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80198de:	f103 0303 	add.w	r3, r3, #3
 80198e2:	b29b      	uxth	r3, r3
 80198e4:	f023 0303 	bic.w	r3, r3, #3
 80198e8:	82bb      	strh	r3, [r7, #20]
      ip_hlen += optlen_aligned;
 80198ea:	8afa      	ldrh	r2, [r7, #22]
 80198ec:	8abb      	ldrh	r3, [r7, #20]
 80198ee:	18d3      	adds	r3, r2, r3
 80198f0:	82fb      	strh	r3, [r7, #22]
      /* First write in the IP options */
      if (pbuf_header(p, optlen_aligned)) {
 80198f2:	8abb      	ldrh	r3, [r7, #20]
 80198f4:	b21b      	sxth	r3, r3
 80198f6:	68f8      	ldr	r0, [r7, #12]
 80198f8:	4619      	mov	r1, r3
 80198fa:	f7f9 fa67 	bl	8012dcc <pbuf_header>
 80198fe:	4603      	mov	r3, r0
 8019900:	2b00      	cmp	r3, #0
 8019902:	d002      	beq.n	801990a <ip_output_if_opt+0x56>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
        IP_STATS_INC(ip.err);
        snmp_inc_ipoutdiscards();
        return ERR_BUF;
 8019904:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 8019908:	e0e8      	b.n	8019adc <ip_output_if_opt+0x228>
      }
      MEMCPY(p->payload, ip_options, optlen);
 801990a:	68fb      	ldr	r3, [r7, #12]
 801990c:	685a      	ldr	r2, [r3, #4]
 801990e:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 8019910:	4610      	mov	r0, r2
 8019912:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8019914:	461a      	mov	r2, r3
 8019916:	f009 fe7d 	bl	8023614 <memcpy>
      if (optlen < optlen_aligned) {
 801991a:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 801991c:	8abb      	ldrh	r3, [r7, #20]
 801991e:	429a      	cmp	r2, r3
 8019920:	d20c      	bcs.n	801993c <ip_output_if_opt+0x88>
        /* zero the remaining bytes */
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
 8019922:	68fb      	ldr	r3, [r7, #12]
 8019924:	685a      	ldr	r2, [r3, #4]
 8019926:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 8019928:	18d2      	adds	r2, r2, r3
 801992a:	8ab9      	ldrh	r1, [r7, #20]
 801992c:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 801992e:	1acb      	subs	r3, r1, r3
 8019930:	4610      	mov	r0, r2
 8019932:	f04f 0100 	mov.w	r1, #0
 8019936:	461a      	mov	r2, r3
 8019938:	f009 ffda 	bl	80238f0 <memset>
      }
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 801993c:	68f8      	ldr	r0, [r7, #12]
 801993e:	f04f 0114 	mov.w	r1, #20
 8019942:	f7f9 fa43 	bl	8012dcc <pbuf_header>
 8019946:	4603      	mov	r3, r0
 8019948:	2b00      	cmp	r3, #0
 801994a:	d002      	beq.n	8019952 <ip_output_if_opt+0x9e>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 801994c:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 8019950:	e0c4      	b.n	8019adc <ip_output_if_opt+0x228>
    }

    iphdr = p->payload;
 8019952:	68fb      	ldr	r3, [r7, #12]
 8019954:	685b      	ldr	r3, [r3, #4]
 8019956:	613b      	str	r3, [r7, #16]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 8019958:	693b      	ldr	r3, [r7, #16]
 801995a:	891b      	ldrh	r3, [r3, #8]
 801995c:	b29b      	uxth	r3, r3
 801995e:	4618      	mov	r0, r3
 8019960:	f7ff fc12 	bl	8019188 <ntohs>
 8019964:	4603      	mov	r3, r0
 8019966:	b29b      	uxth	r3, r3
 8019968:	b2db      	uxtb	r3, r3
 801996a:	b29a      	uxth	r2, r3
 801996c:	78fb      	ldrb	r3, [r7, #3]
 801996e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8019972:	b29b      	uxth	r3, r3
 8019974:	4313      	orrs	r3, r2
 8019976:	b29b      	uxth	r3, r3
 8019978:	b29b      	uxth	r3, r3
 801997a:	4618      	mov	r0, r3
 801997c:	f7ff fbec 	bl	8019158 <htons>
 8019980:	4603      	mov	r3, r0
 8019982:	461a      	mov	r2, r3
 8019984:	693b      	ldr	r3, [r7, #16]
 8019986:	811a      	strh	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 8019988:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 801998c:	b29c      	uxth	r4, r3
 801998e:	693b      	ldr	r3, [r7, #16]
 8019990:	891b      	ldrh	r3, [r3, #8]
 8019992:	b29b      	uxth	r3, r3
 8019994:	4618      	mov	r0, r3
 8019996:	f7ff fbf7 	bl	8019188 <ntohs>
 801999a:	4603      	mov	r3, r0
 801999c:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80199a0:	b29b      	uxth	r3, r3
 80199a2:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80199a6:	b29b      	uxth	r3, r3
 80199a8:	4622      	mov	r2, r4
 80199aa:	4313      	orrs	r3, r2
 80199ac:	b29b      	uxth	r3, r3
 80199ae:	b29b      	uxth	r3, r3
 80199b0:	4618      	mov	r0, r3
 80199b2:	f7ff fbd1 	bl	8019158 <htons>
 80199b6:	4603      	mov	r3, r0
 80199b8:	461a      	mov	r2, r3
 80199ba:	693b      	ldr	r3, [r7, #16]
 80199bc:	811a      	strh	r2, [r3, #8]

    ip_addr_set(&(iphdr->dest), dest);
 80199be:	687b      	ldr	r3, [r7, #4]
 80199c0:	2b00      	cmp	r3, #0
 80199c2:	d002      	beq.n	80199ca <ip_output_if_opt+0x116>
 80199c4:	687b      	ldr	r3, [r7, #4]
 80199c6:	681b      	ldr	r3, [r3, #0]
 80199c8:	e001      	b.n	80199ce <ip_output_if_opt+0x11a>
 80199ca:	f04f 0300 	mov.w	r3, #0
 80199ce:	693a      	ldr	r2, [r7, #16]
 80199d0:	6113      	str	r3, [r2, #16]

    IPH_VHLTOS_SET(iphdr, 4, ip_hlen / 4, tos);
 80199d2:	8afb      	ldrh	r3, [r7, #22]
 80199d4:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80199d8:	b29b      	uxth	r3, r3
 80199da:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80199de:	b29b      	uxth	r3, r3
 80199e0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80199e4:	b29a      	uxth	r2, r3
 80199e6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 80199ea:	b29b      	uxth	r3, r3
 80199ec:	4313      	orrs	r3, r2
 80199ee:	b29b      	uxth	r3, r3
 80199f0:	b29b      	uxth	r3, r3
 80199f2:	4618      	mov	r0, r3
 80199f4:	f7ff fbb0 	bl	8019158 <htons>
 80199f8:	4603      	mov	r3, r0
 80199fa:	461a      	mov	r2, r3
 80199fc:	693b      	ldr	r3, [r7, #16]
 80199fe:	801a      	strh	r2, [r3, #0]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 8019a00:	68fb      	ldr	r3, [r7, #12]
 8019a02:	891b      	ldrh	r3, [r3, #8]
 8019a04:	4618      	mov	r0, r3
 8019a06:	f7ff fba7 	bl	8019158 <htons>
 8019a0a:	4603      	mov	r3, r0
 8019a0c:	461a      	mov	r2, r3
 8019a0e:	693b      	ldr	r3, [r7, #16]
 8019a10:	805a      	strh	r2, [r3, #2]
    IPH_OFFSET_SET(iphdr, 0);
 8019a12:	693b      	ldr	r3, [r7, #16]
 8019a14:	f04f 0200 	mov.w	r2, #0
 8019a18:	719a      	strb	r2, [r3, #6]
 8019a1a:	f04f 0200 	mov.w	r2, #0
 8019a1e:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 8019a20:	f245 53a8 	movw	r3, #21928	; 0x55a8
 8019a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019a28:	881b      	ldrh	r3, [r3, #0]
 8019a2a:	4618      	mov	r0, r3
 8019a2c:	f7ff fb94 	bl	8019158 <htons>
 8019a30:	4603      	mov	r3, r0
 8019a32:	461a      	mov	r2, r3
 8019a34:	693b      	ldr	r3, [r7, #16]
 8019a36:	809a      	strh	r2, [r3, #4]
    ++ip_id;
 8019a38:	f245 53a8 	movw	r3, #21928	; 0x55a8
 8019a3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019a40:	881b      	ldrh	r3, [r3, #0]
 8019a42:	f103 0301 	add.w	r3, r3, #1
 8019a46:	b29a      	uxth	r2, r3
 8019a48:	f245 53a8 	movw	r3, #21928	; 0x55a8
 8019a4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019a50:	801a      	strh	r2, [r3, #0]

    if (ip_addr_isany(src)) {
 8019a52:	68bb      	ldr	r3, [r7, #8]
 8019a54:	2b00      	cmp	r3, #0
 8019a56:	d003      	beq.n	8019a60 <ip_output_if_opt+0x1ac>
 8019a58:	68bb      	ldr	r3, [r7, #8]
 8019a5a:	681b      	ldr	r3, [r3, #0]
 8019a5c:	2b00      	cmp	r3, #0
 8019a5e:	d10c      	bne.n	8019a7a <ip_output_if_opt+0x1c6>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
 8019a60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019a62:	f103 0304 	add.w	r3, r3, #4
 8019a66:	2b00      	cmp	r3, #0
 8019a68:	d002      	beq.n	8019a70 <ip_output_if_opt+0x1bc>
 8019a6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019a6c:	685b      	ldr	r3, [r3, #4]
 8019a6e:	e001      	b.n	8019a74 <ip_output_if_opt+0x1c0>
 8019a70:	f04f 0300 	mov.w	r3, #0
 8019a74:	693a      	ldr	r2, [r7, #16]
 8019a76:	60d3      	str	r3, [r2, #12]
 8019a78:	e009      	b.n	8019a8e <ip_output_if_opt+0x1da>
    } else {
      ip_addr_set(&(iphdr->src), src);
 8019a7a:	68bb      	ldr	r3, [r7, #8]
 8019a7c:	2b00      	cmp	r3, #0
 8019a7e:	d002      	beq.n	8019a86 <ip_output_if_opt+0x1d2>
 8019a80:	68bb      	ldr	r3, [r7, #8]
 8019a82:	681b      	ldr	r3, [r3, #0]
 8019a84:	e001      	b.n	8019a8a <ip_output_if_opt+0x1d6>
 8019a86:	f04f 0300 	mov.w	r3, #0
 8019a8a:	693a      	ldr	r2, [r7, #16]
 8019a8c:	60d3      	str	r3, [r2, #12]
    }

    IPH_CHKSUM_SET(iphdr, 0);
 8019a8e:	693b      	ldr	r3, [r7, #16]
 8019a90:	f04f 0200 	mov.w	r2, #0
 8019a94:	729a      	strb	r2, [r3, #10]
 8019a96:	f04f 0200 	mov.w	r2, #0
 8019a9a:	72da      	strb	r2, [r3, #11]
 8019a9c:	e006      	b.n	8019aac <ip_output_if_opt+0x1f8>
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
 8019a9e:	68fb      	ldr	r3, [r7, #12]
 8019aa0:	685b      	ldr	r3, [r3, #4]
 8019aa2:	613b      	str	r3, [r7, #16]
    dest = &(iphdr->dest);
 8019aa4:	693b      	ldr	r3, [r7, #16]
 8019aa6:	f103 0310 	add.w	r3, r3, #16
 8019aaa:	607b      	str	r3, [r7, #4]
    return netif_loop_output(netif, p, dest);
  }
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 8019aac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019aae:	8c1b      	ldrh	r3, [r3, #32]
 8019ab0:	2b00      	cmp	r3, #0
 8019ab2:	d00c      	beq.n	8019ace <ip_output_if_opt+0x21a>
 8019ab4:	68fb      	ldr	r3, [r7, #12]
 8019ab6:	891a      	ldrh	r2, [r3, #8]
 8019ab8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019aba:	8c1b      	ldrh	r3, [r3, #32]
 8019abc:	429a      	cmp	r2, r3
 8019abe:	d906      	bls.n	8019ace <ip_output_if_opt+0x21a>
    return ip_frag(p,netif,dest);
 8019ac0:	68f8      	ldr	r0, [r7, #12]
 8019ac2:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8019ac4:	687a      	ldr	r2, [r7, #4]
 8019ac6:	f000 fc5d 	bl	801a384 <ip_frag>
 8019aca:	4603      	mov	r3, r0
 8019acc:	e006      	b.n	8019adc <ip_output_if_opt+0x228>
  }
#endif

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 8019ace:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8019ad0:	695b      	ldr	r3, [r3, #20]
 8019ad2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8019ad4:	68f9      	ldr	r1, [r7, #12]
 8019ad6:	687a      	ldr	r2, [r7, #4]
 8019ad8:	4798      	blx	r3
 8019ada:	4603      	mov	r3, r0
 8019adc:	b25b      	sxtb	r3, r3
}
 8019ade:	4618      	mov	r0, r3
 8019ae0:	f107 071c 	add.w	r7, r7, #28
 8019ae4:	46bd      	mov	sp, r7
 8019ae6:	bd90      	pop	{r4, r7, pc}

08019ae8 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 8019ae8:	b580      	push	{r7, lr}
 8019aea:	b08a      	sub	sp, #40	; 0x28
 8019aec:	af04      	add	r7, sp, #16
 8019aee:	60f8      	str	r0, [r7, #12]
 8019af0:	60b9      	str	r1, [r7, #8]
 8019af2:	607a      	str	r2, [r7, #4]
 8019af4:	70fb      	strb	r3, [r7, #3]
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
 8019af6:	6878      	ldr	r0, [r7, #4]
 8019af8:	f7ff fcf6 	bl	80194e8 <ip_route>
 8019afc:	6178      	str	r0, [r7, #20]
 8019afe:	697b      	ldr	r3, [r7, #20]
 8019b00:	2b00      	cmp	r3, #0
 8019b02:	d102      	bne.n	8019b0a <ip_output+0x22>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
 8019b04:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 8019b08:	e00e      	b.n	8019b28 <ip_output+0x40>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 8019b0a:	78fb      	ldrb	r3, [r7, #3]
 8019b0c:	f897 2020 	ldrb.w	r2, [r7, #32]
 8019b10:	9200      	str	r2, [sp, #0]
 8019b12:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 8019b16:	9201      	str	r2, [sp, #4]
 8019b18:	697a      	ldr	r2, [r7, #20]
 8019b1a:	9202      	str	r2, [sp, #8]
 8019b1c:	68f8      	ldr	r0, [r7, #12]
 8019b1e:	68b9      	ldr	r1, [r7, #8]
 8019b20:	687a      	ldr	r2, [r7, #4]
 8019b22:	f7ff fea7 	bl	8019874 <ip_output_if>
 8019b26:	4603      	mov	r3, r0
 8019b28:	b25b      	sxtb	r3, r3
}
 8019b2a:	4618      	mov	r0, r3
 8019b2c:	f107 0718 	add.w	r7, r7, #24
 8019b30:	46bd      	mov	sp, r7
 8019b32:	bd80      	pop	{r7, pc}

08019b34 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
 8019b34:	b480      	push	{r7}
 8019b36:	b085      	sub	sp, #20
 8019b38:	af00      	add	r7, sp, #0
 8019b3a:	6078      	str	r0, [r7, #4]
 8019b3c:	6039      	str	r1, [r7, #0]
  u32_t addr2test;

  addr2test = addr->addr;
 8019b3e:	687b      	ldr	r3, [r7, #4]
 8019b40:	681b      	ldr	r3, [r3, #0]
 8019b42:	60fb      	str	r3, [r7, #12]
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
 8019b44:	68fb      	ldr	r3, [r7, #12]
 8019b46:	f1b3 3fff 	cmp.w	r3, #4294967295
 8019b4a:	d002      	beq.n	8019b52 <ip_addr_isbroadcast+0x1e>
 8019b4c:	68fb      	ldr	r3, [r7, #12]
 8019b4e:	2b00      	cmp	r3, #0
 8019b50:	d102      	bne.n	8019b58 <ip_addr_isbroadcast+0x24>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
 8019b52:	f04f 0301 	mov.w	r3, #1
 8019b56:	e02c      	b.n	8019bb2 <ip_addr_isbroadcast+0x7e>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
 8019b58:	683b      	ldr	r3, [r7, #0]
 8019b5a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8019b5e:	f003 0302 	and.w	r3, r3, #2
 8019b62:	2b00      	cmp	r3, #0
 8019b64:	d102      	bne.n	8019b6c <ip_addr_isbroadcast+0x38>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 8019b66:	f04f 0300 	mov.w	r3, #0
 8019b6a:	e022      	b.n	8019bb2 <ip_addr_isbroadcast+0x7e>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
 8019b6c:	683b      	ldr	r3, [r7, #0]
 8019b6e:	685a      	ldr	r2, [r3, #4]
 8019b70:	68fb      	ldr	r3, [r7, #12]
 8019b72:	429a      	cmp	r2, r3
 8019b74:	d102      	bne.n	8019b7c <ip_addr_isbroadcast+0x48>
    return 0;
 8019b76:	f04f 0300 	mov.w	r3, #0
 8019b7a:	e01a      	b.n	8019bb2 <ip_addr_isbroadcast+0x7e>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
 8019b7c:	687b      	ldr	r3, [r7, #4]
 8019b7e:	681a      	ldr	r2, [r3, #0]
 8019b80:	683b      	ldr	r3, [r7, #0]
 8019b82:	685b      	ldr	r3, [r3, #4]
 8019b84:	405a      	eors	r2, r3
 8019b86:	683b      	ldr	r3, [r7, #0]
 8019b88:	689b      	ldr	r3, [r3, #8]
 8019b8a:	4013      	ands	r3, r2
 8019b8c:	2b00      	cmp	r3, #0
 8019b8e:	d10e      	bne.n	8019bae <ip_addr_isbroadcast+0x7a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
 8019b90:	683b      	ldr	r3, [r7, #0]
 8019b92:	689b      	ldr	r3, [r3, #8]
 8019b94:	ea6f 0203 	mvn.w	r2, r3
 8019b98:	68fb      	ldr	r3, [r7, #12]
 8019b9a:	401a      	ands	r2, r3
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
 8019b9c:	683b      	ldr	r3, [r7, #0]
 8019b9e:	689b      	ldr	r3, [r3, #8]
 8019ba0:	ea6f 0303 	mvn.w	r3, r3
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
 8019ba4:	429a      	cmp	r2, r3
 8019ba6:	d102      	bne.n	8019bae <ip_addr_isbroadcast+0x7a>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
 8019ba8:	f04f 0301 	mov.w	r3, #1
 8019bac:	e001      	b.n	8019bb2 <ip_addr_isbroadcast+0x7e>
  else
    return 0;
 8019bae:	f04f 0300 	mov.w	r3, #0
}
 8019bb2:	4618      	mov	r0, r3
 8019bb4:	f107 0714 	add.w	r7, r7, #20
 8019bb8:	46bd      	mov	sp, r7
 8019bba:	bc80      	pop	{r7}
 8019bbc:	4770      	bx	lr
 8019bbe:	bf00      	nop

08019bc0 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
 8019bc0:	b580      	push	{r7, lr}
 8019bc2:	b084      	sub	sp, #16
 8019bc4:	af00      	add	r7, sp, #0
  struct ip_reassdata *r, *prev = NULL;
 8019bc6:	f04f 0300 	mov.w	r3, #0
 8019bca:	60bb      	str	r3, [r7, #8]

  r = reassdatagrams;
 8019bcc:	f245 53ac 	movw	r3, #21932	; 0x55ac
 8019bd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019bd4:	681b      	ldr	r3, [r3, #0]
 8019bd6:	60fb      	str	r3, [r7, #12]
  while (r != NULL) {
 8019bd8:	e019      	b.n	8019c0e <ip_reass_tmr+0x4e>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 8019bda:	68fb      	ldr	r3, [r7, #12]
 8019bdc:	7fdb      	ldrb	r3, [r3, #31]
 8019bde:	2b00      	cmp	r3, #0
 8019be0:	d00c      	beq.n	8019bfc <ip_reass_tmr+0x3c>
      r->timer--;
 8019be2:	68fb      	ldr	r3, [r7, #12]
 8019be4:	7fdb      	ldrb	r3, [r3, #31]
 8019be6:	f103 33ff 	add.w	r3, r3, #4294967295
 8019bea:	b2da      	uxtb	r2, r3
 8019bec:	68fb      	ldr	r3, [r7, #12]
 8019bee:	77da      	strb	r2, [r3, #31]
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
 8019bf0:	68fb      	ldr	r3, [r7, #12]
 8019bf2:	60bb      	str	r3, [r7, #8]
      r = r->next;
 8019bf4:	68fb      	ldr	r3, [r7, #12]
 8019bf6:	681b      	ldr	r3, [r3, #0]
 8019bf8:	60fb      	str	r3, [r7, #12]
 8019bfa:	e008      	b.n	8019c0e <ip_reass_tmr+0x4e>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
 8019bfc:	68fb      	ldr	r3, [r7, #12]
 8019bfe:	607b      	str	r3, [r7, #4]
      /* get the next pointer before freeing */
      r = r->next;
 8019c00:	68fb      	ldr	r3, [r7, #12]
 8019c02:	681b      	ldr	r3, [r3, #0]
 8019c04:	60fb      	str	r3, [r7, #12]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
 8019c06:	6878      	ldr	r0, [r7, #4]
 8019c08:	68b9      	ldr	r1, [r7, #8]
 8019c0a:	f000 f807 	bl	8019c1c <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 8019c0e:	68fb      	ldr	r3, [r7, #12]
 8019c10:	2b00      	cmp	r3, #0
 8019c12:	d1e2      	bne.n	8019bda <ip_reass_tmr+0x1a>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
 8019c14:	f107 0710 	add.w	r7, r7, #16
 8019c18:	46bd      	mov	sp, r7
 8019c1a:	bd80      	pop	{r7, pc}

08019c1c <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 8019c1c:	b580      	push	{r7, lr}
 8019c1e:	b086      	sub	sp, #24
 8019c20:	af00      	add	r7, sp, #0
 8019c22:	6078      	str	r0, [r7, #4]
 8019c24:	6039      	str	r1, [r7, #0]
  int pbufs_freed = 0;
 8019c26:	f04f 0300 	mov.w	r3, #0
 8019c2a:	617b      	str	r3, [r7, #20]
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  if (prev != NULL) {
 8019c2c:	683b      	ldr	r3, [r7, #0]
 8019c2e:	2b00      	cmp	r3, #0
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 8019c30:	687b      	ldr	r3, [r7, #4]
 8019c32:	685b      	ldr	r3, [r3, #4]
 8019c34:	685b      	ldr	r3, [r3, #4]
 8019c36:	60fb      	str	r3, [r7, #12]
  if (iprh->start == 0) {
 8019c38:	68fb      	ldr	r3, [r7, #12]
 8019c3a:	889b      	ldrh	r3, [r3, #4]
 8019c3c:	b29b      	uxth	r3, r3
 8019c3e:	2b00      	cmp	r3, #0
 8019c40:	d120      	bne.n	8019c84 <ip_reass_free_complete_datagram+0x68>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
 8019c42:	687b      	ldr	r3, [r7, #4]
 8019c44:	685b      	ldr	r3, [r3, #4]
 8019c46:	613b      	str	r3, [r7, #16]
    ipr->p = iprh->next_pbuf;
 8019c48:	68fb      	ldr	r3, [r7, #12]
 8019c4a:	681a      	ldr	r2, [r3, #0]
 8019c4c:	687b      	ldr	r3, [r7, #4]
 8019c4e:	605a      	str	r2, [r3, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 8019c50:	693b      	ldr	r3, [r7, #16]
 8019c52:	685a      	ldr	r2, [r3, #4]
 8019c54:	687b      	ldr	r3, [r7, #4]
 8019c56:	f103 0308 	add.w	r3, r3, #8
 8019c5a:	4610      	mov	r0, r2
 8019c5c:	4619      	mov	r1, r3
 8019c5e:	f04f 0214 	mov.w	r2, #20
 8019c62:	f009 fcd7 	bl	8023614 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 8019c66:	6938      	ldr	r0, [r7, #16]
 8019c68:	f04f 0101 	mov.w	r1, #1
 8019c6c:	f7fe fbbc 	bl	80183e8 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
 8019c70:	6938      	ldr	r0, [r7, #16]
 8019c72:	f7f9 f979 	bl	8012f68 <pbuf_clen>
 8019c76:	4603      	mov	r3, r0
 8019c78:	697a      	ldr	r2, [r7, #20]
 8019c7a:	18d3      	adds	r3, r2, r3
 8019c7c:	617b      	str	r3, [r7, #20]
    pbuf_free(p);
 8019c7e:	6938      	ldr	r0, [r7, #16]
 8019c80:	f7f9 f91e 	bl	8012ec0 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 8019c84:	687b      	ldr	r3, [r7, #4]
 8019c86:	685b      	ldr	r3, [r3, #4]
 8019c88:	613b      	str	r3, [r7, #16]
  while (p != NULL) {
 8019c8a:	e011      	b.n	8019cb0 <ip_reass_free_complete_datagram+0x94>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 8019c8c:	693b      	ldr	r3, [r7, #16]
 8019c8e:	685b      	ldr	r3, [r3, #4]
 8019c90:	60fb      	str	r3, [r7, #12]
    pcur = p;
 8019c92:	693b      	ldr	r3, [r7, #16]
 8019c94:	60bb      	str	r3, [r7, #8]
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 8019c96:	68fb      	ldr	r3, [r7, #12]
 8019c98:	681b      	ldr	r3, [r3, #0]
 8019c9a:	613b      	str	r3, [r7, #16]
    pbufs_freed += pbuf_clen(pcur);
 8019c9c:	68b8      	ldr	r0, [r7, #8]
 8019c9e:	f7f9 f963 	bl	8012f68 <pbuf_clen>
 8019ca2:	4603      	mov	r3, r0
 8019ca4:	697a      	ldr	r2, [r7, #20]
 8019ca6:	18d3      	adds	r3, r2, r3
 8019ca8:	617b      	str	r3, [r7, #20]
    pbuf_free(pcur);    
 8019caa:	68b8      	ldr	r0, [r7, #8]
 8019cac:	f7f9 f908 	bl	8012ec0 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 8019cb0:	693b      	ldr	r3, [r7, #16]
 8019cb2:	2b00      	cmp	r3, #0
 8019cb4:	d1ea      	bne.n	8019c8c <ip_reass_free_complete_datagram+0x70>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 8019cb6:	6878      	ldr	r0, [r7, #4]
 8019cb8:	6839      	ldr	r1, [r7, #0]
 8019cba:	f000 f8c7 	bl	8019e4c <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 8019cbe:	f245 53b0 	movw	r3, #21936	; 0x55b0
 8019cc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019cc6:	881a      	ldrh	r2, [r3, #0]
 8019cc8:	697b      	ldr	r3, [r7, #20]
 8019cca:	b29b      	uxth	r3, r3
 8019ccc:	1ad3      	subs	r3, r2, r3
 8019cce:	b29a      	uxth	r2, r3
 8019cd0:	f245 53b0 	movw	r3, #21936	; 0x55b0
 8019cd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019cd8:	801a      	strh	r2, [r3, #0]

  return pbufs_freed;
 8019cda:	697b      	ldr	r3, [r7, #20]
}
 8019cdc:	4618      	mov	r0, r3
 8019cde:	f107 0718 	add.w	r7, r7, #24
 8019ce2:	46bd      	mov	sp, r7
 8019ce4:	bd80      	pop	{r7, pc}
 8019ce6:	bf00      	nop

08019ce8 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 8019ce8:	b580      	push	{r7, lr}
 8019cea:	b088      	sub	sp, #32
 8019cec:	af00      	add	r7, sp, #0
 8019cee:	6078      	str	r0, [r7, #4]
 8019cf0:	6039      	str	r1, [r7, #0]
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 8019cf2:	f04f 0300 	mov.w	r3, #0
 8019cf6:	613b      	str	r3, [r7, #16]
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
 8019cf8:	f04f 0300 	mov.w	r3, #0
 8019cfc:	61bb      	str	r3, [r7, #24]
    prev = NULL;
 8019cfe:	f04f 0300 	mov.w	r3, #0
 8019d02:	617b      	str	r3, [r7, #20]
    other_datagrams = 0;
 8019d04:	f04f 0300 	mov.w	r3, #0
 8019d08:	60fb      	str	r3, [r7, #12]
    r = reassdatagrams;
 8019d0a:	f245 53ac 	movw	r3, #21932	; 0x55ac
 8019d0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019d12:	681b      	ldr	r3, [r3, #0]
 8019d14:	61fb      	str	r3, [r7, #28]
    while (r != NULL) {
 8019d16:	e02d      	b.n	8019d74 <ip_reass_remove_oldest_datagram+0x8c>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 8019d18:	69fb      	ldr	r3, [r7, #28]
 8019d1a:	695a      	ldr	r2, [r3, #20]
 8019d1c:	687b      	ldr	r3, [r7, #4]
 8019d1e:	68db      	ldr	r3, [r3, #12]
 8019d20:	429a      	cmp	r2, r3
 8019d22:	d10c      	bne.n	8019d3e <ip_reass_remove_oldest_datagram+0x56>
 8019d24:	69fb      	ldr	r3, [r7, #28]
 8019d26:	699a      	ldr	r2, [r3, #24]
 8019d28:	687b      	ldr	r3, [r7, #4]
 8019d2a:	691b      	ldr	r3, [r3, #16]
 8019d2c:	429a      	cmp	r2, r3
 8019d2e:	d106      	bne.n	8019d3e <ip_reass_remove_oldest_datagram+0x56>
 8019d30:	69fb      	ldr	r3, [r7, #28]
 8019d32:	899a      	ldrh	r2, [r3, #12]
 8019d34:	687b      	ldr	r3, [r7, #4]
 8019d36:	889b      	ldrh	r3, [r3, #4]
 8019d38:	b29b      	uxth	r3, r3
 8019d3a:	429a      	cmp	r2, r3
 8019d3c:	d011      	beq.n	8019d62 <ip_reass_remove_oldest_datagram+0x7a>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 8019d3e:	68fb      	ldr	r3, [r7, #12]
 8019d40:	f103 0301 	add.w	r3, r3, #1
 8019d44:	60fb      	str	r3, [r7, #12]
        if (oldest == NULL) {
 8019d46:	69bb      	ldr	r3, [r7, #24]
 8019d48:	2b00      	cmp	r3, #0
 8019d4a:	d102      	bne.n	8019d52 <ip_reass_remove_oldest_datagram+0x6a>
          oldest = r;
 8019d4c:	69fb      	ldr	r3, [r7, #28]
 8019d4e:	61bb      	str	r3, [r7, #24]
 8019d50:	e007      	b.n	8019d62 <ip_reass_remove_oldest_datagram+0x7a>
        } else if (r->timer <= oldest->timer) {
 8019d52:	69fb      	ldr	r3, [r7, #28]
 8019d54:	7fda      	ldrb	r2, [r3, #31]
 8019d56:	69bb      	ldr	r3, [r7, #24]
 8019d58:	7fdb      	ldrb	r3, [r3, #31]
 8019d5a:	429a      	cmp	r2, r3
 8019d5c:	d801      	bhi.n	8019d62 <ip_reass_remove_oldest_datagram+0x7a>
          /* older than the previous oldest */
          oldest = r;
 8019d5e:	69fb      	ldr	r3, [r7, #28]
 8019d60:	61bb      	str	r3, [r7, #24]
        }
      }
      if (r->next != NULL) {
 8019d62:	69fb      	ldr	r3, [r7, #28]
 8019d64:	681b      	ldr	r3, [r3, #0]
 8019d66:	2b00      	cmp	r3, #0
 8019d68:	d001      	beq.n	8019d6e <ip_reass_remove_oldest_datagram+0x86>
        prev = r;
 8019d6a:	69fb      	ldr	r3, [r7, #28]
 8019d6c:	617b      	str	r3, [r7, #20]
      }
      r = r->next;
 8019d6e:	69fb      	ldr	r3, [r7, #28]
 8019d70:	681b      	ldr	r3, [r3, #0]
 8019d72:	61fb      	str	r3, [r7, #28]
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
 8019d74:	69fb      	ldr	r3, [r7, #28]
 8019d76:	2b00      	cmp	r3, #0
 8019d78:	d1ce      	bne.n	8019d18 <ip_reass_remove_oldest_datagram+0x30>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 8019d7a:	69bb      	ldr	r3, [r7, #24]
 8019d7c:	2b00      	cmp	r3, #0
 8019d7e:	d008      	beq.n	8019d92 <ip_reass_remove_oldest_datagram+0xaa>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 8019d80:	69b8      	ldr	r0, [r7, #24]
 8019d82:	6979      	ldr	r1, [r7, #20]
 8019d84:	f7ff ff4a 	bl	8019c1c <ip_reass_free_complete_datagram>
 8019d88:	60b8      	str	r0, [r7, #8]
      pbufs_freed += pbufs_freed_current;
 8019d8a:	693a      	ldr	r2, [r7, #16]
 8019d8c:	68bb      	ldr	r3, [r7, #8]
 8019d8e:	18d3      	adds	r3, r2, r3
 8019d90:	613b      	str	r3, [r7, #16]
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 8019d92:	693a      	ldr	r2, [r7, #16]
 8019d94:	683b      	ldr	r3, [r7, #0]
 8019d96:	429a      	cmp	r2, r3
 8019d98:	da02      	bge.n	8019da0 <ip_reass_remove_oldest_datagram+0xb8>
 8019d9a:	68fb      	ldr	r3, [r7, #12]
 8019d9c:	2b01      	cmp	r3, #1
 8019d9e:	dcab      	bgt.n	8019cf8 <ip_reass_remove_oldest_datagram+0x10>
  return pbufs_freed;
 8019da0:	693b      	ldr	r3, [r7, #16]
}
 8019da2:	4618      	mov	r0, r3
 8019da4:	f107 0720 	add.w	r7, r7, #32
 8019da8:	46bd      	mov	sp, r7
 8019daa:	bd80      	pop	{r7, pc}

08019dac <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
 8019dac:	b580      	push	{r7, lr}
 8019dae:	b084      	sub	sp, #16
 8019db0:	af00      	add	r7, sp, #0
 8019db2:	6078      	str	r0, [r7, #4]
 8019db4:	6039      	str	r1, [r7, #0]
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
 8019db6:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8019dba:	f6c0 0302 	movt	r3, #2050	; 0x802
 8019dbe:	895b      	ldrh	r3, [r3, #10]
 8019dc0:	4618      	mov	r0, r3
 8019dc2:	f7f8 f9a5 	bl	8012110 <mem_malloc>
 8019dc6:	60f8      	str	r0, [r7, #12]
  if (ipr == NULL) {
 8019dc8:	68fb      	ldr	r3, [r7, #12]
 8019dca:	2b00      	cmp	r3, #0
 8019dcc:	d116      	bne.n	8019dfc <ip_reass_enqueue_new_datagram+0x50>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 8019dce:	6878      	ldr	r0, [r7, #4]
 8019dd0:	6839      	ldr	r1, [r7, #0]
 8019dd2:	f7ff ff89 	bl	8019ce8 <ip_reass_remove_oldest_datagram>
 8019dd6:	4602      	mov	r2, r0
 8019dd8:	683b      	ldr	r3, [r7, #0]
 8019dda:	429a      	cmp	r2, r3
 8019ddc:	db08      	blt.n	8019df0 <ip_reass_enqueue_new_datagram+0x44>
      ipr = memp_malloc(MEMP_REASSDATA);
 8019dde:	f246 73d4 	movw	r3, #26580	; 0x67d4
 8019de2:	f6c0 0302 	movt	r3, #2050	; 0x802
 8019de6:	895b      	ldrh	r3, [r3, #10]
 8019de8:	4618      	mov	r0, r3
 8019dea:	f7f8 f991 	bl	8012110 <mem_malloc>
 8019dee:	60f8      	str	r0, [r7, #12]
    }
    if (ipr == NULL)
 8019df0:	68fb      	ldr	r3, [r7, #12]
 8019df2:	2b00      	cmp	r3, #0
 8019df4:	d102      	bne.n	8019dfc <ip_reass_enqueue_new_datagram+0x50>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
 8019df6:	f04f 0300 	mov.w	r3, #0
 8019dfa:	e021      	b.n	8019e40 <ip_reass_enqueue_new_datagram+0x94>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 8019dfc:	68f8      	ldr	r0, [r7, #12]
 8019dfe:	f04f 0100 	mov.w	r1, #0
 8019e02:	f04f 0220 	mov.w	r2, #32
 8019e06:	f009 fd73 	bl	80238f0 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 8019e0a:	68fb      	ldr	r3, [r7, #12]
 8019e0c:	f04f 0203 	mov.w	r2, #3
 8019e10:	77da      	strb	r2, [r3, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 8019e12:	f245 53ac 	movw	r3, #21932	; 0x55ac
 8019e16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019e1a:	681a      	ldr	r2, [r3, #0]
 8019e1c:	68fb      	ldr	r3, [r7, #12]
 8019e1e:	601a      	str	r2, [r3, #0]
  reassdatagrams = ipr;
 8019e20:	f245 53ac 	movw	r3, #21932	; 0x55ac
 8019e24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019e28:	68fa      	ldr	r2, [r7, #12]
 8019e2a:	601a      	str	r2, [r3, #0]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 8019e2c:	68fb      	ldr	r3, [r7, #12]
 8019e2e:	f103 0308 	add.w	r3, r3, #8
 8019e32:	4618      	mov	r0, r3
 8019e34:	6879      	ldr	r1, [r7, #4]
 8019e36:	f04f 0214 	mov.w	r2, #20
 8019e3a:	f009 fbeb 	bl	8023614 <memcpy>
  return ipr;
 8019e3e:	68fb      	ldr	r3, [r7, #12]
}
 8019e40:	4618      	mov	r0, r3
 8019e42:	f107 0710 	add.w	r7, r7, #16
 8019e46:	46bd      	mov	sp, r7
 8019e48:	bd80      	pop	{r7, pc}
 8019e4a:	bf00      	nop

08019e4c <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 8019e4c:	b580      	push	{r7, lr}
 8019e4e:	b082      	sub	sp, #8
 8019e50:	af00      	add	r7, sp, #0
 8019e52:	6078      	str	r0, [r7, #4]
 8019e54:	6039      	str	r1, [r7, #0]
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 8019e56:	f245 53ac 	movw	r3, #21932	; 0x55ac
 8019e5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019e5e:	681a      	ldr	r2, [r3, #0]
 8019e60:	687b      	ldr	r3, [r7, #4]
 8019e62:	429a      	cmp	r2, r3
 8019e64:	d107      	bne.n	8019e76 <ip_reass_dequeue_datagram+0x2a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 8019e66:	687b      	ldr	r3, [r7, #4]
 8019e68:	681a      	ldr	r2, [r3, #0]
 8019e6a:	f245 53ac 	movw	r3, #21932	; 0x55ac
 8019e6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019e72:	601a      	str	r2, [r3, #0]
 8019e74:	e003      	b.n	8019e7e <ip_reass_dequeue_datagram+0x32>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 8019e76:	687b      	ldr	r3, [r7, #4]
 8019e78:	681a      	ldr	r2, [r3, #0]
 8019e7a:	683b      	ldr	r3, [r7, #0]
 8019e7c:	601a      	str	r2, [r3, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 8019e7e:	6878      	ldr	r0, [r7, #4]
 8019e80:	f7f8 f81a 	bl	8011eb8 <mem_free>
}
 8019e84:	f107 0708 	add.w	r7, r7, #8
 8019e88:	46bd      	mov	sp, r7
 8019e8a:	bd80      	pop	{r7, pc}

08019e8c <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
 8019e8c:	b590      	push	{r4, r7, lr}
 8019e8e:	b08b      	sub	sp, #44	; 0x2c
 8019e90:	af00      	add	r7, sp, #0
 8019e92:	6078      	str	r0, [r7, #4]
 8019e94:	6039      	str	r1, [r7, #0]
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
 8019e96:	f04f 0300 	mov.w	r3, #0
 8019e9a:	623b      	str	r3, [r7, #32]
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
 8019e9c:	f04f 0301 	mov.w	r3, #1
 8019ea0:	61bb      	str	r3, [r7, #24]

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 8019ea2:	683b      	ldr	r3, [r7, #0]
 8019ea4:	685b      	ldr	r3, [r3, #4]
 8019ea6:	617b      	str	r3, [r7, #20]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 8019ea8:	697b      	ldr	r3, [r7, #20]
 8019eaa:	885b      	ldrh	r3, [r3, #2]
 8019eac:	b29b      	uxth	r3, r3
 8019eae:	4618      	mov	r0, r3
 8019eb0:	f7ff f96a 	bl	8019188 <ntohs>
 8019eb4:	4603      	mov	r3, r0
 8019eb6:	461c      	mov	r4, r3
 8019eb8:	697b      	ldr	r3, [r7, #20]
 8019eba:	881b      	ldrh	r3, [r3, #0]
 8019ebc:	b29b      	uxth	r3, r3
 8019ebe:	4618      	mov	r0, r3
 8019ec0:	f7ff f962 	bl	8019188 <ntohs>
 8019ec4:	4603      	mov	r3, r0
 8019ec6:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8019eca:	b29b      	uxth	r3, r3
 8019ecc:	f003 030f 	and.w	r3, r3, #15
 8019ed0:	b29b      	uxth	r3, r3
 8019ed2:	461a      	mov	r2, r3
 8019ed4:	ea4f 3282 	mov.w	r2, r2, lsl #14
 8019ed8:	1ad3      	subs	r3, r2, r3
 8019eda:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8019ede:	b29b      	uxth	r3, r3
 8019ee0:	18e3      	adds	r3, r4, r3
 8019ee2:	827b      	strh	r3, [r7, #18]
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 8019ee4:	697b      	ldr	r3, [r7, #20]
 8019ee6:	88db      	ldrh	r3, [r3, #6]
 8019ee8:	b29b      	uxth	r3, r3
 8019eea:	4618      	mov	r0, r3
 8019eec:	f7ff f94c 	bl	8019188 <ntohs>
 8019ef0:	4603      	mov	r3, r0
 8019ef2:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 8019ef6:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 8019efa:	b29b      	uxth	r3, r3
 8019efc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8019f00:	823b      	strh	r3, [r7, #16]
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 8019f02:	683b      	ldr	r3, [r7, #0]
 8019f04:	685b      	ldr	r3, [r3, #4]
 8019f06:	627b      	str	r3, [r7, #36]	; 0x24
  iprh->next_pbuf = NULL;
 8019f08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f0a:	f04f 0200 	mov.w	r2, #0
 8019f0e:	701a      	strb	r2, [r3, #0]
 8019f10:	f04f 0200 	mov.w	r2, #0
 8019f14:	705a      	strb	r2, [r3, #1]
 8019f16:	f04f 0200 	mov.w	r2, #0
 8019f1a:	709a      	strb	r2, [r3, #2]
 8019f1c:	f04f 0200 	mov.w	r2, #0
 8019f20:	70da      	strb	r2, [r3, #3]
  iprh->start = offset;
 8019f22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f24:	8a3a      	ldrh	r2, [r7, #16]
 8019f26:	809a      	strh	r2, [r3, #4]
  iprh->end = offset + len;
 8019f28:	8a3a      	ldrh	r2, [r7, #16]
 8019f2a:	8a7b      	ldrh	r3, [r7, #18]
 8019f2c:	18d3      	adds	r3, r2, r3
 8019f2e:	b29a      	uxth	r2, r3
 8019f30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f32:	80da      	strh	r2, [r3, #6]

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 8019f34:	687b      	ldr	r3, [r7, #4]
 8019f36:	685b      	ldr	r3, [r3, #4]
 8019f38:	61fb      	str	r3, [r7, #28]
 8019f3a:	e04d      	b.n	8019fd8 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 8019f3c:	69fb      	ldr	r3, [r7, #28]
 8019f3e:	685b      	ldr	r3, [r3, #4]
 8019f40:	60fb      	str	r3, [r7, #12]
    if (iprh->start < iprh_tmp->start) {
 8019f42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f44:	889b      	ldrh	r3, [r3, #4]
 8019f46:	b29a      	uxth	r2, r3
 8019f48:	68fb      	ldr	r3, [r7, #12]
 8019f4a:	889b      	ldrh	r3, [r3, #4]
 8019f4c:	b29b      	uxth	r3, r3
 8019f4e:	429a      	cmp	r2, r3
 8019f50:	d21f      	bcs.n	8019f92 <ip_reass_chain_frag_into_datagram_and_validate+0x106>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 8019f52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f54:	69fa      	ldr	r2, [r7, #28]
 8019f56:	601a      	str	r2, [r3, #0]
      if (iprh_prev != NULL) {
 8019f58:	6a3b      	ldr	r3, [r7, #32]
 8019f5a:	2b00      	cmp	r3, #0
 8019f5c:	d015      	beq.n	8019f8a <ip_reass_chain_frag_into_datagram_and_validate+0xfe>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 8019f5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f60:	889b      	ldrh	r3, [r3, #4]
 8019f62:	b29a      	uxth	r2, r3
 8019f64:	6a3b      	ldr	r3, [r7, #32]
 8019f66:	88db      	ldrh	r3, [r3, #6]
 8019f68:	b29b      	uxth	r3, r3
 8019f6a:	429a      	cmp	r2, r3
 8019f6c:	f0c0 8091 	bcc.w	801a092 <ip_reass_chain_frag_into_datagram_and_validate+0x206>
 8019f70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f72:	88db      	ldrh	r3, [r3, #6]
 8019f74:	b29a      	uxth	r2, r3
 8019f76:	68fb      	ldr	r3, [r7, #12]
 8019f78:	889b      	ldrh	r3, [r3, #4]
 8019f7a:	b29b      	uxth	r3, r3
 8019f7c:	429a      	cmp	r2, r3
 8019f7e:	f200 8088 	bhi.w	801a092 <ip_reass_chain_frag_into_datagram_and_validate+0x206>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 8019f82:	6a3b      	ldr	r3, [r7, #32]
 8019f84:	683a      	ldr	r2, [r7, #0]
 8019f86:	601a      	str	r2, [r3, #0]
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 8019f88:	e029      	b.n	8019fde <ip_reass_chain_frag_into_datagram_and_validate+0x152>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
 8019f8a:	687b      	ldr	r3, [r7, #4]
 8019f8c:	683a      	ldr	r2, [r7, #0]
 8019f8e:	605a      	str	r2, [r3, #4]
      }
      break;
 8019f90:	e025      	b.n	8019fde <ip_reass_chain_frag_into_datagram_and_validate+0x152>
    } else if(iprh->start == iprh_tmp->start) {
 8019f92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f94:	889b      	ldrh	r3, [r3, #4]
 8019f96:	b29a      	uxth	r2, r3
 8019f98:	68fb      	ldr	r3, [r7, #12]
 8019f9a:	889b      	ldrh	r3, [r3, #4]
 8019f9c:	b29b      	uxth	r3, r3
 8019f9e:	429a      	cmp	r2, r3
 8019fa0:	d074      	beq.n	801a08c <ip_reass_chain_frag_into_datagram_and_validate+0x200>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 8019fa2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019fa4:	889b      	ldrh	r3, [r3, #4]
 8019fa6:	b29a      	uxth	r2, r3
 8019fa8:	68fb      	ldr	r3, [r7, #12]
 8019faa:	88db      	ldrh	r3, [r3, #6]
 8019fac:	b29b      	uxth	r3, r3
 8019fae:	429a      	cmp	r2, r3
 8019fb0:	d36e      	bcc.n	801a090 <ip_reass_chain_frag_into_datagram_and_validate+0x204>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
 8019fb2:	6a3b      	ldr	r3, [r7, #32]
 8019fb4:	2b00      	cmp	r3, #0
 8019fb6:	d00a      	beq.n	8019fce <ip_reass_chain_frag_into_datagram_and_validate+0x142>
        if (iprh_prev->end != iprh_tmp->start) {
 8019fb8:	6a3b      	ldr	r3, [r7, #32]
 8019fba:	88db      	ldrh	r3, [r3, #6]
 8019fbc:	b29a      	uxth	r2, r3
 8019fbe:	68fb      	ldr	r3, [r7, #12]
 8019fc0:	889b      	ldrh	r3, [r3, #4]
 8019fc2:	b29b      	uxth	r3, r3
 8019fc4:	429a      	cmp	r2, r3
 8019fc6:	d002      	beq.n	8019fce <ip_reass_chain_frag_into_datagram_and_validate+0x142>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 8019fc8:	f04f 0300 	mov.w	r3, #0
 8019fcc:	61bb      	str	r3, [r7, #24]
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 8019fce:	68fb      	ldr	r3, [r7, #12]
 8019fd0:	681b      	ldr	r3, [r3, #0]
 8019fd2:	61fb      	str	r3, [r7, #28]
    iprh_prev = iprh_tmp;
 8019fd4:	68fb      	ldr	r3, [r7, #12]
 8019fd6:	623b      	str	r3, [r7, #32]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 8019fd8:	69fb      	ldr	r3, [r7, #28]
 8019fda:	2b00      	cmp	r3, #0
 8019fdc:	d1ae      	bne.n	8019f3c <ip_reass_chain_frag_into_datagram_and_validate+0xb0>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
 8019fde:	69fb      	ldr	r3, [r7, #28]
 8019fe0:	2b00      	cmp	r3, #0
 8019fe2:	d118      	bne.n	801a016 <ip_reass_chain_frag_into_datagram_and_validate+0x18a>
    if (iprh_prev != NULL) {
 8019fe4:	6a3b      	ldr	r3, [r7, #32]
 8019fe6:	2b00      	cmp	r3, #0
 8019fe8:	d012      	beq.n	801a010 <ip_reass_chain_frag_into_datagram_and_validate+0x184>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 8019fea:	6a3b      	ldr	r3, [r7, #32]
 8019fec:	88db      	ldrh	r3, [r3, #6]
 8019fee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019ff0:	889b      	ldrh	r3, [r3, #4]
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 8019ff2:	6a3b      	ldr	r3, [r7, #32]
 8019ff4:	683a      	ldr	r2, [r7, #0]
 8019ff6:	601a      	str	r2, [r3, #0]
      if (iprh_prev->end != iprh->start) {
 8019ff8:	6a3b      	ldr	r3, [r7, #32]
 8019ffa:	88db      	ldrh	r3, [r3, #6]
 8019ffc:	b29a      	uxth	r2, r3
 8019ffe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a000:	889b      	ldrh	r3, [r3, #4]
 801a002:	b29b      	uxth	r3, r3
 801a004:	429a      	cmp	r2, r3
 801a006:	d006      	beq.n	801a016 <ip_reass_chain_frag_into_datagram_and_validate+0x18a>
        valid = 0;
 801a008:	f04f 0300 	mov.w	r3, #0
 801a00c:	61bb      	str	r3, [r7, #24]
 801a00e:	e002      	b.n	801a016 <ip_reass_chain_frag_into_datagram_and_validate+0x18a>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 801a010:	687b      	ldr	r3, [r7, #4]
 801a012:	683a      	ldr	r2, [r7, #0]
 801a014:	605a      	str	r2, [r3, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 801a016:	687b      	ldr	r3, [r7, #4]
 801a018:	7f9b      	ldrb	r3, [r3, #30]
 801a01a:	f003 0301 	and.w	r3, r3, #1
 801a01e:	2b00      	cmp	r3, #0
 801a020:	d031      	beq.n	801a086 <ip_reass_chain_frag_into_datagram_and_validate+0x1fa>
    /* and had no wholes so far */
    if (valid) {
 801a022:	69bb      	ldr	r3, [r7, #24]
 801a024:	2b00      	cmp	r3, #0
 801a026:	d02c      	beq.n	801a082 <ip_reass_chain_frag_into_datagram_and_validate+0x1f6>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 801a028:	687b      	ldr	r3, [r7, #4]
 801a02a:	685b      	ldr	r3, [r3, #4]
 801a02c:	685b      	ldr	r3, [r3, #4]
 801a02e:	889b      	ldrh	r3, [r3, #4]
 801a030:	b29b      	uxth	r3, r3
 801a032:	2b00      	cmp	r3, #0
 801a034:	d003      	beq.n	801a03e <ip_reass_chain_frag_into_datagram_and_validate+0x1b2>
        valid = 0;
 801a036:	f04f 0300 	mov.w	r3, #0
 801a03a:	61bb      	str	r3, [r7, #24]
 801a03c:	e021      	b.n	801a082 <ip_reass_chain_frag_into_datagram_and_validate+0x1f6>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
 801a03e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a040:	623b      	str	r3, [r7, #32]
        q = iprh->next_pbuf;
 801a042:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a044:	681b      	ldr	r3, [r3, #0]
 801a046:	61fb      	str	r3, [r7, #28]
        while (q != NULL) {
 801a048:	e013      	b.n	801a072 <ip_reass_chain_frag_into_datagram_and_validate+0x1e6>
          iprh = (struct ip_reass_helper*)q->payload;
 801a04a:	69fb      	ldr	r3, [r7, #28]
 801a04c:	685b      	ldr	r3, [r3, #4]
 801a04e:	627b      	str	r3, [r7, #36]	; 0x24
          if (iprh_prev->end != iprh->start) {
 801a050:	6a3b      	ldr	r3, [r7, #32]
 801a052:	88db      	ldrh	r3, [r3, #6]
 801a054:	b29a      	uxth	r2, r3
 801a056:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a058:	889b      	ldrh	r3, [r3, #4]
 801a05a:	b29b      	uxth	r3, r3
 801a05c:	429a      	cmp	r2, r3
 801a05e:	d003      	beq.n	801a068 <ip_reass_chain_frag_into_datagram_and_validate+0x1dc>
            valid = 0;
 801a060:	f04f 0300 	mov.w	r3, #0
 801a064:	61bb      	str	r3, [r7, #24]
            break;
 801a066:	e007      	b.n	801a078 <ip_reass_chain_frag_into_datagram_and_validate+0x1ec>
          }
          iprh_prev = iprh;
 801a068:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a06a:	623b      	str	r3, [r7, #32]
          q = iprh->next_pbuf;
 801a06c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a06e:	681b      	ldr	r3, [r3, #0]
 801a070:	61fb      	str	r3, [r7, #28]
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 801a072:	69fb      	ldr	r3, [r7, #28]
 801a074:	2b00      	cmp	r3, #0
 801a076:	d1e8      	bne.n	801a04a <ip_reass_chain_frag_into_datagram_and_validate+0x1be>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
 801a078:	69bb      	ldr	r3, [r7, #24]
 801a07a:	2b00      	cmp	r3, #0
 801a07c:	d001      	beq.n	801a082 <ip_reass_chain_frag_into_datagram_and_validate+0x1f6>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
 801a07e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a080:	88db      	ldrh	r3, [r3, #6]
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
 801a082:	69bb      	ldr	r3, [r7, #24]
 801a084:	e01a      	b.n	801a0bc <ip_reass_chain_frag_into_datagram_and_validate+0x230>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
 801a086:	f04f 0300 	mov.w	r3, #0
 801a08a:	e017      	b.n	801a0bc <ip_reass_chain_frag_into_datagram_and_validate+0x230>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
 801a08c:	bf00      	nop
 801a08e:	e000      	b.n	801a092 <ip_reass_chain_frag_into_datagram_and_validate+0x206>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
 801a090:	bf00      	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 801a092:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a096:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a09a:	881c      	ldrh	r4, [r3, #0]
 801a09c:	6838      	ldr	r0, [r7, #0]
 801a09e:	f7f8 ff63 	bl	8012f68 <pbuf_clen>
 801a0a2:	4603      	mov	r3, r0
 801a0a4:	1ae3      	subs	r3, r4, r3
 801a0a6:	b29a      	uxth	r2, r3
 801a0a8:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a0ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a0b0:	801a      	strh	r2, [r3, #0]
  pbuf_free(new_p);
 801a0b2:	6838      	ldr	r0, [r7, #0]
 801a0b4:	f7f8 ff04 	bl	8012ec0 <pbuf_free>
  return 0;
 801a0b8:	f04f 0300 	mov.w	r3, #0
#endif /* IP_REASS_CHECK_OVERLAP */
}
 801a0bc:	4618      	mov	r0, r3
 801a0be:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 801a0c2:	46bd      	mov	sp, r7
 801a0c4:	bd90      	pop	{r4, r7, pc}
 801a0c6:	bf00      	nop

0801a0c8 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 801a0c8:	b590      	push	{r4, r7, lr}
 801a0ca:	b08b      	sub	sp, #44	; 0x2c
 801a0cc:	af00      	add	r7, sp, #0
 801a0ce:	6078      	str	r0, [r7, #4]
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
 801a0d0:	f04f 0300 	mov.w	r3, #0
 801a0d4:	61fb      	str	r3, [r7, #28]

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 801a0d6:	687b      	ldr	r3, [r7, #4]
 801a0d8:	685b      	ldr	r3, [r3, #4]
 801a0da:	61bb      	str	r3, [r7, #24]

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 801a0dc:	69bb      	ldr	r3, [r7, #24]
 801a0de:	881b      	ldrh	r3, [r3, #0]
 801a0e0:	b29b      	uxth	r3, r3
 801a0e2:	4618      	mov	r0, r3
 801a0e4:	f7ff f850 	bl	8019188 <ntohs>
 801a0e8:	4603      	mov	r3, r0
 801a0ea:	ea4f 2313 	mov.w	r3, r3, lsr #8
 801a0ee:	b29b      	uxth	r3, r3
 801a0f0:	f003 030f 	and.w	r3, r3, #15
 801a0f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a0f8:	2b14      	cmp	r3, #20
 801a0fa:	f040 8138 	bne.w	801a36e <ip_reass+0x2a6>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 801a0fe:	69bb      	ldr	r3, [r7, #24]
 801a100:	88db      	ldrh	r3, [r3, #6]
 801a102:	b29b      	uxth	r3, r3
 801a104:	4618      	mov	r0, r3
 801a106:	f7ff f83f 	bl	8019188 <ntohs>
 801a10a:	4603      	mov	r3, r0
 801a10c:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801a110:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801a114:	b29b      	uxth	r3, r3
 801a116:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801a11a:	82fb      	strh	r3, [r7, #22]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 801a11c:	69bb      	ldr	r3, [r7, #24]
 801a11e:	885b      	ldrh	r3, [r3, #2]
 801a120:	b29b      	uxth	r3, r3
 801a122:	4618      	mov	r0, r3
 801a124:	f7ff f830 	bl	8019188 <ntohs>
 801a128:	4603      	mov	r3, r0
 801a12a:	461c      	mov	r4, r3
 801a12c:	69bb      	ldr	r3, [r7, #24]
 801a12e:	881b      	ldrh	r3, [r3, #0]
 801a130:	b29b      	uxth	r3, r3
 801a132:	4618      	mov	r0, r3
 801a134:	f7ff f828 	bl	8019188 <ntohs>
 801a138:	4603      	mov	r3, r0
 801a13a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 801a13e:	b29b      	uxth	r3, r3
 801a140:	f003 030f 	and.w	r3, r3, #15
 801a144:	b29b      	uxth	r3, r3
 801a146:	461a      	mov	r2, r3
 801a148:	ea4f 3282 	mov.w	r2, r2, lsl #14
 801a14c:	1ad3      	subs	r3, r2, r3
 801a14e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a152:	b29b      	uxth	r3, r3
 801a154:	18e3      	adds	r3, r4, r3
 801a156:	82bb      	strh	r3, [r7, #20]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 801a158:	6878      	ldr	r0, [r7, #4]
 801a15a:	f7f8 ff05 	bl	8012f68 <pbuf_clen>
 801a15e:	4603      	mov	r3, r0
 801a160:	74fb      	strb	r3, [r7, #19]
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 801a162:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a166:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a16a:	881b      	ldrh	r3, [r3, #0]
 801a16c:	461a      	mov	r2, r3
 801a16e:	7cfb      	ldrb	r3, [r7, #19]
 801a170:	18d3      	adds	r3, r2, r3
 801a172:	2b0a      	cmp	r3, #10
 801a174:	dd13      	ble.n	801a19e <ip_reass+0xd6>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 801a176:	7cfb      	ldrb	r3, [r7, #19]
 801a178:	69b8      	ldr	r0, [r7, #24]
 801a17a:	4619      	mov	r1, r3
 801a17c:	f7ff fdb4 	bl	8019ce8 <ip_reass_remove_oldest_datagram>
 801a180:	4603      	mov	r3, r0
 801a182:	2b00      	cmp	r3, #0
 801a184:	f000 80f4 	beq.w	801a370 <ip_reass+0x2a8>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 801a188:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a18c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a190:	881b      	ldrh	r3, [r3, #0]
 801a192:	461a      	mov	r2, r3
 801a194:	7cfb      	ldrb	r3, [r7, #19]
 801a196:	18d3      	adds	r3, r2, r3

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 801a198:	2b0a      	cmp	r3, #10
 801a19a:	f300 80e9 	bgt.w	801a370 <ip_reass+0x2a8>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 801a19e:	f245 53ac 	movw	r3, #21932	; 0x55ac
 801a1a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a1a6:	681b      	ldr	r3, [r3, #0]
 801a1a8:	623b      	str	r3, [r7, #32]
 801a1aa:	e017      	b.n	801a1dc <ip_reass+0x114>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 801a1ac:	6a3b      	ldr	r3, [r7, #32]
 801a1ae:	695a      	ldr	r2, [r3, #20]
 801a1b0:	69bb      	ldr	r3, [r7, #24]
 801a1b2:	68db      	ldr	r3, [r3, #12]
 801a1b4:	429a      	cmp	r2, r3
 801a1b6:	d10c      	bne.n	801a1d2 <ip_reass+0x10a>
 801a1b8:	6a3b      	ldr	r3, [r7, #32]
 801a1ba:	699a      	ldr	r2, [r3, #24]
 801a1bc:	69bb      	ldr	r3, [r7, #24]
 801a1be:	691b      	ldr	r3, [r3, #16]
 801a1c0:	429a      	cmp	r2, r3
 801a1c2:	d106      	bne.n	801a1d2 <ip_reass+0x10a>
 801a1c4:	6a3b      	ldr	r3, [r7, #32]
 801a1c6:	899a      	ldrh	r2, [r3, #12]
 801a1c8:	69bb      	ldr	r3, [r7, #24]
 801a1ca:	889b      	ldrh	r3, [r3, #4]
 801a1cc:	b29b      	uxth	r3, r3
 801a1ce:	429a      	cmp	r2, r3
 801a1d0:	d008      	beq.n	801a1e4 <ip_reass+0x11c>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
 801a1d2:	6a3b      	ldr	r3, [r7, #32]
 801a1d4:	61fb      	str	r3, [r7, #28]
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 801a1d6:	6a3b      	ldr	r3, [r7, #32]
 801a1d8:	681b      	ldr	r3, [r3, #0]
 801a1da:	623b      	str	r3, [r7, #32]
 801a1dc:	6a3b      	ldr	r3, [r7, #32]
 801a1de:	2b00      	cmp	r3, #0
 801a1e0:	d1e4      	bne.n	801a1ac <ip_reass+0xe4>
 801a1e2:	e000      	b.n	801a1e6 <ip_reass+0x11e>
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
 801a1e4:	bf00      	nop
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
 801a1e6:	6a3b      	ldr	r3, [r7, #32]
 801a1e8:	2b00      	cmp	r3, #0
 801a1ea:	d109      	bne.n	801a200 <ip_reass+0x138>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 801a1ec:	7cfb      	ldrb	r3, [r7, #19]
 801a1ee:	69b8      	ldr	r0, [r7, #24]
 801a1f0:	4619      	mov	r1, r3
 801a1f2:	f7ff fddb 	bl	8019dac <ip_reass_enqueue_new_datagram>
 801a1f6:	6238      	str	r0, [r7, #32]
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
 801a1f8:	6a3b      	ldr	r3, [r7, #32]
 801a1fa:	2b00      	cmp	r3, #0
 801a1fc:	d122      	bne.n	801a244 <ip_reass+0x17c>
      goto nullreturn;
 801a1fe:	e0b7      	b.n	801a370 <ip_reass+0x2a8>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 801a200:	69bb      	ldr	r3, [r7, #24]
 801a202:	88db      	ldrh	r3, [r3, #6]
 801a204:	b29b      	uxth	r3, r3
 801a206:	4618      	mov	r0, r3
 801a208:	f7fe ffbe 	bl	8019188 <ntohs>
 801a20c:	4603      	mov	r3, r0
 801a20e:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801a212:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801a216:	2b00      	cmp	r3, #0
 801a218:	d114      	bne.n	801a244 <ip_reass+0x17c>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 801a21a:	6a3b      	ldr	r3, [r7, #32]
 801a21c:	89db      	ldrh	r3, [r3, #14]
 801a21e:	4618      	mov	r0, r3
 801a220:	f7fe ffb2 	bl	8019188 <ntohs>
 801a224:	4603      	mov	r3, r0
 801a226:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801a22a:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 801a22e:	2b00      	cmp	r3, #0
 801a230:	d008      	beq.n	801a244 <ip_reass+0x17c>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 801a232:	6a3b      	ldr	r3, [r7, #32]
 801a234:	f103 0308 	add.w	r3, r3, #8
 801a238:	4618      	mov	r0, r3
 801a23a:	69b9      	ldr	r1, [r7, #24]
 801a23c:	f04f 0214 	mov.w	r2, #20
 801a240:	f009 f9e8 	bl	8023614 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 801a244:	7cfb      	ldrb	r3, [r7, #19]
 801a246:	b29a      	uxth	r2, r3
 801a248:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a24c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a250:	881b      	ldrh	r3, [r3, #0]
 801a252:	18d3      	adds	r3, r2, r3
 801a254:	b29a      	uxth	r2, r3
 801a256:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a25a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a25e:	801a      	strh	r2, [r3, #0]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
 801a260:	69bb      	ldr	r3, [r7, #24]
 801a262:	88db      	ldrh	r3, [r3, #6]
 801a264:	b29b      	uxth	r3, r3
 801a266:	4618      	mov	r0, r3
 801a268:	f7fe ff8e 	bl	8019188 <ntohs>
 801a26c:	4603      	mov	r3, r0
 801a26e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801a272:	2b00      	cmp	r3, #0
 801a274:	d10c      	bne.n	801a290 <ip_reass+0x1c8>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 801a276:	6a3b      	ldr	r3, [r7, #32]
 801a278:	7f9b      	ldrb	r3, [r3, #30]
 801a27a:	f043 0301 	orr.w	r3, r3, #1
 801a27e:	b2da      	uxtb	r2, r3
 801a280:	6a3b      	ldr	r3, [r7, #32]
 801a282:	779a      	strb	r2, [r3, #30]
    ipr->datagram_len = offset + len;
 801a284:	8afa      	ldrh	r2, [r7, #22]
 801a286:	8abb      	ldrh	r3, [r7, #20]
 801a288:	18d3      	adds	r3, r2, r3
 801a28a:	b29a      	uxth	r2, r3
 801a28c:	6a3b      	ldr	r3, [r7, #32]
 801a28e:	839a      	strh	r2, [r3, #28]
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
 801a290:	6a38      	ldr	r0, [r7, #32]
 801a292:	6879      	ldr	r1, [r7, #4]
 801a294:	f7ff fdfa 	bl	8019e8c <ip_reass_chain_frag_into_datagram_and_validate>
 801a298:	4603      	mov	r3, r0
 801a29a:	2b00      	cmp	r3, #0
 801a29c:	d064      	beq.n	801a368 <ip_reass+0x2a0>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 801a29e:	6a3b      	ldr	r3, [r7, #32]
 801a2a0:	8b9b      	ldrh	r3, [r3, #28]
 801a2a2:	f103 0314 	add.w	r3, r3, #20
 801a2a6:	b29a      	uxth	r2, r3
 801a2a8:	6a3b      	ldr	r3, [r7, #32]
 801a2aa:	839a      	strh	r2, [r3, #28]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 801a2ac:	6a3b      	ldr	r3, [r7, #32]
 801a2ae:	685b      	ldr	r3, [r3, #4]
 801a2b0:	685b      	ldr	r3, [r3, #4]
 801a2b2:	681b      	ldr	r3, [r3, #0]
 801a2b4:	627b      	str	r3, [r7, #36]	; 0x24

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
 801a2b6:	6a3b      	ldr	r3, [r7, #32]
 801a2b8:	685b      	ldr	r3, [r3, #4]
 801a2ba:	685b      	ldr	r3, [r3, #4]
 801a2bc:	61bb      	str	r3, [r7, #24]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 801a2be:	6a3b      	ldr	r3, [r7, #32]
 801a2c0:	f103 0308 	add.w	r3, r3, #8
 801a2c4:	69b8      	ldr	r0, [r7, #24]
 801a2c6:	4619      	mov	r1, r3
 801a2c8:	f04f 0214 	mov.w	r2, #20
 801a2cc:	f009 f9a2 	bl	8023614 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 801a2d0:	6a3b      	ldr	r3, [r7, #32]
 801a2d2:	8b9b      	ldrh	r3, [r3, #28]
 801a2d4:	4618      	mov	r0, r3
 801a2d6:	f7fe ff3f 	bl	8019158 <htons>
 801a2da:	4603      	mov	r3, r0
 801a2dc:	461a      	mov	r2, r3
 801a2de:	69bb      	ldr	r3, [r7, #24]
 801a2e0:	805a      	strh	r2, [r3, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 801a2e2:	69bb      	ldr	r3, [r7, #24]
 801a2e4:	f04f 0200 	mov.w	r2, #0
 801a2e8:	719a      	strb	r2, [r3, #6]
 801a2ea:	f04f 0200 	mov.w	r2, #0
 801a2ee:	71da      	strb	r2, [r3, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 801a2f0:	69bb      	ldr	r3, [r7, #24]
 801a2f2:	f04f 0200 	mov.w	r2, #0
 801a2f6:	729a      	strb	r2, [r3, #10]
 801a2f8:	f04f 0200 	mov.w	r2, #0
 801a2fc:	72da      	strb	r2, [r3, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 801a2fe:	69b8      	ldr	r0, [r7, #24]
 801a300:	f04f 0114 	mov.w	r1, #20
 801a304:	f7ff f87e 	bl	8019404 <inet_chksum>
 801a308:	4603      	mov	r3, r0
 801a30a:	461a      	mov	r2, r3
 801a30c:	69bb      	ldr	r3, [r7, #24]
 801a30e:	815a      	strh	r2, [r3, #10]

    p = ipr->p;
 801a310:	6a3b      	ldr	r3, [r7, #32]
 801a312:	685b      	ldr	r3, [r3, #4]
 801a314:	607b      	str	r3, [r7, #4]

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 801a316:	e00e      	b.n	801a336 <ip_reass+0x26e>
      iprh = (struct ip_reass_helper*)r->payload;
 801a318:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a31a:	685b      	ldr	r3, [r3, #4]
 801a31c:	60fb      	str	r3, [r7, #12]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 801a31e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801a320:	f06f 0113 	mvn.w	r1, #19
 801a324:	f7f8 fd52 	bl	8012dcc <pbuf_header>
      pbuf_cat(p, r);
 801a328:	6878      	ldr	r0, [r7, #4]
 801a32a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801a32c:	f7f8 fe4a 	bl	8012fc4 <pbuf_cat>
      r = iprh->next_pbuf;
 801a330:	68fb      	ldr	r3, [r7, #12]
 801a332:	681b      	ldr	r3, [r3, #0]
 801a334:	627b      	str	r3, [r7, #36]	; 0x24
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 801a336:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a338:	2b00      	cmp	r3, #0
 801a33a:	d1ed      	bne.n	801a318 <ip_reass+0x250>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 801a33c:	6a38      	ldr	r0, [r7, #32]
 801a33e:	69f9      	ldr	r1, [r7, #28]
 801a340:	f7ff fd84 	bl	8019e4c <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 801a344:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a348:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a34c:	881c      	ldrh	r4, [r3, #0]
 801a34e:	6878      	ldr	r0, [r7, #4]
 801a350:	f7f8 fe0a 	bl	8012f68 <pbuf_clen>
 801a354:	4603      	mov	r3, r0
 801a356:	1ae3      	subs	r3, r4, r3
 801a358:	b29a      	uxth	r2, r3
 801a35a:	f245 53b0 	movw	r3, #21936	; 0x55b0
 801a35e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a362:	801a      	strh	r2, [r3, #0]

    /* Return the pbuf chain */
    return p;
 801a364:	687b      	ldr	r3, [r7, #4]
 801a366:	e008      	b.n	801a37a <ip_reass+0x2b2>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 801a368:	f04f 0300 	mov.w	r3, #0
 801a36c:	e005      	b.n	801a37a <ip_reass+0x2b2>
  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
 801a36e:	bf00      	nop
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 801a370:	6878      	ldr	r0, [r7, #4]
 801a372:	f7f8 fda5 	bl	8012ec0 <pbuf_free>
  return NULL;
 801a376:	f04f 0300 	mov.w	r3, #0
}
 801a37a:	4618      	mov	r0, r3
 801a37c:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 801a380:	46bd      	mov	sp, r7
 801a382:	bd90      	pop	{r4, r7, pc}

0801a384 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
 801a384:	b580      	push	{r7, lr}
 801a386:	b08c      	sub	sp, #48	; 0x30
 801a388:	af00      	add	r7, sp, #0
 801a38a:	60f8      	str	r0, [r7, #12]
 801a38c:	60b9      	str	r1, [r7, #8]
 801a38e:	607a      	str	r2, [r7, #4]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 801a390:	68bb      	ldr	r3, [r7, #8]
 801a392:	8c1b      	ldrh	r3, [r3, #32]
 801a394:	84fb      	strh	r3, [r7, #38]	; 0x26
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
 801a396:	f04f 0314 	mov.w	r3, #20
 801a39a:	857b      	strh	r3, [r7, #42]	; 0x2a
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
 801a39c:	f04f 0002 	mov.w	r0, #2
 801a3a0:	f04f 0100 	mov.w	r1, #0
 801a3a4:	f04f 0202 	mov.w	r2, #2
 801a3a8:	f7f8 fb82 	bl	8012ab0 <pbuf_alloc>
 801a3ac:	6238      	str	r0, [r7, #32]
  if (rambuf == NULL) {
 801a3ae:	6a3b      	ldr	r3, [r7, #32]
 801a3b0:	2b00      	cmp	r3, #0
 801a3b2:	d102      	bne.n	801a3ba <ip_frag+0x36>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
 801a3b4:	f04f 03ff 	mov.w	r3, #255	; 0xff
 801a3b8:	e0ce      	b.n	801a558 <ip_frag+0x1d4>
  }
  rambuf->tot_len = rambuf->len = mtu;
 801a3ba:	6a3b      	ldr	r3, [r7, #32]
 801a3bc:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801a3be:	815a      	strh	r2, [r3, #10]
 801a3c0:	6a3b      	ldr	r3, [r7, #32]
 801a3c2:	895a      	ldrh	r2, [r3, #10]
 801a3c4:	6a3b      	ldr	r3, [r7, #32]
 801a3c6:	811a      	strh	r2, [r3, #8]
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
 801a3c8:	f245 53b4 	movw	r3, #21940	; 0x55b4
 801a3cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a3d0:	f103 0303 	add.w	r3, r3, #3
 801a3d4:	f023 0303 	bic.w	r3, r3, #3
 801a3d8:	461a      	mov	r2, r3
 801a3da:	6a3b      	ldr	r3, [r7, #32]
 801a3dc:	605a      	str	r2, [r3, #4]

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
 801a3de:	6a3b      	ldr	r3, [r7, #32]
 801a3e0:	685b      	ldr	r3, [r3, #4]
 801a3e2:	61fb      	str	r3, [r7, #28]
  SMEMCPY(iphdr, p->payload, IP_HLEN);
 801a3e4:	68fb      	ldr	r3, [r7, #12]
 801a3e6:	685b      	ldr	r3, [r3, #4]
 801a3e8:	69f8      	ldr	r0, [r7, #28]
 801a3ea:	4619      	mov	r1, r3
 801a3ec:	f04f 0214 	mov.w	r2, #20
 801a3f0:	f009 f910 	bl	8023614 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 801a3f4:	69fb      	ldr	r3, [r7, #28]
 801a3f6:	88db      	ldrh	r3, [r3, #6]
 801a3f8:	b29b      	uxth	r3, r3
 801a3fa:	4618      	mov	r0, r3
 801a3fc:	f7fe fec4 	bl	8019188 <ntohs>
 801a400:	4603      	mov	r3, r0
 801a402:	853b      	strh	r3, [r7, #40]	; 0x28
  ofo = tmp & IP_OFFMASK;
 801a404:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801a406:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801a40a:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801a40e:	85bb      	strh	r3, [r7, #44]	; 0x2c
  omf = tmp & IP_MF;
 801a410:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801a412:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801a416:	837b      	strh	r3, [r7, #26]

  left = p->tot_len - IP_HLEN;
 801a418:	68fb      	ldr	r3, [r7, #12]
 801a41a:	891b      	ldrh	r3, [r3, #8]
 801a41c:	f1a3 0314 	sub.w	r3, r3, #20
 801a420:	85fb      	strh	r3, [r7, #46]	; 0x2e

  nfb = (mtu - IP_HLEN) / 8;
 801a422:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801a424:	f1a3 0314 	sub.w	r3, r3, #20
 801a428:	2b00      	cmp	r3, #0
 801a42a:	da01      	bge.n	801a430 <ip_frag+0xac>
 801a42c:	f103 0307 	add.w	r3, r3, #7
 801a430:	ea4f 03e3 	mov.w	r3, r3, asr #3
 801a434:	833b      	strh	r3, [r7, #24]

  while (left) {
 801a436:	e086      	b.n	801a546 <ip_frag+0x1c2>
    last = (left <= mtu - IP_HLEN);
 801a438:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801a43a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801a43c:	f1a3 0314 	sub.w	r3, r3, #20
 801a440:	429a      	cmp	r2, r3
 801a442:	bfcc      	ite	gt
 801a444:	2300      	movgt	r3, #0
 801a446:	2301      	movle	r3, #1
 801a448:	b2db      	uxtb	r3, r3
 801a44a:	82fb      	strh	r3, [r7, #22]

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 801a44c:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801a44e:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801a452:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801a456:	b29a      	uxth	r2, r3
 801a458:	8b7b      	ldrh	r3, [r7, #26]
 801a45a:	4313      	orrs	r3, r2
 801a45c:	853b      	strh	r3, [r7, #40]	; 0x28
    if (!last)
 801a45e:	8afb      	ldrh	r3, [r7, #22]
 801a460:	2b00      	cmp	r3, #0
 801a462:	d103      	bne.n	801a46c <ip_frag+0xe8>
      tmp = tmp | IP_MF;
 801a464:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801a466:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 801a46a:	853b      	strh	r3, [r7, #40]	; 0x28

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 801a46c:	8afb      	ldrh	r3, [r7, #22]
 801a46e:	2b00      	cmp	r3, #0
 801a470:	d104      	bne.n	801a47c <ip_frag+0xf8>
 801a472:	8b3b      	ldrh	r3, [r7, #24]
 801a474:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801a478:	b29b      	uxth	r3, r3
 801a47a:	e000      	b.n	801a47e <ip_frag+0xfa>
 801a47c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801a47e:	82bb      	strh	r3, [r7, #20]

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 801a480:	69fb      	ldr	r3, [r7, #28]
 801a482:	f103 0114 	add.w	r1, r3, #20
 801a486:	8aba      	ldrh	r2, [r7, #20]
 801a488:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801a48a:	68f8      	ldr	r0, [r7, #12]
 801a48c:	f7f8 fe8e 	bl	80131ac <pbuf_copy_partial>
 801a490:	4603      	mov	r3, r0
 801a492:	461a      	mov	r2, r3
 801a494:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801a496:	18d3      	adds	r3, r2, r3
 801a498:	857b      	strh	r3, [r7, #42]	; 0x2a
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 801a49a:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801a49c:	4618      	mov	r0, r3
 801a49e:	f7fe fe5b 	bl	8019158 <htons>
 801a4a2:	4603      	mov	r3, r0
 801a4a4:	461a      	mov	r2, r3
 801a4a6:	69fb      	ldr	r3, [r7, #28]
 801a4a8:	80da      	strh	r2, [r3, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 801a4aa:	8abb      	ldrh	r3, [r7, #20]
 801a4ac:	f103 0314 	add.w	r3, r3, #20
 801a4b0:	b29b      	uxth	r3, r3
 801a4b2:	4618      	mov	r0, r3
 801a4b4:	f7fe fe50 	bl	8019158 <htons>
 801a4b8:	4603      	mov	r3, r0
 801a4ba:	461a      	mov	r2, r3
 801a4bc:	69fb      	ldr	r3, [r7, #28]
 801a4be:	805a      	strh	r2, [r3, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 801a4c0:	69fb      	ldr	r3, [r7, #28]
 801a4c2:	f04f 0200 	mov.w	r2, #0
 801a4c6:	729a      	strb	r2, [r3, #10]
 801a4c8:	f04f 0200 	mov.w	r2, #0
 801a4cc:	72da      	strb	r2, [r3, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 801a4ce:	69f8      	ldr	r0, [r7, #28]
 801a4d0:	f04f 0114 	mov.w	r1, #20
 801a4d4:	f7fe ff96 	bl	8019404 <inet_chksum>
 801a4d8:	4603      	mov	r3, r0
 801a4da:	461a      	mov	r2, r3
 801a4dc:	69fb      	ldr	r3, [r7, #28]
 801a4de:	815a      	strh	r2, [r3, #10]

#if IP_FRAG_USES_STATIC_BUF
    if (last)
 801a4e0:	8afb      	ldrh	r3, [r7, #22]
 801a4e2:	2b00      	cmp	r3, #0
 801a4e4:	d007      	beq.n	801a4f6 <ip_frag+0x172>
      pbuf_realloc(rambuf, left + IP_HLEN);
 801a4e6:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801a4e8:	f103 0314 	add.w	r3, r3, #20
 801a4ec:	b29b      	uxth	r3, r3
 801a4ee:	6a38      	ldr	r0, [r7, #32]
 801a4f0:	4619      	mov	r1, r3
 801a4f2:	f7f8 fc05 	bl	8012d00 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
 801a4f6:	f04f 0002 	mov.w	r0, #2
 801a4fa:	f04f 0100 	mov.w	r1, #0
 801a4fe:	f04f 0200 	mov.w	r2, #0
 801a502:	f7f8 fad5 	bl	8012ab0 <pbuf_alloc>
 801a506:	6138      	str	r0, [r7, #16]
    if (header != NULL) {
 801a508:	693b      	ldr	r3, [r7, #16]
 801a50a:	2b00      	cmp	r3, #0
 801a50c:	d015      	beq.n	801a53a <ip_frag+0x1b6>
      pbuf_chain(header, rambuf);
 801a50e:	6938      	ldr	r0, [r7, #16]
 801a510:	6a39      	ldr	r1, [r7, #32]
 801a512:	f7f8 fd85 	bl	8013020 <pbuf_chain>
      netif->output(netif, header, dest);
 801a516:	68bb      	ldr	r3, [r7, #8]
 801a518:	695b      	ldr	r3, [r3, #20]
 801a51a:	68b8      	ldr	r0, [r7, #8]
 801a51c:	6939      	ldr	r1, [r7, #16]
 801a51e:	687a      	ldr	r2, [r7, #4]
 801a520:	4798      	blx	r3
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
 801a522:	6938      	ldr	r0, [r7, #16]
 801a524:	f7f8 fccc 	bl	8012ec0 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 801a528:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801a52a:	8abb      	ldrh	r3, [r7, #20]
 801a52c:	1ad3      	subs	r3, r2, r3
 801a52e:	85fb      	strh	r3, [r7, #46]	; 0x2e
    ofo += nfb;
 801a530:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 801a532:	8b3b      	ldrh	r3, [r7, #24]
 801a534:	18d3      	adds	r3, r2, r3
 801a536:	85bb      	strh	r3, [r7, #44]	; 0x2c
 801a538:	e005      	b.n	801a546 <ip_frag+0x1c2>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
 801a53a:	6a38      	ldr	r0, [r7, #32]
 801a53c:	f7f8 fcc0 	bl	8012ec0 <pbuf_free>
      return ERR_MEM;
 801a540:	f04f 03ff 	mov.w	r3, #255	; 0xff
 801a544:	e008      	b.n	801a558 <ip_frag+0x1d4>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 801a546:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801a548:	2b00      	cmp	r3, #0
 801a54a:	f47f af75 	bne.w	801a438 <ip_frag+0xb4>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
 801a54e:	6a38      	ldr	r0, [r7, #32]
 801a550:	f7f8 fcb6 	bl	8012ec0 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 801a554:	f04f 0300 	mov.w	r3, #0
 801a558:	b25b      	sxtb	r3, r3
}
 801a55a:	4618      	mov	r0, r3
 801a55c:	f107 0730 	add.w	r7, r7, #48	; 0x30
 801a560:	46bd      	mov	sp, r7
 801a562:	bd80      	pop	{r7, pc}

0801a564 <PHY_InitializeDevice>:
/**
 *
 * This function initializes Ethernet PHY
 */
status_t  PHY_InitializeDevice (void)
{
 801a564:	b580      	push	{r7, lr}
 801a566:	b082      	sub	sp, #8
 801a568:	af00      	add	r7, sp, #0
  /* <<<DD_ETHPHY_API_1>>> */
  uint16_t RegData = 0; /* Initialize to 0 */
 801a56a:	f04f 0300 	mov.w	r3, #0
 801a56e:	807b      	strh	r3, [r7, #2]
  status_t Status = (uint32_t)PHY_INIT_ERROR;
 801a570:	f04f 0301 	mov.w	r3, #1
 801a574:	607b      	str	r3, [r7, #4]
  BOOLType IsLinkUp = FALSE;
 801a576:	f04f 0300 	mov.w	r3, #0
 801a57a:	707b      	strb	r3, [r7, #1]

  DBG002_FUNCTION_ENTRY(APP_GID,ETH002_FUNCTION_ENTRY);
  do
  {
    Status = PHY_lResetPHY();
 801a57c:	f000 f90a 	bl	801a794 <PHY_lResetPHY>
 801a580:	6078      	str	r0, [r7, #4]
    if (Status != DAVEApp_SUCCESS)
 801a582:	687b      	ldr	r3, [r7, #4]
 801a584:	2b00      	cmp	r3, #0
 801a586:	d10d      	bne.n	801a5a4 <PHY_InitializeDevice+0x40>
    {
      DBG002_ERROR(APP_GID, PHY_INIT_ERROR, 0, NULL);
      break;
    }
#if AUTO_NEGO
    Status = PHY_lPerformLinkNegotiation();
 801a588:	f000 f952 	bl	801a830 <PHY_lPerformLinkNegotiation>
 801a58c:	6078      	str	r0, [r7, #4]
    if (Status != DAVEApp_SUCCESS)
 801a58e:	687b      	ldr	r3, [r7, #4]
 801a590:	2b00      	cmp	r3, #0
 801a592:	d109      	bne.n	801a5a8 <PHY_InitializeDevice+0x44>
                          

#endif

    /* check for LINK is up... */
    IsLinkUp = PHY_IsLinkUP();
 801a594:	f000 f810 	bl	801a5b8 <PHY_IsLinkUP>
 801a598:	4603      	mov	r3, r0
 801a59a:	707b      	strb	r3, [r7, #1]
    }


    /* PHY Initialization is successful */
    DBG002_INFO(APP_GID, PHY_INIT_SUCCSS, 0, NULL);
    Status = DAVEApp_SUCCESS;
 801a59c:	f04f 0300 	mov.w	r3, #0
 801a5a0:	607b      	str	r3, [r7, #4]
 801a5a2:	e002      	b.n	801a5aa <PHY_InitializeDevice+0x46>
  {
    Status = PHY_lResetPHY();
    if (Status != DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, PHY_INIT_ERROR, 0, NULL);
      break;
 801a5a4:	bf00      	nop
 801a5a6:	e000      	b.n	801a5aa <PHY_InitializeDevice+0x46>
#if AUTO_NEGO
    Status = PHY_lPerformLinkNegotiation();
    if (Status != DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, PHY_INIT_ERROR, 0, NULL);
      break;
 801a5a8:	bf00      	nop
    DBG002_INFO(APP_GID, PHY_INIT_SUCCSS, 0, NULL);
    Status = DAVEApp_SUCCESS;
  }while(0);

  DBG002_FUNCTION_EXIT(APP_GID,ETH002_FUNCTION_EXIT);
  return Status;
 801a5aa:	687b      	ldr	r3, [r7, #4]
}
 801a5ac:	4618      	mov	r0, r3
 801a5ae:	f107 0708 	add.w	r7, r7, #8
 801a5b2:	46bd      	mov	sp, r7
 801a5b4:	bd80      	pop	{r7, pc}
 801a5b6:	bf00      	nop

0801a5b8 <PHY_IsLinkUP>:
 * The function returns Link status of Ethernet PHY
 *
 * @return: True if Link is UP, False otherwise
 */
BOOLType PHY_IsLinkUP (void)
{
 801a5b8:	b580      	push	{r7, lr}
 801a5ba:	b084      	sub	sp, #16
 801a5bc:	af00      	add	r7, sp, #0
  /* <<<DD_ETHPHY_API_2>>> */
  BOOLType IsLinkUP = FALSE;
 801a5be:	f04f 0300 	mov.w	r3, #0
 801a5c2:	73fb      	strb	r3, [r7, #15]
  uint16_t RegData = (uint16_t)0U;  /* Initialize to 0 */
 801a5c4:	f04f 0300 	mov.w	r3, #0
 801a5c8:	80fb      	strh	r3, [r7, #6]
  uint16_t RegData1 = (uint16_t)0U; /* Initialize to 0 */
 801a5ca:	f04f 0300 	mov.w	r3, #0
 801a5ce:	80bb      	strh	r3, [r7, #4]
  status_t Status = (status_t)DAVEApp_SUCCESS;
 801a5d0:	f04f 0300 	mov.w	r3, #0
 801a5d4:	60bb      	str	r3, [r7, #8]

  DBG002_FUNCTION_ENTRY(APP_GID,ETH002_FUNCTION_ENTRY);
  Status = (status_t)PHY_lReadReg((uint32_t)PHY_BASE_ADDRESS,
 801a5d6:	f107 0306 	add.w	r3, r7, #6
 801a5da:	f04f 0000 	mov.w	r0, #0
 801a5de:	f04f 0101 	mov.w	r1, #1
 801a5e2:	461a      	mov	r2, r3
 801a5e4:	f000 f820 	bl	801a628 <PHY_lReadReg>
 801a5e8:	60b8      	str	r0, [r7, #8]
                         (uint32_t)BASIC_MODE_STATUS_REG,
                         &RegData);
  if (Status != (status_t)DAVEApp_SUCCESS)
 801a5ea:	68bb      	ldr	r3, [r7, #8]
 801a5ec:	2b00      	cmp	r3, #0
 801a5ee:	d114      	bne.n	801a61a <PHY_IsLinkUP+0x62>
  {
	DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
  }
  else
  {
    Status =  (status_t)PHY_lReadReg((uint32_t)PHY_BASE_ADDRESS,
 801a5f0:	f107 0304 	add.w	r3, r7, #4
 801a5f4:	f04f 0000 	mov.w	r0, #0
 801a5f8:	f04f 0101 	mov.w	r1, #1
 801a5fc:	461a      	mov	r2, r3
 801a5fe:	f000 f813 	bl	801a628 <PHY_lReadReg>
 801a602:	60b8      	str	r0, [r7, #8]
                         (uint32_t)BASIC_MODE_STATUS_REG,
                         &RegData1);
    if (Status != (status_t)DAVEApp_SUCCESS)
 801a604:	68bb      	ldr	r3, [r7, #8]
 801a606:	2b00      	cmp	r3, #0
 801a608:	d107      	bne.n	801a61a <PHY_IsLinkUP+0x62>
    {
      DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
    }
    else if (RegData1 & (uint16_t)Mii_LINK_STATUS)
 801a60a:	88bb      	ldrh	r3, [r7, #4]
 801a60c:	f003 0304 	and.w	r3, r3, #4
 801a610:	2b00      	cmp	r3, #0
 801a612:	d002      	beq.n	801a61a <PHY_IsLinkUP+0x62>
    {
      DBG002_INFO(APP_GID, PHY_LINK_UP, 0, NULL);
      IsLinkUP = TRUE;
 801a614:	f04f 0301 	mov.w	r3, #1
 801a618:	73fb      	strb	r3, [r7, #15]
    {
      DBG002_INFO(APP_GID, PHY_LINK_DOWN, 0, NULL);
    }
  }
  DBG002_FUNCTION_EXIT(APP_GID,ETH002_FUNCTION_EXIT);
  return IsLinkUP;
 801a61a:	7bfb      	ldrb	r3, [r7, #15]
}
 801a61c:	4618      	mov	r0, r3
 801a61e:	f107 0710 	add.w	r7, r7, #16
 801a622:	46bd      	mov	sp, r7
 801a624:	bd80      	pop	{r7, pc}
 801a626:	bf00      	nop

0801a628 <PHY_lReadReg>:
(
  uint32_t PhyBase,
  uint32_t RegOffset,
  uint16_t *RegData
)
{
 801a628:	b580      	push	{r7, lr}
 801a62a:	b088      	sub	sp, #32
 801a62c:	af00      	add	r7, sp, #0
 801a62e:	60f8      	str	r0, [r7, #12]
 801a630:	60b9      	str	r1, [r7, #8]
 801a632:	607a      	str	r2, [r7, #4]
  ETH_GLOBAL_TypeDef *GMACRegs = (ETH_GLOBAL_TypeDef *) ETH0_BASE;
 801a634:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 801a638:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801a63c:	617b      	str	r3, [r7, #20]
  uint32_t Address;
  uint32_t LoopVariable;
  status_t Status = (uint32_t)PHY_READ_ERROR;
 801a63e:	f04f 0302 	mov.w	r3, #2
 801a642:	61bb      	str	r3, [r7, #24]

  DBG002_FUNCTION_ENTRY(APP_GID,ETH002_FUNCTION_ENTRY);

  Address = ((PhyBase << (uint32_t)GmiiDevShift) & (uint32_t)GmiiDevMask) |
 801a644:	68fb      	ldr	r3, [r7, #12]
 801a646:	ea4f 23c3 	mov.w	r3, r3, lsl #11
 801a64a:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801a64e:	ea4f 4313 	mov.w	r3, r3, lsr #16
        ((RegOffset << (uint32_t)GmiiRegShift) & (uint32_t)GmiiRegMask);
 801a652:	68ba      	ldr	r2, [r7, #8]
 801a654:	ea4f 1282 	mov.w	r2, r2, lsl #6
 801a658:	f402 62f8 	and.w	r2, r2, #1984	; 0x7c0
  uint32_t LoopVariable;
  status_t Status = (uint32_t)PHY_READ_ERROR;

  DBG002_FUNCTION_ENTRY(APP_GID,ETH002_FUNCTION_ENTRY);

  Address = ((PhyBase << (uint32_t)GmiiDevShift) & (uint32_t)GmiiDevMask) |
 801a65c:	4313      	orrs	r3, r2
 801a65e:	613b      	str	r3, [r7, #16]
        ((RegOffset << (uint32_t)GmiiRegShift) & (uint32_t)GmiiRegMask);

  Address = Address | (uint32_t)GmiiBusy; /* Gmii busy bit */
 801a660:	693b      	ldr	r3, [r7, #16]
 801a662:	f043 0301 	orr.w	r3, r3, #1
 801a666:	613b      	str	r3, [r7, #16]
  /* write the Addressess from where the data to be read in GmiiGmiiAddr
   * register of synopGMAC ip
   */
  GMACRegs->GMII_ADDRESS = Address;
 801a668:	697b      	ldr	r3, [r7, #20]
 801a66a:	693a      	ldr	r2, [r7, #16]
 801a66c:	611a      	str	r2, [r3, #16]

  for(LoopVariable = (uint32_t)0U; LoopVariable < (uint32_t)BUSY_WAIT_LOOP_COUNT; LoopVariable++)
 801a66e:	f04f 0300 	mov.w	r3, #0
 801a672:	61fb      	str	r3, [r7, #28]
 801a674:	e018      	b.n	801a6a8 <PHY_lReadReg+0x80>
  {
    /* Wait till the busy bit gets cleared with in a certain amount of time */
    if ((GMACRegs->GMII_ADDRESS & (uint32_t)GmiiBusy) != (uint32_t)1U)
 801a676:	697b      	ldr	r3, [r7, #20]
 801a678:	691b      	ldr	r3, [r3, #16]
 801a67a:	f003 0301 	and.w	r3, r3, #1
 801a67e:	2b00      	cmp	r3, #0
 801a680:	d018      	beq.n	801a6b4 <PHY_lReadReg+0x8c>
    {
      break;
    }

	if(NULL != PHYtimerCallback)
 801a682:	f246 537c 	movw	r3, #25980	; 0x657c
 801a686:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a68a:	681b      	ldr	r3, [r3, #0]
 801a68c:	2b00      	cmp	r3, #0
 801a68e:	d007      	beq.n	801a6a0 <PHY_lReadReg+0x78>
	{
		PHYtimerCallback(PHY_REG_OPERATION_WAIT_TIME);
 801a690:	f246 537c 	movw	r3, #25980	; 0x657c
 801a694:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a698:	681b      	ldr	r3, [r3, #0]
 801a69a:	f04f 000a 	mov.w	r0, #10
 801a69e:	4798      	blx	r3
  /* write the Addressess from where the data to be read in GmiiGmiiAddr
   * register of synopGMAC ip
   */
  GMACRegs->GMII_ADDRESS = Address;

  for(LoopVariable = (uint32_t)0U; LoopVariable < (uint32_t)BUSY_WAIT_LOOP_COUNT; LoopVariable++)
 801a6a0:	69fb      	ldr	r3, [r7, #28]
 801a6a2:	f103 0301 	add.w	r3, r3, #1
 801a6a6:	61fb      	str	r3, [r7, #28]
 801a6a8:	69fa      	ldr	r2, [r7, #28]
 801a6aa:	f240 33e7 	movw	r3, #999	; 0x3e7
 801a6ae:	429a      	cmp	r2, r3
 801a6b0:	d9e1      	bls.n	801a676 <PHY_lReadReg+0x4e>
 801a6b2:	e000      	b.n	801a6b6 <PHY_lReadReg+0x8e>
  {
    /* Wait till the busy bit gets cleared with in a certain amount of time */
    if ((GMACRegs->GMII_ADDRESS & (uint32_t)GmiiBusy) != (uint32_t)1U)
    {
      break;
 801a6b4:	bf00      	nop
		PHYtimerCallback(PHY_REG_OPERATION_WAIT_TIME);
	}

  }

  if(LoopVariable < (uint32_t)BUSY_WAIT_LOOP_COUNT)
 801a6b6:	69fa      	ldr	r2, [r7, #28]
 801a6b8:	f240 33e7 	movw	r3, #999	; 0x3e7
 801a6bc:	429a      	cmp	r2, r3
 801a6be:	d807      	bhi.n	801a6d0 <PHY_lReadReg+0xa8>
  {
    *RegData =   (uint16_t)((uint32_t)GMACRegs->GMII_DATA & (uint32_t)0xFFFFU);
 801a6c0:	697b      	ldr	r3, [r7, #20]
 801a6c2:	695b      	ldr	r3, [r3, #20]
 801a6c4:	b29a      	uxth	r2, r3
 801a6c6:	687b      	ldr	r3, [r7, #4]
 801a6c8:	801a      	strh	r2, [r3, #0]
     Status = (status_t)DAVEApp_SUCCESS;
 801a6ca:	f04f 0300 	mov.w	r3, #0
 801a6ce:	61bb      	str	r3, [r7, #24]
  else
  {
    DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
  }
  DBG002_FUNCTION_EXIT(APP_GID,ETH002_FUNCTION_EXIT);
  return Status;
 801a6d0:	69bb      	ldr	r3, [r7, #24]
}
 801a6d2:	4618      	mov	r0, r3
 801a6d4:	f107 0720 	add.w	r7, r7, #32
 801a6d8:	46bd      	mov	sp, r7
 801a6da:	bd80      	pop	{r7, pc}

0801a6dc <PHY_lWriteReg>:
(
  uint32_t PhyBase,
  uint32_t RegOffset,
  uint16_t Data
)
{
 801a6dc:	b580      	push	{r7, lr}
 801a6de:	b088      	sub	sp, #32
 801a6e0:	af00      	add	r7, sp, #0
 801a6e2:	60f8      	str	r0, [r7, #12]
 801a6e4:	60b9      	str	r1, [r7, #8]
 801a6e6:	4613      	mov	r3, r2
 801a6e8:	80fb      	strh	r3, [r7, #6]
  ETH_GLOBAL_TypeDef *GMACRegs = (ETH_GLOBAL_TypeDef *) ETH0_BASE;
 801a6ea:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 801a6ee:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801a6f2:	617b      	str	r3, [r7, #20]
  uint32_t Address;
  uint32_t LoopVariable;
  status_t Status = (uint32_t)PHY_WRITE_ERROR;
 801a6f4:	f04f 0303 	mov.w	r3, #3
 801a6f8:	61bb      	str	r3, [r7, #24]

  DBG002_FUNCTION_ENTRY(APP_GID,ETH002_FUNCTION_ENTRY);

  /* write the data in to GmacGmiiData register of synopGMAC IP */
  GMACRegs->GMII_DATA = Data;
 801a6fa:	88fa      	ldrh	r2, [r7, #6]
 801a6fc:	697b      	ldr	r3, [r7, #20]
 801a6fe:	615a      	str	r2, [r3, #20]

  Address = ((PhyBase << (uint32_t)GmiiDevShift) & (uint32_t)GmiiDevMask) |
 801a700:	68fb      	ldr	r3, [r7, #12]
 801a702:	ea4f 23c3 	mov.w	r3, r3, lsl #11
 801a706:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801a70a:	ea4f 4313 	mov.w	r3, r3, lsr #16
        ((RegOffset << (uint32_t)GmiiRegShift) & (uint32_t)GmiiRegMask) | (uint32_t)GmiiWrite;
 801a70e:	68ba      	ldr	r2, [r7, #8]
 801a710:	ea4f 1282 	mov.w	r2, r2, lsl #6
 801a714:	f402 62f8 	and.w	r2, r2, #1984	; 0x7c0
  DBG002_FUNCTION_ENTRY(APP_GID,ETH002_FUNCTION_ENTRY);

  /* write the data in to GmacGmiiData register of synopGMAC IP */
  GMACRegs->GMII_DATA = Data;

  Address = ((PhyBase << (uint32_t)GmiiDevShift) & (uint32_t)GmiiDevMask) |
 801a718:	4313      	orrs	r3, r2
 801a71a:	f043 0302 	orr.w	r3, r3, #2
 801a71e:	613b      	str	r3, [r7, #16]
        ((RegOffset << (uint32_t)GmiiRegShift) & (uint32_t)GmiiRegMask) | (uint32_t)GmiiWrite;

  /* set Gmii clk to 20-35 Mhz and Gmii busy bit */
  Address = Address | (uint32_t)GmiiBusy;
 801a720:	693b      	ldr	r3, [r7, #16]
 801a722:	f043 0301 	orr.w	r3, r3, #1
 801a726:	613b      	str	r3, [r7, #16]

  GMACRegs->GMII_ADDRESS = Address;
 801a728:	697b      	ldr	r3, [r7, #20]
 801a72a:	693a      	ldr	r2, [r7, #16]
 801a72c:	611a      	str	r2, [r3, #16]

  for(LoopVariable = (uint32_t)0U; LoopVariable < (uint32_t)BUSY_WAIT_LOOP_COUNT; LoopVariable++)
 801a72e:	f04f 0300 	mov.w	r3, #0
 801a732:	61fb      	str	r3, [r7, #28]
 801a734:	e018      	b.n	801a768 <PHY_lWriteReg+0x8c>
  {
    if ((GMACRegs->GMII_ADDRESS & (uint32_t)GmiiBusy) != (uint32_t)1U)
 801a736:	697b      	ldr	r3, [r7, #20]
 801a738:	691b      	ldr	r3, [r3, #16]
 801a73a:	f003 0301 	and.w	r3, r3, #1
 801a73e:	2b00      	cmp	r3, #0
 801a740:	d018      	beq.n	801a774 <PHY_lWriteReg+0x98>
    {
      break;
    }
	if(NULL != PHYtimerCallback)
 801a742:	f246 537c 	movw	r3, #25980	; 0x657c
 801a746:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a74a:	681b      	ldr	r3, [r3, #0]
 801a74c:	2b00      	cmp	r3, #0
 801a74e:	d007      	beq.n	801a760 <PHY_lWriteReg+0x84>
	{
		PHYtimerCallback(PHY_REG_OPERATION_WAIT_TIME);
 801a750:	f246 537c 	movw	r3, #25980	; 0x657c
 801a754:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a758:	681b      	ldr	r3, [r3, #0]
 801a75a:	f04f 000a 	mov.w	r0, #10
 801a75e:	4798      	blx	r3
  /* set Gmii clk to 20-35 Mhz and Gmii busy bit */
  Address = Address | (uint32_t)GmiiBusy;

  GMACRegs->GMII_ADDRESS = Address;

  for(LoopVariable = (uint32_t)0U; LoopVariable < (uint32_t)BUSY_WAIT_LOOP_COUNT; LoopVariable++)
 801a760:	69fb      	ldr	r3, [r7, #28]
 801a762:	f103 0301 	add.w	r3, r3, #1
 801a766:	61fb      	str	r3, [r7, #28]
 801a768:	69fa      	ldr	r2, [r7, #28]
 801a76a:	f240 33e7 	movw	r3, #999	; 0x3e7
 801a76e:	429a      	cmp	r2, r3
 801a770:	d9e1      	bls.n	801a736 <PHY_lWriteReg+0x5a>
 801a772:	e000      	b.n	801a776 <PHY_lWriteReg+0x9a>
  {
    if ((GMACRegs->GMII_ADDRESS & (uint32_t)GmiiBusy) != (uint32_t)1U)
    {
      break;
 801a774:	bf00      	nop
	{
		PHYtimerCallback(PHY_REG_OPERATION_WAIT_TIME);
	}
  }

  if(LoopVariable < (uint32_t)BUSY_WAIT_LOOP_COUNT)
 801a776:	69fa      	ldr	r2, [r7, #28]
 801a778:	f240 33e7 	movw	r3, #999	; 0x3e7
 801a77c:	429a      	cmp	r2, r3
 801a77e:	d802      	bhi.n	801a786 <PHY_lWriteReg+0xaa>
  {
    Status = (status_t)DAVEApp_SUCCESS;
 801a780:	f04f 0300 	mov.w	r3, #0
 801a784:	61bb      	str	r3, [r7, #24]
  {
	  DBG002_ERROR(APP_GID, PHY_BUSY_BIT_NOT_CLEARED, 0, NULL);
  }

  DBG002_FUNCTION_EXIT(APP_GID,ETH002_FUNCTION_EXIT);
  return Status;
 801a786:	69bb      	ldr	r3, [r7, #24]
}
 801a788:	4618      	mov	r0, r3
 801a78a:	f107 0720 	add.w	r7, r7, #32
 801a78e:	46bd      	mov	sp, r7
 801a790:	bd80      	pop	{r7, pc}
 801a792:	bf00      	nop

0801a794 <PHY_lResetPHY>:
* @param[in] void
*
* @return Returns DAVEApp_SUCCESS on success else return the error status.
*/
static status_t PHY_lResetPHY(void)
{
 801a794:	b580      	push	{r7, lr}
 801a796:	b082      	sub	sp, #8
 801a798:	af00      	add	r7, sp, #0
  status_t  Status = (uint32_t)PHY_RESET_ERROR;
 801a79a:	f04f 0304 	mov.w	r3, #4
 801a79e:	607b      	str	r3, [r7, #4]
  uint16_t RegData =  (uint16_t)0; /* Initialize to 0 */
 801a7a0:	f04f 0300 	mov.w	r3, #0
 801a7a4:	807b      	strh	r3, [r7, #2]
  
  /* Reset Ethernet PHY */
  Status = PHY_lWriteReg ((uint32_t)PHY_BASE_ADDRESS,
 801a7a6:	887b      	ldrh	r3, [r7, #2]
 801a7a8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 801a7ac:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 801a7b0:	b29b      	uxth	r3, r3
 801a7b2:	f04f 0000 	mov.w	r0, #0
 801a7b6:	f04f 0100 	mov.w	r1, #0
 801a7ba:	461a      	mov	r2, r3
 801a7bc:	f7ff ff8e 	bl	801a6dc <PHY_lWriteReg>
 801a7c0:	6078      	str	r0, [r7, #4]
            (uint32_t)BASIC_MODE_CONTROL_REG,
            (uint16_t)(RegData | (uint32_t)Mii_RESET));
  if (Status != (status_t)DAVEApp_SUCCESS)
 801a7c2:	687b      	ldr	r3, [r7, #4]
 801a7c4:	2b00      	cmp	r3, #0
 801a7c6:	d12c      	bne.n	801a822 <PHY_lResetPHY+0x8e>
    DBG002_ERROR(APP_GID, PHY_RESET_ERROR, 0, NULL);
  }
  /* Wait for for reset to complete, actually 30 milliseconds @120Mhz CPU clock */
  else
  {
    if(NULL != PHYtimerCallback)
 801a7c8:	f246 537c 	movw	r3, #25980	; 0x657c
 801a7cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a7d0:	681b      	ldr	r3, [r3, #0]
 801a7d2:	2b00      	cmp	r3, #0
 801a7d4:	d007      	beq.n	801a7e6 <PHY_lResetPHY+0x52>
    {
    	PHYtimerCallback(RESET_COMPLETE_WAIT_PERIOD);
 801a7d6:	f246 537c 	movw	r3, #25980	; 0x657c
 801a7da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a7de:	681b      	ldr	r3, [r3, #0]
 801a7e0:	f04f 001e 	mov.w	r0, #30
 801a7e4:	4798      	blx	r3
    }
    /* Check if Ethernet PHY Reset is complete */
    Status = PHY_lReadReg ((uint32_t)PHY_BASE_ADDRESS,
 801a7e6:	f107 0302 	add.w	r3, r7, #2
 801a7ea:	f04f 0000 	mov.w	r0, #0
 801a7ee:	f04f 0100 	mov.w	r1, #0
 801a7f2:	461a      	mov	r2, r3
 801a7f4:	f7ff ff18 	bl	801a628 <PHY_lReadReg>
 801a7f8:	6078      	str	r0, [r7, #4]
                          (uint32_t)BASIC_MODE_CONTROL_REG,
                          &RegData);
    if (Status != (status_t)DAVEApp_SUCCESS)
 801a7fa:	687b      	ldr	r3, [r7, #4]
 801a7fc:	2b00      	cmp	r3, #0
 801a7fe:	d110      	bne.n	801a822 <PHY_lResetPHY+0x8e>
    {
      DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
    }
    else
    {
      if ((RegData & (uint32_t)Mii_RESET) == (uint32_t)Mii_RESET)
 801a800:	887b      	ldrh	r3, [r7, #2]
 801a802:	b29b      	uxth	r3, r3
 801a804:	b21b      	sxth	r3, r3
 801a806:	2b00      	cmp	r3, #0
 801a808:	db0b      	blt.n	801a822 <PHY_lResetPHY+0x8e>
        DBG002_ERROR(APP_GID, PHY_RESET_ERROR, 0, NULL);
      }
      else
      {
        /* Read PHY ID to check if the correct PHY is used */
        Status = PHY_lReadReg ((uint32_t)PHY_BASE_ADDRESS,
 801a80a:	f107 0302 	add.w	r3, r7, #2
 801a80e:	f04f 0000 	mov.w	r0, #0
 801a812:	f04f 0102 	mov.w	r1, #2
 801a816:	461a      	mov	r2, r3
 801a818:	f7ff ff06 	bl	801a628 <PHY_lReadReg>
 801a81c:	6078      	str	r0, [r7, #4]
                          (uint32_t)PHY_ID_REG_1,
                          &RegData);
        if (Status != (status_t)DAVEApp_SUCCESS)
 801a81e:	687b      	ldr	r3, [r7, #4]
 801a820:	2b00      	cmp	r3, #0
#endif
        }
      }
    }
  }
  return Status;
 801a822:	687b      	ldr	r3, [r7, #4]
}
 801a824:	4618      	mov	r0, r3
 801a826:	f107 0708 	add.w	r7, r7, #8
 801a82a:	46bd      	mov	sp, r7
 801a82c:	bd80      	pop	{r7, pc}
 801a82e:	bf00      	nop

0801a830 <PHY_lPerformLinkNegotiation>:
* @param[in] void
*
* @return Returns DAVEApp_SUCCESS on success else return the error status.
*/
static status_t PHY_lPerformLinkNegotiation(void)
{
 801a830:	b580      	push	{r7, lr}
 801a832:	b082      	sub	sp, #8
 801a834:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)PHY_READ_ERROR;
 801a836:	f04f 0302 	mov.w	r3, #2
 801a83a:	607b      	str	r3, [r7, #4]
  uint16_t RegData = (uint16_t)0; /* Initialize to 0 */
 801a83c:	f04f 0300 	mov.w	r3, #0
 801a840:	807b      	strh	r3, [r7, #2]

  Status = PHY_lReadReg ((uint32_t)PHY_BASE_ADDRESS,
 801a842:	f107 0302 	add.w	r3, r7, #2
 801a846:	f04f 0000 	mov.w	r0, #0
 801a84a:	f04f 0104 	mov.w	r1, #4
 801a84e:	461a      	mov	r2, r3
 801a850:	f7ff feea 	bl	801a628 <PHY_lReadReg>
 801a854:	6078      	str	r0, [r7, #4]
                          (uint32_t)AN_ADV_REG,
                          &RegData);
  if (Status != (status_t)DAVEApp_SUCCESS)
 801a856:	687b      	ldr	r3, [r7, #4]
 801a858:	2b00      	cmp	r3, #0
 801a85a:	d15e      	bne.n	801a91a <PHY_lPerformLinkNegotiation+0xea>
  {
    DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
  }
  else
  {
	  Status = PHY_lWriteReg ((uint32_t)PHY_BASE_ADDRESS,
 801a85c:	887b      	ldrh	r3, [r7, #2]
 801a85e:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 801a862:	b29b      	uxth	r3, r3
 801a864:	f04f 0000 	mov.w	r0, #0
 801a868:	f04f 0104 	mov.w	r1, #4
 801a86c:	461a      	mov	r2, r3
 801a86e:	f7ff ff35 	bl	801a6dc <PHY_lWriteReg>
 801a872:	6078      	str	r0, [r7, #4]
              (uint32_t)AN_ADV_REG,
              (uint16_t)(RegData | (uint32_t)0xC00));
    if (Status != (status_t)DAVEApp_SUCCESS)
 801a874:	687b      	ldr	r3, [r7, #4]
 801a876:	2b00      	cmp	r3, #0
 801a878:	d14f      	bne.n	801a91a <PHY_lPerformLinkNegotiation+0xea>
    {
      DBG002_ERROR(APP_GID, PHY_RESET_ERROR, 0, NULL);
    }
    else
    {
      Status = PHY_lReadReg ((uint32_t)PHY_BASE_ADDRESS,
 801a87a:	f107 0302 	add.w	r3, r7, #2
 801a87e:	f04f 0000 	mov.w	r0, #0
 801a882:	f04f 0100 	mov.w	r1, #0
 801a886:	461a      	mov	r2, r3
 801a888:	f7ff fece 	bl	801a628 <PHY_lReadReg>
 801a88c:	6078      	str	r0, [r7, #4]
                          (uint32_t)BASIC_MODE_CONTROL_REG,
                          &RegData);
      if (Status != (status_t)DAVEApp_SUCCESS)
 801a88e:	687b      	ldr	r3, [r7, #4]
 801a890:	2b00      	cmp	r3, #0
 801a892:	d142      	bne.n	801a91a <PHY_lPerformLinkNegotiation+0xea>
      {
        DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
      }
      else
      {
        Status = PHY_lWriteReg ((uint32_t)PHY_BASE_ADDRESS,
 801a894:	887b      	ldrh	r3, [r7, #2]
 801a896:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 801a89a:	b29b      	uxth	r3, r3
 801a89c:	f04f 0000 	mov.w	r0, #0
 801a8a0:	f04f 0100 	mov.w	r1, #0
 801a8a4:	461a      	mov	r2, r3
 801a8a6:	f7ff ff19 	bl	801a6dc <PHY_lWriteReg>
 801a8aa:	6078      	str	r0, [r7, #4]
              (uint32_t)BASIC_MODE_CONTROL_REG,
              (uint16_t)(RegData | (uint32_t)Mii_AUTONEGO));
        if (Status != (status_t)DAVEApp_SUCCESS)
 801a8ac:	687b      	ldr	r3, [r7, #4]
 801a8ae:	2b00      	cmp	r3, #0
 801a8b0:	d133      	bne.n	801a91a <PHY_lPerformLinkNegotiation+0xea>
        {
          DBG002_ERROR(APP_GID, PHY_RESET_ERROR, 0, NULL);
        }
        else
        {
	        if(NULL != PHYtimerCallback)
 801a8b2:	f246 537c 	movw	r3, #25980	; 0x657c
 801a8b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a8ba:	681b      	ldr	r3, [r3, #0]
 801a8bc:	2b00      	cmp	r3, #0
 801a8be:	d007      	beq.n	801a8d0 <PHY_lPerformLinkNegotiation+0xa0>
	        {
	          PHYtimerCallback(RESET_COMPLETE_WAIT_PERIOD);
 801a8c0:	f246 537c 	movw	r3, #25980	; 0x657c
 801a8c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a8c8:	681b      	ldr	r3, [r3, #0]
 801a8ca:	f04f 001e 	mov.w	r0, #30
 801a8ce:	4798      	blx	r3
	        }
          do
          {
          }while(PHY_lIsAutoNegoComplete() != TRUE);
 801a8d0:	f000 f82a 	bl	801a928 <PHY_lIsAutoNegoComplete>
 801a8d4:	4603      	mov	r3, r0
 801a8d6:	2b01      	cmp	r3, #1
 801a8d8:	d1fa      	bne.n	801a8d0 <PHY_lPerformLinkNegotiation+0xa0>
          if(((uint32_t)RegData & (uint32_t)Mii_AUTO_NEGO_COMPLETE) != (uint32_t)0)
 801a8da:	887b      	ldrh	r3, [r7, #2]
 801a8dc:	f003 0320 	and.w	r3, r3, #32
 801a8e0:	2b00      	cmp	r3, #0
 801a8e2:	d003      	beq.n	801a8ec <PHY_lPerformLinkNegotiation+0xbc>
          {
            DBG002_INFO(APP_GID, PHY_AUTO_NEGO_COMPLETE, 0, NULL);
            Status = (status_t)DAVEApp_SUCCESS;
 801a8e4:	f04f 0300 	mov.w	r3, #0
 801a8e8:	607b      	str	r3, [r7, #4]
 801a8ea:	e016      	b.n	801a91a <PHY_lPerformLinkNegotiation+0xea>
          }
          else
          {
	          Status = PHY_lReadReg ((uint32_t)PHY_BASE_ADDRESS,
 801a8ec:	f107 0302 	add.w	r3, r7, #2
 801a8f0:	f04f 0000 	mov.w	r0, #0
 801a8f4:	f04f 0105 	mov.w	r1, #5
 801a8f8:	461a      	mov	r2, r3
 801a8fa:	f7ff fe95 	bl	801a628 <PHY_lReadReg>
 801a8fe:	6078      	str	r0, [r7, #4]
                          (uint32_t)LNK_PART_ABl_REG,
                          &RegData);
            if (Status != (status_t)DAVEApp_SUCCESS)
 801a900:	687b      	ldr	r3, [r7, #4]
 801a902:	2b00      	cmp	r3, #0
 801a904:	d109      	bne.n	801a91a <PHY_lPerformLinkNegotiation+0xea>
            {
              DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
            }
            else
            {
	            Status = PHY_lReadReg ((uint32_t)PHY_BASE_ADDRESS,
 801a906:	f107 0302 	add.w	r3, r7, #2
 801a90a:	f04f 0000 	mov.w	r0, #0
 801a90e:	f04f 0106 	mov.w	r1, #6
 801a912:	461a      	mov	r2, r3
 801a914:	f7ff fe88 	bl	801a628 <PHY_lReadReg>
 801a918:	6078      	str	r0, [r7, #4]
          }
        }
      }
    }
  }
  return Status;
 801a91a:	687b      	ldr	r3, [r7, #4]
}
 801a91c:	4618      	mov	r0, r3
 801a91e:	f107 0708 	add.w	r7, r7, #8
 801a922:	46bd      	mov	sp, r7
 801a924:	bd80      	pop	{r7, pc}
 801a926:	bf00      	nop

0801a928 <PHY_lIsAutoNegoComplete>:
* @param[in] void
*
* @return Returns TRUE is auto negotiation is complete, false otherwise.
*/
static BOOLType PHY_lIsAutoNegoComplete(void)
{
 801a928:	b580      	push	{r7, lr}
 801a92a:	b084      	sub	sp, #16
 801a92c:	af00      	add	r7, sp, #0
  uint16_t RegData = (uint16_t)0; /* Initialize to 0 */
 801a92e:	f04f 0300 	mov.w	r3, #0
 801a932:	807b      	strh	r3, [r7, #2]
  uint32_t LoopCount = (uint32_t)CHECK_AUTO_NEGO_TIME_COUNT;
 801a934:	f04f 0364 	mov.w	r3, #100	; 0x64
 801a938:	60fb      	str	r3, [r7, #12]
  status_t Status = (uint32_t)PHY_INIT_ERROR;
 801a93a:	f04f 0301 	mov.w	r3, #1
 801a93e:	607b      	str	r3, [r7, #4]
  BOOLType IsAutoNegoComplete = FALSE;
 801a940:	f04f 0300 	mov.w	r3, #0
 801a944:	72fb      	strb	r3, [r7, #11]

  while(LoopCount != (uint32_t)0)
 801a946:	e019      	b.n	801a97c <PHY_lIsAutoNegoComplete+0x54>
  {
    Status = PHY_lReadReg ((uint32_t)PHY_BASE_ADDRESS,
 801a948:	f107 0302 	add.w	r3, r7, #2
 801a94c:	f04f 0000 	mov.w	r0, #0
 801a950:	f04f 0101 	mov.w	r1, #1
 801a954:	461a      	mov	r2, r3
 801a956:	f7ff fe67 	bl	801a628 <PHY_lReadReg>
 801a95a:	6078      	str	r0, [r7, #4]
                      (uint32_t)BASIC_MODE_STATUS_REG,
                           &RegData);
    if(Status != (status_t)DAVEApp_SUCCESS)
 801a95c:	687b      	ldr	r3, [r7, #4]
 801a95e:	2b00      	cmp	r3, #0
 801a960:	d110      	bne.n	801a984 <PHY_lIsAutoNegoComplete+0x5c>
    {
      DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
      break;
    }
    if(((uint32_t)RegData & (uint32_t)Mii_AUTO_NEGO_COMPLETE) != (uint32_t)0)
 801a962:	887b      	ldrh	r3, [r7, #2]
 801a964:	f003 0320 	and.w	r3, r3, #32
 801a968:	2b00      	cmp	r3, #0
 801a96a:	d003      	beq.n	801a974 <PHY_lIsAutoNegoComplete+0x4c>
    {
      DBG002_INFO(APP_GID, PHY_AUTO_NEGO_COMPLETE, 0, NULL);
      IsAutoNegoComplete = TRUE;
 801a96c:	f04f 0301 	mov.w	r3, #1
 801a970:	72fb      	strb	r3, [r7, #11]
 801a972:	e003      	b.n	801a97c <PHY_lIsAutoNegoComplete+0x54>
    }
    else
    {
      LoopCount--;
 801a974:	68fb      	ldr	r3, [r7, #12]
 801a976:	f103 33ff 	add.w	r3, r3, #4294967295
 801a97a:	60fb      	str	r3, [r7, #12]
  uint16_t RegData = (uint16_t)0; /* Initialize to 0 */
  uint32_t LoopCount = (uint32_t)CHECK_AUTO_NEGO_TIME_COUNT;
  status_t Status = (uint32_t)PHY_INIT_ERROR;
  BOOLType IsAutoNegoComplete = FALSE;

  while(LoopCount != (uint32_t)0)
 801a97c:	68fb      	ldr	r3, [r7, #12]
 801a97e:	2b00      	cmp	r3, #0
 801a980:	d1e2      	bne.n	801a948 <PHY_lIsAutoNegoComplete+0x20>
 801a982:	e000      	b.n	801a986 <PHY_lIsAutoNegoComplete+0x5e>
                      (uint32_t)BASIC_MODE_STATUS_REG,
                           &RegData);
    if(Status != (status_t)DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, PHY_READ_ERROR, 0, NULL);
      break;
 801a984:	bf00      	nop
    else
    {
      LoopCount--;
    }
  }
  if((uint32_t)0 == LoopCount)
 801a986:	68fb      	ldr	r3, [r7, #12]
 801a988:	2b00      	cmp	r3, #0
 801a98a:	d102      	bne.n	801a992 <PHY_lIsAutoNegoComplete+0x6a>
  {
  	 IsAutoNegoComplete = TRUE;
 801a98c:	f04f 0301 	mov.w	r3, #1
 801a990:	72fb      	strb	r3, [r7, #11]
  }
  return IsAutoNegoComplete;
 801a992:	7afb      	ldrb	r3, [r7, #11]
}
 801a994:	4618      	mov	r0, r3
 801a996:	f107 0710 	add.w	r7, r7, #16
 801a99a:	46bd      	mov	sp, r7
 801a99c:	bd80      	pop	{r7, pc}
 801a99e:	bf00      	nop

0801a9a0 <PHY_RegisterTimerCallback>:
/**
 * This function is a timer call back function
 *
 */
void PHY_RegisterTimerCallback(PHYTimerCallbackType Callback)
{
 801a9a0:	b480      	push	{r7}
 801a9a2:	b083      	sub	sp, #12
 801a9a4:	af00      	add	r7, sp, #0
 801a9a6:	6078      	str	r0, [r7, #4]
	PHYtimerCallback = Callback;
 801a9a8:	f246 537c 	movw	r3, #25980	; 0x657c
 801a9ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a9b0:	687a      	ldr	r2, [r7, #4]
 801a9b2:	601a      	str	r2, [r3, #0]
}
 801a9b4:	f107 070c 	add.w	r7, r7, #12
 801a9b8:	46bd      	mov	sp, r7
 801a9ba:	bc80      	pop	{r7}
 801a9bc:	4770      	bx	lr
 801a9be:	bf00      	nop

0801a9c0 <synopGMAC_set_tx_address>:




s32 synopGMAC_set_tx_address(synopGMACdevice * gmacdev,u32 count, u32 Buffer1)
{
 801a9c0:	b480      	push	{r7}
 801a9c2:	b087      	sub	sp, #28
 801a9c4:	af00      	add	r7, sp, #0
 801a9c6:	60f8      	str	r0, [r7, #12]
 801a9c8:	60b9      	str	r1, [r7, #8]
 801a9ca:	607a      	str	r2, [r7, #4]
	DmaDesc*  txdesc = &(gmacdev->TxDesc[count]);
 801a9cc:	68fb      	ldr	r3, [r7, #12]
 801a9ce:	6999      	ldr	r1, [r3, #24]
 801a9d0:	68ba      	ldr	r2, [r7, #8]
 801a9d2:	4613      	mov	r3, r2
 801a9d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801a9d8:	189b      	adds	r3, r3, r2
 801a9da:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801a9de:	18cb      	adds	r3, r1, r3
 801a9e0:	617b      	str	r3, [r7, #20]
	txdesc->buffer1 = Buffer1;
 801a9e2:	697b      	ldr	r3, [r7, #20]
 801a9e4:	687a      	ldr	r2, [r7, #4]
 801a9e6:	609a      	str	r2, [r3, #8]
	txdesc->data1 = Buffer1;
 801a9e8:	697b      	ldr	r3, [r7, #20]
 801a9ea:	687a      	ldr	r2, [r7, #4]
 801a9ec:	621a      	str	r2, [r3, #32]
	txdesc->buffer2 = 0;
 801a9ee:	697b      	ldr	r3, [r7, #20]
 801a9f0:	f04f 0200 	mov.w	r2, #0
 801a9f4:	60da      	str	r2, [r3, #12]
	txdesc->data2 = 0;
 801a9f6:	697b      	ldr	r3, [r7, #20]
 801a9f8:	f04f 0200 	mov.w	r2, #0
 801a9fc:	625a      	str	r2, [r3, #36]	; 0x24
	return 0;
 801a9fe:	f04f 0300 	mov.w	r3, #0
}
 801aa02:	4618      	mov	r0, r3
 801aa04:	f107 071c 	add.w	r7, r7, #28
 801aa08:	46bd      	mov	sp, r7
 801aa0a:	bc80      	pop	{r7}
 801aa0c:	4770      	bx	lr
 801aa0e:	bf00      	nop

0801aa10 <synopGMAC_RegisterOneShotTimerCallback>:

void synopGMAC_RegisterOneShotTimerCallback(SynopGMACTimerCallbackType Callback)
{
 801aa10:	b480      	push	{r7}
 801aa12:	b083      	sub	sp, #12
 801aa14:	af00      	add	r7, sp, #0
 801aa16:	6078      	str	r0, [r7, #4]
	SynopGMACOneShotTimerCallback = Callback;
 801aa18:	f645 3394 	movw	r3, #23444	; 0x5b94
 801aa1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aa20:	687a      	ldr	r2, [r7, #4]
 801aa22:	601a      	str	r2, [r3, #0]
}
 801aa24:	f107 070c 	add.w	r7, r7, #12
 801aa28:	46bd      	mov	sp, r7
 801aa2a:	bc80      	pop	{r7}
 801aa2c:	4770      	bx	lr
 801aa2e:	bf00      	nop

0801aa30 <synopGMAC_set_mdc_clk_div>:
  * @param[in] pointer to device structure.
  * @param[in] clk divider value.
  * \return Reuturns 0 on success else return the error value.
  */
s32 synopGMAC_set_mdc_clk_div(synopGMACdevice *gmacdev,u32 clk_div_val)
{
 801aa30:	b580      	push	{r7, lr}
 801aa32:	b084      	sub	sp, #16
 801aa34:	af00      	add	r7, sp, #0
 801aa36:	6078      	str	r0, [r7, #4]
 801aa38:	6039      	str	r1, [r7, #0]
	u32 orig_data;
	orig_data = synopGMACReadReg((u32 *)gmacdev->MacBase,GmacGmiiAddr); //set the mdc clock to the user defined value
 801aa3a:	687b      	ldr	r3, [r7, #4]
 801aa3c:	681b      	ldr	r3, [r3, #0]
 801aa3e:	4618      	mov	r0, r3
 801aa40:	f04f 0110 	mov.w	r1, #16
 801aa44:	f002 fdae 	bl	801d5a4 <synopGMACReadReg>
 801aa48:	60f8      	str	r0, [r7, #12]
	orig_data &= (~ GmiiCsrClkMask);	   
 801aa4a:	68fb      	ldr	r3, [r7, #12]
 801aa4c:	f023 033c 	bic.w	r3, r3, #60	; 0x3c
 801aa50:	60fb      	str	r3, [r7, #12]
	orig_data |= clk_div_val;
 801aa52:	68fa      	ldr	r2, [r7, #12]
 801aa54:	683b      	ldr	r3, [r7, #0]
 801aa56:	4313      	orrs	r3, r2
 801aa58:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->MacBase, GmacGmiiAddr ,orig_data);
 801aa5a:	687b      	ldr	r3, [r7, #4]
 801aa5c:	681b      	ldr	r3, [r3, #0]
 801aa5e:	4618      	mov	r0, r3
 801aa60:	f04f 0110 	mov.w	r1, #16
 801aa64:	68fa      	ldr	r2, [r7, #12]
 801aa66:	f002 fdaf 	bl	801d5c8 <synopGMACWriteReg>
	return 0;
 801aa6a:	f04f 0300 	mov.w	r3, #0
}
 801aa6e:	4618      	mov	r0, r3
 801aa70:	f107 0710 	add.w	r7, r7, #16
 801aa74:	46bd      	mov	sp, r7
 801aa76:	bd80      	pop	{r7, pc}

0801aa78 <synopGMAC_get_mdc_clk_div>:
  * @param[in] pointer to device structure.
  * @param[in] clk divider value.
  * \return Returns the MDC divider value read.
  */
u32 synopGMAC_get_mdc_clk_div(synopGMACdevice *gmacdev)
{
 801aa78:	b580      	push	{r7, lr}
 801aa7a:	b084      	sub	sp, #16
 801aa7c:	af00      	add	r7, sp, #0
 801aa7e:	6078      	str	r0, [r7, #4]
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->MacBase,GmacGmiiAddr);
 801aa80:	687b      	ldr	r3, [r7, #4]
 801aa82:	681b      	ldr	r3, [r3, #0]
 801aa84:	4618      	mov	r0, r3
 801aa86:	f04f 0110 	mov.w	r1, #16
 801aa8a:	f002 fd8b 	bl	801d5a4 <synopGMACReadReg>
 801aa8e:	60f8      	str	r0, [r7, #12]
	data &= GmiiCsrClkMask;
 801aa90:	68fb      	ldr	r3, [r7, #12]
 801aa92:	f003 033c 	and.w	r3, r3, #60	; 0x3c
 801aa96:	60fb      	str	r3, [r7, #12]
	return data;
 801aa98:	68fb      	ldr	r3, [r7, #12]
}
 801aa9a:	4618      	mov	r0, r3
 801aa9c:	f107 0710 	add.w	r7, r7, #16
 801aaa0:	46bd      	mov	sp, r7
 801aaa2:	bd80      	pop	{r7, pc}

0801aaa4 <synopGMAC_read_version>:
  * @param[in] pointer to synopGMACdevice.
  * \return Always return 0.
  */

s32 synopGMAC_read_version (synopGMACdevice * gmacdev) 
{	
 801aaa4:	b580      	push	{r7, lr}
 801aaa6:	b084      	sub	sp, #16
 801aaa8:	af00      	add	r7, sp, #0
 801aaaa:	6078      	str	r0, [r7, #4]
	u32 data = 0;
 801aaac:	f04f 0300 	mov.w	r3, #0
 801aab0:	60fb      	str	r3, [r7, #12]
 
	data = synopGMACReadReg((u32 *)gmacdev->MacBase, GmacVersion );
 801aab2:	687b      	ldr	r3, [r7, #4]
 801aab4:	681b      	ldr	r3, [r3, #0]
 801aab6:	4618      	mov	r0, r3
 801aab8:	f04f 0120 	mov.w	r1, #32
 801aabc:	f002 fd72 	bl	801d5a4 <synopGMACReadReg>
 801aac0:	60f8      	str	r0, [r7, #12]
	gmacdev->Version = data;
 801aac2:	687b      	ldr	r3, [r7, #4]
 801aac4:	68fa      	ldr	r2, [r7, #12]
 801aac6:	60da      	str	r2, [r3, #12]

	// TR("The data read from %08x is %08x\n",(gmacdev->MacBase+GmacVersion),data);
	return 0;
 801aac8:	f04f 0300 	mov.w	r3, #0
}
 801aacc:	4618      	mov	r0, r3
 801aace:	f107 0710 	add.w	r7, r7, #16
 801aad2:	46bd      	mov	sp, r7
 801aad4:	bd80      	pop	{r7, pc}
 801aad6:	bf00      	nop

0801aad8 <synopGMAC_rmii_100mbps_enable>:
  * Enables the RMII 100Mbps mode. 
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_rmii_100mbps_enable(synopGMACdevice * gmacdev)
{
 801aad8:	b580      	push	{r7, lr}
 801aada:	b082      	sub	sp, #8
 801aadc:	af00      	add	r7, sp, #0
 801aade:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacFESpeed100);
 801aae0:	687b      	ldr	r3, [r7, #4]
 801aae2:	681b      	ldr	r3, [r3, #0]
 801aae4:	4618      	mov	r0, r3
 801aae6:	f04f 0100 	mov.w	r1, #0
 801aaea:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 801aaee:	f002 fd7d 	bl	801d5ec <synopGMACSetBits>
	return;
 801aaf2:	bf00      	nop
}
 801aaf4:	f107 0708 	add.w	r7, r7, #8
 801aaf8:	46bd      	mov	sp, r7
 801aafa:	bd80      	pop	{r7, pc}

0801aafc <synopGMAC_reset>:
  * This reests the DMA and GMAC core. After reset all the registers holds their respective reset value
  * @param[in] pointer to synopGMACdevice.
  * \return 0 on success else return the error status.
  */
s32 synopGMAC_reset (synopGMACdevice * gmacdev ) 
{	
 801aafc:	b580      	push	{r7, lr}
 801aafe:	b084      	sub	sp, #16
 801ab00:	af00      	add	r7, sp, #0
 801ab02:	6078      	str	r0, [r7, #4]
	u32 data = 0;
 801ab04:	f04f 0300 	mov.w	r3, #0
 801ab08:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaBusMode ,DmaResetOn);
 801ab0a:	687b      	ldr	r3, [r7, #4]
 801ab0c:	685b      	ldr	r3, [r3, #4]
 801ab0e:	4618      	mov	r0, r3
 801ab10:	f04f 0100 	mov.w	r1, #0
 801ab14:	f04f 0201 	mov.w	r2, #1
 801ab18:	f002 fd56 	bl	801d5c8 <synopGMACWriteReg>

	/* Find out the correct DEFAULT_LOOP_VARIABLE for IFX platform */

    //    synopGMAC_Wait(WAIT_TIME_TO_RESET);
		if(NULL != SynopGMACOneShotTimerCallback)
 801ab1c:	f645 3394 	movw	r3, #23444	; 0x5b94
 801ab20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ab24:	681b      	ldr	r3, [r3, #0]
 801ab26:	2b00      	cmp	r3, #0
 801ab28:	d009      	beq.n	801ab3e <synopGMAC_reset+0x42>
		{
				SynopGMACOneShotTimerCallback(WAIT_TIME_TO_RESET);
 801ab2a:	f645 3394 	movw	r3, #23444	; 0x5b94
 801ab2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ab32:	681b      	ldr	r3, [r3, #0]
 801ab34:	f04f 0001 	mov.w	r0, #1
 801ab38:	4798      	blx	r3
 801ab3a:	e000      	b.n	801ab3e <synopGMAC_reset+0x42>
	
		if( (data & DmaResetOn) == DmaResetOff)
		{
			break;
		}
	}
 801ab3c:	bf00      	nop
		}


	while (1)
	{
		data = synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaBusMode);
 801ab3e:	687b      	ldr	r3, [r7, #4]
 801ab40:	685b      	ldr	r3, [r3, #4]
 801ab42:	4618      	mov	r0, r3
 801ab44:	f04f 0100 	mov.w	r1, #0
 801ab48:	f002 fd2c 	bl	801d5a4 <synopGMACReadReg>
 801ab4c:	60f8      	str	r0, [r7, #12]
		//TR("DATA after Reset = %08x\n",data);
	
		if( (data & DmaResetOn) == DmaResetOff)
 801ab4e:	68fb      	ldr	r3, [r7, #12]
 801ab50:	f003 0301 	and.w	r3, r3, #1
 801ab54:	2b00      	cmp	r3, #0
 801ab56:	d1f1      	bne.n	801ab3c <synopGMAC_reset+0x40>
		{
			break;
 801ab58:	bf00      	nop
		}
	}
	return 0;	
 801ab5a:	f04f 0300 	mov.w	r3, #0
}
 801ab5e:	4618      	mov	r0, r3
 801ab60:	f107 0710 	add.w	r7, r7, #16
 801ab64:	46bd      	mov	sp, r7
 801ab66:	bd80      	pop	{r7, pc}

0801ab68 <synopGMAC_dma_bus_mode_init>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] the data to be programmed.
  * \return 0 on success else return the error status.
  */
s32 synopGMAC_dma_bus_mode_init(synopGMACdevice * gmacdev, u32 init_value )
{
 801ab68:	b580      	push	{r7, lr}
 801ab6a:	b082      	sub	sp, #8
 801ab6c:	af00      	add	r7, sp, #0
 801ab6e:	6078      	str	r0, [r7, #4]
 801ab70:	6039      	str	r1, [r7, #0]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaBusMode ,init_value);
 801ab72:	687b      	ldr	r3, [r7, #4]
 801ab74:	685b      	ldr	r3, [r3, #4]
 801ab76:	4618      	mov	r0, r3
 801ab78:	f04f 0100 	mov.w	r1, #0
 801ab7c:	683a      	ldr	r2, [r7, #0]
 801ab7e:	f002 fd23 	bl	801d5c8 <synopGMACWriteReg>
	return 0;
 801ab82:	f04f 0300 	mov.w	r3, #0

}
 801ab86:	4618      	mov	r0, r3
 801ab88:	f107 0708 	add.w	r7, r7, #8
 801ab8c:	46bd      	mov	sp, r7
 801ab8e:	bd80      	pop	{r7, pc}

0801ab90 <synopGMAC_dma_control_init>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] the data to be programmed.
  * \return 0 on success else return the error status.
  */
s32 synopGMAC_dma_control_init(synopGMACdevice * gmacdev, u32 init_value)
{
 801ab90:	b580      	push	{r7, lr}
 801ab92:	b082      	sub	sp, #8
 801ab94:	af00      	add	r7, sp, #0
 801ab96:	6078      	str	r0, [r7, #4]
 801ab98:	6039      	str	r1, [r7, #0]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaControl, init_value);
 801ab9a:	687b      	ldr	r3, [r7, #4]
 801ab9c:	685b      	ldr	r3, [r3, #4]
 801ab9e:	4618      	mov	r0, r3
 801aba0:	f04f 0118 	mov.w	r1, #24
 801aba4:	683a      	ldr	r2, [r7, #0]
 801aba6:	f002 fd0f 	bl	801d5c8 <synopGMACWriteReg>
	return 0;
 801abaa:	f04f 0300 	mov.w	r3, #0
}
 801abae:	4618      	mov	r0, r3
 801abb0:	f107 0708 	add.w	r7, r7, #8
 801abb4:	46bd      	mov	sp, r7
 801abb6:	bd80      	pop	{r7, pc}

0801abb8 <synopGMAC_wd_enable>:
  * 2048 bytes of data (10,240 if Jumbo frame enabled).
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_wd_enable(synopGMACdevice * gmacdev)
{
 801abb8:	b580      	push	{r7, lr}
 801abba:	b082      	sub	sp, #8
 801abbc:	af00      	add	r7, sp, #0
 801abbe:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacWatchdog);
 801abc0:	687b      	ldr	r3, [r7, #4]
 801abc2:	681b      	ldr	r3, [r3, #0]
 801abc4:	4618      	mov	r0, r3
 801abc6:	f04f 0100 	mov.w	r1, #0
 801abca:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 801abce:	f002 fd27 	bl	801d620 <synopGMACClearBits>
	return;
 801abd2:	bf00      	nop
}
 801abd4:	f107 0708 	add.w	r7, r7, #8
 801abd8:	46bd      	mov	sp, r7
 801abda:	bd80      	pop	{r7, pc}

0801abdc <synopGMAC_wd_disable>:
  * 16,384 bytes.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_wd_disable(synopGMACdevice * gmacdev)
{
 801abdc:	b580      	push	{r7, lr}
 801abde:	b082      	sub	sp, #8
 801abe0:	af00      	add	r7, sp, #0
 801abe2:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacWatchdog);
 801abe4:	687b      	ldr	r3, [r7, #4]
 801abe6:	681b      	ldr	r3, [r3, #0]
 801abe8:	4618      	mov	r0, r3
 801abea:	f04f 0100 	mov.w	r1, #0
 801abee:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 801abf2:	f002 fcfb 	bl	801d5ec <synopGMACSetBits>
	return;
 801abf6:	bf00      	nop
}
 801abf8:	f107 0708 	add.w	r7, r7, #8
 801abfc:	46bd      	mov	sp, r7
 801abfe:	bd80      	pop	{r7, pc}

0801ac00 <synopGMAC_jab_enable>:
  * When enabled, GMAC disabled the jabber timer, and can transfer 16,384 byte frames.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_jab_enable(synopGMACdevice * gmacdev)
{
 801ac00:	b580      	push	{r7, lr}
 801ac02:	b082      	sub	sp, #8
 801ac04:	af00      	add	r7, sp, #0
 801ac06:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacJabber);
 801ac08:	687b      	ldr	r3, [r7, #4]
 801ac0a:	681b      	ldr	r3, [r3, #0]
 801ac0c:	4618      	mov	r0, r3
 801ac0e:	f04f 0100 	mov.w	r1, #0
 801ac12:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 801ac16:	f002 fce9 	bl	801d5ec <synopGMACSetBits>
	return;
 801ac1a:	bf00      	nop
}
 801ac1c:	f107 0708 	add.w	r7, r7, #8
 801ac20:	46bd      	mov	sp, r7
 801ac22:	bd80      	pop	{r7, pc}

0801ac24 <synopGMAC_jab_disable>:
  * sends more than 2048 bytes of data (10240 if Jumbo frame enabled).
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_jab_disable(synopGMACdevice * gmacdev)
{
 801ac24:	b580      	push	{r7, lr}
 801ac26:	b082      	sub	sp, #8
 801ac28:	af00      	add	r7, sp, #0
 801ac2a:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacJabber);
 801ac2c:	687b      	ldr	r3, [r7, #4]
 801ac2e:	681b      	ldr	r3, [r3, #0]
 801ac30:	4618      	mov	r0, r3
 801ac32:	f04f 0100 	mov.w	r1, #0
 801ac36:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 801ac3a:	f002 fcf1 	bl	801d620 <synopGMACClearBits>
	return;
 801ac3e:	bf00      	nop
}
 801ac40:	f107 0708 	add.w	r7, r7, #8
 801ac44:	46bd      	mov	sp, r7
 801ac46:	bd80      	pop	{r7, pc}

0801ac48 <synopGMAC_frame_burst_enable>:
  * Reserved in 10/100 and Full-Duplex configurations.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_frame_burst_enable(synopGMACdevice * gmacdev)
{
 801ac48:	b580      	push	{r7, lr}
 801ac4a:	b082      	sub	sp, #8
 801ac4c:	af00      	add	r7, sp, #0
 801ac4e:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacFrameBurst);
 801ac50:	687b      	ldr	r3, [r7, #4]
 801ac52:	681b      	ldr	r3, [r3, #0]
 801ac54:	4618      	mov	r0, r3
 801ac56:	f04f 0100 	mov.w	r1, #0
 801ac5a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 801ac5e:	f002 fcc5 	bl	801d5ec <synopGMACSetBits>
	return;
 801ac62:	bf00      	nop
}
 801ac64:	f107 0708 	add.w	r7, r7, #8
 801ac68:	46bd      	mov	sp, r7
 801ac6a:	bd80      	pop	{r7, pc}

0801ac6c <synopGMAC_frame_burst_disable>:
  * When Disabled, frame bursting is not supported.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_frame_burst_disable(synopGMACdevice * gmacdev)
{
 801ac6c:	b580      	push	{r7, lr}
 801ac6e:	b082      	sub	sp, #8
 801ac70:	af00      	add	r7, sp, #0
 801ac72:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacFrameBurst);
 801ac74:	687b      	ldr	r3, [r7, #4]
 801ac76:	681b      	ldr	r3, [r3, #0]
 801ac78:	4618      	mov	r0, r3
 801ac7a:	f04f 0100 	mov.w	r1, #0
 801ac7e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 801ac82:	f002 fccd 	bl	801d620 <synopGMACClearBits>
	return;
 801ac86:	bf00      	nop
}
 801ac88:	f107 0708 	add.w	r7, r7, #8
 801ac8c:	46bd      	mov	sp, r7
 801ac8e:	bd80      	pop	{r7, pc}

0801ac90 <synopGMAC_jumbo_frame_enable>:
  * Giant frame error is not reported in receive frame status.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_jumbo_frame_enable(synopGMACdevice * gmacdev)
{
 801ac90:	b580      	push	{r7, lr}
 801ac92:	b082      	sub	sp, #8
 801ac94:	af00      	add	r7, sp, #0
 801ac96:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacJumboFrame);
 801ac98:	687b      	ldr	r3, [r7, #4]
 801ac9a:	681b      	ldr	r3, [r3, #0]
 801ac9c:	4618      	mov	r0, r3
 801ac9e:	f04f 0100 	mov.w	r1, #0
 801aca2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 801aca6:	f002 fca1 	bl	801d5ec <synopGMACSetBits>
	return;
 801acaa:	bf00      	nop
}
 801acac:	f107 0708 	add.w	r7, r7, #8
 801acb0:	46bd      	mov	sp, r7
 801acb2:	bd80      	pop	{r7, pc}

0801acb4 <synopGMAC_jumbo_frame_disable>:
  * Giant frame error is reported in receive frame status.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_jumbo_frame_disable(synopGMACdevice * gmacdev)
{
 801acb4:	b580      	push	{r7, lr}
 801acb6:	b082      	sub	sp, #8
 801acb8:	af00      	add	r7, sp, #0
 801acba:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacJumboFrame);
 801acbc:	687b      	ldr	r3, [r7, #4]
 801acbe:	681b      	ldr	r3, [r3, #0]
 801acc0:	4618      	mov	r0, r3
 801acc2:	f04f 0100 	mov.w	r1, #0
 801acc6:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 801acca:	f002 fca9 	bl	801d620 <synopGMACClearBits>
	return;
 801acce:	bf00      	nop
}
 801acd0:	f107 0708 	add.w	r7, r7, #8
 801acd4:	46bd      	mov	sp, r7
 801acd6:	bd80      	pop	{r7, pc}

0801acd8 <synopGMAC_disable_crs>:
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */

void synopGMAC_disable_crs(synopGMACdevice * gmacdev)
{
 801acd8:	b580      	push	{r7, lr}
 801acda:	b082      	sub	sp, #8
 801acdc:	af00      	add	r7, sp, #0
 801acde:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacDisableCrs);
 801ace0:	687b      	ldr	r3, [r7, #4]
 801ace2:	681b      	ldr	r3, [r3, #0]
 801ace4:	4618      	mov	r0, r3
 801ace6:	f04f 0100 	mov.w	r1, #0
 801acea:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 801acee:	f002 fc7d 	bl	801d5ec <synopGMACSetBits>
	return;
 801acf2:	bf00      	nop
}
 801acf4:	f107 0708 	add.w	r7, r7, #8
 801acf8:	46bd      	mov	sp, r7
 801acfa:	bd80      	pop	{r7, pc}

0801acfc <synopGMAC_select_gmii>:
  * When called GMII (1000Mbps) port is selected (programmable only in 10/100/1000 Mbps configuration).
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_select_gmii(synopGMACdevice * gmacdev)
{
 801acfc:	b580      	push	{r7, lr}
 801acfe:	b082      	sub	sp, #8
 801ad00:	af00      	add	r7, sp, #0
 801ad02:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacMiiGmii);
 801ad04:	687b      	ldr	r3, [r7, #4]
 801ad06:	681b      	ldr	r3, [r3, #0]
 801ad08:	4618      	mov	r0, r3
 801ad0a:	f04f 0100 	mov.w	r1, #0
 801ad0e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 801ad12:	f002 fc85 	bl	801d620 <synopGMACClearBits>
	return;
 801ad16:	bf00      	nop
}
 801ad18:	f107 0708 	add.w	r7, r7, #8
 801ad1c:	46bd      	mov	sp, r7
 801ad1e:	bd80      	pop	{r7, pc}

0801ad20 <synopGMAC_select_mii>:
  * When called MII (10/100Mbps) port is selected (programmable only in 10/100/1000 Mbps configuration).
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_select_mii(synopGMACdevice * gmacdev)
{
 801ad20:	b580      	push	{r7, lr}
 801ad22:	b082      	sub	sp, #8
 801ad24:	af00      	add	r7, sp, #0
 801ad26:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacMiiGmii);
 801ad28:	687b      	ldr	r3, [r7, #4]
 801ad2a:	681b      	ldr	r3, [r3, #0]
 801ad2c:	4618      	mov	r0, r3
 801ad2e:	f04f 0100 	mov.w	r1, #0
 801ad32:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 801ad36:	f002 fc59 	bl	801d5ec <synopGMACSetBits>
	return;
 801ad3a:	bf00      	nop
}
 801ad3c:	f107 0708 	add.w	r7, r7, #8
 801ad40:	46bd      	mov	sp, r7
 801ad42:	bd80      	pop	{r7, pc}

0801ad44 <synopGMAC_rx_own_enable>:
  * When enaled GMAC receives all the packets given by phy while transmitting.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_rx_own_enable(synopGMACdevice * gmacdev)
{
 801ad44:	b580      	push	{r7, lr}
 801ad46:	b082      	sub	sp, #8
 801ad48:	af00      	add	r7, sp, #0
 801ad4a:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacRxOwn);
 801ad4c:	687b      	ldr	r3, [r7, #4]
 801ad4e:	681b      	ldr	r3, [r3, #0]
 801ad50:	4618      	mov	r0, r3
 801ad52:	f04f 0100 	mov.w	r1, #0
 801ad56:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 801ad5a:	f002 fc61 	bl	801d620 <synopGMACClearBits>
	return;
 801ad5e:	bf00      	nop
}
 801ad60:	f107 0708 	add.w	r7, r7, #8
 801ad64:	46bd      	mov	sp, r7
 801ad66:	bd80      	pop	{r7, pc}

0801ad68 <synopGMAC_rx_own_disable>:
  * When enaled GMAC disables the reception of frames when gmii_txen_o is asserted.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_rx_own_disable(synopGMACdevice * gmacdev)
{
 801ad68:	b580      	push	{r7, lr}
 801ad6a:	b082      	sub	sp, #8
 801ad6c:	af00      	add	r7, sp, #0
 801ad6e:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacRxOwn);
 801ad70:	687b      	ldr	r3, [r7, #4]
 801ad72:	681b      	ldr	r3, [r3, #0]
 801ad74:	4618      	mov	r0, r3
 801ad76:	f04f 0100 	mov.w	r1, #0
 801ad7a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 801ad7e:	f002 fc35 	bl	801d5ec <synopGMACSetBits>
	return;
 801ad82:	bf00      	nop
}
 801ad84:	f107 0708 	add.w	r7, r7, #8
 801ad88:	46bd      	mov	sp, r7
 801ad8a:	bd80      	pop	{r7, pc}

0801ad8c <synopGMAC_loopback_on>:
  * \return returns void.
  * \note (G)MII Receive clock is required for loopback to work properly, as transmit clock is
  * not looped back internally.
  */
void synopGMAC_loopback_on(synopGMACdevice * gmacdev)
{
 801ad8c:	b580      	push	{r7, lr}
 801ad8e:	b082      	sub	sp, #8
 801ad90:	af00      	add	r7, sp, #0
 801ad92:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacLoopback);
 801ad94:	687b      	ldr	r3, [r7, #4]
 801ad96:	681b      	ldr	r3, [r3, #0]
 801ad98:	4618      	mov	r0, r3
 801ad9a:	f04f 0100 	mov.w	r1, #0
 801ad9e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801ada2:	f002 fc23 	bl	801d5ec <synopGMACSetBits>
	return;
 801ada6:	bf00      	nop
}
 801ada8:	f107 0708 	add.w	r7, r7, #8
 801adac:	46bd      	mov	sp, r7
 801adae:	bd80      	pop	{r7, pc}

0801adb0 <synopGMAC_loopback_off>:
  * Sets the GMAC in Normal mode. 
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_loopback_off(synopGMACdevice * gmacdev)
{
 801adb0:	b580      	push	{r7, lr}
 801adb2:	b082      	sub	sp, #8
 801adb4:	af00      	add	r7, sp, #0
 801adb6:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacLoopback);
 801adb8:	687b      	ldr	r3, [r7, #4]
 801adba:	681b      	ldr	r3, [r3, #0]
 801adbc:	4618      	mov	r0, r3
 801adbe:	f04f 0100 	mov.w	r1, #0
 801adc2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 801adc6:	f002 fc2b 	bl	801d620 <synopGMACClearBits>
	return;
 801adca:	bf00      	nop
}
 801adcc:	f107 0708 	add.w	r7, r7, #8
 801add0:	46bd      	mov	sp, r7
 801add2:	bd80      	pop	{r7, pc}

0801add4 <synopGMAC_set_full_duplex>:
  * Sets the GMAC core in Full-Duplex mode. 
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_set_full_duplex(synopGMACdevice * gmacdev)
{
 801add4:	b580      	push	{r7, lr}
 801add6:	b082      	sub	sp, #8
 801add8:	af00      	add	r7, sp, #0
 801adda:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacDuplex);
 801addc:	687b      	ldr	r3, [r7, #4]
 801adde:	681b      	ldr	r3, [r3, #0]
 801ade0:	4618      	mov	r0, r3
 801ade2:	f04f 0100 	mov.w	r1, #0
 801ade6:	f44f 6200 	mov.w	r2, #2048	; 0x800
 801adea:	f002 fbff 	bl	801d5ec <synopGMACSetBits>
	return;
 801adee:	bf00      	nop
}
 801adf0:	f107 0708 	add.w	r7, r7, #8
 801adf4:	46bd      	mov	sp, r7
 801adf6:	bd80      	pop	{r7, pc}

0801adf8 <synopGMAC_set_half_duplex>:
  * Sets the GMAC core in Half-Duplex mode. 
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_set_half_duplex(synopGMACdevice * gmacdev)
{
 801adf8:	b580      	push	{r7, lr}
 801adfa:	b082      	sub	sp, #8
 801adfc:	af00      	add	r7, sp, #0
 801adfe:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacDuplex);
 801ae00:	687b      	ldr	r3, [r7, #4]
 801ae02:	681b      	ldr	r3, [r3, #0]
 801ae04:	4618      	mov	r0, r3
 801ae06:	f04f 0100 	mov.w	r1, #0
 801ae0a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 801ae0e:	f002 fc07 	bl	801d620 <synopGMACClearBits>
	return;
 801ae12:	bf00      	nop
}
 801ae14:	f107 0708 	add.w	r7, r7, #8
 801ae18:	46bd      	mov	sp, r7
 801ae1a:	bd80      	pop	{r7, pc}

0801ae1c <synopGMAC_retry_enable>:
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  * \note This function is tightly coupled with synopGMAC_back_off_limit(synopGMACdev *, u32).
  */
void synopGMAC_retry_enable(synopGMACdevice * gmacdev)
{
 801ae1c:	b580      	push	{r7, lr}
 801ae1e:	b082      	sub	sp, #8
 801ae20:	af00      	add	r7, sp, #0
 801ae22:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacRetry);
 801ae24:	687b      	ldr	r3, [r7, #4]
 801ae26:	681b      	ldr	r3, [r3, #0]
 801ae28:	4618      	mov	r0, r3
 801ae2a:	f04f 0100 	mov.w	r1, #0
 801ae2e:	f44f 7200 	mov.w	r2, #512	; 0x200
 801ae32:	f002 fbf5 	bl	801d620 <synopGMACClearBits>
	return;
 801ae36:	bf00      	nop
}
 801ae38:	f107 0708 	add.w	r7, r7, #8
 801ae3c:	46bd      	mov	sp, r7
 801ae3e:	bd80      	pop	{r7, pc}

0801ae40 <synopGMAC_retry_disable>:
  * transmission and report a frame abort with excessive collision in tranmit frame status. 
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_retry_disable(synopGMACdevice * gmacdev)
{
 801ae40:	b580      	push	{r7, lr}
 801ae42:	b082      	sub	sp, #8
 801ae44:	af00      	add	r7, sp, #0
 801ae46:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacRetry);
 801ae48:	687b      	ldr	r3, [r7, #4]
 801ae4a:	681b      	ldr	r3, [r3, #0]
 801ae4c:	4618      	mov	r0, r3
 801ae4e:	f04f 0100 	mov.w	r1, #0
 801ae52:	f44f 7200 	mov.w	r2, #512	; 0x200
 801ae56:	f002 fbc9 	bl	801d5ec <synopGMACSetBits>
	return;
 801ae5a:	bf00      	nop
}
 801ae5c:	f107 0708 	add.w	r7, r7, #8
 801ae60:	46bd      	mov	sp, r7
 801ae62:	bd80      	pop	{r7, pc}

0801ae64 <synopGMAC_pad_crc_strip_enable>:
  * 1501 bytes are passed to the application without stripping the Pad/FCS field. 
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_pad_crc_strip_enable(synopGMACdevice * gmacdev)
{
 801ae64:	b580      	push	{r7, lr}
 801ae66:	b082      	sub	sp, #8
 801ae68:	af00      	add	r7, sp, #0
 801ae6a:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacPadCrcStrip);
 801ae6c:	687b      	ldr	r3, [r7, #4]
 801ae6e:	681b      	ldr	r3, [r3, #0]
 801ae70:	4618      	mov	r0, r3
 801ae72:	f04f 0100 	mov.w	r1, #0
 801ae76:	f04f 0280 	mov.w	r2, #128	; 0x80
 801ae7a:	f002 fbb7 	bl	801d5ec <synopGMACSetBits>
	return;
 801ae7e:	bf00      	nop
}
 801ae80:	f107 0708 	add.w	r7, r7, #8
 801ae84:	46bd      	mov	sp, r7
 801ae86:	bd80      	pop	{r7, pc}

0801ae88 <synopGMAC_pad_crc_strip_disable>:
  * GMAC will pass all the incoming frames to Host unmodified. 
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_pad_crc_strip_disable(synopGMACdevice * gmacdev)
{
 801ae88:	b580      	push	{r7, lr}
 801ae8a:	b082      	sub	sp, #8
 801ae8c:	af00      	add	r7, sp, #0
 801ae8e:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacPadCrcStrip);
 801ae90:	687b      	ldr	r3, [r7, #4]
 801ae92:	681b      	ldr	r3, [r3, #0]
 801ae94:	4618      	mov	r0, r3
 801ae96:	f04f 0100 	mov.w	r1, #0
 801ae9a:	f04f 0280 	mov.w	r2, #128	; 0x80
 801ae9e:	f002 fbbf 	bl	801d620 <synopGMACClearBits>
	return;
 801aea2:	bf00      	nop
}
 801aea4:	f107 0708 	add.w	r7, r7, #8
 801aea8:	46bd      	mov	sp, r7
 801aeaa:	bd80      	pop	{r7, pc}

0801aeac <synopGMAC_back_off_limit>:
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  * \note This function is tightly coupled with synopGMAC_retry_enable(synopGMACdevice * gmacdev)
  */
void synopGMAC_back_off_limit(synopGMACdevice * gmacdev, u32 value)
{
 801aeac:	b580      	push	{r7, lr}
 801aeae:	b084      	sub	sp, #16
 801aeb0:	af00      	add	r7, sp, #0
 801aeb2:	6078      	str	r0, [r7, #4]
 801aeb4:	6039      	str	r1, [r7, #0]
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->MacBase, GmacConfig);
 801aeb6:	687b      	ldr	r3, [r7, #4]
 801aeb8:	681b      	ldr	r3, [r3, #0]
 801aeba:	4618      	mov	r0, r3
 801aebc:	f04f 0100 	mov.w	r1, #0
 801aec0:	f002 fb70 	bl	801d5a4 <synopGMACReadReg>
 801aec4:	60f8      	str	r0, [r7, #12]
	data &= (~GmacBackoffLimit);
 801aec6:	68fb      	ldr	r3, [r7, #12]
 801aec8:	f023 0360 	bic.w	r3, r3, #96	; 0x60
 801aecc:	60fb      	str	r3, [r7, #12]
	data |= value;
 801aece:	68fa      	ldr	r2, [r7, #12]
 801aed0:	683b      	ldr	r3, [r7, #0]
 801aed2:	4313      	orrs	r3, r2
 801aed4:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->MacBase, GmacConfig,data);
 801aed6:	687b      	ldr	r3, [r7, #4]
 801aed8:	681b      	ldr	r3, [r3, #0]
 801aeda:	4618      	mov	r0, r3
 801aedc:	f04f 0100 	mov.w	r1, #0
 801aee0:	68fa      	ldr	r2, [r7, #12]
 801aee2:	f002 fb71 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801aee6:	bf00      	nop
}
 801aee8:	f107 0710 	add.w	r7, r7, #16
 801aeec:	46bd      	mov	sp, r7
 801aeee:	bd80      	pop	{r7, pc}

0801aef0 <synopGMAC_deferral_check_enable>:
  * \return returns void.
  * \note Deferral begins when transmitter is ready to transmit, but is prevented because  of
  * an active CRS (carrier sense) 
  */
void synopGMAC_deferral_check_enable(synopGMACdevice * gmacdev)
{
 801aef0:	b580      	push	{r7, lr}
 801aef2:	b082      	sub	sp, #8
 801aef4:	af00      	add	r7, sp, #0
 801aef6:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacDeferralCheck);
 801aef8:	687b      	ldr	r3, [r7, #4]
 801aefa:	681b      	ldr	r3, [r3, #0]
 801aefc:	4618      	mov	r0, r3
 801aefe:	f04f 0100 	mov.w	r1, #0
 801af02:	f04f 0210 	mov.w	r2, #16
 801af06:	f002 fb71 	bl	801d5ec <synopGMACSetBits>
	return;
 801af0a:	bf00      	nop
}
 801af0c:	f107 0708 	add.w	r7, r7, #8
 801af10:	46bd      	mov	sp, r7
 801af12:	bd80      	pop	{r7, pc}

0801af14 <synopGMAC_deferral_check_disable>:
  * GMAC defers until the CRS signal goes inactive.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_deferral_check_disable(synopGMACdevice * gmacdev)
{
 801af14:	b580      	push	{r7, lr}
 801af16:	b082      	sub	sp, #8
 801af18:	af00      	add	r7, sp, #0
 801af1a:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacDeferralCheck);
 801af1c:	687b      	ldr	r3, [r7, #4]
 801af1e:	681b      	ldr	r3, [r3, #0]
 801af20:	4618      	mov	r0, r3
 801af22:	f04f 0100 	mov.w	r1, #0
 801af26:	f04f 0210 	mov.w	r2, #16
 801af2a:	f002 fb79 	bl	801d620 <synopGMACClearBits>
	return;
 801af2e:	bf00      	nop
}
 801af30:	f107 0708 	add.w	r7, r7, #8
 801af34:	46bd      	mov	sp, r7
 801af36:	bd80      	pop	{r7, pc}

0801af38 <synopGMAC_rx_enable>:
  * Enable the reception of frames on GMII/MII.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_rx_enable(synopGMACdevice * gmacdev)
{
 801af38:	b580      	push	{r7, lr}
 801af3a:	b082      	sub	sp, #8
 801af3c:	af00      	add	r7, sp, #0
 801af3e:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacRx);
 801af40:	687b      	ldr	r3, [r7, #4]
 801af42:	681b      	ldr	r3, [r3, #0]
 801af44:	4618      	mov	r0, r3
 801af46:	f04f 0100 	mov.w	r1, #0
 801af4a:	f04f 0204 	mov.w	r2, #4
 801af4e:	f002 fb4d 	bl	801d5ec <synopGMACSetBits>
	return;
 801af52:	bf00      	nop
}
 801af54:	f107 0708 	add.w	r7, r7, #8
 801af58:	46bd      	mov	sp, r7
 801af5a:	bd80      	pop	{r7, pc}

0801af5c <synopGMAC_rx_disable>:
  * GMAC receive state machine is disabled after completion of reception of current frame.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_rx_disable(synopGMACdevice * gmacdev)
{
 801af5c:	b580      	push	{r7, lr}
 801af5e:	b082      	sub	sp, #8
 801af60:	af00      	add	r7, sp, #0
 801af62:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacRx);
 801af64:	687b      	ldr	r3, [r7, #4]
 801af66:	681b      	ldr	r3, [r3, #0]
 801af68:	4618      	mov	r0, r3
 801af6a:	f04f 0100 	mov.w	r1, #0
 801af6e:	f04f 0204 	mov.w	r2, #4
 801af72:	f002 fb55 	bl	801d620 <synopGMACClearBits>
	return;
 801af76:	bf00      	nop
}
 801af78:	f107 0708 	add.w	r7, r7, #8
 801af7c:	46bd      	mov	sp, r7
 801af7e:	bd80      	pop	{r7, pc}

0801af80 <synopGMAC_tx_enable>:
  * Enable the transmission of frames on GMII/MII.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_tx_enable(synopGMACdevice * gmacdev)
{
 801af80:	b580      	push	{r7, lr}
 801af82:	b082      	sub	sp, #8
 801af84:	af00      	add	r7, sp, #0
 801af86:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacConfig, GmacTx);
 801af88:	687b      	ldr	r3, [r7, #4]
 801af8a:	681b      	ldr	r3, [r3, #0]
 801af8c:	4618      	mov	r0, r3
 801af8e:	f04f 0100 	mov.w	r1, #0
 801af92:	f04f 0208 	mov.w	r2, #8
 801af96:	f002 fb29 	bl	801d5ec <synopGMACSetBits>
	return;
 801af9a:	bf00      	nop
}
 801af9c:	f107 0708 	add.w	r7, r7, #8
 801afa0:	46bd      	mov	sp, r7
 801afa2:	bd80      	pop	{r7, pc}

0801afa4 <synopGMAC_tx_disable>:
  * GMAC transmit state machine is disabled after completion of transmission of current frame.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_tx_disable(synopGMACdevice * gmacdev)
{
 801afa4:	b580      	push	{r7, lr}
 801afa6:	b082      	sub	sp, #8
 801afa8:	af00      	add	r7, sp, #0
 801afaa:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacConfig, GmacTx);
 801afac:	687b      	ldr	r3, [r7, #4]
 801afae:	681b      	ldr	r3, [r3, #0]
 801afb0:	4618      	mov	r0, r3
 801afb2:	f04f 0100 	mov.w	r1, #0
 801afb6:	f04f 0208 	mov.w	r2, #8
 801afba:	f002 fb31 	bl	801d620 <synopGMACClearBits>
	return;
 801afbe:	bf00      	nop
}
 801afc0:	f107 0708 	add.w	r7, r7, #8
 801afc4:	46bd      	mov	sp, r7
 801afc6:	bd80      	pop	{r7, pc}

0801afc8 <synopGMAC_frame_filter_enable>:
  * pass SA/DA address filtering or not.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_frame_filter_enable(synopGMACdevice * gmacdev)
{
 801afc8:	b580      	push	{r7, lr}
 801afca:	b082      	sub	sp, #8
 801afcc:	af00      	add	r7, sp, #0
 801afce:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacFilter);
 801afd0:	687b      	ldr	r3, [r7, #4]
 801afd2:	681b      	ldr	r3, [r3, #0]
 801afd4:	4618      	mov	r0, r3
 801afd6:	f04f 0104 	mov.w	r1, #4
 801afda:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801afde:	f002 fb1f 	bl	801d620 <synopGMACClearBits>
	return;
 801afe2:	bf00      	nop
}
 801afe4:	f107 0708 	add.w	r7, r7, #8
 801afe8:	46bd      	mov	sp, r7
 801afea:	bd80      	pop	{r7, pc}

0801afec <synopGMAC_frame_filter_disable>:
  * pass SA/DA address filtering.
  * @param[in] pointer to synopGMACdevice.
  * \return void. 
  */
void synopGMAC_frame_filter_disable(synopGMACdevice * gmacdev)
{
 801afec:	b580      	push	{r7, lr}
 801afee:	b082      	sub	sp, #8
 801aff0:	af00      	add	r7, sp, #0
 801aff2:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacFilter);
 801aff4:	687b      	ldr	r3, [r7, #4]
 801aff6:	681b      	ldr	r3, [r3, #0]
 801aff8:	4618      	mov	r0, r3
 801affa:	f04f 0104 	mov.w	r1, #4
 801affe:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801b002:	f002 faf3 	bl	801d5ec <synopGMACSetBits>
	return;
 801b006:	bf00      	nop
}
 801b008:	f107 0708 	add.w	r7, r7, #8
 801b00c:	46bd      	mov	sp, r7
 801b00e:	bd80      	pop	{r7, pc}

0801b010 <synopGMAC_write_hash_table_high>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] data to be written to hash table high register.
  * \return void. 
  */
void synopGMAC_write_hash_table_high(synopGMACdevice * gmacdev, u32 data)
{
 801b010:	b580      	push	{r7, lr}
 801b012:	b082      	sub	sp, #8
 801b014:	af00      	add	r7, sp, #0
 801b016:	6078      	str	r0, [r7, #4]
 801b018:	6039      	str	r1, [r7, #0]
	synopGMACWriteReg((u32 *)gmacdev->MacBase,GmacHashHigh,data);
 801b01a:	687b      	ldr	r3, [r7, #4]
 801b01c:	681b      	ldr	r3, [r3, #0]
 801b01e:	4618      	mov	r0, r3
 801b020:	f04f 0108 	mov.w	r1, #8
 801b024:	683a      	ldr	r2, [r7, #0]
 801b026:	f002 facf 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801b02a:	bf00      	nop
}
 801b02c:	f107 0708 	add.w	r7, r7, #8
 801b030:	46bd      	mov	sp, r7
 801b032:	bd80      	pop	{r7, pc}

0801b034 <synopGMAC_write_hash_table_low>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] data to be written to hash table low register.
  * \return void. 
  */
void synopGMAC_write_hash_table_low(synopGMACdevice * gmacdev, u32 data)
{
 801b034:	b580      	push	{r7, lr}
 801b036:	b082      	sub	sp, #8
 801b038:	af00      	add	r7, sp, #0
 801b03a:	6078      	str	r0, [r7, #4]
 801b03c:	6039      	str	r1, [r7, #0]
	synopGMACWriteReg((u32 *)gmacdev->MacBase,GmacHashLow,data);
 801b03e:	687b      	ldr	r3, [r7, #4]
 801b040:	681b      	ldr	r3, [r3, #0]
 801b042:	4618      	mov	r0, r3
 801b044:	f04f 010c 	mov.w	r1, #12
 801b048:	683a      	ldr	r2, [r7, #0]
 801b04a:	f002 fabd 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801b04e:	bf00      	nop
}
 801b050:	f107 0708 	add.w	r7, r7, #8
 801b054:	46bd      	mov	sp, r7
 801b056:	bd80      	pop	{r7, pc}

0801b058 <synopGMAC_hash_perfect_filter_enable>:
  * configuration are sent to application.
  * @param[in] pointer to synopGMACdevice.
  * \return void. 
  */
void synopGMAC_hash_perfect_filter_enable(synopGMACdevice * gmacdev)
{
 801b058:	b580      	push	{r7, lr}
 801b05a:	b082      	sub	sp, #8
 801b05c:	af00      	add	r7, sp, #0
 801b05e:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacHashPerfectFilter);
 801b060:	687b      	ldr	r3, [r7, #4]
 801b062:	681b      	ldr	r3, [r3, #0]
 801b064:	4618      	mov	r0, r3
 801b066:	f04f 0104 	mov.w	r1, #4
 801b06a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801b06e:	f002 fabd 	bl	801d5ec <synopGMACSetBits>
	return;
 801b072:	bf00      	nop
}
 801b074:	f107 0708 	add.w	r7, r7, #8
 801b078:	46bd      	mov	sp, r7
 801b07a:	bd80      	pop	{r7, pc}

0801b07c <synopGMAC_Hash_filter_only_enable>:
  * configuration are sent to application.
  * @param[in] pointer to synopGMACdevice.
  * \return void. 
  */
void synopGMAC_Hash_filter_only_enable(synopGMACdevice * gmacdev)
{
 801b07c:	b580      	push	{r7, lr}
 801b07e:	b082      	sub	sp, #8
 801b080:	af00      	add	r7, sp, #0
 801b082:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacHashPerfectFilter);
 801b084:	687b      	ldr	r3, [r7, #4]
 801b086:	681b      	ldr	r3, [r3, #0]
 801b088:	4618      	mov	r0, r3
 801b08a:	f04f 0104 	mov.w	r1, #4
 801b08e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801b092:	f002 faab 	bl	801d5ec <synopGMACSetBits>
	return;
 801b096:	bf00      	nop
}
 801b098:	f107 0708 	add.w	r7, r7, #8
 801b09c:	46bd      	mov	sp, r7
 801b09e:	bd80      	pop	{r7, pc}

0801b0a0 <synopGMAC_src_addr_filter_enable>:
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  * \note This function is overriden by synopGMAC_frame_filter_disable(synopGMACdevice *) 
  */
void synopGMAC_src_addr_filter_enable(synopGMACdevice * gmacdev)
{
 801b0a0:	b580      	push	{r7, lr}
 801b0a2:	b082      	sub	sp, #8
 801b0a4:	af00      	add	r7, sp, #0
 801b0a6:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacSrcAddrFilter);
 801b0a8:	687b      	ldr	r3, [r7, #4]
 801b0aa:	681b      	ldr	r3, [r3, #0]
 801b0ac:	4618      	mov	r0, r3
 801b0ae:	f04f 0104 	mov.w	r1, #4
 801b0b2:	f44f 7200 	mov.w	r2, #512	; 0x200
 801b0b6:	f002 fa99 	bl	801d5ec <synopGMACSetBits>
	return;
 801b0ba:	bf00      	nop
}
 801b0bc:	f107 0708 	add.w	r7, r7, #8
 801b0c0:	46bd      	mov	sp, r7
 801b0c2:	bd80      	pop	{r7, pc}

0801b0c4 <synopGMAC_src_addr_filter_disable>:
  * When disabled GMAC forwards the received frames with updated SAMatch bit in RxStatus. 
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_src_addr_filter_disable(synopGMACdevice * gmacdev)
{
 801b0c4:	b580      	push	{r7, lr}
 801b0c6:	b082      	sub	sp, #8
 801b0c8:	af00      	add	r7, sp, #0
 801b0ca:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacSrcAddrFilter);
 801b0cc:	687b      	ldr	r3, [r7, #4]
 801b0ce:	681b      	ldr	r3, [r3, #0]
 801b0d0:	4618      	mov	r0, r3
 801b0d2:	f04f 0104 	mov.w	r1, #4
 801b0d6:	f44f 7200 	mov.w	r2, #512	; 0x200
 801b0da:	f002 faa1 	bl	801d620 <synopGMACClearBits>
	return;
 801b0de:	bf00      	nop
}
 801b0e0:	f107 0708 	add.w	r7, r7, #8
 801b0e4:	46bd      	mov	sp, r7
 801b0e6:	bd80      	pop	{r7, pc}

0801b0e8 <synopGMAC_dst_addr_filter_inverse>:
  * Enables Inverse Destination address filtering.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_dst_addr_filter_inverse(synopGMACdevice * gmacdev)
{
 801b0e8:	b580      	push	{r7, lr}
 801b0ea:	b082      	sub	sp, #8
 801b0ec:	af00      	add	r7, sp, #0
 801b0ee:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacDestAddrFilterNor);
 801b0f0:	687b      	ldr	r3, [r7, #4]
 801b0f2:	681b      	ldr	r3, [r3, #0]
 801b0f4:	4618      	mov	r0, r3
 801b0f6:	f04f 0104 	mov.w	r1, #4
 801b0fa:	f04f 0200 	mov.w	r2, #0
 801b0fe:	f002 fa75 	bl	801d5ec <synopGMACSetBits>
	return;
 801b102:	bf00      	nop
}
 801b104:	f107 0708 	add.w	r7, r7, #8
 801b108:	46bd      	mov	sp, r7
 801b10a:	bd80      	pop	{r7, pc}

0801b10c <synopGMAC_dst_addr_filter_normal>:
  * Enables the normal Destination address filtering.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_dst_addr_filter_normal(synopGMACdevice * gmacdev)
{
 801b10c:	b580      	push	{r7, lr}
 801b10e:	b082      	sub	sp, #8
 801b110:	af00      	add	r7, sp, #0
 801b112:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacDestAddrFilterNor);
 801b114:	687b      	ldr	r3, [r7, #4]
 801b116:	681b      	ldr	r3, [r3, #0]
 801b118:	4618      	mov	r0, r3
 801b11a:	f04f 0104 	mov.w	r1, #4
 801b11e:	f04f 0200 	mov.w	r2, #0
 801b122:	f002 fa7d 	bl	801d620 <synopGMACClearBits>
	return;
 801b126:	bf00      	nop
}
 801b128:	f107 0708 	add.w	r7, r7, #8
 801b12c:	46bd      	mov	sp, r7
 801b12e:	bd80      	pop	{r7, pc}

0801b130 <synopGMAC_set_pass_control>:
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  * \note Depends on RFE of FlowControlRegister[2]
  */
void synopGMAC_set_pass_control(synopGMACdevice * gmacdev,u32 passcontrol)
{	
 801b130:	b580      	push	{r7, lr}
 801b132:	b084      	sub	sp, #16
 801b134:	af00      	add	r7, sp, #0
 801b136:	6078      	str	r0, [r7, #4]
 801b138:	6039      	str	r1, [r7, #0]
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->MacBase, GmacFrameFilter);
 801b13a:	687b      	ldr	r3, [r7, #4]
 801b13c:	681b      	ldr	r3, [r3, #0]
 801b13e:	4618      	mov	r0, r3
 801b140:	f04f 0104 	mov.w	r1, #4
 801b144:	f002 fa2e 	bl	801d5a4 <synopGMACReadReg>
 801b148:	60f8      	str	r0, [r7, #12]
	data &= (~GmacPassControl);
 801b14a:	68fb      	ldr	r3, [r7, #12]
 801b14c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 801b150:	60fb      	str	r3, [r7, #12]
	data |= passcontrol;
 801b152:	68fa      	ldr	r2, [r7, #12]
 801b154:	683b      	ldr	r3, [r7, #0]
 801b156:	4313      	orrs	r3, r2
 801b158:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->MacBase,GmacFrameFilter,data);
 801b15a:	687b      	ldr	r3, [r7, #4]
 801b15c:	681b      	ldr	r3, [r3, #0]
 801b15e:	4618      	mov	r0, r3
 801b160:	f04f 0104 	mov.w	r1, #4
 801b164:	68fa      	ldr	r2, [r7, #12]
 801b166:	f002 fa2f 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801b16a:	bf00      	nop
}
 801b16c:	f107 0710 	add.w	r7, r7, #16
 801b170:	46bd      	mov	sp, r7
 801b172:	bd80      	pop	{r7, pc}

0801b174 <synopGMAC_broadcast_enable>:
  * When enabled Address filtering module passes all incoming broadcast frames.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_broadcast_enable(synopGMACdevice * gmacdev)
{
 801b174:	b580      	push	{r7, lr}
 801b176:	b082      	sub	sp, #8
 801b178:	af00      	add	r7, sp, #0
 801b17a:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacBroadcast);
 801b17c:	687b      	ldr	r3, [r7, #4]
 801b17e:	681b      	ldr	r3, [r3, #0]
 801b180:	4618      	mov	r0, r3
 801b182:	f04f 0104 	mov.w	r1, #4
 801b186:	f04f 0220 	mov.w	r2, #32
 801b18a:	f002 fa49 	bl	801d620 <synopGMACClearBits>
	return;
 801b18e:	bf00      	nop
}
 801b190:	f107 0708 	add.w	r7, r7, #8
 801b194:	46bd      	mov	sp, r7
 801b196:	bd80      	pop	{r7, pc}

0801b198 <synopGMAC_broadcast_disable>:
  * When disabled Address filtering module filters all incoming broadcast frames.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_broadcast_disable(synopGMACdevice * gmacdev)
{
 801b198:	b580      	push	{r7, lr}
 801b19a:	b082      	sub	sp, #8
 801b19c:	af00      	add	r7, sp, #0
 801b19e:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacBroadcast);
 801b1a0:	687b      	ldr	r3, [r7, #4]
 801b1a2:	681b      	ldr	r3, [r3, #0]
 801b1a4:	4618      	mov	r0, r3
 801b1a6:	f04f 0104 	mov.w	r1, #4
 801b1aa:	f04f 0220 	mov.w	r2, #32
 801b1ae:	f002 fa1d 	bl	801d5ec <synopGMACSetBits>
	return;
 801b1b2:	bf00      	nop
}
 801b1b4:	f107 0708 	add.w	r7, r7, #8
 801b1b8:	46bd      	mov	sp, r7
 801b1ba:	bd80      	pop	{r7, pc}

0801b1bc <synopGMAC_multicast_enable>:
  * When enabled all multicast frames are passed.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_multicast_enable(synopGMACdevice * gmacdev)
{
 801b1bc:	b580      	push	{r7, lr}
 801b1be:	b082      	sub	sp, #8
 801b1c0:	af00      	add	r7, sp, #0
 801b1c2:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacMulticastFilter);
 801b1c4:	687b      	ldr	r3, [r7, #4]
 801b1c6:	681b      	ldr	r3, [r3, #0]
 801b1c8:	4618      	mov	r0, r3
 801b1ca:	f04f 0104 	mov.w	r1, #4
 801b1ce:	f04f 0210 	mov.w	r2, #16
 801b1d2:	f002 fa0b 	bl	801d5ec <synopGMACSetBits>
	return;
 801b1d6:	bf00      	nop
}
 801b1d8:	f107 0708 	add.w	r7, r7, #8
 801b1dc:	46bd      	mov	sp, r7
 801b1de:	bd80      	pop	{r7, pc}

0801b1e0 <synopGMAC_multicast_disable>:
  * When disabled multicast frame filtering depends on HMC bit.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_multicast_disable(synopGMACdevice * gmacdev)
{
 801b1e0:	b580      	push	{r7, lr}
 801b1e2:	b082      	sub	sp, #8
 801b1e4:	af00      	add	r7, sp, #0
 801b1e6:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacMulticastFilter);
 801b1e8:	687b      	ldr	r3, [r7, #4]
 801b1ea:	681b      	ldr	r3, [r3, #0]
 801b1ec:	4618      	mov	r0, r3
 801b1ee:	f04f 0104 	mov.w	r1, #4
 801b1f2:	f04f 0210 	mov.w	r2, #16
 801b1f6:	f002 fa13 	bl	801d620 <synopGMACClearBits>
	return;
 801b1fa:	bf00      	nop
}
 801b1fc:	f107 0708 	add.w	r7, r7, #8
 801b200:	46bd      	mov	sp, r7
 801b202:	bd80      	pop	{r7, pc}

0801b204 <synopGMAC_multicast_hash_filter_enable>:
  * When enabled GMAC performs teh destination address filtering according to the hash table.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_multicast_hash_filter_enable(synopGMACdevice * gmacdev)
{
 801b204:	b580      	push	{r7, lr}
 801b206:	b082      	sub	sp, #8
 801b208:	af00      	add	r7, sp, #0
 801b20a:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacMcastHashFilter);
 801b20c:	687b      	ldr	r3, [r7, #4]
 801b20e:	681b      	ldr	r3, [r3, #0]
 801b210:	4618      	mov	r0, r3
 801b212:	f04f 0104 	mov.w	r1, #4
 801b216:	f04f 0204 	mov.w	r2, #4
 801b21a:	f002 f9e7 	bl	801d5ec <synopGMACSetBits>
	return;
 801b21e:	bf00      	nop
}
 801b220:	f107 0708 	add.w	r7, r7, #8
 801b224:	46bd      	mov	sp, r7
 801b226:	bd80      	pop	{r7, pc}

0801b228 <synopGMAC_multicast_hash_filter_disable>:
  * DA field with the value programmed in DA register.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_multicast_hash_filter_disable(synopGMACdevice * gmacdev)
{
 801b228:	b580      	push	{r7, lr}
 801b22a:	b082      	sub	sp, #8
 801b22c:	af00      	add	r7, sp, #0
 801b22e:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacMcastHashFilter);
 801b230:	687b      	ldr	r3, [r7, #4]
 801b232:	681b      	ldr	r3, [r3, #0]
 801b234:	4618      	mov	r0, r3
 801b236:	f04f 0104 	mov.w	r1, #4
 801b23a:	f04f 0204 	mov.w	r2, #4
 801b23e:	f002 f9ef 	bl	801d620 <synopGMACClearBits>
	return;
 801b242:	bf00      	nop
}
 801b244:	f107 0708 	add.w	r7, r7, #8
 801b248:	46bd      	mov	sp, r7
 801b24a:	bd80      	pop	{r7, pc}

0801b24c <synopGMAC_promisc_enable>:
  * and source addresses.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_promisc_enable(synopGMACdevice * gmacdev)
{
 801b24c:	b580      	push	{r7, lr}
 801b24e:	b082      	sub	sp, #8
 801b250:	af00      	add	r7, sp, #0
 801b252:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacPromiscuousMode);
 801b254:	687b      	ldr	r3, [r7, #4]
 801b256:	681b      	ldr	r3, [r3, #0]
 801b258:	4618      	mov	r0, r3
 801b25a:	f04f 0104 	mov.w	r1, #4
 801b25e:	f04f 0201 	mov.w	r2, #1
 801b262:	f002 f9c3 	bl	801d5ec <synopGMACSetBits>
	return;
 801b266:	bf00      	nop
}
 801b268:	f107 0708 	add.w	r7, r7, #8
 801b26c:	46bd      	mov	sp, r7
 801b26e:	bd80      	pop	{r7, pc}

0801b270 <synopGMAC_promisc_disable>:
  * When called the GMAC falls back to normal operation from promiscous mode.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_promisc_disable(synopGMACdevice * gmacdev)
{
 801b270:	b580      	push	{r7, lr}
 801b272:	b082      	sub	sp, #8
 801b274:	af00      	add	r7, sp, #0
 801b276:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacPromiscuousMode);
 801b278:	687b      	ldr	r3, [r7, #4]
 801b27a:	681b      	ldr	r3, [r3, #0]
 801b27c:	4618      	mov	r0, r3
 801b27e:	f04f 0104 	mov.w	r1, #4
 801b282:	f04f 0201 	mov.w	r2, #1
 801b286:	f002 f9cb 	bl	801d620 <synopGMACClearBits>
	return;
 801b28a:	bf00      	nop
}
 801b28c:	f107 0708 	add.w	r7, r7, #8
 801b290:	46bd      	mov	sp, r7
 801b292:	bd80      	pop	{r7, pc}

0801b294 <synopGMAC_unicast_hash_filter_enable>:
  * When enabled GMAC performs the destination address filtering of unicast frames according to the hash table.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_unicast_hash_filter_enable(synopGMACdevice * gmacdev)
{
 801b294:	b580      	push	{r7, lr}
 801b296:	b082      	sub	sp, #8
 801b298:	af00      	add	r7, sp, #0
 801b29a:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacUcastHashFilter);
 801b29c:	687b      	ldr	r3, [r7, #4]
 801b29e:	681b      	ldr	r3, [r3, #0]
 801b2a0:	4618      	mov	r0, r3
 801b2a2:	f04f 0104 	mov.w	r1, #4
 801b2a6:	f04f 0202 	mov.w	r2, #2
 801b2aa:	f002 f99f 	bl	801d5ec <synopGMACSetBits>
	return;
 801b2ae:	bf00      	nop
}
 801b2b0:	f107 0708 	add.w	r7, r7, #8
 801b2b4:	46bd      	mov	sp, r7
 801b2b6:	bd80      	pop	{r7, pc}

0801b2b8 <synopGMAC_unicast_hash_filter_disable>:
  * DA field with the value programmed in DA register.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_unicast_hash_filter_disable(synopGMACdevice * gmacdev)
{
 801b2b8:	b580      	push	{r7, lr}
 801b2ba:	b082      	sub	sp, #8
 801b2bc:	af00      	add	r7, sp, #0
 801b2be:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFrameFilter, GmacUcastHashFilter);
 801b2c0:	687b      	ldr	r3, [r7, #4]
 801b2c2:	681b      	ldr	r3, [r3, #0]
 801b2c4:	4618      	mov	r0, r3
 801b2c6:	f04f 0104 	mov.w	r1, #4
 801b2ca:	f04f 0202 	mov.w	r2, #2
 801b2ce:	f002 f9a7 	bl	801d620 <synopGMACClearBits>
	return;
 801b2d2:	bf00      	nop
}
 801b2d4:	f107 0708 	add.w	r7, r7, #8
 801b2d8:	46bd      	mov	sp, r7
 801b2da:	bd80      	pop	{r7, pc}

0801b2dc <synopGMAC_unicast_pause_frame_detect_enable>:
  * detection of pause frames with unique multicast address.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_unicast_pause_frame_detect_enable(synopGMACdevice * gmacdev)
{
 801b2dc:	b580      	push	{r7, lr}
 801b2de:	b082      	sub	sp, #8
 801b2e0:	af00      	add	r7, sp, #0
 801b2e2:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacUnicastPauseFrame);
 801b2e4:	687b      	ldr	r3, [r7, #4]
 801b2e6:	681b      	ldr	r3, [r3, #0]
 801b2e8:	4618      	mov	r0, r3
 801b2ea:	f04f 0118 	mov.w	r1, #24
 801b2ee:	f04f 0208 	mov.w	r2, #8
 801b2f2:	f002 f97b 	bl	801d5ec <synopGMACSetBits>
	return;
 801b2f6:	bf00      	nop
}
 801b2f8:	f107 0708 	add.w	r7, r7, #8
 801b2fc:	46bd      	mov	sp, r7
 801b2fe:	bd80      	pop	{r7, pc}

0801b300 <synopGMAC_unicast_pause_frame_detect_disable>:
  * When disabled GMAC only detects with the unique multicast address (802.3x).
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_unicast_pause_frame_detect_disable(synopGMACdevice * gmacdev)
{
 801b300:	b580      	push	{r7, lr}
 801b302:	b082      	sub	sp, #8
 801b304:	af00      	add	r7, sp, #0
 801b306:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacUnicastPauseFrame);
 801b308:	687b      	ldr	r3, [r7, #4]
 801b30a:	681b      	ldr	r3, [r3, #0]
 801b30c:	4618      	mov	r0, r3
 801b30e:	f04f 0118 	mov.w	r1, #24
 801b312:	f04f 0208 	mov.w	r2, #8
 801b316:	f002 f983 	bl	801d620 <synopGMACClearBits>
	return;
 801b31a:	bf00      	nop
}
 801b31c:	f107 0708 	add.w	r7, r7, #8
 801b320:	46bd      	mov	sp, r7
 801b322:	bd80      	pop	{r7, pc}

0801b324 <synopGMAC_rx_flow_control_enable>:
  * When Enabled GMAC will decode the rx pause frame and disable the tx for a specified time.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_rx_flow_control_enable(synopGMACdevice * gmacdev)
{
 801b324:	b580      	push	{r7, lr}
 801b326:	b082      	sub	sp, #8
 801b328:	af00      	add	r7, sp, #0
 801b32a:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacRxFlowControl);
 801b32c:	687b      	ldr	r3, [r7, #4]
 801b32e:	681b      	ldr	r3, [r3, #0]
 801b330:	4618      	mov	r0, r3
 801b332:	f04f 0118 	mov.w	r1, #24
 801b336:	f04f 0204 	mov.w	r2, #4
 801b33a:	f002 f957 	bl	801d5ec <synopGMACSetBits>
	return;
 801b33e:	bf00      	nop
}
 801b340:	f107 0708 	add.w	r7, r7, #8
 801b344:	46bd      	mov	sp, r7
 801b346:	bd80      	pop	{r7, pc}

0801b348 <synopGMAC_rx_flow_control_disable>:
  * When disabled GMAC will not decode pause frame.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_rx_flow_control_disable(synopGMACdevice * gmacdev)
{
 801b348:	b580      	push	{r7, lr}
 801b34a:	b082      	sub	sp, #8
 801b34c:	af00      	add	r7, sp, #0
 801b34e:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacRxFlowControl);
 801b350:	687b      	ldr	r3, [r7, #4]
 801b352:	681b      	ldr	r3, [r3, #0]
 801b354:	4618      	mov	r0, r3
 801b356:	f04f 0118 	mov.w	r1, #24
 801b35a:	f04f 0204 	mov.w	r2, #4
 801b35e:	f002 f95f 	bl	801d620 <synopGMACClearBits>
	return;
 801b362:	bf00      	nop
}
 801b364:	f107 0708 	add.w	r7, r7, #8
 801b368:	46bd      	mov	sp, r7
 801b36a:	bd80      	pop	{r7, pc}

0801b36c <synopGMAC_tx_flow_control_enable>:
  *	- In Half duplex GMAC enables the back pressure operation
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_tx_flow_control_enable(synopGMACdevice * gmacdev)
{
 801b36c:	b580      	push	{r7, lr}
 801b36e:	b082      	sub	sp, #8
 801b370:	af00      	add	r7, sp, #0
 801b372:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacTxFlowControl);
 801b374:	687b      	ldr	r3, [r7, #4]
 801b376:	681b      	ldr	r3, [r3, #0]
 801b378:	4618      	mov	r0, r3
 801b37a:	f04f 0118 	mov.w	r1, #24
 801b37e:	f04f 0202 	mov.w	r2, #2
 801b382:	f002 f933 	bl	801d5ec <synopGMACSetBits>
	return;
 801b386:	bf00      	nop
}
 801b388:	f107 0708 	add.w	r7, r7, #8
 801b38c:	46bd      	mov	sp, r7
 801b38e:	bd80      	pop	{r7, pc}

0801b390 <synopGMAC_tx_flow_control_disable>:
  *	- In Half duplex GMAC disables the back pressure feature.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_tx_flow_control_disable(synopGMACdevice * gmacdev)
{
 801b390:	b580      	push	{r7, lr}
 801b392:	b082      	sub	sp, #8
 801b394:	af00      	add	r7, sp, #0
 801b396:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacTxFlowControl);
 801b398:	687b      	ldr	r3, [r7, #4]
 801b39a:	681b      	ldr	r3, [r3, #0]
 801b39c:	4618      	mov	r0, r3
 801b39e:	f04f 0118 	mov.w	r1, #24
 801b3a2:	f04f 0202 	mov.w	r2, #2
 801b3a6:	f002 f93b 	bl	801d620 <synopGMACClearBits>
	return;
 801b3aa:	bf00      	nop
}
 801b3ac:	f107 0708 	add.w	r7, r7, #8
 801b3b0:	46bd      	mov	sp, r7
 801b3b2:	bd80      	pop	{r7, pc}

0801b3b4 <synopGMAC_tx_activate_flow_control>:
  *	- In Half duplex GMAC initiates back pressure function.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_tx_activate_flow_control(synopGMACdevice * gmacdev)
{
 801b3b4:	b580      	push	{r7, lr}
 801b3b6:	b082      	sub	sp, #8
 801b3b8:	af00      	add	r7, sp, #0
 801b3ba:	6078      	str	r0, [r7, #4]
	//In case of full duplex check for this bit to b'0. if it is read as b'1 indicates that
        //control frame transmission is in progress.
	if(gmacdev->Speed == FULLDUPLEX){
 801b3bc:	687b      	ldr	r3, [r7, #4]
 801b3be:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 801b3c2:	2b02      	cmp	r3, #2
 801b3c4:	d115      	bne.n	801b3f2 <synopGMAC_tx_activate_flow_control+0x3e>
		if(!synopGMACCheckBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacFlowControlBackPressure))
 801b3c6:	687b      	ldr	r3, [r7, #4]
 801b3c8:	681b      	ldr	r3, [r3, #0]
 801b3ca:	4618      	mov	r0, r3
 801b3cc:	f04f 0118 	mov.w	r1, #24
 801b3d0:	f04f 0201 	mov.w	r2, #1
 801b3d4:	f002 f940 	bl	801d658 <synopGMACCheckBits>
 801b3d8:	4603      	mov	r3, r0
 801b3da:	2b00      	cmp	r3, #0
 801b3dc:	d112      	bne.n	801b404 <synopGMAC_tx_activate_flow_control+0x50>
			synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacFlowControlBackPressure);
 801b3de:	687b      	ldr	r3, [r7, #4]
 801b3e0:	681b      	ldr	r3, [r3, #0]
 801b3e2:	4618      	mov	r0, r3
 801b3e4:	f04f 0118 	mov.w	r1, #24
 801b3e8:	f04f 0201 	mov.w	r2, #1
 801b3ec:	f002 f8fe 	bl	801d5ec <synopGMACSetBits>
	else{ //if half duplex mode
		
		synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacFlowControlBackPressure);
	}

	return;
 801b3f0:	e008      	b.n	801b404 <synopGMAC_tx_activate_flow_control+0x50>
		if(!synopGMACCheckBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacFlowControlBackPressure))
			synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacFlowControlBackPressure);
	}
	else{ //if half duplex mode
		
		synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacFlowControlBackPressure);
 801b3f2:	687b      	ldr	r3, [r7, #4]
 801b3f4:	681b      	ldr	r3, [r3, #0]
 801b3f6:	4618      	mov	r0, r3
 801b3f8:	f04f 0118 	mov.w	r1, #24
 801b3fc:	f04f 0201 	mov.w	r2, #1
 801b400:	f002 f8f4 	bl	801d5ec <synopGMACSetBits>
	}

	return;
 801b404:	bf00      	nop
}
 801b406:	f107 0708 	add.w	r7, r7, #8
 801b40a:	46bd      	mov	sp, r7
 801b40c:	bd80      	pop	{r7, pc}
 801b40e:	bf00      	nop

0801b410 <synopGMAC_tx_deactivate_flow_control>:
  * stops Flowcontrol operation.
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_tx_deactivate_flow_control(synopGMACdevice * gmacdev)
{
 801b410:	b580      	push	{r7, lr}
 801b412:	b082      	sub	sp, #8
 801b414:	af00      	add	r7, sp, #0
 801b416:	6078      	str	r0, [r7, #4]
	//In full duplex this bit is automatically cleared after transmitting a pause control frame.
	if(gmacdev->Speed == HALFDUPLEX){
 801b418:	687b      	ldr	r3, [r7, #4]
 801b41a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 801b41e:	2b01      	cmp	r3, #1
 801b420:	d108      	bne.n	801b434 <synopGMAC_tx_deactivate_flow_control+0x24>
	synopGMACSetBits((u32 *)gmacdev->MacBase, GmacFlowControl, GmacFlowControlBackPressure);
 801b422:	687b      	ldr	r3, [r7, #4]
 801b424:	681b      	ldr	r3, [r3, #0]
 801b426:	4618      	mov	r0, r3
 801b428:	f04f 0118 	mov.w	r1, #24
 801b42c:	f04f 0201 	mov.w	r2, #1
 801b430:	f002 f8dc 	bl	801d5ec <synopGMACSetBits>
	}
	return;
 801b434:	bf00      	nop
}
 801b436:	f107 0708 	add.w	r7, r7, #8
 801b43a:	46bd      	mov	sp, r7
 801b43c:	bd80      	pop	{r7, pc}
 801b43e:	bf00      	nop

0801b440 <synopGMAC_pause_control>:
  * if found any issues
  * @param[in] pointer to synopGMACdevice.
  * \return void.
  */
void synopGMAC_pause_control(synopGMACdevice *gmacdev)
{
 801b440:	b580      	push	{r7, lr}
 801b442:	b084      	sub	sp, #16
 801b444:	af00      	add	r7, sp, #0
 801b446:	6078      	str	r0, [r7, #4]
	u32 omr_reg;
	u32 mac_flow_control_reg;
	omr_reg = synopGMACReadReg((u32 *)gmacdev->DmaBase,DmaControl);
 801b448:	687b      	ldr	r3, [r7, #4]
 801b44a:	685b      	ldr	r3, [r3, #4]
 801b44c:	4618      	mov	r0, r3
 801b44e:	f04f 0118 	mov.w	r1, #24
 801b452:	f002 f8a7 	bl	801d5a4 <synopGMACReadReg>
 801b456:	60f8      	str	r0, [r7, #12]
	omr_reg |= DmaRxFlowCtrlAct4K | DmaRxFlowCtrlDeact5K |DmaEnHwFlowCtrl;
 801b458:	68fb      	ldr	r3, [r7, #12]
 801b45a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 801b45e:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 801b462:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaControl, omr_reg);
 801b464:	687b      	ldr	r3, [r7, #4]
 801b466:	685b      	ldr	r3, [r3, #4]
 801b468:	4618      	mov	r0, r3
 801b46a:	f04f 0118 	mov.w	r1, #24
 801b46e:	68fa      	ldr	r2, [r7, #12]
 801b470:	f002 f8aa 	bl	801d5c8 <synopGMACWriteReg>

	mac_flow_control_reg = synopGMACReadReg((u32 *)gmacdev->MacBase,GmacFlowControl);
 801b474:	687b      	ldr	r3, [r7, #4]
 801b476:	681b      	ldr	r3, [r3, #0]
 801b478:	4618      	mov	r0, r3
 801b47a:	f04f 0118 	mov.w	r1, #24
 801b47e:	f002 f891 	bl	801d5a4 <synopGMACReadReg>
 801b482:	60b8      	str	r0, [r7, #8]
	mac_flow_control_reg |= GmacRxFlowControl | GmacTxFlowControl | 0xFFFF0000;
 801b484:	68ba      	ldr	r2, [r7, #8]
 801b486:	f04f 0306 	mov.w	r3, #6
 801b48a:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 801b48e:	4313      	orrs	r3, r2
 801b490:	60bb      	str	r3, [r7, #8]
	synopGMACWriteReg((u32 *)gmacdev->MacBase,GmacFlowControl,mac_flow_control_reg);
 801b492:	687b      	ldr	r3, [r7, #4]
 801b494:	681b      	ldr	r3, [r3, #0]
 801b496:	4618      	mov	r0, r3
 801b498:	f04f 0118 	mov.w	r1, #24
 801b49c:	68ba      	ldr	r2, [r7, #8]
 801b49e:	f002 f893 	bl	801d5c8 <synopGMACWriteReg>

	return;
 801b4a2:	bf00      	nop

}
 801b4a4:	f107 0710 	add.w	r7, r7, #16
 801b4a8:	46bd      	mov	sp, r7
 801b4aa:	bd80      	pop	{r7, pc}

0801b4ac <synopGMAC_mac_init>:
  * One can change the functions invoked here to have different configuration as per the requirement
  * @param[in] pointer to synopGMACdevice.
  * \return Returns 0 on success.
  */
s32 synopGMAC_mac_init(synopGMACdevice * gmacdev)
{
 801b4ac:	b580      	push	{r7, lr}
 801b4ae:	b082      	sub	sp, #8
 801b4b0:	af00      	add	r7, sp, #0
 801b4b2:	6078      	str	r0, [r7, #4]
	
	if(gmacdev->DuplexMode == FULLDUPLEX){
 801b4b4:	687b      	ldr	r3, [r7, #4]
 801b4b6:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 801b4ba:	2b02      	cmp	r3, #2
 801b4bc:	d152      	bne.n	801b564 <synopGMAC_mac_init+0xb8>
		synopGMAC_wd_enable(gmacdev);
 801b4be:	6878      	ldr	r0, [r7, #4]
 801b4c0:	f7ff fb7a 	bl	801abb8 <synopGMAC_wd_enable>
		synopGMAC_jab_enable(gmacdev);
 801b4c4:	6878      	ldr	r0, [r7, #4]
 801b4c6:	f7ff fb9b 	bl	801ac00 <synopGMAC_jab_enable>
		synopGMAC_frame_burst_enable(gmacdev);
 801b4ca:	6878      	ldr	r0, [r7, #4]
 801b4cc:	f7ff fbbc 	bl	801ac48 <synopGMAC_frame_burst_enable>
		synopGMAC_jumbo_frame_disable(gmacdev);
 801b4d0:	6878      	ldr	r0, [r7, #4]
 801b4d2:	f7ff fbef 	bl	801acb4 <synopGMAC_jumbo_frame_disable>
		synopGMAC_rx_own_enable(gmacdev);
 801b4d6:	6878      	ldr	r0, [r7, #4]
 801b4d8:	f7ff fc34 	bl	801ad44 <synopGMAC_rx_own_enable>
		synopGMAC_loopback_off(gmacdev);
 801b4dc:	6878      	ldr	r0, [r7, #4]
 801b4de:	f7ff fc67 	bl	801adb0 <synopGMAC_loopback_off>
		synopGMAC_set_full_duplex(gmacdev);
 801b4e2:	6878      	ldr	r0, [r7, #4]
 801b4e4:	f7ff fc76 	bl	801add4 <synopGMAC_set_full_duplex>
		synopGMAC_retry_enable(gmacdev);
 801b4e8:	6878      	ldr	r0, [r7, #4]
 801b4ea:	f7ff fc97 	bl	801ae1c <synopGMAC_retry_enable>
		synopGMAC_pad_crc_strip_disable(gmacdev);
 801b4ee:	6878      	ldr	r0, [r7, #4]
 801b4f0:	f7ff fcca 	bl	801ae88 <synopGMAC_pad_crc_strip_disable>
		synopGMAC_back_off_limit(gmacdev,GmacBackoffLimit0);
 801b4f4:	6878      	ldr	r0, [r7, #4]
 801b4f6:	f04f 0100 	mov.w	r1, #0
 801b4fa:	f7ff fcd7 	bl	801aeac <synopGMAC_back_off_limit>
		synopGMAC_deferral_check_disable(gmacdev);
 801b4fe:	6878      	ldr	r0, [r7, #4]
 801b500:	f7ff fd08 	bl	801af14 <synopGMAC_deferral_check_disable>
		synopGMAC_tx_enable(gmacdev);	
 801b504:	6878      	ldr	r0, [r7, #4]
 801b506:	f7ff fd3b 	bl	801af80 <synopGMAC_tx_enable>
		synopGMAC_rx_enable(gmacdev);
 801b50a:	6878      	ldr	r0, [r7, #4]
 801b50c:	f7ff fd14 	bl	801af38 <synopGMAC_rx_enable>

		synopGMAC_select_mii(gmacdev);
 801b510:	6878      	ldr	r0, [r7, #4]
 801b512:	f7ff fc05 	bl	801ad20 <synopGMAC_select_mii>

		/*Frame Filter Configuration*/
	 	synopGMAC_frame_filter_enable(gmacdev);
 801b516:	6878      	ldr	r0, [r7, #4]
 801b518:	f7ff fd56 	bl	801afc8 <synopGMAC_frame_filter_enable>
		synopGMAC_set_pass_control(gmacdev,GmacPassControl0);
 801b51c:	6878      	ldr	r0, [r7, #4]
 801b51e:	f04f 0100 	mov.w	r1, #0
 801b522:	f7ff fe05 	bl	801b130 <synopGMAC_set_pass_control>
		synopGMAC_broadcast_enable(gmacdev);
 801b526:	6878      	ldr	r0, [r7, #4]
 801b528:	f7ff fe24 	bl	801b174 <synopGMAC_broadcast_enable>
		synopGMAC_src_addr_filter_disable(gmacdev);
 801b52c:	6878      	ldr	r0, [r7, #4]
 801b52e:	f7ff fdc9 	bl	801b0c4 <synopGMAC_src_addr_filter_disable>
		synopGMAC_multicast_disable(gmacdev);
 801b532:	6878      	ldr	r0, [r7, #4]
 801b534:	f7ff fe54 	bl	801b1e0 <synopGMAC_multicast_disable>
		synopGMAC_dst_addr_filter_normal(gmacdev);
 801b538:	6878      	ldr	r0, [r7, #4]
 801b53a:	f7ff fde7 	bl	801b10c <synopGMAC_dst_addr_filter_normal>
		synopGMAC_multicast_hash_filter_disable(gmacdev);
 801b53e:	6878      	ldr	r0, [r7, #4]
 801b540:	f7ff fe72 	bl	801b228 <synopGMAC_multicast_hash_filter_disable>
		synopGMAC_promisc_disable(gmacdev);	
 801b544:	6878      	ldr	r0, [r7, #4]
 801b546:	f7ff fe93 	bl	801b270 <synopGMAC_promisc_disable>
		//synopGMAC_promisc_enable(gmacdev);
		synopGMAC_unicast_hash_filter_disable(gmacdev);
 801b54a:	6878      	ldr	r0, [r7, #4]
 801b54c:	f7ff feb4 	bl	801b2b8 <synopGMAC_unicast_hash_filter_disable>
	
		/*Flow Control Configuration*/
		synopGMAC_unicast_pause_frame_detect_disable(gmacdev);
 801b550:	6878      	ldr	r0, [r7, #4]
 801b552:	f7ff fed5 	bl	801b300 <synopGMAC_unicast_pause_frame_detect_disable>
		synopGMAC_rx_flow_control_enable(gmacdev);
 801b556:	6878      	ldr	r0, [r7, #4]
 801b558:	f7ff fee4 	bl	801b324 <synopGMAC_rx_flow_control_enable>
		synopGMAC_tx_flow_control_enable(gmacdev);
 801b55c:	6878      	ldr	r0, [r7, #4]
 801b55e:	f7ff ff05 	bl	801b36c <synopGMAC_tx_flow_control_enable>
 801b562:	e051      	b.n	801b608 <synopGMAC_mac_init+0x15c>
	}
	else{//for Half Duplex configuration
		
		synopGMAC_wd_enable(gmacdev);
 801b564:	6878      	ldr	r0, [r7, #4]
 801b566:	f7ff fb27 	bl	801abb8 <synopGMAC_wd_enable>
		synopGMAC_jab_enable(gmacdev);
 801b56a:	6878      	ldr	r0, [r7, #4]
 801b56c:	f7ff fb48 	bl	801ac00 <synopGMAC_jab_enable>
		synopGMAC_frame_burst_enable(gmacdev);
 801b570:	6878      	ldr	r0, [r7, #4]
 801b572:	f7ff fb69 	bl	801ac48 <synopGMAC_frame_burst_enable>
		synopGMAC_jumbo_frame_disable(gmacdev);
 801b576:	6878      	ldr	r0, [r7, #4]
 801b578:	f7ff fb9c 	bl	801acb4 <synopGMAC_jumbo_frame_disable>
		synopGMAC_rx_own_enable(gmacdev);
 801b57c:	6878      	ldr	r0, [r7, #4]
 801b57e:	f7ff fbe1 	bl	801ad44 <synopGMAC_rx_own_enable>
		synopGMAC_loopback_off(gmacdev);
 801b582:	6878      	ldr	r0, [r7, #4]
 801b584:	f7ff fc14 	bl	801adb0 <synopGMAC_loopback_off>
		synopGMAC_set_half_duplex(gmacdev);
 801b588:	6878      	ldr	r0, [r7, #4]
 801b58a:	f7ff fc35 	bl	801adf8 <synopGMAC_set_half_duplex>
		synopGMAC_retry_enable(gmacdev);
 801b58e:	6878      	ldr	r0, [r7, #4]
 801b590:	f7ff fc44 	bl	801ae1c <synopGMAC_retry_enable>
		synopGMAC_pad_crc_strip_disable(gmacdev);
 801b594:	6878      	ldr	r0, [r7, #4]
 801b596:	f7ff fc77 	bl	801ae88 <synopGMAC_pad_crc_strip_disable>
		synopGMAC_back_off_limit(gmacdev,GmacBackoffLimit0);
 801b59a:	6878      	ldr	r0, [r7, #4]
 801b59c:	f04f 0100 	mov.w	r1, #0
 801b5a0:	f7ff fc84 	bl	801aeac <synopGMAC_back_off_limit>
		synopGMAC_deferral_check_disable(gmacdev);
 801b5a4:	6878      	ldr	r0, [r7, #4]
 801b5a6:	f7ff fcb5 	bl	801af14 <synopGMAC_deferral_check_disable>
		synopGMAC_tx_enable(gmacdev);	
 801b5aa:	6878      	ldr	r0, [r7, #4]
 801b5ac:	f7ff fce8 	bl	801af80 <synopGMAC_tx_enable>
		synopGMAC_rx_enable(gmacdev);
 801b5b0:	6878      	ldr	r0, [r7, #4]
 801b5b2:	f7ff fcc1 	bl	801af38 <synopGMAC_rx_enable>

		synopGMAC_select_mii(gmacdev);
 801b5b6:	6878      	ldr	r0, [r7, #4]
 801b5b8:	f7ff fbb2 	bl	801ad20 <synopGMAC_select_mii>

		/*Frame Filter Configuration*/
	 	//synopGMAC_frame_filter_enable(gmacdev); 
		synopGMAC_frame_filter_disable(gmacdev);
 801b5bc:	6878      	ldr	r0, [r7, #4]
 801b5be:	f7ff fd15 	bl	801afec <synopGMAC_frame_filter_disable>
		synopGMAC_set_pass_control(gmacdev,GmacPassControl0);
 801b5c2:	6878      	ldr	r0, [r7, #4]
 801b5c4:	f04f 0100 	mov.w	r1, #0
 801b5c8:	f7ff fdb2 	bl	801b130 <synopGMAC_set_pass_control>
		synopGMAC_broadcast_enable(gmacdev);
 801b5cc:	6878      	ldr	r0, [r7, #4]
 801b5ce:	f7ff fdd1 	bl	801b174 <synopGMAC_broadcast_enable>
		synopGMAC_src_addr_filter_disable(gmacdev);
 801b5d2:	6878      	ldr	r0, [r7, #4]
 801b5d4:	f7ff fd76 	bl	801b0c4 <synopGMAC_src_addr_filter_disable>
		synopGMAC_multicast_disable(gmacdev);
 801b5d8:	6878      	ldr	r0, [r7, #4]
 801b5da:	f7ff fe01 	bl	801b1e0 <synopGMAC_multicast_disable>
		synopGMAC_dst_addr_filter_normal(gmacdev);
 801b5de:	6878      	ldr	r0, [r7, #4]
 801b5e0:	f7ff fd94 	bl	801b10c <synopGMAC_dst_addr_filter_normal>
		synopGMAC_multicast_hash_filter_disable(gmacdev);
 801b5e4:	6878      	ldr	r0, [r7, #4]
 801b5e6:	f7ff fe1f 	bl	801b228 <synopGMAC_multicast_hash_filter_disable>
		synopGMAC_promisc_disable(gmacdev);
 801b5ea:	6878      	ldr	r0, [r7, #4]
 801b5ec:	f7ff fe40 	bl	801b270 <synopGMAC_promisc_disable>
		synopGMAC_unicast_hash_filter_disable(gmacdev);
 801b5f0:	6878      	ldr	r0, [r7, #4]
 801b5f2:	f7ff fe61 	bl	801b2b8 <synopGMAC_unicast_hash_filter_disable>
		
		/*Flow Control Configuration*/
		synopGMAC_unicast_pause_frame_detect_disable(gmacdev);
 801b5f6:	6878      	ldr	r0, [r7, #4]
 801b5f8:	f7ff fe82 	bl	801b300 <synopGMAC_unicast_pause_frame_detect_disable>
		synopGMAC_rx_flow_control_disable(gmacdev);
 801b5fc:	6878      	ldr	r0, [r7, #4]
 801b5fe:	f7ff fea3 	bl	801b348 <synopGMAC_rx_flow_control_disable>
		synopGMAC_tx_flow_control_disable(gmacdev);
 801b602:	6878      	ldr	r0, [r7, #4]
 801b604:	f7ff fec4 	bl	801b390 <synopGMAC_tx_flow_control_disable>
		PHYreg = synopGMACReadReg((u32 *)gmacdev->MacBase,GmacGmiiData);
		synopGMACWriteReg((u32 *)gmacdev->MacBase, GmacGmiiData, PHYreg   | 0x00000800);
		synopGMACWriteReg((u32 *)gmacdev->MacBase, GmacGmiiAddr, GmiiBusy | 0x0000040a);
#endif
	}
	return 0;
 801b608:	f04f 0300 	mov.w	r3, #0
}
 801b60c:	4618      	mov	r0, r3
 801b60e:	f107 0708 	add.w	r7, r7, #8
 801b612:	46bd      	mov	sp, r7
 801b614:	bd80      	pop	{r7, pc}
 801b616:	bf00      	nop

0801b618 <synopGMAC_set_mac_addr>:
  * @param[in] Register offset for Mac address low
  * @param[in] buffer containing mac address to be programmed.
  * \return 0 upon success. Error code upon failure.
  */
s32 synopGMAC_set_mac_addr(synopGMACdevice *gmacdev, u32 MacHigh, u32 MacLow, u8 *MacAddr)
{
 801b618:	b580      	push	{r7, lr}
 801b61a:	b086      	sub	sp, #24
 801b61c:	af00      	add	r7, sp, #0
 801b61e:	60f8      	str	r0, [r7, #12]
 801b620:	60b9      	str	r1, [r7, #8]
 801b622:	607a      	str	r2, [r7, #4]
 801b624:	603b      	str	r3, [r7, #0]
	u32 data;
	
	data = (MacAddr[5] << 8) | MacAddr[4];
 801b626:	683b      	ldr	r3, [r7, #0]
 801b628:	f103 0305 	add.w	r3, r3, #5
 801b62c:	781b      	ldrb	r3, [r3, #0]
 801b62e:	ea4f 2203 	mov.w	r2, r3, lsl #8
 801b632:	683b      	ldr	r3, [r7, #0]
 801b634:	f103 0304 	add.w	r3, r3, #4
 801b638:	781b      	ldrb	r3, [r3, #0]
 801b63a:	4313      	orrs	r3, r2
 801b63c:	617b      	str	r3, [r7, #20]
	synopGMACWriteReg((u32 *)gmacdev->MacBase,MacHigh,data);
 801b63e:	68fb      	ldr	r3, [r7, #12]
 801b640:	681b      	ldr	r3, [r3, #0]
 801b642:	4618      	mov	r0, r3
 801b644:	68b9      	ldr	r1, [r7, #8]
 801b646:	697a      	ldr	r2, [r7, #20]
 801b648:	f001 ffbe 	bl	801d5c8 <synopGMACWriteReg>
	data = (MacAddr[3] << 24) | (MacAddr[2] << 16) | (MacAddr[1] << 8) | MacAddr[0] ;
 801b64c:	683b      	ldr	r3, [r7, #0]
 801b64e:	f103 0303 	add.w	r3, r3, #3
 801b652:	781b      	ldrb	r3, [r3, #0]
 801b654:	ea4f 6203 	mov.w	r2, r3, lsl #24
 801b658:	683b      	ldr	r3, [r7, #0]
 801b65a:	f103 0302 	add.w	r3, r3, #2
 801b65e:	781b      	ldrb	r3, [r3, #0]
 801b660:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801b664:	431a      	orrs	r2, r3
 801b666:	683b      	ldr	r3, [r7, #0]
 801b668:	f103 0301 	add.w	r3, r3, #1
 801b66c:	781b      	ldrb	r3, [r3, #0]
 801b66e:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801b672:	431a      	orrs	r2, r3
 801b674:	683b      	ldr	r3, [r7, #0]
 801b676:	781b      	ldrb	r3, [r3, #0]
 801b678:	4313      	orrs	r3, r2
 801b67a:	617b      	str	r3, [r7, #20]
	synopGMACWriteReg((u32 *)gmacdev->MacBase,MacLow,data);
 801b67c:	68fb      	ldr	r3, [r7, #12]
 801b67e:	681b      	ldr	r3, [r3, #0]
 801b680:	4618      	mov	r0, r3
 801b682:	6879      	ldr	r1, [r7, #4]
 801b684:	697a      	ldr	r2, [r7, #20]
 801b686:	f001 ff9f 	bl	801d5c8 <synopGMACWriteReg>
	return 0;
 801b68a:	f04f 0300 	mov.w	r3, #0
}
 801b68e:	4618      	mov	r0, r3
 801b690:	f107 0718 	add.w	r7, r7, #24
 801b694:	46bd      	mov	sp, r7
 801b696:	bd80      	pop	{r7, pc}

0801b698 <synopGMAC_get_mac_addr>:
  * @param[in] Register offset for Mac address low
  * @param[out] buffer containing the device mac address.
  * \return 0 upon success. Error code upon failure.
  */
s32 synopGMAC_get_mac_addr(synopGMACdevice *gmacdev, u32 MacHigh, u32 MacLow, u8 *MacAddr)
{
 801b698:	b580      	push	{r7, lr}
 801b69a:	b086      	sub	sp, #24
 801b69c:	af00      	add	r7, sp, #0
 801b69e:	60f8      	str	r0, [r7, #12]
 801b6a0:	60b9      	str	r1, [r7, #8]
 801b6a2:	607a      	str	r2, [r7, #4]
 801b6a4:	603b      	str	r3, [r7, #0]
	u32 data;
		
	data = synopGMACReadReg((u32 *)gmacdev->MacBase,MacHigh);
 801b6a6:	68fb      	ldr	r3, [r7, #12]
 801b6a8:	681b      	ldr	r3, [r3, #0]
 801b6aa:	4618      	mov	r0, r3
 801b6ac:	68b9      	ldr	r1, [r7, #8]
 801b6ae:	f001 ff79 	bl	801d5a4 <synopGMACReadReg>
 801b6b2:	6178      	str	r0, [r7, #20]
	MacAddr[5] = (data >> 8) & 0xff;
 801b6b4:	683b      	ldr	r3, [r7, #0]
 801b6b6:	f103 0305 	add.w	r3, r3, #5
 801b6ba:	697a      	ldr	r2, [r7, #20]
 801b6bc:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801b6c0:	b2d2      	uxtb	r2, r2
 801b6c2:	701a      	strb	r2, [r3, #0]
	MacAddr[4] = (data)        & 0xff;
 801b6c4:	683b      	ldr	r3, [r7, #0]
 801b6c6:	f103 0304 	add.w	r3, r3, #4
 801b6ca:	697a      	ldr	r2, [r7, #20]
 801b6cc:	b2d2      	uxtb	r2, r2
 801b6ce:	701a      	strb	r2, [r3, #0]

	data = synopGMACReadReg((u32 *)gmacdev->MacBase,MacLow);
 801b6d0:	68fb      	ldr	r3, [r7, #12]
 801b6d2:	681b      	ldr	r3, [r3, #0]
 801b6d4:	4618      	mov	r0, r3
 801b6d6:	6879      	ldr	r1, [r7, #4]
 801b6d8:	f001 ff64 	bl	801d5a4 <synopGMACReadReg>
 801b6dc:	6178      	str	r0, [r7, #20]
	MacAddr[3] = (data >> 24) & 0xff;
 801b6de:	683b      	ldr	r3, [r7, #0]
 801b6e0:	f103 0303 	add.w	r3, r3, #3
 801b6e4:	697a      	ldr	r2, [r7, #20]
 801b6e6:	ea4f 6212 	mov.w	r2, r2, lsr #24
 801b6ea:	b2d2      	uxtb	r2, r2
 801b6ec:	701a      	strb	r2, [r3, #0]
	MacAddr[2] = (data >> 16) & 0xff;
 801b6ee:	683b      	ldr	r3, [r7, #0]
 801b6f0:	f103 0302 	add.w	r3, r3, #2
 801b6f4:	697a      	ldr	r2, [r7, #20]
 801b6f6:	ea4f 4212 	mov.w	r2, r2, lsr #16
 801b6fa:	b2d2      	uxtb	r2, r2
 801b6fc:	701a      	strb	r2, [r3, #0]
	MacAddr[1] = (data >> 8 ) & 0xff;
 801b6fe:	683b      	ldr	r3, [r7, #0]
 801b700:	f103 0301 	add.w	r3, r3, #1
 801b704:	697a      	ldr	r2, [r7, #20]
 801b706:	ea4f 2212 	mov.w	r2, r2, lsr #8
 801b70a:	b2d2      	uxtb	r2, r2
 801b70c:	701a      	strb	r2, [r3, #0]
	MacAddr[0] = (data )      & 0xff;
 801b70e:	697b      	ldr	r3, [r7, #20]
 801b710:	b2da      	uxtb	r2, r3
 801b712:	683b      	ldr	r3, [r7, #0]
 801b714:	701a      	strb	r2, [r3, #0]

	return 0;
 801b716:	f04f 0300 	mov.w	r3, #0
}
 801b71a:	4618      	mov	r0, r3
 801b71c:	f107 0718 	add.w	r7, r7, #24
 801b720:	46bd      	mov	sp, r7
 801b722:	bd80      	pop	{r7, pc}

0801b724 <synopGMAC_attach>:
  * \return 0 upon success. Error code upon failure.
  * \note This is important function. No kernel api provided by Synopsys 
  */

s32 synopGMAC_attach (synopGMACdevice * gmacdev, u32 macBase, u32 dmaBase, u32 phyBase) 
{
 801b724:	b580      	push	{r7, lr}
 801b726:	b086      	sub	sp, #24
 801b728:	af00      	add	r7, sp, #0
 801b72a:	60f8      	str	r0, [r7, #12]
 801b72c:	60b9      	str	r1, [r7, #8]
 801b72e:	607a      	str	r2, [r7, #4]
 801b730:	603b      	str	r3, [r7, #0]
	u8 mac_addr0[6] = DEFAULT_MAC_ADDRESS;
 801b732:	f646 0380 	movw	r3, #26752	; 0x6880
 801b736:	f6c0 0302 	movt	r3, #2050	; 0x802
 801b73a:	f107 0210 	add.w	r2, r7, #16
 801b73e:	6818      	ldr	r0, [r3, #0]
 801b740:	6010      	str	r0, [r2, #0]
 801b742:	889b      	ldrh	r3, [r3, #4]
 801b744:	8093      	strh	r3, [r2, #4]
	/*Make sure the Device data strucure is cleared before we proceed further*/

	memset((void *) gmacdev,0,sizeof(synopGMACdevice));
 801b746:	68f8      	ldr	r0, [r7, #12]
 801b748:	f04f 0100 	mov.w	r1, #0
 801b74c:	f04f 02c4 	mov.w	r2, #196	; 0xc4
 801b750:	f008 f8ce 	bl	80238f0 <memset>
	/*Populate the mac and dma base addresses*/
	gmacdev->MacBase = macBase;
 801b754:	68fb      	ldr	r3, [r7, #12]
 801b756:	68ba      	ldr	r2, [r7, #8]
 801b758:	601a      	str	r2, [r3, #0]
	gmacdev->DmaBase = dmaBase;
 801b75a:	68fb      	ldr	r3, [r7, #12]
 801b75c:	687a      	ldr	r2, [r7, #4]
 801b75e:	605a      	str	r2, [r3, #4]
	gmacdev->PhyBase = phyBase;
 801b760:	68fb      	ldr	r3, [r7, #12]
 801b762:	683a      	ldr	r2, [r7, #0]
 801b764:	609a      	str	r2, [r3, #8]

	/* Program/flash in the station/IP's Mac address */
	synopGMAC_set_mac_addr(gmacdev,GmacAddr0High,GmacAddr0Low, mac_addr0); 
 801b766:	f107 0310 	add.w	r3, r7, #16
 801b76a:	68f8      	ldr	r0, [r7, #12]
 801b76c:	f04f 0140 	mov.w	r1, #64	; 0x40
 801b770:	f04f 0244 	mov.w	r2, #68	; 0x44
 801b774:	f7ff ff50 	bl	801b618 <synopGMAC_set_mac_addr>

	return 0;	
 801b778:	f04f 0300 	mov.w	r3, #0
}
 801b77c:	4618      	mov	r0, r3
 801b77e:	f107 0718 	add.w	r7, r7, #24
 801b782:	46bd      	mov	sp, r7
 801b784:	bd80      	pop	{r7, pc}
 801b786:	bf00      	nop

0801b788 <synopGMAC_rx_desc_init_ring>:
  * \return void.
  * \note Initialization of the buffer1, buffer2, data1,data2 and status are not done here. This only initializes whether one wants to use this descriptor
  * in chain mode or ring mode. For chain mode of operation the buffer2 and data2 are programmed before calling this function.
  */
void synopGMAC_rx_desc_init_ring(DmaDesc *desc, bool last_ring_desc)
{
 801b788:	b480      	push	{r7}
 801b78a:	b083      	sub	sp, #12
 801b78c:	af00      	add	r7, sp, #0
 801b78e:	6078      	str	r0, [r7, #4]
 801b790:	460b      	mov	r3, r1
 801b792:	70fb      	strb	r3, [r7, #3]
	desc->status = 0;
 801b794:	687b      	ldr	r3, [r7, #4]
 801b796:	f04f 0200 	mov.w	r2, #0
 801b79a:	601a      	str	r2, [r3, #0]
	desc->length = last_ring_desc ? RxDescEndOfRing : 0;
 801b79c:	78fb      	ldrb	r3, [r7, #3]
 801b79e:	2b00      	cmp	r3, #0
 801b7a0:	d002      	beq.n	801b7a8 <synopGMAC_rx_desc_init_ring+0x20>
 801b7a2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 801b7a6:	e001      	b.n	801b7ac <synopGMAC_rx_desc_init_ring+0x24>
 801b7a8:	f04f 0300 	mov.w	r3, #0
 801b7ac:	687a      	ldr	r2, [r7, #4]
 801b7ae:	6053      	str	r3, [r2, #4]
	desc->buffer1 = 0;
 801b7b0:	687b      	ldr	r3, [r7, #4]
 801b7b2:	f04f 0200 	mov.w	r2, #0
 801b7b6:	609a      	str	r2, [r3, #8]
	desc->buffer2 = 0;
 801b7b8:	687b      	ldr	r3, [r7, #4]
 801b7ba:	f04f 0200 	mov.w	r2, #0
 801b7be:	60da      	str	r2, [r3, #12]
	desc->data1 = 0;
 801b7c0:	687b      	ldr	r3, [r7, #4]
 801b7c2:	f04f 0200 	mov.w	r2, #0
 801b7c6:	621a      	str	r2, [r3, #32]
	desc->data2 = 0;
 801b7c8:	687b      	ldr	r3, [r7, #4]
 801b7ca:	f04f 0200 	mov.w	r2, #0
 801b7ce:	625a      	str	r2, [r3, #36]	; 0x24
	return;
 801b7d0:	bf00      	nop
}
 801b7d2:	f107 070c 	add.w	r7, r7, #12
 801b7d6:	46bd      	mov	sp, r7
 801b7d8:	bc80      	pop	{r7}
 801b7da:	4770      	bx	lr

0801b7dc <synopGMAC_tx_desc_init_ring>:
  * \return void.
  * \note Initialization of the buffer1, buffer2, data1,data2 and status are not done here. This only initializes whether one wants to use this descriptor
  * in chain mode or ring mode. For chain mode of operation the buffer2 and data2 are programmed before calling this function.
  */
void synopGMAC_tx_desc_init_ring(DmaDesc *desc, bool last_ring_desc)
{
 801b7dc:	b480      	push	{r7}
 801b7de:	b083      	sub	sp, #12
 801b7e0:	af00      	add	r7, sp, #0
 801b7e2:	6078      	str	r0, [r7, #4]
 801b7e4:	460b      	mov	r3, r1
 801b7e6:	70fb      	strb	r3, [r7, #3]
	#ifdef ENH_DESC
	desc->status = last_ring_desc? TxDescEndOfRing : 0;
 801b7e8:	78fb      	ldrb	r3, [r7, #3]
 801b7ea:	2b00      	cmp	r3, #0
 801b7ec:	d002      	beq.n	801b7f4 <synopGMAC_tx_desc_init_ring+0x18>
 801b7ee:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 801b7f2:	e001      	b.n	801b7f8 <synopGMAC_tx_desc_init_ring+0x1c>
 801b7f4:	f04f 0300 	mov.w	r3, #0
 801b7f8:	687a      	ldr	r2, [r7, #4]
 801b7fa:	6013      	str	r3, [r2, #0]
	desc->length = 0; 
 801b7fc:	687b      	ldr	r3, [r7, #4]
 801b7fe:	f04f 0200 	mov.w	r2, #0
 801b802:	605a      	str	r2, [r3, #4]
	desc->buffer1 = 0;
	desc->buffer2 = 0;
	desc->data1 = 0;
	desc->data2 = 0;
	*/
	return;
 801b804:	bf00      	nop
}
 801b806:	f107 070c 	add.w	r7, r7, #12
 801b80a:	46bd      	mov	sp, r7
 801b80c:	bc80      	pop	{r7}
 801b80e:	4770      	bx	lr

0801b810 <synopGMAC_rx_desc_init_chain>:
  * @param[in] whether end of ring
  * \return void.
  */

void synopGMAC_rx_desc_init_chain(DmaDesc * desc)
{
 801b810:	b480      	push	{r7}
 801b812:	b083      	sub	sp, #12
 801b814:	af00      	add	r7, sp, #0
 801b816:	6078      	str	r0, [r7, #4]
	desc->status = 0;
 801b818:	687b      	ldr	r3, [r7, #4]
 801b81a:	f04f 0200 	mov.w	r2, #0
 801b81e:	601a      	str	r2, [r3, #0]
	desc->length = RxDescChain;
 801b820:	687b      	ldr	r3, [r7, #4]
 801b822:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 801b826:	605a      	str	r2, [r3, #4]
	desc->buffer1 = 0;
 801b828:	687b      	ldr	r3, [r7, #4]
 801b82a:	f04f 0200 	mov.w	r2, #0
 801b82e:	609a      	str	r2, [r3, #8]
	desc->data1 = 0;
 801b830:	687b      	ldr	r3, [r7, #4]
 801b832:	f04f 0200 	mov.w	r2, #0
 801b836:	621a      	str	r2, [r3, #32]
	return;
 801b838:	bf00      	nop
}
 801b83a:	f107 070c 	add.w	r7, r7, #12
 801b83e:	46bd      	mov	sp, r7
 801b840:	bc80      	pop	{r7}
 801b842:	4770      	bx	lr

0801b844 <synopGMAC_tx_desc_init_chain>:
  * @param[in] pointer to DmaDesc structure.
  * @param[in] whether end of ring
  * \return void.
  */
void synopGMAC_tx_desc_init_chain(DmaDesc * desc)
{
 801b844:	b480      	push	{r7}
 801b846:	b083      	sub	sp, #12
 801b848:	af00      	add	r7, sp, #0
 801b84a:	6078      	str	r0, [r7, #4]
	#ifdef ENH_DESC
	desc->status = TxDescChain;
 801b84c:	687b      	ldr	r3, [r7, #4]
 801b84e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 801b852:	601a      	str	r2, [r3, #0]
	desc->length = 0;
 801b854:	687b      	ldr	r3, [r7, #4]
 801b856:	f04f 0200 	mov.w	r2, #0
 801b85a:	605a      	str	r2, [r3, #4]
	#else
	desc->length = TxDescChain;
	#endif
	return;
 801b85c:	bf00      	nop

}
 801b85e:	f107 070c 	add.w	r7, r7, #12
 801b862:	46bd      	mov	sp, r7
 801b864:	bc80      	pop	{r7}
 801b866:	4770      	bx	lr

0801b868 <synopGMAC_init_tx_rx_desc_queue>:


s32 synopGMAC_init_tx_rx_desc_queue(synopGMACdevice *gmacdev)
{
 801b868:	b580      	push	{r7, lr}
 801b86a:	b084      	sub	sp, #16
 801b86c:	af00      	add	r7, sp, #0
 801b86e:	6078      	str	r0, [r7, #4]
	s32 i;
	for(i =0; i < gmacdev -> TxDescCount; i++){
 801b870:	f04f 0300 	mov.w	r3, #0
 801b874:	60fb      	str	r3, [r7, #12]
 801b876:	e01b      	b.n	801b8b0 <synopGMAC_init_tx_rx_desc_queue+0x48>
	synopGMAC_tx_desc_init_ring(gmacdev->TxDesc + i, i == gmacdev->TxDescCount-1);
 801b878:	687b      	ldr	r3, [r7, #4]
 801b87a:	6999      	ldr	r1, [r3, #24]
 801b87c:	68fa      	ldr	r2, [r7, #12]
 801b87e:	4613      	mov	r3, r2
 801b880:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b884:	189b      	adds	r3, r3, r2
 801b886:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801b88a:	18ca      	adds	r2, r1, r3
 801b88c:	68f9      	ldr	r1, [r7, #12]
 801b88e:	687b      	ldr	r3, [r7, #4]
 801b890:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b892:	f103 33ff 	add.w	r3, r3, #4294967295
 801b896:	4299      	cmp	r1, r3
 801b898:	bf14      	ite	ne
 801b89a:	2300      	movne	r3, #0
 801b89c:	2301      	moveq	r3, #1
 801b89e:	b2db      	uxtb	r3, r3
 801b8a0:	4610      	mov	r0, r2
 801b8a2:	4619      	mov	r1, r3
 801b8a4:	f7ff ff9a 	bl	801b7dc <synopGMAC_tx_desc_init_ring>


s32 synopGMAC_init_tx_rx_desc_queue(synopGMACdevice *gmacdev)
{
	s32 i;
	for(i =0; i < gmacdev -> TxDescCount; i++){
 801b8a8:	68fb      	ldr	r3, [r7, #12]
 801b8aa:	f103 0301 	add.w	r3, r3, #1
 801b8ae:	60fb      	str	r3, [r7, #12]
 801b8b0:	68fa      	ldr	r2, [r7, #12]
 801b8b2:	687b      	ldr	r3, [r7, #4]
 801b8b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b8b6:	429a      	cmp	r2, r3
 801b8b8:	d3de      	bcc.n	801b878 <synopGMAC_init_tx_rx_desc_queue+0x10>
	synopGMAC_tx_desc_init_ring(gmacdev->TxDesc + i, i == gmacdev->TxDescCount-1);
	}

	for(i =0; i < gmacdev -> RxDescCount; i++){
 801b8ba:	f04f 0300 	mov.w	r3, #0
 801b8be:	60fb      	str	r3, [r7, #12]
 801b8c0:	e01b      	b.n	801b8fa <synopGMAC_init_tx_rx_desc_queue+0x92>
	synopGMAC_rx_desc_init_ring(gmacdev->RxDesc + i, i == gmacdev->RxDescCount-1);
 801b8c2:	687b      	ldr	r3, [r7, #4]
 801b8c4:	69d9      	ldr	r1, [r3, #28]
 801b8c6:	68fa      	ldr	r2, [r7, #12]
 801b8c8:	4613      	mov	r3, r2
 801b8ca:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801b8ce:	189b      	adds	r3, r3, r2
 801b8d0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801b8d4:	18ca      	adds	r2, r1, r3
 801b8d6:	68f9      	ldr	r1, [r7, #12]
 801b8d8:	687b      	ldr	r3, [r7, #4]
 801b8da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801b8dc:	f103 33ff 	add.w	r3, r3, #4294967295
 801b8e0:	4299      	cmp	r1, r3
 801b8e2:	bf14      	ite	ne
 801b8e4:	2300      	movne	r3, #0
 801b8e6:	2301      	moveq	r3, #1
 801b8e8:	b2db      	uxtb	r3, r3
 801b8ea:	4610      	mov	r0, r2
 801b8ec:	4619      	mov	r1, r3
 801b8ee:	f7ff ff4b 	bl	801b788 <synopGMAC_rx_desc_init_ring>
	s32 i;
	for(i =0; i < gmacdev -> TxDescCount; i++){
	synopGMAC_tx_desc_init_ring(gmacdev->TxDesc + i, i == gmacdev->TxDescCount-1);
	}

	for(i =0; i < gmacdev -> RxDescCount; i++){
 801b8f2:	68fb      	ldr	r3, [r7, #12]
 801b8f4:	f103 0301 	add.w	r3, r3, #1
 801b8f8:	60fb      	str	r3, [r7, #12]
 801b8fa:	68fa      	ldr	r2, [r7, #12]
 801b8fc:	687b      	ldr	r3, [r7, #4]
 801b8fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801b900:	429a      	cmp	r2, r3
 801b902:	d3de      	bcc.n	801b8c2 <synopGMAC_init_tx_rx_desc_queue+0x5a>
	synopGMAC_rx_desc_init_ring(gmacdev->RxDesc + i, i == gmacdev->RxDescCount-1);
	}
	
	gmacdev->TxNext = 0;
 801b904:	687b      	ldr	r3, [r7, #4]
 801b906:	f04f 0200 	mov.w	r2, #0
 801b90a:	635a      	str	r2, [r3, #52]	; 0x34
	gmacdev->TxBusy = 0;
 801b90c:	687b      	ldr	r3, [r7, #4]
 801b90e:	f04f 0200 	mov.w	r2, #0
 801b912:	631a      	str	r2, [r3, #48]	; 0x30
	gmacdev->RxNext = 0;
 801b914:	687b      	ldr	r3, [r7, #4]
 801b916:	f04f 0200 	mov.w	r2, #0
 801b91a:	63da      	str	r2, [r3, #60]	; 0x3c
	gmacdev->RxBusy = 0;
 801b91c:	687b      	ldr	r3, [r7, #4]
 801b91e:	f04f 0200 	mov.w	r2, #0
 801b922:	639a      	str	r2, [r3, #56]	; 0x38
	
	return -ESYNOPGMACNOERR;
 801b924:	f04f 0300 	mov.w	r3, #0
}
 801b928:	4618      	mov	r0, r3
 801b92a:	f107 0710 	add.w	r7, r7, #16
 801b92e:	46bd      	mov	sp, r7
 801b930:	bd80      	pop	{r7, pc}
 801b932:	bf00      	nop

0801b934 <synopGMAC_init_rx_desc_base>:
  * Dma Rx Base address with the starting address of the descriptor ring or chain.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_init_rx_desc_base(synopGMACdevice *gmacdev)
{
 801b934:	b580      	push	{r7, lr}
 801b936:	b082      	sub	sp, #8
 801b938:	af00      	add	r7, sp, #0
 801b93a:	6078      	str	r0, [r7, #4]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase,DmaRxBaseAddr,(u32)gmacdev->RxDescDma);
 801b93c:	687b      	ldr	r3, [r7, #4]
 801b93e:	685b      	ldr	r3, [r3, #4]
 801b940:	461a      	mov	r2, r3
 801b942:	687b      	ldr	r3, [r7, #4]
 801b944:	695b      	ldr	r3, [r3, #20]
 801b946:	4610      	mov	r0, r2
 801b948:	f04f 010c 	mov.w	r1, #12
 801b94c:	461a      	mov	r2, r3
 801b94e:	f001 fe3b 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801b952:	bf00      	nop
}
 801b954:	f107 0708 	add.w	r7, r7, #8
 801b958:	46bd      	mov	sp, r7
 801b95a:	bd80      	pop	{r7, pc}

0801b95c <synopGMAC_init_tx_desc_base>:
  * Dma Tx Base address with the starting address of the descriptor ring or chain.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_init_tx_desc_base(synopGMACdevice *gmacdev)
{
 801b95c:	b580      	push	{r7, lr}
 801b95e:	b082      	sub	sp, #8
 801b960:	af00      	add	r7, sp, #0
 801b962:	6078      	str	r0, [r7, #4]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase,DmaTxBaseAddr,(u32)gmacdev->TxDescDma);
 801b964:	687b      	ldr	r3, [r7, #4]
 801b966:	685b      	ldr	r3, [r3, #4]
 801b968:	461a      	mov	r2, r3
 801b96a:	687b      	ldr	r3, [r7, #4]
 801b96c:	691b      	ldr	r3, [r3, #16]
 801b96e:	4610      	mov	r0, r2
 801b970:	f04f 0110 	mov.w	r1, #16
 801b974:	461a      	mov	r2, r3
 801b976:	f001 fe27 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801b97a:	bf00      	nop
}
 801b97c:	f107 0708 	add.w	r7, r7, #8
 801b980:	46bd      	mov	sp, r7
 801b982:	bd80      	pop	{r7, pc}

0801b984 <synopGMAC_set_owner_dma>:
  * indicating the DMA is the owner for this descriptor. 
  * @param[in] pointer to DmaDesc structure.
  * \return returns void.
  */
void synopGMAC_set_owner_dma(DmaDesc *desc)
{
 801b984:	b480      	push	{r7}
 801b986:	b083      	sub	sp, #12
 801b988:	af00      	add	r7, sp, #0
 801b98a:	6078      	str	r0, [r7, #4]
desc->status |=  DescOwnByDma;
 801b98c:	687b      	ldr	r3, [r7, #4]
 801b98e:	681b      	ldr	r3, [r3, #0]
 801b990:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 801b994:	687b      	ldr	r3, [r7, #4]
 801b996:	601a      	str	r2, [r3, #0]
}
 801b998:	f107 070c 	add.w	r7, r7, #12
 801b99c:	46bd      	mov	sp, r7
 801b99e:	bc80      	pop	{r7}
 801b9a0:	4770      	bx	lr
 801b9a2:	bf00      	nop

0801b9a4 <synopGMAC_set_desc_sof>:
  * This Descriptor contains the start of ethernet frame.
  * @param[in] pointer to DmaDesc structure.
  * \return returns void.
  */
void synopGMAC_set_desc_sof(DmaDesc *desc)
{
 801b9a4:	b480      	push	{r7}
 801b9a6:	b083      	sub	sp, #12
 801b9a8:	af00      	add	r7, sp, #0
 801b9aa:	6078      	str	r0, [r7, #4]
#ifdef ENH_DESC
desc->status |= DescTxFirst;//ENH_DESC
 801b9ac:	687b      	ldr	r3, [r7, #4]
 801b9ae:	681b      	ldr	r3, [r3, #0]
 801b9b0:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 801b9b4:	687b      	ldr	r3, [r7, #4]
 801b9b6:	601a      	str	r2, [r3, #0]
#else
desc->length |= DescTxFirst;
#endif

}
 801b9b8:	f107 070c 	add.w	r7, r7, #12
 801b9bc:	46bd      	mov	sp, r7
 801b9be:	bc80      	pop	{r7}
 801b9c0:	4770      	bx	lr
 801b9c2:	bf00      	nop

0801b9c4 <synopGMAC_set_desc_eof>:
  * This descriptor contains the End of ethernet frame.
  * @param[in] pointer to DmaDesc structure.
  * \return returns void.
  */
void synopGMAC_set_desc_eof(DmaDesc *desc)
{
 801b9c4:	b480      	push	{r7}
 801b9c6:	b083      	sub	sp, #12
 801b9c8:	af00      	add	r7, sp, #0
 801b9ca:	6078      	str	r0, [r7, #4]
#ifdef ENH_DESC
desc->status |= DescTxLast;//ENH_DESC
 801b9cc:	687b      	ldr	r3, [r7, #4]
 801b9ce:	681b      	ldr	r3, [r3, #0]
 801b9d0:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 801b9d4:	687b      	ldr	r3, [r7, #4]
 801b9d6:	601a      	str	r2, [r3, #0]
#else
desc->length |= DescTxLast;
#endif
}
 801b9d8:	f107 070c 	add.w	r7, r7, #12
 801b9dc:	46bd      	mov	sp, r7
 801b9de:	bc80      	pop	{r7}
 801b9e0:	4770      	bx	lr
 801b9e2:	bf00      	nop

0801b9e4 <synopGMAC_is_sof_in_rx_desc>:
  * contains a fresh ethernet frame?
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if SOF in current descriptor, else returns fail.
  */
bool synopGMAC_is_sof_in_rx_desc(DmaDesc *desc)
{
 801b9e4:	b480      	push	{r7}
 801b9e6:	b083      	sub	sp, #12
 801b9e8:	af00      	add	r7, sp, #0
 801b9ea:	6078      	str	r0, [r7, #4]
return ((desc->status & DescRxFirst) == DescRxFirst);                      
 801b9ec:	687b      	ldr	r3, [r7, #4]
 801b9ee:	681b      	ldr	r3, [r3, #0]
 801b9f0:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801b9f4:	2b00      	cmp	r3, #0
 801b9f6:	bf0c      	ite	eq
 801b9f8:	2300      	moveq	r3, #0
 801b9fa:	2301      	movne	r3, #1
 801b9fc:	b2db      	uxtb	r3, r3
}
 801b9fe:	4618      	mov	r0, r3
 801ba00:	f107 070c 	add.w	r7, r7, #12
 801ba04:	46bd      	mov	sp, r7
 801ba06:	bc80      	pop	{r7}
 801ba08:	4770      	bx	lr
 801ba0a:	bf00      	nop

0801ba0c <synopGMAC_is_eof_in_rx_desc>:
  * contains end of ethernet frame?
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if SOF in current descriptor, else returns fail.
  */
bool synopGMAC_is_eof_in_rx_desc(DmaDesc *desc)
{
 801ba0c:	b480      	push	{r7}
 801ba0e:	b083      	sub	sp, #12
 801ba10:	af00      	add	r7, sp, #0
 801ba12:	6078      	str	r0, [r7, #4]
return ((desc->status & DescRxLast) == DescRxLast);                      
 801ba14:	687b      	ldr	r3, [r7, #4]
 801ba16:	681b      	ldr	r3, [r3, #0]
 801ba18:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801ba1c:	2b00      	cmp	r3, #0
 801ba1e:	bf0c      	ite	eq
 801ba20:	2300      	moveq	r3, #0
 801ba22:	2301      	movne	r3, #1
 801ba24:	b2db      	uxtb	r3, r3
}
 801ba26:	4618      	mov	r0, r3
 801ba28:	f107 070c 	add.w	r7, r7, #12
 801ba2c:	46bd      	mov	sp, r7
 801ba2e:	bc80      	pop	{r7}
 801ba30:	4770      	bx	lr
 801ba32:	bf00      	nop

0801ba34 <synopGMAC_is_da_filter_failed>:
  * checks whether destination address filter failed in the rx frame.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if Failed, false if not.
  */
bool synopGMAC_is_da_filter_failed(DmaDesc *desc)
{
 801ba34:	b480      	push	{r7}
 801ba36:	b083      	sub	sp, #12
 801ba38:	af00      	add	r7, sp, #0
 801ba3a:	6078      	str	r0, [r7, #4]
return ((desc->status & DescDAFilterFail) == DescDAFilterFail);                      
 801ba3c:	687b      	ldr	r3, [r7, #4]
 801ba3e:	681b      	ldr	r3, [r3, #0]
 801ba40:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 801ba44:	2b00      	cmp	r3, #0
 801ba46:	bf0c      	ite	eq
 801ba48:	2300      	moveq	r3, #0
 801ba4a:	2301      	movne	r3, #1
 801ba4c:	b2db      	uxtb	r3, r3
}
 801ba4e:	4618      	mov	r0, r3
 801ba50:	f107 070c 	add.w	r7, r7, #12
 801ba54:	46bd      	mov	sp, r7
 801ba56:	bc80      	pop	{r7}
 801ba58:	4770      	bx	lr
 801ba5a:	bf00      	nop

0801ba5c <synopGMAC_is_sa_filter_failed>:
  * checks whether source address filter failed in the rx frame.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if Failed, false if not.
  */
bool synopGMAC_is_sa_filter_failed(DmaDesc *desc)
{
 801ba5c:	b480      	push	{r7}
 801ba5e:	b083      	sub	sp, #12
 801ba60:	af00      	add	r7, sp, #0
 801ba62:	6078      	str	r0, [r7, #4]
return ((desc->status & DescSAFilterFail) == DescSAFilterFail);                      
 801ba64:	687b      	ldr	r3, [r7, #4]
 801ba66:	681b      	ldr	r3, [r3, #0]
 801ba68:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801ba6c:	2b00      	cmp	r3, #0
 801ba6e:	bf0c      	ite	eq
 801ba70:	2300      	moveq	r3, #0
 801ba72:	2301      	movne	r3, #1
 801ba74:	b2db      	uxtb	r3, r3
}
 801ba76:	4618      	mov	r0, r3
 801ba78:	f107 070c 	add.w	r7, r7, #12
 801ba7c:	46bd      	mov	sp, r7
 801ba7e:	bc80      	pop	{r7}
 801ba80:	4770      	bx	lr
 801ba82:	bf00      	nop

0801ba84 <synopGMAC_is_desc_owned_by_dma>:
  * If descriptor is owned by DMA then the OWN bit is set to 1. This API is same for both ring and chain mode.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if Dma owns descriptor and false if not.
  */
bool synopGMAC_is_desc_owned_by_dma(DmaDesc *desc)
{
 801ba84:	b480      	push	{r7}
 801ba86:	b083      	sub	sp, #12
 801ba88:	af00      	add	r7, sp, #0
 801ba8a:	6078      	str	r0, [r7, #4]
return ((desc->status & DescOwnByDma) == DescOwnByDma );
 801ba8c:	687b      	ldr	r3, [r7, #4]
 801ba8e:	681b      	ldr	r3, [r3, #0]
 801ba90:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 801ba94:	b2db      	uxtb	r3, r3
}
 801ba96:	4618      	mov	r0, r3
 801ba98:	f107 070c 	add.w	r7, r7, #12
 801ba9c:	46bd      	mov	sp, r7
 801ba9e:	bc80      	pop	{r7}
 801baa0:	4770      	bx	lr
 801baa2:	bf00      	nop

0801baa4 <synopGMAC_get_rx_desc_frame_length>:
  * This returns the no of bytes received in the received ethernet frame including CRC(FCS).
  * @param[in] pointer to DmaDesc structure.
  * \return returns the length of received frame lengths in bytes.
  */
u32 synopGMAC_get_rx_desc_frame_length(u32 status)
{
 801baa4:	b480      	push	{r7}
 801baa6:	b083      	sub	sp, #12
 801baa8:	af00      	add	r7, sp, #0
 801baaa:	6078      	str	r0, [r7, #4]
	return ((status & DescFrameLengthMask) >> DescFrameLengthShift);
 801baac:	687a      	ldr	r2, [r7, #4]
 801baae:	f04f 0300 	mov.w	r3, #0
 801bab2:	f6c3 73ff 	movt	r3, #16383	; 0x3fff
 801bab6:	4013      	ands	r3, r2
 801bab8:	ea4f 4313 	mov.w	r3, r3, lsr #16
}
 801babc:	4618      	mov	r0, r3
 801babe:	f107 070c 	add.w	r7, r7, #12
 801bac2:	46bd      	mov	sp, r7
 801bac4:	bc80      	pop	{r7}
 801bac6:	4770      	bx	lr

0801bac8 <synopGMAC_is_desc_valid>:
  * error the descritpor is said to be a valid descriptor.
  * @param[in] pointer to DmaDesc structure.
  * \return True if desc valid. false if error.
  */
bool synopGMAC_is_desc_valid(u32 status)
{
 801bac8:	b480      	push	{r7}
 801baca:	b083      	sub	sp, #12
 801bacc:	af00      	add	r7, sp, #0
 801bace:	6078      	str	r0, [r7, #4]
	return ((status & DescError) == 0);
 801bad0:	687b      	ldr	r3, [r7, #4]
 801bad2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801bad6:	2b00      	cmp	r3, #0
 801bad8:	bf14      	ite	ne
 801bada:	2300      	movne	r3, #0
 801badc:	2301      	moveq	r3, #1
 801bade:	b2db      	uxtb	r3, r3
}
 801bae0:	4618      	mov	r0, r3
 801bae2:	f107 070c 	add.w	r7, r7, #12
 801bae6:	46bd      	mov	sp, r7
 801bae8:	bc80      	pop	{r7}
 801baea:	4770      	bx	lr

0801baec <synopGMAC_is_desc_empty>:
  * In chain mode buffer2 length is 0 but buffer2 itself contains the next descriptor address.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if descriptor is empty, false if not empty.
  */
bool synopGMAC_is_desc_empty(DmaDesc *desc)
{
 801baec:	b480      	push	{r7}
 801baee:	b083      	sub	sp, #12
 801baf0:	af00      	add	r7, sp, #0
 801baf2:	6078      	str	r0, [r7, #4]
	//if both the buffer1 length and buffer2 length are zero desc is empty
    return(((desc->length  & DescSize1Mask) == 0) && ((desc->length  & DescSize2Mask) == 0) );
 801baf4:	687b      	ldr	r3, [r7, #4]
 801baf6:	685b      	ldr	r3, [r3, #4]
 801baf8:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801bafc:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801bb00:	2b00      	cmp	r3, #0
 801bb02:	d10b      	bne.n	801bb1c <synopGMAC_is_desc_empty+0x30>
 801bb04:	687b      	ldr	r3, [r7, #4]
 801bb06:	685a      	ldr	r2, [r3, #4]
 801bb08:	f04f 0300 	mov.w	r3, #0
 801bb0c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
 801bb10:	4013      	ands	r3, r2
 801bb12:	2b00      	cmp	r3, #0
 801bb14:	d102      	bne.n	801bb1c <synopGMAC_is_desc_empty+0x30>
 801bb16:	f04f 0301 	mov.w	r3, #1
 801bb1a:	e001      	b.n	801bb20 <synopGMAC_is_desc_empty+0x34>
 801bb1c:	f04f 0300 	mov.w	r3, #0
 801bb20:	b2db      	uxtb	r3, r3
}
 801bb22:	4618      	mov	r0, r3
 801bb24:	f107 070c 	add.w	r7, r7, #12
 801bb28:	46bd      	mov	sp, r7
 801bb2a:	bc80      	pop	{r7}
 801bb2c:	4770      	bx	lr
 801bb2e:	bf00      	nop

0801bb30 <synopGMAC_is_rx_desc_valid>:
  * if rx descripor is not in error and complete frame is available in the same descriptor
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if no error and first and last desc bits are set, otherwise it returns false.
  */
bool synopGMAC_is_rx_desc_valid(u32 status)
{
 801bb30:	b480      	push	{r7}
 801bb32:	b083      	sub	sp, #12
 801bb34:	af00      	add	r7, sp, #0
 801bb36:	6078      	str	r0, [r7, #4]
	return ((status & DescError) == 0) && ((status & DescRxFirst) == DescRxFirst) && ((status & DescRxLast) == DescRxLast);
 801bb38:	687b      	ldr	r3, [r7, #4]
 801bb3a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801bb3e:	2b00      	cmp	r3, #0
 801bb40:	d10c      	bne.n	801bb5c <synopGMAC_is_rx_desc_valid+0x2c>
 801bb42:	687b      	ldr	r3, [r7, #4]
 801bb44:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801bb48:	2b00      	cmp	r3, #0
 801bb4a:	d007      	beq.n	801bb5c <synopGMAC_is_rx_desc_valid+0x2c>
 801bb4c:	687b      	ldr	r3, [r7, #4]
 801bb4e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801bb52:	2b00      	cmp	r3, #0
 801bb54:	d002      	beq.n	801bb5c <synopGMAC_is_rx_desc_valid+0x2c>
 801bb56:	f04f 0301 	mov.w	r3, #1
 801bb5a:	e001      	b.n	801bb60 <synopGMAC_is_rx_desc_valid+0x30>
 801bb5c:	f04f 0300 	mov.w	r3, #0
 801bb60:	b2db      	uxtb	r3, r3
}
 801bb62:	4618      	mov	r0, r3
 801bb64:	f107 070c 	add.w	r7, r7, #12
 801bb68:	46bd      	mov	sp, r7
 801bb6a:	bc80      	pop	{r7}
 801bb6c:	4770      	bx	lr
 801bb6e:	bf00      	nop

0801bb70 <synopGMAC_is_tx_aborted>:
  * Checks whether the tx is aborted due to collisions.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if collisions, else returns false.
  */
bool synopGMAC_is_tx_aborted(u32 status)
{
 801bb70:	b480      	push	{r7}
 801bb72:	b083      	sub	sp, #12
 801bb74:	af00      	add	r7, sp, #0
 801bb76:	6078      	str	r0, [r7, #4]
	return (((status & DescTxLateCollision) == DescTxLateCollision) | ((status & DescTxExcCollisions) == DescTxExcCollisions));
 801bb78:	687b      	ldr	r3, [r7, #4]
 801bb7a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801bb7e:	2b00      	cmp	r3, #0
 801bb80:	bf0c      	ite	eq
 801bb82:	2300      	moveq	r3, #0
 801bb84:	2301      	movne	r3, #1
 801bb86:	b2da      	uxtb	r2, r3
 801bb88:	687b      	ldr	r3, [r7, #4]
 801bb8a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801bb8e:	2b00      	cmp	r3, #0
 801bb90:	bf0c      	ite	eq
 801bb92:	2300      	moveq	r3, #0
 801bb94:	2301      	movne	r3, #1
 801bb96:	b2db      	uxtb	r3, r3
 801bb98:	4313      	orrs	r3, r2
 801bb9a:	b2db      	uxtb	r3, r3

}
 801bb9c:	4618      	mov	r0, r3
 801bb9e:	f107 070c 	add.w	r7, r7, #12
 801bba2:	46bd      	mov	sp, r7
 801bba4:	bc80      	pop	{r7}
 801bba6:	4770      	bx	lr

0801bba8 <synopGMAC_is_tx_carrier_error>:
  * Checks whether the tx carrier error.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if carrier error occured, else returns falser.
  */
bool synopGMAC_is_tx_carrier_error(u32 status)
{
 801bba8:	b480      	push	{r7}
 801bbaa:	b083      	sub	sp, #12
 801bbac:	af00      	add	r7, sp, #0
 801bbae:	6078      	str	r0, [r7, #4]
	return (((status & DescTxLostCarrier) == DescTxLostCarrier)  | ((status & DescTxNoCarrier) == DescTxNoCarrier));
 801bbb0:	687b      	ldr	r3, [r7, #4]
 801bbb2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801bbb6:	2b00      	cmp	r3, #0
 801bbb8:	bf0c      	ite	eq
 801bbba:	2300      	moveq	r3, #0
 801bbbc:	2301      	movne	r3, #1
 801bbbe:	b2da      	uxtb	r2, r3
 801bbc0:	687b      	ldr	r3, [r7, #4]
 801bbc2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801bbc6:	2b00      	cmp	r3, #0
 801bbc8:	bf0c      	ite	eq
 801bbca:	2300      	moveq	r3, #0
 801bbcc:	2301      	movne	r3, #1
 801bbce:	b2db      	uxtb	r3, r3
 801bbd0:	4313      	orrs	r3, r2
 801bbd2:	b2db      	uxtb	r3, r3
}
 801bbd4:	4618      	mov	r0, r3
 801bbd6:	f107 070c 	add.w	r7, r7, #12
 801bbda:	46bd      	mov	sp, r7
 801bbdc:	bc80      	pop	{r7}
 801bbde:	4770      	bx	lr

0801bbe0 <synopGMAC_get_tx_collision_count>:
  * Make sure to check excessive collision didnot happen to ensure the count is valid.
  * @param[in] pointer to DmaDesc structure.
  * \return returns the count value of collision.
  */
u32 synopGMAC_get_tx_collision_count(u32 status)
{
 801bbe0:	b480      	push	{r7}
 801bbe2:	b083      	sub	sp, #12
 801bbe4:	af00      	add	r7, sp, #0
 801bbe6:	6078      	str	r0, [r7, #4]
	return ((status & DescTxCollMask) >> DescTxCollShift);
 801bbe8:	687b      	ldr	r3, [r7, #4]
 801bbea:	f003 0378 	and.w	r3, r3, #120	; 0x78
 801bbee:	ea4f 03d3 	mov.w	r3, r3, lsr #3
}
 801bbf2:	4618      	mov	r0, r3
 801bbf4:	f107 070c 	add.w	r7, r7, #12
 801bbf8:	46bd      	mov	sp, r7
 801bbfa:	bc80      	pop	{r7}
 801bbfc:	4770      	bx	lr
 801bbfe:	bf00      	nop

0801bc00 <synopGMAC_is_exc_tx_collisions>:
u32 synopGMAC_is_exc_tx_collisions(u32 status)
{
 801bc00:	b480      	push	{r7}
 801bc02:	b083      	sub	sp, #12
 801bc04:	af00      	add	r7, sp, #0
 801bc06:	6078      	str	r0, [r7, #4]
	return ((status & DescTxExcCollisions) == DescTxExcCollisions);
 801bc08:	687b      	ldr	r3, [r7, #4]
 801bc0a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801bc0e:	2b00      	cmp	r3, #0
 801bc10:	bf0c      	ite	eq
 801bc12:	2300      	moveq	r3, #0
 801bc14:	2301      	movne	r3, #1
 801bc16:	b2db      	uxtb	r3, r3
}
 801bc18:	4618      	mov	r0, r3
 801bc1a:	f107 070c 	add.w	r7, r7, #12
 801bc1e:	46bd      	mov	sp, r7
 801bc20:	bc80      	pop	{r7}
 801bc22:	4770      	bx	lr

0801bc24 <synopGMAC_is_rx_frame_damaged>:
  * Retruns true if rx frame was damaged due to buffer overflow in MTL or late collision in half duplex mode.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if error else returns false.
  */
bool synopGMAC_is_rx_frame_damaged(u32 status)
{
 801bc24:	b480      	push	{r7}
 801bc26:	b083      	sub	sp, #12
 801bc28:	af00      	add	r7, sp, #0
 801bc2a:	6078      	str	r0, [r7, #4]
//bool synopGMAC_dma_rx_collisions(u32 status)
	return (((status & DescRxDamaged) == DescRxDamaged) | ((status & DescRxCollision) == DescRxCollision));
 801bc2c:	687b      	ldr	r3, [r7, #4]
 801bc2e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 801bc32:	2b00      	cmp	r3, #0
 801bc34:	bf0c      	ite	eq
 801bc36:	2300      	moveq	r3, #0
 801bc38:	2301      	movne	r3, #1
 801bc3a:	b2da      	uxtb	r2, r3
 801bc3c:	687b      	ldr	r3, [r7, #4]
 801bc3e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801bc42:	2b00      	cmp	r3, #0
 801bc44:	bf0c      	ite	eq
 801bc46:	2300      	moveq	r3, #0
 801bc48:	2301      	movne	r3, #1
 801bc4a:	b2db      	uxtb	r3, r3
 801bc4c:	4313      	orrs	r3, r2
 801bc4e:	b2db      	uxtb	r3, r3
}
 801bc50:	4618      	mov	r0, r3
 801bc52:	f107 070c 	add.w	r7, r7, #12
 801bc56:	46bd      	mov	sp, r7
 801bc58:	bc80      	pop	{r7}
 801bc5a:	4770      	bx	lr

0801bc5c <synopGMAC_is_rx_frame_collision>:
  * Retruns true if rx frame was damaged due to late collision in half duplex mode.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if error else returns false.
  */
bool synopGMAC_is_rx_frame_collision(u32 status)
{
 801bc5c:	b480      	push	{r7}
 801bc5e:	b083      	sub	sp, #12
 801bc60:	af00      	add	r7, sp, #0
 801bc62:	6078      	str	r0, [r7, #4]
//bool synopGMAC_dma_rx_collisions(u32 status)
	return ((status & DescRxCollision) == DescRxCollision);
 801bc64:	687b      	ldr	r3, [r7, #4]
 801bc66:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801bc6a:	2b00      	cmp	r3, #0
 801bc6c:	bf0c      	ite	eq
 801bc6e:	2300      	moveq	r3, #0
 801bc70:	2301      	movne	r3, #1
 801bc72:	b2db      	uxtb	r3, r3
}
 801bc74:	4618      	mov	r0, r3
 801bc76:	f107 070c 	add.w	r7, r7, #12
 801bc7a:	46bd      	mov	sp, r7
 801bc7c:	bc80      	pop	{r7}
 801bc7e:	4770      	bx	lr

0801bc80 <synopGMAC_is_rx_crc>:
  * Retruns true if rx frame CRC error occured.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if error else returns false.
  */
bool synopGMAC_is_rx_crc(u32 status)
{
 801bc80:	b480      	push	{r7}
 801bc82:	b083      	sub	sp, #12
 801bc84:	af00      	add	r7, sp, #0
 801bc86:	6078      	str	r0, [r7, #4]
//u32 synopGMAC_dma_rx_crc(u32 status)
	return ((status & DescRxCrc) == DescRxCrc);
 801bc88:	687b      	ldr	r3, [r7, #4]
 801bc8a:	f003 0302 	and.w	r3, r3, #2
 801bc8e:	2b00      	cmp	r3, #0
 801bc90:	bf0c      	ite	eq
 801bc92:	2300      	moveq	r3, #0
 801bc94:	2301      	movne	r3, #1
 801bc96:	b2db      	uxtb	r3, r3
}
 801bc98:	4618      	mov	r0, r3
 801bc9a:	f107 070c 	add.w	r7, r7, #12
 801bc9e:	46bd      	mov	sp, r7
 801bca0:	bc80      	pop	{r7}
 801bca2:	4770      	bx	lr

0801bca4 <synopGMAC_is_frame_dribbling_errors>:
  * Retruns true if dribbling error in rx frame.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if error else returns false.
  */
bool synopGMAC_is_frame_dribbling_errors(u32 status)
{
 801bca4:	b480      	push	{r7}
 801bca6:	b083      	sub	sp, #12
 801bca8:	af00      	add	r7, sp, #0
 801bcaa:	6078      	str	r0, [r7, #4]
//u32 synopGMAC_dma_rx_frame_errors(u32 status)
	return ((status & DescRxDribbling) == DescRxDribbling);
 801bcac:	687b      	ldr	r3, [r7, #4]
 801bcae:	f003 0304 	and.w	r3, r3, #4
 801bcb2:	2b00      	cmp	r3, #0
 801bcb4:	bf0c      	ite	eq
 801bcb6:	2300      	moveq	r3, #0
 801bcb8:	2301      	movne	r3, #1
 801bcba:	b2db      	uxtb	r3, r3
}
 801bcbc:	4618      	mov	r0, r3
 801bcbe:	f107 070c 	add.w	r7, r7, #12
 801bcc2:	46bd      	mov	sp, r7
 801bcc4:	bc80      	pop	{r7}
 801bcc6:	4770      	bx	lr

0801bcc8 <synopGMAC_is_rx_frame_length_errors>:
  * Retruns true if received frame length doesnot match with the length field
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if error else returns false.
  */
bool synopGMAC_is_rx_frame_length_errors(u32 status)
{
 801bcc8:	b480      	push	{r7}
 801bcca:	b083      	sub	sp, #12
 801bccc:	af00      	add	r7, sp, #0
 801bcce:	6078      	str	r0, [r7, #4]
//u32 synopGMAC_dma_rx_length_errors(u32 status)
	return((status & DescRxLengthError) == DescRxLengthError);
 801bcd0:	687b      	ldr	r3, [r7, #4]
 801bcd2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 801bcd6:	2b00      	cmp	r3, #0
 801bcd8:	bf0c      	ite	eq
 801bcda:	2300      	moveq	r3, #0
 801bcdc:	2301      	movne	r3, #1
 801bcde:	b2db      	uxtb	r3, r3
}
 801bce0:	4618      	mov	r0, r3
 801bce2:	f107 070c 	add.w	r7, r7, #12
 801bce6:	46bd      	mov	sp, r7
 801bce8:	bc80      	pop	{r7}
 801bcea:	4770      	bx	lr

0801bcec <synopGMAC_is_last_rx_desc>:
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if it is last descriptor, false if not.
  * \note This function should not be called before initializing the descriptor using synopGMAC_desc_init().
  */
bool synopGMAC_is_last_rx_desc(synopGMACdevice * gmacdev,DmaDesc *desc)
{
 801bcec:	b480      	push	{r7}
 801bcee:	b083      	sub	sp, #12
 801bcf0:	af00      	add	r7, sp, #0
 801bcf2:	6078      	str	r0, [r7, #4]
 801bcf4:	6039      	str	r1, [r7, #0]
//bool synopGMAC_is_last_desc(DmaDesc *desc)
return (((desc->length & RxDescEndOfRing) == RxDescEndOfRing) || ((u32)gmacdev->RxDesc == desc->data2));
 801bcf6:	683b      	ldr	r3, [r7, #0]
 801bcf8:	685b      	ldr	r3, [r3, #4]
 801bcfa:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 801bcfe:	2b00      	cmp	r3, #0
 801bd00:	d106      	bne.n	801bd10 <synopGMAC_is_last_rx_desc+0x24>
 801bd02:	687b      	ldr	r3, [r7, #4]
 801bd04:	69db      	ldr	r3, [r3, #28]
 801bd06:	461a      	mov	r2, r3
 801bd08:	683b      	ldr	r3, [r7, #0]
 801bd0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801bd0c:	429a      	cmp	r2, r3
 801bd0e:	d102      	bne.n	801bd16 <synopGMAC_is_last_rx_desc+0x2a>
 801bd10:	f04f 0301 	mov.w	r3, #1
 801bd14:	e001      	b.n	801bd1a <synopGMAC_is_last_rx_desc+0x2e>
 801bd16:	f04f 0300 	mov.w	r3, #0
 801bd1a:	b2db      	uxtb	r3, r3
}
 801bd1c:	4618      	mov	r0, r3
 801bd1e:	f107 070c 	add.w	r7, r7, #12
 801bd22:	46bd      	mov	sp, r7
 801bd24:	bc80      	pop	{r7}
 801bd26:	4770      	bx	lr

0801bd28 <synopGMAC_is_last_tx_desc>:
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if it is last descriptor, false if not.
  * \note This function should not be called before initializing the descriptor using synopGMAC_desc_init().
  */
bool synopGMAC_is_last_tx_desc(synopGMACdevice * gmacdev,DmaDesc *desc)
{
 801bd28:	b480      	push	{r7}
 801bd2a:	b083      	sub	sp, #12
 801bd2c:	af00      	add	r7, sp, #0
 801bd2e:	6078      	str	r0, [r7, #4]
 801bd30:	6039      	str	r1, [r7, #0]
//bool synopGMAC_is_last_desc(DmaDesc *desc)
#ifdef ENH_DESC
	return (((desc->status & TxDescEndOfRing) == TxDescEndOfRing) || ((u32)gmacdev->TxDesc == desc->data2));
 801bd32:	683b      	ldr	r3, [r7, #0]
 801bd34:	681b      	ldr	r3, [r3, #0]
 801bd36:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 801bd3a:	2b00      	cmp	r3, #0
 801bd3c:	d106      	bne.n	801bd4c <synopGMAC_is_last_tx_desc+0x24>
 801bd3e:	687b      	ldr	r3, [r7, #4]
 801bd40:	699b      	ldr	r3, [r3, #24]
 801bd42:	461a      	mov	r2, r3
 801bd44:	683b      	ldr	r3, [r7, #0]
 801bd46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801bd48:	429a      	cmp	r2, r3
 801bd4a:	d102      	bne.n	801bd52 <synopGMAC_is_last_tx_desc+0x2a>
 801bd4c:	f04f 0301 	mov.w	r3, #1
 801bd50:	e001      	b.n	801bd56 <synopGMAC_is_last_tx_desc+0x2e>
 801bd52:	f04f 0300 	mov.w	r3, #0
 801bd56:	b2db      	uxtb	r3, r3
#else
	return (((desc->length & TxDescEndOfRing) == TxDescEndOfRing) || ((u32)gmacdev->TxDesc == desc->data2));
#endif
}
 801bd58:	4618      	mov	r0, r3
 801bd5a:	f107 070c 	add.w	r7, r7, #12
 801bd5e:	46bd      	mov	sp, r7
 801bd60:	bc80      	pop	{r7}
 801bd62:	4770      	bx	lr

0801bd64 <synopGMAC_is_rx_desc_chained>:
  * This returns true if it is this descriptor is in chain mode.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if chain mode is set, false if not.
  */
bool synopGMAC_is_rx_desc_chained(DmaDesc * desc)
{
 801bd64:	b480      	push	{r7}
 801bd66:	b083      	sub	sp, #12
 801bd68:	af00      	add	r7, sp, #0
 801bd6a:	6078      	str	r0, [r7, #4]
	return((desc->length & RxDescChain) == RxDescChain);             
 801bd6c:	687b      	ldr	r3, [r7, #4]
 801bd6e:	685b      	ldr	r3, [r3, #4]
 801bd70:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 801bd74:	2b00      	cmp	r3, #0
 801bd76:	bf0c      	ite	eq
 801bd78:	2300      	moveq	r3, #0
 801bd7a:	2301      	movne	r3, #1
 801bd7c:	b2db      	uxtb	r3, r3
}
 801bd7e:	4618      	mov	r0, r3
 801bd80:	f107 070c 	add.w	r7, r7, #12
 801bd84:	46bd      	mov	sp, r7
 801bd86:	bc80      	pop	{r7}
 801bd88:	4770      	bx	lr
 801bd8a:	bf00      	nop

0801bd8c <synopGMAC_is_tx_desc_chained>:
  * This returns true if it is this descriptor is in chain mode.
  * @param[in] pointer to DmaDesc structure.
  * \return returns true if chain mode is set, false if not.
  */
bool synopGMAC_is_tx_desc_chained(DmaDesc * desc)
{
 801bd8c:	b480      	push	{r7}
 801bd8e:	b083      	sub	sp, #12
 801bd90:	af00      	add	r7, sp, #0
 801bd92:	6078      	str	r0, [r7, #4]
#ifdef ENH_DESC
	return((desc->status & TxDescChain) == TxDescChain);             
 801bd94:	687b      	ldr	r3, [r7, #4]
 801bd96:	681b      	ldr	r3, [r3, #0]
 801bd98:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 801bd9c:	2b00      	cmp	r3, #0
 801bd9e:	bf0c      	ite	eq
 801bda0:	2300      	moveq	r3, #0
 801bda2:	2301      	movne	r3, #1
 801bda4:	b2db      	uxtb	r3, r3
#else
	return((desc->length & TxDescChain) == TxDescChain);             
#endif
}
 801bda6:	4618      	mov	r0, r3
 801bda8:	f107 070c 	add.w	r7, r7, #12
 801bdac:	46bd      	mov	sp, r7
 801bdae:	bc80      	pop	{r7}
 801bdb0:	4770      	bx	lr
 801bdb2:	bf00      	nop

0801bdb4 <synopGMAC_get_desc_data>:
  * @param[out] length of buffer2.
  * @param[out] virtual address of buffer2.
  * \return returns void.
  */
void synopGMAC_get_desc_data(DmaDesc * desc, u32 * Status, u32 * Buffer1, u32 * Length1, u32 * Data1, u32 * Buffer2, u32 * Length2, u32 * Data2)
{
 801bdb4:	b480      	push	{r7}
 801bdb6:	b085      	sub	sp, #20
 801bdb8:	af00      	add	r7, sp, #0
 801bdba:	60f8      	str	r0, [r7, #12]
 801bdbc:	60b9      	str	r1, [r7, #8]
 801bdbe:	607a      	str	r2, [r7, #4]
 801bdc0:	603b      	str	r3, [r7, #0]

	if(Status != 0)   
 801bdc2:	68bb      	ldr	r3, [r7, #8]
 801bdc4:	2b00      	cmp	r3, #0
 801bdc6:	d003      	beq.n	801bdd0 <synopGMAC_get_desc_data+0x1c>
		*Status = desc->status;
 801bdc8:	68fb      	ldr	r3, [r7, #12]
 801bdca:	681a      	ldr	r2, [r3, #0]
 801bdcc:	68bb      	ldr	r3, [r7, #8]
 801bdce:	601a      	str	r2, [r3, #0]

	if(Buffer1 != 0)
 801bdd0:	687b      	ldr	r3, [r7, #4]
 801bdd2:	2b00      	cmp	r3, #0
 801bdd4:	d003      	beq.n	801bdde <synopGMAC_get_desc_data+0x2a>
		*Buffer1 = desc->buffer1;
 801bdd6:	68fb      	ldr	r3, [r7, #12]
 801bdd8:	689a      	ldr	r2, [r3, #8]
 801bdda:	687b      	ldr	r3, [r7, #4]
 801bddc:	601a      	str	r2, [r3, #0]
	if(Length1 != 0)
 801bdde:	683b      	ldr	r3, [r7, #0]
 801bde0:	2b00      	cmp	r3, #0
 801bde2:	d007      	beq.n	801bdf4 <synopGMAC_get_desc_data+0x40>
		*Length1 = (desc->length & DescSize1Mask) >> DescSize1Shift;
 801bde4:	68fb      	ldr	r3, [r7, #12]
 801bde6:	685b      	ldr	r3, [r3, #4]
 801bde8:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801bdec:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801bdf0:	683a      	ldr	r2, [r7, #0]
 801bdf2:	6013      	str	r3, [r2, #0]
	if(Data1 != 0)
 801bdf4:	69bb      	ldr	r3, [r7, #24]
 801bdf6:	2b00      	cmp	r3, #0
 801bdf8:	d003      	beq.n	801be02 <synopGMAC_get_desc_data+0x4e>
		*Data1 = desc->data1;
 801bdfa:	68fb      	ldr	r3, [r7, #12]
 801bdfc:	6a1a      	ldr	r2, [r3, #32]
 801bdfe:	69bb      	ldr	r3, [r7, #24]
 801be00:	601a      	str	r2, [r3, #0]

	if(Buffer2 != 0)
 801be02:	69fb      	ldr	r3, [r7, #28]
 801be04:	2b00      	cmp	r3, #0
 801be06:	d003      	beq.n	801be10 <synopGMAC_get_desc_data+0x5c>
		*Buffer2 = desc->buffer2;
 801be08:	68fb      	ldr	r3, [r7, #12]
 801be0a:	68da      	ldr	r2, [r3, #12]
 801be0c:	69fb      	ldr	r3, [r7, #28]
 801be0e:	601a      	str	r2, [r3, #0]
	if(Length2 != 0)
 801be10:	6a3b      	ldr	r3, [r7, #32]
 801be12:	2b00      	cmp	r3, #0
 801be14:	d00a      	beq.n	801be2c <synopGMAC_get_desc_data+0x78>
		*Length2 = (desc->length & DescSize2Mask) >> DescSize2Shift;
 801be16:	68fb      	ldr	r3, [r7, #12]
 801be18:	685a      	ldr	r2, [r3, #4]
 801be1a:	f04f 0300 	mov.w	r3, #0
 801be1e:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
 801be22:	4013      	ands	r3, r2
 801be24:	ea4f 4213 	mov.w	r2, r3, lsr #16
 801be28:	6a3b      	ldr	r3, [r7, #32]
 801be2a:	601a      	str	r2, [r3, #0]
	if(Data1 != 0)
 801be2c:	69bb      	ldr	r3, [r7, #24]
 801be2e:	2b00      	cmp	r3, #0
 801be30:	d003      	beq.n	801be3a <synopGMAC_get_desc_data+0x86>
		*Data2 = desc->data2;
 801be32:	68fb      	ldr	r3, [r7, #12]
 801be34:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801be36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801be38:	601a      	str	r2, [r3, #0]
	
	return;
 801be3a:	bf00      	nop

}
 801be3c:	f107 0714 	add.w	r7, r7, #20
 801be40:	46bd      	mov	sp, r7
 801be42:	bc80      	pop	{r7}
 801be44:	4770      	bx	lr
 801be46:	bf00      	nop

0801be48 <synopGMAC_get_tx_qptr>:
  * @param[out] u32 data indicating whether the descriptor is in ring mode or chain mode.
  * \return returns present tx descriptor index on success. Negative value if error.
  */
s32 synopGMAC_get_tx_qptr(synopGMACdevice * gmacdev, u32 * Status, u32 * Buffer1, u32 * Length1, u32 * Data1, u32 * Buffer2, u32 * Length2, u32 * Data2,
                          u32 * Ext_Status, u32 * Time_Stamp_High, u32 * Time_Stamp_Low)
{
 801be48:	b580      	push	{r7, lr}
 801be4a:	b086      	sub	sp, #24
 801be4c:	af00      	add	r7, sp, #0
 801be4e:	60f8      	str	r0, [r7, #12]
 801be50:	60b9      	str	r1, [r7, #8]
 801be52:	607a      	str	r2, [r7, #4]
 801be54:	603b      	str	r3, [r7, #0]
	u32  txover      = gmacdev->TxBusy;
 801be56:	68fb      	ldr	r3, [r7, #12]
 801be58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801be5a:	617b      	str	r3, [r7, #20]
	DmaDesc * txdesc = gmacdev->TxBusyDesc;
 801be5c:	68fb      	ldr	r3, [r7, #12]
 801be5e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801be60:	613b      	str	r3, [r7, #16]
	
	if(synopGMAC_is_desc_owned_by_dma(txdesc))
 801be62:	6938      	ldr	r0, [r7, #16]
 801be64:	f7ff fe0e 	bl	801ba84 <synopGMAC_is_desc_owned_by_dma>
 801be68:	4603      	mov	r3, r0
 801be6a:	2b00      	cmp	r3, #0
 801be6c:	d002      	beq.n	801be74 <synopGMAC_get_tx_qptr+0x2c>
		return -1;
 801be6e:	f04f 33ff 	mov.w	r3, #4294967295
 801be72:	e096      	b.n	801bfa2 <synopGMAC_get_tx_qptr+0x15a>
	if(synopGMAC_is_desc_empty(txdesc))
 801be74:	6938      	ldr	r0, [r7, #16]
 801be76:	f7ff fe39 	bl	801baec <synopGMAC_is_desc_empty>
 801be7a:	4603      	mov	r3, r0
 801be7c:	2b00      	cmp	r3, #0
 801be7e:	d002      	beq.n	801be86 <synopGMAC_get_tx_qptr+0x3e>
		return -1;
 801be80:	f04f 33ff 	mov.w	r3, #4294967295
 801be84:	e08d      	b.n	801bfa2 <synopGMAC_get_tx_qptr+0x15a>

	(gmacdev->BusyTxDesc)--; //busy tx descriptor is reduced by one as it will be handed over to Processor now
 801be86:	68fb      	ldr	r3, [r7, #12]
 801be88:	6a1b      	ldr	r3, [r3, #32]
 801be8a:	f103 32ff 	add.w	r2, r3, #4294967295
 801be8e:	68fb      	ldr	r3, [r7, #12]
 801be90:	621a      	str	r2, [r3, #32]

	if(Status != 0)   
 801be92:	68bb      	ldr	r3, [r7, #8]
 801be94:	2b00      	cmp	r3, #0
 801be96:	d003      	beq.n	801bea0 <synopGMAC_get_tx_qptr+0x58>
		*Status = txdesc->status;
 801be98:	693b      	ldr	r3, [r7, #16]
 801be9a:	681a      	ldr	r2, [r3, #0]
 801be9c:	68bb      	ldr	r3, [r7, #8]
 801be9e:	601a      	str	r2, [r3, #0]

	if(Ext_Status != 0)
 801bea0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bea2:	2b00      	cmp	r3, #0
 801bea4:	d003      	beq.n	801beae <synopGMAC_get_tx_qptr+0x66>
		*Ext_Status = txdesc->extstatus;
 801bea6:	693b      	ldr	r3, [r7, #16]
 801bea8:	691a      	ldr	r2, [r3, #16]
 801beaa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801beac:	601a      	str	r2, [r3, #0]
        if(Time_Stamp_High != 0)
 801beae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801beb0:	2b00      	cmp	r3, #0
 801beb2:	d003      	beq.n	801bebc <synopGMAC_get_tx_qptr+0x74>
		*Time_Stamp_High = txdesc->timestamphigh; 
 801beb4:	693b      	ldr	r3, [r7, #16]
 801beb6:	69da      	ldr	r2, [r3, #28]
 801beb8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801beba:	601a      	str	r2, [r3, #0]
        if(Time_Stamp_Low != 0)
 801bebc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bebe:	2b00      	cmp	r3, #0
 801bec0:	d003      	beq.n	801beca <synopGMAC_get_tx_qptr+0x82>
		*Time_Stamp_High = txdesc->timestamplow; 
 801bec2:	693b      	ldr	r3, [r7, #16]
 801bec4:	699a      	ldr	r2, [r3, #24]
 801bec6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bec8:	601a      	str	r2, [r3, #0]

	if(Buffer1 != 0)
 801beca:	687b      	ldr	r3, [r7, #4]
 801becc:	2b00      	cmp	r3, #0
 801bece:	d003      	beq.n	801bed8 <synopGMAC_get_tx_qptr+0x90>
		*Buffer1 = txdesc->buffer1;
 801bed0:	693b      	ldr	r3, [r7, #16]
 801bed2:	689a      	ldr	r2, [r3, #8]
 801bed4:	687b      	ldr	r3, [r7, #4]
 801bed6:	601a      	str	r2, [r3, #0]
	if(Length1 != 0)
 801bed8:	683b      	ldr	r3, [r7, #0]
 801beda:	2b00      	cmp	r3, #0
 801bedc:	d007      	beq.n	801beee <synopGMAC_get_tx_qptr+0xa6>
		*Length1 = (txdesc->length & DescSize1Mask) >> DescSize1Shift;
 801bede:	693b      	ldr	r3, [r7, #16]
 801bee0:	685b      	ldr	r3, [r3, #4]
 801bee2:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801bee6:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801beea:	683a      	ldr	r2, [r7, #0]
 801beec:	6013      	str	r3, [r2, #0]
	if(Data1 != 0)
 801beee:	6a3b      	ldr	r3, [r7, #32]
 801bef0:	2b00      	cmp	r3, #0
 801bef2:	d003      	beq.n	801befc <synopGMAC_get_tx_qptr+0xb4>
		*Data1 = txdesc->data1;
 801bef4:	693b      	ldr	r3, [r7, #16]
 801bef6:	6a1a      	ldr	r2, [r3, #32]
 801bef8:	6a3b      	ldr	r3, [r7, #32]
 801befa:	601a      	str	r2, [r3, #0]

	if(Buffer2 != 0)
 801befc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801befe:	2b00      	cmp	r3, #0
 801bf00:	d003      	beq.n	801bf0a <synopGMAC_get_tx_qptr+0xc2>
		*Buffer2 = txdesc->buffer2;
 801bf02:	693b      	ldr	r3, [r7, #16]
 801bf04:	68da      	ldr	r2, [r3, #12]
 801bf06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bf08:	601a      	str	r2, [r3, #0]
	if(Length2 != 0)
 801bf0a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bf0c:	2b00      	cmp	r3, #0
 801bf0e:	d00a      	beq.n	801bf26 <synopGMAC_get_tx_qptr+0xde>
		*Length2 = (txdesc->length & DescSize2Mask) >> DescSize2Shift;
 801bf10:	693b      	ldr	r3, [r7, #16]
 801bf12:	685a      	ldr	r2, [r3, #4]
 801bf14:	f04f 0300 	mov.w	r3, #0
 801bf18:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
 801bf1c:	4013      	ands	r3, r2
 801bf1e:	ea4f 4213 	mov.w	r2, r3, lsr #16
 801bf22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bf24:	601a      	str	r2, [r3, #0]
	if(Data1 != 0)
 801bf26:	6a3b      	ldr	r3, [r7, #32]
 801bf28:	2b00      	cmp	r3, #0
 801bf2a:	d003      	beq.n	801bf34 <synopGMAC_get_tx_qptr+0xec>
		*Data2 = txdesc->data2;
 801bf2c:	693b      	ldr	r3, [r7, #16]
 801bf2e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801bf30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bf32:	601a      	str	r2, [r3, #0]

	gmacdev->TxBusy     = synopGMAC_is_last_tx_desc(gmacdev,txdesc) ? 0 : txover + 1;
 801bf34:	68f8      	ldr	r0, [r7, #12]
 801bf36:	6939      	ldr	r1, [r7, #16]
 801bf38:	f7ff fef6 	bl	801bd28 <synopGMAC_is_last_tx_desc>
 801bf3c:	4603      	mov	r3, r0
 801bf3e:	2b00      	cmp	r3, #0
 801bf40:	d103      	bne.n	801bf4a <synopGMAC_get_tx_qptr+0x102>
 801bf42:	697b      	ldr	r3, [r7, #20]
 801bf44:	f103 0301 	add.w	r3, r3, #1
 801bf48:	e001      	b.n	801bf4e <synopGMAC_get_tx_qptr+0x106>
 801bf4a:	f04f 0300 	mov.w	r3, #0
 801bf4e:	68fa      	ldr	r2, [r7, #12]
 801bf50:	6313      	str	r3, [r2, #48]	; 0x30

	if(synopGMAC_is_tx_desc_chained(txdesc)){
 801bf52:	6938      	ldr	r0, [r7, #16]
 801bf54:	f7ff ff1a 	bl	801bd8c <synopGMAC_is_tx_desc_chained>
 801bf58:	4603      	mov	r3, r0
 801bf5a:	2b00      	cmp	r3, #0
 801bf5c:	d008      	beq.n	801bf70 <synopGMAC_get_tx_qptr+0x128>
	   	gmacdev->TxBusyDesc = (DmaDesc *)txdesc->data2;
 801bf5e:	693b      	ldr	r3, [r7, #16]
 801bf60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801bf62:	461a      	mov	r2, r3
 801bf64:	68fb      	ldr	r3, [r7, #12]
 801bf66:	641a      	str	r2, [r3, #64]	; 0x40
		synopGMAC_tx_desc_init_chain(txdesc);
 801bf68:	6938      	ldr	r0, [r7, #16]
 801bf6a:	f7ff fc6b 	bl	801b844 <synopGMAC_tx_desc_init_chain>
 801bf6e:	e017      	b.n	801bfa0 <synopGMAC_get_tx_qptr+0x158>
	}
	else{
		gmacdev->TxBusyDesc = synopGMAC_is_last_tx_desc(gmacdev,txdesc) ? gmacdev->TxDesc : (txdesc + 1);
 801bf70:	68f8      	ldr	r0, [r7, #12]
 801bf72:	6939      	ldr	r1, [r7, #16]
 801bf74:	f7ff fed8 	bl	801bd28 <synopGMAC_is_last_tx_desc>
 801bf78:	4603      	mov	r3, r0
 801bf7a:	2b00      	cmp	r3, #0
 801bf7c:	d002      	beq.n	801bf84 <synopGMAC_get_tx_qptr+0x13c>
 801bf7e:	68fb      	ldr	r3, [r7, #12]
 801bf80:	699b      	ldr	r3, [r3, #24]
 801bf82:	e002      	b.n	801bf8a <synopGMAC_get_tx_qptr+0x142>
 801bf84:	693b      	ldr	r3, [r7, #16]
 801bf86:	f103 0328 	add.w	r3, r3, #40	; 0x28
 801bf8a:	68fa      	ldr	r2, [r7, #12]
 801bf8c:	6413      	str	r3, [r2, #64]	; 0x40
		synopGMAC_tx_desc_init_ring(txdesc, synopGMAC_is_last_tx_desc(gmacdev,txdesc));
 801bf8e:	68f8      	ldr	r0, [r7, #12]
 801bf90:	6939      	ldr	r1, [r7, #16]
 801bf92:	f7ff fec9 	bl	801bd28 <synopGMAC_is_last_tx_desc>
 801bf96:	4603      	mov	r3, r0
 801bf98:	6938      	ldr	r0, [r7, #16]
 801bf9a:	4619      	mov	r1, r3
 801bf9c:	f7ff fc1e 	bl	801b7dc <synopGMAC_tx_desc_init_ring>
	}
	//TR("(get)%02d %08x %08x %08x %08x %08x %08x %08x\n",txover,(u32)txdesc,txdesc->status,txdesc->length,txdesc->buffer1,txdesc->buffer2,txdesc->data1,txdesc->data2);

	return txover;	
 801bfa0:	697b      	ldr	r3, [r7, #20]
}
 801bfa2:	4618      	mov	r0, r3
 801bfa4:	f107 0718 	add.w	r7, r7, #24
 801bfa8:	46bd      	mov	sp, r7
 801bfaa:	bd80      	pop	{r7, pc}

0801bfac <synopGMAC_set_tx_qptr>:
  * @param[in] u32 data indicating whether the descriptor is in ring mode or chain mode.
  * @param[in] u32 indicating whether the checksum offloading in HW/SW.
  * \return returns present tx descriptor index on success. Negative value if error.
  */
s32 synopGMAC_set_tx_qptr(synopGMACdevice * gmacdev, u32 Buffer1, u32 Length1, u32 Data1, u32 Buffer2, u32 Length2, u32 Data2,u32 offload_needed)
{
 801bfac:	b580      	push	{r7, lr}
 801bfae:	b086      	sub	sp, #24
 801bfb0:	af00      	add	r7, sp, #0
 801bfb2:	60f8      	str	r0, [r7, #12]
 801bfb4:	60b9      	str	r1, [r7, #8]
 801bfb6:	607a      	str	r2, [r7, #4]
 801bfb8:	603b      	str	r3, [r7, #0]
	u32  txnext      = gmacdev->TxNext;
 801bfba:	68fb      	ldr	r3, [r7, #12]
 801bfbc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801bfbe:	617b      	str	r3, [r7, #20]
	DmaDesc * txdesc = gmacdev->TxNextDesc;
 801bfc0:	68fb      	ldr	r3, [r7, #12]
 801bfc2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801bfc4:	613b      	str	r3, [r7, #16]
	if(!synopGMAC_is_desc_empty(txdesc))
 801bfc6:	6938      	ldr	r0, [r7, #16]
 801bfc8:	f7ff fd90 	bl	801baec <synopGMAC_is_desc_empty>
 801bfcc:	4603      	mov	r3, r0
 801bfce:	2b00      	cmp	r3, #0
 801bfd0:	d102      	bne.n	801bfd8 <synopGMAC_set_tx_qptr+0x2c>
		return -1;
 801bfd2:	f04f 33ff 	mov.w	r3, #4294967295
 801bfd6:	e083      	b.n	801c0e0 <synopGMAC_set_tx_qptr+0x134>

	(gmacdev->BusyTxDesc)++; //busy tx descriptor is incremented by one as it will be handed over to DMA
 801bfd8:	68fb      	ldr	r3, [r7, #12]
 801bfda:	6a1b      	ldr	r3, [r3, #32]
 801bfdc:	f103 0201 	add.w	r2, r3, #1
 801bfe0:	68fb      	ldr	r3, [r7, #12]
 801bfe2:	621a      	str	r2, [r3, #32]
	
	if(synopGMAC_is_tx_desc_chained(txdesc))
 801bfe4:	6938      	ldr	r0, [r7, #16]
 801bfe6:	f7ff fed1 	bl	801bd8c <synopGMAC_is_tx_desc_chained>
 801bfea:	4603      	mov	r3, r0
 801bfec:	2b00      	cmp	r3, #0
 801bfee:	d031      	beq.n	801c054 <synopGMAC_set_tx_qptr+0xa8>
	{
		txdesc->length |= ((Length1 <<DescSize1Shift) & DescSize1Mask);
 801bff0:	693b      	ldr	r3, [r7, #16]
 801bff2:	685a      	ldr	r2, [r3, #4]
 801bff4:	687b      	ldr	r3, [r7, #4]
 801bff6:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801bffa:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801bffe:	431a      	orrs	r2, r3
 801c000:	693b      	ldr	r3, [r7, #16]
 801c002:	605a      	str	r2, [r3, #4]

#ifdef ENH_DESC
		txdesc->status |=  (DescTxFirst | DescTxLast | DescTxIntEnable); //ENH_DESC
 801c004:	693b      	ldr	r3, [r7, #16]
 801c006:	681b      	ldr	r3, [r3, #0]
 801c008:	f043 42e0 	orr.w	r2, r3, #1879048192	; 0x70000000
 801c00c:	693b      	ldr	r3, [r7, #16]
 801c00e:	601a      	str	r2, [r3, #0]
#endif

		//txdesc->buffer1 = Buffer1;
		//txdesc->data1 = Data1;

		if(offload_needed)
 801c010:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c012:	2b00      	cmp	r3, #0
 801c014:	d003      	beq.n	801c01e <synopGMAC_set_tx_qptr+0x72>
			 Make sure that the OS you are running supports the IP and TCP checkusm offloaidng,
			 before calling any of the functions given below.		 
			 */
		//	synopGMAC_tx_checksum_offload_ipv4hdr(gmacdev, txdesc);
		//	synopGMAC_tx_checksum_offload_tcponly(gmacdev, txdesc);
			synopGMAC_tx_checksum_offload_tcp_pseudo(gmacdev, txdesc);
 801c016:	68f8      	ldr	r0, [r7, #12]
 801c018:	6939      	ldr	r1, [r7, #16]
 801c01a:	f000 ff0d 	bl	801ce38 <synopGMAC_tx_checksum_offload_tcp_pseudo>
		}

#ifdef ENH_DESC
		txdesc->status |= DescOwnByDma;//ENH_DESC
 801c01e:	693b      	ldr	r3, [r7, #16]
 801c020:	681b      	ldr	r3, [r3, #0]
 801c022:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 801c026:	693b      	ldr	r3, [r7, #16]
 801c028:	601a      	str	r2, [r3, #0]
#else
		txdesc->status = DescOwnByDma;
#endif

		gmacdev->TxNext = synopGMAC_is_last_tx_desc(gmacdev,txdesc) ? 0 : txnext + 1;
 801c02a:	68f8      	ldr	r0, [r7, #12]
 801c02c:	6939      	ldr	r1, [r7, #16]
 801c02e:	f7ff fe7b 	bl	801bd28 <synopGMAC_is_last_tx_desc>
 801c032:	4603      	mov	r3, r0
 801c034:	2b00      	cmp	r3, #0
 801c036:	d103      	bne.n	801c040 <synopGMAC_set_tx_qptr+0x94>
 801c038:	697b      	ldr	r3, [r7, #20]
 801c03a:	f103 0301 	add.w	r3, r3, #1
 801c03e:	e001      	b.n	801c044 <synopGMAC_set_tx_qptr+0x98>
 801c040:	f04f 0300 	mov.w	r3, #0
 801c044:	68fa      	ldr	r2, [r7, #12]
 801c046:	6353      	str	r3, [r2, #52]	; 0x34
	   	gmacdev->TxNextDesc = (DmaDesc *)txdesc->data2;
 801c048:	693b      	ldr	r3, [r7, #16]
 801c04a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801c04c:	461a      	mov	r2, r3
 801c04e:	68fb      	ldr	r3, [r7, #12]
 801c050:	645a      	str	r2, [r3, #68]	; 0x44
 801c052:	e044      	b.n	801c0de <synopGMAC_set_tx_qptr+0x132>
	}
	else
	{
		txdesc->length |= (((Length1 <<DescSize1Shift) & DescSize1Mask) | ((Length2 <<DescSize2Shift) & DescSize2Mask));
 801c054:	693b      	ldr	r3, [r7, #16]
 801c056:	6859      	ldr	r1, [r3, #4]
 801c058:	687b      	ldr	r3, [r7, #4]
 801c05a:	ea4f 42c3 	mov.w	r2, r3, lsl #19
 801c05e:	ea4f 42d2 	mov.w	r2, r2, lsr #19
 801c062:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c064:	ea4f 4003 	mov.w	r0, r3, lsl #16
 801c068:	f04f 0300 	mov.w	r3, #0
 801c06c:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
 801c070:	4003      	ands	r3, r0
 801c072:	4313      	orrs	r3, r2
 801c074:	ea41 0203 	orr.w	r2, r1, r3
 801c078:	693b      	ldr	r3, [r7, #16]
 801c07a:	605a      	str	r2, [r3, #4]

#ifdef ENH_DESC
		txdesc->status |=  (DescTxFirst | DescTxLast | DescTxIntEnable); //ENH_DESC
 801c07c:	693b      	ldr	r3, [r7, #16]
 801c07e:	681b      	ldr	r3, [r3, #0]
 801c080:	f043 42e0 	orr.w	r2, r3, #1879048192	; 0x70000000
 801c084:	693b      	ldr	r3, [r7, #16]
 801c086:	601a      	str	r2, [r3, #0]
#else
		txdesc->length |=  (DescTxFirst | DescTxLast | DescTxIntEnable); //Its always assumed that complete data will fit in to one descriptor
#endif

		if(offload_needed)
 801c088:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c08a:	2b00      	cmp	r3, #0
 801c08c:	d003      	beq.n	801c096 <synopGMAC_set_tx_qptr+0xea>
			 Make sure that the OS you are running supports the IP and TCP checkusm offloaidng,
			 before calling any of the functions given below.		 
			 */
		//	synopGMAC_tx_checksum_offload_ipv4hdr(gmacdev, txdesc);
		//	synopGMAC_tx_checksum_offload_tcponly(gmacdev, txdesc);
			synopGMAC_tx_checksum_offload_tcp_pseudo(gmacdev, txdesc);
 801c08e:	68f8      	ldr	r0, [r7, #12]
 801c090:	6939      	ldr	r1, [r7, #16]
 801c092:	f000 fed1 	bl	801ce38 <synopGMAC_tx_checksum_offload_tcp_pseudo>
		}

#ifdef ENH_DESC	
		txdesc->status |= DescOwnByDma;//ENH_DESC
 801c096:	693b      	ldr	r3, [r7, #16]
 801c098:	681b      	ldr	r3, [r3, #0]
 801c09a:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 801c09e:	693b      	ldr	r3, [r7, #16]
 801c0a0:	601a      	str	r2, [r3, #0]
#else
		txdesc->status = DescOwnByDma;
#endif

		gmacdev->TxNext = synopGMAC_is_last_tx_desc(gmacdev,txdesc) ? 0 : txnext + 1;
 801c0a2:	68f8      	ldr	r0, [r7, #12]
 801c0a4:	6939      	ldr	r1, [r7, #16]
 801c0a6:	f7ff fe3f 	bl	801bd28 <synopGMAC_is_last_tx_desc>
 801c0aa:	4603      	mov	r3, r0
 801c0ac:	2b00      	cmp	r3, #0
 801c0ae:	d103      	bne.n	801c0b8 <synopGMAC_set_tx_qptr+0x10c>
 801c0b0:	697b      	ldr	r3, [r7, #20]
 801c0b2:	f103 0301 	add.w	r3, r3, #1
 801c0b6:	e001      	b.n	801c0bc <synopGMAC_set_tx_qptr+0x110>
 801c0b8:	f04f 0300 	mov.w	r3, #0
 801c0bc:	68fa      	ldr	r2, [r7, #12]
 801c0be:	6353      	str	r3, [r2, #52]	; 0x34
		gmacdev->TxNextDesc = synopGMAC_is_last_tx_desc(gmacdev,txdesc) ? gmacdev->TxDesc : (txdesc + 1);
 801c0c0:	68f8      	ldr	r0, [r7, #12]
 801c0c2:	6939      	ldr	r1, [r7, #16]
 801c0c4:	f7ff fe30 	bl	801bd28 <synopGMAC_is_last_tx_desc>
 801c0c8:	4603      	mov	r3, r0
 801c0ca:	2b00      	cmp	r3, #0
 801c0cc:	d002      	beq.n	801c0d4 <synopGMAC_set_tx_qptr+0x128>
 801c0ce:	68fb      	ldr	r3, [r7, #12]
 801c0d0:	699b      	ldr	r3, [r3, #24]
 801c0d2:	e002      	b.n	801c0da <synopGMAC_set_tx_qptr+0x12e>
 801c0d4:	693b      	ldr	r3, [r7, #16]
 801c0d6:	f103 0328 	add.w	r3, r3, #40	; 0x28
 801c0da:	68fa      	ldr	r2, [r7, #12]
 801c0dc:	6453      	str	r3, [r2, #68]	; 0x44
	}


	return txnext;	
 801c0de:	697b      	ldr	r3, [r7, #20]
}
 801c0e0:	4618      	mov	r0, r3
 801c0e2:	f107 0718 	add.w	r7, r7, #24
 801c0e6:	46bd      	mov	sp, r7
 801c0e8:	bd80      	pop	{r7, pc}
 801c0ea:	bf00      	nop

0801c0ec <synopGMAC_set_rx_qptr>:
  * @param[in] length of buffer2 (Max is 2048).
  * @param[in] u32 data indicating whether the descriptor is in ring mode or chain mode.
  * \return returns present rx descriptor index on success. Negative value if error.
  */
s32 synopGMAC_set_rx_qptr(synopGMACdevice * gmacdev, u32 Buffer1, u32 Length1, u32 Data1, u32 Buffer2, u32 Length2, u32 Data2)
{
 801c0ec:	b580      	push	{r7, lr}
 801c0ee:	b086      	sub	sp, #24
 801c0f0:	af00      	add	r7, sp, #0
 801c0f2:	60f8      	str	r0, [r7, #12]
 801c0f4:	60b9      	str	r1, [r7, #8]
 801c0f6:	607a      	str	r2, [r7, #4]
 801c0f8:	603b      	str	r3, [r7, #0]
	u32  rxnext      = gmacdev->RxNext;
 801c0fa:	68fb      	ldr	r3, [r7, #12]
 801c0fc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801c0fe:	617b      	str	r3, [r7, #20]
	DmaDesc * rxdesc = gmacdev->RxNextDesc;
 801c100:	68fb      	ldr	r3, [r7, #12]
 801c102:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 801c104:	613b      	str	r3, [r7, #16]

	if(!synopGMAC_is_desc_empty(rxdesc))
 801c106:	6938      	ldr	r0, [r7, #16]
 801c108:	f7ff fcf0 	bl	801baec <synopGMAC_is_desc_empty>
 801c10c:	4603      	mov	r3, r0
 801c10e:	2b00      	cmp	r3, #0
 801c110:	d102      	bne.n	801c118 <synopGMAC_set_rx_qptr+0x2c>
		return -1;
 801c112:	f04f 33ff 	mov.w	r3, #4294967295
 801c116:	e097      	b.n	801c248 <synopGMAC_set_rx_qptr+0x15c>


	if(synopGMAC_is_rx_desc_chained(rxdesc)){
 801c118:	6938      	ldr	r0, [r7, #16]
 801c11a:	f7ff fe23 	bl	801bd64 <synopGMAC_is_rx_desc_chained>
 801c11e:	4603      	mov	r3, r0
 801c120:	2b00      	cmp	r3, #0
 801c122:	d038      	beq.n	801c196 <synopGMAC_set_rx_qptr+0xaa>
		rxdesc->length |= ((Length1 <<DescSize1Shift) & DescSize1Mask);
 801c124:	693b      	ldr	r3, [r7, #16]
 801c126:	685a      	ldr	r2, [r3, #4]
 801c128:	687b      	ldr	r3, [r7, #4]
 801c12a:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801c12e:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801c132:	431a      	orrs	r2, r3
 801c134:	693b      	ldr	r3, [r7, #16]
 801c136:	605a      	str	r2, [r3, #4]

		rxdesc->buffer1 = Buffer1;
 801c138:	693b      	ldr	r3, [r7, #16]
 801c13a:	68ba      	ldr	r2, [r7, #8]
 801c13c:	609a      	str	r2, [r3, #8]
		rxdesc->data1 = Data1;
 801c13e:	693b      	ldr	r3, [r7, #16]
 801c140:	683a      	ldr	r2, [r7, #0]
 801c142:	621a      	str	r2, [r3, #32]

		rxdesc->extstatus = 0;
 801c144:	693b      	ldr	r3, [r7, #16]
 801c146:	f04f 0200 	mov.w	r2, #0
 801c14a:	611a      	str	r2, [r3, #16]
		rxdesc->reserved1 = 0;
 801c14c:	693b      	ldr	r3, [r7, #16]
 801c14e:	f04f 0200 	mov.w	r2, #0
 801c152:	615a      	str	r2, [r3, #20]
		rxdesc->timestamplow = 0;
 801c154:	693b      	ldr	r3, [r7, #16]
 801c156:	f04f 0200 	mov.w	r2, #0
 801c15a:	619a      	str	r2, [r3, #24]
		rxdesc->timestamphigh = 0;
 801c15c:	693b      	ldr	r3, [r7, #16]
 801c15e:	f04f 0200 	mov.w	r2, #0
 801c162:	61da      	str	r2, [r3, #28]

		if((rxnext % MODULO_INTERRUPT) !=0)
		rxdesc->length |= RxDisIntCompl;		
  
		rxdesc->status = DescOwnByDma;
 801c164:	693b      	ldr	r3, [r7, #16]
 801c166:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801c16a:	601a      	str	r2, [r3, #0]

		gmacdev->RxNext     = synopGMAC_is_last_rx_desc(gmacdev,rxdesc) ? 0 : rxnext + 1;
 801c16c:	68f8      	ldr	r0, [r7, #12]
 801c16e:	6939      	ldr	r1, [r7, #16]
 801c170:	f7ff fdbc 	bl	801bcec <synopGMAC_is_last_rx_desc>
 801c174:	4603      	mov	r3, r0
 801c176:	2b00      	cmp	r3, #0
 801c178:	d103      	bne.n	801c182 <synopGMAC_set_rx_qptr+0x96>
 801c17a:	697b      	ldr	r3, [r7, #20]
 801c17c:	f103 0301 	add.w	r3, r3, #1
 801c180:	e001      	b.n	801c186 <synopGMAC_set_rx_qptr+0x9a>
 801c182:	f04f 0300 	mov.w	r3, #0
 801c186:	68fa      	ldr	r2, [r7, #12]
 801c188:	63d3      	str	r3, [r2, #60]	; 0x3c
	   	gmacdev->RxNextDesc = (DmaDesc *)rxdesc->data2;
 801c18a:	693b      	ldr	r3, [r7, #16]
 801c18c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801c18e:	461a      	mov	r2, r3
 801c190:	68fb      	ldr	r3, [r7, #12]
 801c192:	64da      	str	r2, [r3, #76]	; 0x4c
 801c194:	e051      	b.n	801c23a <synopGMAC_set_rx_qptr+0x14e>
	}
	else{
		rxdesc->length |= (((Length1 <<DescSize1Shift) & DescSize1Mask) | ((Length2 << DescSize2Shift) & DescSize2Mask));
 801c196:	693b      	ldr	r3, [r7, #16]
 801c198:	6859      	ldr	r1, [r3, #4]
 801c19a:	687b      	ldr	r3, [r7, #4]
 801c19c:	ea4f 42c3 	mov.w	r2, r3, lsl #19
 801c1a0:	ea4f 42d2 	mov.w	r2, r2, lsr #19
 801c1a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c1a6:	ea4f 4003 	mov.w	r0, r3, lsl #16
 801c1aa:	f04f 0300 	mov.w	r3, #0
 801c1ae:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
 801c1b2:	4003      	ands	r3, r0
 801c1b4:	4313      	orrs	r3, r2
 801c1b6:	ea41 0203 	orr.w	r2, r1, r3
 801c1ba:	693b      	ldr	r3, [r7, #16]
 801c1bc:	605a      	str	r2, [r3, #4]

		rxdesc->buffer1 = Buffer1;
 801c1be:	693b      	ldr	r3, [r7, #16]
 801c1c0:	68ba      	ldr	r2, [r7, #8]
 801c1c2:	609a      	str	r2, [r3, #8]
		rxdesc->data1 = Data1;
 801c1c4:	693b      	ldr	r3, [r7, #16]
 801c1c6:	683a      	ldr	r2, [r7, #0]
 801c1c8:	621a      	str	r2, [r3, #32]

		rxdesc->extstatus = 0;
 801c1ca:	693b      	ldr	r3, [r7, #16]
 801c1cc:	f04f 0200 	mov.w	r2, #0
 801c1d0:	611a      	str	r2, [r3, #16]
		rxdesc->reserved1 = 0;
 801c1d2:	693b      	ldr	r3, [r7, #16]
 801c1d4:	f04f 0200 	mov.w	r2, #0
 801c1d8:	615a      	str	r2, [r3, #20]
		rxdesc->timestamplow = 0;
 801c1da:	693b      	ldr	r3, [r7, #16]
 801c1dc:	f04f 0200 	mov.w	r2, #0
 801c1e0:	619a      	str	r2, [r3, #24]
		rxdesc->timestamphigh = 0;
 801c1e2:	693b      	ldr	r3, [r7, #16]
 801c1e4:	f04f 0200 	mov.w	r2, #0
 801c1e8:	61da      	str	r2, [r3, #28]

		rxdesc->buffer2 = Buffer2;
 801c1ea:	693b      	ldr	r3, [r7, #16]
 801c1ec:	6a3a      	ldr	r2, [r7, #32]
 801c1ee:	60da      	str	r2, [r3, #12]
		rxdesc->data2 = Data2;
 801c1f0:	693b      	ldr	r3, [r7, #16]
 801c1f2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801c1f4:	625a      	str	r2, [r3, #36]	; 0x24
	
		if((rxnext % MODULO_INTERRUPT) !=0)
		rxdesc->length |= RxDisIntCompl;		

		rxdesc->status = DescOwnByDma;
 801c1f6:	693b      	ldr	r3, [r7, #16]
 801c1f8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801c1fc:	601a      	str	r2, [r3, #0]

		gmacdev->RxNext     = synopGMAC_is_last_rx_desc(gmacdev,rxdesc) ? 0 : rxnext + 1;
 801c1fe:	68f8      	ldr	r0, [r7, #12]
 801c200:	6939      	ldr	r1, [r7, #16]
 801c202:	f7ff fd73 	bl	801bcec <synopGMAC_is_last_rx_desc>
 801c206:	4603      	mov	r3, r0
 801c208:	2b00      	cmp	r3, #0
 801c20a:	d103      	bne.n	801c214 <synopGMAC_set_rx_qptr+0x128>
 801c20c:	697b      	ldr	r3, [r7, #20]
 801c20e:	f103 0301 	add.w	r3, r3, #1
 801c212:	e001      	b.n	801c218 <synopGMAC_set_rx_qptr+0x12c>
 801c214:	f04f 0300 	mov.w	r3, #0
 801c218:	68fa      	ldr	r2, [r7, #12]
 801c21a:	63d3      	str	r3, [r2, #60]	; 0x3c
		gmacdev->RxNextDesc = synopGMAC_is_last_rx_desc(gmacdev,rxdesc) ? gmacdev->RxDesc : (rxdesc + 1);
 801c21c:	68f8      	ldr	r0, [r7, #12]
 801c21e:	6939      	ldr	r1, [r7, #16]
 801c220:	f7ff fd64 	bl	801bcec <synopGMAC_is_last_rx_desc>
 801c224:	4603      	mov	r3, r0
 801c226:	2b00      	cmp	r3, #0
 801c228:	d002      	beq.n	801c230 <synopGMAC_set_rx_qptr+0x144>
 801c22a:	68fb      	ldr	r3, [r7, #12]
 801c22c:	69db      	ldr	r3, [r3, #28]
 801c22e:	e002      	b.n	801c236 <synopGMAC_set_rx_qptr+0x14a>
 801c230:	693b      	ldr	r3, [r7, #16]
 801c232:	f103 0328 	add.w	r3, r3, #40	; 0x28
 801c236:	68fa      	ldr	r2, [r7, #12]
 801c238:	64d3      	str	r3, [r2, #76]	; 0x4c
	}
	//TR("%02d %08x %08x %08x %08x %08x %08x %08x\n",rxnext,(u32)rxdesc,rxdesc->status,rxdesc->length,rxdesc->buffer1,rxdesc->buffer2,rxdesc->data1,rxdesc->data2);

	(gmacdev->BusyRxDesc)++; //One descriptor will be given to Hardware. So busy count incremented by one
 801c23a:	68fb      	ldr	r3, [r7, #12]
 801c23c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801c23e:	f103 0201 	add.w	r2, r3, #1
 801c242:	68fb      	ldr	r3, [r7, #12]
 801c244:	625a      	str	r2, [r3, #36]	; 0x24
	return rxnext;
 801c246:	697b      	ldr	r3, [r7, #20]
}
 801c248:	4618      	mov	r0, r3
 801c24a:	f107 0718 	add.w	r7, r7, #24
 801c24e:	46bd      	mov	sp, r7
 801c250:	bd80      	pop	{r7, pc}
 801c252:	bf00      	nop

0801c254 <synopGMAC_get_rx_qptr>:
  * @param[out] virtual pointer for buffer2.
  * \return returns present rx descriptor index on success. Negative value if error.
  */
s32 synopGMAC_get_rx_qptr(synopGMACdevice * gmacdev, u32 * Status, u32 * Buffer1, u32 * Length1, u32 * Data1, u32 * Buffer2, u32 * Length2, u32 * Data2,
                          u32 * Ext_Status, u32 * Time_Stamp_High, u32 * Time_Stamp_Low)
{
 801c254:	b580      	push	{r7, lr}
 801c256:	b086      	sub	sp, #24
 801c258:	af00      	add	r7, sp, #0
 801c25a:	60f8      	str	r0, [r7, #12]
 801c25c:	60b9      	str	r1, [r7, #8]
 801c25e:	607a      	str	r2, [r7, #4]
 801c260:	603b      	str	r3, [r7, #0]
	u32 rxnext       = gmacdev->RxBusy;	// index of descriptor the DMA just completed. May be useful when data 
 801c262:	68fb      	ldr	r3, [r7, #12]
 801c264:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801c266:	617b      	str	r3, [r7, #20]
						//is spread over multiple buffers/descriptors
	DmaDesc * rxdesc = gmacdev->RxBusyDesc;
 801c268:	68fb      	ldr	r3, [r7, #12]
 801c26a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801c26c:	613b      	str	r3, [r7, #16]
	if(synopGMAC_is_desc_owned_by_dma(rxdesc))
 801c26e:	6938      	ldr	r0, [r7, #16]
 801c270:	f7ff fc08 	bl	801ba84 <synopGMAC_is_desc_owned_by_dma>
 801c274:	4603      	mov	r3, r0
 801c276:	2b00      	cmp	r3, #0
 801c278:	d002      	beq.n	801c280 <synopGMAC_get_rx_qptr+0x2c>
		return -1;
 801c27a:	f04f 33ff 	mov.w	r3, #4294967295
 801c27e:	e06f      	b.n	801c360 <synopGMAC_get_rx_qptr+0x10c>
	if(synopGMAC_is_desc_empty(rxdesc))
 801c280:	6938      	ldr	r0, [r7, #16]
 801c282:	f7ff fc33 	bl	801baec <synopGMAC_is_desc_empty>
 801c286:	4603      	mov	r3, r0
 801c288:	2b00      	cmp	r3, #0
 801c28a:	d002      	beq.n	801c292 <synopGMAC_get_rx_qptr+0x3e>
		return -1;
 801c28c:	f04f 33ff 	mov.w	r3, #4294967295
 801c290:	e066      	b.n	801c360 <synopGMAC_get_rx_qptr+0x10c>
	

	if(Status != 0)
 801c292:	68bb      	ldr	r3, [r7, #8]
 801c294:	2b00      	cmp	r3, #0
 801c296:	d003      	beq.n	801c2a0 <synopGMAC_get_rx_qptr+0x4c>
		*Status = rxdesc->status;// send the status of this descriptor
 801c298:	693b      	ldr	r3, [r7, #16]
 801c29a:	681a      	ldr	r2, [r3, #0]
 801c29c:	68bb      	ldr	r3, [r7, #8]
 801c29e:	601a      	str	r2, [r3, #0]

	if(Ext_Status != 0)
 801c2a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c2a2:	2b00      	cmp	r3, #0
 801c2a4:	d003      	beq.n	801c2ae <synopGMAC_get_rx_qptr+0x5a>
		*Ext_Status = rxdesc->extstatus;
 801c2a6:	693b      	ldr	r3, [r7, #16]
 801c2a8:	691a      	ldr	r2, [r3, #16]
 801c2aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c2ac:	601a      	str	r2, [r3, #0]
        if(Time_Stamp_High != 0)
 801c2ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c2b0:	2b00      	cmp	r3, #0
 801c2b2:	d003      	beq.n	801c2bc <synopGMAC_get_rx_qptr+0x68>
		*Time_Stamp_High = rxdesc->timestamphigh; 
 801c2b4:	693b      	ldr	r3, [r7, #16]
 801c2b6:	69da      	ldr	r2, [r3, #28]
 801c2b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c2ba:	601a      	str	r2, [r3, #0]
        if(Time_Stamp_Low != 0)
 801c2bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c2be:	2b00      	cmp	r3, #0
 801c2c0:	d003      	beq.n	801c2ca <synopGMAC_get_rx_qptr+0x76>
		*Time_Stamp_Low = rxdesc->timestamplow; 
 801c2c2:	693b      	ldr	r3, [r7, #16]
 801c2c4:	699a      	ldr	r2, [r3, #24]
 801c2c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c2c8:	601a      	str	r2, [r3, #0]

	if(Length1 != 0)
 801c2ca:	683b      	ldr	r3, [r7, #0]
 801c2cc:	2b00      	cmp	r3, #0
 801c2ce:	d007      	beq.n	801c2e0 <synopGMAC_get_rx_qptr+0x8c>
		*Length1 = (rxdesc->length & DescSize1Mask) >> DescSize1Shift;
 801c2d0:	693b      	ldr	r3, [r7, #16]
 801c2d2:	685b      	ldr	r3, [r3, #4]
 801c2d4:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 801c2d8:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 801c2dc:	683a      	ldr	r2, [r7, #0]
 801c2de:	6013      	str	r3, [r2, #0]
	if(Buffer1 != 0)
 801c2e0:	687b      	ldr	r3, [r7, #4]
 801c2e2:	2b00      	cmp	r3, #0
 801c2e4:	d003      	beq.n	801c2ee <synopGMAC_get_rx_qptr+0x9a>
		*Buffer1 = rxdesc->buffer1;
 801c2e6:	693b      	ldr	r3, [r7, #16]
 801c2e8:	689a      	ldr	r2, [r3, #8]
 801c2ea:	687b      	ldr	r3, [r7, #4]
 801c2ec:	601a      	str	r2, [r3, #0]
	if(Data1 != 0)
 801c2ee:	6a3b      	ldr	r3, [r7, #32]
 801c2f0:	2b00      	cmp	r3, #0
 801c2f2:	d003      	beq.n	801c2fc <synopGMAC_get_rx_qptr+0xa8>
		*Data1 = rxdesc->data1;
 801c2f4:	693b      	ldr	r3, [r7, #16]
 801c2f6:	6a1a      	ldr	r2, [r3, #32]
 801c2f8:	6a3b      	ldr	r3, [r7, #32]
 801c2fa:	601a      	str	r2, [r3, #0]

	if(Length2 != 0)
 801c2fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c2fe:	2b00      	cmp	r3, #0
 801c300:	d00a      	beq.n	801c318 <synopGMAC_get_rx_qptr+0xc4>
		*Length2 = (rxdesc->length & DescSize2Mask) >> DescSize2Shift;
 801c302:	693b      	ldr	r3, [r7, #16]
 801c304:	685a      	ldr	r2, [r3, #4]
 801c306:	f04f 0300 	mov.w	r3, #0
 801c30a:	f6c1 73ff 	movt	r3, #8191	; 0x1fff
 801c30e:	4013      	ands	r3, r2
 801c310:	ea4f 4213 	mov.w	r2, r3, lsr #16
 801c314:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c316:	601a      	str	r2, [r3, #0]
	if(Buffer2 != 0)
 801c318:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c31a:	2b00      	cmp	r3, #0
 801c31c:	d003      	beq.n	801c326 <synopGMAC_get_rx_qptr+0xd2>
		*Buffer2 = rxdesc->buffer2;
 801c31e:	693b      	ldr	r3, [r7, #16]
 801c320:	68da      	ldr	r2, [r3, #12]
 801c322:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c324:	601a      	str	r2, [r3, #0]
	if(Data1 != 0)
 801c326:	6a3b      	ldr	r3, [r7, #32]
 801c328:	2b00      	cmp	r3, #0
 801c32a:	d003      	beq.n	801c334 <synopGMAC_get_rx_qptr+0xe0>
		*Data2 = rxdesc->data2;
 801c32c:	693b      	ldr	r3, [r7, #16]
 801c32e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801c330:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c332:	601a      	str	r2, [r3, #0]

	gmacdev->RxBusy     = synopGMAC_is_last_rx_desc(gmacdev,rxdesc) ? 0 : rxnext + 1;
 801c334:	68f8      	ldr	r0, [r7, #12]
 801c336:	6939      	ldr	r1, [r7, #16]
 801c338:	f7ff fcd8 	bl	801bcec <synopGMAC_is_last_rx_desc>
 801c33c:	4603      	mov	r3, r0
 801c33e:	2b00      	cmp	r3, #0
 801c340:	d103      	bne.n	801c34a <synopGMAC_get_rx_qptr+0xf6>
 801c342:	697b      	ldr	r3, [r7, #20]
 801c344:	f103 0301 	add.w	r3, r3, #1
 801c348:	e001      	b.n	801c34e <synopGMAC_get_rx_qptr+0xfa>
 801c34a:	f04f 0300 	mov.w	r3, #0
 801c34e:	68fa      	ldr	r2, [r7, #12]
 801c350:	6393      	str	r3, [r2, #56]	; 0x38

	//TR("%02d %08x %08x %08x %08x %08x %08x %08x\n",rxnext,(u32)rxdesc,rxdesc->status,rxdesc->length,rxdesc->buffer1,rxdesc->buffer2,rxdesc->data1,rxdesc->data2);
	(gmacdev->BusyRxDesc)--; //busy tx descriptor is reduced by one as it will be handed over to Processor now
 801c352:	68fb      	ldr	r3, [r7, #12]
 801c354:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801c356:	f103 32ff 	add.w	r2, r3, #4294967295
 801c35a:	68fb      	ldr	r3, [r7, #12]
 801c35c:	625a      	str	r2, [r3, #36]	; 0x24
	return(rxnext);
 801c35e:	697b      	ldr	r3, [r7, #20]

}
 801c360:	4618      	mov	r0, r3
 801c362:	f107 0718 	add.w	r7, r7, #24
 801c366:	46bd      	mov	sp, r7
 801c368:	bd80      	pop	{r7, pc}
 801c36a:	bf00      	nop

0801c36c <synopGMAC_clear_interrupt>:
  * If the Dma status register is read then all the interrupts gets cleared
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_clear_interrupt(synopGMACdevice *gmacdev)
{
 801c36c:	b580      	push	{r7, lr}
 801c36e:	b084      	sub	sp, #16
 801c370:	af00      	add	r7, sp, #0
 801c372:	6078      	str	r0, [r7, #4]
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaStatus);
 801c374:	687b      	ldr	r3, [r7, #4]
 801c376:	685b      	ldr	r3, [r3, #4]
 801c378:	4618      	mov	r0, r3
 801c37a:	f04f 0114 	mov.w	r1, #20
 801c37e:	f001 f911 	bl	801d5a4 <synopGMACReadReg>
 801c382:	60f8      	str	r0, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaStatus ,data);
 801c384:	687b      	ldr	r3, [r7, #4]
 801c386:	685b      	ldr	r3, [r3, #4]
 801c388:	4618      	mov	r0, r3
 801c38a:	f04f 0114 	mov.w	r1, #20
 801c38e:	68fa      	ldr	r2, [r7, #12]
 801c390:	f001 f91a 	bl	801d5c8 <synopGMACWriteReg>
}
 801c394:	f107 0710 	add.w	r7, r7, #16
 801c398:	46bd      	mov	sp, r7
 801c39a:	bd80      	pop	{r7, pc}

0801c39c <synopGMAC_get_interrupt_type>:
  * Returns the all unmasked interrupt status after reading the DmaStatus register.
  * @param[in] pointer to synopGMACdevice.
  * \return 0 upon success. Error code upon failure.
  */
u32 synopGMAC_get_interrupt_type(synopGMACdevice *gmacdev)
{
 801c39c:	b580      	push	{r7, lr}
 801c39e:	b084      	sub	sp, #16
 801c3a0:	af00      	add	r7, sp, #0
 801c3a2:	6078      	str	r0, [r7, #4]
	u32 data;
	u32 interrupts = 0;
 801c3a4:	f04f 0300 	mov.w	r3, #0
 801c3a8:	60fb      	str	r3, [r7, #12]
	data = synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaStatus);
 801c3aa:	687b      	ldr	r3, [r7, #4]
 801c3ac:	685b      	ldr	r3, [r3, #4]
 801c3ae:	4618      	mov	r0, r3
 801c3b0:	f04f 0114 	mov.w	r1, #20
 801c3b4:	f001 f8f6 	bl	801d5a4 <synopGMACReadReg>
 801c3b8:	60b8      	str	r0, [r7, #8]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaStatus ,data); //This is the appropriate location to clear the interrupts
 801c3ba:	687b      	ldr	r3, [r7, #4]
 801c3bc:	685b      	ldr	r3, [r3, #4]
 801c3be:	4618      	mov	r0, r3
 801c3c0:	f04f 0114 	mov.w	r1, #20
 801c3c4:	68ba      	ldr	r2, [r7, #8]
 801c3c6:	f001 f8ff 	bl	801d5c8 <synopGMACWriteReg>
	if(data & DmaIntErrorMask)	interrupts     |= synopGMACDmaError;
 801c3ca:	68bb      	ldr	r3, [r7, #8]
 801c3cc:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801c3d0:	2b00      	cmp	r3, #0
 801c3d2:	d003      	beq.n	801c3dc <synopGMAC_get_interrupt_type+0x40>
 801c3d4:	68fb      	ldr	r3, [r7, #12]
 801c3d6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 801c3da:	60fb      	str	r3, [r7, #12]
	if(data & DmaIntRxNormMask)	interrupts     |= synopGMACDmaRxNormal;
 801c3dc:	68bb      	ldr	r3, [r7, #8]
 801c3de:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801c3e2:	2b00      	cmp	r3, #0
 801c3e4:	d003      	beq.n	801c3ee <synopGMAC_get_interrupt_type+0x52>
 801c3e6:	68fb      	ldr	r3, [r7, #12]
 801c3e8:	f043 0301 	orr.w	r3, r3, #1
 801c3ec:	60fb      	str	r3, [r7, #12]
	if(data & DmaIntRxAbnMask)	interrupts     |= synopGMACDmaRxAbnormal;
 801c3ee:	68bb      	ldr	r3, [r7, #8]
 801c3f0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801c3f4:	2b00      	cmp	r3, #0
 801c3f6:	d003      	beq.n	801c400 <synopGMAC_get_interrupt_type+0x64>
 801c3f8:	68fb      	ldr	r3, [r7, #12]
 801c3fa:	f043 0302 	orr.w	r3, r3, #2
 801c3fe:	60fb      	str	r3, [r7, #12]
	if(data & DmaIntRxStoppedMask)	interrupts |= synopGMACDmaRxStopped;
 801c400:	68bb      	ldr	r3, [r7, #8]
 801c402:	f403 7380 	and.w	r3, r3, #256	; 0x100
 801c406:	2b00      	cmp	r3, #0
 801c408:	d003      	beq.n	801c412 <synopGMAC_get_interrupt_type+0x76>
 801c40a:	68fb      	ldr	r3, [r7, #12]
 801c40c:	f043 0304 	orr.w	r3, r3, #4
 801c410:	60fb      	str	r3, [r7, #12]
	if(data & DmaIntTxNormMask)	interrupts     |= synopGMACDmaTxNormal;
 801c412:	68bb      	ldr	r3, [r7, #8]
 801c414:	f003 0301 	and.w	r3, r3, #1
 801c418:	2b00      	cmp	r3, #0
 801c41a:	d003      	beq.n	801c424 <synopGMAC_get_interrupt_type+0x88>
 801c41c:	68fb      	ldr	r3, [r7, #12]
 801c41e:	f043 0308 	orr.w	r3, r3, #8
 801c422:	60fb      	str	r3, [r7, #12]
	if(data & DmaIntTxAbnMask)	interrupts     |= synopGMACDmaTxAbnormal;
 801c424:	68bb      	ldr	r3, [r7, #8]
 801c426:	f003 0320 	and.w	r3, r3, #32
 801c42a:	2b00      	cmp	r3, #0
 801c42c:	d003      	beq.n	801c436 <synopGMAC_get_interrupt_type+0x9a>
 801c42e:	68fb      	ldr	r3, [r7, #12]
 801c430:	f043 0310 	orr.w	r3, r3, #16
 801c434:	60fb      	str	r3, [r7, #12]
	if(data & DmaIntTxStoppedMask)	interrupts |= synopGMACDmaTxStopped;
 801c436:	68bb      	ldr	r3, [r7, #8]
 801c438:	f003 0302 	and.w	r3, r3, #2
 801c43c:	2b00      	cmp	r3, #0
 801c43e:	d003      	beq.n	801c448 <synopGMAC_get_interrupt_type+0xac>
 801c440:	68fb      	ldr	r3, [r7, #12]
 801c442:	f043 0320 	orr.w	r3, r3, #32
 801c446:	60fb      	str	r3, [r7, #12]
#ifdef AVB_SUPPORT
    if(data & DmaSlotCounterIntr)   interrupts |= synopGMADmaSlotCounter;      
#endif

	return interrupts;
 801c448:	68fb      	ldr	r3, [r7, #12]
}
 801c44a:	4618      	mov	r0, r3
 801c44c:	f107 0710 	add.w	r7, r7, #16
 801c450:	46bd      	mov	sp, r7
 801c452:	bd80      	pop	{r7, pc}

0801c454 <synopGMAC_get_interrupt_mask>:
  * Returns the interrupt mask.
  * @param[in] pointer to synopGMACdevice.
  * \return 0 upon success. Error code upon failure.
  */
u32 synopGMAC_get_interrupt_mask(synopGMACdevice *gmacdev)
{
 801c454:	b580      	push	{r7, lr}
 801c456:	b082      	sub	sp, #8
 801c458:	af00      	add	r7, sp, #0
 801c45a:	6078      	str	r0, [r7, #4]
	return(synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaInterrupt));
 801c45c:	687b      	ldr	r3, [r7, #4]
 801c45e:	685b      	ldr	r3, [r3, #4]
 801c460:	4618      	mov	r0, r3
 801c462:	f04f 011c 	mov.w	r1, #28
 801c466:	f001 f89d 	bl	801d5a4 <synopGMACReadReg>
 801c46a:	4603      	mov	r3, r0
}
 801c46c:	4618      	mov	r0, r3
 801c46e:	f107 0708 	add.w	r7, r7, #8
 801c472:	46bd      	mov	sp, r7
 801c474:	bd80      	pop	{r7, pc}
 801c476:	bf00      	nop

0801c478 <synopGMAC_enable_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] bit mask of interrupts to be enabled.
  * \return returns void.
  */
void synopGMAC_enable_interrupt(synopGMACdevice *gmacdev, u32 interrupts)
{
 801c478:	b580      	push	{r7, lr}
 801c47a:	b082      	sub	sp, #8
 801c47c:	af00      	add	r7, sp, #0
 801c47e:	6078      	str	r0, [r7, #4]
 801c480:	6039      	str	r1, [r7, #0]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaInterrupt, interrupts);
 801c482:	687b      	ldr	r3, [r7, #4]
 801c484:	685b      	ldr	r3, [r3, #4]
 801c486:	4618      	mov	r0, r3
 801c488:	f04f 011c 	mov.w	r1, #28
 801c48c:	683a      	ldr	r2, [r7, #0]
 801c48e:	f001 f89b 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801c492:	bf00      	nop
}
 801c494:	f107 0708 	add.w	r7, r7, #8
 801c498:	46bd      	mov	sp, r7
 801c49a:	bd80      	pop	{r7, pc}

0801c49c <synopGMAC_disable_interrupt_all>:
  * \return returns void.
  * \note This function disabled all the interrupts, if you want to disable a particular interrupt then
  *  use synopGMAC_disable_interrupt().
  */
void synopGMAC_disable_interrupt_all(synopGMACdevice *gmacdev)
{
 801c49c:	b580      	push	{r7, lr}
 801c49e:	b082      	sub	sp, #8
 801c4a0:	af00      	add	r7, sp, #0
 801c4a2:	6078      	str	r0, [r7, #4]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaInterrupt, DmaIntDisable);
 801c4a4:	687b      	ldr	r3, [r7, #4]
 801c4a6:	685b      	ldr	r3, [r3, #4]
 801c4a8:	4618      	mov	r0, r3
 801c4aa:	f04f 011c 	mov.w	r1, #28
 801c4ae:	f04f 0200 	mov.w	r2, #0
 801c4b2:	f001 f889 	bl	801d5c8 <synopGMACWriteReg>
	return;
 801c4b6:	bf00      	nop
}
 801c4b8:	f107 0708 	add.w	r7, r7, #8
 801c4bc:	46bd      	mov	sp, r7
 801c4be:	bd80      	pop	{r7, pc}

0801c4c0 <synopGMAC_disable_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] bit mask for interrupts to be disabled.
  * \return returns void.
  */
void synopGMAC_disable_interrupt(synopGMACdevice *gmacdev, u32 interrupts)
{
 801c4c0:	b580      	push	{r7, lr}
 801c4c2:	b082      	sub	sp, #8
 801c4c4:	af00      	add	r7, sp, #0
 801c4c6:	6078      	str	r0, [r7, #4]
 801c4c8:	6039      	str	r1, [r7, #0]
	synopGMACClearBits((u32 *)gmacdev->DmaBase, DmaInterrupt, interrupts);
 801c4ca:	687b      	ldr	r3, [r7, #4]
 801c4cc:	685b      	ldr	r3, [r3, #4]
 801c4ce:	4618      	mov	r0, r3
 801c4d0:	f04f 011c 	mov.w	r1, #28
 801c4d4:	683a      	ldr	r2, [r7, #0]
 801c4d6:	f001 f8a3 	bl	801d620 <synopGMACClearBits>
	return;
 801c4da:	bf00      	nop
}
 801c4dc:	f107 0708 	add.w	r7, r7, #8
 801c4e0:	46bd      	mov	sp, r7
 801c4e2:	bd80      	pop	{r7, pc}

0801c4e4 <synopGMAC_enable_dma_rx>:
  * Enable the DMA Reception.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_enable_dma_rx(synopGMACdevice * gmacdev)
{
 801c4e4:	b580      	push	{r7, lr}
 801c4e6:	b084      	sub	sp, #16
 801c4e8:	af00      	add	r7, sp, #0
 801c4ea:	6078      	str	r0, [r7, #4]
//	synopGMACSetBits((u32 *)gmacdev->DmaBase, DmaControl, DmaRxStart);
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaControl);
 801c4ec:	687b      	ldr	r3, [r7, #4]
 801c4ee:	685b      	ldr	r3, [r3, #4]
 801c4f0:	4618      	mov	r0, r3
 801c4f2:	f04f 0118 	mov.w	r1, #24
 801c4f6:	f001 f855 	bl	801d5a4 <synopGMACReadReg>
 801c4fa:	60f8      	str	r0, [r7, #12]
  	data |= DmaRxStart; 
 801c4fc:	68fb      	ldr	r3, [r7, #12]
 801c4fe:	f043 0302 	orr.w	r3, r3, #2
 801c502:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaControl ,data);
 801c504:	687b      	ldr	r3, [r7, #4]
 801c506:	685b      	ldr	r3, [r3, #4]
 801c508:	4618      	mov	r0, r3
 801c50a:	f04f 0118 	mov.w	r1, #24
 801c50e:	68fa      	ldr	r2, [r7, #12]
 801c510:	f001 f85a 	bl	801d5c8 <synopGMACWriteReg>

}
 801c514:	f107 0710 	add.w	r7, r7, #16
 801c518:	46bd      	mov	sp, r7
 801c51a:	bd80      	pop	{r7, pc}

0801c51c <synopGMAC_enable_dma_tx>:
  * Enable the DMA Transmission.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_enable_dma_tx(synopGMACdevice * gmacdev)
{
 801c51c:	b580      	push	{r7, lr}
 801c51e:	b084      	sub	sp, #16
 801c520:	af00      	add	r7, sp, #0
 801c522:	6078      	str	r0, [r7, #4]
//	synopGMACSetBits((u32 *)gmacdev->DmaBase, DmaControl, DmaTxStart);
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaControl);
 801c524:	687b      	ldr	r3, [r7, #4]
 801c526:	685b      	ldr	r3, [r3, #4]
 801c528:	4618      	mov	r0, r3
 801c52a:	f04f 0118 	mov.w	r1, #24
 801c52e:	f001 f839 	bl	801d5a4 <synopGMACReadReg>
 801c532:	60f8      	str	r0, [r7, #12]
  	data |= DmaTxStart; 
 801c534:	68fb      	ldr	r3, [r7, #12]
 801c536:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 801c53a:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaControl ,data);
 801c53c:	687b      	ldr	r3, [r7, #4]
 801c53e:	685b      	ldr	r3, [r3, #4]
 801c540:	4618      	mov	r0, r3
 801c542:	f04f 0118 	mov.w	r1, #24
 801c546:	68fa      	ldr	r2, [r7, #12]
 801c548:	f001 f83e 	bl	801d5c8 <synopGMACWriteReg>

}
 801c54c:	f107 0710 	add.w	r7, r7, #16
 801c550:	46bd      	mov	sp, r7
 801c552:	bd80      	pop	{r7, pc}

0801c554 <synopGMAC_resume_dma_tx>:
  * This forces the DMA to resume transmission.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_resume_dma_tx(synopGMACdevice * gmacdev)
{
 801c554:	b580      	push	{r7, lr}
 801c556:	b082      	sub	sp, #8
 801c558:	af00      	add	r7, sp, #0
 801c55a:	6078      	str	r0, [r7, #4]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaTxPollDemand, 0);
 801c55c:	687b      	ldr	r3, [r7, #4]
 801c55e:	685b      	ldr	r3, [r3, #4]
 801c560:	4618      	mov	r0, r3
 801c562:	f04f 0104 	mov.w	r1, #4
 801c566:	f04f 0200 	mov.w	r2, #0
 801c56a:	f001 f82d 	bl	801d5c8 <synopGMACWriteReg>

}
 801c56e:	f107 0708 	add.w	r7, r7, #8
 801c572:	46bd      	mov	sp, r7
 801c574:	bd80      	pop	{r7, pc}
 801c576:	bf00      	nop

0801c578 <synopGMAC_resume_dma_rx>:
  * This forces the DMA to resume reception.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_resume_dma_rx(synopGMACdevice * gmacdev)
{
 801c578:	b580      	push	{r7, lr}
 801c57a:	b082      	sub	sp, #8
 801c57c:	af00      	add	r7, sp, #0
 801c57e:	6078      	str	r0, [r7, #4]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaRxPollDemand, 0);
 801c580:	687b      	ldr	r3, [r7, #4]
 801c582:	685b      	ldr	r3, [r3, #4]
 801c584:	4618      	mov	r0, r3
 801c586:	f04f 0108 	mov.w	r1, #8
 801c58a:	f04f 0200 	mov.w	r2, #0
 801c58e:	f001 f81b 	bl	801d5c8 <synopGMACWriteReg>

}
 801c592:	f107 0708 	add.w	r7, r7, #8
 801c596:	46bd      	mov	sp, r7
 801c598:	bd80      	pop	{r7, pc}
 801c59a:	bf00      	nop

0801c59c <synopGMAC_take_desc_ownership>:
  * The function is same for both the ring mode and the chain mode DMA structures.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_take_desc_ownership(DmaDesc * desc)
{
 801c59c:	b480      	push	{r7}
 801c59e:	b083      	sub	sp, #12
 801c5a0:	af00      	add	r7, sp, #0
 801c5a2:	6078      	str	r0, [r7, #4]
	if(desc){
 801c5a4:	687b      	ldr	r3, [r7, #4]
 801c5a6:	2b00      	cmp	r3, #0
 801c5a8:	d005      	beq.n	801c5b6 <synopGMAC_take_desc_ownership+0x1a>
		desc->status &= ~DescOwnByDma;  //Clear the DMA own bit
 801c5aa:	687b      	ldr	r3, [r7, #4]
 801c5ac:	681b      	ldr	r3, [r3, #0]
 801c5ae:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 801c5b2:	687b      	ldr	r3, [r7, #4]
 801c5b4:	601a      	str	r2, [r3, #0]
//		desc->status |= DescError;	// Set the error to indicate this descriptor is bad
	}
}
 801c5b6:	f107 070c 	add.w	r7, r7, #12
 801c5ba:	46bd      	mov	sp, r7
 801c5bc:	bc80      	pop	{r7}
 801c5be:	4770      	bx	lr

0801c5c0 <synopGMAC_take_desc_ownership_rx>:
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  * \note Make sure to disable the transmission before calling this function, otherwise may result in racing situation.
  */
void synopGMAC_take_desc_ownership_rx(synopGMACdevice * gmacdev)
{
 801c5c0:	b580      	push	{r7, lr}
 801c5c2:	b084      	sub	sp, #16
 801c5c4:	af00      	add	r7, sp, #0
 801c5c6:	6078      	str	r0, [r7, #4]
	s32 i;
	DmaDesc *desc;
	desc = gmacdev->RxDesc;
 801c5c8:	687b      	ldr	r3, [r7, #4]
 801c5ca:	69db      	ldr	r3, [r3, #28]
 801c5cc:	60bb      	str	r3, [r7, #8]
	for(i = 0; i < gmacdev->RxDescCount; i++){
 801c5ce:	f04f 0300 	mov.w	r3, #0
 801c5d2:	60fb      	str	r3, [r7, #12]
 801c5d4:	e01c      	b.n	801c610 <synopGMAC_take_desc_ownership_rx+0x50>
		if(synopGMAC_is_rx_desc_chained(desc)){	//This descriptor is in chain mode
 801c5d6:	68b8      	ldr	r0, [r7, #8]
 801c5d8:	f7ff fbc4 	bl	801bd64 <synopGMAC_is_rx_desc_chained>
 801c5dc:	4603      	mov	r3, r0
 801c5de:	2b00      	cmp	r3, #0
 801c5e0:	d006      	beq.n	801c5f0 <synopGMAC_take_desc_ownership_rx+0x30>
	
			synopGMAC_take_desc_ownership(desc);
 801c5e2:	68b8      	ldr	r0, [r7, #8]
 801c5e4:	f7ff ffda 	bl	801c59c <synopGMAC_take_desc_ownership>
			desc = (DmaDesc *)desc->data2;
 801c5e8:	68bb      	ldr	r3, [r7, #8]
 801c5ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801c5ec:	60bb      	str	r3, [r7, #8]
 801c5ee:	e00b      	b.n	801c608 <synopGMAC_take_desc_ownership_rx+0x48>
		}
		else{
			synopGMAC_take_desc_ownership(desc + i);
 801c5f0:	68fa      	ldr	r2, [r7, #12]
 801c5f2:	4613      	mov	r3, r2
 801c5f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801c5f8:	189b      	adds	r3, r3, r2
 801c5fa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801c5fe:	68ba      	ldr	r2, [r7, #8]
 801c600:	18d3      	adds	r3, r2, r3
 801c602:	4618      	mov	r0, r3
 801c604:	f7ff ffca 	bl	801c59c <synopGMAC_take_desc_ownership>
void synopGMAC_take_desc_ownership_rx(synopGMACdevice * gmacdev)
{
	s32 i;
	DmaDesc *desc;
	desc = gmacdev->RxDesc;
	for(i = 0; i < gmacdev->RxDescCount; i++){
 801c608:	68fb      	ldr	r3, [r7, #12]
 801c60a:	f103 0301 	add.w	r3, r3, #1
 801c60e:	60fb      	str	r3, [r7, #12]
 801c610:	68fa      	ldr	r2, [r7, #12]
 801c612:	687b      	ldr	r3, [r7, #4]
 801c614:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801c616:	429a      	cmp	r2, r3
 801c618:	d3dd      	bcc.n	801c5d6 <synopGMAC_take_desc_ownership_rx+0x16>
		}
		else{
			synopGMAC_take_desc_ownership(desc + i);
		}
	}
}
 801c61a:	f107 0710 	add.w	r7, r7, #16
 801c61e:	46bd      	mov	sp, r7
 801c620:	bd80      	pop	{r7, pc}
 801c622:	bf00      	nop

0801c624 <synopGMAC_take_desc_ownership_tx>:
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  * \note Make sure to disable the transmission before calling this function, otherwise may result in racing situation.
  */
void synopGMAC_take_desc_ownership_tx(synopGMACdevice * gmacdev)
{
 801c624:	b580      	push	{r7, lr}
 801c626:	b084      	sub	sp, #16
 801c628:	af00      	add	r7, sp, #0
 801c62a:	6078      	str	r0, [r7, #4]
	s32 i;
	DmaDesc *desc;
	desc = gmacdev->TxDesc;
 801c62c:	687b      	ldr	r3, [r7, #4]
 801c62e:	699b      	ldr	r3, [r3, #24]
 801c630:	60bb      	str	r3, [r7, #8]
	for(i = 0; i < gmacdev->TxDescCount; i++){
 801c632:	f04f 0300 	mov.w	r3, #0
 801c636:	60fb      	str	r3, [r7, #12]
 801c638:	e01c      	b.n	801c674 <synopGMAC_take_desc_ownership_tx+0x50>
		if(synopGMAC_is_tx_desc_chained(desc)){	//This descriptor is in chain mode
 801c63a:	68b8      	ldr	r0, [r7, #8]
 801c63c:	f7ff fba6 	bl	801bd8c <synopGMAC_is_tx_desc_chained>
 801c640:	4603      	mov	r3, r0
 801c642:	2b00      	cmp	r3, #0
 801c644:	d006      	beq.n	801c654 <synopGMAC_take_desc_ownership_tx+0x30>
			synopGMAC_take_desc_ownership(desc);
 801c646:	68b8      	ldr	r0, [r7, #8]
 801c648:	f7ff ffa8 	bl	801c59c <synopGMAC_take_desc_ownership>
			desc = (DmaDesc *)desc->data2;
 801c64c:	68bb      	ldr	r3, [r7, #8]
 801c64e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801c650:	60bb      	str	r3, [r7, #8]
 801c652:	e00b      	b.n	801c66c <synopGMAC_take_desc_ownership_tx+0x48>
		}
		else{
			synopGMAC_take_desc_ownership(desc + i);
 801c654:	68fa      	ldr	r2, [r7, #12]
 801c656:	4613      	mov	r3, r2
 801c658:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801c65c:	189b      	adds	r3, r3, r2
 801c65e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801c662:	68ba      	ldr	r2, [r7, #8]
 801c664:	18d3      	adds	r3, r2, r3
 801c666:	4618      	mov	r0, r3
 801c668:	f7ff ff98 	bl	801c59c <synopGMAC_take_desc_ownership>
void synopGMAC_take_desc_ownership_tx(synopGMACdevice * gmacdev)
{
	s32 i;
	DmaDesc *desc;
	desc = gmacdev->TxDesc;
	for(i = 0; i < gmacdev->TxDescCount; i++){
 801c66c:	68fb      	ldr	r3, [r7, #12]
 801c66e:	f103 0301 	add.w	r3, r3, #1
 801c672:	60fb      	str	r3, [r7, #12]
 801c674:	68fa      	ldr	r2, [r7, #12]
 801c676:	687b      	ldr	r3, [r7, #4]
 801c678:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801c67a:	429a      	cmp	r2, r3
 801c67c:	d3dd      	bcc.n	801c63a <synopGMAC_take_desc_ownership_tx+0x16>
		else{
			synopGMAC_take_desc_ownership(desc + i);
		}
	}
	
}
 801c67e:	f107 0710 	add.w	r7, r7, #16
 801c682:	46bd      	mov	sp, r7
 801c684:	bd80      	pop	{r7, pc}
 801c686:	bf00      	nop

0801c688 <synopGMAC_disable_dma_tx>:
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */

void synopGMAC_disable_dma_tx(synopGMACdevice * gmacdev)
{	
 801c688:	b580      	push	{r7, lr}
 801c68a:	b084      	sub	sp, #16
 801c68c:	af00      	add	r7, sp, #0
 801c68e:	6078      	str	r0, [r7, #4]
//	synopGMACClearBits((u32 *)gmacdev->DmaBase, DmaControl, DmaTxStart);
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaControl);
 801c690:	687b      	ldr	r3, [r7, #4]
 801c692:	685b      	ldr	r3, [r3, #4]
 801c694:	4618      	mov	r0, r3
 801c696:	f04f 0118 	mov.w	r1, #24
 801c69a:	f000 ff83 	bl	801d5a4 <synopGMACReadReg>
 801c69e:	60f8      	str	r0, [r7, #12]
  	data &= (~DmaTxStart); 
 801c6a0:	68fb      	ldr	r3, [r7, #12]
 801c6a2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 801c6a6:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaControl ,data);
 801c6a8:	687b      	ldr	r3, [r7, #4]
 801c6aa:	685b      	ldr	r3, [r3, #4]
 801c6ac:	4618      	mov	r0, r3
 801c6ae:	f04f 0118 	mov.w	r1, #24
 801c6b2:	68fa      	ldr	r2, [r7, #12]
 801c6b4:	f000 ff88 	bl	801d5c8 <synopGMACWriteReg>
}
 801c6b8:	f107 0710 	add.w	r7, r7, #16
 801c6bc:	46bd      	mov	sp, r7
 801c6be:	bd80      	pop	{r7, pc}

0801c6c0 <synopGMAC_disable_dma_rx>:
  * Disable the DMA for Reception.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_disable_dma_rx(synopGMACdevice * gmacdev)
{	
 801c6c0:	b580      	push	{r7, lr}
 801c6c2:	b084      	sub	sp, #16
 801c6c4:	af00      	add	r7, sp, #0
 801c6c6:	6078      	str	r0, [r7, #4]
//	synopGMACClearBits((u32 *)gmacdev->DmaBase, DmaControl, DmaRxStart);
	u32 data;
	data = synopGMACReadReg((u32 *)gmacdev->DmaBase, DmaControl);
 801c6c8:	687b      	ldr	r3, [r7, #4]
 801c6ca:	685b      	ldr	r3, [r3, #4]
 801c6cc:	4618      	mov	r0, r3
 801c6ce:	f04f 0118 	mov.w	r1, #24
 801c6d2:	f000 ff67 	bl	801d5a4 <synopGMACReadReg>
 801c6d6:	60f8      	str	r0, [r7, #12]
  	data &= (~DmaRxStart); 
 801c6d8:	68fb      	ldr	r3, [r7, #12]
 801c6da:	f023 0302 	bic.w	r3, r3, #2
 801c6de:	60fb      	str	r3, [r7, #12]
	synopGMACWriteReg((u32 *)gmacdev->DmaBase, DmaControl ,data);
 801c6e0:	687b      	ldr	r3, [r7, #4]
 801c6e2:	685b      	ldr	r3, [r3, #4]
 801c6e4:	4618      	mov	r0, r3
 801c6e6:	f04f 0118 	mov.w	r1, #24
 801c6ea:	68fa      	ldr	r2, [r7, #12]
 801c6ec:	f000 ff6c 	bl	801d5c8 <synopGMACWriteReg>
}
 801c6f0:	f107 0710 	add.w	r7, r7, #16
 801c6f4:	46bd      	mov	sp, r7
 801c6f6:	bd80      	pop	{r7, pc}

0801c6f8 <synopGMAC_pmt_int_enable>:
  * reception.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_pmt_int_enable(synopGMACdevice *gmacdev)
{
 801c6f8:	b580      	push	{r7, lr}
 801c6fa:	b082      	sub	sp, #8
 801c6fc:	af00      	add	r7, sp, #0
 801c6fe:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacInterruptMask,GmacPmtIntMask); 
 801c700:	687b      	ldr	r3, [r7, #4]
 801c702:	681b      	ldr	r3, [r3, #0]
 801c704:	4618      	mov	r0, r3
 801c706:	f04f 013c 	mov.w	r1, #60	; 0x3c
 801c70a:	f04f 0208 	mov.w	r2, #8
 801c70e:	f000 ff87 	bl	801d620 <synopGMACClearBits>
        return;
 801c712:	bf00      	nop
}
 801c714:	f107 0708 	add.w	r7, r7, #8
 801c718:	46bd      	mov	sp, r7
 801c71a:	bd80      	pop	{r7, pc}

0801c71c <synopGMAC_pmt_int_disable>:
  * reception.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_pmt_int_disable(synopGMACdevice *gmacdev)
{
 801c71c:	b580      	push	{r7, lr}
 801c71e:	b082      	sub	sp, #8
 801c720:	af00      	add	r7, sp, #0
 801c722:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacInterruptMask,GmacPmtIntMask); 
 801c724:	687b      	ldr	r3, [r7, #4]
 801c726:	681b      	ldr	r3, [r3, #0]
 801c728:	4618      	mov	r0, r3
 801c72a:	f04f 013c 	mov.w	r1, #60	; 0x3c
 801c72e:	f04f 0208 	mov.w	r2, #8
 801c732:	f000 ff5b 	bl	801d5ec <synopGMACSetBits>
        return;
 801c736:	bf00      	nop
}
 801c738:	f107 0708 	add.w	r7, r7, #8
 801c73c:	46bd      	mov	sp, r7
 801c73e:	bd80      	pop	{r7, pc}

0801c740 <synopGMAC_power_down_enable>:
  * This function puts the Gmac in power down mode.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_power_down_enable(synopGMACdevice *gmacdev)
{
 801c740:	b580      	push	{r7, lr}
 801c742:	b082      	sub	sp, #8
 801c744:	af00      	add	r7, sp, #0
 801c746:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus,GmacPmtPowerDown);	
 801c748:	687b      	ldr	r3, [r7, #4]
 801c74a:	681b      	ldr	r3, [r3, #0]
 801c74c:	4618      	mov	r0, r3
 801c74e:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c752:	f04f 0201 	mov.w	r2, #1
 801c756:	f000 ff49 	bl	801d5ec <synopGMACSetBits>
	return;
 801c75a:	bf00      	nop
}
 801c75c:	f107 0708 	add.w	r7, r7, #8
 801c760:	46bd      	mov	sp, r7
 801c762:	bd80      	pop	{r7, pc}

0801c764 <synopGMAC_power_down_disable>:
  * wake up frames received from the network, this function should be called.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_power_down_disable(synopGMACdevice *gmacdev)
{
 801c764:	b580      	push	{r7, lr}
 801c766:	b082      	sub	sp, #8
 801c768:	af00      	add	r7, sp, #0
 801c76a:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus,GmacPmtPowerDown);	
 801c76c:	687b      	ldr	r3, [r7, #4]
 801c76e:	681b      	ldr	r3, [r3, #0]
 801c770:	4618      	mov	r0, r3
 801c772:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c776:	f04f 0201 	mov.w	r2, #1
 801c77a:	f000 ff51 	bl	801d620 <synopGMACClearBits>
	return;
 801c77e:	bf00      	nop
}
 801c780:	f107 0708 	add.w	r7, r7, #8
 801c784:	46bd      	mov	sp, r7
 801c786:	bd80      	pop	{r7, pc}

0801c788 <synopGMAC_enable_pmt_interrupt>:
  * Enables the pmt interrupt generation in powerdown mode.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_enable_pmt_interrupt(synopGMACdevice *gmacdev)
{
 801c788:	b580      	push	{r7, lr}
 801c78a:	b082      	sub	sp, #8
 801c78c:	af00      	add	r7, sp, #0
 801c78e:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacInterruptMask,GmacPmtIntMask);	
 801c790:	687b      	ldr	r3, [r7, #4]
 801c792:	681b      	ldr	r3, [r3, #0]
 801c794:	4618      	mov	r0, r3
 801c796:	f04f 013c 	mov.w	r1, #60	; 0x3c
 801c79a:	f04f 0208 	mov.w	r2, #8
 801c79e:	f000 ff3f 	bl	801d620 <synopGMACClearBits>
}
 801c7a2:	f107 0708 	add.w	r7, r7, #8
 801c7a6:	46bd      	mov	sp, r7
 801c7a8:	bd80      	pop	{r7, pc}
 801c7aa:	bf00      	nop

0801c7ac <synopGMAC_disable_pmt_interrupt>:
  * Disables the pmt interrupt generation in powerdown mode.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_disable_pmt_interrupt(synopGMACdevice *gmacdev)
{
 801c7ac:	b580      	push	{r7, lr}
 801c7ae:	b082      	sub	sp, #8
 801c7b0:	af00      	add	r7, sp, #0
 801c7b2:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacInterruptMask,GmacPmtIntMask);	
 801c7b4:	687b      	ldr	r3, [r7, #4]
 801c7b6:	681b      	ldr	r3, [r3, #0]
 801c7b8:	4618      	mov	r0, r3
 801c7ba:	f04f 013c 	mov.w	r1, #60	; 0x3c
 801c7be:	f04f 0208 	mov.w	r2, #8
 801c7c2:	f000 ff13 	bl	801d5ec <synopGMACSetBits>
}
 801c7c6:	f107 0708 	add.w	r7, r7, #8
 801c7ca:	46bd      	mov	sp, r7
 801c7cc:	bd80      	pop	{r7, pc}
 801c7ce:	bf00      	nop

0801c7d0 <synopGMAC_magic_packet_enable>:
  * Enables GMAC to look for Magic packet.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_magic_packet_enable(synopGMACdevice *gmacdev)
{
 801c7d0:	b580      	push	{r7, lr}
 801c7d2:	b082      	sub	sp, #8
 801c7d4:	af00      	add	r7, sp, #0
 801c7d6:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus,GmacPmtMagicPktEnable);	
 801c7d8:	687b      	ldr	r3, [r7, #4]
 801c7da:	681b      	ldr	r3, [r3, #0]
 801c7dc:	4618      	mov	r0, r3
 801c7de:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c7e2:	f04f 0202 	mov.w	r2, #2
 801c7e6:	f000 ff01 	bl	801d5ec <synopGMACSetBits>
	return;
 801c7ea:	bf00      	nop
}
 801c7ec:	f107 0708 	add.w	r7, r7, #8
 801c7f0:	46bd      	mov	sp, r7
 801c7f2:	bd80      	pop	{r7, pc}

0801c7f4 <synopGMAC_wakeup_frame_enable>:
  * Wake up frame is defined by the user.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_wakeup_frame_enable(synopGMACdevice *gmacdev)
{
 801c7f4:	b580      	push	{r7, lr}
 801c7f6:	b082      	sub	sp, #8
 801c7f8:	af00      	add	r7, sp, #0
 801c7fa:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus,GmacPmtWakeupFrameEnable);	
 801c7fc:	687b      	ldr	r3, [r7, #4]
 801c7fe:	681b      	ldr	r3, [r3, #0]
 801c800:	4618      	mov	r0, r3
 801c802:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c806:	f04f 0204 	mov.w	r2, #4
 801c80a:	f000 feef 	bl	801d5ec <synopGMACSetBits>
	return;
 801c80e:	bf00      	nop
}
 801c810:	f107 0708 	add.w	r7, r7, #8
 801c814:	46bd      	mov	sp, r7
 801c816:	bd80      	pop	{r7, pc}

0801c818 <synopGMAC_pmt_unicast_enable>:
  * Enables wake-up frame filter to handle unicast packets.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_pmt_unicast_enable(synopGMACdevice *gmacdev)
{
 801c818:	b580      	push	{r7, lr}
 801c81a:	b082      	sub	sp, #8
 801c81c:	af00      	add	r7, sp, #0
 801c81e:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus,GmacPmtGlobalUnicast);	
 801c820:	687b      	ldr	r3, [r7, #4]
 801c822:	681b      	ldr	r3, [r3, #0]
 801c824:	4618      	mov	r0, r3
 801c826:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c82a:	f44f 7200 	mov.w	r2, #512	; 0x200
 801c82e:	f000 fedd 	bl	801d5ec <synopGMACSetBits>
	return;
 801c832:	bf00      	nop
}
 801c834:	f107 0708 	add.w	r7, r7, #8
 801c838:	46bd      	mov	sp, r7
 801c83a:	bd80      	pop	{r7, pc}

0801c83c <synopGMAC_is_magic_packet_received>:
  * Checks whether the packet received is a magic packet?.
  * @param[in] pointer to synopGMACdevice.
  * \return returns True if magic packet received else returns false.
  */
bool synopGMAC_is_magic_packet_received(synopGMACdevice *gmacdev)
{
 801c83c:	b580      	push	{r7, lr}
 801c83e:	b084      	sub	sp, #16
 801c840:	af00      	add	r7, sp, #0
 801c842:	6078      	str	r0, [r7, #4]
	u32 data;
	data = 	synopGMACReadReg((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus);	
 801c844:	687b      	ldr	r3, [r7, #4]
 801c846:	681b      	ldr	r3, [r3, #0]
 801c848:	4618      	mov	r0, r3
 801c84a:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c84e:	f000 fea9 	bl	801d5a4 <synopGMACReadReg>
 801c852:	60f8      	str	r0, [r7, #12]
	return((data & GmacPmtMagicPktReceived) == GmacPmtMagicPktReceived);
 801c854:	68fb      	ldr	r3, [r7, #12]
 801c856:	f003 0320 	and.w	r3, r3, #32
 801c85a:	2b00      	cmp	r3, #0
 801c85c:	bf0c      	ite	eq
 801c85e:	2300      	moveq	r3, #0
 801c860:	2301      	movne	r3, #1
 801c862:	b2db      	uxtb	r3, r3
}
 801c864:	4618      	mov	r0, r3
 801c866:	f107 0710 	add.w	r7, r7, #16
 801c86a:	46bd      	mov	sp, r7
 801c86c:	bd80      	pop	{r7, pc}
 801c86e:	bf00      	nop

0801c870 <synopGMAC_is_wakeup_frame_received>:
  * Checks whether the packet received is a wakeup frame?.
  * @param[in] pointer to synopGMACdevice.
  * \return returns true if wakeup frame received else returns false.
  */
bool synopGMAC_is_wakeup_frame_received(synopGMACdevice *gmacdev)
{
 801c870:	b580      	push	{r7, lr}
 801c872:	b084      	sub	sp, #16
 801c874:	af00      	add	r7, sp, #0
 801c876:	6078      	str	r0, [r7, #4]
	u32 data;
	data = 	synopGMACReadReg((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus);	
 801c878:	687b      	ldr	r3, [r7, #4]
 801c87a:	681b      	ldr	r3, [r3, #0]
 801c87c:	4618      	mov	r0, r3
 801c87e:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c882:	f000 fe8f 	bl	801d5a4 <synopGMACReadReg>
 801c886:	60f8      	str	r0, [r7, #12]
	return((data & GmacPmtWakeupFrameReceived) == GmacPmtWakeupFrameReceived);
 801c888:	68fb      	ldr	r3, [r7, #12]
 801c88a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801c88e:	2b00      	cmp	r3, #0
 801c890:	bf0c      	ite	eq
 801c892:	2300      	moveq	r3, #0
 801c894:	2301      	movne	r3, #1
 801c896:	b2db      	uxtb	r3, r3
}
 801c898:	4618      	mov	r0, r3
 801c89a:	f107 0710 	add.w	r7, r7, #16
 801c89e:	46bd      	mov	sp, r7
 801c8a0:	bd80      	pop	{r7, pc}
 801c8a2:	bf00      	nop

0801c8a4 <synopGMAC_write_wakeup_frame_register>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] pointer to frame filter contents array.
  * \return returns void.
  */
void synopGMAC_write_wakeup_frame_register(synopGMACdevice *gmacdev, u32 * filter_contents)
{
 801c8a4:	b580      	push	{r7, lr}
 801c8a6:	b084      	sub	sp, #16
 801c8a8:	af00      	add	r7, sp, #0
 801c8aa:	6078      	str	r0, [r7, #4]
 801c8ac:	6039      	str	r1, [r7, #0]
	s32 i;
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacPmtCtrlStatus,GmacPmtFrmFilterPtrReset);
 801c8ae:	687b      	ldr	r3, [r7, #4]
 801c8b0:	681b      	ldr	r3, [r3, #0]
 801c8b2:	4618      	mov	r0, r3
 801c8b4:	f04f 012c 	mov.w	r1, #44	; 0x2c
 801c8b8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801c8bc:	f000 fe96 	bl	801d5ec <synopGMACSetBits>
         
     //   synopGMAC_Wait(WAKE_UP_FRAME_WAIT);
	if(NULL != SynopGMACOneShotTimerCallback)
 801c8c0:	f645 3394 	movw	r3, #23444	; 0x5b94
 801c8c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c8c8:	681b      	ldr	r3, [r3, #0]
 801c8ca:	2b00      	cmp	r3, #0
 801c8cc:	d007      	beq.n	801c8de <synopGMAC_write_wakeup_frame_register+0x3a>
	{
		SynopGMACOneShotTimerCallback(WAKE_UP_FRAME_WAIT);
 801c8ce:	f645 3394 	movw	r3, #23444	; 0x5b94
 801c8d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c8d6:	681b      	ldr	r3, [r3, #0]
 801c8d8:	f04f 0001 	mov.w	r0, #1
 801c8dc:	4798      	blx	r3
	}

	for(i =0; i<WAKEUP_REG_LENGTH; i++)
 801c8de:	f04f 0300 	mov.w	r3, #0
 801c8e2:	60fb      	str	r3, [r7, #12]
 801c8e4:	e012      	b.n	801c90c <synopGMAC_write_wakeup_frame_register+0x68>
		synopGMACWriteReg((u32 *)gmacdev->MacBase, GmacWakeupAddr,  *(filter_contents + i));
 801c8e6:	687b      	ldr	r3, [r7, #4]
 801c8e8:	681b      	ldr	r3, [r3, #0]
 801c8ea:	461a      	mov	r2, r3
 801c8ec:	68fb      	ldr	r3, [r7, #12]
 801c8ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801c8f2:	6839      	ldr	r1, [r7, #0]
 801c8f4:	18cb      	adds	r3, r1, r3
 801c8f6:	681b      	ldr	r3, [r3, #0]
 801c8f8:	4610      	mov	r0, r2
 801c8fa:	f04f 0128 	mov.w	r1, #40	; 0x28
 801c8fe:	461a      	mov	r2, r3
 801c900:	f000 fe62 	bl	801d5c8 <synopGMACWriteReg>
	if(NULL != SynopGMACOneShotTimerCallback)
	{
		SynopGMACOneShotTimerCallback(WAKE_UP_FRAME_WAIT);
	}

	for(i =0; i<WAKEUP_REG_LENGTH; i++)
 801c904:	68fb      	ldr	r3, [r7, #12]
 801c906:	f103 0301 	add.w	r3, r3, #1
 801c90a:	60fb      	str	r3, [r7, #12]
 801c90c:	68fb      	ldr	r3, [r7, #12]
 801c90e:	2b07      	cmp	r3, #7
 801c910:	dde9      	ble.n	801c8e6 <synopGMAC_write_wakeup_frame_register+0x42>
		synopGMACWriteReg((u32 *)gmacdev->MacBase, GmacWakeupAddr,  *(filter_contents + i));
	return;
 801c912:	bf00      	nop

}
 801c914:	f107 0710 	add.w	r7, r7, #16
 801c918:	46bd      	mov	sp, r7
 801c91a:	bd80      	pop	{r7, pc}

0801c91c <synopGMAC_mmc_counters_stop>:
  * due to any tx or rx frames until synopGMAC_mmc_counters_resume is called.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_mmc_counters_stop(synopGMACdevice *gmacdev)
{
 801c91c:	b580      	push	{r7, lr}
 801c91e:	b082      	sub	sp, #8
 801c920:	af00      	add	r7, sp, #0
 801c922:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacMmcCntrl,GmacMmcCounterFreeze);
 801c924:	687b      	ldr	r3, [r7, #4]
 801c926:	681b      	ldr	r3, [r3, #0]
 801c928:	4618      	mov	r0, r3
 801c92a:	f44f 7180 	mov.w	r1, #256	; 0x100
 801c92e:	f04f 0208 	mov.w	r2, #8
 801c932:	f000 fe5b 	bl	801d5ec <synopGMACSetBits>
	return;
 801c936:	bf00      	nop
}
 801c938:	f107 0708 	add.w	r7, r7, #8
 801c93c:	46bd      	mov	sp, r7
 801c93e:	bd80      	pop	{r7, pc}

0801c940 <synopGMAC_mmc_counters_resume>:
  * Resumes the MMC counter updation.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_mmc_counters_resume(synopGMACdevice *gmacdev)
{
 801c940:	b580      	push	{r7, lr}
 801c942:	b082      	sub	sp, #8
 801c944:	af00      	add	r7, sp, #0
 801c946:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacMmcCntrl,GmacMmcCounterFreeze);
 801c948:	687b      	ldr	r3, [r7, #4]
 801c94a:	681b      	ldr	r3, [r3, #0]
 801c94c:	4618      	mov	r0, r3
 801c94e:	f44f 7180 	mov.w	r1, #256	; 0x100
 801c952:	f04f 0208 	mov.w	r2, #8
 801c956:	f000 fe63 	bl	801d620 <synopGMACClearBits>
	return;
 801c95a:	bf00      	nop
}
 801c95c:	f107 0708 	add.w	r7, r7, #8
 801c960:	46bd      	mov	sp, r7
 801c962:	bd80      	pop	{r7, pc}

0801c964 <synopGMAC_mmc_counters_set_selfclear>:
  * Programs MMC interface so that counters are cleared when the counters are read.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_mmc_counters_set_selfclear(synopGMACdevice *gmacdev)
{
 801c964:	b580      	push	{r7, lr}
 801c966:	b082      	sub	sp, #8
 801c968:	af00      	add	r7, sp, #0
 801c96a:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacMmcCntrl,GmacMmcCounterResetOnRead);
 801c96c:	687b      	ldr	r3, [r7, #4]
 801c96e:	681b      	ldr	r3, [r3, #0]
 801c970:	4618      	mov	r0, r3
 801c972:	f44f 7180 	mov.w	r1, #256	; 0x100
 801c976:	f04f 0204 	mov.w	r2, #4
 801c97a:	f000 fe37 	bl	801d5ec <synopGMACSetBits>
	return;
 801c97e:	bf00      	nop
}
 801c980:	f107 0708 	add.w	r7, r7, #8
 801c984:	46bd      	mov	sp, r7
 801c986:	bd80      	pop	{r7, pc}

0801c988 <synopGMAC_mmc_counters_reset_selfclear>:
  * Programs MMC interface so that counters are cleared when the counters are read.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_mmc_counters_reset_selfclear(synopGMACdevice *gmacdev)
{
 801c988:	b580      	push	{r7, lr}
 801c98a:	b082      	sub	sp, #8
 801c98c:	af00      	add	r7, sp, #0
 801c98e:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacMmcCntrl,GmacMmcCounterResetOnRead);
 801c990:	687b      	ldr	r3, [r7, #4]
 801c992:	681b      	ldr	r3, [r3, #0]
 801c994:	4618      	mov	r0, r3
 801c996:	f44f 7180 	mov.w	r1, #256	; 0x100
 801c99a:	f04f 0204 	mov.w	r2, #4
 801c99e:	f000 fe3f 	bl	801d620 <synopGMACClearBits>
	return;
 801c9a2:	bf00      	nop
}
 801c9a4:	f107 0708 	add.w	r7, r7, #8
 801c9a8:	46bd      	mov	sp, r7
 801c9aa:	bd80      	pop	{r7, pc}

0801c9ac <synopGMAC_mmc_counters_disable_rollover>:
  * Programs MMC interface so that counters will not rollover after reaching maximum value.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_mmc_counters_disable_rollover(synopGMACdevice *gmacdev)
{
 801c9ac:	b580      	push	{r7, lr}
 801c9ae:	b082      	sub	sp, #8
 801c9b0:	af00      	add	r7, sp, #0
 801c9b2:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacMmcCntrl,GmacMmcCounterStopRollover);
 801c9b4:	687b      	ldr	r3, [r7, #4]
 801c9b6:	681b      	ldr	r3, [r3, #0]
 801c9b8:	4618      	mov	r0, r3
 801c9ba:	f44f 7180 	mov.w	r1, #256	; 0x100
 801c9be:	f04f 0202 	mov.w	r2, #2
 801c9c2:	f000 fe13 	bl	801d5ec <synopGMACSetBits>
	return;
 801c9c6:	bf00      	nop
}
 801c9c8:	f107 0708 	add.w	r7, r7, #8
 801c9cc:	46bd      	mov	sp, r7
 801c9ce:	bd80      	pop	{r7, pc}

0801c9d0 <synopGMAC_mmc_counters_enable_rollover>:
  * Programs MMC interface so that counters will rollover after reaching maximum value.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_mmc_counters_enable_rollover(synopGMACdevice *gmacdev)
{
 801c9d0:	b580      	push	{r7, lr}
 801c9d2:	b082      	sub	sp, #8
 801c9d4:	af00      	add	r7, sp, #0
 801c9d6:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacMmcCntrl,GmacMmcCounterStopRollover);
 801c9d8:	687b      	ldr	r3, [r7, #4]
 801c9da:	681b      	ldr	r3, [r3, #0]
 801c9dc:	4618      	mov	r0, r3
 801c9de:	f44f 7180 	mov.w	r1, #256	; 0x100
 801c9e2:	f04f 0202 	mov.w	r2, #2
 801c9e6:	f000 fe1b 	bl	801d620 <synopGMACClearBits>
	return;
 801c9ea:	bf00      	nop
}
 801c9ec:	f107 0708 	add.w	r7, r7, #8
 801c9f0:	46bd      	mov	sp, r7
 801c9f2:	bd80      	pop	{r7, pc}

0801c9f4 <synopGMAC_read_mmc_counter>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] the counter to be read.
  * \return returns the read count value.
  */
u32 synopGMAC_read_mmc_counter(synopGMACdevice *gmacdev, u32 counter)
{
 801c9f4:	b580      	push	{r7, lr}
 801c9f6:	b082      	sub	sp, #8
 801c9f8:	af00      	add	r7, sp, #0
 801c9fa:	6078      	str	r0, [r7, #4]
 801c9fc:	6039      	str	r1, [r7, #0]
	return(	synopGMACReadReg((u32 *)gmacdev->MacBase,counter));
 801c9fe:	687b      	ldr	r3, [r7, #4]
 801ca00:	681b      	ldr	r3, [r3, #0]
 801ca02:	4618      	mov	r0, r3
 801ca04:	6839      	ldr	r1, [r7, #0]
 801ca06:	f000 fdcd 	bl	801d5a4 <synopGMACReadReg>
 801ca0a:	4603      	mov	r3, r0
}
 801ca0c:	4618      	mov	r0, r3
 801ca0e:	f107 0708 	add.w	r7, r7, #8
 801ca12:	46bd      	mov	sp, r7
 801ca14:	bd80      	pop	{r7, pc}
 801ca16:	bf00      	nop

0801ca18 <synopGMAC_read_mmc_rx_int_status>:
  * Read the MMC Rx interrupt status.
  * @param[in] pointer to synopGMACdevice.
  * \return returns the Rx interrupt status.
  */
u32 synopGMAC_read_mmc_rx_int_status(synopGMACdevice *gmacdev)
{
 801ca18:	b580      	push	{r7, lr}
 801ca1a:	b082      	sub	sp, #8
 801ca1c:	af00      	add	r7, sp, #0
 801ca1e:	6078      	str	r0, [r7, #4]
	return(	synopGMACReadReg((u32 *)gmacdev->MacBase,GmacMmcIntrRx));
 801ca20:	687b      	ldr	r3, [r7, #4]
 801ca22:	681b      	ldr	r3, [r3, #0]
 801ca24:	4618      	mov	r0, r3
 801ca26:	f44f 7182 	mov.w	r1, #260	; 0x104
 801ca2a:	f000 fdbb 	bl	801d5a4 <synopGMACReadReg>
 801ca2e:	4603      	mov	r3, r0
}
 801ca30:	4618      	mov	r0, r3
 801ca32:	f107 0708 	add.w	r7, r7, #8
 801ca36:	46bd      	mov	sp, r7
 801ca38:	bd80      	pop	{r7, pc}
 801ca3a:	bf00      	nop

0801ca3c <synopGMAC_read_mmc_tx_int_status>:
  * Read the MMC Tx interrupt status.
  * @param[in] pointer to synopGMACdevice.
  * \return returns the Tx interrupt status.
  */
u32 synopGMAC_read_mmc_tx_int_status(synopGMACdevice *gmacdev)
{
 801ca3c:	b580      	push	{r7, lr}
 801ca3e:	b082      	sub	sp, #8
 801ca40:	af00      	add	r7, sp, #0
 801ca42:	6078      	str	r0, [r7, #4]
	return(	synopGMACReadReg((u32 *)gmacdev->MacBase,GmacMmcIntrTx));
 801ca44:	687b      	ldr	r3, [r7, #4]
 801ca46:	681b      	ldr	r3, [r3, #0]
 801ca48:	4618      	mov	r0, r3
 801ca4a:	f44f 7184 	mov.w	r1, #264	; 0x108
 801ca4e:	f000 fda9 	bl	801d5a4 <synopGMACReadReg>
 801ca52:	4603      	mov	r3, r0
}
 801ca54:	4618      	mov	r0, r3
 801ca56:	f107 0708 	add.w	r7, r7, #8
 801ca5a:	46bd      	mov	sp, r7
 801ca5c:	bd80      	pop	{r7, pc}
 801ca5e:	bf00      	nop

0801ca60 <synopGMAC_disable_mmc_tx_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] tx interrupt bit mask for which interrupts needs to be disabled.
  * \return returns void.
  */
void synopGMAC_disable_mmc_tx_interrupt(synopGMACdevice *gmacdev, u32 mask)
{
 801ca60:	b580      	push	{r7, lr}
 801ca62:	b082      	sub	sp, #8
 801ca64:	af00      	add	r7, sp, #0
 801ca66:	6078      	str	r0, [r7, #4]
 801ca68:	6039      	str	r1, [r7, #0]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacMmcIntrMaskTx,mask);
 801ca6a:	687b      	ldr	r3, [r7, #4]
 801ca6c:	681b      	ldr	r3, [r3, #0]
 801ca6e:	4618      	mov	r0, r3
 801ca70:	f44f 7188 	mov.w	r1, #272	; 0x110
 801ca74:	683a      	ldr	r2, [r7, #0]
 801ca76:	f000 fdb9 	bl	801d5ec <synopGMACSetBits>
	return;
 801ca7a:	bf00      	nop
}
 801ca7c:	f107 0708 	add.w	r7, r7, #8
 801ca80:	46bd      	mov	sp, r7
 801ca82:	bd80      	pop	{r7, pc}

0801ca84 <synopGMAC_enable_mmc_tx_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] tx interrupt bit mask for which interrupts needs to be enabled.
  * \return returns void.
  */
void synopGMAC_enable_mmc_tx_interrupt(synopGMACdevice *gmacdev, u32 mask)
{
 801ca84:	b580      	push	{r7, lr}
 801ca86:	b082      	sub	sp, #8
 801ca88:	af00      	add	r7, sp, #0
 801ca8a:	6078      	str	r0, [r7, #4]
 801ca8c:	6039      	str	r1, [r7, #0]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacMmcIntrMaskTx,mask);
 801ca8e:	687b      	ldr	r3, [r7, #4]
 801ca90:	681b      	ldr	r3, [r3, #0]
 801ca92:	4618      	mov	r0, r3
 801ca94:	f44f 7188 	mov.w	r1, #272	; 0x110
 801ca98:	683a      	ldr	r2, [r7, #0]
 801ca9a:	f000 fdc1 	bl	801d620 <synopGMACClearBits>
}
 801ca9e:	f107 0708 	add.w	r7, r7, #8
 801caa2:	46bd      	mov	sp, r7
 801caa4:	bd80      	pop	{r7, pc}
 801caa6:	bf00      	nop

0801caa8 <synopGMAC_disable_mmc_rx_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] rx interrupt bit mask for which interrupts needs to be disabled.
  * \return returns void.
  */
void synopGMAC_disable_mmc_rx_interrupt(synopGMACdevice *gmacdev, u32 mask)
{
 801caa8:	b580      	push	{r7, lr}
 801caaa:	b082      	sub	sp, #8
 801caac:	af00      	add	r7, sp, #0
 801caae:	6078      	str	r0, [r7, #4]
 801cab0:	6039      	str	r1, [r7, #0]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacMmcIntrMaskRx,mask);
 801cab2:	687b      	ldr	r3, [r7, #4]
 801cab4:	681b      	ldr	r3, [r3, #0]
 801cab6:	4618      	mov	r0, r3
 801cab8:	f44f 7186 	mov.w	r1, #268	; 0x10c
 801cabc:	683a      	ldr	r2, [r7, #0]
 801cabe:	f000 fd95 	bl	801d5ec <synopGMACSetBits>
	return;
 801cac2:	bf00      	nop
}
 801cac4:	f107 0708 	add.w	r7, r7, #8
 801cac8:	46bd      	mov	sp, r7
 801caca:	bd80      	pop	{r7, pc}

0801cacc <synopGMAC_enable_mmc_rx_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] rx interrupt bit mask for which interrupts needs to be enabled.
  * \return returns void.
  */
void synopGMAC_enable_mmc_rx_interrupt(synopGMACdevice *gmacdev, u32 mask)
{
 801cacc:	b580      	push	{r7, lr}
 801cace:	b082      	sub	sp, #8
 801cad0:	af00      	add	r7, sp, #0
 801cad2:	6078      	str	r0, [r7, #4]
 801cad4:	6039      	str	r1, [r7, #0]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacMmcIntrMaskRx,mask);
 801cad6:	687b      	ldr	r3, [r7, #4]
 801cad8:	681b      	ldr	r3, [r3, #0]
 801cada:	4618      	mov	r0, r3
 801cadc:	f44f 7186 	mov.w	r1, #268	; 0x10c
 801cae0:	683a      	ldr	r2, [r7, #0]
 801cae2:	f000 fd9d 	bl	801d620 <synopGMACClearBits>
	return;
 801cae6:	bf00      	nop
}
 801cae8:	f107 0708 	add.w	r7, r7, #8
 801caec:	46bd      	mov	sp, r7
 801caee:	bd80      	pop	{r7, pc}

0801caf0 <synopGMAC_disable_mmc_ipc_rx_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] rx interrupt bit mask for which interrupts needs to be disabled.
  * \return returns void.
  */
void synopGMAC_disable_mmc_ipc_rx_interrupt(synopGMACdevice *gmacdev, u32 mask)
{
 801caf0:	b580      	push	{r7, lr}
 801caf2:	b082      	sub	sp, #8
 801caf4:	af00      	add	r7, sp, #0
 801caf6:	6078      	str	r0, [r7, #4]
 801caf8:	6039      	str	r1, [r7, #0]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacMmcRxIpcIntrMask,mask);
 801cafa:	687b      	ldr	r3, [r7, #4]
 801cafc:	681b      	ldr	r3, [r3, #0]
 801cafe:	4618      	mov	r0, r3
 801cb00:	f44f 7100 	mov.w	r1, #512	; 0x200
 801cb04:	683a      	ldr	r2, [r7, #0]
 801cb06:	f000 fd71 	bl	801d5ec <synopGMACSetBits>
	return;
 801cb0a:	bf00      	nop
}
 801cb0c:	f107 0708 	add.w	r7, r7, #8
 801cb10:	46bd      	mov	sp, r7
 801cb12:	bd80      	pop	{r7, pc}

0801cb14 <synopGMAC_enable_mmc_ipc_rx_interrupt>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] rx interrupt bit mask for which interrupts needs to be enabled.
  * \return returns void.
  */
void synopGMAC_enable_mmc_ipc_rx_interrupt(synopGMACdevice *gmacdev, u32 mask)
{
 801cb14:	b580      	push	{r7, lr}
 801cb16:	b082      	sub	sp, #8
 801cb18:	af00      	add	r7, sp, #0
 801cb1a:	6078      	str	r0, [r7, #4]
 801cb1c:	6039      	str	r1, [r7, #0]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacMmcRxIpcIntrMask,mask);
 801cb1e:	687b      	ldr	r3, [r7, #4]
 801cb20:	681b      	ldr	r3, [r3, #0]
 801cb22:	4618      	mov	r0, r3
 801cb24:	f44f 7100 	mov.w	r1, #512	; 0x200
 801cb28:	683a      	ldr	r2, [r7, #0]
 801cb2a:	f000 fd79 	bl	801d620 <synopGMACClearBits>
	return;
 801cb2e:	bf00      	nop
}
 801cb30:	f107 0708 	add.w	r7, r7, #8
 801cb34:	46bd      	mov	sp, r7
 801cb36:	bd80      	pop	{r7, pc}

0801cb38 <synopGMAC_enable_rx_chksum_offload>:
  * for payload of IP datagram and appends it to Ethernet frame transferred to the application.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_enable_rx_chksum_offload(synopGMACdevice *gmacdev)
{
 801cb38:	b580      	push	{r7, lr}
 801cb3a:	b082      	sub	sp, #8
 801cb3c:	af00      	add	r7, sp, #0
 801cb3e:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->MacBase,GmacConfig,GmacRxIpcOffload);
 801cb40:	687b      	ldr	r3, [r7, #4]
 801cb42:	681b      	ldr	r3, [r3, #0]
 801cb44:	4618      	mov	r0, r3
 801cb46:	f04f 0100 	mov.w	r1, #0
 801cb4a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801cb4e:	f000 fd4d 	bl	801d5ec <synopGMACSetBits>
	return;
 801cb52:	bf00      	nop
}
 801cb54:	f107 0708 	add.w	r7, r7, #8
 801cb58:	46bd      	mov	sp, r7
 801cb5a:	bd80      	pop	{r7, pc}

0801cb5c <synopGMAC_disable_rx_Ipchecksum_offload>:
  * Ip checksum offloading is disabled in the receive path.
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_disable_rx_Ipchecksum_offload(synopGMACdevice *gmacdev)
{
 801cb5c:	b580      	push	{r7, lr}
 801cb5e:	b082      	sub	sp, #8
 801cb60:	af00      	add	r7, sp, #0
 801cb62:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->MacBase,GmacConfig,GmacRxIpcOffload);
 801cb64:	687b      	ldr	r3, [r7, #4]
 801cb66:	681b      	ldr	r3, [r3, #0]
 801cb68:	4618      	mov	r0, r3
 801cb6a:	f04f 0100 	mov.w	r1, #0
 801cb6e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801cb72:	f000 fd55 	bl	801d620 <synopGMACClearBits>
}
 801cb76:	f107 0708 	add.w	r7, r7, #8
 801cb7a:	46bd      	mov	sp, r7
 801cb7c:	bd80      	pop	{r7, pc}
 801cb7e:	bf00      	nop

0801cb80 <synopGMAC_rx_tcpip_chksum_drop_enable>:
  * fails the tcp/ip checksum in hardware. Valid only when full checksum offloading is enabled(type-2).
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_rx_tcpip_chksum_drop_enable(synopGMACdevice *gmacdev)
{
 801cb80:	b580      	push	{r7, lr}
 801cb82:	b082      	sub	sp, #8
 801cb84:	af00      	add	r7, sp, #0
 801cb86:	6078      	str	r0, [r7, #4]
	synopGMACClearBits((u32 *)gmacdev->DmaBase,DmaControl,DmaDisableDropTcpCs);
 801cb88:	687b      	ldr	r3, [r7, #4]
 801cb8a:	685b      	ldr	r3, [r3, #4]
 801cb8c:	4618      	mov	r0, r3
 801cb8e:	f04f 0118 	mov.w	r1, #24
 801cb92:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 801cb96:	f000 fd43 	bl	801d620 <synopGMACClearBits>
	return;
 801cb9a:	bf00      	nop
}
 801cb9c:	f107 0708 	add.w	r7, r7, #8
 801cba0:	46bd      	mov	sp, r7
 801cba2:	bd80      	pop	{r7, pc}

0801cba4 <synopGMAC_rx_tcpip_chksum_drop_disable>:
  * fails the tcp/ip checksum in hardware. Valid only when full checksum offloading is enabled(type-2).
  * @param[in] pointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_rx_tcpip_chksum_drop_disable(synopGMACdevice *gmacdev)
{
 801cba4:	b580      	push	{r7, lr}
 801cba6:	b082      	sub	sp, #8
 801cba8:	af00      	add	r7, sp, #0
 801cbaa:	6078      	str	r0, [r7, #4]
	synopGMACSetBits((u32 *)gmacdev->DmaBase,DmaControl,DmaDisableDropTcpCs);
 801cbac:	687b      	ldr	r3, [r7, #4]
 801cbae:	685b      	ldr	r3, [r3, #4]
 801cbb0:	4618      	mov	r0, r3
 801cbb2:	f04f 0118 	mov.w	r1, #24
 801cbb6:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 801cbba:	f000 fd17 	bl	801d5ec <synopGMACSetBits>
	return;
 801cbbe:	bf00      	nop
}
 801cbc0:	f107 0708 	add.w	r7, r7, #8
 801cbc4:	46bd      	mov	sp, r7
 801cbc6:	bd80      	pop	{r7, pc}

0801cbc8 <synopGMAC_is_ext_status>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] u32 status field of the corresponding descriptor.
  * \return returns TRUE or FALSE.
  */
bool synopGMAC_is_ext_status(synopGMACdevice *gmacdev,u32 status) 		      // extended status present indicates that the RDES4 need to be probed
{
 801cbc8:	b480      	push	{r7}
 801cbca:	b083      	sub	sp, #12
 801cbcc:	af00      	add	r7, sp, #0
 801cbce:	6078      	str	r0, [r7, #4]
 801cbd0:	6039      	str	r1, [r7, #0]
	return((status & DescRxEXTsts ) != 0 ); // if extstatus set then it returns 1
 801cbd2:	683b      	ldr	r3, [r7, #0]
 801cbd4:	f003 0301 	and.w	r3, r3, #1
 801cbd8:	2b00      	cmp	r3, #0
 801cbda:	bf0c      	ite	eq
 801cbdc:	2300      	moveq	r3, #0
 801cbde:	2301      	movne	r3, #1
 801cbe0:	b2db      	uxtb	r3, r3
}
 801cbe2:	4618      	mov	r0, r3
 801cbe4:	f107 070c 	add.w	r7, r7, #12
 801cbe8:	46bd      	mov	sp, r7
 801cbea:	bc80      	pop	{r7}
 801cbec:	4770      	bx	lr
 801cbee:	bf00      	nop

0801cbf0 <synopGMAC_ES_is_IP_header_error>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] u32 status field of the corresponding descriptor.
  * \return returns TRUE or FALSE.
  */
bool synopGMAC_ES_is_IP_header_error(synopGMACdevice *gmacdev,u32 ext_status)          // IP header (IPV4) checksum error
{
 801cbf0:	b480      	push	{r7}
 801cbf2:	b083      	sub	sp, #12
 801cbf4:	af00      	add	r7, sp, #0
 801cbf6:	6078      	str	r0, [r7, #4]
 801cbf8:	6039      	str	r1, [r7, #0]
	return((ext_status & DescRxIpHeaderError) != 0 ); // if IPV4 header error return 1
 801cbfa:	683b      	ldr	r3, [r7, #0]
 801cbfc:	f003 0308 	and.w	r3, r3, #8
 801cc00:	2b00      	cmp	r3, #0
 801cc02:	bf0c      	ite	eq
 801cc04:	2300      	moveq	r3, #0
 801cc06:	2301      	movne	r3, #1
 801cc08:	b2db      	uxtb	r3, r3
}
 801cc0a:	4618      	mov	r0, r3
 801cc0c:	f107 070c 	add.w	r7, r7, #12
 801cc10:	46bd      	mov	sp, r7
 801cc12:	bc80      	pop	{r7}
 801cc14:	4770      	bx	lr
 801cc16:	bf00      	nop

0801cc18 <synopGMAC_ES_is_rx_checksum_bypassed>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] u32 status field of the corresponding descriptor.
  * \return returns TRUE or FALSE.
  */
bool synopGMAC_ES_is_rx_checksum_bypassed(synopGMACdevice *gmacdev,u32 ext_status)     // Hardware engine bypassed the checksum computation/checking
{
 801cc18:	b480      	push	{r7}
 801cc1a:	b083      	sub	sp, #12
 801cc1c:	af00      	add	r7, sp, #0
 801cc1e:	6078      	str	r0, [r7, #4]
 801cc20:	6039      	str	r1, [r7, #0]
	return((ext_status & DescRxChkSumBypass ) != 0 ); // if checksum offloading bypassed return 1
 801cc22:	683b      	ldr	r3, [r7, #0]
 801cc24:	f003 0320 	and.w	r3, r3, #32
 801cc28:	2b00      	cmp	r3, #0
 801cc2a:	bf0c      	ite	eq
 801cc2c:	2300      	moveq	r3, #0
 801cc2e:	2301      	movne	r3, #1
 801cc30:	b2db      	uxtb	r3, r3
}
 801cc32:	4618      	mov	r0, r3
 801cc34:	f107 070c 	add.w	r7, r7, #12
 801cc38:	46bd      	mov	sp, r7
 801cc3a:	bc80      	pop	{r7}
 801cc3c:	4770      	bx	lr
 801cc3e:	bf00      	nop

0801cc40 <synopGMAC_ES_is_IP_payload_error>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] u32 status field of the corresponding descriptor.
  * \return returns TRUE or FALSE.
  */
bool synopGMAC_ES_is_IP_payload_error(synopGMACdevice *gmacdev,u32 ext_status)         // IP payload checksum is in error (UDP/TCP/ICMP checksum error)
{
 801cc40:	b480      	push	{r7}
 801cc42:	b083      	sub	sp, #12
 801cc44:	af00      	add	r7, sp, #0
 801cc46:	6078      	str	r0, [r7, #4]
 801cc48:	6039      	str	r1, [r7, #0]
	return((ext_status & DescRxIpPayloadError) != 0 ); // if IP payload error return 1
 801cc4a:	683b      	ldr	r3, [r7, #0]
 801cc4c:	f003 0310 	and.w	r3, r3, #16
 801cc50:	2b00      	cmp	r3, #0
 801cc52:	bf0c      	ite	eq
 801cc54:	2300      	moveq	r3, #0
 801cc56:	2301      	movne	r3, #1
 801cc58:	b2db      	uxtb	r3, r3
}
 801cc5a:	4618      	mov	r0, r3
 801cc5c:	f107 070c 	add.w	r7, r7, #12
 801cc60:	46bd      	mov	sp, r7
 801cc62:	bc80      	pop	{r7}
 801cc64:	4770      	bx	lr
 801cc66:	bf00      	nop

0801cc68 <synopGMAC_is_rx_checksum_error>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] u32 status field of the corresponding descriptor.
  * \return returns decoded enum (u32) indicating the status.
  */
u32 synopGMAC_is_rx_checksum_error(synopGMACdevice *gmacdev, u32 status)
{
 801cc68:	b480      	push	{r7}
 801cc6a:	b083      	sub	sp, #12
 801cc6c:	af00      	add	r7, sp, #0
 801cc6e:	6078      	str	r0, [r7, #4]
 801cc70:	6039      	str	r1, [r7, #0]
	if     (((status & DescRxChkBit5) == 0) && ((status & DescRxChkBit7) == 0) && ((status & DescRxChkBit0) == 0))
 801cc72:	683b      	ldr	r3, [r7, #0]
 801cc74:	f003 0320 	and.w	r3, r3, #32
 801cc78:	2b00      	cmp	r3, #0
 801cc7a:	d10c      	bne.n	801cc96 <synopGMAC_is_rx_checksum_error+0x2e>
 801cc7c:	683b      	ldr	r3, [r7, #0]
 801cc7e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801cc82:	2b00      	cmp	r3, #0
 801cc84:	d107      	bne.n	801cc96 <synopGMAC_is_rx_checksum_error+0x2e>
 801cc86:	683b      	ldr	r3, [r7, #0]
 801cc88:	f003 0301 	and.w	r3, r3, #1
 801cc8c:	2b00      	cmp	r3, #0
 801cc8e:	d102      	bne.n	801cc96 <synopGMAC_is_rx_checksum_error+0x2e>
	return RxLenLT600;
 801cc90:	f04f 0300 	mov.w	r3, #0
 801cc94:	e06d      	b.n	801cd72 <synopGMAC_is_rx_checksum_error+0x10a>
	else if(((status & DescRxChkBit5) == 0) && ((status & DescRxChkBit7) == 0) && ((status & DescRxChkBit0) != 0))
 801cc96:	683b      	ldr	r3, [r7, #0]
 801cc98:	f003 0320 	and.w	r3, r3, #32
 801cc9c:	2b00      	cmp	r3, #0
 801cc9e:	d10c      	bne.n	801ccba <synopGMAC_is_rx_checksum_error+0x52>
 801cca0:	683b      	ldr	r3, [r7, #0]
 801cca2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801cca6:	2b00      	cmp	r3, #0
 801cca8:	d107      	bne.n	801ccba <synopGMAC_is_rx_checksum_error+0x52>
 801ccaa:	683b      	ldr	r3, [r7, #0]
 801ccac:	f003 0301 	and.w	r3, r3, #1
 801ccb0:	2b00      	cmp	r3, #0
 801ccb2:	d002      	beq.n	801ccba <synopGMAC_is_rx_checksum_error+0x52>
	return RxIpHdrPayLoadChkBypass;
 801ccb4:	f04f 0301 	mov.w	r3, #1
 801ccb8:	e05b      	b.n	801cd72 <synopGMAC_is_rx_checksum_error+0x10a>
	else if(((status & DescRxChkBit5) == 0) && ((status & DescRxChkBit7) != 0) && ((status & DescRxChkBit0) != 0))
 801ccba:	683b      	ldr	r3, [r7, #0]
 801ccbc:	f003 0320 	and.w	r3, r3, #32
 801ccc0:	2b00      	cmp	r3, #0
 801ccc2:	d10c      	bne.n	801ccde <synopGMAC_is_rx_checksum_error+0x76>
 801ccc4:	683b      	ldr	r3, [r7, #0]
 801ccc6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801ccca:	2b00      	cmp	r3, #0
 801cccc:	d007      	beq.n	801ccde <synopGMAC_is_rx_checksum_error+0x76>
 801ccce:	683b      	ldr	r3, [r7, #0]
 801ccd0:	f003 0301 	and.w	r3, r3, #1
 801ccd4:	2b00      	cmp	r3, #0
 801ccd6:	d002      	beq.n	801ccde <synopGMAC_is_rx_checksum_error+0x76>
	return RxChkBypass;
 801ccd8:	f04f 0303 	mov.w	r3, #3
 801ccdc:	e049      	b.n	801cd72 <synopGMAC_is_rx_checksum_error+0x10a>
	else if(((status & DescRxChkBit5) != 0) && ((status & DescRxChkBit7) == 0) && ((status & DescRxChkBit0) == 0))
 801ccde:	683b      	ldr	r3, [r7, #0]
 801cce0:	f003 0320 	and.w	r3, r3, #32
 801cce4:	2b00      	cmp	r3, #0
 801cce6:	d00c      	beq.n	801cd02 <synopGMAC_is_rx_checksum_error+0x9a>
 801cce8:	683b      	ldr	r3, [r7, #0]
 801ccea:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801ccee:	2b00      	cmp	r3, #0
 801ccf0:	d107      	bne.n	801cd02 <synopGMAC_is_rx_checksum_error+0x9a>
 801ccf2:	683b      	ldr	r3, [r7, #0]
 801ccf4:	f003 0301 	and.w	r3, r3, #1
 801ccf8:	2b00      	cmp	r3, #0
 801ccfa:	d102      	bne.n	801cd02 <synopGMAC_is_rx_checksum_error+0x9a>
	return RxNoChkError;
 801ccfc:	f04f 0304 	mov.w	r3, #4
 801cd00:	e037      	b.n	801cd72 <synopGMAC_is_rx_checksum_error+0x10a>
	else if(((status & DescRxChkBit5) != 0) && ((status & DescRxChkBit7) == 0) && ((status & DescRxChkBit0) != 0))
 801cd02:	683b      	ldr	r3, [r7, #0]
 801cd04:	f003 0320 	and.w	r3, r3, #32
 801cd08:	2b00      	cmp	r3, #0
 801cd0a:	d00c      	beq.n	801cd26 <synopGMAC_is_rx_checksum_error+0xbe>
 801cd0c:	683b      	ldr	r3, [r7, #0]
 801cd0e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801cd12:	2b00      	cmp	r3, #0
 801cd14:	d107      	bne.n	801cd26 <synopGMAC_is_rx_checksum_error+0xbe>
 801cd16:	683b      	ldr	r3, [r7, #0]
 801cd18:	f003 0301 	and.w	r3, r3, #1
 801cd1c:	2b00      	cmp	r3, #0
 801cd1e:	d002      	beq.n	801cd26 <synopGMAC_is_rx_checksum_error+0xbe>
	return RxPayLoadChkError;
 801cd20:	f04f 0305 	mov.w	r3, #5
 801cd24:	e025      	b.n	801cd72 <synopGMAC_is_rx_checksum_error+0x10a>
	else if(((status & DescRxChkBit5) != 0) && ((status & DescRxChkBit7) != 0) && ((status & DescRxChkBit0) == 0))
 801cd26:	683b      	ldr	r3, [r7, #0]
 801cd28:	f003 0320 	and.w	r3, r3, #32
 801cd2c:	2b00      	cmp	r3, #0
 801cd2e:	d00c      	beq.n	801cd4a <synopGMAC_is_rx_checksum_error+0xe2>
 801cd30:	683b      	ldr	r3, [r7, #0]
 801cd32:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801cd36:	2b00      	cmp	r3, #0
 801cd38:	d007      	beq.n	801cd4a <synopGMAC_is_rx_checksum_error+0xe2>
 801cd3a:	683b      	ldr	r3, [r7, #0]
 801cd3c:	f003 0301 	and.w	r3, r3, #1
 801cd40:	2b00      	cmp	r3, #0
 801cd42:	d102      	bne.n	801cd4a <synopGMAC_is_rx_checksum_error+0xe2>
	return RxIpHdrChkError;
 801cd44:	f04f 0306 	mov.w	r3, #6
 801cd48:	e013      	b.n	801cd72 <synopGMAC_is_rx_checksum_error+0x10a>
	else if(((status & DescRxChkBit5) != 0) && ((status & DescRxChkBit7) != 0) && ((status & DescRxChkBit0) != 0))
 801cd4a:	683b      	ldr	r3, [r7, #0]
 801cd4c:	f003 0320 	and.w	r3, r3, #32
 801cd50:	2b00      	cmp	r3, #0
 801cd52:	d00c      	beq.n	801cd6e <synopGMAC_is_rx_checksum_error+0x106>
 801cd54:	683b      	ldr	r3, [r7, #0]
 801cd56:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801cd5a:	2b00      	cmp	r3, #0
 801cd5c:	d007      	beq.n	801cd6e <synopGMAC_is_rx_checksum_error+0x106>
 801cd5e:	683b      	ldr	r3, [r7, #0]
 801cd60:	f003 0301 	and.w	r3, r3, #1
 801cd64:	2b00      	cmp	r3, #0
 801cd66:	d002      	beq.n	801cd6e <synopGMAC_is_rx_checksum_error+0x106>
	return RxIpHdrPayLoadChkError;
 801cd68:	f04f 0307 	mov.w	r3, #7
 801cd6c:	e001      	b.n	801cd72 <synopGMAC_is_rx_checksum_error+0x10a>
	else
	return RxIpHdrPayLoadRes;
 801cd6e:	f04f 0302 	mov.w	r3, #2
}
 801cd72:	4618      	mov	r0, r3
 801cd74:	f107 070c 	add.w	r7, r7, #12
 801cd78:	46bd      	mov	sp, r7
 801cd7a:	bc80      	pop	{r7}
 801cd7c:	4770      	bx	lr
 801cd7e:	bf00      	nop

0801cd80 <synopGMAC_is_tx_ipv4header_checksum_error>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] u32 status field of the corresponding descriptor.
  * \return returns true if error in ipv4 header checksum, else returns false.
  */
bool synopGMAC_is_tx_ipv4header_checksum_error(synopGMACdevice *gmacdev, u32 status)
{
 801cd80:	b480      	push	{r7}
 801cd82:	b083      	sub	sp, #12
 801cd84:	af00      	add	r7, sp, #0
 801cd86:	6078      	str	r0, [r7, #4]
 801cd88:	6039      	str	r1, [r7, #0]
	return((status & DescTxIpv4ChkError) == DescTxIpv4ChkError);
 801cd8a:	683b      	ldr	r3, [r7, #0]
 801cd8c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 801cd90:	2b00      	cmp	r3, #0
 801cd92:	bf0c      	ite	eq
 801cd94:	2300      	moveq	r3, #0
 801cd96:	2301      	movne	r3, #1
 801cd98:	b2db      	uxtb	r3, r3
}
 801cd9a:	4618      	mov	r0, r3
 801cd9c:	f107 070c 	add.w	r7, r7, #12
 801cda0:	46bd      	mov	sp, r7
 801cda2:	bc80      	pop	{r7}
 801cda4:	4770      	bx	lr
 801cda6:	bf00      	nop

0801cda8 <synopGMAC_is_tx_payload_checksum_error>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] u32 status field of the corresponding descriptor.
  * \return returns true if error in ipv4 header checksum, else returns false.
  */
bool synopGMAC_is_tx_payload_checksum_error(synopGMACdevice *gmacdev, u32 status)
{
 801cda8:	b480      	push	{r7}
 801cdaa:	b083      	sub	sp, #12
 801cdac:	af00      	add	r7, sp, #0
 801cdae:	6078      	str	r0, [r7, #4]
 801cdb0:	6039      	str	r1, [r7, #0]
	return((status & DescTxPayChkError) == DescTxPayChkError);
 801cdb2:	683b      	ldr	r3, [r7, #0]
 801cdb4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 801cdb8:	2b00      	cmp	r3, #0
 801cdba:	bf0c      	ite	eq
 801cdbc:	2300      	moveq	r3, #0
 801cdbe:	2301      	movne	r3, #1
 801cdc0:	b2db      	uxtb	r3, r3
}
 801cdc2:	4618      	mov	r0, r3
 801cdc4:	f107 070c 	add.w	r7, r7, #12
 801cdc8:	46bd      	mov	sp, r7
 801cdca:	bc80      	pop	{r7}
 801cdcc:	4770      	bx	lr
 801cdce:	bf00      	nop

0801cdd0 <synopGMAC_tx_checksum_offload_bypass>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] Pointer to tx descriptor for which  ointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_tx_checksum_offload_bypass(synopGMACdevice *gmacdev, DmaDesc *desc)
{
 801cdd0:	b480      	push	{r7}
 801cdd2:	b083      	sub	sp, #12
 801cdd4:	af00      	add	r7, sp, #0
 801cdd6:	6078      	str	r0, [r7, #4]
 801cdd8:	6039      	str	r1, [r7, #0]
	#ifdef ENH_DESC
	desc->status = (desc->length & (~DescTxCisMask));//ENH_DESC
 801cdda:	683b      	ldr	r3, [r7, #0]
 801cddc:	685b      	ldr	r3, [r3, #4]
 801cdde:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 801cde2:	683b      	ldr	r3, [r7, #0]
 801cde4:	601a      	str	r2, [r3, #0]
	#else
	desc->length = (desc->length & (~DescTxCisMask));
	#endif

}
 801cde6:	f107 070c 	add.w	r7, r7, #12
 801cdea:	46bd      	mov	sp, r7
 801cdec:	bc80      	pop	{r7}
 801cdee:	4770      	bx	lr

0801cdf0 <synopGMAC_tx_checksum_offload_ipv4hdr>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] Pointer to tx descriptor for which  ointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_tx_checksum_offload_ipv4hdr(synopGMACdevice *gmacdev, DmaDesc *desc)
{
 801cdf0:	b480      	push	{r7}
 801cdf2:	b083      	sub	sp, #12
 801cdf4:	af00      	add	r7, sp, #0
 801cdf6:	6078      	str	r0, [r7, #4]
 801cdf8:	6039      	str	r1, [r7, #0]
	#ifdef ENH_DESC
	desc->status = ((desc->status & (~DescTxCisMask)) | DescTxCisIpv4HdrCs);//ENH_DESC
 801cdfa:	683b      	ldr	r3, [r7, #0]
 801cdfc:	681b      	ldr	r3, [r3, #0]
 801cdfe:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 801ce02:	f443 0280 	orr.w	r2, r3, #4194304	; 0x400000
 801ce06:	683b      	ldr	r3, [r7, #0]
 801ce08:	601a      	str	r2, [r3, #0]
	#else
	desc->length = ((desc->length & (~DescTxCisMask)) | DescTxCisIpv4HdrCs);
	#endif

}
 801ce0a:	f107 070c 	add.w	r7, r7, #12
 801ce0e:	46bd      	mov	sp, r7
 801ce10:	bc80      	pop	{r7}
 801ce12:	4770      	bx	lr

0801ce14 <synopGMAC_tx_checksum_offload_tcponly>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] Pointer to tx descriptor for which  ointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_tx_checksum_offload_tcponly(synopGMACdevice *gmacdev, DmaDesc *desc)
{
 801ce14:	b480      	push	{r7}
 801ce16:	b083      	sub	sp, #12
 801ce18:	af00      	add	r7, sp, #0
 801ce1a:	6078      	str	r0, [r7, #4]
 801ce1c:	6039      	str	r1, [r7, #0]
	#ifdef ENH_DESC
	desc->status = ((desc->status & (~DescTxCisMask)) | DescTxCisTcpOnlyCs);//ENH_DESC
 801ce1e:	683b      	ldr	r3, [r7, #0]
 801ce20:	681b      	ldr	r3, [r3, #0]
 801ce22:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 801ce26:	f443 0200 	orr.w	r2, r3, #8388608	; 0x800000
 801ce2a:	683b      	ldr	r3, [r7, #0]
 801ce2c:	601a      	str	r2, [r3, #0]
	#else
	desc->length = ((desc->length & (~DescTxCisMask)) | DescTxCisTcpOnlyCs);
	#endif

}
 801ce2e:	f107 070c 	add.w	r7, r7, #12
 801ce32:	46bd      	mov	sp, r7
 801ce34:	bc80      	pop	{r7}
 801ce36:	4770      	bx	lr

0801ce38 <synopGMAC_tx_checksum_offload_tcp_pseudo>:
  * @param[in] pointer to synopGMACdevice.
  * @param[in] Pointer to tx descriptor for which  ointer to synopGMACdevice.
  * \return returns void.
  */
void synopGMAC_tx_checksum_offload_tcp_pseudo(synopGMACdevice *gmacdev, DmaDesc *desc)
{
 801ce38:	b480      	push	{r7}
 801ce3a:	b083      	sub	sp, #12
 801ce3c:	af00      	add	r7, sp, #0
 801ce3e:	6078      	str	r0, [r7, #4]
 801ce40:	6039      	str	r1, [r7, #0]
	#ifdef ENH_DESC
	desc->status = ((desc->status & (~DescTxCisMask)) | DescTxCisTcpPseudoCs);
 801ce42:	683b      	ldr	r3, [r7, #0]
 801ce44:	681b      	ldr	r3, [r3, #0]
 801ce46:	f443 0240 	orr.w	r2, r3, #12582912	; 0xc00000
 801ce4a:	683b      	ldr	r3, [r7, #0]
 801ce4c:	601a      	str	r2, [r3, #0]
	#else
	desc->length = ((desc->length & (~DescTxCisMask)) | DescTxCisTcpPseudoCs);
	#endif

}
 801ce4e:	f107 070c 	add.w	r7, r7, #12
 801ce52:	46bd      	mov	sp, r7
 801ce54:	bc80      	pop	{r7}
 801ce56:	4770      	bx	lr

0801ce58 <synopGMAC_IsEtherAddrsValid>:
 * @addtogroup Ethernet_privatefunc
 * @{
 */

status_t synopGMAC_IsEtherAddrsValid(unsigned char* MacAddress)
{
 801ce58:	b580      	push	{r7, lr}
 801ce5a:	b084      	sub	sp, #16
 801ce5c:	af00      	add	r7, sp, #0
 801ce5e:	6078      	str	r0, [r7, #4]
   status_t Status = DAVEApp_SUCCESS;
 801ce60:	f04f 0300 	mov.w	r3, #0
 801ce64:	60fb      	str	r3, [r7, #12]
   
   if(!is_valid_ether_addr((unsigned char*)MacAddress))
 801ce66:	6878      	ldr	r0, [r7, #4]
 801ce68:	f000 fb28 	bl	801d4bc <is_valid_ether_addr>
 801ce6c:	4603      	mov	r3, r0
 801ce6e:	2b00      	cmp	r3, #0
 801ce70:	d102      	bne.n	801ce78 <synopGMAC_IsEtherAddrsValid+0x20>
   {
    Status = ETH_INVALID_MAC_ADDR;
 801ce72:	f04f 0308 	mov.w	r3, #8
 801ce76:	60fb      	str	r3, [r7, #12]
   }
   return Status;
 801ce78:	68fb      	ldr	r3, [r7, #12]
}
 801ce7a:	4618      	mov	r0, r3
 801ce7c:	f107 0710 	add.w	r7, r7, #16
 801ce80:	46bd      	mov	sp, r7
 801ce82:	bd80      	pop	{r7, pc}

0801ce84 <synopGMAC_powerup_mac>:
 * @param[in] gmacdev pointer to GMAC device structure.
 *
 * \return returns void.
 */
void synopGMAC_powerup_mac (synopGMACdevice *gmacdev)
{
 801ce84:	b580      	push	{r7, lr}
 801ce86:	b082      	sub	sp, #8
 801ce88:	af00      	add	r7, sp, #0
 801ce8a:	6078      	str	r0, [r7, #4]
  GMAC_Power_down = 0;  // Let ISR know that MAC is out of power down now
 801ce8c:	f246 6344 	movw	r3, #26180	; 0x6644
 801ce90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ce94:	f04f 0200 	mov.w	r2, #0
 801ce98:	601a      	str	r2, [r3, #0]

  if (synopGMAC_is_magic_packet_received(gmacdev))
 801ce9a:	6878      	ldr	r0, [r7, #4]
 801ce9c:	f7ff fcce 	bl	801c83c <synopGMAC_is_magic_packet_received>
  {
    TR("GMAC wokeup due to Magic Pkt Received\n");
  }

  if (synopGMAC_is_wakeup_frame_received(gmacdev))
 801cea0:	6878      	ldr	r0, [r7, #4]
 801cea2:	f7ff fce5 	bl	801c870 <synopGMAC_is_wakeup_frame_received>
  {
    TR("GMAC wokeup due to Wakeup Frame Received\n");
  }

  /* Disable the assertion of PMT interrupt */
  synopGMAC_pmt_int_disable(gmacdev);
 801cea6:	6878      	ldr	r0, [r7, #4]
 801cea8:	f7ff fc38 	bl	801c71c <synopGMAC_pmt_int_disable>

  /* Enable the mac and Dma rx and tx paths */
  synopGMAC_rx_enable(gmacdev);
 801ceac:	6878      	ldr	r0, [r7, #4]
 801ceae:	f7fe f843 	bl	801af38 <synopGMAC_rx_enable>

  synopGMAC_enable_dma_rx(gmacdev);
 801ceb2:	6878      	ldr	r0, [r7, #4]
 801ceb4:	f7ff fb16 	bl	801c4e4 <synopGMAC_enable_dma_rx>

  synopGMAC_tx_enable(gmacdev);
 801ceb8:	6878      	ldr	r0, [r7, #4]
 801ceba:	f7fe f861 	bl	801af80 <synopGMAC_tx_enable>

  synopGMAC_enable_dma_tx(gmacdev);
 801cebe:	6878      	ldr	r0, [r7, #4]
 801cec0:	f7ff fb2c 	bl	801c51c <synopGMAC_enable_dma_tx>

  return;
 801cec4:	bf00      	nop
}
 801cec6:	f107 0708 	add.w	r7, r7, #8
 801ceca:	46bd      	mov	sp, r7
 801cecc:	bd80      	pop	{r7, pc}
 801cece:	bf00      	nop

0801ced0 <synopGMAC_cable_unplug_function>:
 *
 * @return void.
 *
 */
void synopGMAC_cable_unplug_function (void *synopGMACdev)
{
 801ced0:	b580      	push	{r7, lr}
 801ced2:	b084      	sub	sp, #16
 801ced4:	af00      	add	r7, sp, #0
 801ced6:	6078      	str	r0, [r7, #4]
  /* <<<DD_ETH_PORT_9>>> */
  status_t Status = DAVEApp_SUCCESS;
 801ced8:	f04f 0300 	mov.w	r3, #0
 801cedc:	60fb      	str	r3, [r7, #12]

  synopGMACdevice *GMACdev = (synopGMACdevice *)synopGMACdev;
 801cede:	687b      	ldr	r3, [r7, #4]
 801cee0:	60bb      	str	r3, [r7, #8]

  /* Check if PHY Link is up */
  if( PHY_IsLinkUP() == FALSE)
 801cee2:	f7fd fb69 	bl	801a5b8 <PHY_IsLinkUP>
 801cee6:	4603      	mov	r3, r0
 801cee8:	2b00      	cmp	r3, #0
 801ceea:	d114      	bne.n	801cf16 <synopGMAC_cable_unplug_function+0x46>
  {
    TR("No Link: \n");
    GMACdev->LinkState = 0;
 801ceec:	68bb      	ldr	r3, [r7, #8]
 801ceee:	f04f 0200 	mov.w	r2, #0
 801cef2:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
    GMACdev->DuplexMode = 0;
 801cef6:	68bb      	ldr	r3, [r7, #8]
 801cef8:	f04f 0200 	mov.w	r2, #0
 801cefc:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    GMACdev->Speed = 0;
 801cf00:	68bb      	ldr	r3, [r7, #8]
 801cf02:	f04f 0200 	mov.w	r2, #0
 801cf06:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    GMACdev->LoopBackMode = 0;
 801cf0a:	68bb      	ldr	r3, [r7, #8]
 801cf0c:	f04f 0200 	mov.w	r2, #0
 801cf10:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
 801cf14:	e00d      	b.n	801cf32 <synopGMAC_cable_unplug_function+0x62>
  }
  else
  {
    TR("Link UP: \n");
    if(!GMACdev->LinkState)
 801cf16:	68bb      	ldr	r3, [r7, #8]
 801cf18:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 801cf1c:	2b00      	cmp	r3, #0
 801cf1e:	d108      	bne.n	801cf32 <synopGMAC_cable_unplug_function+0x62>
    {
      Status = PHY_InitializeDevice();
 801cf20:	f7fd fb20 	bl	801a564 <PHY_InitializeDevice>
 801cf24:	60f8      	str	r0, [r7, #12]
      if (Status != DAVEApp_SUCCESS)
      {
    	  DBG002_WARNING(APP_GID, Status, 0, NULL);
      }
      synopGMAC_mac_init(GMACdev);
 801cf26:	68b8      	ldr	r0, [r7, #8]
 801cf28:	f7fe fac0 	bl	801b4ac <synopGMAC_mac_init>
      synopGMAC_promisc_enable(GMACdev);
 801cf2c:	68b8      	ldr	r0, [r7, #8]
 801cf2e:	f7fe f98d 	bl	801b24c <synopGMAC_promisc_enable>
    }
  }
}
 801cf32:	f107 0710 	add.w	r7, r7, #16
 801cf36:	46bd      	mov	sp, r7
 801cf38:	bd80      	pop	{r7, pc}
 801cf3a:	bf00      	nop

0801cf3c <synopGMAC_setup_rx_desc_queue>:
  *  function returns -ESYNOPGMACNOMEM in the process of descriptor chain creation. once returned from this function
  *  user should for gmacdev->RxDescCount to see how many descriptors are there in the chain. Should continue further
  *  only if the number of descriptors in the chain meets the requirements
  */
s32 synopGMAC_setup_rx_desc_queue(synopGMACdevice * gmacdev, u32 no_of_desc, u32 desc_mode)
{
 801cf3c:	b580      	push	{r7, lr}
 801cf3e:	b088      	sub	sp, #32
 801cf40:	af00      	add	r7, sp, #0
 801cf42:	60f8      	str	r0, [r7, #12]
 801cf44:	60b9      	str	r1, [r7, #8]
 801cf46:	607a      	str	r2, [r7, #4]
  /* <<<DD_ETH_PORT_10>>> */
  s32 i;
  DmaDesc *first_desc = NULL;
 801cf48:	f04f 0300 	mov.w	r3, #0
 801cf4c:	61bb      	str	r3, [r7, #24]
  DmaDesc *second_desc = NULL;
 801cf4e:	f04f 0300 	mov.w	r3, #0
 801cf52:	617b      	str	r3, [r7, #20]
  DmaDesc *temp_desc = NULL;
 801cf54:	f04f 0300 	mov.w	r3, #0
 801cf58:	613b      	str	r3, [r7, #16]
  //dma_addr_t dma_addr;

  gmacdev->RxDescCount = 0;
 801cf5a:	68fb      	ldr	r3, [r7, #12]
 801cf5c:	f04f 0200 	mov.w	r2, #0
 801cf60:	629a      	str	r2, [r3, #40]	; 0x28

  if(desc_mode == RINGMODE)
 801cf62:	687b      	ldr	r3, [r7, #4]
 801cf64:	2b01      	cmp	r3, #1
 801cf66:	d134      	bne.n	801cfd2 <synopGMAC_setup_rx_desc_queue+0x96>
  {
    gmacdev->RxDescCount = no_of_desc;
 801cf68:	68fb      	ldr	r3, [r7, #12]
 801cf6a:	68ba      	ldr	r2, [r7, #8]
 801cf6c:	629a      	str	r2, [r3, #40]	; 0x28
    gmacdev->RxDesc      = Eth_RxDMADescList;
 801cf6e:	68fa      	ldr	r2, [r7, #12]
 801cf70:	f240 0300 	movw	r3, #0
 801cf74:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801cf78:	61d3      	str	r3, [r2, #28]
    gmacdev->RxDescDma   = (dma_addr_t )Eth_RxDMADescList;
 801cf7a:	f240 0300 	movw	r3, #0
 801cf7e:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801cf82:	68fa      	ldr	r2, [r7, #12]
 801cf84:	6153      	str	r3, [r2, #20]

    for(i = 0; i < gmacdev->RxDescCount; i++)
 801cf86:	f04f 0300 	mov.w	r3, #0
 801cf8a:	61fb      	str	r3, [r7, #28]
 801cf8c:	e01b      	b.n	801cfc6 <synopGMAC_setup_rx_desc_queue+0x8a>
    {
      synopGMAC_rx_desc_init_ring(gmacdev->RxDesc + i, i == gmacdev->RxDescCount-1);
 801cf8e:	68fb      	ldr	r3, [r7, #12]
 801cf90:	69d9      	ldr	r1, [r3, #28]
 801cf92:	69fa      	ldr	r2, [r7, #28]
 801cf94:	4613      	mov	r3, r2
 801cf96:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801cf9a:	189b      	adds	r3, r3, r2
 801cf9c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801cfa0:	18ca      	adds	r2, r1, r3
 801cfa2:	69f9      	ldr	r1, [r7, #28]
 801cfa4:	68fb      	ldr	r3, [r7, #12]
 801cfa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801cfa8:	f103 33ff 	add.w	r3, r3, #4294967295
 801cfac:	4299      	cmp	r1, r3
 801cfae:	bf14      	ite	ne
 801cfb0:	2300      	movne	r3, #0
 801cfb2:	2301      	moveq	r3, #1
 801cfb4:	b2db      	uxtb	r3, r3
 801cfb6:	4610      	mov	r0, r2
 801cfb8:	4619      	mov	r1, r3
 801cfba:	f7fe fbe5 	bl	801b788 <synopGMAC_rx_desc_init_ring>
  {
    gmacdev->RxDescCount = no_of_desc;
    gmacdev->RxDesc      = Eth_RxDMADescList;
    gmacdev->RxDescDma   = (dma_addr_t )Eth_RxDMADescList;

    for(i = 0; i < gmacdev->RxDescCount; i++)
 801cfbe:	69fb      	ldr	r3, [r7, #28]
 801cfc0:	f103 0301 	add.w	r3, r3, #1
 801cfc4:	61fb      	str	r3, [r7, #28]
 801cfc6:	69fa      	ldr	r2, [r7, #28]
 801cfc8:	68fb      	ldr	r3, [r7, #12]
 801cfca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801cfcc:	429a      	cmp	r2, r3
 801cfce:	d3de      	bcc.n	801cf8e <synopGMAC_setup_rx_desc_queue+0x52>
 801cfd0:	e051      	b.n	801d076 <synopGMAC_setup_rx_desc_queue+0x13a>
      synopGMAC_rx_desc_init_ring(gmacdev->RxDesc + i, i == gmacdev->RxDescCount-1);
    }
  }
  else
  {
    gmacdev->RxDesc       = Eth_RxDMADescList;
 801cfd2:	68fa      	ldr	r2, [r7, #12]
 801cfd4:	f240 0300 	movw	r3, #0
 801cfd8:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801cfdc:	61d3      	str	r3, [r2, #28]
    gmacdev->RxDescDma    = (dma_addr_t)Eth_RxDMADescList;
 801cfde:	f240 0300 	movw	r3, #0
 801cfe2:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801cfe6:	68fa      	ldr	r2, [r7, #12]
 801cfe8:	6153      	str	r3, [r2, #20]

    TR("Rx===============================================================Rx\n");

    first_desc->buffer2   = gmacdev->RxDescDma;
 801cfea:	68fb      	ldr	r3, [r7, #12]
 801cfec:	695a      	ldr	r2, [r3, #20]
 801cfee:	69bb      	ldr	r3, [r7, #24]
 801cff0:	60da      	str	r2, [r3, #12]
    first_desc->data2     = (u32) gmacdev->RxDesc;
 801cff2:	68fb      	ldr	r3, [r7, #12]
 801cff4:	69db      	ldr	r3, [r3, #28]
 801cff6:	461a      	mov	r2, r3
 801cff8:	69bb      	ldr	r3, [r7, #24]
 801cffa:	625a      	str	r2, [r3, #36]	; 0x24

    gmacdev->RxDescCount = 1;
 801cffc:	68fb      	ldr	r3, [r7, #12]
 801cffe:	f04f 0201 	mov.w	r2, #1
 801d002:	629a      	str	r2, [r3, #40]	; 0x28

    //dma_addr  =   (dma_addr_t)Eth_RxDMADescList;
    temp_desc = (DmaDesc *)Eth_RxDMADescList;
 801d004:	f240 0300 	movw	r3, #0
 801d008:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801d00c:	613b      	str	r3, [r7, #16]

    for(i = 0; i < (no_of_desc-1); i++)
 801d00e:	f04f 0300 	mov.w	r3, #0
 801d012:	61fb      	str	r3, [r7, #28]
 801d014:	e026      	b.n	801d064 <synopGMAC_setup_rx_desc_queue+0x128>
    {
      first_desc->buffer2  = (dma_addr_t) (temp_desc + i);
 801d016:	69fa      	ldr	r2, [r7, #28]
 801d018:	4613      	mov	r3, r2
 801d01a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d01e:	189b      	adds	r3, r3, r2
 801d020:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801d024:	693a      	ldr	r2, [r7, #16]
 801d026:	18d3      	adds	r3, r2, r3
 801d028:	461a      	mov	r2, r3
 801d02a:	69bb      	ldr	r3, [r7, #24]
 801d02c:	60da      	str	r2, [r3, #12]
      first_desc->data2    = (u32)second_desc;
 801d02e:	697a      	ldr	r2, [r7, #20]
 801d030:	69bb      	ldr	r3, [r7, #24]
 801d032:	625a      	str	r2, [r3, #36]	; 0x24

      second_desc->buffer2 = gmacdev->RxDescDma;
 801d034:	68fb      	ldr	r3, [r7, #12]
 801d036:	695a      	ldr	r2, [r3, #20]
 801d038:	697b      	ldr	r3, [r7, #20]
 801d03a:	60da      	str	r2, [r3, #12]
      second_desc->data2   = (u32)gmacdev->RxDesc;
 801d03c:	68fb      	ldr	r3, [r7, #12]
 801d03e:	69db      	ldr	r3, [r3, #28]
 801d040:	461a      	mov	r2, r3
 801d042:	697b      	ldr	r3, [r7, #20]
 801d044:	625a      	str	r2, [r3, #36]	; 0x24

      synopGMAC_rx_desc_init_chain(first_desc);
 801d046:	69b8      	ldr	r0, [r7, #24]
 801d048:	f7fe fbe2 	bl	801b810 <synopGMAC_rx_desc_init_chain>
      gmacdev->RxDescCount += 1;
 801d04c:	68fb      	ldr	r3, [r7, #12]
 801d04e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801d050:	f103 0201 	add.w	r2, r3, #1
 801d054:	68fb      	ldr	r3, [r7, #12]
 801d056:	629a      	str	r2, [r3, #40]	; 0x28
      first_desc = second_desc;
 801d058:	697b      	ldr	r3, [r7, #20]
 801d05a:	61bb      	str	r3, [r7, #24]
    gmacdev->RxDescCount = 1;

    //dma_addr  =   (dma_addr_t)Eth_RxDMADescList;
    temp_desc = (DmaDesc *)Eth_RxDMADescList;

    for(i = 0; i < (no_of_desc-1); i++)
 801d05c:	69fb      	ldr	r3, [r7, #28]
 801d05e:	f103 0301 	add.w	r3, r3, #1
 801d062:	61fb      	str	r3, [r7, #28]
 801d064:	69fa      	ldr	r2, [r7, #28]
 801d066:	68bb      	ldr	r3, [r7, #8]
 801d068:	f103 33ff 	add.w	r3, r3, #4294967295
 801d06c:	429a      	cmp	r2, r3
 801d06e:	d3d2      	bcc.n	801d016 <synopGMAC_setup_rx_desc_queue+0xda>
      synopGMAC_rx_desc_init_chain(first_desc);
      gmacdev->RxDescCount += 1;
      first_desc = second_desc;
    }

    synopGMAC_rx_desc_init_chain(first_desc);
 801d070:	69b8      	ldr	r0, [r7, #24]
 801d072:	f7fe fbcd 	bl	801b810 <synopGMAC_rx_desc_init_chain>
    TR("Rx===================================================================Rx\n");
  }

  gmacdev->RxNext = 0;
 801d076:	68fb      	ldr	r3, [r7, #12]
 801d078:	f04f 0200 	mov.w	r2, #0
 801d07c:	63da      	str	r2, [r3, #60]	; 0x3c
  gmacdev->RxBusy = 0;
 801d07e:	68fb      	ldr	r3, [r7, #12]
 801d080:	f04f 0200 	mov.w	r2, #0
 801d084:	639a      	str	r2, [r3, #56]	; 0x38
  gmacdev->RxNextDesc = gmacdev->RxDesc;
 801d086:	68fb      	ldr	r3, [r7, #12]
 801d088:	69da      	ldr	r2, [r3, #28]
 801d08a:	68fb      	ldr	r3, [r7, #12]
 801d08c:	64da      	str	r2, [r3, #76]	; 0x4c
  gmacdev->RxBusyDesc = gmacdev->RxDesc;
 801d08e:	68fb      	ldr	r3, [r7, #12]
 801d090:	69da      	ldr	r2, [r3, #28]
 801d092:	68fb      	ldr	r3, [r7, #12]
 801d094:	649a      	str	r2, [r3, #72]	; 0x48

  gmacdev->BusyRxDesc   = 0;
 801d096:	68fb      	ldr	r3, [r7, #12]
 801d098:	f04f 0200 	mov.w	r2, #0
 801d09c:	625a      	str	r2, [r3, #36]	; 0x24

  return -ESYNOPGMACNOERR;
 801d09e:	f04f 0300 	mov.w	r3, #0
}
 801d0a2:	4618      	mov	r0, r3
 801d0a4:	f107 0720 	add.w	r7, r7, #32
 801d0a8:	46bd      	mov	sp, r7
 801d0aa:	bd80      	pop	{r7, pc}

0801d0ac <synopGMAC_giveup_rx_desc_queue>:
  *
  * @return void.
  * \note No referece should be made to descriptors once this function is called. This function is invoked when the device is closed.
  */
void synopGMAC_giveup_rx_desc_queue (synopGMACdevice * gmacdev, u32 desc_mode)
{
 801d0ac:	b590      	push	{r4, r7, lr}
 801d0ae:	b091      	sub	sp, #68	; 0x44
 801d0b0:	af04      	add	r7, sp, #16
 801d0b2:	6078      	str	r0, [r7, #4]
 801d0b4:	6039      	str	r1, [r7, #0]
  s32 i;

  DmaDesc *first_desc = NULL;
 801d0b6:	f04f 0300 	mov.w	r3, #0
 801d0ba:	62bb      	str	r3, [r7, #40]	; 0x28
  u32 length1;
  u32 length2;
  u32 data1;
  u32 data2;

  if(desc_mode == RINGMODE)
 801d0bc:	683b      	ldr	r3, [r7, #0]
 801d0be:	2b01      	cmp	r3, #1
 801d0c0:	d12f      	bne.n	801d122 <synopGMAC_giveup_rx_desc_queue+0x76>
  {
    for(i = 0; i < gmacdev->RxDescCount; i++)
 801d0c2:	f04f 0300 	mov.w	r3, #0
 801d0c6:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d0c8:	e025      	b.n	801d116 <synopGMAC_giveup_rx_desc_queue+0x6a>
    {
      synopGMAC_get_desc_data(gmacdev->RxDesc + i, &status, &dma_addr1, &length1, &data1, &dma_addr2, &length2, &data2);
 801d0ca:	687b      	ldr	r3, [r7, #4]
 801d0cc:	69d9      	ldr	r1, [r3, #28]
 801d0ce:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d0d0:	4613      	mov	r3, r2
 801d0d2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d0d6:	189b      	adds	r3, r3, r2
 801d0d8:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801d0dc:	18c8      	adds	r0, r1, r3
 801d0de:	f107 0124 	add.w	r1, r7, #36	; 0x24
 801d0e2:	f107 0220 	add.w	r2, r7, #32
 801d0e6:	f107 0318 	add.w	r3, r7, #24
 801d0ea:	f107 0410 	add.w	r4, r7, #16
 801d0ee:	9400      	str	r4, [sp, #0]
 801d0f0:	f107 041c 	add.w	r4, r7, #28
 801d0f4:	9401      	str	r4, [sp, #4]
 801d0f6:	f107 0414 	add.w	r4, r7, #20
 801d0fa:	9402      	str	r4, [sp, #8]
 801d0fc:	f107 040c 	add.w	r4, r7, #12
 801d100:	9403      	str	r4, [sp, #12]
 801d102:	f7fe fe57 	bl	801bdb4 <synopGMAC_get_desc_data>

      if((length1 != 0) && (data1 != 0))
 801d106:	69bb      	ldr	r3, [r7, #24]
 801d108:	2b00      	cmp	r3, #0
      {
        //TR("(Ring mode) rx buffer1 %08x of size %d from %d rx descriptor is given back\n",data1, length1, i);
      }

      if((length2 != 0) && (data2 != 0))
 801d10a:	697b      	ldr	r3, [r7, #20]
 801d10c:	2b00      	cmp	r3, #0
  u32 data1;
  u32 data2;

  if(desc_mode == RINGMODE)
  {
    for(i = 0; i < gmacdev->RxDescCount; i++)
 801d10e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d110:	f103 0301 	add.w	r3, r3, #1
 801d114:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d116:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d118:	687b      	ldr	r3, [r7, #4]
 801d11a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801d11c:	429a      	cmp	r2, r3
 801d11e:	d3d4      	bcc.n	801d0ca <synopGMAC_giveup_rx_desc_queue+0x1e>
 801d120:	e028      	b.n	801d174 <synopGMAC_giveup_rx_desc_queue+0xc8>
  }
  else
  {
    TR("rx-------------------------------------------------------------------rx\n");

    first_desc          = gmacdev->RxDesc;
 801d122:	687b      	ldr	r3, [r7, #4]
 801d124:	69db      	ldr	r3, [r3, #28]
 801d126:	62bb      	str	r3, [r7, #40]	; 0x28
    //first_desc_dma_addr = gmacdev->RxDescDma;

    for(i = 0; i < gmacdev->RxDescCount; i++)
 801d128:	f04f 0300 	mov.w	r3, #0
 801d12c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d12e:	e01c      	b.n	801d16a <synopGMAC_giveup_rx_desc_queue+0xbe>
    {
      synopGMAC_get_desc_data(first_desc, &status, &dma_addr1, &length1, &data1, &dma_addr2, &length2, &data2);
 801d130:	f107 0124 	add.w	r1, r7, #36	; 0x24
 801d134:	f107 0220 	add.w	r2, r7, #32
 801d138:	f107 0318 	add.w	r3, r7, #24
 801d13c:	f107 0010 	add.w	r0, r7, #16
 801d140:	9000      	str	r0, [sp, #0]
 801d142:	f107 001c 	add.w	r0, r7, #28
 801d146:	9001      	str	r0, [sp, #4]
 801d148:	f107 0014 	add.w	r0, r7, #20
 801d14c:	9002      	str	r0, [sp, #8]
 801d14e:	f107 000c 	add.w	r0, r7, #12
 801d152:	9003      	str	r0, [sp, #12]
 801d154:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801d156:	f7fe fe2d 	bl	801bdb4 <synopGMAC_get_desc_data>
      //TR("%02d %08x %08x %08x %08x %08x %08x %08x\n",i,(u32)first_desc,first_desc->status,first_desc->length,first_desc->buffer1,first_desc->buffer2,first_desc->data1,first_desc->data2);

      if((length1 != 0) && (data1 != 0))
 801d15a:	69bb      	ldr	r3, [r7, #24]
 801d15c:	2b00      	cmp	r3, #0
      {
        //TR("(Chain mode) rx buffer1 %08x of size %d from %d rx descriptor is given back\n",data1, length1, i);
      }

      first_desc = (DmaDesc *)data2;
 801d15e:	68fb      	ldr	r3, [r7, #12]
 801d160:	62bb      	str	r3, [r7, #40]	; 0x28
    TR("rx-------------------------------------------------------------------rx\n");

    first_desc          = gmacdev->RxDesc;
    //first_desc_dma_addr = gmacdev->RxDescDma;

    for(i = 0; i < gmacdev->RxDescCount; i++)
 801d162:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d164:	f103 0301 	add.w	r3, r3, #1
 801d168:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d16a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d16c:	687b      	ldr	r3, [r7, #4]
 801d16e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801d170:	429a      	cmp	r2, r3
 801d172:	d3dd      	bcc.n	801d130 <synopGMAC_giveup_rx_desc_queue+0x84>
    }

    TR("rx-------------------------------------------------------------------rx\n");
  }

  gmacdev->RxDesc    = NULL;
 801d174:	687b      	ldr	r3, [r7, #4]
 801d176:	f04f 0200 	mov.w	r2, #0
 801d17a:	61da      	str	r2, [r3, #28]
  gmacdev->RxDescDma = 0;
 801d17c:	687b      	ldr	r3, [r7, #4]
 801d17e:	f04f 0200 	mov.w	r2, #0
 801d182:	615a      	str	r2, [r3, #20]
  return;
}
 801d184:	f107 0734 	add.w	r7, r7, #52	; 0x34
 801d188:	46bd      	mov	sp, r7
 801d18a:	bd90      	pop	{r4, r7, pc}

0801d18c <synopGMAC_setup_tx_desc_queue>:
  *  user should for gmacdev->TxDescCount to see how many descriptors are there in the chain. Should continue further
  *  only if the number of descriptors in the chain meets the requirements
  */

s32 synopGMAC_setup_tx_desc_queue(synopGMACdevice *gmacdev, u32 no_of_desc, u32 desc_mode)
{
 801d18c:	b580      	push	{r7, lr}
 801d18e:	b088      	sub	sp, #32
 801d190:	af00      	add	r7, sp, #0
 801d192:	60f8      	str	r0, [r7, #12]
 801d194:	60b9      	str	r1, [r7, #8]
 801d196:	607a      	str	r2, [r7, #4]
  /* <<<DD_ETH_PORT_11>>> */
  s32 i;

  DmaDesc *first_desc = NULL;
 801d198:	f04f 0300 	mov.w	r3, #0
 801d19c:	61bb      	str	r3, [r7, #24]
  DmaDesc *second_desc = NULL;
 801d19e:	f04f 0300 	mov.w	r3, #0
 801d1a2:	617b      	str	r3, [r7, #20]

  DmaDesc *temp_desc = NULL;
 801d1a4:	f04f 0300 	mov.w	r3, #0
 801d1a8:	613b      	str	r3, [r7, #16]
  //dma_addr_t dma_addr;

  gmacdev->TxDescCount = 0;
 801d1aa:	68fb      	ldr	r3, [r7, #12]
 801d1ac:	f04f 0200 	mov.w	r2, #0
 801d1b0:	62da      	str	r2, [r3, #44]	; 0x2c

  if(desc_mode == RINGMODE)
 801d1b2:	687b      	ldr	r3, [r7, #4]
 801d1b4:	2b01      	cmp	r3, #1
 801d1b6:	d134      	bne.n	801d222 <synopGMAC_setup_tx_desc_queue+0x96>
  {
    gmacdev->TxDescCount = no_of_desc;
 801d1b8:	68fb      	ldr	r3, [r7, #12]
 801d1ba:	68ba      	ldr	r2, [r7, #8]
 801d1bc:	62da      	str	r2, [r3, #44]	; 0x2c
    gmacdev->TxDesc      = Eth_TxDMADescList;
 801d1be:	68fa      	ldr	r2, [r7, #12]
 801d1c0:	f242 4390 	movw	r3, #9360	; 0x2490
 801d1c4:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801d1c8:	6193      	str	r3, [r2, #24]
    gmacdev->TxDescDma   = (unsigned long)Eth_TxDMADescList;
 801d1ca:	f242 4390 	movw	r3, #9360	; 0x2490
 801d1ce:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801d1d2:	68fa      	ldr	r2, [r7, #12]
 801d1d4:	6113      	str	r3, [r2, #16]

    for(i = 0; i < gmacdev->TxDescCount; i++)
 801d1d6:	f04f 0300 	mov.w	r3, #0
 801d1da:	61fb      	str	r3, [r7, #28]
 801d1dc:	e01b      	b.n	801d216 <synopGMAC_setup_tx_desc_queue+0x8a>
    {
      synopGMAC_tx_desc_init_ring(gmacdev->TxDesc + i, i == gmacdev->TxDescCount-1);
 801d1de:	68fb      	ldr	r3, [r7, #12]
 801d1e0:	6999      	ldr	r1, [r3, #24]
 801d1e2:	69fa      	ldr	r2, [r7, #28]
 801d1e4:	4613      	mov	r3, r2
 801d1e6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d1ea:	189b      	adds	r3, r3, r2
 801d1ec:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801d1f0:	18ca      	adds	r2, r1, r3
 801d1f2:	69f9      	ldr	r1, [r7, #28]
 801d1f4:	68fb      	ldr	r3, [r7, #12]
 801d1f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d1f8:	f103 33ff 	add.w	r3, r3, #4294967295
 801d1fc:	4299      	cmp	r1, r3
 801d1fe:	bf14      	ite	ne
 801d200:	2300      	movne	r3, #0
 801d202:	2301      	moveq	r3, #1
 801d204:	b2db      	uxtb	r3, r3
 801d206:	4610      	mov	r0, r2
 801d208:	4619      	mov	r1, r3
 801d20a:	f7fe fae7 	bl	801b7dc <synopGMAC_tx_desc_init_ring>
  {
    gmacdev->TxDescCount = no_of_desc;
    gmacdev->TxDesc      = Eth_TxDMADescList;
    gmacdev->TxDescDma   = (unsigned long)Eth_TxDMADescList;

    for(i = 0; i < gmacdev->TxDescCount; i++)
 801d20e:	69fb      	ldr	r3, [r7, #28]
 801d210:	f103 0301 	add.w	r3, r3, #1
 801d214:	61fb      	str	r3, [r7, #28]
 801d216:	69fa      	ldr	r2, [r7, #28]
 801d218:	68fb      	ldr	r3, [r7, #12]
 801d21a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d21c:	429a      	cmp	r2, r3
 801d21e:	d3de      	bcc.n	801d1de <synopGMAC_setup_tx_desc_queue+0x52>
 801d220:	e051      	b.n	801d2c6 <synopGMAC_setup_tx_desc_queue+0x13a>
      synopGMAC_tx_desc_init_ring(gmacdev->TxDesc + i, i == gmacdev->TxDescCount-1);
    }
  }
  else
  {
    gmacdev->TxDesc       = Eth_TxDMADescList;
 801d222:	68fa      	ldr	r2, [r7, #12]
 801d224:	f242 4390 	movw	r3, #9360	; 0x2490
 801d228:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801d22c:	6193      	str	r3, [r2, #24]
    gmacdev->TxDescDma    = (dma_addr_t)Eth_TxDMADescList;
 801d22e:	f242 4390 	movw	r3, #9360	; 0x2490
 801d232:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801d236:	68fa      	ldr	r2, [r7, #12]
 801d238:	6113      	str	r3, [r2, #16]

    TR("Tx===================================================================Tx\n");

    first_desc->buffer2   = gmacdev->TxDescDma;
 801d23a:	68fb      	ldr	r3, [r7, #12]
 801d23c:	691a      	ldr	r2, [r3, #16]
 801d23e:	69bb      	ldr	r3, [r7, #24]
 801d240:	60da      	str	r2, [r3, #12]
    first_desc->data2     = (u32)gmacdev->TxDesc;
 801d242:	68fb      	ldr	r3, [r7, #12]
 801d244:	699b      	ldr	r3, [r3, #24]
 801d246:	461a      	mov	r2, r3
 801d248:	69bb      	ldr	r3, [r7, #24]
 801d24a:	625a      	str	r2, [r3, #36]	; 0x24

    gmacdev->TxDescCount = 1;
 801d24c:	68fb      	ldr	r3, [r7, #12]
 801d24e:	f04f 0201 	mov.w	r2, #1
 801d252:	62da      	str	r2, [r3, #44]	; 0x2c

    //dma_addr  = (dma_addr_t)Eth_TxDMADescList;
    temp_desc = (DmaDesc *)Eth_TxDMADescList;
 801d254:	f242 4390 	movw	r3, #9360	; 0x2490
 801d258:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801d25c:	613b      	str	r3, [r7, #16]

    for(i = 0; i < (no_of_desc-1); i++)
 801d25e:	f04f 0300 	mov.w	r3, #0
 801d262:	61fb      	str	r3, [r7, #28]
 801d264:	e026      	b.n	801d2b4 <synopGMAC_setup_tx_desc_queue+0x128>
    {
      first_desc->buffer2 =  (dma_addr_t) (temp_desc + i);
 801d266:	69fa      	ldr	r2, [r7, #28]
 801d268:	4613      	mov	r3, r2
 801d26a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d26e:	189b      	adds	r3, r3, r2
 801d270:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801d274:	693a      	ldr	r2, [r7, #16]
 801d276:	18d3      	adds	r3, r2, r3
 801d278:	461a      	mov	r2, r3
 801d27a:	69bb      	ldr	r3, [r7, #24]
 801d27c:	60da      	str	r2, [r3, #12]
      first_desc->data2    = (u32)second_desc;
 801d27e:	697a      	ldr	r2, [r7, #20]
 801d280:	69bb      	ldr	r3, [r7, #24]
 801d282:	625a      	str	r2, [r3, #36]	; 0x24

      second_desc->buffer2 = gmacdev->TxDescDma;
 801d284:	68fb      	ldr	r3, [r7, #12]
 801d286:	691a      	ldr	r2, [r3, #16]
 801d288:	697b      	ldr	r3, [r7, #20]
 801d28a:	60da      	str	r2, [r3, #12]
      second_desc->data2   = (u32)gmacdev->TxDesc;
 801d28c:	68fb      	ldr	r3, [r7, #12]
 801d28e:	699b      	ldr	r3, [r3, #24]
 801d290:	461a      	mov	r2, r3
 801d292:	697b      	ldr	r3, [r7, #20]
 801d294:	625a      	str	r2, [r3, #36]	; 0x24

      synopGMAC_tx_desc_init_chain(first_desc);
 801d296:	69b8      	ldr	r0, [r7, #24]
 801d298:	f7fe fad4 	bl	801b844 <synopGMAC_tx_desc_init_chain>

      gmacdev->TxDescCount += 1;
 801d29c:	68fb      	ldr	r3, [r7, #12]
 801d29e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d2a0:	f103 0201 	add.w	r2, r3, #1
 801d2a4:	68fb      	ldr	r3, [r7, #12]
 801d2a6:	62da      	str	r2, [r3, #44]	; 0x2c
      first_desc = second_desc;
 801d2a8:	697b      	ldr	r3, [r7, #20]
 801d2aa:	61bb      	str	r3, [r7, #24]
    gmacdev->TxDescCount = 1;

    //dma_addr  = (dma_addr_t)Eth_TxDMADescList;
    temp_desc = (DmaDesc *)Eth_TxDMADescList;

    for(i = 0; i < (no_of_desc-1); i++)
 801d2ac:	69fb      	ldr	r3, [r7, #28]
 801d2ae:	f103 0301 	add.w	r3, r3, #1
 801d2b2:	61fb      	str	r3, [r7, #28]
 801d2b4:	69fa      	ldr	r2, [r7, #28]
 801d2b6:	68bb      	ldr	r3, [r7, #8]
 801d2b8:	f103 33ff 	add.w	r3, r3, #4294967295
 801d2bc:	429a      	cmp	r2, r3
 801d2be:	d3d2      	bcc.n	801d266 <synopGMAC_setup_tx_desc_queue+0xda>

      gmacdev->TxDescCount += 1;
      first_desc = second_desc;
    }

    synopGMAC_tx_desc_init_chain(first_desc);
 801d2c0:	69b8      	ldr	r0, [r7, #24]
 801d2c2:	f7fe fabf 	bl	801b844 <synopGMAC_tx_desc_init_chain>
    TR("Tx===================================================================Tx\n");
  }

  gmacdev->TxNext = 0;
 801d2c6:	68fb      	ldr	r3, [r7, #12]
 801d2c8:	f04f 0200 	mov.w	r2, #0
 801d2cc:	635a      	str	r2, [r3, #52]	; 0x34
  gmacdev->TxBusy = 0;
 801d2ce:	68fb      	ldr	r3, [r7, #12]
 801d2d0:	f04f 0200 	mov.w	r2, #0
 801d2d4:	631a      	str	r2, [r3, #48]	; 0x30
  gmacdev->TxNextDesc = gmacdev->TxDesc;
 801d2d6:	68fb      	ldr	r3, [r7, #12]
 801d2d8:	699a      	ldr	r2, [r3, #24]
 801d2da:	68fb      	ldr	r3, [r7, #12]
 801d2dc:	645a      	str	r2, [r3, #68]	; 0x44
  gmacdev->TxBusyDesc = gmacdev->TxDesc;
 801d2de:	68fb      	ldr	r3, [r7, #12]
 801d2e0:	699a      	ldr	r2, [r3, #24]
 801d2e2:	68fb      	ldr	r3, [r7, #12]
 801d2e4:	641a      	str	r2, [r3, #64]	; 0x40
  gmacdev->BusyTxDesc  = 0;
 801d2e6:	68fb      	ldr	r3, [r7, #12]
 801d2e8:	f04f 0200 	mov.w	r2, #0
 801d2ec:	621a      	str	r2, [r3, #32]

  return -ESYNOPGMACNOERR;
 801d2ee:	f04f 0300 	mov.w	r3, #0
}
 801d2f2:	4618      	mov	r0, r3
 801d2f4:	f107 0720 	add.w	r7, r7, #32
 801d2f8:	46bd      	mov	sp, r7
 801d2fa:	bd80      	pop	{r7, pc}

0801d2fc <synopGMAC_giveup_tx_desc_queue>:
  *
  * @return void
  * \note No reference should be made to descriptors once this function is called. This function is invoked when the device is closed.
  */
void synopGMAC_giveup_tx_desc_queue(synopGMACdevice *gmacdev, u32 desc_mode)
{
 801d2fc:	b590      	push	{r4, r7, lr}
 801d2fe:	b091      	sub	sp, #68	; 0x44
 801d300:	af04      	add	r7, sp, #16
 801d302:	6078      	str	r0, [r7, #4]
 801d304:	6039      	str	r1, [r7, #0]
  s32 i;

  DmaDesc *first_desc = NULL;
 801d306:	f04f 0300 	mov.w	r3, #0
 801d30a:	62bb      	str	r3, [r7, #40]	; 0x28
  u32 length1;
  u32 length2;
  u32 data1;
  u32 data2;

  if(desc_mode == RINGMODE)
 801d30c:	683b      	ldr	r3, [r7, #0]
 801d30e:	2b01      	cmp	r3, #1
 801d310:	d12f      	bne.n	801d372 <synopGMAC_giveup_tx_desc_queue+0x76>
  {
    for(i =0; i < gmacdev -> TxDescCount; i++)
 801d312:	f04f 0300 	mov.w	r3, #0
 801d316:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d318:	e025      	b.n	801d366 <synopGMAC_giveup_tx_desc_queue+0x6a>
    {
      synopGMAC_get_desc_data(gmacdev->TxDesc + i,&status, &dma_addr1, &length1, &data1, &dma_addr2, &length2, &data2);
 801d31a:	687b      	ldr	r3, [r7, #4]
 801d31c:	6999      	ldr	r1, [r3, #24]
 801d31e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d320:	4613      	mov	r3, r2
 801d322:	ea4f 0383 	mov.w	r3, r3, lsl #2
 801d326:	189b      	adds	r3, r3, r2
 801d328:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801d32c:	18c8      	adds	r0, r1, r3
 801d32e:	f107 0124 	add.w	r1, r7, #36	; 0x24
 801d332:	f107 0220 	add.w	r2, r7, #32
 801d336:	f107 0318 	add.w	r3, r7, #24
 801d33a:	f107 0410 	add.w	r4, r7, #16
 801d33e:	9400      	str	r4, [sp, #0]
 801d340:	f107 041c 	add.w	r4, r7, #28
 801d344:	9401      	str	r4, [sp, #4]
 801d346:	f107 0414 	add.w	r4, r7, #20
 801d34a:	9402      	str	r4, [sp, #8]
 801d34c:	f107 040c 	add.w	r4, r7, #12
 801d350:	9403      	str	r4, [sp, #12]
 801d352:	f7fe fd2f 	bl	801bdb4 <synopGMAC_get_desc_data>

      if((length1 != 0) && (data1 != 0))
 801d356:	69bb      	ldr	r3, [r7, #24]
 801d358:	2b00      	cmp	r3, #0
      {
        //TR("(Ring mode) tx buffer1 %08x of size %d from %d rx descriptor is given back\n",data1, length1, i);
      }

      if((length2 != 0) && (data2 != 0))
 801d35a:	697b      	ldr	r3, [r7, #20]
 801d35c:	2b00      	cmp	r3, #0
  u32 data1;
  u32 data2;

  if(desc_mode == RINGMODE)
  {
    for(i =0; i < gmacdev -> TxDescCount; i++)
 801d35e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d360:	f103 0301 	add.w	r3, r3, #1
 801d364:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d366:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d368:	687b      	ldr	r3, [r7, #4]
 801d36a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d36c:	429a      	cmp	r2, r3
 801d36e:	d3d4      	bcc.n	801d31a <synopGMAC_giveup_tx_desc_queue+0x1e>
 801d370:	e028      	b.n	801d3c4 <synopGMAC_giveup_tx_desc_queue+0xc8>
  }
  else
  {
    TR("tx-------------------------------------------------------------------tx\n");

    first_desc          = gmacdev->TxDesc;
 801d372:	687b      	ldr	r3, [r7, #4]
 801d374:	699b      	ldr	r3, [r3, #24]
 801d376:	62bb      	str	r3, [r7, #40]	; 0x28
    //first_desc_dma_addr = gmacdev->TxDescDma;

    for(i =0; i < gmacdev -> TxDescCount; i++)
 801d378:	f04f 0300 	mov.w	r3, #0
 801d37c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d37e:	e01c      	b.n	801d3ba <synopGMAC_giveup_tx_desc_queue+0xbe>
    {
      synopGMAC_get_desc_data(first_desc, &status, &dma_addr1, &length1, &data1, &dma_addr2, &length2, &data2);
 801d380:	f107 0124 	add.w	r1, r7, #36	; 0x24
 801d384:	f107 0220 	add.w	r2, r7, #32
 801d388:	f107 0318 	add.w	r3, r7, #24
 801d38c:	f107 0010 	add.w	r0, r7, #16
 801d390:	9000      	str	r0, [sp, #0]
 801d392:	f107 001c 	add.w	r0, r7, #28
 801d396:	9001      	str	r0, [sp, #4]
 801d398:	f107 0014 	add.w	r0, r7, #20
 801d39c:	9002      	str	r0, [sp, #8]
 801d39e:	f107 000c 	add.w	r0, r7, #12
 801d3a2:	9003      	str	r0, [sp, #12]
 801d3a4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 801d3a6:	f7fe fd05 	bl	801bdb4 <synopGMAC_get_desc_data>
      // TR("%02d %08x %08x %08x %08x %08x %08x %08x\n",i,(u32)first_desc,first_desc->status,first_desc->length,first_desc->buffer1,first_desc->buffer2,first_desc->data1,first_desc->data2);

      if((length1 != 0) && (data1 != 0))
 801d3aa:	69bb      	ldr	r3, [r7, #24]
 801d3ac:	2b00      	cmp	r3, #0
        // TR("(Chain mode) tx buffer1 %08x of size %d from %d rx descriptor is given back\n",data1, length1, i);
      }

      // TR("Memory allocated %08x for Tx Descriptor (chain) at  %d is given back\n",data2,i);

      first_desc = (DmaDesc *)data2;
 801d3ae:	68fb      	ldr	r3, [r7, #12]
 801d3b0:	62bb      	str	r3, [r7, #40]	; 0x28
    TR("tx-------------------------------------------------------------------tx\n");

    first_desc          = gmacdev->TxDesc;
    //first_desc_dma_addr = gmacdev->TxDescDma;

    for(i =0; i < gmacdev -> TxDescCount; i++)
 801d3b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d3b4:	f103 0301 	add.w	r3, r3, #1
 801d3b8:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d3ba:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d3bc:	687b      	ldr	r3, [r7, #4]
 801d3be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801d3c0:	429a      	cmp	r2, r3
 801d3c2:	d3dd      	bcc.n	801d380 <synopGMAC_giveup_tx_desc_queue+0x84>
      //first_desc_dma_addr = dma_addr2;
    }
    TR("tx-------------------------------------------------------------------tx\n");
  }

  gmacdev->TxDesc    = NULL;
 801d3c4:	687b      	ldr	r3, [r7, #4]
 801d3c6:	f04f 0200 	mov.w	r2, #0
 801d3ca:	619a      	str	r2, [r3, #24]
  gmacdev->TxDescDma = 0;
 801d3cc:	687b      	ldr	r3, [r7, #4]
 801d3ce:	f04f 0200 	mov.w	r2, #0
 801d3d2:	611a      	str	r2, [r3, #16]
  return;
}
 801d3d4:	f107 0734 	add.w	r7, r7, #52	; 0x34
 801d3d8:	46bd      	mov	sp, r7
 801d3da:	bd90      	pop	{r4, r7, pc}

0801d3dc <synop_handle_transmit_over>:
 * @return void.
 * \note This function runs in interrupt context
 */

void synop_handle_transmit_over(synopGMACdevice * synopGMACdev)
{
 801d3dc:	b590      	push	{r4, r7, lr}
 801d3de:	b097      	sub	sp, #92	; 0x5c
 801d3e0:	af08      	add	r7, sp, #32
 801d3e2:	6078      	str	r0, [r7, #4]
  u32 ext_status;
  u32 time_stamp_high;
  u32 time_stamp_low;
#endif

  if(synopGMACdev == NULL)
 801d3e4:	687b      	ldr	r3, [r7, #4]
 801d3e6:	2b00      	cmp	r3, #0
 801d3e8:	d063      	beq.n	801d4b2 <synop_handle_transmit_over+0xd6>
    /*Handle the transmit Descriptors*/
  do
  {

#ifdef ENH_DESC_8W
    desc_index = synopGMAC_get_tx_qptr(synopGMACdev, &status, &dma_addr1, &length1, &data1, &dma_addr2, &length2, &data2,&ext_status,&time_stamp_high,&time_stamp_low);
 801d3ea:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801d3ee:	f107 021c 	add.w	r2, r7, #28
 801d3f2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801d3f6:	f107 0030 	add.w	r0, r7, #48	; 0x30
 801d3fa:	9000      	str	r0, [sp, #0]
 801d3fc:	f107 0018 	add.w	r0, r7, #24
 801d400:	9001      	str	r0, [sp, #4]
 801d402:	f107 0020 	add.w	r0, r7, #32
 801d406:	9002      	str	r0, [sp, #8]
 801d408:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 801d40c:	9003      	str	r0, [sp, #12]
 801d40e:	f107 0014 	add.w	r0, r7, #20
 801d412:	9004      	str	r0, [sp, #16]
 801d414:	f107 0010 	add.w	r0, r7, #16
 801d418:	9005      	str	r0, [sp, #20]
 801d41a:	f107 000c 	add.w	r0, r7, #12
 801d41e:	9006      	str	r0, [sp, #24]
 801d420:	6878      	ldr	r0, [r7, #4]
 801d422:	f7fe fd11 	bl	801be48 <synopGMAC_get_tx_qptr>
 801d426:	6378      	str	r0, [r7, #52]	; 0x34
        //synopGMAC_TS_read_timestamp_higher_val(synopGMACdev, &time_stamp_higher);
#else
    desc_index = synopGMAC_get_tx_qptr(synopGMACdev, &status, &dma_addr1, &length1, &data1, &dma_addr2, &length2, &data2);
#endif
    //desc_index = synopGMAC_get_tx_qptr(gmacdev, &status, &dma_addr, &length, &data1);
    if(desc_index >= 0 && data1 != 0)
 801d428:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d42a:	2b00      	cmp	r3, #0
 801d42c:	db34      	blt.n	801d498 <synop_handle_transmit_over+0xbc>
 801d42e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d430:	2b00      	cmp	r3, #0
 801d432:	d031      	beq.n	801d498 <synop_handle_transmit_over+0xbc>
      {
        TR("Harware Failed to Insert Payload Checksum\n");
      }
#endif

      if(synopGMAC_is_desc_valid(status))
 801d434:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d436:	4618      	mov	r0, r3
 801d438:	f7fe fb46 	bl	801bac8 <synopGMAC_is_desc_valid>
 801d43c:	4603      	mov	r3, r0
 801d43e:	2b00      	cmp	r3, #0
 801d440:	d00c      	beq.n	801d45c <synop_handle_transmit_over+0x80>
      {
    	synopGMACdev->NetStatistics.TxBytes += length1;
 801d442:	687b      	ldr	r3, [r7, #4]
 801d444:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 801d446:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d448:	18d2      	adds	r2, r2, r3
 801d44a:	687b      	ldr	r3, [r7, #4]
 801d44c:	65da      	str	r2, [r3, #92]	; 0x5c
    	synopGMACdev->NetStatistics.TxPackets++;
 801d44e:	687b      	ldr	r3, [r7, #4]
 801d450:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801d452:	f103 0201 	add.w	r2, r3, #1
 801d456:	687b      	ldr	r3, [r7, #4]
 801d458:	655a      	str	r2, [r3, #84]	; 0x54
 801d45a:	e01d      	b.n	801d498 <synop_handle_transmit_over+0xbc>
      }
      else
      {
        synopGMACdev->NetStatistics.TxErrors++;
 801d45c:	687b      	ldr	r3, [r7, #4]
 801d45e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 801d460:	f103 0201 	add.w	r2, r3, #1
 801d464:	687b      	ldr	r3, [r7, #4]
 801d466:	665a      	str	r2, [r3, #100]	; 0x64
        synopGMACdev->NetStatistics.TxAbortedErrors += synopGMAC_is_tx_aborted(status);
 801d468:	687b      	ldr	r3, [r7, #4]
 801d46a:	f8d3 4090 	ldr.w	r4, [r3, #144]	; 0x90
 801d46e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d470:	4618      	mov	r0, r3
 801d472:	f7fe fb7d 	bl	801bb70 <synopGMAC_is_tx_aborted>
 801d476:	4603      	mov	r3, r0
 801d478:	18e2      	adds	r2, r4, r3
 801d47a:	687b      	ldr	r3, [r7, #4]
 801d47c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        synopGMACdev->NetStatistics.TxCarrierErrors += synopGMAC_is_tx_carrier_error(status);
 801d480:	687b      	ldr	r3, [r7, #4]
 801d482:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
 801d486:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d488:	4618      	mov	r0, r3
 801d48a:	f7fe fb8d 	bl	801bba8 <synopGMAC_is_tx_carrier_error>
 801d48e:	4603      	mov	r3, r0
 801d490:	18e2      	adds	r2, r4, r3
 801d492:	687b      	ldr	r3, [r7, #4]
 801d494:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      }
    }
    synopGMACdev->NetStatistics.Collisions += synopGMAC_get_tx_collision_count(status);
 801d498:	687b      	ldr	r3, [r7, #4]
 801d49a:	6f5c      	ldr	r4, [r3, #116]	; 0x74
 801d49c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d49e:	4618      	mov	r0, r3
 801d4a0:	f7fe fb9e 	bl	801bbe0 <synopGMAC_get_tx_collision_count>
 801d4a4:	4603      	mov	r3, r0
 801d4a6:	18e2      	adds	r2, r4, r3
 801d4a8:	687b      	ldr	r3, [r7, #4]
 801d4aa:	675a      	str	r2, [r3, #116]	; 0x74
  } while(desc_index >= 0);
 801d4ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d4ae:	2b00      	cmp	r3, #0
 801d4b0:	da9b      	bge.n	801d3ea <synop_handle_transmit_over+0xe>
}
 801d4b2:	f107 073c 	add.w	r7, r7, #60	; 0x3c
 801d4b6:	46bd      	mov	sp, r7
 801d4b8:	bd90      	pop	{r4, r7, pc}
 801d4ba:	bf00      	nop

0801d4bc <is_valid_ether_addr>:
 * @param[in] MacAddr Mac address
 *
 * @return 1 if Ethernet MAC is valid, otherwise 0
 */
static __INLINE int is_valid_ether_addr(const unsigned char *MacAddr)
{
 801d4bc:	b480      	push	{r7}
 801d4be:	b083      	sub	sp, #12
 801d4c0:	af00      	add	r7, sp, #0
 801d4c2:	6078      	str	r0, [r7, #4]
  /* <<<DD_ETH_PORT_13>>> */
  return (! (0x01 & MacAddr[0]) &&
 801d4c4:	687b      	ldr	r3, [r7, #4]
 801d4c6:	781b      	ldrb	r3, [r3, #0]
 801d4c8:	f003 0301 	and.w	r3, r3, #1
 801d4cc:	b2db      	uxtb	r3, r3
 801d4ce:	2b00      	cmp	r3, #0
 801d4d0:	d124      	bne.n	801d51c <is_valid_ether_addr+0x60>
		   (MacAddr[0] | MacAddr[1] | MacAddr[2] | MacAddr[3] |
 801d4d2:	687b      	ldr	r3, [r7, #4]
 801d4d4:	781a      	ldrb	r2, [r3, #0]
 801d4d6:	687b      	ldr	r3, [r7, #4]
 801d4d8:	f103 0301 	add.w	r3, r3, #1
 801d4dc:	781b      	ldrb	r3, [r3, #0]
 * @return 1 if Ethernet MAC is valid, otherwise 0
 */
static __INLINE int is_valid_ether_addr(const unsigned char *MacAddr)
{
  /* <<<DD_ETH_PORT_13>>> */
  return (! (0x01 & MacAddr[0]) &&
 801d4de:	4313      	orrs	r3, r2
 801d4e0:	b2da      	uxtb	r2, r3
		   (MacAddr[0] | MacAddr[1] | MacAddr[2] | MacAddr[3] |
 801d4e2:	687b      	ldr	r3, [r7, #4]
 801d4e4:	f103 0302 	add.w	r3, r3, #2
 801d4e8:	781b      	ldrb	r3, [r3, #0]
 * @return 1 if Ethernet MAC is valid, otherwise 0
 */
static __INLINE int is_valid_ether_addr(const unsigned char *MacAddr)
{
  /* <<<DD_ETH_PORT_13>>> */
  return (! (0x01 & MacAddr[0]) &&
 801d4ea:	4313      	orrs	r3, r2
 801d4ec:	b2da      	uxtb	r2, r3
		   (MacAddr[0] | MacAddr[1] | MacAddr[2] | MacAddr[3] |
 801d4ee:	687b      	ldr	r3, [r7, #4]
 801d4f0:	f103 0303 	add.w	r3, r3, #3
 801d4f4:	781b      	ldrb	r3, [r3, #0]
 * @return 1 if Ethernet MAC is valid, otherwise 0
 */
static __INLINE int is_valid_ether_addr(const unsigned char *MacAddr)
{
  /* <<<DD_ETH_PORT_13>>> */
  return (! (0x01 & MacAddr[0]) &&
 801d4f6:	4313      	orrs	r3, r2
 801d4f8:	b2da      	uxtb	r2, r3
		   (MacAddr[0] | MacAddr[1] | MacAddr[2] | MacAddr[3] |
		    MacAddr[4] | MacAddr[5]));
 801d4fa:	687b      	ldr	r3, [r7, #4]
 801d4fc:	f103 0304 	add.w	r3, r3, #4
 801d500:	781b      	ldrb	r3, [r3, #0]
 * @return 1 if Ethernet MAC is valid, otherwise 0
 */
static __INLINE int is_valid_ether_addr(const unsigned char *MacAddr)
{
  /* <<<DD_ETH_PORT_13>>> */
  return (! (0x01 & MacAddr[0]) &&
 801d502:	4313      	orrs	r3, r2
 801d504:	b2da      	uxtb	r2, r3
		   (MacAddr[0] | MacAddr[1] | MacAddr[2] | MacAddr[3] |
		    MacAddr[4] | MacAddr[5]));
 801d506:	687b      	ldr	r3, [r7, #4]
 801d508:	f103 0305 	add.w	r3, r3, #5
 801d50c:	781b      	ldrb	r3, [r3, #0]
 * @return 1 if Ethernet MAC is valid, otherwise 0
 */
static __INLINE int is_valid_ether_addr(const unsigned char *MacAddr)
{
  /* <<<DD_ETH_PORT_13>>> */
  return (! (0x01 & MacAddr[0]) &&
 801d50e:	4313      	orrs	r3, r2
 801d510:	b2db      	uxtb	r3, r3
 801d512:	2b00      	cmp	r3, #0
 801d514:	d002      	beq.n	801d51c <is_valid_ether_addr+0x60>
 801d516:	f04f 0301 	mov.w	r3, #1
 801d51a:	e001      	b.n	801d520 <is_valid_ether_addr+0x64>
 801d51c:	f04f 0300 	mov.w	r3, #0
		   (MacAddr[0] | MacAddr[1] | MacAddr[2] | MacAddr[3] |
		    MacAddr[4] | MacAddr[5]));
}
 801d520:	4618      	mov	r0, r3
 801d522:	f107 070c 	add.w	r7, r7, #12
 801d526:	46bd      	mov	sp, r7
 801d528:	bc80      	pop	{r7}
 801d52a:	4770      	bx	lr

0801d52c <synopGMAC_set_mac_address>:
 * @param[in] synopGMACdev pointer to GMAC Device structure.
 * @param[in] macaddr pointer to an address structure.
 * \return Returns 0 on success Errorcode on failure.
 */
s32 synopGMAC_set_mac_address(synopGMACdevice *synopGMACdev, void * macaddr)
{
 801d52c:	b580      	push	{r7, lr}
 801d52e:	b082      	sub	sp, #8
 801d530:	af00      	add	r7, sp, #0
 801d532:	6078      	str	r0, [r7, #4]
 801d534:	6039      	str	r1, [r7, #0]
  if(synopGMACdev == NULL)
 801d536:	687b      	ldr	r3, [r7, #4]
 801d538:	2b00      	cmp	r3, #0
 801d53a:	d102      	bne.n	801d542 <synopGMAC_set_mac_address+0x16>
  {
    DBG002_ERROR(APP_GID, ETH_NULL_PARAM, 0, NULL);
    return ETH_NULL_PARAM;
 801d53c:	f04f 0309 	mov.w	r3, #9
 801d540:	e01c      	b.n	801d57c <synopGMAC_set_mac_address+0x50>
  }

  /* Check if the Ethernet Address is valid */
  if(!is_valid_ether_addr((unsigned char*)macaddr))
 801d542:	6838      	ldr	r0, [r7, #0]
 801d544:	f7ff ffba 	bl	801d4bc <is_valid_ether_addr>
 801d548:	4603      	mov	r3, r0
 801d54a:	2b00      	cmp	r3, #0
 801d54c:	d102      	bne.n	801d554 <synopGMAC_set_mac_address+0x28>
  {
	  DBG002_ERROR(APP_GID, ETH_INVALID_MAC_ADDR, 0, NULL);
      return ETH_INVALID_MAC_ADDR;
 801d54e:	f04f 0308 	mov.w	r3, #8
 801d552:	e013      	b.n	801d57c <synopGMAC_set_mac_address+0x50>
  }

  synopGMAC_set_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low,
 801d554:	6878      	ldr	r0, [r7, #4]
 801d556:	f04f 0140 	mov.w	r1, #64	; 0x40
 801d55a:	f04f 0244 	mov.w	r2, #68	; 0x44
 801d55e:	683b      	ldr	r3, [r7, #0]
 801d560:	f7fe f85a 	bl	801b618 <synopGMAC_set_mac_addr>
		  (unsigned char *)macaddr);

  synopGMAC_get_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low,
		  (u8 *)(synopGMACdev->MacAddress));
 801d564:	687b      	ldr	r3, [r7, #4]
 801d566:	f103 03bc 	add.w	r3, r3, #188	; 0xbc
  }

  synopGMAC_set_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low,
		  (unsigned char *)macaddr);

  synopGMAC_get_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low,
 801d56a:	6878      	ldr	r0, [r7, #4]
 801d56c:	f04f 0140 	mov.w	r1, #64	; 0x40
 801d570:	f04f 0244 	mov.w	r2, #68	; 0x44
 801d574:	f7fe f890 	bl	801b698 <synopGMAC_get_mac_addr>
		  (u8 *)(synopGMACdev->MacAddress));

  return DAVEApp_SUCCESS;
 801d578:	f04f 0300 	mov.w	r3, #0
}
 801d57c:	4618      	mov	r0, r3
 801d57e:	f107 0708 	add.w	r7, r7, #8
 801d582:	46bd      	mov	sp, r7
 801d584:	bd80      	pop	{r7, pc}
 801d586:	bf00      	nop

0801d588 <synopGMAC_change_mtu>:
 * @param[in] pointer to synopGMACdevice structure.
 * @param[in] New value for maximum frame size.
 * \return Returns 0 on success Errorcode on failure.
 */
s32 synopGMAC_change_mtu(synopGMACdevice * synopGMACdev, s32 newmtu)
{
 801d588:	b480      	push	{r7}
 801d58a:	b083      	sub	sp, #12
 801d58c:	af00      	add	r7, sp, #0
 801d58e:	6078      	str	r0, [r7, #4]
 801d590:	6039      	str	r1, [r7, #0]
  //Todo Function not yet implemented.
  return 0;
 801d592:	f04f 0300 	mov.w	r3, #0
}
 801d596:	4618      	mov	r0, r3
 801d598:	f107 070c 	add.w	r7, r7, #12
 801d59c:	46bd      	mov	sp, r7
 801d59e:	bc80      	pop	{r7}
 801d5a0:	4770      	bx	lr
 801d5a2:	bf00      	nop

0801d5a4 <synopGMACReadReg>:
 * @param[in] pointer to the base of register map
 * @param[in] Offset from the base
 * \return  Returns the register contents
 */
u32 synopGMACReadReg(u32 *RegBase, u32 RegOffset)
{
 801d5a4:	b480      	push	{r7}
 801d5a6:	b085      	sub	sp, #20
 801d5a8:	af00      	add	r7, sp, #0
 801d5aa:	6078      	str	r0, [r7, #4]
 801d5ac:	6039      	str	r1, [r7, #0]
  u32 data;
  data = (*(u32 *) ((u32)RegBase + RegOffset));
 801d5ae:	687a      	ldr	r2, [r7, #4]
 801d5b0:	683b      	ldr	r3, [r7, #0]
 801d5b2:	18d3      	adds	r3, r2, r3
 801d5b4:	681b      	ldr	r3, [r3, #0]
 801d5b6:	60fb      	str	r3, [r7, #12]
  return data;
 801d5b8:	68fb      	ldr	r3, [r7, #12]

}
 801d5ba:	4618      	mov	r0, r3
 801d5bc:	f107 0714 	add.w	r7, r7, #20
 801d5c0:	46bd      	mov	sp, r7
 801d5c2:	bc80      	pop	{r7}
 801d5c4:	4770      	bx	lr
 801d5c6:	bf00      	nop

0801d5c8 <synopGMACWriteReg>:
 * @param[in] Offset from the base
 * @param[in] Data to be written
 * \return  void
 */
void  synopGMACWriteReg(u32 *RegBase, u32 RegOffset, u32 RegData)
{
 801d5c8:	b480      	push	{r7}
 801d5ca:	b085      	sub	sp, #20
 801d5cc:	af00      	add	r7, sp, #0
 801d5ce:	60f8      	str	r0, [r7, #12]
 801d5d0:	60b9      	str	r1, [r7, #8]
 801d5d2:	607a      	str	r2, [r7, #4]
  * (u32 *) ((u32)RegBase + RegOffset) = RegData;
 801d5d4:	68fa      	ldr	r2, [r7, #12]
 801d5d6:	68bb      	ldr	r3, [r7, #8]
 801d5d8:	18d3      	adds	r3, r2, r3
 801d5da:	687a      	ldr	r2, [r7, #4]
 801d5dc:	601a      	str	r2, [r3, #0]
  return;
 801d5de:	bf00      	nop
}
 801d5e0:	f107 0714 	add.w	r7, r7, #20
 801d5e4:	46bd      	mov	sp, r7
 801d5e6:	bc80      	pop	{r7}
 801d5e8:	4770      	bx	lr
 801d5ea:	bf00      	nop

0801d5ec <synopGMACSetBits>:
 * @param[in] Offset from the base
 * @param[in] Bit mask to set bits to logical 1
 * \return  void
 */
void synopGMACSetBits(u32 *RegBase, u32 RegOffset, u32 BitPos)
{
 801d5ec:	b480      	push	{r7}
 801d5ee:	b087      	sub	sp, #28
 801d5f0:	af00      	add	r7, sp, #0
 801d5f2:	60f8      	str	r0, [r7, #12]
 801d5f4:	60b9      	str	r1, [r7, #8]
 801d5f6:	607a      	str	r2, [r7, #4]
  u32 data;

  /* Read data from the register */
  data = (*(u32 *) ((u32)RegBase + RegOffset));
 801d5f8:	68fa      	ldr	r2, [r7, #12]
 801d5fa:	68bb      	ldr	r3, [r7, #8]
 801d5fc:	18d3      	adds	r3, r2, r3
 801d5fe:	681b      	ldr	r3, [r3, #0]
 801d600:	617b      	str	r3, [r7, #20]

  /* Set the bits */
  data |= BitPos;
 801d602:	697a      	ldr	r2, [r7, #20]
 801d604:	687b      	ldr	r3, [r7, #4]
 801d606:	4313      	orrs	r3, r2
 801d608:	617b      	str	r3, [r7, #20]

  /* Write back into the register */
  * (u32 *) ((u32)RegBase + RegOffset) = data;
 801d60a:	68fa      	ldr	r2, [r7, #12]
 801d60c:	68bb      	ldr	r3, [r7, #8]
 801d60e:	18d3      	adds	r3, r2, r3
 801d610:	697a      	ldr	r2, [r7, #20]
 801d612:	601a      	str	r2, [r3, #0]
  return;
 801d614:	bf00      	nop
}
 801d616:	f107 071c 	add.w	r7, r7, #28
 801d61a:	46bd      	mov	sp, r7
 801d61c:	bc80      	pop	{r7}
 801d61e:	4770      	bx	lr

0801d620 <synopGMACClearBits>:
 * @param[in] Offset from the base
 * @param[in] Bit mask to clear bits to logical 0
 * \return  void
 */
void synopGMACClearBits(u32 *RegBase, u32 RegOffset, u32 BitPos)
{
 801d620:	b480      	push	{r7}
 801d622:	b087      	sub	sp, #28
 801d624:	af00      	add	r7, sp, #0
 801d626:	60f8      	str	r0, [r7, #12]
 801d628:	60b9      	str	r1, [r7, #8]
 801d62a:	607a      	str	r2, [r7, #4]
  u32 data;
  /* Read data from the register */
  data = (*(u32 *) ((u32)RegBase + RegOffset));
 801d62c:	68fa      	ldr	r2, [r7, #12]
 801d62e:	68bb      	ldr	r3, [r7, #8]
 801d630:	18d3      	adds	r3, r2, r3
 801d632:	681b      	ldr	r3, [r3, #0]
 801d634:	617b      	str	r3, [r7, #20]

  /*Clear the bits */
  data &= (~BitPos);
 801d636:	687b      	ldr	r3, [r7, #4]
 801d638:	ea6f 0303 	mvn.w	r3, r3
 801d63c:	697a      	ldr	r2, [r7, #20]
 801d63e:	4013      	ands	r3, r2
 801d640:	617b      	str	r3, [r7, #20]

  /* Write back into the register */
  * (u32 *) ((u32)RegBase + RegOffset) = data;
 801d642:	68fa      	ldr	r2, [r7, #12]
 801d644:	68bb      	ldr	r3, [r7, #8]
 801d646:	18d3      	adds	r3, r2, r3
 801d648:	697a      	ldr	r2, [r7, #20]
 801d64a:	601a      	str	r2, [r3, #0]

  return;
 801d64c:	bf00      	nop
}
 801d64e:	f107 071c 	add.w	r7, r7, #28
 801d652:	46bd      	mov	sp, r7
 801d654:	bc80      	pop	{r7}
 801d656:	4770      	bx	lr

0801d658 <synopGMACCheckBits>:
 * @param[in] Bit mask to set bits to logical 1
 * \return  returns TRUE if set to '1' returns FALSE if set to '0'. Result undefined there are no bit set in the BitPos argument.
 *
 */
bool synopGMACCheckBits(u32 *RegBase, u32 RegOffset, u32 BitPos)
{
 801d658:	b480      	push	{r7}
 801d65a:	b087      	sub	sp, #28
 801d65c:	af00      	add	r7, sp, #0
 801d65e:	60f8      	str	r0, [r7, #12]
 801d660:	60b9      	str	r1, [r7, #8]
 801d662:	607a      	str	r2, [r7, #4]
  u32 data;
  u32 addr = (u32)RegBase + RegOffset;
 801d664:	68fa      	ldr	r2, [r7, #12]
 801d666:	68bb      	ldr	r3, [r7, #8]
 801d668:	18d3      	adds	r3, r2, r3
 801d66a:	617b      	str	r3, [r7, #20]
  data = (*(u32 *)addr);
 801d66c:	697b      	ldr	r3, [r7, #20]
 801d66e:	681b      	ldr	r3, [r3, #0]
 801d670:	613b      	str	r3, [r7, #16]
  data &= BitPos;
 801d672:	693a      	ldr	r2, [r7, #16]
 801d674:	687b      	ldr	r3, [r7, #4]
 801d676:	4013      	ands	r3, r2
 801d678:	613b      	str	r3, [r7, #16]
  if(data)  return TRUE;
 801d67a:	693b      	ldr	r3, [r7, #16]
 801d67c:	2b00      	cmp	r3, #0
 801d67e:	d002      	beq.n	801d686 <synopGMACCheckBits+0x2e>
 801d680:	f04f 0301 	mov.w	r3, #1
 801d684:	e001      	b.n	801d68a <synopGMACCheckBits+0x32>
  else	    return FALSE;
 801d686:	f04f 0300 	mov.w	r3, #0

}
 801d68a:	4618      	mov	r0, r3
 801d68c:	f107 071c 	add.w	r7, r7, #28
 801d690:	46bd      	mov	sp, r7
 801d692:	bc80      	pop	{r7}
 801d694:	4770      	bx	lr
 801d696:	bf00      	nop

0801d698 <NVIC_GetPriorityGrouping>:
  The function reads the priority grouping field from the NVIC Interrupt Controller.

    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 801d698:	b480      	push	{r7}
 801d69a:	af00      	add	r7, sp, #0
  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
 801d69c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 801d6a0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 801d6a4:	68db      	ldr	r3, [r3, #12]
 801d6a6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 801d6aa:	ea4f 2313 	mov.w	r3, r3, lsr #8
}
 801d6ae:	4618      	mov	r0, r3
 801d6b0:	46bd      	mov	sp, r7
 801d6b2:	bc80      	pop	{r7}
 801d6b4:	4770      	bx	lr
 801d6b6:	bf00      	nop

0801d6b8 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 801d6b8:	b480      	push	{r7}
 801d6ba:	b083      	sub	sp, #12
 801d6bc:	af00      	add	r7, sp, #0
 801d6be:	4603      	mov	r3, r0
 801d6c0:	71fb      	strb	r3, [r7, #7]
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 801d6c2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 801d6c6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 801d6ca:	f997 2007 	ldrsb.w	r2, [r7, #7]
 801d6ce:	ea4f 1252 	mov.w	r2, r2, lsr #5
 801d6d2:	79f9      	ldrb	r1, [r7, #7]
 801d6d4:	f001 011f 	and.w	r1, r1, #31
 801d6d8:	f04f 0001 	mov.w	r0, #1
 801d6dc:	fa00 f101 	lsl.w	r1, r0, r1
 801d6e0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 801d6e4:	f107 070c 	add.w	r7, r7, #12
 801d6e8:	46bd      	mov	sp, r7
 801d6ea:	bc80      	pop	{r7}
 801d6ec:	4770      	bx	lr
 801d6ee:	bf00      	nop

0801d6f0 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 801d6f0:	b480      	push	{r7}
 801d6f2:	b083      	sub	sp, #12
 801d6f4:	af00      	add	r7, sp, #0
 801d6f6:	4603      	mov	r3, r0
 801d6f8:	6039      	str	r1, [r7, #0]
 801d6fa:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 801d6fc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 801d700:	2b00      	cmp	r3, #0
 801d702:	da10      	bge.n	801d726 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 801d704:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 801d708:	f2ce 0300 	movt	r3, #57344	; 0xe000
 801d70c:	79fa      	ldrb	r2, [r7, #7]
 801d70e:	f002 020f 	and.w	r2, r2, #15
 801d712:	f1a2 0104 	sub.w	r1, r2, #4
 801d716:	683a      	ldr	r2, [r7, #0]
 801d718:	b2d2      	uxtb	r2, r2
 801d71a:	ea4f 0282 	mov.w	r2, r2, lsl #2
 801d71e:	b2d2      	uxtb	r2, r2
 801d720:	185b      	adds	r3, r3, r1
 801d722:	761a      	strb	r2, [r3, #24]
 801d724:	e00d      	b.n	801d742 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 801d726:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 801d72a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 801d72e:	f997 1007 	ldrsb.w	r1, [r7, #7]
 801d732:	683a      	ldr	r2, [r7, #0]
 801d734:	b2d2      	uxtb	r2, r2
 801d736:	ea4f 0282 	mov.w	r2, r2, lsl #2
 801d73a:	b2d2      	uxtb	r2, r2
 801d73c:	185b      	adds	r3, r3, r1
 801d73e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 801d742:	f107 070c 	add.w	r7, r7, #12
 801d746:	46bd      	mov	sp, r7
 801d748:	bc80      	pop	{r7}
 801d74a:	4770      	bx	lr

0801d74c <NVIC_EncodePriority>:
    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
    \param [in]       SubPriority  Subpriority value (starting from 0).
    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 801d74c:	b480      	push	{r7}
 801d74e:	b089      	sub	sp, #36	; 0x24
 801d750:	af00      	add	r7, sp, #0
 801d752:	60f8      	str	r0, [r7, #12]
 801d754:	60b9      	str	r1, [r7, #8]
 801d756:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
 801d758:	68fb      	ldr	r3, [r7, #12]
 801d75a:	f003 0307 	and.w	r3, r3, #7
 801d75e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
 801d760:	69fb      	ldr	r3, [r7, #28]
 801d762:	f1c3 0307 	rsb	r3, r3, #7
 801d766:	2b06      	cmp	r3, #6
 801d768:	bf28      	it	cs
 801d76a:	2306      	movcs	r3, #6
 801d76c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
 801d76e:	69fb      	ldr	r3, [r7, #28]
 801d770:	f103 0306 	add.w	r3, r3, #6
 801d774:	2b06      	cmp	r3, #6
 801d776:	d903      	bls.n	801d780 <NVIC_EncodePriority+0x34>
 801d778:	69fb      	ldr	r3, [r7, #28]
 801d77a:	f103 33ff 	add.w	r3, r3, #4294967295
 801d77e:	e001      	b.n	801d784 <NVIC_EncodePriority+0x38>
 801d780:	f04f 0300 	mov.w	r3, #0
 801d784:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
 801d786:	69bb      	ldr	r3, [r7, #24]
 801d788:	f04f 0201 	mov.w	r2, #1
 801d78c:	fa02 f303 	lsl.w	r3, r2, r3
 801d790:	f103 33ff 	add.w	r3, r3, #4294967295
 801d794:	461a      	mov	r2, r3
 801d796:	68bb      	ldr	r3, [r7, #8]
 801d798:	401a      	ands	r2, r3
 801d79a:	697b      	ldr	r3, [r7, #20]
 801d79c:	fa02 f203 	lsl.w	r2, r2, r3
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
 801d7a0:	697b      	ldr	r3, [r7, #20]
 801d7a2:	f04f 0101 	mov.w	r1, #1
 801d7a6:	fa01 f303 	lsl.w	r3, r1, r3
 801d7aa:	f103 33ff 	add.w	r3, r3, #4294967295
 801d7ae:	4619      	mov	r1, r3
 801d7b0:	687b      	ldr	r3, [r7, #4]
 801d7b2:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

  return (
 801d7b4:	4313      	orrs	r3, r2
           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
         );
}
 801d7b6:	4618      	mov	r0, r3
 801d7b8:	f107 0724 	add.w	r7, r7, #36	; 0x24
 801d7bc:	46bd      	mov	sp, r7
 801d7be:	bc80      	pop	{r7}
 801d7c0:	4770      	bx	lr
 801d7c2:	bf00      	nop

0801d7c4 <Eth_GetTxBuffer>:

/*******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/
status_t Eth_GetTxBuffer(uint8_t** Buffer)
{
 801d7c4:	b480      	push	{r7}
 801d7c6:	b083      	sub	sp, #12
 801d7c8:	af00      	add	r7, sp, #0
 801d7ca:	6078      	str	r0, [r7, #4]
	*Buffer = (uint8_t*)synopGMACdev->TxNextDesc->buffer1;
 801d7cc:	f246 6348 	movw	r3, #26184	; 0x6648
 801d7d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d7d4:	681b      	ldr	r3, [r3, #0]
 801d7d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801d7d8:	689b      	ldr	r3, [r3, #8]
 801d7da:	461a      	mov	r2, r3
 801d7dc:	687b      	ldr	r3, [r7, #4]
 801d7de:	601a      	str	r2, [r3, #0]
	return DAVEApp_SUCCESS;
 801d7e0:	f04f 0300 	mov.w	r3, #0
}
 801d7e4:	4618      	mov	r0, r3
 801d7e6:	f107 070c 	add.w	r7, r7, #12
 801d7ea:	46bd      	mov	sp, r7
 801d7ec:	bc80      	pop	{r7}
 801d7ee:	4770      	bx	lr

0801d7f0 <Eth_InitNetworkInterface>:
status_t Eth_InitNetworkInterface(void)
{
 801d7f0:	b580      	push	{r7, lr}
 801d7f2:	af00      	add	r7, sp, #0
  synopGMACdev = &GMACdevice;
 801d7f4:	f246 6348 	movw	r3, #26184	; 0x6648
 801d7f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d7fc:	f246 5280 	movw	r2, #25984	; 0x6580
 801d800:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d804:	601a      	str	r2, [r3, #0]
  /* Set Ethernet MAC interface  (RMII/MII) to one selected by user */
  WR_REG(ETH0_CON->CON, ETH_CON_INFSEL_Msk, ETH_CON_INFSEL_Pos, ETH_MAC_SEL);
 801d806:	f244 0340 	movw	r3, #16448	; 0x4040
 801d80a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801d80e:	f244 0240 	movw	r2, #16448	; 0x4040
 801d812:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801d816:	6812      	ldr	r2, [r2, #0]
 801d818:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 801d81c:	601a      	str	r2, [r3, #0]
   
  
  /* To Deassert */
  RESET001_DeassertReset(PER2_ETH0);
 801d81e:	f04f 0004 	mov.w	r0, #4
 801d822:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801d826:	f7ec f8c5 	bl	80099b4 <RESET001_DeassertReset>
  /** Configure CLKSET*/
  WR_REG(SCU_CLK->CLKSET, SCU_CLK_CLKSTAT_ETH0CST_Msk, SCU_CLK_CLKSTAT_ETH0CST_Pos, 1U);  
 801d82a:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 801d82e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801d832:	f44f 428c 	mov.w	r2, #17920	; 0x4600
 801d836:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801d83a:	6852      	ldr	r2, [r2, #4]
 801d83c:	f042 0204 	orr.w	r2, r2, #4
 801d840:	605a      	str	r2, [r3, #4]
  /* Pad Driver Mode settings */  
  /* OUT PINs used in ETH for setting Pad drive modes */   
  /* Configuration of TXD0 Pin 2.8 based on User configuration */                                      
  WR_REG(PORT2->PDR1, PORT2_PDR1_PD8_Msk, PORT2_PDR1_PD8_Pos, 0U);    
 801d842:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801d846:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801d84a:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801d84e:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801d852:	6c52      	ldr	r2, [r2, #68]	; 0x44
 801d854:	f022 0207 	bic.w	r2, r2, #7
 801d858:	645a      	str	r2, [r3, #68]	; 0x44
  /* Configuration of TXD1 Pin 2.9 based on User configuration */                                      
  WR_REG(PORT2->PDR1, PORT2_PDR1_PD9_Msk, PORT2_PDR1_PD9_Pos, 0U);    
 801d85a:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801d85e:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801d862:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801d866:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801d86a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 801d86c:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 801d870:	645a      	str	r2, [r3, #68]	; 0x44
  /* Configuration of TXD1 Pin 2.5 based on User configuration */
  WR_REG(PORT2->PDR0, PORT2_PDR0_PD5_Msk, PORT2_PDR0_PD5_Pos, 0U);   
 801d872:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801d876:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801d87a:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801d87e:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801d882:	6c12      	ldr	r2, [r2, #64]	; 0x40
 801d884:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 801d888:	641a      	str	r2, [r3, #64]	; 0x40
  /* <<<DD_ETH_PORT_1>>> */
  /* Attach the device to MAC struct. This will configure all the required base
   * addresses such as MAC base, Configuration base, PHY base address
   * (out of 32 possible phys )
   */
  synopGMAC_attach(synopGMACdev, ETH0_BASE, ETH_BASE, PHY_BASE_ADDRESS);  
 801d88a:	f246 6348 	movw	r3, #26184	; 0x6648
 801d88e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d892:	681b      	ldr	r3, [r3, #0]
 801d894:	4618      	mov	r0, r3
 801d896:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 801d89a:	f2c5 0100 	movt	r1, #20480	; 0x5000
 801d89e:	f44f 4250 	mov.w	r2, #53248	; 0xd000
 801d8a2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801d8a6:	f04f 0300 	mov.w	r3, #0
 801d8aa:	f7fd ff3b 	bl	801b724 <synopGMAC_attach>
  /* Reset the GMAC */
  synopGMAC_reset(synopGMACdev);
 801d8ae:	f246 6348 	movw	r3, #26184	; 0x6648
 801d8b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d8b6:	681b      	ldr	r3, [r3, #0]
 801d8b8:	4618      	mov	r0, r3
 801d8ba:	f7fd f91f 	bl	801aafc <synopGMAC_reset>
  
  DBG002_INFO(APP_GID, ETH_INIT_SUCCESS, 0, NULL);
  return DAVEApp_SUCCESS;
 801d8be:	f04f 0300 	mov.w	r3, #0
}
 801d8c2:	4618      	mov	r0, r3
 801d8c4:	bd80      	pop	{r7, pc}
 801d8c6:	bf00      	nop

0801d8c8 <Eth_ExitNetworkInterface>:


void Eth_ExitNetworkInterface(void)
{
 801d8c8:	b480      	push	{r7}
 801d8ca:	af00      	add	r7, sp, #0
  /* <<<DD_ETH_PORT_2>>> */
  /* This function is an empty function kept for uniformity */
  DBG002_INFO(APP_GID, ETH_EXIT_SUCCESS, 0, NULL);
}
 801d8cc:	46bd      	mov	sp, r7
 801d8ce:	bc80      	pop	{r7}
 801d8d0:	4770      	bx	lr
 801d8d2:	bf00      	nop

0801d8d4 <Eth_OpenNetworkInterface>:


status_t Eth_OpenNetworkInterface(void)
{
 801d8d4:	b590      	push	{r4, r7, lr}
 801d8d6:	b089      	sub	sp, #36	; 0x24
 801d8d8:	af04      	add	r7, sp, #16
  /* <<<DD_ETH_PORT_3>>> */
  status_t Status = ETH_OPEN_ERROR;
 801d8da:	f04f 0302 	mov.w	r3, #2
 801d8de:	60fb      	str	r3, [r7, #12]
  uint32_t DescCount = 0;
 801d8e0:	f04f 0300 	mov.w	r3, #0
 801d8e4:	60bb      	str	r3, [r7, #8]
  int32_t DescStatus = -1;
 801d8e6:	f04f 33ff 	mov.w	r3, #4294967295
 801d8ea:	607b      	str	r3, [r7, #4]
    /* Attach the device to MAC struct. This will configure all the required base
     * addresses such as MAC base, Configuration base, PHY base address(out of 32
     * possible PHYs)
     */

    synopGMAC_attach(synopGMACdev, ETH0_BASE, ETH_BASE, PHY_BASE_ADDRESS);
 801d8ec:	f246 6348 	movw	r3, #26184	; 0x6648
 801d8f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d8f4:	681b      	ldr	r3, [r3, #0]
 801d8f6:	4618      	mov	r0, r3
 801d8f8:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 801d8fc:	f2c5 0100 	movt	r1, #20480	; 0x5000
 801d900:	f44f 4250 	mov.w	r2, #53248	; 0xd000
 801d904:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801d908:	f04f 0300 	mov.w	r3, #0
 801d90c:	f7fd ff0a 	bl	801b724 <synopGMAC_attach>

    /* Lets read the version of IP in to device structure*/
    synopGMAC_read_version(synopGMACdev);
 801d910:	f246 6348 	movw	r3, #26184	; 0x6648
 801d914:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d918:	681b      	ldr	r3, [r3, #0]
 801d91a:	4618      	mov	r0, r3
 801d91c:	f7fd f8c2 	bl	801aaa4 <synopGMAC_read_version>

    /* Stack should use IOCTL to get the MAC Address */
    synopGMAC_get_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low,
 801d920:	f246 6348 	movw	r3, #26184	; 0x6648
 801d924:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d928:	681a      	ldr	r2, [r3, #0]
        synopGMACdev->MacAddress);
 801d92a:	f246 6348 	movw	r3, #26184	; 0x6648
 801d92e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d932:	681b      	ldr	r3, [r3, #0]
 801d934:	f103 03bc 	add.w	r3, r3, #188	; 0xbc

    /* Lets read the version of IP in to device structure*/
    synopGMAC_read_version(synopGMACdev);

    /* Stack should use IOCTL to get the MAC Address */
    synopGMAC_get_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low,
 801d938:	4610      	mov	r0, r2
 801d93a:	f04f 0140 	mov.w	r1, #64	; 0x40
 801d93e:	f04f 0244 	mov.w	r2, #68	; 0x44
 801d942:	f7fd fea9 	bl	801b698 <synopGMAC_get_mac_addr>
        synopGMACdev->MacAddress);

    /* Check for PHY initialization */
    synopGMAC_set_mdc_clk_div(synopGMACdev, GmiiCsrClk3);
 801d946:	f246 6348 	movw	r3, #26184	; 0x6648
 801d94a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d94e:	681b      	ldr	r3, [r3, #0]
 801d950:	4618      	mov	r0, r3
 801d952:	f04f 010c 	mov.w	r1, #12
 801d956:	f7fd f86b 	bl	801aa30 <synopGMAC_set_mdc_clk_div>

    synopGMACdev->ClockDivMdc = synopGMAC_get_mdc_clk_div(synopGMACdev);
 801d95a:	f246 6348 	movw	r3, #26184	; 0x6648
 801d95e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d962:	681c      	ldr	r4, [r3, #0]
 801d964:	f246 6348 	movw	r3, #26184	; 0x6648
 801d968:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d96c:	681b      	ldr	r3, [r3, #0]
 801d96e:	4618      	mov	r0, r3
 801d970:	f7fd f882 	bl	801aa78 <synopGMAC_get_mdc_clk_div>
 801d974:	4603      	mov	r3, r0
 801d976:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4

    /* Initialize Ethernet PHY */
    Status = PHY_InitializeDevice();
 801d97a:	f7fc fdf3 	bl	801a564 <PHY_InitializeDevice>
 801d97e:	60f8      	str	r0, [r7, #12]
    if (Status != DAVEApp_SUCCESS)
 801d980:	68fb      	ldr	r3, [r7, #12]
 801d982:	2b00      	cmp	r3, #0
 801d984:	f040 813d 	bne.w	801dc02 <Eth_OpenNetworkInterface+0x32e>
      break;
    }

#ifndef BUILD_UIP  /* UIP polls the packets. Hence no interrupt handler.*/
    /* ISR will be registered via NVIC */
    NVIC_SetPriority(108, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 801d988:	f7ff fe86 	bl	801d698 <NVIC_GetPriorityGrouping>
 801d98c:	4603      	mov	r3, r0
 801d98e:	4618      	mov	r0, r3
 801d990:	f04f 013f 	mov.w	r1, #63	; 0x3f
 801d994:	f04f 0200 	mov.w	r2, #0
 801d998:	f7ff fed8 	bl	801d74c <NVIC_EncodePriority>
 801d99c:	4603      	mov	r3, r0
 801d99e:	f04f 006c 	mov.w	r0, #108	; 0x6c
 801d9a2:	4619      	mov	r1, r3
 801d9a4:	f7ff fea4 	bl	801d6f0 <NVIC_SetPriority>
       			                                    63, 0));
    NVIC_EnableIRQ(108);
 801d9a8:	f04f 006c 	mov.w	r0, #108	; 0x6c
 801d9ac:	f7ff fe84 	bl	801d6b8 <NVIC_EnableIRQ>
#endif 

    /* Set up the TX descriptor queue/ring */
    /* Configure the descriptors in RING mode */
    synopGMAC_setup_tx_desc_queue(synopGMACdev, TRANSMIT_DESC_SIZE, RINGMODE);
 801d9b0:	f246 6348 	movw	r3, #26184	; 0x6648
 801d9b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d9b8:	681b      	ldr	r3, [r3, #0]
 801d9ba:	4618      	mov	r0, r3
 801d9bc:	f04f 0106 	mov.w	r1, #6
 801d9c0:	f04f 0201 	mov.w	r2, #1
 801d9c4:	f7ff fbe2 	bl	801d18c <synopGMAC_setup_tx_desc_queue>

    /* Program the transmit descriptor base address in to DmaTxBase Address */
    synopGMAC_init_tx_desc_base(synopGMACdev);
 801d9c8:	f246 6348 	movw	r3, #26184	; 0x6648
 801d9cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d9d0:	681b      	ldr	r3, [r3, #0]
 801d9d2:	4618      	mov	r0, r3
 801d9d4:	f7fd ffc2 	bl	801b95c <synopGMAC_init_tx_desc_base>

    /* Set up the Rx descriptor queue/ring */
    synopGMAC_setup_rx_desc_queue(synopGMACdev, RECEIVE_DESC_SIZE, RINGMODE);
 801d9d8:	f246 6348 	movw	r3, #26184	; 0x6648
 801d9dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d9e0:	681b      	ldr	r3, [r3, #0]
 801d9e2:	4618      	mov	r0, r3
 801d9e4:	f04f 0106 	mov.w	r1, #6
 801d9e8:	f04f 0201 	mov.w	r2, #1
 801d9ec:	f7ff faa6 	bl	801cf3c <synopGMAC_setup_rx_desc_queue>

    /* Program the receive descriptor base address in to DmaTxBase Address */
    synopGMAC_init_rx_desc_base(synopGMACdev);
 801d9f0:	f246 6348 	movw	r3, #26184	; 0x6648
 801d9f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d9f8:	681b      	ldr	r3, [r3, #0]
 801d9fa:	4618      	mov	r0, r3
 801d9fc:	f7fd ff9a 	bl	801b934 <synopGMAC_init_rx_desc_base>

#ifdef ENH_DESC_8W
    /* Note: Keeping the default values */
    /* pbl32 incr with rxthreshold 128 and Desc is 8 Words */
    synopGMAC_dma_bus_mode_init(synopGMACdev, DmaBurstLength32 |
 801da00:	f246 6348 	movw	r3, #26184	; 0x6648
 801da04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da08:	681b      	ldr	r3, [r3, #0]
 801da0a:	4618      	mov	r0, r3
 801da0c:	f242 0188 	movw	r1, #8328	; 0x2088
 801da10:	f7fd f8aa 	bl	801ab68 <synopGMAC_dma_bus_mode_init>
    synopGMAC_dma_bus_mode_init(synopGMACdev,
        DmaBurstLength32 | DmaDescriptorSkip2);
#endif

    /* Configure Store and forward, OSF, RX threshold control */
    synopGMAC_dma_control_init(synopGMACdev,
 801da14:	f246 6348 	movw	r3, #26184	; 0x6648
 801da18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da1c:	681b      	ldr	r3, [r3, #0]
 801da1e:	4618      	mov	r0, r3
 801da20:	f04f 011c 	mov.w	r1, #28
 801da24:	f2c0 0120 	movt	r1, #32
 801da28:	f7fd f8b2 	bl	801ab90 <synopGMAC_dma_control_init>
        DmaStoreAndForward | DmaTxSecondFrame | DmaRxThreshCtrl128);
		 
#ifdef HALF_DUPLEX
    synopGMACdev->DuplexMode = HALFDUPLEX;
#else
    synopGMACdev->DuplexMode = FULLDUPLEX;
 801da2c:	f246 6348 	movw	r3, #26184	; 0x6648
 801da30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da34:	681b      	ldr	r3, [r3, #0]
 801da36:	f04f 0202 	mov.w	r2, #2
 801da3a:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#ifdef SPEED_100	
	synopGMAC_rmii_100mbps_enable(synopGMACdev); 
#endif

#if AUTO_NEGO
	synopGMAC_rmii_100mbps_enable(synopGMACdev); 
 801da3e:	f246 6348 	movw	r3, #26184	; 0x6648
 801da42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da46:	681b      	ldr	r3, [r3, #0]
 801da48:	4618      	mov	r0, r3
 801da4a:	f7fd f845 	bl	801aad8 <synopGMAC_rmii_100mbps_enable>
#endif
    /* Initialize the MAC interface */
    synopGMAC_mac_init(synopGMACdev);
 801da4e:	f246 6348 	movw	r3, #26184	; 0x6648
 801da52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da56:	681b      	ldr	r3, [r3, #0]
 801da58:	4618      	mov	r0, r3
 801da5a:	f7fd fd27 	bl	801b4ac <synopGMAC_mac_init>

#ifdef ENABLE_MULTICAST    
    /* To enable Multicast */
    synopGMAC_multicast_enable(synopGMACdev);
 801da5e:	f246 6348 	movw	r3, #26184	; 0x6648
 801da62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da66:	681b      	ldr	r3, [r3, #0]
 801da68:	4618      	mov	r0, r3
 801da6a:	f7fd fba7 	bl	801b1bc <synopGMAC_multicast_enable>

    synopGMAC_multicast_hash_filter_enable(synopGMACdev);
 801da6e:	f246 6348 	movw	r3, #26184	; 0x6648
 801da72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da76:	681b      	ldr	r3, [r3, #0]
 801da78:	4618      	mov	r0, r3
 801da7a:	f7fd fbc3 	bl	801b204 <synopGMAC_multicast_hash_filter_enable>
#endif
    
   /* To enable Broadcast */
   synopGMAC_broadcast_enable(synopGMACdev);
 801da7e:	f246 6348 	movw	r3, #26184	; 0x6648
 801da82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da86:	681b      	ldr	r3, [r3, #0]
 801da88:	4618      	mov	r0, r3
 801da8a:	f7fd fb73 	bl	801b174 <synopGMAC_broadcast_enable>
    /* IPC Checksum offloading is enabled for this driver. Should only be used
     * if Full IP checksum offload engine is configured in the hardware
     */

    /* Enable the offload engine in the receive path */
    synopGMAC_enable_rx_chksum_offload(synopGMACdev);
 801da8e:	f246 6348 	movw	r3, #26184	; 0x6648
 801da92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801da96:	681b      	ldr	r3, [r3, #0]
 801da98:	4618      	mov	r0, r3
 801da9a:	f7ff f84d 	bl	801cb38 <synopGMAC_enable_rx_chksum_offload>

    /* This is default configuration, DMA drops the packets if error in
     * encapsulated Ethernet payload
     */
    synopGMAC_rx_tcpip_chksum_drop_enable(synopGMACdev);
 801da9e:	f246 6348 	movw	r3, #26184	; 0x6648
 801daa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801daa6:	681b      	ldr	r3, [r3, #0]
 801daa8:	4618      	mov	r0, r3
 801daaa:	f7ff f869 	bl	801cb80 <synopGMAC_rx_tcpip_chksum_drop_enable>
     */
#endif

    do
    {
      DescStatus = synopGMAC_set_rx_qptr(synopGMACdev,
 801daae:	f246 6348 	movw	r3, #26184	; 0x6648
 801dab2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dab6:	6819      	ldr	r1, [r3, #0]
                                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
 801dab8:	68bb      	ldr	r3, [r7, #8]
 801daba:	f240 52dc 	movw	r2, #1500	; 0x5dc
 801dabe:	fb02 f303 	mul.w	r3, r2, r3
 801dac2:	f103 0214 	add.w	r2, r3, #20
 801dac6:	f240 03f0 	movw	r3, #240	; 0xf0
 801daca:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801dace:	18d3      	adds	r3, r2, r3
     */
#endif

    do
    {
      DescStatus = synopGMAC_set_rx_qptr(synopGMACdev,
 801dad0:	461a      	mov	r2, r3
                                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
                                 ETH_PACKET_SIZE,
                                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
 801dad2:	68bb      	ldr	r3, [r7, #8]
 801dad4:	f240 50dc 	movw	r0, #1500	; 0x5dc
 801dad8:	fb00 f303 	mul.w	r3, r0, r3
 801dadc:	f103 0014 	add.w	r0, r3, #20
 801dae0:	f240 03f0 	movw	r3, #240	; 0xf0
 801dae4:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801dae8:	18c3      	adds	r3, r0, r3
     */
#endif

    do
    {
      DescStatus = synopGMAC_set_rx_qptr(synopGMACdev,
 801daea:	f04f 0000 	mov.w	r0, #0
 801daee:	9000      	str	r0, [sp, #0]
 801daf0:	f04f 0000 	mov.w	r0, #0
 801daf4:	9001      	str	r0, [sp, #4]
 801daf6:	f04f 0000 	mov.w	r0, #0
 801dafa:	9002      	str	r0, [sp, #8]
 801dafc:	4608      	mov	r0, r1
 801dafe:	4611      	mov	r1, r2
 801db00:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
 801db04:	f7fe faf2 	bl	801c0ec <synopGMAC_set_rx_qptr>
 801db08:	6078      	str	r0, [r7, #4]
                                 ETH_PACKET_SIZE,
                                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
                                 0,0,0);


      DescStatus = synopGMAC_set_tx_address(synopGMACdev, DescCount,
 801db0a:	f246 6348 	movw	r3, #26184	; 0x6648
 801db0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801db12:	681a      	ldr	r2, [r3, #0]
                                            (uint32_t)&Eth_TxBuffer[DescCount * ETH_PACKET_SIZE]
 801db14:	68bb      	ldr	r3, [r7, #8]
 801db16:	f240 51dc 	movw	r1, #1500	; 0x5dc
 801db1a:	fb01 f303 	mul.w	r3, r1, r3
 801db1e:	f103 0114 	add.w	r1, r3, #20
 801db22:	f242 5380 	movw	r3, #9600	; 0x2580
 801db26:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801db2a:	18cb      	adds	r3, r1, r3
                                 ETH_PACKET_SIZE,
                                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
                                 0,0,0);


      DescStatus = synopGMAC_set_tx_address(synopGMACdev, DescCount,
 801db2c:	4610      	mov	r0, r2
 801db2e:	68b9      	ldr	r1, [r7, #8]
 801db30:	461a      	mov	r2, r3
 801db32:	f7fc ff45 	bl	801a9c0 <synopGMAC_set_tx_address>
 801db36:	6078      	str	r0, [r7, #4]
                                            (uint32_t)&Eth_TxBuffer[DescCount * ETH_PACKET_SIZE]
                                            );

      DescCount++;
 801db38:	68bb      	ldr	r3, [r7, #8]
 801db3a:	f103 0301 	add.w	r3, r3, #1
 801db3e:	60bb      	str	r3, [r7, #8]
    }while((DescStatus >= 0) && (DescCount < RECEIVE_DESC_SIZE));
 801db40:	687b      	ldr	r3, [r7, #4]
 801db42:	2b00      	cmp	r3, #0
 801db44:	db02      	blt.n	801db4c <Eth_OpenNetworkInterface+0x278>
 801db46:	68bb      	ldr	r3, [r7, #8]
 801db48:	2b05      	cmp	r3, #5
 801db4a:	d9b0      	bls.n	801daae <Eth_OpenNetworkInterface+0x1da>

    DBG002_INFO(APP_GID, ETH_SETUP_RX_DESC, 0, NULL);

	if(NULL != SynopGMACPeriodicTimerCallback)
 801db4c:	f645 3398 	movw	r3, #23448	; 0x5b98
 801db50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801db54:	681b      	ldr	r3, [r3, #0]
 801db56:	2b00      	cmp	r3, #0
 801db58:	d00d      	beq.n	801db76 <Eth_OpenNetworkInterface+0x2a2>
	{
		SynopGMACPeriodicTimerCallback(CABLE_STATUS_PERIOD, synopGMACdev);
 801db5a:	f645 3398 	movw	r3, #23448	; 0x5b98
 801db5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801db62:	681a      	ldr	r2, [r3, #0]
 801db64:	f246 6348 	movw	r3, #26184	; 0x6648
 801db68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801db6c:	681b      	ldr	r3, [r3, #0]
 801db6e:	f04f 0005 	mov.w	r0, #5
 801db72:	4619      	mov	r1, r3
 801db74:	4790      	blx	r2
	}
    /* Clear all the interrupts */
    synopGMAC_clear_interrupt(synopGMACdev);
 801db76:	f246 6348 	movw	r3, #26184	; 0x6648
 801db7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801db7e:	681b      	ldr	r3, [r3, #0]
 801db80:	4618      	mov	r0, r3
 801db82:	f7fe fbf3 	bl	801c36c <synopGMAC_clear_interrupt>
    /**
     * Disable the interrupts generated by MMC and IPC counters.
     * If these are not disabled ISR should be modified accordingly to handle
     * these interrupts.
     */
    synopGMAC_disable_mmc_tx_interrupt(synopGMACdev, 0xFFFFFFFF);
 801db86:	f246 6348 	movw	r3, #26184	; 0x6648
 801db8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801db8e:	681b      	ldr	r3, [r3, #0]
 801db90:	4618      	mov	r0, r3
 801db92:	f04f 31ff 	mov.w	r1, #4294967295
 801db96:	f7fe ff63 	bl	801ca60 <synopGMAC_disable_mmc_tx_interrupt>
    synopGMAC_disable_mmc_rx_interrupt(synopGMACdev, 0xFFFFFFFF);
 801db9a:	f246 6348 	movw	r3, #26184	; 0x6648
 801db9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dba2:	681b      	ldr	r3, [r3, #0]
 801dba4:	4618      	mov	r0, r3
 801dba6:	f04f 31ff 	mov.w	r1, #4294967295
 801dbaa:	f7fe ff7d 	bl	801caa8 <synopGMAC_disable_mmc_rx_interrupt>
    synopGMAC_disable_mmc_ipc_rx_interrupt(synopGMACdev, 0xFFFFFFFF);
 801dbae:	f246 6348 	movw	r3, #26184	; 0x6648
 801dbb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dbb6:	681b      	ldr	r3, [r3, #0]
 801dbb8:	4618      	mov	r0, r3
 801dbba:	f04f 31ff 	mov.w	r1, #4294967295
 801dbbe:	f7fe ff97 	bl	801caf0 <synopGMAC_disable_mmc_ipc_rx_interrupt>

    /** Configure DMA Interrupts */
    synopGMAC_enable_interrupt(synopGMACdev, DmaIntEnable);
 801dbc2:	f246 6348 	movw	r3, #26184	; 0x6648
 801dbc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dbca:	681b      	ldr	r3, [r3, #0]
 801dbcc:	4618      	mov	r0, r3
 801dbce:	f24a 11e3 	movw	r1, #41443	; 0xa1e3
 801dbd2:	f2c0 0101 	movt	r1, #1
 801dbd6:	f7fe fc4f 	bl	801c478 <synopGMAC_enable_interrupt>
    synopGMAC_enable_dma_rx(synopGMACdev);
 801dbda:	f246 6348 	movw	r3, #26184	; 0x6648
 801dbde:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dbe2:	681b      	ldr	r3, [r3, #0]
 801dbe4:	4618      	mov	r0, r3
 801dbe6:	f7fe fc7d 	bl	801c4e4 <synopGMAC_enable_dma_rx>
    synopGMAC_enable_dma_tx(synopGMACdev);
 801dbea:	f246 6348 	movw	r3, #26184	; 0x6648
 801dbee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dbf2:	681b      	ldr	r3, [r3, #0]
 801dbf4:	4618      	mov	r0, r3
 801dbf6:	f7fe fc91 	bl	801c51c <synopGMAC_enable_dma_tx>

    Status = DAVEApp_SUCCESS;
 801dbfa:	f04f 0300 	mov.w	r3, #0
 801dbfe:	60fb      	str	r3, [r7, #12]
 801dc00:	e000      	b.n	801dc04 <Eth_OpenNetworkInterface+0x330>
    /* Initialize Ethernet PHY */
    Status = PHY_InitializeDevice();
    if (Status != DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, Status, 0, NULL);
      break;
 801dc02:	bf00      	nop
    synopGMAC_enable_dma_tx(synopGMACdev);

    Status = DAVEApp_SUCCESS;
  }while (0);

  return Status;
 801dc04:	68fb      	ldr	r3, [r7, #12]
}
 801dc06:	4618      	mov	r0, r3
 801dc08:	f107 0714 	add.w	r7, r7, #20
 801dc0c:	46bd      	mov	sp, r7
 801dc0e:	bd90      	pop	{r4, r7, pc}

0801dc10 <Eth_CloseNetworkInterface>:


status_t Eth_CloseNetworkInterface (void)
{
 801dc10:	b580      	push	{r7, lr}
 801dc12:	b082      	sub	sp, #8
 801dc14:	af00      	add	r7, sp, #0
  /* <<<DD_ETH_PORT_4>>> */
  status_t Status = ETH_CLOSE_ERROR;
 801dc16:	f04f 0303 	mov.w	r3, #3
 801dc1a:	607b      	str	r3, [r7, #4]

  /* Disable all the interrupts*/
  synopGMAC_disable_interrupt_all(synopGMACdev);
 801dc1c:	f246 6348 	movw	r3, #26184	; 0x6648
 801dc20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc24:	681b      	ldr	r3, [r3, #0]
 801dc26:	4618      	mov	r0, r3
 801dc28:	f7fe fc38 	bl	801c49c <synopGMAC_disable_interrupt_all>

  DBG002_INFO(APP_GID, ETH_INTR_DISABLED, 0, NULL);

  /* Disable the reception */
  synopGMAC_disable_dma_rx(synopGMACdev);
 801dc2c:	f246 6348 	movw	r3, #26184	; 0x6648
 801dc30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc34:	681b      	ldr	r3, [r3, #0]
 801dc36:	4618      	mov	r0, r3
 801dc38:	f7fe fd42 	bl	801c6c0 <synopGMAC_disable_dma_rx>
  synopGMAC_take_desc_ownership_rx(synopGMACdev);
 801dc3c:	f246 6348 	movw	r3, #26184	; 0x6648
 801dc40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc44:	681b      	ldr	r3, [r3, #0]
 801dc46:	4618      	mov	r0, r3
 801dc48:	f7fe fcba 	bl	801c5c0 <synopGMAC_take_desc_ownership_rx>

  DBG002_INFO(APP_GID, ETH_RX_DISABLED, 0, NULL);

  /* Disable the transmission */
  synopGMAC_disable_dma_tx(synopGMACdev);
 801dc4c:	f246 6348 	movw	r3, #26184	; 0x6648
 801dc50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc54:	681b      	ldr	r3, [r3, #0]
 801dc56:	4618      	mov	r0, r3
 801dc58:	f7fe fd16 	bl	801c688 <synopGMAC_disable_dma_tx>
  synopGMAC_take_desc_ownership_tx(synopGMACdev);
 801dc5c:	f246 6348 	movw	r3, #26184	; 0x6648
 801dc60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc64:	681b      	ldr	r3, [r3, #0]
 801dc66:	4618      	mov	r0, r3
 801dc68:	f7fe fcdc 	bl	801c624 <synopGMAC_take_desc_ownership_tx>

  DBG002_INFO(APP_GID, ETH_TX_DISABLED, 0, NULL);

  /* Free the Rx Descriptor contents */
  synopGMAC_giveup_rx_desc_queue(synopGMACdev, RINGMODE);
 801dc6c:	f246 6348 	movw	r3, #26184	; 0x6648
 801dc70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc74:	681b      	ldr	r3, [r3, #0]
 801dc76:	4618      	mov	r0, r3
 801dc78:	f04f 0101 	mov.w	r1, #1
 801dc7c:	f7ff fa16 	bl	801d0ac <synopGMAC_giveup_rx_desc_queue>

  /* Free the Tx Descriptor contents */
  synopGMAC_giveup_tx_desc_queue(synopGMACdev, RINGMODE);
 801dc80:	f246 6348 	movw	r3, #26184	; 0x6648
 801dc84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc88:	681b      	ldr	r3, [r3, #0]
 801dc8a:	4618      	mov	r0, r3
 801dc8c:	f04f 0101 	mov.w	r1, #1
 801dc90:	f7ff fb34 	bl	801d2fc <synopGMAC_giveup_tx_desc_queue>

  /* Delete the Cable plug/unplug Timer*/
  if(NULL != SynopGMACDeletePeriodicTimer)
 801dc94:	f645 339c 	movw	r3, #23452	; 0x5b9c
 801dc98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dc9c:	681b      	ldr	r3, [r3, #0]
 801dc9e:	2b00      	cmp	r3, #0
 801dca0:	d005      	beq.n	801dcae <Eth_CloseNetworkInterface+0x9e>
  {
	SynopGMACDeletePeriodicTimer();
 801dca2:	f645 339c 	movw	r3, #23452	; 0x5b9c
 801dca6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dcaa:	681b      	ldr	r3, [r3, #0]
 801dcac:	4798      	blx	r3
  }
  if (Status != DAVEApp_SUCCESS)
  {
    DBG002_WARNING(APP_GID, ETH_CLOSE_ERROR, 0, NULL);
  }
  Status = DAVEApp_SUCCESS;
 801dcae:	f04f 0300 	mov.w	r3, #0
 801dcb2:	607b      	str	r3, [r7, #4]
  return Status;
 801dcb4:	687b      	ldr	r3, [r7, #4]
}
 801dcb6:	4618      	mov	r0, r3
 801dcb8:	f107 0708 	add.w	r7, r7, #8
 801dcbc:	46bd      	mov	sp, r7
 801dcbe:	bd80      	pop	{r7, pc}

0801dcc0 <Eth_TransmitFrames>:
status_t Eth_TransmitFrames
(
  uint8_t *PacketBuffer,
  uint32_t PacketLength
)
{
 801dcc0:	b580      	push	{r7, lr}
 801dcc2:	b08a      	sub	sp, #40	; 0x28
 801dcc4:	af04      	add	r7, sp, #16
 801dcc6:	6078      	str	r0, [r7, #4]
 801dcc8:	6039      	str	r1, [r7, #0]
  /* <<<DD_ETH_PORT_5>>> */
  uint32_t Status = ETH_XMIT_ERROR;
 801dcca:	f04f 0304 	mov.w	r3, #4
 801dcce:	617b      	str	r3, [r7, #20]
  uint32_t OffloadNeeded = 0;
 801dcd0:	f04f 0300 	mov.w	r3, #0
 801dcd4:	613b      	str	r3, [r7, #16]
  int32_t DescStatus = -1;
 801dcd6:	f04f 33ff 	mov.w	r3, #4294967295
 801dcda:	60fb      	str	r3, [r7, #12]
  /* extern uint8_t Eth_TxBuffer[2048]; */
  
  do
  {
	if(NULL == PacketBuffer)
 801dcdc:	687b      	ldr	r3, [r7, #4]
 801dcde:	2b00      	cmp	r3, #0
 801dce0:	d029      	beq.n	801dd36 <Eth_TransmitFrames+0x76>


#ifdef IPC_OFFLOAD

    /* Checksum offloading is required */
    OffloadNeeded = 0x00000001;
 801dce2:	f04f 0301 	mov.w	r3, #1
 801dce6:	613b      	str	r3, [r7, #16]
     * Lets make our DMA know about this
     */
    /*DescStatus = synopGMAC_set_tx_qptr(synopGMACdev, (uint32_t)PacketBuffer,
        PacketLength, (uint32_t)PacketBuffer,0,0,0, OffloadNeeded); */

	DescStatus = synopGMAC_set_tx_qptr(synopGMACdev, (uint32_t)PacketBuffer,
 801dce8:	f246 6348 	movw	r3, #26184	; 0x6648
 801dcec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dcf0:	6819      	ldr	r1, [r3, #0]
 801dcf2:	687a      	ldr	r2, [r7, #4]
 801dcf4:	687b      	ldr	r3, [r7, #4]
 801dcf6:	f04f 0000 	mov.w	r0, #0
 801dcfa:	9000      	str	r0, [sp, #0]
 801dcfc:	f04f 0000 	mov.w	r0, #0
 801dd00:	9001      	str	r0, [sp, #4]
 801dd02:	f04f 0000 	mov.w	r0, #0
 801dd06:	9002      	str	r0, [sp, #8]
 801dd08:	6938      	ldr	r0, [r7, #16]
 801dd0a:	9003      	str	r0, [sp, #12]
 801dd0c:	4608      	mov	r0, r1
 801dd0e:	4611      	mov	r1, r2
 801dd10:	683a      	ldr	r2, [r7, #0]
 801dd12:	f7fe f94b 	bl	801bfac <synopGMAC_set_tx_qptr>
 801dd16:	60f8      	str	r0, [r7, #12]
        PacketLength, (uint32_t)PacketBuffer,0,0,0, OffloadNeeded);

    if(DescStatus < 0)
 801dd18:	68fb      	ldr	r3, [r7, #12]
 801dd1a:	2b00      	cmp	r3, #0
 801dd1c:	db0d      	blt.n	801dd3a <Eth_TransmitFrames+0x7a>
      DBG002_ERROR(APP_GID, ETH_TX_SETUP_ERROR, 0, NULL);
      break;
    }

    /* Now force the DMA to start transmission*/
    synopGMAC_resume_dma_tx(synopGMACdev);
 801dd1e:	f246 6348 	movw	r3, #26184	; 0x6648
 801dd22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dd26:	681b      	ldr	r3, [r3, #0]
 801dd28:	4618      	mov	r0, r3
 801dd2a:	f7fe fc13 	bl	801c554 <synopGMAC_resume_dma_tx>

    Status = DAVEApp_SUCCESS;
 801dd2e:	f04f 0300 	mov.w	r3, #0
 801dd32:	617b      	str	r3, [r7, #20]
 801dd34:	e002      	b.n	801dd3c <Eth_TransmitFrames+0x7c>
  do
  {
	if(NULL == PacketBuffer)
    {
      DBG002_ERROR(APP_GID, ETH_NULL_PARAM, 0, NULL);
      break;
 801dd36:	bf00      	nop
 801dd38:	e000      	b.n	801dd3c <Eth_TransmitFrames+0x7c>
        PacketLength, (uint32_t)PacketBuffer,0,0,0, OffloadNeeded);

    if(DescStatus < 0)
    {
      DBG002_ERROR(APP_GID, ETH_TX_SETUP_ERROR, 0, NULL);
      break;
 801dd3a:	bf00      	nop
    synopGMAC_resume_dma_tx(synopGMACdev);

    Status = DAVEApp_SUCCESS;
  } while (0);

  return Status;
 801dd3c:	697b      	ldr	r3, [r7, #20]
}
 801dd3e:	4618      	mov	r0, r3
 801dd40:	f107 0718 	add.w	r7, r7, #24
 801dd44:	46bd      	mov	sp, r7
 801dd46:	bd80      	pop	{r7, pc}

0801dd48 <Eth_ReceiveData>:
  return Length;
}

#else  /* BUILD_UIP */
status_t Eth_ReceiveData(void)
{
 801dd48:	b5b0      	push	{r4, r5, r7, lr}
 801dd4a:	b094      	sub	sp, #80	; 0x50
 801dd4c:	af08      	add	r7, sp, #32
  /* <<<DD_ETH_PORT_6>>> */
  int32_t DescIndex = 0;
 801dd4e:	f04f 0300 	mov.w	r3, #0
 801dd52:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t Data1 = 0 ;
 801dd54:	f04f 0300 	mov.w	r3, #0
 801dd58:	623b      	str	r3, [r7, #32]
  uint32_t Data2 = 0;
 801dd5a:	f04f 0300 	mov.w	r3, #0
 801dd5e:	61fb      	str	r3, [r7, #28]
  uint32_t Length = 0;
 801dd60:	f04f 0300 	mov.w	r3, #0
 801dd64:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t Status = ETH_RECV_ERROR;
 801dd66:	f04f 0305 	mov.w	r3, #5
 801dd6a:	61bb      	str	r3, [r7, #24]
  uint32_t dma_addr1 = 0;
 801dd6c:	f04f 0300 	mov.w	r3, #0
 801dd70:	617b      	str	r3, [r7, #20]
  uint32_t dma_addr2 = 0;
 801dd72:	f04f 0300 	mov.w	r3, #0
 801dd76:	613b      	str	r3, [r7, #16]
#endif

  /* Handle the Receive Descriptors*/
  do
  {
    DmaDesc *rxdesc = synopGMACdev->RxBusyDesc;
 801dd78:	f246 6348 	movw	r3, #26184	; 0x6648
 801dd7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dd80:	681b      	ldr	r3, [r3, #0]
 801dd82:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801dd84:	627b      	str	r3, [r7, #36]	; 0x24

    DescIndex = synopGMAC_get_rx_qptr(synopGMACdev,
 801dd86:	f246 6348 	movw	r3, #26184	; 0x6648
 801dd8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dd8e:	6819      	ldr	r1, [r3, #0]
    		                          &Status,
 801dd90:	f107 0218 	add.w	r2, r7, #24
    		                          &dma_addr1,
 801dd94:	f107 0314 	add.w	r3, r7, #20
    		                          NULL,
    		                          &Data1,
 801dd98:	f107 0020 	add.w	r0, r7, #32
  /* Handle the Receive Descriptors*/
  do
  {
    DmaDesc *rxdesc = synopGMACdev->RxBusyDesc;

    DescIndex = synopGMAC_get_rx_qptr(synopGMACdev,
 801dd9c:	9000      	str	r0, [sp, #0]
    		                          &Status,
    		                          &dma_addr1,
    		                          NULL,
    		                          &Data1,
    		                          &dma_addr2,
 801dd9e:	f107 0010 	add.w	r0, r7, #16
  /* Handle the Receive Descriptors*/
  do
  {
    DmaDesc *rxdesc = synopGMACdev->RxBusyDesc;

    DescIndex = synopGMAC_get_rx_qptr(synopGMACdev,
 801dda2:	9001      	str	r0, [sp, #4]
 801dda4:	f04f 0000 	mov.w	r0, #0
 801dda8:	9002      	str	r0, [sp, #8]
    		                          &dma_addr1,
    		                          NULL,
    		                          &Data1,
    		                          &dma_addr2,
    		                          NULL,
    		                          &Data2,&ext_status,&time_stamp_high,&time_stamp_low);
 801ddaa:	f107 001c 	add.w	r0, r7, #28
  /* Handle the Receive Descriptors*/
  do
  {
    DmaDesc *rxdesc = synopGMACdev->RxBusyDesc;

    DescIndex = synopGMAC_get_rx_qptr(synopGMACdev,
 801ddae:	9003      	str	r0, [sp, #12]
 801ddb0:	f107 000c 	add.w	r0, r7, #12
 801ddb4:	9004      	str	r0, [sp, #16]
 801ddb6:	f107 0008 	add.w	r0, r7, #8
 801ddba:	9005      	str	r0, [sp, #20]
 801ddbc:	f107 0004 	add.w	r0, r7, #4
 801ddc0:	9006      	str	r0, [sp, #24]
 801ddc2:	4608      	mov	r0, r1
 801ddc4:	4611      	mov	r1, r2
 801ddc6:	461a      	mov	r2, r3
 801ddc8:	f04f 0300 	mov.w	r3, #0
 801ddcc:	f7fe fa42 	bl	801c254 <synopGMAC_get_rx_qptr>
 801ddd0:	62f8      	str	r0, [r7, #44]	; 0x2c
    		                          NULL,
    		                          &Data1,
    		                          &dma_addr2,
    		                          NULL,
    		                          &Data2,&ext_status,&time_stamp_high,&time_stamp_low);
    if(DescIndex >= 0 && Data1 != 0)
 801ddd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ddd4:	2b00      	cmp	r3, #0
 801ddd6:	f2c0 8137 	blt.w	801e048 <Eth_ReceiveData+0x300>
 801ddda:	6a3b      	ldr	r3, [r7, #32]
 801dddc:	2b00      	cmp	r3, #0
 801ddde:	f000 8133 	beq.w	801e048 <Eth_ReceiveData+0x300>
    {
      //TR("Received Data at Rx Descriptor %d for skb 0x%08x whose Status is %08x\n",DescIndex,Data1,Status);

      if(synopGMAC_is_rx_desc_valid(Status))
 801dde2:	69bb      	ldr	r3, [r7, #24]
 801dde4:	4618      	mov	r0, r3
 801dde6:	f7fd fea3 	bl	801bb30 <synopGMAC_is_rx_desc_valid>
 801ddea:	4603      	mov	r3, r0
 801ddec:	2b00      	cmp	r3, #0
 801ddee:	f000 80a8 	beq.w	801df42 <Eth_ReceiveData+0x1fa>
      {
    	  /** Not interested in Ethernet CRC bytes */
        Length =  synopGMAC_get_rx_desc_frame_length(Status) - 4;
 801ddf2:	69bb      	ldr	r3, [r7, #24]
 801ddf4:	4618      	mov	r0, r3
 801ddf6:	f7fd fe55 	bl	801baa4 <synopGMAC_get_rx_desc_frame_length>
 801ddfa:	4603      	mov	r3, r0
 801ddfc:	f1a3 0304 	sub.w	r3, r3, #4
 801de00:	62bb      	str	r3, [r7, #40]	; 0x28

#ifdef IPC_OFFLOAD
        /* Now lets check for the IPC offloading */
        TR("Checksum Offloading will be done now\n");

        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)
 801de02:	f246 6348 	movw	r3, #26184	; 0x6648
 801de06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de0a:	681a      	ldr	r2, [r3, #0]
 801de0c:	69bb      	ldr	r3, [r7, #24]
 801de0e:	4610      	mov	r0, r2
 801de10:	4619      	mov	r1, r3
 801de12:	f7fe ff29 	bl	801cc68 <synopGMAC_is_rx_checksum_error>
        		== RxNoChkError )
        {
          TR("Ip header and TCP/UDP payload checksum Bypassed <Chk Status = 4>\n");
        }

        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)
 801de16:	f246 6348 	movw	r3, #26184	; 0x6648
 801de1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de1e:	681a      	ldr	r2, [r3, #0]
 801de20:	69bb      	ldr	r3, [r7, #24]
 801de22:	4610      	mov	r0, r2
 801de24:	4619      	mov	r1, r3
 801de26:	f7fe ff1f 	bl	801cc68 <synopGMAC_is_rx_checksum_error>
        		== RxIpHdrChkError )
        {
          TR("Error in 16bit IPV4 Header Checksum <Chk Status = 6>  \n");
        }

        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status) == RxLenLT600)
 801de2a:	f246 6348 	movw	r3, #26184	; 0x6648
 801de2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de32:	681a      	ldr	r2, [r3, #0]
 801de34:	69bb      	ldr	r3, [r7, #24]
 801de36:	4610      	mov	r0, r2
 801de38:	4619      	mov	r1, r3
 801de3a:	f7fe ff15 	bl	801cc68 <synopGMAC_is_rx_checksum_error>
        {
          TR("IEEE 802.3 type frame with Length field Lesss than 0x0600 \
        		  <Chk Status = 0>\n");
        }

        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status)
 801de3e:	f246 6348 	movw	r3, #26184	; 0x6648
 801de42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de46:	681a      	ldr	r2, [r3, #0]
 801de48:	69bb      	ldr	r3, [r7, #24]
 801de4a:	4610      	mov	r0, r2
 801de4c:	4619      	mov	r1, r3
 801de4e:	f7fe ff0b 	bl	801cc68 <synopGMAC_is_rx_checksum_error>
        {
          TR("Ip header and TCP/UDP payload checksum Bypassed \
        		  <Chk Status = 1>");
        }

        if (synopGMAC_is_rx_checksum_error(synopGMACdev, Status) == RxChkBypass)
 801de52:	f246 6348 	movw	r3, #26184	; 0x6648
 801de56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de5a:	681a      	ldr	r2, [r3, #0]
 801de5c:	69bb      	ldr	r3, [r7, #24]
 801de5e:	4610      	mov	r0, r2
 801de60:	4619      	mov	r1, r3
 801de62:	f7fe ff01 	bl	801cc68 <synopGMAC_is_rx_checksum_error>
        {
          TR("Ip header and TCP/UDP payload checksum Bypassed \
        		  <Chk Status = 3>");
        }

        if(synopGMAC_is_rx_checksum_error(synopGMACdev, Status) ==
 801de66:	f246 6348 	movw	r3, #26184	; 0x6648
 801de6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de6e:	681a      	ldr	r2, [r3, #0]
 801de70:	69bb      	ldr	r3, [r7, #24]
 801de72:	4610      	mov	r0, r2
 801de74:	4619      	mov	r1, r3
 801de76:	f7fe fef7 	bl	801cc68 <synopGMAC_is_rx_checksum_error>
        		RxPayLoadChkError)
        {
          TR("TCP/UDP payload checksum Error <Chk Status = 5>");
        }

        if(synopGMAC_is_rx_checksum_error(synopGMACdev, Status) ==
 801de7a:	f246 6348 	movw	r3, #26184	; 0x6648
 801de7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de82:	681a      	ldr	r2, [r3, #0]
 801de84:	69bb      	ldr	r3, [r7, #24]
 801de86:	4610      	mov	r0, r2
 801de88:	4619      	mov	r1, r3
 801de8a:	f7fe feed 	bl	801cc68 <synopGMAC_is_rx_checksum_error>
        {
          TR("Both IP header and Payload Checksum Error <Chk Status = 7>");
        }
#endif /* IPC_OFFLOAD */

        synopGMACdev->NetStatistics.RxPackets++;
 801de8e:	f246 6348 	movw	r3, #26184	; 0x6648
 801de92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801de96:	681b      	ldr	r3, [r3, #0]
 801de98:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801de9a:	f102 0201 	add.w	r2, r2, #1
 801de9e:	651a      	str	r2, [r3, #80]	; 0x50
        synopGMACdev->NetStatistics.RxBytes += Length;
 801dea0:	f246 6348 	movw	r3, #26184	; 0x6648
 801dea4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dea8:	681a      	ldr	r2, [r3, #0]
 801deaa:	f246 6348 	movw	r3, #26184	; 0x6648
 801deae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801deb2:	681b      	ldr	r3, [r3, #0]
 801deb4:	6d99      	ldr	r1, [r3, #88]	; 0x58
 801deb6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801deb8:	18cb      	adds	r3, r1, r3
 801deba:	6593      	str	r3, [r2, #88]	; 0x58

        /* Send the packet buffer to Eth_Received_Data_Handler for processing */
        Eth_Received_Data_Handler(rxdesc->buffer1, Length);
 801debc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801debe:	689b      	ldr	r3, [r3, #8]
 801dec0:	4618      	mov	r0, r3
 801dec2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801dec4:	f7f3 fa1c 	bl	8011300 <Eth_Received_Data_Handler>

		if(synopGMAC_is_rx_desc_chained(rxdesc))
 801dec8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801deca:	f7fd ff4b 	bl	801bd64 <synopGMAC_is_rx_desc_chained>
 801dece:	4603      	mov	r3, r0
 801ded0:	2b00      	cmp	r3, #0
 801ded2:	d00b      	beq.n	801deec <Eth_ReceiveData+0x1a4>
		{
	   		synopGMACdev->RxBusyDesc = (DmaDesc *)rxdesc->data2;
 801ded4:	f246 6348 	movw	r3, #26184	; 0x6648
 801ded8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dedc:	681b      	ldr	r3, [r3, #0]
 801dede:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801dee0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 801dee2:	649a      	str	r2, [r3, #72]	; 0x48
			synopGMAC_rx_desc_init_chain(rxdesc);
 801dee4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801dee6:	f7fd fc93 	bl	801b810 <synopGMAC_rx_desc_init_chain>
 801deea:	e07f      	b.n	801dfec <Eth_ReceiveData+0x2a4>
			//synopGMAC_rx_desc_init_chain(rxdesc, synopGMAC_is_last_rx_desc(synopGMACdev,rxdesc),0,0);
		}
		else
		{
			synopGMACdev->RxBusyDesc = synopGMAC_is_last_rx_desc(synopGMACdev,rxdesc) ? synopGMACdev->RxDesc : (rxdesc + 1);
 801deec:	f246 6348 	movw	r3, #26184	; 0x6648
 801def0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801def4:	681c      	ldr	r4, [r3, #0]
 801def6:	f246 6348 	movw	r3, #26184	; 0x6648
 801defa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801defe:	681b      	ldr	r3, [r3, #0]
 801df00:	4618      	mov	r0, r3
 801df02:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801df04:	f7fd fef2 	bl	801bcec <synopGMAC_is_last_rx_desc>
 801df08:	4603      	mov	r3, r0
 801df0a:	2b00      	cmp	r3, #0
 801df0c:	d006      	beq.n	801df1c <Eth_ReceiveData+0x1d4>
 801df0e:	f246 6348 	movw	r3, #26184	; 0x6648
 801df12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801df16:	681b      	ldr	r3, [r3, #0]
 801df18:	69db      	ldr	r3, [r3, #28]
 801df1a:	e002      	b.n	801df22 <Eth_ReceiveData+0x1da>
 801df1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801df1e:	f103 0328 	add.w	r3, r3, #40	; 0x28
 801df22:	64a3      	str	r3, [r4, #72]	; 0x48
			synopGMAC_rx_desc_init_ring(rxdesc, synopGMAC_is_last_rx_desc(synopGMACdev,rxdesc));
 801df24:	f246 6348 	movw	r3, #26184	; 0x6648
 801df28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801df2c:	681b      	ldr	r3, [r3, #0]
 801df2e:	4618      	mov	r0, r3
 801df30:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801df32:	f7fd fedb 	bl	801bcec <synopGMAC_is_last_rx_desc>
 801df36:	4603      	mov	r3, r0
 801df38:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801df3a:	4619      	mov	r1, r3
 801df3c:	f7fd fc24 	bl	801b788 <synopGMAC_rx_desc_init_ring>
 801df40:	e054      	b.n	801dfec <Eth_ReceiveData+0x2a4>
		}
      }
      else
      {
    	  synopGMACdev->NetStatistics.RxErrors++;
 801df42:	f246 6348 	movw	r3, #26184	; 0x6648
 801df46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801df4a:	681b      	ldr	r3, [r3, #0]
 801df4c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 801df4e:	f102 0201 	add.w	r2, r2, #1
 801df52:	661a      	str	r2, [r3, #96]	; 0x60
        synopGMACdev->NetStatistics.Collisions     +=
 801df54:	f246 6348 	movw	r3, #26184	; 0x6648
 801df58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801df5c:	681c      	ldr	r4, [r3, #0]
 801df5e:	f246 6348 	movw	r3, #26184	; 0x6648
 801df62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801df66:	681b      	ldr	r3, [r3, #0]
 801df68:	6f5d      	ldr	r5, [r3, #116]	; 0x74
            synopGMAC_is_rx_frame_collision(Status);
 801df6a:	69bb      	ldr	r3, [r7, #24]
 801df6c:	4618      	mov	r0, r3
 801df6e:	f7fd fe75 	bl	801bc5c <synopGMAC_is_rx_frame_collision>
 801df72:	4603      	mov	r3, r0
		}
      }
      else
      {
    	  synopGMACdev->NetStatistics.RxErrors++;
        synopGMACdev->NetStatistics.Collisions     +=
 801df74:	18eb      	adds	r3, r5, r3
 801df76:	6763      	str	r3, [r4, #116]	; 0x74
            synopGMAC_is_rx_frame_collision(Status);
        synopGMACdev->NetStatistics.RxCrcErrors    +=
 801df78:	f246 6348 	movw	r3, #26184	; 0x6648
 801df7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801df80:	681c      	ldr	r4, [r3, #0]
 801df82:	f246 6348 	movw	r3, #26184	; 0x6648
 801df86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801df8a:	681b      	ldr	r3, [r3, #0]
 801df8c:	f8d3 5080 	ldr.w	r5, [r3, #128]	; 0x80
            synopGMAC_is_rx_crc(Status);
 801df90:	69bb      	ldr	r3, [r7, #24]
 801df92:	4618      	mov	r0, r3
 801df94:	f7fd fe74 	bl	801bc80 <synopGMAC_is_rx_crc>
 801df98:	4603      	mov	r3, r0
      else
      {
    	  synopGMACdev->NetStatistics.RxErrors++;
        synopGMACdev->NetStatistics.Collisions     +=
            synopGMAC_is_rx_frame_collision(Status);
        synopGMACdev->NetStatistics.RxCrcErrors    +=
 801df9a:	18eb      	adds	r3, r5, r3
 801df9c:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
            synopGMAC_is_rx_crc(Status);
        synopGMACdev->NetStatistics.RxFrameErrors  +=
 801dfa0:	f246 6348 	movw	r3, #26184	; 0x6648
 801dfa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dfa8:	681c      	ldr	r4, [r3, #0]
 801dfaa:	f246 6348 	movw	r3, #26184	; 0x6648
 801dfae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dfb2:	681b      	ldr	r3, [r3, #0]
 801dfb4:	f8d3 5084 	ldr.w	r5, [r3, #132]	; 0x84
            synopGMAC_is_frame_dribbling_errors(Status);
 801dfb8:	69bb      	ldr	r3, [r7, #24]
 801dfba:	4618      	mov	r0, r3
 801dfbc:	f7fd fe72 	bl	801bca4 <synopGMAC_is_frame_dribbling_errors>
 801dfc0:	4603      	mov	r3, r0
    	  synopGMACdev->NetStatistics.RxErrors++;
        synopGMACdev->NetStatistics.Collisions     +=
            synopGMAC_is_rx_frame_collision(Status);
        synopGMACdev->NetStatistics.RxCrcErrors    +=
            synopGMAC_is_rx_crc(Status);
        synopGMACdev->NetStatistics.RxFrameErrors  +=
 801dfc2:	18eb      	adds	r3, r5, r3
 801dfc4:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
            synopGMAC_is_frame_dribbling_errors(Status);
        synopGMACdev->NetStatistics.RxLengthErrors +=
 801dfc8:	f246 6348 	movw	r3, #26184	; 0x6648
 801dfcc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dfd0:	681c      	ldr	r4, [r3, #0]
 801dfd2:	f246 6348 	movw	r3, #26184	; 0x6648
 801dfd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dfda:	681b      	ldr	r3, [r3, #0]
 801dfdc:	6f9d      	ldr	r5, [r3, #120]	; 0x78
            synopGMAC_is_rx_frame_length_errors(Status);
 801dfde:	69bb      	ldr	r3, [r7, #24]
 801dfe0:	4618      	mov	r0, r3
 801dfe2:	f7fd fe71 	bl	801bcc8 <synopGMAC_is_rx_frame_length_errors>
 801dfe6:	4603      	mov	r3, r0
            synopGMAC_is_rx_frame_collision(Status);
        synopGMACdev->NetStatistics.RxCrcErrors    +=
            synopGMAC_is_rx_crc(Status);
        synopGMACdev->NetStatistics.RxFrameErrors  +=
            synopGMAC_is_frame_dribbling_errors(Status);
        synopGMACdev->NetStatistics.RxLengthErrors +=
 801dfe8:	18eb      	adds	r3, r5, r3
 801dfea:	67a3      	str	r3, [r4, #120]	; 0x78
            synopGMAC_is_rx_frame_length_errors(Status);
      }

      /* Return the descriptor back to DMA */
      DescIndex = synopGMAC_set_rx_qptr(synopGMACdev,
 801dfec:	f246 6348 	movw	r3, #26184	; 0x6648
 801dff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dff4:	6819      	ldr	r1, [r3, #0]
                                        (uint32_t)&Eth_RxBuffer[DescIndex * ETH_PACKET_SIZE],
 801dff6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dff8:	f240 52dc 	movw	r2, #1500	; 0x5dc
 801dffc:	fb02 f303 	mul.w	r3, r2, r3
 801e000:	f103 0214 	add.w	r2, r3, #20
 801e004:	f240 03f0 	movw	r3, #240	; 0xf0
 801e008:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801e00c:	18d3      	adds	r3, r2, r3
        synopGMACdev->NetStatistics.RxLengthErrors +=
            synopGMAC_is_rx_frame_length_errors(Status);
      }

      /* Return the descriptor back to DMA */
      DescIndex = synopGMAC_set_rx_qptr(synopGMACdev,
 801e00e:	461a      	mov	r2, r3
                                        (uint32_t)&Eth_RxBuffer[DescIndex * ETH_PACKET_SIZE],
    		                            ETH_PACKET_SIZE,
                                        (uint32_t)&Eth_RxBuffer[DescIndex * ETH_PACKET_SIZE],
 801e010:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e012:	f240 50dc 	movw	r0, #1500	; 0x5dc
 801e016:	fb00 f303 	mul.w	r3, r0, r3
 801e01a:	f103 0014 	add.w	r0, r3, #20
 801e01e:	f240 03f0 	movw	r3, #240	; 0xf0
 801e022:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801e026:	18c3      	adds	r3, r0, r3
        synopGMACdev->NetStatistics.RxLengthErrors +=
            synopGMAC_is_rx_frame_length_errors(Status);
      }

      /* Return the descriptor back to DMA */
      DescIndex = synopGMAC_set_rx_qptr(synopGMACdev,
 801e028:	f04f 0000 	mov.w	r0, #0
 801e02c:	9000      	str	r0, [sp, #0]
 801e02e:	f04f 0000 	mov.w	r0, #0
 801e032:	9001      	str	r0, [sp, #4]
 801e034:	f04f 0000 	mov.w	r0, #0
 801e038:	9002      	str	r0, [sp, #8]
 801e03a:	4608      	mov	r0, r1
 801e03c:	4611      	mov	r1, r2
 801e03e:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
 801e042:	f7fe f853 	bl	801c0ec <synopGMAC_set_rx_qptr>
 801e046:	62f8      	str	r0, [r7, #44]	; 0x2c
      if(DescIndex < 0)
      {
        TR("Cannot set Rx Descriptor\n");
      }
    }
    Status = DAVEApp_SUCCESS;
 801e048:	f04f 0300 	mov.w	r3, #0
 801e04c:	61bb      	str	r3, [r7, #24]
  }while(DescIndex >= 0);
 801e04e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e050:	2b00      	cmp	r3, #0
 801e052:	f6bf ae91 	bge.w	801dd78 <Eth_ReceiveData+0x30>

  return Status;
 801e056:	69bb      	ldr	r3, [r7, #24]
}
 801e058:	4618      	mov	r0, r3
 801e05a:	f107 0730 	add.w	r7, r7, #48	; 0x30
 801e05e:	46bd      	mov	sp, r7
 801e060:	bdb0      	pop	{r4, r5, r7, pc}
 801e062:	bf00      	nop

0801e064 <ETH0_0_IRQHandler>:
#endif  /* BUILD_UIP */

void IRQ_Hdlr_108(void)
{
 801e064:	b580      	push	{r7, lr}
 801e066:	b08a      	sub	sp, #40	; 0x28
 801e068:	af04      	add	r7, sp, #16

  /* Read the Dma interrupt status to know whether the interrupt got generated
   * by our device or not
   *  <<<DD_ETH_PORT_7_1>>>
   */
  dma_status_reg = synopGMACReadReg((uint32_t *)ETH_BASE, DmaStatus);
 801e06a:	f44f 4050 	mov.w	r0, #53248	; 0xd000
 801e06e:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e072:	f04f 0114 	mov.w	r1, #20
 801e076:	f7ff fa95 	bl	801d5a4 <synopGMACReadReg>
 801e07a:	6138      	str	r0, [r7, #16]

  if(dma_status_reg == 0)
 801e07c:	693b      	ldr	r3, [r7, #16]
 801e07e:	2b00      	cmp	r3, #0
 801e080:	f000 818d 	beq.w	801e39e <ETH0_0_IRQHandler+0x33a>
    DBG002_ERROR(APP_GID, ETH_NO_INTERRUPT, 0, NULL);
    return;
  }

  /* Disable all interrupts */
  synopGMAC_disable_interrupt_all(synopGMACdev);
 801e084:	f246 6348 	movw	r3, #26184	; 0x6648
 801e088:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e08c:	681b      	ldr	r3, [r3, #0]
 801e08e:	4618      	mov	r0, r3
 801e090:	f7fe fa04 	bl	801c49c <synopGMAC_disable_interrupt_all>

  if(dma_status_reg & GmacPmtIntr)
 801e094:	693b      	ldr	r3, [r7, #16]
 801e096:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 801e09a:	2b00      	cmp	r3, #0
 801e09c:	d007      	beq.n	801e0ae <ETH0_0_IRQHandler+0x4a>
  {
    TR("Interrupt due to PMT module\n");
    synopGMAC_powerup_mac(synopGMACdev);
 801e09e:	f246 6348 	movw	r3, #26184	; 0x6648
 801e0a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e0a6:	681b      	ldr	r3, [r3, #0]
 801e0a8:	4618      	mov	r0, r3
 801e0aa:	f7fe feeb 	bl	801ce84 <synopGMAC_powerup_mac>
  {
    TR("Interrupt due to GMAC LINE module\n");
  }

  /* Now lets handle the DMA interrupts*/
  interrupt = synopGMAC_get_interrupt_type(synopGMACdev);
 801e0ae:	f246 6348 	movw	r3, #26184	; 0x6648
 801e0b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e0b6:	681b      	ldr	r3, [r3, #0]
 801e0b8:	4618      	mov	r0, r3
 801e0ba:	f7fe f96f 	bl	801c39c <synopGMAC_get_interrupt_type>
 801e0be:	60f8      	str	r0, [r7, #12]

  if(interrupt & synopGMACDmaError)
 801e0c0:	68fb      	ldr	r3, [r7, #12]
 801e0c2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801e0c6:	2b00      	cmp	r3, #0
 801e0c8:	f000 809c 	beq.w	801e204 <ETH0_0_IRQHandler+0x1a0>
  {
    /* <<<DD_ETH_PORT_7_2>>> */
    /* after soft reset, configure the MAC address to default value */
    uint8_t mac_addr0[6] = DEFAULT_MAC_ADDRESS;
 801e0cc:	f646 0388 	movw	r3, #26760	; 0x6888
 801e0d0:	f6c0 0302 	movt	r3, #2050	; 0x802
 801e0d4:	463a      	mov	r2, r7
 801e0d6:	6818      	ldr	r0, [r3, #0]
 801e0d8:	6010      	str	r0, [r2, #0]
 801e0da:	889b      	ldrh	r3, [r3, #4]
 801e0dc:	8093      	strh	r3, [r2, #4]

    TR("Fatal Bus Error Interrupt Seen\n");

    synopGMAC_disable_dma_tx(synopGMACdev);
 801e0de:	f246 6348 	movw	r3, #26184	; 0x6648
 801e0e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e0e6:	681b      	ldr	r3, [r3, #0]
 801e0e8:	4618      	mov	r0, r3
 801e0ea:	f7fe facd 	bl	801c688 <synopGMAC_disable_dma_tx>
    synopGMAC_disable_dma_rx(synopGMACdev);
 801e0ee:	f246 6348 	movw	r3, #26184	; 0x6648
 801e0f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e0f6:	681b      	ldr	r3, [r3, #0]
 801e0f8:	4618      	mov	r0, r3
 801e0fa:	f7fe fae1 	bl	801c6c0 <synopGMAC_disable_dma_rx>

    synopGMAC_take_desc_ownership_tx(synopGMACdev);
 801e0fe:	f246 6348 	movw	r3, #26184	; 0x6648
 801e102:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e106:	681b      	ldr	r3, [r3, #0]
 801e108:	4618      	mov	r0, r3
 801e10a:	f7fe fa8b 	bl	801c624 <synopGMAC_take_desc_ownership_tx>
    synopGMAC_take_desc_ownership_rx(synopGMACdev);
 801e10e:	f246 6348 	movw	r3, #26184	; 0x6648
 801e112:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e116:	681b      	ldr	r3, [r3, #0]
 801e118:	4618      	mov	r0, r3
 801e11a:	f7fe fa51 	bl	801c5c0 <synopGMAC_take_desc_ownership_rx>

    synopGMAC_init_tx_rx_desc_queue(synopGMACdev);
 801e11e:	f246 6348 	movw	r3, #26184	; 0x6648
 801e122:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e126:	681b      	ldr	r3, [r3, #0]
 801e128:	4618      	mov	r0, r3
 801e12a:	f7fd fb9d 	bl	801b868 <synopGMAC_init_tx_rx_desc_queue>

    /* reset the DMA engine and the GMAC IP */
    synopGMAC_reset(synopGMACdev);
 801e12e:	f246 6348 	movw	r3, #26184	; 0x6648
 801e132:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e136:	681b      	ldr	r3, [r3, #0]
 801e138:	4618      	mov	r0, r3
 801e13a:	f7fc fcdf 	bl	801aafc <synopGMAC_reset>

    synopGMAC_set_mac_addr(synopGMACdev, GmacAddr0High, GmacAddr0Low, mac_addr0);
 801e13e:	f246 6348 	movw	r3, #26184	; 0x6648
 801e142:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e146:	681a      	ldr	r2, [r3, #0]
 801e148:	463b      	mov	r3, r7
 801e14a:	4610      	mov	r0, r2
 801e14c:	f04f 0140 	mov.w	r1, #64	; 0x40
 801e150:	f04f 0244 	mov.w	r2, #68	; 0x44
 801e154:	f7fd fa60 	bl	801b618 <synopGMAC_set_mac_addr>

    synopGMAC_dma_bus_mode_init(synopGMACdev, DmaFixedBurstEnable|
 801e158:	f246 6348 	movw	r3, #26184	; 0x6648
 801e15c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e160:	681b      	ldr	r3, [r3, #0]
 801e162:	4618      	mov	r0, r3
 801e164:	f640 0108 	movw	r1, #2056	; 0x808
 801e168:	f2c0 0101 	movt	r1, #1
 801e16c:	f7fc fcfc 	bl	801ab68 <synopGMAC_dma_bus_mode_init>
    		                    DmaBurstLength8 | DmaDescriptorSkip2 );

    synopGMAC_dma_control_init(synopGMACdev, DmaStoreAndForward);
 801e170:	f246 6348 	movw	r3, #26184	; 0x6648
 801e174:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e178:	681b      	ldr	r3, [r3, #0]
 801e17a:	4618      	mov	r0, r3
 801e17c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 801e180:	f7fc fd06 	bl	801ab90 <synopGMAC_dma_control_init>

    synopGMAC_init_rx_desc_base(synopGMACdev);
 801e184:	f246 6348 	movw	r3, #26184	; 0x6648
 801e188:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e18c:	681b      	ldr	r3, [r3, #0]
 801e18e:	4618      	mov	r0, r3
 801e190:	f7fd fbd0 	bl	801b934 <synopGMAC_init_rx_desc_base>

    synopGMAC_init_tx_desc_base(synopGMACdev);
 801e194:	f246 6348 	movw	r3, #26184	; 0x6648
 801e198:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e19c:	681b      	ldr	r3, [r3, #0]
 801e19e:	4618      	mov	r0, r3
 801e1a0:	f7fd fbdc 	bl	801b95c <synopGMAC_init_tx_desc_base>

    synopGMAC_mac_init(synopGMACdev);
 801e1a4:	f246 6348 	movw	r3, #26184	; 0x6648
 801e1a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e1ac:	681b      	ldr	r3, [r3, #0]
 801e1ae:	4618      	mov	r0, r3
 801e1b0:	f7fd f97c 	bl	801b4ac <synopGMAC_mac_init>

    /* To enable Multicast */
    synopGMAC_multicast_enable(synopGMACdev);
 801e1b4:	f246 6348 	movw	r3, #26184	; 0x6648
 801e1b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e1bc:	681b      	ldr	r3, [r3, #0]
 801e1be:	4618      	mov	r0, r3
 801e1c0:	f7fc fffc 	bl	801b1bc <synopGMAC_multicast_enable>

    synopGMAC_multicast_hash_filter_enable(synopGMACdev);
 801e1c4:	f246 6348 	movw	r3, #26184	; 0x6648
 801e1c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e1cc:	681b      	ldr	r3, [r3, #0]
 801e1ce:	4618      	mov	r0, r3
 801e1d0:	f7fd f818 	bl	801b204 <synopGMAC_multicast_hash_filter_enable>
   /* To enable Broadcast */
    synopGMAC_broadcast_enable(synopGMACdev);
 801e1d4:	f246 6348 	movw	r3, #26184	; 0x6648
 801e1d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e1dc:	681b      	ldr	r3, [r3, #0]
 801e1de:	4618      	mov	r0, r3
 801e1e0:	f7fc ffc8 	bl	801b174 <synopGMAC_broadcast_enable>

    synopGMAC_enable_dma_rx(synopGMACdev);
 801e1e4:	f246 6348 	movw	r3, #26184	; 0x6648
 801e1e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e1ec:	681b      	ldr	r3, [r3, #0]
 801e1ee:	4618      	mov	r0, r3
 801e1f0:	f7fe f978 	bl	801c4e4 <synopGMAC_enable_dma_rx>

    synopGMAC_enable_dma_tx(synopGMACdev);
 801e1f4:	f246 6348 	movw	r3, #26184	; 0x6648
 801e1f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e1fc:	681b      	ldr	r3, [r3, #0]
 801e1fe:	4618      	mov	r0, r3
 801e200:	f7fe f98c 	bl	801c51c <synopGMAC_enable_dma_tx>
  }

  if(interrupt & synopGMACDmaRxNormal)
 801e204:	68fb      	ldr	r3, [r7, #12]
 801e206:	f003 0301 	and.w	r3, r3, #1
 801e20a:	2b00      	cmp	r3, #0
 801e20c:	d001      	beq.n	801e212 <ETH0_0_IRQHandler+0x1ae>
    /* <<<DD_ETH_PORT_7_3>>>
     * Send the packet to the TCP/IP stack.
     * This receive function retrieves packet from descriptor and delivers to
     * the TCP/IP stack.
     */
    Eth_ReceiveData();
 801e20e:	f7ff fd9b 	bl	801dd48 <Eth_ReceiveData>
  }

  if(interrupt & synopGMACDmaRxAbnormal)
 801e212:	68fb      	ldr	r3, [r7, #12]
 801e214:	f003 0302 	and.w	r3, r3, #2
 801e218:	2b00      	cmp	r3, #0
 801e21a:	d017      	beq.n	801e24c <ETH0_0_IRQHandler+0x1e8>
  {
    TR("Abnormal Rx Interrupt Seen\n");

    if(GMAC_Power_down == 0)
 801e21c:	f246 6344 	movw	r3, #26180	; 0x6644
 801e220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e224:	681b      	ldr	r3, [r3, #0]
 801e226:	2b00      	cmp	r3, #0
 801e228:	d110      	bne.n	801e24c <ETH0_0_IRQHandler+0x1e8>
    {
      /* If Mac is not in powerdown */
      synopGMACdev->NetStatistics.RxOverErrors++;
 801e22a:	f246 6348 	movw	r3, #26184	; 0x6648
 801e22e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e232:	681b      	ldr	r3, [r3, #0]
 801e234:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 801e236:	f102 0201 	add.w	r2, r2, #1
 801e23a:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Now Descriptors have been created in synop_handle_received_data(). 
       * Just issue a poll demand to resume DMA operation
       */
      synopGMAC_resume_dma_rx(synopGMACdev);
 801e23c:	f246 6348 	movw	r3, #26184	; 0x6648
 801e240:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e244:	681b      	ldr	r3, [r3, #0]
 801e246:	4618      	mov	r0, r3
 801e248:	f7fe f996 	bl	801c578 <synopGMAC_resume_dma_rx>
    }
  }

  if(interrupt & synopGMACDmaRxStopped)
 801e24c:	68fb      	ldr	r3, [r7, #12]
 801e24e:	f003 0304 	and.w	r3, r3, #4
 801e252:	2b00      	cmp	r3, #0
 801e254:	d050      	beq.n	801e2f8 <ETH0_0_IRQHandler+0x294>
  {
    /* <<<DD_ETH_PORT_7_4>>> */
	  uint32_t DescCount = 0;
 801e256:	f04f 0300 	mov.w	r3, #0
 801e25a:	617b      	str	r3, [r7, #20]

	  /* Receiver gone in to stopped state */
    TR("Receiver stopped seeing Rx interrupts\n");

    if(GMAC_Power_down == 0)
 801e25c:	f246 6344 	movw	r3, #26180	; 0x6644
 801e260:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e264:	681b      	ldr	r3, [r3, #0]
 801e266:	2b00      	cmp	r3, #0
 801e268:	d146      	bne.n	801e2f8 <ETH0_0_IRQHandler+0x294>
    {
      /* If Mac is not in powerdown */
      synopGMACdev->NetStatistics.RxOverErrors++;
 801e26a:	f246 6348 	movw	r3, #26184	; 0x6648
 801e26e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e272:	681b      	ldr	r3, [r3, #0]
 801e274:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 801e276:	f102 0201 	add.w	r2, r2, #1
 801e27a:	67da      	str	r2, [r3, #124]	; 0x7c
      do
      {
          /* Set Rx Q Pointer */
          status = synopGMAC_set_rx_qptr(synopGMACdev,
 801e27c:	f246 6348 	movw	r3, #26184	; 0x6648
 801e280:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e284:	6819      	ldr	r1, [r3, #0]
        		                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
 801e286:	697b      	ldr	r3, [r7, #20]
 801e288:	f240 52dc 	movw	r2, #1500	; 0x5dc
 801e28c:	fb02 f303 	mul.w	r3, r2, r3
 801e290:	f103 0214 	add.w	r2, r3, #20
 801e294:	f240 03f0 	movw	r3, #240	; 0xf0
 801e298:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801e29c:	18d3      	adds	r3, r2, r3
      /* If Mac is not in powerdown */
      synopGMACdev->NetStatistics.RxOverErrors++;
      do
      {
          /* Set Rx Q Pointer */
          status = synopGMAC_set_rx_qptr(synopGMACdev,
 801e29e:	461a      	mov	r2, r3
        		                 (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
              		             ETH_PACKET_SIZE,
              		             (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
 801e2a0:	697b      	ldr	r3, [r7, #20]
 801e2a2:	f240 50dc 	movw	r0, #1500	; 0x5dc
 801e2a6:	fb00 f303 	mul.w	r3, r0, r3
 801e2aa:	f103 0014 	add.w	r0, r3, #20
 801e2ae:	f240 03f0 	movw	r3, #240	; 0xf0
 801e2b2:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801e2b6:	18c3      	adds	r3, r0, r3
      /* If Mac is not in powerdown */
      synopGMACdev->NetStatistics.RxOverErrors++;
      do
      {
          /* Set Rx Q Pointer */
          status = synopGMAC_set_rx_qptr(synopGMACdev,
 801e2b8:	f04f 0000 	mov.w	r0, #0
 801e2bc:	9000      	str	r0, [sp, #0]
 801e2be:	f04f 0000 	mov.w	r0, #0
 801e2c2:	9001      	str	r0, [sp, #4]
 801e2c4:	f04f 0000 	mov.w	r0, #0
 801e2c8:	9002      	str	r0, [sp, #8]
 801e2ca:	4608      	mov	r0, r1
 801e2cc:	4611      	mov	r1, r2
 801e2ce:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
 801e2d2:	f7fd ff0b 	bl	801c0ec <synopGMAC_set_rx_qptr>
 801e2d6:	4603      	mov	r3, r0
 801e2d8:	60bb      	str	r3, [r7, #8]
              		             (uint32_t)&Eth_RxBuffer[DescCount * ETH_PACKET_SIZE],
              		             0,0,0);

          //TR("Set Rx Descriptor no %08x \n",status);

          DescCount++;
 801e2da:	697b      	ldr	r3, [r7, #20]
 801e2dc:	f103 0301 	add.w	r3, r3, #1
 801e2e0:	617b      	str	r3, [r7, #20]
      }while(status >= 0 && (DescCount < TRANSMIT_DESC_SIZE));
 801e2e2:	697b      	ldr	r3, [r7, #20]
 801e2e4:	2b05      	cmp	r3, #5
 801e2e6:	d9c9      	bls.n	801e27c <ETH0_0_IRQHandler+0x218>

      synopGMAC_enable_dma_rx(synopGMACdev);
 801e2e8:	f246 6348 	movw	r3, #26184	; 0x6648
 801e2ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e2f0:	681b      	ldr	r3, [r3, #0]
 801e2f2:	4618      	mov	r0, r3
 801e2f4:	f7fe f8f6 	bl	801c4e4 <synopGMAC_enable_dma_rx>
    }
  }

  if(interrupt & synopGMACDmaTxNormal)
 801e2f8:	68fb      	ldr	r3, [r7, #12]
 801e2fa:	f003 0308 	and.w	r3, r3, #8
 801e2fe:	2b00      	cmp	r3, #0
 801e300:	d007      	beq.n	801e312 <ETH0_0_IRQHandler+0x2ae>
  {
    //xmit function has done its job
    TR("Finished Normal Transmission \n");

    /* Call function to update statistics. */
    synop_handle_transmit_over(synopGMACdev);
 801e302:	f246 6348 	movw	r3, #26184	; 0x6648
 801e306:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e30a:	681b      	ldr	r3, [r3, #0]
 801e30c:	4618      	mov	r0, r3
 801e30e:	f7ff f865 	bl	801d3dc <synop_handle_transmit_over>
  }

  if(interrupt & synopGMACDmaTxAbnormal)
 801e312:	68fb      	ldr	r3, [r7, #12]
 801e314:	f003 0310 	and.w	r3, r3, #16
 801e318:	2b00      	cmp	r3, #0
 801e31a:	d00e      	beq.n	801e33a <ETH0_0_IRQHandler+0x2d6>
  {
    TR("Abnormal Tx Interrupt Seen\n");

    if(GMAC_Power_down == 0)
 801e31c:	f246 6344 	movw	r3, #26180	; 0x6644
 801e320:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e324:	681b      	ldr	r3, [r3, #0]
 801e326:	2b00      	cmp	r3, #0
 801e328:	d107      	bne.n	801e33a <ETH0_0_IRQHandler+0x2d6>
    {
      /* If Mac is not in powerdown */
      synop_handle_transmit_over(synopGMACdev);
 801e32a:	f246 6348 	movw	r3, #26184	; 0x6648
 801e32e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e332:	681b      	ldr	r3, [r3, #0]
 801e334:	4618      	mov	r0, r3
 801e336:	f7ff f851 	bl	801d3dc <synop_handle_transmit_over>
    }
  }

  if(interrupt & synopGMACDmaTxStopped)
 801e33a:	68fb      	ldr	r3, [r7, #12]
 801e33c:	f003 0320 	and.w	r3, r3, #32
 801e340:	2b00      	cmp	r3, #0
 801e342:	d01e      	beq.n	801e382 <ETH0_0_IRQHandler+0x31e>
  {
    /* <<<DD_ETH_PORT_7_5>>> */
    TR("Transmitter stopped sending the packets\n");

    if(GMAC_Power_down == 0)
 801e344:	f246 6344 	movw	r3, #26180	; 0x6644
 801e348:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e34c:	681b      	ldr	r3, [r3, #0]
 801e34e:	2b00      	cmp	r3, #0
 801e350:	d117      	bne.n	801e382 <ETH0_0_IRQHandler+0x31e>
    {
      /* If Mac is not in powerdown */
      synopGMAC_disable_dma_tx(synopGMACdev);
 801e352:	f246 6348 	movw	r3, #26184	; 0x6648
 801e356:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e35a:	681b      	ldr	r3, [r3, #0]
 801e35c:	4618      	mov	r0, r3
 801e35e:	f7fe f993 	bl	801c688 <synopGMAC_disable_dma_tx>

      synopGMAC_take_desc_ownership_tx(synopGMACdev);
 801e362:	f246 6348 	movw	r3, #26184	; 0x6648
 801e366:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e36a:	681b      	ldr	r3, [r3, #0]
 801e36c:	4618      	mov	r0, r3
 801e36e:	f7fe f959 	bl	801c624 <synopGMAC_take_desc_ownership_tx>

      synopGMAC_enable_dma_tx(synopGMACdev);
 801e372:	f246 6348 	movw	r3, #26184	; 0x6648
 801e376:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e37a:	681b      	ldr	r3, [r3, #0]
 801e37c:	4618      	mov	r0, r3
 801e37e:	f7fe f8cd 	bl	801c51c <synopGMAC_enable_dma_tx>
      TR("Transmission Resumed\n");
    }
  }

  /* Enable the Interrupts before returning from ISR */
  synopGMAC_enable_interrupt(synopGMACdev, DmaIntEnable);
 801e382:	f246 6348 	movw	r3, #26184	; 0x6648
 801e386:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e38a:	681b      	ldr	r3, [r3, #0]
 801e38c:	4618      	mov	r0, r3
 801e38e:	f24a 11e3 	movw	r1, #41443	; 0xa1e3
 801e392:	f2c0 0101 	movt	r1, #1
 801e396:	f7fe f86f 	bl	801c478 <synopGMAC_enable_interrupt>

  return;
 801e39a:	bf00      	nop
 801e39c:	e000      	b.n	801e3a0 <ETH0_0_IRQHandler+0x33c>
  dma_status_reg = synopGMACReadReg((uint32_t *)ETH_BASE, DmaStatus);

  if(dma_status_reg == 0)
  {
    DBG002_ERROR(APP_GID, ETH_NO_INTERRUPT, 0, NULL);
    return;
 801e39e:	bf00      	nop

  /* Enable the Interrupts before returning from ISR */
  synopGMAC_enable_interrupt(synopGMACdev, DmaIntEnable);

  return;
}
 801e3a0:	f107 0718 	add.w	r7, r7, #24
 801e3a4:	46bd      	mov	sp, r7
 801e3a6:	bd80      	pop	{r7, pc}

0801e3a8 <Eth_PerformIoctl>:

status_t Eth_PerformIoctl(uint32_t Cmd, Eth_IoctlParamType *Eth_IoctlParam)
{
 801e3a8:	b580      	push	{r7, lr}
 801e3aa:	b084      	sub	sp, #16
 801e3ac:	af00      	add	r7, sp, #0
 801e3ae:	6078      	str	r0, [r7, #4]
 801e3b0:	6039      	str	r1, [r7, #0]
  /* <<<DD_ETH_PORT_8_1>>> */
  uint32_t Status = ETH_IOCTL_ERROR;
 801e3b2:	f04f 0306 	mov.w	r3, #6
 801e3b6:	60fb      	str	r3, [r7, #12]

  do
  {
    if(NULL == Eth_IoctlParam)
 801e3b8:	683b      	ldr	r3, [r7, #0]
 801e3ba:	2b00      	cmp	r3, #0
 801e3bc:	f000 80f8 	beq.w	801e5b0 <Eth_PerformIoctl+0x208>
      DBG002_ERROR(APP_GID, ETH_NULL_PARAM, 0, NULL);
      break;
    }

    /* Check the command and take action */
    switch(Cmd)
 801e3c0:	687b      	ldr	r3, [r7, #4]
 801e3c2:	2b09      	cmp	r3, #9
 801e3c4:	f200 80f6 	bhi.w	801e5b4 <Eth_PerformIoctl+0x20c>
 801e3c8:	a201      	add	r2, pc, #4	; (adr r2, 801e3d0 <Eth_PerformIoctl+0x28>)
 801e3ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e3ce:	bf00      	nop
 801e3d0:	0801e3f9 	.word	0x0801e3f9
 801e3d4:	0801e443 	.word	0x0801e443
 801e3d8:	0801e48d 	.word	0x0801e48d
 801e3dc:	0801e4b9 	.word	0x0801e4b9
 801e3e0:	0801e4df 	.word	0x0801e4df
 801e3e4:	0801e505 	.word	0x0801e505
 801e3e8:	0801e519 	.word	0x0801e519
 801e3ec:	0801e543 	.word	0x0801e543
 801e3f0:	0801e561 	.word	0x0801e561
 801e3f4:	0801e589 	.word	0x0801e589
    {
      case IOCTL_READ_REGISTER:
      {
        /* <<<DD_ETH_PORT_8_2>>> */
        /** IOCTL for reading IP registers : Read Registers */
        if (Eth_IoctlParam->Unit== 0)
 801e3f8:	683b      	ldr	r3, [r7, #0]
 801e3fa:	681b      	ldr	r3, [r3, #0]
 801e3fc:	2b00      	cmp	r3, #0
 801e3fe:	d10c      	bne.n	801e41a <Eth_PerformIoctl+0x72>
        {
          /* Read Mac Register */
          Eth_IoctlParam->Data = synopGMACReadReg((uint32_t *)ETH0_BASE,
                                                  Eth_IoctlParam->Address);
 801e400:	683b      	ldr	r3, [r7, #0]
        /* <<<DD_ETH_PORT_8_2>>> */
        /** IOCTL for reading IP registers : Read Registers */
        if (Eth_IoctlParam->Unit== 0)
        {
          /* Read Mac Register */
          Eth_IoctlParam->Data = synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e402:	685b      	ldr	r3, [r3, #4]
 801e404:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e408:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e40c:	4619      	mov	r1, r3
 801e40e:	f7ff f8c9 	bl	801d5a4 <synopGMACReadReg>
 801e412:	4602      	mov	r2, r0
 801e414:	683b      	ldr	r3, [r7, #0]
 801e416:	609a      	str	r2, [r3, #8]
 801e418:	e00f      	b.n	801e43a <Eth_PerformIoctl+0x92>
                                                  Eth_IoctlParam->Address);
        }
        else if (Eth_IoctlParam->Unit == 1)
 801e41a:	683b      	ldr	r3, [r7, #0]
 801e41c:	681b      	ldr	r3, [r3, #0]
 801e41e:	2b01      	cmp	r3, #1
 801e420:	d10b      	bne.n	801e43a <Eth_PerformIoctl+0x92>
        {
          /* Read DMA Register */
          Eth_IoctlParam->Data = synopGMACReadReg((uint32_t *)ETH_BASE,
                                                  Eth_IoctlParam->Address);
 801e422:	683b      	ldr	r3, [r7, #0]
                                                  Eth_IoctlParam->Address);
        }
        else if (Eth_IoctlParam->Unit == 1)
        {
          /* Read DMA Register */
          Eth_IoctlParam->Data = synopGMACReadReg((uint32_t *)ETH_BASE,
 801e424:	685b      	ldr	r3, [r3, #4]
 801e426:	f44f 4050 	mov.w	r0, #53248	; 0xd000
 801e42a:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e42e:	4619      	mov	r1, r3
 801e430:	f7ff f8b8 	bl	801d5a4 <synopGMACReadReg>
 801e434:	4602      	mov	r2, r0
 801e436:	683b      	ldr	r3, [r7, #0]
 801e438:	609a      	str	r2, [r3, #8]
                                                  Eth_IoctlParam->Address);
        }
        Status  = DAVEApp_SUCCESS;
 801e43a:	f04f 0300 	mov.w	r3, #0
 801e43e:	60fb      	str	r3, [r7, #12]
        break;
 801e440:	e0bb      	b.n	801e5ba <Eth_PerformIoctl+0x212>

      case IOCTL_WRITE_REGISTER:
      {
        /* <<<DD_ETH_PORT_8_3>>> */
        /** IOCTL for writing registers : Write Registers */
        if (Eth_IoctlParam->Unit == 0)
 801e442:	683b      	ldr	r3, [r7, #0]
 801e444:	681b      	ldr	r3, [r3, #0]
 801e446:	2b00      	cmp	r3, #0
 801e448:	d10c      	bne.n	801e464 <Eth_PerformIoctl+0xbc>
        {
          /* Write Mac Register */
          synopGMACWriteReg((uint32_t *)ETH0_BASE,Eth_IoctlParam->Address,
 801e44a:	683b      	ldr	r3, [r7, #0]
 801e44c:	685a      	ldr	r2, [r3, #4]
              Eth_IoctlParam->Data);
 801e44e:	683b      	ldr	r3, [r7, #0]
        /* <<<DD_ETH_PORT_8_3>>> */
        /** IOCTL for writing registers : Write Registers */
        if (Eth_IoctlParam->Unit == 0)
        {
          /* Write Mac Register */
          synopGMACWriteReg((uint32_t *)ETH0_BASE,Eth_IoctlParam->Address,
 801e450:	689b      	ldr	r3, [r3, #8]
 801e452:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e456:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e45a:	4611      	mov	r1, r2
 801e45c:	461a      	mov	r2, r3
 801e45e:	f7ff f8b3 	bl	801d5c8 <synopGMACWriteReg>
 801e462:	e00f      	b.n	801e484 <Eth_PerformIoctl+0xdc>
              Eth_IoctlParam->Data);
        }
        else if (Eth_IoctlParam->Unit == 1)
 801e464:	683b      	ldr	r3, [r7, #0]
 801e466:	681b      	ldr	r3, [r3, #0]
 801e468:	2b01      	cmp	r3, #1
 801e46a:	d10b      	bne.n	801e484 <Eth_PerformIoctl+0xdc>
        {
          /* Write DMA Register */
          synopGMACWriteReg((uint32_t *)ETH_BASE, Eth_IoctlParam->Address,
 801e46c:	683b      	ldr	r3, [r7, #0]
 801e46e:	685a      	ldr	r2, [r3, #4]
              Eth_IoctlParam->Data);
 801e470:	683b      	ldr	r3, [r7, #0]
              Eth_IoctlParam->Data);
        }
        else if (Eth_IoctlParam->Unit == 1)
        {
          /* Write DMA Register */
          synopGMACWriteReg((uint32_t *)ETH_BASE, Eth_IoctlParam->Address,
 801e472:	689b      	ldr	r3, [r3, #8]
 801e474:	f44f 4050 	mov.w	r0, #53248	; 0xd000
 801e478:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e47c:	4611      	mov	r1, r2
 801e47e:	461a      	mov	r2, r3
 801e480:	f7ff f8a2 	bl	801d5c8 <synopGMACWriteReg>
              Eth_IoctlParam->Data);
        }
        Status  = DAVEApp_SUCCESS;
 801e484:	f04f 0300 	mov.w	r3, #0
 801e488:	60fb      	str	r3, [r7, #12]
        break;
 801e48a:	e096      	b.n	801e5ba <Eth_PerformIoctl+0x212>

      case IOCTL_READ_IPSTRUCT:
      {
        /* <<<DD_ETH_PORT_8_4>>> */
        /** IOCTL for reading ETH0 DEVICE IP private structure */
        if (Eth_IoctlParam->Unit == 0)
 801e48c:	683b      	ldr	r3, [r7, #0]
 801e48e:	681b      	ldr	r3, [r3, #0]
 801e490:	2b00      	cmp	r3, #0
 801e492:	d10d      	bne.n	801e4b0 <Eth_PerformIoctl+0x108>
        {
          memcpy((synopGMACdevice *)Eth_IoctlParam->Address,
 801e494:	683b      	ldr	r3, [r7, #0]
 801e496:	685b      	ldr	r3, [r3, #4]
 801e498:	461a      	mov	r2, r3
 801e49a:	f246 6348 	movw	r3, #26184	; 0x6648
 801e49e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e4a2:	681b      	ldr	r3, [r3, #0]
 801e4a4:	4610      	mov	r0, r2
 801e4a6:	4619      	mov	r1, r3
 801e4a8:	f04f 02c4 	mov.w	r2, #196	; 0xc4
 801e4ac:	f005 f8b2 	bl	8023614 <memcpy>
        }
        else
        {
          TR("IOCTL_READ_IPSTRUCT failed");
        }
        Status  = DAVEApp_SUCCESS;
 801e4b0:	f04f 0300 	mov.w	r3, #0
 801e4b4:	60fb      	str	r3, [r7, #12]
        break;
 801e4b6:	e080      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      case IOCTL_READ_RXDESC:
      {
        /* <<<DD_ETH_PORT_8_5>>> */
        /** IOCTL for Reading Rx DMA DESCRIPTOR */ 
        memcpy((DmaDesc *)Eth_IoctlParam->Address,
 801e4b8:	683b      	ldr	r3, [r7, #0]
 801e4ba:	685b      	ldr	r3, [r3, #4]
 801e4bc:	461a      	mov	r2, r3
				        synopGMACdev->RxDesc,
 801e4be:	f246 6348 	movw	r3, #26184	; 0x6648
 801e4c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e4c6:	681b      	ldr	r3, [r3, #0]
 801e4c8:	69db      	ldr	r3, [r3, #28]
      }
      case IOCTL_READ_RXDESC:
      {
        /* <<<DD_ETH_PORT_8_5>>> */
        /** IOCTL for Reading Rx DMA DESCRIPTOR */ 
        memcpy((DmaDesc *)Eth_IoctlParam->Address,
 801e4ca:	4610      	mov	r0, r2
 801e4cc:	4619      	mov	r1, r3
 801e4ce:	f04f 0228 	mov.w	r2, #40	; 0x28
 801e4d2:	f005 f89f 	bl	8023614 <memcpy>
				        synopGMACdev->RxDesc,
               sizeof(DmaDesc));
        Status  = DAVEApp_SUCCESS;
 801e4d6:	f04f 0300 	mov.w	r3, #0
 801e4da:	60fb      	str	r3, [r7, #12]
        break;
 801e4dc:	e06d      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      case IOCTL_READ_TXDESC:
      {
        /* <<<DD_ETH_PORT_8_6>>> */
        /** IOCTL for Reading Tx DMA DESCRIPTOR */
        memcpy((DmaDesc *)Eth_IoctlParam->Address,
 801e4de:	683b      	ldr	r3, [r7, #0]
 801e4e0:	685b      	ldr	r3, [r3, #4]
 801e4e2:	461a      	mov	r2, r3
                synopGMACdev->TxDesc,
 801e4e4:	f246 6348 	movw	r3, #26184	; 0x6648
 801e4e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e4ec:	681b      	ldr	r3, [r3, #0]
 801e4ee:	699b      	ldr	r3, [r3, #24]
      }
      case IOCTL_READ_TXDESC:
      {
        /* <<<DD_ETH_PORT_8_6>>> */
        /** IOCTL for Reading Tx DMA DESCRIPTOR */
        memcpy((DmaDesc *)Eth_IoctlParam->Address,
 801e4f0:	4610      	mov	r0, r2
 801e4f2:	4619      	mov	r1, r3
 801e4f4:	f04f 0228 	mov.w	r2, #40	; 0x28
 801e4f8:	f005 f88c 	bl	8023614 <memcpy>
                synopGMACdev->TxDesc,
                sizeof(DmaDesc));
        Status  = DAVEApp_SUCCESS;
 801e4fc:	f04f 0300 	mov.w	r3, #0
 801e500:	60fb      	str	r3, [r7, #12]
        break;
 801e502:	e05a      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      case IOCTL_READ_RMON_COUNTERS:
      {
        /* <<<DD_ETH_PORT_8_7>>> */
        Eth_StructRMONCountersType *RMONCounters =
            (Eth_StructRMONCountersType *) Eth_IoctlParam->Address;
 801e504:	683b      	ldr	r3, [r7, #0]
 801e506:	685b      	ldr	r3, [r3, #4]
        break;
      }
      case IOCTL_READ_RMON_COUNTERS:
      {
        /* <<<DD_ETH_PORT_8_7>>> */
        Eth_StructRMONCountersType *RMONCounters =
 801e508:	60bb      	str	r3, [r7, #8]
            (Eth_StructRMONCountersType *) Eth_IoctlParam->Address;

        Eth_lGetRMONCounters(RMONCounters);
 801e50a:	68b8      	ldr	r0, [r7, #8]
 801e50c:	f000 f85c 	bl	801e5c8 <Eth_lGetRMONCounters>
        Status  = DAVEApp_SUCCESS;
 801e510:	f04f 0300 	mov.w	r3, #0
 801e514:	60fb      	str	r3, [r7, #12]
        break;
 801e516:	e050      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      case IOCTL_CHANGE_MTU:
      {
        /* <<<DD_ETH_PORT_8_8>>> */
        /** IOCTL for changing the MTU size */
        if (Eth_IoctlParam->Data > MAX_MTU_SIZE)
 801e518:	683b      	ldr	r3, [r7, #0]
 801e51a:	689a      	ldr	r2, [r3, #8]
 801e51c:	f240 53dc 	movw	r3, #1500	; 0x5dc
 801e520:	429a      	cmp	r2, r3
 801e522:	d849      	bhi.n	801e5b8 <Eth_PerformIoctl+0x210>
        {
          DBG002_ERROR(APP_GID, ETH_IOCTL_ERROR, sizeof("Invalid MTU size"), "Invalid MTU size");
          break;
        }
        synopGMAC_change_mtu(synopGMACdev, Eth_IoctlParam->Data);
 801e524:	f246 6348 	movw	r3, #26184	; 0x6648
 801e528:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e52c:	681a      	ldr	r2, [r3, #0]
 801e52e:	683b      	ldr	r3, [r7, #0]
 801e530:	689b      	ldr	r3, [r3, #8]
 801e532:	4610      	mov	r0, r2
 801e534:	4619      	mov	r1, r3
 801e536:	f7ff f827 	bl	801d588 <synopGMAC_change_mtu>
        Status  = DAVEApp_SUCCESS;
 801e53a:	f04f 0300 	mov.w	r3, #0
 801e53e:	60fb      	str	r3, [r7, #12]
        break;
 801e540:	e03b      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      case IOCTL_SET_MAC_ADDRESS:
      {
        /* <<<DD_ETH_PORT_8_9>>> */
        /** IOCTL to set MAC Address */
        synopGMAC_set_mac_address(synopGMACdev, (void *)Eth_IoctlParam->Address);
 801e542:	f246 6348 	movw	r3, #26184	; 0x6648
 801e546:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e54a:	681a      	ldr	r2, [r3, #0]
 801e54c:	683b      	ldr	r3, [r7, #0]
 801e54e:	685b      	ldr	r3, [r3, #4]
 801e550:	4610      	mov	r0, r2
 801e552:	4619      	mov	r1, r3
 801e554:	f7fe ffea 	bl	801d52c <synopGMAC_set_mac_address>
        Status  = DAVEApp_SUCCESS;
 801e558:	f04f 0300 	mov.w	r3, #0
 801e55c:	60fb      	str	r3, [r7, #12]
        break;
 801e55e:	e02c      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      case IOCTL_GET_MAC_ADDRESS:
      {
        /* <<<DD_ETH_PORT_8_10>>> */
        /** IOCTL to get Eth MAC Address */
        memcpy((uint8_t *)Eth_IoctlParam->Address,
 801e560:	683b      	ldr	r3, [r7, #0]
 801e562:	685b      	ldr	r3, [r3, #4]
 801e564:	461a      	mov	r2, r3
            synopGMACdev->MacAddress, MAC_ADDR_LEN);
 801e566:	f246 6348 	movw	r3, #26184	; 0x6648
 801e56a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e56e:	681b      	ldr	r3, [r3, #0]
 801e570:	f103 03bc 	add.w	r3, r3, #188	; 0xbc
      }
      case IOCTL_GET_MAC_ADDRESS:
      {
        /* <<<DD_ETH_PORT_8_10>>> */
        /** IOCTL to get Eth MAC Address */
        memcpy((uint8_t *)Eth_IoctlParam->Address,
 801e574:	4610      	mov	r0, r2
 801e576:	4619      	mov	r1, r3
 801e578:	f04f 0206 	mov.w	r2, #6
 801e57c:	f005 f84a 	bl	8023614 <memcpy>
            synopGMACdev->MacAddress, MAC_ADDR_LEN);
        Status  = DAVEApp_SUCCESS;
 801e580:	f04f 0300 	mov.w	r3, #0
 801e584:	60fb      	str	r3, [r7, #12]
        break;
 801e586:	e018      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      case IOCTL_GET_NET_STATS:
      {
        /* <<<DD_ETH_PORT_8_11>>> */
        /** IOCTL to get network statistics */
        memcpy((void *)Eth_IoctlParam->Address, &(synopGMACdev->NetStatistics),
 801e588:	683b      	ldr	r3, [r7, #0]
 801e58a:	685b      	ldr	r3, [r3, #4]
 801e58c:	461a      	mov	r2, r3
 801e58e:	f246 6348 	movw	r3, #26184	; 0x6648
 801e592:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e596:	681b      	ldr	r3, [r3, #0]
 801e598:	f103 0350 	add.w	r3, r3, #80	; 0x50
 801e59c:	4610      	mov	r0, r2
 801e59e:	4619      	mov	r1, r3
 801e5a0:	f04f 0254 	mov.w	r2, #84	; 0x54
 801e5a4:	f005 f836 	bl	8023614 <memcpy>
            sizeof(Eth_NetStatisticsType));
        Status  = DAVEApp_SUCCESS;
 801e5a8:	f04f 0300 	mov.w	r3, #0
 801e5ac:	60fb      	str	r3, [r7, #12]
        break;
 801e5ae:	e004      	b.n	801e5ba <Eth_PerformIoctl+0x212>
  do
  {
    if(NULL == Eth_IoctlParam)
    {
      DBG002_ERROR(APP_GID, ETH_NULL_PARAM, 0, NULL);
      break;
 801e5b0:	bf00      	nop
 801e5b2:	e002      	b.n	801e5ba <Eth_PerformIoctl+0x212>
      }
      default:
      {
        DBG002_ERROR(APP_GID, ETH_IOCTL_ERROR, sizeof("INVALID option"),
            "INVALID option");
        break;
 801e5b4:	bf00      	nop
 801e5b6:	e000      	b.n	801e5ba <Eth_PerformIoctl+0x212>
        /* <<<DD_ETH_PORT_8_8>>> */
        /** IOCTL for changing the MTU size */
        if (Eth_IoctlParam->Data > MAX_MTU_SIZE)
        {
          DBG002_ERROR(APP_GID, ETH_IOCTL_ERROR, sizeof("Invalid MTU size"), "Invalid MTU size");
          break;
 801e5b8:	bf00      	nop
        break;
      }
    }
  }while(0);

  return Status;
 801e5ba:	68fb      	ldr	r3, [r7, #12]
}
 801e5bc:	4618      	mov	r0, r3
 801e5be:	f107 0710 	add.w	r7, r7, #16
 801e5c2:	46bd      	mov	sp, r7
 801e5c4:	bd80      	pop	{r7, pc}
 801e5c6:	bf00      	nop

0801e5c8 <Eth_lGetRMONCounters>:

/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/
static void Eth_lGetRMONCounters(Eth_StructRMONCountersType *RMONCounters)
{
 801e5c8:	b580      	push	{r7, lr}
 801e5ca:	b082      	sub	sp, #8
 801e5cc:	af00      	add	r7, sp, #0
 801e5ce:	6078      	str	r0, [r7, #4]
  /* <<<DD_ETH_PORT_14>>> */
  RMONCounters->TXOCtetCountGB = synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e5d0:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e5d4:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e5d8:	f44f 718c 	mov.w	r1, #280	; 0x118
 801e5dc:	f7fe ffe2 	bl	801d5a4 <synopGMACReadReg>
 801e5e0:	4602      	mov	r2, r0
 801e5e2:	687b      	ldr	r3, [r7, #4]
 801e5e4:	601a      	str	r2, [r3, #0]
      TXFRAMECOUNTGB_OFFSET);

  RMONCounters->TxFrameCountGB = synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e5e6:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e5ea:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e5ee:	f44f 718c 	mov.w	r1, #280	; 0x118
 801e5f2:	f7fe ffd7 	bl	801d5a4 <synopGMACReadReg>
 801e5f6:	4602      	mov	r2, r0
 801e5f8:	687b      	ldr	r3, [r7, #4]
 801e5fa:	605a      	str	r2, [r3, #4]
      TXFRAMECOUNTGB_OFFSET);

  RMONCounters->TxBroadcastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e5fc:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e600:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e604:	f44f 718e 	mov.w	r1, #284	; 0x11c
 801e608:	f7fe ffcc 	bl	801d5a4 <synopGMACReadReg>
 801e60c:	4602      	mov	r2, r0
      TXFRAMECOUNTGB_OFFSET);

  RMONCounters->TxFrameCountGB = synopGMACReadReg((uint32_t *)ETH0_BASE,
      TXFRAMECOUNTGB_OFFSET);

  RMONCounters->TxBroadcastFramesG =
 801e60e:	687b      	ldr	r3, [r7, #4]
 801e610:	609a      	str	r2, [r3, #8]
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXBROADCASTFRAMESG_OFFSET);

  RMONCounters->TxMulticastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e612:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e616:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e61a:	f44f 7190 	mov.w	r1, #288	; 0x120
 801e61e:	f7fe ffc1 	bl	801d5a4 <synopGMACReadReg>
 801e622:	4602      	mov	r2, r0

  RMONCounters->TxBroadcastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXBROADCASTFRAMESG_OFFSET);

  RMONCounters->TxMulticastFramesG =
 801e624:	687b      	ldr	r3, [r7, #4]
 801e626:	60da      	str	r2, [r3, #12]
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXMULTICASTFRAMESG_OFFSET);

  RMONCounters->Tx64OctetsGB = synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e628:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e62c:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e630:	f44f 7192 	mov.w	r1, #292	; 0x124
 801e634:	f7fe ffb6 	bl	801d5a4 <synopGMACReadReg>
 801e638:	4602      	mov	r2, r0
 801e63a:	687b      	ldr	r3, [r7, #4]
 801e63c:	611a      	str	r2, [r3, #16]
      TX64OCTETSGB_OFFSET);

  RMONCounters->Tx65To127OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e63e:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e642:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e646:	f44f 7194 	mov.w	r1, #296	; 0x128
 801e64a:	f7fe ffab 	bl	801d5a4 <synopGMACReadReg>
 801e64e:	4602      	mov	r2, r0
          TXMULTICASTFRAMESG_OFFSET);

  RMONCounters->Tx64OctetsGB = synopGMACReadReg((uint32_t *)ETH0_BASE,
      TX64OCTETSGB_OFFSET);

  RMONCounters->Tx65To127OctetsGB =
 801e650:	687b      	ldr	r3, [r7, #4]
 801e652:	615a      	str	r2, [r3, #20]
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX65TO127OCTETSGB_OFFSET);

  RMONCounters->Tx128To255OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e654:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e658:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e65c:	f44f 7196 	mov.w	r1, #300	; 0x12c
 801e660:	f7fe ffa0 	bl	801d5a4 <synopGMACReadReg>
 801e664:	4602      	mov	r2, r0

  RMONCounters->Tx65To127OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX65TO127OCTETSGB_OFFSET);

  RMONCounters->Tx128To255OctetsGB =
 801e666:	687b      	ldr	r3, [r7, #4]
 801e668:	619a      	str	r2, [r3, #24]
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX128TO255OCTETSGB_OFFSET);

  RMONCounters->Tx256To511OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e66a:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e66e:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e672:	f04f 0130 	mov.w	r1, #48	; 0x30
 801e676:	f7fe ff95 	bl	801d5a4 <synopGMACReadReg>
 801e67a:	4602      	mov	r2, r0

  RMONCounters->Tx128To255OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX128TO255OCTETSGB_OFFSET);

  RMONCounters->Tx256To511OctetsGB =
 801e67c:	687b      	ldr	r3, [r7, #4]
 801e67e:	61da      	str	r2, [r3, #28]
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX256TO511OCTETSGB_OFFSET);

  RMONCounters->Tx512To1023ctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e680:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e684:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e688:	f44f 719a 	mov.w	r1, #308	; 0x134
 801e68c:	f7fe ff8a 	bl	801d5a4 <synopGMACReadReg>
 801e690:	4602      	mov	r2, r0

  RMONCounters->Tx256To511OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX256TO511OCTETSGB_OFFSET);

  RMONCounters->Tx512To1023ctetsGB =
 801e692:	687b      	ldr	r3, [r7, #4]
 801e694:	621a      	str	r2, [r3, #32]
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX512TO1023CTETSGB_OFFSET);

  RMONCounters->Tx1024ToMaxOctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e696:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e69a:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e69e:	f44f 719c 	mov.w	r1, #312	; 0x138
 801e6a2:	f7fe ff7f 	bl	801d5a4 <synopGMACReadReg>
 801e6a6:	4602      	mov	r2, r0

  RMONCounters->Tx512To1023ctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX512TO1023CTETSGB_OFFSET);

  RMONCounters->Tx1024ToMaxOctetsGB =
 801e6a8:	687b      	ldr	r3, [r7, #4]
 801e6aa:	625a      	str	r2, [r3, #36]	; 0x24
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX1024TOMAXOCTETSGB_OFFSET);

  RMONCounters->TxUnicastFramesGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e6ac:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e6b0:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e6b4:	f44f 719e 	mov.w	r1, #316	; 0x13c
 801e6b8:	f7fe ff74 	bl	801d5a4 <synopGMACReadReg>
 801e6bc:	4602      	mov	r2, r0

  RMONCounters->Tx1024ToMaxOctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TX1024TOMAXOCTETSGB_OFFSET);

  RMONCounters->TxUnicastFramesGB =
 801e6be:	687b      	ldr	r3, [r7, #4]
 801e6c0:	629a      	str	r2, [r3, #40]	; 0x28
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXUNICASTFRAMESGB_OFFSET);

  RMONCounters->TxMulticastFramesGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e6c2:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e6c6:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e6ca:	f44f 71a0 	mov.w	r1, #320	; 0x140
 801e6ce:	f7fe ff69 	bl	801d5a4 <synopGMACReadReg>
 801e6d2:	4602      	mov	r2, r0

  RMONCounters->TxUnicastFramesGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXUNICASTFRAMESGB_OFFSET);

  RMONCounters->TxMulticastFramesGB =
 801e6d4:	687b      	ldr	r3, [r7, #4]
 801e6d6:	62da      	str	r2, [r3, #44]	; 0x2c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXMULTICASTFRAMESGB_OFFSET);

  RMONCounters->TxBroadcastFramesGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e6d8:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e6dc:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e6e0:	f44f 71a2 	mov.w	r1, #324	; 0x144
 801e6e4:	f7fe ff5e 	bl	801d5a4 <synopGMACReadReg>
 801e6e8:	4602      	mov	r2, r0

  RMONCounters->TxMulticastFramesGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXMULTICASTFRAMESGB_OFFSET);

  RMONCounters->TxBroadcastFramesGB =
 801e6ea:	687b      	ldr	r3, [r7, #4]
 801e6ec:	631a      	str	r2, [r3, #48]	; 0x30
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXBROADCASTFRAMESGB_OFFSET);

  RMONCounters->UnderFlowError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e6ee:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e6f2:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e6f6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801e6fa:	f7fe ff53 	bl	801d5a4 <synopGMACReadReg>
 801e6fe:	4602      	mov	r2, r0

  RMONCounters->TxBroadcastFramesGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXBROADCASTFRAMESGB_OFFSET);

  RMONCounters->UnderFlowError =
 801e700:	687b      	ldr	r3, [r7, #4]
 801e702:	635a      	str	r2, [r3, #52]	; 0x34
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          UNDERFLOWERROR_OFFSET);

  RMONCounters->SingleCollisionG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e704:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e708:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e70c:	f44f 71a6 	mov.w	r1, #332	; 0x14c
 801e710:	f7fe ff48 	bl	801d5a4 <synopGMACReadReg>
 801e714:	4602      	mov	r2, r0

  RMONCounters->UnderFlowError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          UNDERFLOWERROR_OFFSET);

  RMONCounters->SingleCollisionG =
 801e716:	687b      	ldr	r3, [r7, #4]
 801e718:	639a      	str	r2, [r3, #56]	; 0x38
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          SINGLECOLLISIONG_OFFSET);

  RMONCounters->MultiCollisionG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e71a:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e71e:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e722:	f44f 71a8 	mov.w	r1, #336	; 0x150
 801e726:	f7fe ff3d 	bl	801d5a4 <synopGMACReadReg>
 801e72a:	4602      	mov	r2, r0

  RMONCounters->SingleCollisionG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          SINGLECOLLISIONG_OFFSET);

  RMONCounters->MultiCollisionG =
 801e72c:	687b      	ldr	r3, [r7, #4]
 801e72e:	63da      	str	r2, [r3, #60]	; 0x3c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          MULTICOLLISIONG_OFFSET);

  RMONCounters->TxDeferred =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e730:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e734:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e738:	f44f 71aa 	mov.w	r1, #340	; 0x154
 801e73c:	f7fe ff32 	bl	801d5a4 <synopGMACReadReg>
 801e740:	4602      	mov	r2, r0

  RMONCounters->MultiCollisionG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          MULTICOLLISIONG_OFFSET);

  RMONCounters->TxDeferred =
 801e742:	687b      	ldr	r3, [r7, #4]
 801e744:	641a      	str	r2, [r3, #64]	; 0x40
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXDEFERRED_OFFSET);

  RMONCounters->TxLateCollision =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e746:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e74a:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e74e:	f44f 71ac 	mov.w	r1, #344	; 0x158
 801e752:	f7fe ff27 	bl	801d5a4 <synopGMACReadReg>
 801e756:	4602      	mov	r2, r0

  RMONCounters->TxDeferred =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXDEFERRED_OFFSET);

  RMONCounters->TxLateCollision =
 801e758:	687b      	ldr	r3, [r7, #4]
 801e75a:	645a      	str	r2, [r3, #68]	; 0x44
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXLATECOLLISION_OFFSET);

  RMONCounters->ExcessCollision =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e75c:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e760:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e764:	f44f 71ae 	mov.w	r1, #348	; 0x15c
 801e768:	f7fe ff1c 	bl	801d5a4 <synopGMACReadReg>
 801e76c:	4602      	mov	r2, r0

  RMONCounters->TxLateCollision =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXLATECOLLISION_OFFSET);

  RMONCounters->ExcessCollision =
 801e76e:	687b      	ldr	r3, [r7, #4]
 801e770:	649a      	str	r2, [r3, #72]	; 0x48
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          EXCESSCOLLISION_OFFSET);

  RMONCounters->TxCarrierError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e772:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e776:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e77a:	f44f 71b0 	mov.w	r1, #352	; 0x160
 801e77e:	f7fe ff11 	bl	801d5a4 <synopGMACReadReg>
 801e782:	4602      	mov	r2, r0

  RMONCounters->ExcessCollision =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          EXCESSCOLLISION_OFFSET);

  RMONCounters->TxCarrierError =
 801e784:	687b      	ldr	r3, [r7, #4]
 801e786:	64da      	str	r2, [r3, #76]	; 0x4c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXCARRIERERROR_OFFSET);

  RMONCounters->TxOctetCount =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e788:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e78c:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e790:	f44f 71b2 	mov.w	r1, #356	; 0x164
 801e794:	f7fe ff06 	bl	801d5a4 <synopGMACReadReg>
 801e798:	4602      	mov	r2, r0

  RMONCounters->TxCarrierError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXCARRIERERROR_OFFSET);

  RMONCounters->TxOctetCount =
 801e79a:	687b      	ldr	r3, [r7, #4]
 801e79c:	651a      	str	r2, [r3, #80]	; 0x50
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXOCTETCOUNT_OFFSET);

  RMONCounters->TxFrameCount =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e79e:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e7a2:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e7a6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 801e7aa:	f7fe fefb 	bl	801d5a4 <synopGMACReadReg>
 801e7ae:	4602      	mov	r2, r0

  RMONCounters->TxOctetCount =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXOCTETCOUNT_OFFSET);

  RMONCounters->TxFrameCount =
 801e7b0:	687b      	ldr	r3, [r7, #4]
 801e7b2:	655a      	str	r2, [r3, #84]	; 0x54
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXFRAMECOUNT_OFFSET);

  RMONCounters->TxExcessDef =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e7b4:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e7b8:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e7bc:	f44f 71b6 	mov.w	r1, #364	; 0x16c
 801e7c0:	f7fe fef0 	bl	801d5a4 <synopGMACReadReg>
 801e7c4:	4602      	mov	r2, r0

  RMONCounters->TxFrameCount =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXFRAMECOUNT_OFFSET);

  RMONCounters->TxExcessDef =
 801e7c6:	687b      	ldr	r3, [r7, #4]
 801e7c8:	659a      	str	r2, [r3, #88]	; 0x58
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXEXCESSDEF_OFFSET);

  RMONCounters->TxPauseFrames =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e7ca:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e7ce:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e7d2:	f44f 71b8 	mov.w	r1, #368	; 0x170
 801e7d6:	f7fe fee5 	bl	801d5a4 <synopGMACReadReg>
 801e7da:	4602      	mov	r2, r0

  RMONCounters->TxExcessDef =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXEXCESSDEF_OFFSET);

  RMONCounters->TxPauseFrames =
 801e7dc:	687b      	ldr	r3, [r7, #4]
 801e7de:	65da      	str	r2, [r3, #92]	; 0x5c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXPAUSEFRAMES_OFFSET);

  RMONCounters->TxVLANFrames =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e7e0:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e7e4:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e7e8:	f44f 71ba 	mov.w	r1, #372	; 0x174
 801e7ec:	f7fe feda 	bl	801d5a4 <synopGMACReadReg>
 801e7f0:	4602      	mov	r2, r0

  RMONCounters->TxPauseFrames =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXPAUSEFRAMES_OFFSET);

  RMONCounters->TxVLANFrames =
 801e7f2:	687b      	ldr	r3, [r7, #4]
 801e7f4:	661a      	str	r2, [r3, #96]	; 0x60
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXVLANFRAMES_OFFSET);

  RMONCounters->RxFrameCountGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e7f6:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e7fa:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e7fe:	f44f 71c0 	mov.w	r1, #384	; 0x180
 801e802:	f7fe fecf 	bl	801d5a4 <synopGMACReadReg>
 801e806:	4602      	mov	r2, r0

  RMONCounters->TxVLANFrames =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          TXVLANFRAMES_OFFSET);

  RMONCounters->RxFrameCountGB =
 801e808:	687b      	ldr	r3, [r7, #4]
 801e80a:	665a      	str	r2, [r3, #100]	; 0x64
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXFRAMECOUNTGB_OFFSET);

  RMONCounters->RxOctetCountGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e80c:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e810:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e814:	f44f 71c2 	mov.w	r1, #388	; 0x184
 801e818:	f7fe fec4 	bl	801d5a4 <synopGMACReadReg>
 801e81c:	4602      	mov	r2, r0

  RMONCounters->RxFrameCountGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXFRAMECOUNTGB_OFFSET);

  RMONCounters->RxOctetCountGB =
 801e81e:	687b      	ldr	r3, [r7, #4]
 801e820:	669a      	str	r2, [r3, #104]	; 0x68
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOCTETCOUNTGB_OFFSET);

  RMONCounters->RxOctetCountG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e822:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e826:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e82a:	f44f 71c4 	mov.w	r1, #392	; 0x188
 801e82e:	f7fe feb9 	bl	801d5a4 <synopGMACReadReg>
 801e832:	4602      	mov	r2, r0

  RMONCounters->RxOctetCountGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOCTETCOUNTGB_OFFSET);

  RMONCounters->RxOctetCountG =
 801e834:	687b      	ldr	r3, [r7, #4]
 801e836:	66da      	str	r2, [r3, #108]	; 0x6c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOCTETCOUNTG_OFFSET);

  RMONCounters->RxBroadcastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e838:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e83c:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e840:	f44f 71c6 	mov.w	r1, #396	; 0x18c
 801e844:	f7fe feae 	bl	801d5a4 <synopGMACReadReg>
 801e848:	4602      	mov	r2, r0

  RMONCounters->RxOctetCountG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOCTETCOUNTG_OFFSET);

  RMONCounters->RxBroadcastFramesG =
 801e84a:	687b      	ldr	r3, [r7, #4]
 801e84c:	671a      	str	r2, [r3, #112]	; 0x70
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXBROADCASTFRAMESG_OFFSET);

  RMONCounters->RxMulticastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e84e:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e852:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e856:	f44f 71c8 	mov.w	r1, #400	; 0x190
 801e85a:	f7fe fea3 	bl	801d5a4 <synopGMACReadReg>
 801e85e:	4602      	mov	r2, r0

  RMONCounters->RxBroadcastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXBROADCASTFRAMESG_OFFSET);

  RMONCounters->RxMulticastFramesG =
 801e860:	687b      	ldr	r3, [r7, #4]
 801e862:	675a      	str	r2, [r3, #116]	; 0x74
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXMULTICASTFRAMESG_OFFSET);

  RMONCounters->RxCRCError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e864:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e868:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e86c:	f44f 71ca 	mov.w	r1, #404	; 0x194
 801e870:	f7fe fe98 	bl	801d5a4 <synopGMACReadReg>
 801e874:	4602      	mov	r2, r0

  RMONCounters->RxMulticastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXMULTICASTFRAMESG_OFFSET);

  RMONCounters->RxCRCError =
 801e876:	687b      	ldr	r3, [r7, #4]
 801e878:	679a      	str	r2, [r3, #120]	; 0x78
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXCRCERROR_OFFSET);

  RMONCounters->RxAlignmentError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e87a:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e87e:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e882:	f44f 71cc 	mov.w	r1, #408	; 0x198
 801e886:	f7fe fe8d 	bl	801d5a4 <synopGMACReadReg>
 801e88a:	4602      	mov	r2, r0

  RMONCounters->RxCRCError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXCRCERROR_OFFSET);

  RMONCounters->RxAlignmentError =
 801e88c:	687b      	ldr	r3, [r7, #4]
 801e88e:	67da      	str	r2, [r3, #124]	; 0x7c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXALIGNMENTERROR_OFFSET);

  RMONCounters->RxRuntError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e890:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e894:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e898:	f44f 71ce 	mov.w	r1, #412	; 0x19c
 801e89c:	f7fe fe82 	bl	801d5a4 <synopGMACReadReg>
 801e8a0:	4602      	mov	r2, r0

  RMONCounters->RxAlignmentError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXALIGNMENTERROR_OFFSET);

  RMONCounters->RxRuntError =
 801e8a2:	687b      	ldr	r3, [r7, #4]
 801e8a4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXRUNTERROR_OFFSET);

  RMONCounters->RxJabberError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e8a8:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e8ac:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e8b0:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 801e8b4:	f7fe fe76 	bl	801d5a4 <synopGMACReadReg>
 801e8b8:	4602      	mov	r2, r0

  RMONCounters->RxRuntError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXRUNTERROR_OFFSET);

  RMONCounters->RxJabberError =
 801e8ba:	687b      	ldr	r3, [r7, #4]
 801e8bc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXJABBERERROR_OFFSET);

  RMONCounters->RxUndersizeG =
            synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e8c0:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e8c4:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e8c8:	f44f 71d2 	mov.w	r1, #420	; 0x1a4
 801e8cc:	f7fe fe6a 	bl	801d5a4 <synopGMACReadReg>
 801e8d0:	4602      	mov	r2, r0

  RMONCounters->RxJabberError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXJABBERERROR_OFFSET);

  RMONCounters->RxUndersizeG =
 801e8d2:	687b      	ldr	r3, [r7, #4]
 801e8d4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            synopGMACReadReg((uint32_t *)ETH0_BASE,
            RXUNDERSIZEG_OFFSET);

  RMONCounters->RxOverSizeG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e8d8:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e8dc:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e8e0:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
 801e8e4:	f7fe fe5e 	bl	801d5a4 <synopGMACReadReg>
 801e8e8:	4602      	mov	r2, r0

  RMONCounters->RxUndersizeG =
            synopGMACReadReg((uint32_t *)ETH0_BASE,
            RXUNDERSIZEG_OFFSET);

  RMONCounters->RxOverSizeG =
 801e8ea:	687b      	ldr	r3, [r7, #4]
 801e8ec:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOVERSIZEG_OFFSET);

  RMONCounters->Rx64OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e8f0:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e8f4:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e8f8:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
 801e8fc:	f7fe fe52 	bl	801d5a4 <synopGMACReadReg>
 801e900:	4602      	mov	r2, r0

  RMONCounters->RxOverSizeG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOVERSIZEG_OFFSET);

  RMONCounters->Rx64OctetsGB =
 801e902:	687b      	ldr	r3, [r7, #4]
 801e904:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX64OCTETSGB_OFFSET);

  RMONCounters->Rx65To127OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e908:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e90c:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e910:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 801e914:	f7fe fe46 	bl	801d5a4 <synopGMACReadReg>
 801e918:	4602      	mov	r2, r0

  RMONCounters->Rx64OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX64OCTETSGB_OFFSET);

  RMONCounters->Rx65To127OctetsGB =
 801e91a:	687b      	ldr	r3, [r7, #4]
 801e91c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX65TO127OCTETSGB_OFFSET);

  RMONCounters->Rx127To255OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e920:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e924:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e928:	f44f 71da 	mov.w	r1, #436	; 0x1b4
 801e92c:	f7fe fe3a 	bl	801d5a4 <synopGMACReadReg>
 801e930:	4602      	mov	r2, r0

  RMONCounters->Rx65To127OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX65TO127OCTETSGB_OFFSET);

  RMONCounters->Rx127To255OctetsGB =
 801e932:	687b      	ldr	r3, [r7, #4]
 801e934:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX127TO255OCTETSGB_OFFSET);

  RMONCounters->Rx256To511OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e938:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e93c:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e940:	f44f 71dc 	mov.w	r1, #440	; 0x1b8
 801e944:	f7fe fe2e 	bl	801d5a4 <synopGMACReadReg>
 801e948:	4602      	mov	r2, r0

  RMONCounters->Rx127To255OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX127TO255OCTETSGB_OFFSET);

  RMONCounters->Rx256To511OctetsGB =
 801e94a:	687b      	ldr	r3, [r7, #4]
 801e94c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX256TO511OCTETSGB_OFFSET);

  RMONCounters->Rx512To1023OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e950:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e954:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e958:	f44f 71de 	mov.w	r1, #444	; 0x1bc
 801e95c:	f7fe fe22 	bl	801d5a4 <synopGMACReadReg>
 801e960:	4602      	mov	r2, r0

  RMONCounters->Rx256To511OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX256TO511OCTETSGB_OFFSET);

  RMONCounters->Rx512To1023OctetsGB =
 801e962:	687b      	ldr	r3, [r7, #4]
 801e964:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX512TO1023OCTETSGB_OFFSET);

  RMONCounters->Rx1023ToMaxOctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e968:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e96c:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e970:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
 801e974:	f7fe fe16 	bl	801d5a4 <synopGMACReadReg>
 801e978:	4602      	mov	r2, r0

  RMONCounters->Rx512To1023OctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX512TO1023OCTETSGB_OFFSET);

  RMONCounters->Rx1023ToMaxOctetsGB =
 801e97a:	687b      	ldr	r3, [r7, #4]
 801e97c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX1023TOMAXOCTETSGB_OFFSET);

  RMONCounters->RxUnicastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e980:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e984:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e988:	f44f 71e2 	mov.w	r1, #452	; 0x1c4
 801e98c:	f7fe fe0a 	bl	801d5a4 <synopGMACReadReg>
 801e990:	4602      	mov	r2, r0

  RMONCounters->Rx1023ToMaxOctetsGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RX1023TOMAXOCTETSGB_OFFSET);

  RMONCounters->RxUnicastFramesG =
 801e992:	687b      	ldr	r3, [r7, #4]
 801e994:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXUNICASTFRAMESG_OFFSET);

  RMONCounters->RxLengthError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e998:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e99c:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e9a0:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 801e9a4:	f7fe fdfe 	bl	801d5a4 <synopGMACReadReg>
 801e9a8:	4602      	mov	r2, r0

  RMONCounters->RxUnicastFramesG =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXUNICASTFRAMESG_OFFSET);

  RMONCounters->RxLengthError =
 801e9aa:	687b      	ldr	r3, [r7, #4]
 801e9ac:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXLENGTHERROR_OFFSET);

  RMONCounters->RxOutofRangeType =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e9b0:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e9b4:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e9b8:	f44f 71e6 	mov.w	r1, #460	; 0x1cc
 801e9bc:	f7fe fdf2 	bl	801d5a4 <synopGMACReadReg>
 801e9c0:	4602      	mov	r2, r0

  RMONCounters->RxLengthError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXLENGTHERROR_OFFSET);

  RMONCounters->RxOutofRangeType =
 801e9c2:	687b      	ldr	r3, [r7, #4]
 801e9c4:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOUTOFRANGETYPE_OFFSET);

  RMONCounters->RxPauseFrames =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e9c8:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e9cc:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e9d0:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 801e9d4:	f7fe fde6 	bl	801d5a4 <synopGMACReadReg>
 801e9d8:	4602      	mov	r2, r0

  RMONCounters->RxOutofRangeType =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXOUTOFRANGETYPE_OFFSET);

  RMONCounters->RxPauseFrames =
 801e9da:	687b      	ldr	r3, [r7, #4]
 801e9dc:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXPAUSEFRAMES_OFFSET);

  RMONCounters->RxFifoOverflow =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e9e0:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e9e4:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801e9e8:	f44f 71ea 	mov.w	r1, #468	; 0x1d4
 801e9ec:	f7fe fdda 	bl	801d5a4 <synopGMACReadReg>
 801e9f0:	4602      	mov	r2, r0

  RMONCounters->RxPauseFrames =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXPAUSEFRAMES_OFFSET);

  RMONCounters->RxFifoOverflow =
 801e9f2:	687b      	ldr	r3, [r7, #4]
 801e9f4:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXFIFOOVERFLOW_OFFSET);

  RMONCounters->RxVLANFrameGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801e9f8:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801e9fc:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801ea00:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 801ea04:	f7fe fdce 	bl	801d5a4 <synopGMACReadReg>
 801ea08:	4602      	mov	r2, r0

  RMONCounters->RxFifoOverflow =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXFIFOOVERFLOW_OFFSET);

  RMONCounters->RxVLANFrameGB =
 801ea0a:	687b      	ldr	r3, [r7, #4]
 801ea0c:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXVLANFRAMEGB_OFFSET);

  RMONCounters->RxWatchDOGError =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
 801ea10:	f44f 4040 	mov.w	r0, #49152	; 0xc000
 801ea14:	f2c5 0000 	movt	r0, #20480	; 0x5000
 801ea18:	f44f 71ee 	mov.w	r1, #476	; 0x1dc
 801ea1c:	f7fe fdc2 	bl	801d5a4 <synopGMACReadReg>
 801ea20:	4602      	mov	r2, r0

  RMONCounters->RxVLANFrameGB =
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXVLANFRAMEGB_OFFSET);

  RMONCounters->RxWatchDOGError =
 801ea22:	687b      	ldr	r3, [r7, #4]
 801ea24:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
      synopGMACReadReg((uint32_t *)ETH0_BASE,
          RXWATCHDOGERROR_OFFSET);
}
 801ea28:	f107 0708 	add.w	r7, r7, #8
 801ea2c:	46bd      	mov	sp, r7
 801ea2e:	bd80      	pop	{r7, pc}

0801ea30 <synopGMAC_RegisterPeriodicTimerCallback>:

void synopGMAC_RegisterPeriodicTimerCallback(SynopGMACPeriodicTimerCallbackType Callback)
{
 801ea30:	b480      	push	{r7}
 801ea32:	b083      	sub	sp, #12
 801ea34:	af00      	add	r7, sp, #0
 801ea36:	6078      	str	r0, [r7, #4]
	SynopGMACPeriodicTimerCallback = Callback;
 801ea38:	f645 3398 	movw	r3, #23448	; 0x5b98
 801ea3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ea40:	687a      	ldr	r2, [r7, #4]
 801ea42:	601a      	str	r2, [r3, #0]
}
 801ea44:	f107 070c 	add.w	r7, r7, #12
 801ea48:	46bd      	mov	sp, r7
 801ea4a:	bc80      	pop	{r7}
 801ea4c:	4770      	bx	lr
 801ea4e:	bf00      	nop

0801ea50 <synopGMAC_RegisterDeleteTimerCallback>:

void synopGMAC_RegisterDeleteTimerCallback(SynopGMACDeletePeriodicTimerType Callback)
{
 801ea50:	b480      	push	{r7}
 801ea52:	b083      	sub	sp, #12
 801ea54:	af00      	add	r7, sp, #0
 801ea56:	6078      	str	r0, [r7, #4]
	SynopGMACDeletePeriodicTimer = Callback;
 801ea58:	f645 339c 	movw	r3, #23452	; 0x5b9c
 801ea5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ea60:	687a      	ldr	r2, [r7, #4]
 801ea62:	601a      	str	r2, [r3, #0]
}
 801ea64:	f107 070c 	add.w	r7, r7, #12
 801ea68:	46bd      	mov	sp, r7
 801ea6a:	bc80      	pop	{r7}
 801ea6c:	4770      	bx	lr
 801ea6e:	bf00      	nop

0801ea70 <synopGMAC_periodic_check>:

void synopGMAC_periodic_check()
{
 801ea70:	b580      	push	{r7, lr}
 801ea72:	af00      	add	r7, sp, #0
	synopGMAC_cable_unplug_function(synopGMACdev);
 801ea74:	f246 6348 	movw	r3, #26184	; 0x6648
 801ea78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ea7c:	681b      	ldr	r3, [r3, #0]
 801ea7e:	4618      	mov	r0, r3
 801ea80:	f7fe fa26 	bl	801ced0 <synopGMAC_cable_unplug_function>
}
 801ea84:	bd80      	pop	{r7, pc}
 801ea86:	bf00      	nop

0801ea88 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 801ea88:	b480      	push	{r7}
 801ea8a:	b085      	sub	sp, #20
 801ea8c:	af00      	add	r7, sp, #0
 801ea8e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
 801ea90:	687b      	ldr	r3, [r7, #4]
 801ea92:	f003 0307 	and.w	r3, r3, #7
 801ea96:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 801ea98:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 801ea9c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 801eaa0:	68db      	ldr	r3, [r3, #12]
 801eaa2:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 801eaa4:	68ba      	ldr	r2, [r7, #8]
 801eaa6:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 801eaaa:	4013      	ands	r3, r2
 801eaac:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 801eaae:	68fb      	ldr	r3, [r7, #12]
 801eab0:	ea4f 2203 	mov.w	r2, r3, lsl #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
 801eab4:	68bb      	ldr	r3, [r7, #8]
 801eab6:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 801eab8:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 801eabc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 801eac0:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 801eac2:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 801eac6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 801eaca:	68ba      	ldr	r2, [r7, #8]
 801eacc:	60da      	str	r2, [r3, #12]
}
 801eace:	f107 0714 	add.w	r7, r7, #20
 801ead2:	46bd      	mov	sp, r7
 801ead4:	bc80      	pop	{r7}
 801ead6:	4770      	bx	lr

0801ead8 <DAVE_Init>:
// @Parameters    None
//
//****************************************************************************

void DAVE_Init(void)
{
 801ead8:	b580      	push	{r7, lr}
 801eada:	af00      	add	r7, sp, #0
          
    //  NVIC Priority Grouping
    NVIC_SetPriorityGrouping(1);
 801eadc:	f04f 0001 	mov.w	r0, #1
 801eae0:	f7ff ffd2 	bl	801ea88 <NVIC_SetPriorityGrouping>

//****************************************************************************
// @Initialization of APPs Init Functions
//****************************************************************************
	//  MUX configurations
	DAVE_MUX_PreInit();
 801eae4:	f000 f9fe 	bl	801eee4 <DAVE_MUX_PreInit>
 
	//  Initialization of app 'CLK001'		     
	CLK001_Init();
 801eae8:	f000 fd74 	bl	801f5d4 <CLK001_Init>
 
	//  Initialization of app 'SYSTM001'		     
	SYSTM001_Init();
 801eaec:	f7e5 fbc6 	bl	800427c <SYSTM001_Init>
 
	//  Initialization of app 'SDMMC003'		     
	SDMMC003_Init();
 801eaf0:	f7e7 fe3a 	bl	8006768 <SDMMC003_Init>
 
	//  Initialization of app 'NVIC_SCU001'		     
	NVIC_SCU001_Init();
 801eaf4:	f7eb f86e 	bl	8009bd4 <NVIC_SCU001_Init>
 
	//  Initialization of app 'RTC001'		     
	RTC001_Init();
 801eaf8:	f7ea faaa 	bl	8009050 <RTC001_Init>
 
	//  Initialization of app 'FATFS002'		     
	FATFS002_Init();
 801eafc:	f7ec fcf0 	bl	800b4e0 <FATFS002_Init>
 
	//  Initialization of app 'GMM001'		     
	GMM001_Init();
 801eb00:	f7ec fa3e 	bl	800af80 <GMM001_Init>
 
	//  Initialization of app 'SLTHA001'		     
	SLTHA001_Init();
 801eb04:	f7e6 fe8c 	bl	8005820 <SLTHA001_Init>
 
	//  Initialization of app 'IO004'		     
	IO004_Init();
 801eb08:	f7eb ff7c 	bl	800aa04 <IO004_Init>
 
	//  Initialization of app 'ADCGLOB001'		     
	ADCGLOB001_Init();
 801eb0c:	f001 faa6 	bl	802005c <ADCGLOB001_Init>
 
	//  Initialization of app 'ADCGROUP001'		     
	ADCGROUP001_Init();
 801eb10:	f000 fd80 	bl	801f614 <ADCGROUP001_Init>
 
	//  Initialization of app 'IO001'		     
	IO001_Init();
 801eb14:	f7ec f92e 	bl	800ad74 <IO001_Init>
 
	//  Initialization of app 'ADCCH001'		     
	ADCCH001_Init();
 801eb18:	f002 f8aa 	bl	8020c70 <ADCCH001_Init>
 
	//  Initialization of app 'ADC002'		     
	ADC002_Init();
 801eb1c:	f002 fdf2 	bl	8021704 <ADC002_Init>
 
	//  Initialization of app 'UART001'		     
	UART001_Init();
 801eb20:	f7e4 feb0 	bl	8003884 <UART001_Init>
 
	//  Initialization of app 'NVIC002'		     
	NVIC002_Init();
 801eb24:	f7eb fb7c 	bl	800a220 <NVIC002_Init>
      
	//  MUX configurations
	DAVE_MUX_Init();	
 801eb28:	f000 f808 	bl	801eb3c <DAVE_MUX_Init>
} //  End of function DAVE_Init
 801eb2c:	bd80      	pop	{r7, pc}
 801eb2e:	bf00      	nop

0801eb30 <SystemInit_DAVE3>:
// @Parameters    None
//
//****************************************************************************

void SystemInit_DAVE3(void)
{
 801eb30:	b580      	push	{r7, lr}
 801eb32:	af00      	add	r7, sp, #0
	// CLK Initialisation
	CLK001_Init();
 801eb34:	f000 fd4e 	bl	801f5d4 <CLK001_Init>
} //  End of function SystemInit_DAVE3
 801eb38:	bd80      	pop	{r7, pc}
 801eb3a:	bf00      	nop

0801eb3c <DAVE_MUX_Init>:
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
           
void DAVE_MUX_Init(void)
{              	         
 801eb3c:	b480      	push	{r7}
 801eb3e:	af00      	add	r7, sp, #0
   /*USIC 0 Channel 1 Mux Related SFR/Bitfields Configurations*/ 									  					 				 				 		       				              				  					    					 					   				  					 				 				       				  										 									 					 					  									      					              					  						    					      
         						
   /*USIC 1 Channel 0 Mux Related SFR/Bitfields Configurations*/ 									  					 				 				 		       				              				  					    					 					   				  					 				 				       				  										 									 					 					  									      					              					  						    					      
       						
   /*USIC 1 Channel 1 Mux Related SFR/Bitfields Configurations*/ 						         
 WR_REG(USIC1_CH1->DX0CR, USIC_CH_DX0CR_DSEL_Msk, USIC_CH_DX0CR_DSEL_Pos,3); 
 801eb40:	f44f 7300 	mov.w	r3, #512	; 0x200
 801eb44:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801eb48:	f44f 7200 	mov.w	r2, #512	; 0x200
 801eb4c:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801eb50:	69d2      	ldr	r2, [r2, #28]
 801eb52:	f022 0207 	bic.w	r2, r2, #7
 801eb56:	f042 0203 	orr.w	r2, r2, #3
 801eb5a:	61da      	str	r2, [r3, #28]
  			  					 				 				 		       				              				  					    					 					   				  					 				 				       				  					    
 //Standard receive buffer event is enabled.                 
 WR_REG(USIC1_CH1->RBCTR, USIC_CH_RBCTR_SRBIEN_Msk, USIC_CH_RBCTR_SRBIEN_Pos,1);  
 801eb5c:	f44f 7300 	mov.w	r3, #512	; 0x200
 801eb60:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801eb64:	f44f 7200 	mov.w	r2, #512	; 0x200
 801eb68:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801eb6c:	f8d2 210c 	ldr.w	r2, [r2, #268]	; 0x10c
 801eb70:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 801eb74:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
 					 									 					 					  									      					              					  						    					      
                 
   // Data Pointer & Buffer Size for Transmitter Buffer Control  
 WR_REG(USIC1_CH1->TBCTR, USIC_CH_TBCTR_DPTRSIZE_Msk, USIC_CH_TBCTR_DPTRSIZE_Pos,0x01000002);		/*    DPTR = 2,  SIZE = 1 */ 
 801eb78:	f44f 7300 	mov.w	r3, #512	; 0x200
 801eb7c:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801eb80:	f44f 7200 	mov.w	r2, #512	; 0x200
 801eb84:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801eb88:	f8d2 2108 	ldr.w	r2, [r2, #264]	; 0x108
 801eb8c:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 801eb90:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 801eb94:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 801eb98:	f042 0202 	orr.w	r2, r2, #2
 801eb9c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
         
  // Data Pointer & Buffer Size for Receiver Buffer Control  
 WR_REG(USIC1_CH1->RBCTR, USIC_CH_RBCTR_DPTRSIZE_Msk, USIC_CH_RBCTR_DPTRSIZE_Pos,0x01000000);		/*    DPTR = 0,  SIZE = 1 */ 
 801eba0:	f44f 7300 	mov.w	r3, #512	; 0x200
 801eba4:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801eba8:	f44f 7200 	mov.w	r2, #512	; 0x200
 801ebac:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ebb0:	f8d2 210c 	ldr.w	r2, [r2, #268]	; 0x10c
 801ebb4:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 801ebb8:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 801ebbc:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 801ebc0:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
                                                          	         
                                          

/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */               
           
  WR_REG(PORT0->IOCR0, PORT_IOCR_PC1_PCR_Msk, PORT_IOCR_PC1_PCR_Pos, PORT_IOCR_PCR2);            /*    P0.1 : PORT0_IOCR0_PC1_PCR */
 801ebc4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 801ebc8:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ebcc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 801ebd0:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ebd4:	6912      	ldr	r2, [r2, #16]
 801ebd6:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
 801ebda:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 801ebde:	611a      	str	r2, [r3, #16]

  WR_REG(PORT0->IOCR0, PORT_IOCR_PC1_OE_Msk, PORT_IOCR_PC1_OE_Pos, PORT_IOCR_OE1);                /*    P0.1 : PORT0_IOCR0_PC1_OE */					   
 801ebe0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 801ebe4:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ebe8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 801ebec:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ebf0:	6912      	ldr	r2, [r2, #16]
 801ebf2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 801ebf6:	611a      	str	r2, [r3, #16]

  WR_REG(PORT1->IOCR0, PORT_IOCR_PC0_OE_Msk, PORT_IOCR_PC0_OE_Pos, PORT_IOCR_OE1);                /*    P1.0 : PORT1_IOCR0_PC0_OE */					   
 801ebf8:	f44f 4301 	mov.w	r3, #33024	; 0x8100
 801ebfc:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ec00:	f44f 4201 	mov.w	r2, #33024	; 0x8100
 801ec04:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ec08:	6912      	ldr	r2, [r2, #16]
 801ec0a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801ec0e:	611a      	str	r2, [r3, #16]
           
  WR_REG(PORT1->HWSEL, PORT1_HWSEL_HW6_Msk, PORT1_HWSEL_HW6_Pos, PORT_HWSEL_HW0);                    /*    P1.6 : PORT1_HWSEL_HW6 */  
 801ec10:	f44f 4301 	mov.w	r3, #33024	; 0x8100
 801ec14:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ec18:	f44f 4201 	mov.w	r2, #33024	; 0x8100
 801ec1c:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ec20:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801ec22:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 801ec26:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 801ec2a:	675a      	str	r2, [r3, #116]	; 0x74

  WR_REG(PORT1->IOCR4, PORT_IOCR_PC2_OE_Msk, PORT_IOCR_PC2_OE_Pos, PORT_IOCR_OE1);                /*    P1.6 : PORT1_IOCR4_PC6_OE */					   
 801ec2c:	f44f 4301 	mov.w	r3, #33024	; 0x8100
 801ec30:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ec34:	f44f 4201 	mov.w	r2, #33024	; 0x8100
 801ec38:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ec3c:	6952      	ldr	r2, [r2, #20]
 801ec3e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 801ec42:	615a      	str	r2, [r3, #20]
           
  WR_REG(PORT1->HWSEL, PORT1_HWSEL_HW7_Msk, PORT1_HWSEL_HW7_Pos, PORT_HWSEL_HW0);                    /*    P1.7 : PORT1_HWSEL_HW7 */  
 801ec44:	f44f 4301 	mov.w	r3, #33024	; 0x8100
 801ec48:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ec4c:	f44f 4201 	mov.w	r2, #33024	; 0x8100
 801ec50:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ec54:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801ec56:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 801ec5a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 801ec5e:	675a      	str	r2, [r3, #116]	; 0x74

  WR_REG(PORT1->IOCR4, PORT_IOCR_PC3_OE_Msk, PORT_IOCR_PC3_OE_Pos, PORT_IOCR_OE1);                /*    P1.7 : PORT1_IOCR4_PC7_OE */					   
 801ec60:	f44f 4301 	mov.w	r3, #33024	; 0x8100
 801ec64:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ec68:	f44f 4201 	mov.w	r2, #33024	; 0x8100
 801ec6c:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ec70:	6952      	ldr	r2, [r2, #20]
 801ec72:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 801ec76:	615a      	str	r2, [r3, #20]
           
  WR_REG(PORT2->HWSEL, PORT2_HWSEL_HW0_Msk, PORT2_HWSEL_HW0_Pos, PORT_HWSEL_HW0);                    /*    P2.0 : PORT2_HWSEL_HW0 */  
 801ec78:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ec7c:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ec80:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ec84:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ec88:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801ec8a:	f022 0203 	bic.w	r2, r2, #3
 801ec8e:	f042 0201 	orr.w	r2, r2, #1
 801ec92:	675a      	str	r2, [r3, #116]	; 0x74

  WR_REG(PORT2->IOCR0, PORT_IOCR_PC0_OE_Msk, PORT_IOCR_PC0_OE_Pos, PORT_IOCR_OE1);                /*    P2.0 : PORT2_IOCR0_PC0_OE */					   
 801ec94:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ec98:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ec9c:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801eca0:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801eca4:	6912      	ldr	r2, [r2, #16]
 801eca6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801ecaa:	611a      	str	r2, [r3, #16]
           
  WR_REG(PORT2->IOCR4, PORT_IOCR_PC1_PCR_Msk, PORT_IOCR_PC1_PCR_Pos, PORT_IOCR_PCR1);            /*    P2.5 : PORT2_IOCR4_PC5_PCR */
 801ecac:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ecb0:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ecb4:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ecb8:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ecbc:	6952      	ldr	r2, [r2, #20]
 801ecbe:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
 801ecc2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 801ecc6:	615a      	str	r2, [r3, #20]

  WR_REG(PORT2->IOCR4, PORT_IOCR_PC1_OE_Msk, PORT_IOCR_PC1_OE_Pos, PORT_IOCR_OE1);                /*    P2.5 : PORT2_IOCR4_PC5_OE */					   
 801ecc8:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801eccc:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ecd0:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ecd4:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ecd8:	6952      	ldr	r2, [r2, #20]
 801ecda:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 801ecde:	615a      	str	r2, [r3, #20]
           
  WR_REG(PORT2->IOCR4, PORT_IOCR_PC3_PCR_Msk, PORT_IOCR_PC3_PCR_Pos, PORT_IOCR_PCR1);            /*    P2.7 : PORT2_IOCR4_PC7_PCR */
 801ece0:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ece4:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ece8:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ecec:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ecf0:	6952      	ldr	r2, [r2, #20]
 801ecf2:	f022 5260 	bic.w	r2, r2, #939524096	; 0x38000000
 801ecf6:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 801ecfa:	615a      	str	r2, [r3, #20]

  WR_REG(PORT2->IOCR4, PORT_IOCR_PC3_OE_Msk, PORT_IOCR_PC3_OE_Pos, PORT_IOCR_OE1);                /*    P2.7 : PORT2_IOCR4_PC7_OE */					   
 801ecfc:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ed00:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ed04:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ed08:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ed0c:	6952      	ldr	r2, [r2, #20]
 801ed0e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 801ed12:	615a      	str	r2, [r3, #20]
           
  WR_REG(PORT2->IOCR8, PORT_IOCR_PC0_PCR_Msk, PORT_IOCR_PC0_PCR_Pos, PORT_IOCR_PCR1);            /*    P2.8 : PORT2_IOCR8_PC8_PCR */
 801ed14:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ed18:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ed1c:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ed20:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ed24:	6992      	ldr	r2, [r2, #24]
 801ed26:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 801ed2a:	f042 0208 	orr.w	r2, r2, #8
 801ed2e:	619a      	str	r2, [r3, #24]

  WR_REG(PORT2->IOCR8, PORT_IOCR_PC0_OE_Msk, PORT_IOCR_PC0_OE_Pos, PORT_IOCR_OE1);                /*    P2.8 : PORT2_IOCR8_PC8_OE */					   
 801ed30:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ed34:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ed38:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ed3c:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ed40:	6992      	ldr	r2, [r2, #24]
 801ed42:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801ed46:	619a      	str	r2, [r3, #24]
           
  WR_REG(PORT2->IOCR8, PORT_IOCR_PC1_PCR_Msk, PORT_IOCR_PC1_PCR_Pos, PORT_IOCR_PCR1);            /*    P2.9 : PORT2_IOCR8_PC9_PCR */
 801ed48:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ed4c:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ed50:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ed54:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ed58:	6992      	ldr	r2, [r2, #24]
 801ed5a:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
 801ed5e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 801ed62:	619a      	str	r2, [r3, #24]

  WR_REG(PORT2->IOCR8, PORT_IOCR_PC1_OE_Msk, PORT_IOCR_PC1_OE_Pos, PORT_IOCR_OE1);                /*    P2.9 : PORT2_IOCR8_PC9_OE */					   
 801ed64:	f44f 4302 	mov.w	r3, #33280	; 0x8200
 801ed68:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ed6c:	f44f 4202 	mov.w	r2, #33280	; 0x8200
 801ed70:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ed74:	6992      	ldr	r2, [r2, #24]
 801ed76:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 801ed7a:	619a      	str	r2, [r3, #24]
           
  WR_REG(PORT3->HWSEL, PORT3_HWSEL_HW5_Msk, PORT3_HWSEL_HW5_Pos, PORT_HWSEL_HW0);                    /*    P3.5 : PORT3_HWSEL_HW5 */  
 801ed7c:	f44f 4303 	mov.w	r3, #33536	; 0x8300
 801ed80:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ed84:	f44f 4203 	mov.w	r2, #33536	; 0x8300
 801ed88:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ed8c:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801ed8e:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 801ed92:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 801ed96:	675a      	str	r2, [r3, #116]	; 0x74

  WR_REG(PORT3->IOCR4, PORT_IOCR_PC1_OE_Msk, PORT_IOCR_PC1_OE_Pos, PORT_IOCR_OE1);                /*    P3.5 : PORT3_IOCR4_PC5_OE */					   
 801ed98:	f44f 4303 	mov.w	r3, #33536	; 0x8300
 801ed9c:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801eda0:	f44f 4203 	mov.w	r2, #33536	; 0x8300
 801eda4:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801eda8:	6952      	ldr	r2, [r2, #20]
 801edaa:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 801edae:	615a      	str	r2, [r3, #20]
           
  WR_REG(PORT3->HWSEL, PORT3_HWSEL_HW6_Msk, PORT3_HWSEL_HW6_Pos, PORT_HWSEL_HW0);                    /*    P3.6 : PORT3_HWSEL_HW6 */  
 801edb0:	f44f 4303 	mov.w	r3, #33536	; 0x8300
 801edb4:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801edb8:	f44f 4203 	mov.w	r2, #33536	; 0x8300
 801edbc:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801edc0:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801edc2:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 801edc6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 801edca:	675a      	str	r2, [r3, #116]	; 0x74

  WR_REG(PORT3->IOCR4, PORT_IOCR_PC2_OE_Msk, PORT_IOCR_PC2_OE_Pos, PORT_IOCR_OE1);                /*    P3.6 : PORT3_IOCR4_PC6_OE */					   
 801edcc:	f44f 4303 	mov.w	r3, #33536	; 0x8300
 801edd0:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801edd4:	f44f 4203 	mov.w	r2, #33536	; 0x8300
 801edd8:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801eddc:	6952      	ldr	r2, [r2, #20]
 801edde:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 801ede2:	615a      	str	r2, [r3, #20]
           
  WR_REG(PORT4->HWSEL, PORT4_HWSEL_HW0_Msk, PORT4_HWSEL_HW0_Pos, PORT_HWSEL_HW0);                    /*    P4.0 : PORT4_HWSEL_HW0 */  
 801ede4:	f44f 4304 	mov.w	r3, #33792	; 0x8400
 801ede8:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801edec:	f44f 4204 	mov.w	r2, #33792	; 0x8400
 801edf0:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801edf4:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801edf6:	f022 0203 	bic.w	r2, r2, #3
 801edfa:	f042 0201 	orr.w	r2, r2, #1
 801edfe:	675a      	str	r2, [r3, #116]	; 0x74

  WR_REG(PORT4->IOCR0, PORT_IOCR_PC0_OE_Msk, PORT_IOCR_PC0_OE_Pos, PORT_IOCR_OE1);                /*    P4.0 : PORT4_IOCR0_PC0_OE */					   
 801ee00:	f44f 4304 	mov.w	r3, #33792	; 0x8400
 801ee04:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ee08:	f44f 4204 	mov.w	r2, #33792	; 0x8400
 801ee0c:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ee10:	6912      	ldr	r2, [r2, #16]
 801ee12:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801ee16:	611a      	str	r2, [r3, #16]
           
  WR_REG(PORT4->HWSEL, PORT4_HWSEL_HW1_Msk, PORT4_HWSEL_HW1_Pos, PORT_HWSEL_HW0);                    /*    P4.1 : PORT4_HWSEL_HW1 */  
 801ee18:	f44f 4304 	mov.w	r3, #33792	; 0x8400
 801ee1c:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ee20:	f44f 4204 	mov.w	r2, #33792	; 0x8400
 801ee24:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ee28:	6f52      	ldr	r2, [r2, #116]	; 0x74
 801ee2a:	f022 020c 	bic.w	r2, r2, #12
 801ee2e:	f042 0204 	orr.w	r2, r2, #4
 801ee32:	675a      	str	r2, [r3, #116]	; 0x74

  WR_REG(PORT4->IOCR0, PORT_IOCR_PC1_OE_Msk, PORT_IOCR_PC1_OE_Pos, PORT_IOCR_OE1);                /*    P4.1 : PORT4_IOCR0_PC1_OE */					                   	         
 801ee34:	f44f 4304 	mov.w	r3, #33792	; 0x8400
 801ee38:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ee3c:	f44f 4204 	mov.w	r2, #33792	; 0x8400
 801ee40:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ee44:	6912      	ldr	r2, [r2, #16]
 801ee46:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 801ee4a:	611a      	str	r2, [r3, #16]
                                  
                  /*VADC GROUP0 Mux Related SFR/Bitfields Configurations*/  						                                                   						         						                         						                          						         						                                   						          						          						          						                                    						         
  WR_REG(VADC_G0->ALIAS, VADC_G_ALIAS_ALIAS0_Msk, VADC_G_ALIAS_ALIAS0_Pos,1); 
 801ee4c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 801ee50:	f2c4 0300 	movt	r3, #16384	; 0x4000
 801ee54:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 801ee58:	f2c4 0200 	movt	r2, #16384	; 0x4000
 801ee5c:	f8d2 20b0 	ldr.w	r2, [r2, #176]	; 0xb0
 801ee60:	f022 021f 	bic.w	r2, r2, #31
 801ee64:	f042 0201 	orr.w	r2, r2, #1
 801ee68:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
   						          
   								 						         
  WR_REG(VADC_G0->CHCTR[0], VADC_G_CHCTR_RESREG_Msk, VADC_G_CHCTR_RESREG_Pos,15); 
 801ee6c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 801ee70:	f2c4 0300 	movt	r3, #16384	; 0x4000
 801ee74:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 801ee78:	f2c4 0200 	movt	r2, #16384	; 0x4000
 801ee7c:	f8d2 2200 	ldr.w	r2, [r2, #512]	; 0x200
 801ee80:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 801ee84:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
               /*VADC BACKGROUND Source Mux Related SFR/Bitfields Configurations*/  						                  						                						                                                                          
    //********* Ethernet MAC CONFIGURATIONS *************************
                     
    // Configuring ETH0_CON  =  Ethernet x Port Control Register

    WR_REG(ETH0_CON->CON, ETH_CON_CLK_RMII_Msk, ETH_CON_CLK_RMII_Pos, ETH_RMIIC);                   
 801ee88:	f244 0340 	movw	r3, #16448	; 0x4040
 801ee8c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801ee90:	f244 0240 	movw	r2, #16448	; 0x4040
 801ee94:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801ee98:	6812      	ldr	r2, [r2, #0]
 801ee9a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 801ee9e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 801eea2:	601a      	str	r2, [r3, #0]

    WR_REG(ETH0_CON->CON, ETH_CON_CRS_DV_Msk, ETH_CON_CRS_DV_Pos, ETH_CRS_DVC);                   
 801eea4:	f244 0340 	movw	r3, #16448	; 0x4040
 801eea8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801eeac:	f244 0240 	movw	r2, #16448	; 0x4040
 801eeb0:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801eeb4:	6812      	ldr	r2, [r2, #0]
 801eeb6:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 801eeba:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 801eebe:	601a      	str	r2, [r3, #0]

    WR_REG(ETH0_CON->CON, ETH_CON_MDIO_Msk, ETH_CON_MDIO_Pos, ETH_MDIOB);                               	         
 801eec0:	f244 0340 	movw	r3, #16448	; 0x4040
 801eec4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801eec8:	f244 0240 	movw	r2, #16448	; 0x4040
 801eecc:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801eed0:	6812      	ldr	r2, [r2, #0]
 801eed2:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 801eed6:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 801eeda:	601a      	str	r2, [r3, #0]
                                              
}
 801eedc:	46bd      	mov	sp, r7
 801eede:	bc80      	pop	{r7}
 801eee0:	4770      	bx	lr
 801eee2:	bf00      	nop

0801eee4 <DAVE_MUX_PreInit>:
** Description      : This is the Mux configuration                           **
**                                                                            **
*******************************************************************************/
 
void DAVE_MUX_PreInit(void)
{                    
 801eee4:	b480      	push	{r7}
 801eee6:	af00      	add	r7, sp, #0

/*        PORT Macro definitions for IOCR_OE, IOCR_PCR & HWSEL_HW     */               
           
  WR_REG(PORT15->PDISC, PORT15_PDISC_PDIS8_Msk, PORT15_PDISC_PDIS8_Pos, PORT_PDISC_PDIS0);            /*    P15.8 : PORT15_PDISC_PDIS8 */
 801eee8:	f44f 430f 	mov.w	r3, #36608	; 0x8f00
 801eeec:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801eef0:	f44f 420f 	mov.w	r2, #36608	; 0x8f00
 801eef4:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801eef8:	6e12      	ldr	r2, [r2, #96]	; 0x60
 801eefa:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 801eefe:	661a      	str	r2, [r3, #96]	; 0x60
           
  WR_REG(PORT15->PDISC, PORT15_PDISC_PDIS9_Msk, PORT15_PDISC_PDIS9_Pos, PORT_PDISC_PDIS0);            /*    P15.9 : PORT15_PDISC_PDIS9 */            
 801ef00:	f44f 430f 	mov.w	r3, #36608	; 0x8f00
 801ef04:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801ef08:	f44f 420f 	mov.w	r2, #36608	; 0x8f00
 801ef0c:	f6c4 0202 	movt	r2, #18434	; 0x4802
 801ef10:	6e12      	ldr	r2, [r2, #96]	; 0x60
 801ef12:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 801ef16:	661a      	str	r2, [r3, #96]	; 0x60
}
 801ef18:	46bd      	mov	sp, r7
 801ef1a:	bc80      	pop	{r7}
 801ef1c:	4770      	bx	lr
 801ef1e:	bf00      	nop

0801ef20 <Delay>:
  * @note   -  
  * @param  number of loops
  * @retval None
  */
static void Delay(uint32_t time_1)
{
 801ef20:	b480      	push	{r7}
 801ef22:	b085      	sub	sp, #20
 801ef24:	af00      	add	r7, sp, #0
 801ef26:	6078      	str	r0, [r7, #4]
	uint32_t i = 0U;
 801ef28:	f04f 0300 	mov.w	r3, #0
 801ef2c:	60fb      	str	r3, [r7, #12]
	for(i=0U; i < time_1;i++)
 801ef2e:	f04f 0300 	mov.w	r3, #0
 801ef32:	60fb      	str	r3, [r7, #12]
 801ef34:	e007      	b.n	801ef46 <Delay+0x26>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 801ef36:	bf00      	nop
 801ef38:	bf00      	nop
 801ef3a:	bf00      	nop
 801ef3c:	bf00      	nop
 801ef3e:	68fb      	ldr	r3, [r7, #12]
 801ef40:	f103 0301 	add.w	r3, r3, #1
 801ef44:	60fb      	str	r3, [r7, #12]
 801ef46:	68fa      	ldr	r2, [r7, #12]
 801ef48:	687b      	ldr	r3, [r7, #4]
 801ef4a:	429a      	cmp	r2, r3
 801ef4c:	d3f3      	bcc.n	801ef36 <Delay+0x16>
	{
		__NOP();__NOP();__NOP();__NOP();
	}

} 
 801ef4e:	f107 0714 	add.w	r7, r7, #20
 801ef52:	46bd      	mov	sp, r7
 801ef54:	bc80      	pop	{r7}
 801ef56:	4770      	bx	lr

0801ef58 <System_Clock_valid>:
  * @note   -  
  * @param  None
  * @retval PASS/FAIL
  */
static uint32_t System_Clock_valid(void)
{
 801ef58:	b480      	push	{r7}
 801ef5a:	b083      	sub	sp, #12
 801ef5c:	af00      	add	r7, sp, #0
  uint32_t MAIN_clock_status = 1U;
 801ef5e:	f04f 0301 	mov.w	r3, #1
 801ef62:	607b      	str	r3, [r7, #4]

  /* check if PLL is switched on */
  if((SCU_PLL->PLLCON0 &(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk))!= 0U)
 801ef64:	f244 7310 	movw	r3, #18192	; 0x4710
 801ef68:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801ef6c:	685a      	ldr	r2, [r3, #4]
 801ef6e:	f04f 0302 	mov.w	r3, #2
 801ef72:	f2c0 0301 	movt	r3, #1
 801ef76:	4013      	ands	r3, r2
 801ef78:	2b00      	cmp	r3, #0
 801ef7a:	d002      	beq.n	801ef82 <System_Clock_valid+0x2a>
  {
    MAIN_clock_status=0U;
 801ef7c:	f04f 0300 	mov.w	r3, #0
 801ef80:	607b      	str	r3, [r7, #4]
  }
  return(MAIN_clock_status);
 801ef82:	687b      	ldr	r3, [r7, #4]
}
 801ef84:	4618      	mov	r0, r3
 801ef86:	f107 070c 	add.w	r7, r7, #12
 801ef8a:	46bd      	mov	sp, r7
 801ef8c:	bc80      	pop	{r7}
 801ef8e:	4770      	bx	lr

0801ef90 <System_Clock_init>:
  * @note   -  
  * @param  None
  * @retval PASS/FAIL
  */
static uint32_t System_Clock_init(void)
{
 801ef90:	b580      	push	{r7, lr}
 801ef92:	b084      	sub	sp, #16
 801ef94:	af00      	add	r7, sp, #0
	uint32_t Return_status = 1U;
 801ef96:	f04f 0301 	mov.w	r3, #1
 801ef9a:	60fb      	str	r3, [r7, #12]
#if ((CLK001_TRIM_OPTION == CLK001_CLOCK_TRIM_AUTOMATIC)&& \
    (CLK001_STANDBY_CLOCK == CLK001_HIB_CLOCK_FOSI))
  {
  
     /* check if HIB Domain enabled  */
     if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0U)
 801ef9c:	f44f 4384 	mov.w	r3, #16896	; 0x4200
 801efa0:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801efa4:	681b      	ldr	r3, [r3, #0]
 801efa6:	f003 0301 	and.w	r3, r3, #1
 801efaa:	2b00      	cmp	r3, #0
 801efac:	d10b      	bne.n	801efc6 <System_Clock_init+0x36>
     {
       SCU_POWER->PWRSET |= (uint32_t)SCU_POWER_PWRSET_HIB_Msk;/*enable Hibernate domain*/
 801efae:	f44f 4384 	mov.w	r3, #16896	; 0x4200
 801efb2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801efb6:	f44f 4284 	mov.w	r2, #16896	; 0x4200
 801efba:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801efbe:	6852      	ldr	r2, [r2, #4]
 801efc0:	f042 0201 	orr.w	r2, r2, #1
 801efc4:	605a      	str	r2, [r3, #4]
     }

     /* check if HIB Domain is not in reset state  */
     if ((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0U)
 801efc6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 801efca:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801efce:	681b      	ldr	r3, [r3, #0]
 801efd0:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801efd4:	2b00      	cmp	r3, #0
 801efd6:	d00b      	beq.n	801eff0 <System_Clock_init+0x60>
     {
	     /*de-assert hibernate reset*/
       SCU_RESET->RSTCLR |= (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 801efd8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 801efdc:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801efe0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 801efe4:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801efe8:	6892      	ldr	r2, [r2, #8]
 801efea:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 801efee:	609a      	str	r2, [r3, #8]
     }
     SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 801eff0:	f244 7310 	movw	r3, #18192	; 0x4710
 801eff4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801eff8:	f244 7210 	movw	r2, #18192	; 0x4710
 801effc:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f000:	6852      	ldr	r2, [r2, #4]
 801f002:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 801f006:	605a      	str	r2, [r3, #4]
     /*insert some delay */
     Delay(CLK001_DELAY_CNT_50US_50MHZ); /*~50us @ maximum back up clock freq*/
 801f008:	f04f 0064 	mov.w	r0, #100	; 0x64
 801f00c:	f7ff ff88 	bl	801ef20 <Delay>
     SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 801f010:	f244 7310 	movw	r3, #18192	; 0x4710
 801f014:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f018:	f244 7210 	movw	r2, #18192	; 0x4710
 801f01c:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f020:	6852      	ldr	r2, [r2, #4]
 801f022:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 801f026:	605a      	str	r2, [r3, #4]
  {
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
  }
#endif /*end of trimming options*/
  /*insert some delay after trimming is enabled*/
  Delay(CLK001_DELAY_CNT_50US_50MHZ);/*~50us @ maximum back up clock freq*/
 801f028:	f04f 0064 	mov.w	r0, #100	; 0x64
 801f02c:	f7ff ff78 	bl	801ef20 <Delay>
  }
  /*system clock = pll */
#else/*(CLK001_CLOCK_SYS_SRC == CLK001_CLOCK_SRC_PLL)*/
  {
    /* enable PLL first */
    SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 801f030:	f244 7310 	movw	r3, #18192	; 0x4710
 801f034:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f038:	f244 7210 	movw	r2, #18192	; 0x4710
 801f03c:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f040:	6852      	ldr	r2, [r2, #4]
 801f042:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 801f046:	f022 0202 	bic.w	r2, r2, #2
 801f04a:	605a      	str	r2, [r3, #4]
      /************************************************************************/
      /*    Use external crystal or digital input for PLL clock input         */
      /************************************************************************/ 

      /* Enable OSC_HP if not already on */
      if ((SCU_OSC->OSCHPCTRL & SCU_OSC_OSCHPCTRL_MODE_Msk) != \
 801f04c:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 801f050:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f054:	685b      	ldr	r3, [r3, #4]
 801f056:	f003 0330 	and.w	r3, r3, #48	; 0x30
 801f05a:	2b00      	cmp	r3, #0
 801f05c:	d054      	beq.n	801f108 <System_Clock_init+0x178>
         ((uint32_t)CLK001_OSC_HP_MODE << SCU_OSC_OSCHPCTRL_MODE_Pos))
      {
        /*The OSC HP mode is guaranteed to  be = 11b at this point
        * so we can just clear the bit(s) as per the selected mode
        */
        SCU_OSC->OSCHPCTRL &= (((uint32_t)(~(uint32_t)SCU_OSC_OSCHPCTRL_MODE_Msk)) | \
 801f05e:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 801f062:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f066:	f44f 428e 	mov.w	r2, #18176	; 0x4700
 801f06a:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f06e:	6852      	ldr	r2, [r2, #4]
 801f070:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 801f074:	605a      	str	r2, [r3, #4]
           ((uint32_t)CLK001_OSC_HP_MODE << SCU_OSC_OSCHPCTRL_MODE_Pos));

        /* setup OSC WDG divider - at this point the bitfield would be 0
        hence we can OR with the desired value*/
        SCU_OSC->OSCHPCTRL |=
 801f076:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 801f07a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f07e:	f44f 428e 	mov.w	r2, #18176	; 0x4700
 801f082:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f086:	6852      	ldr	r2, [r2, #4]
 801f088:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
 801f08c:	605a      	str	r2, [r3, #4]
          ((uint32_t)((CLK001_CLOCK_CRYSTAL_FREQUENCY/CLK001_SOSCWDG_FREF)-1)\
                                              <<SCU_OSC_OSCHPCTRL_OSCVAL_Pos);
        /* select external OSC as PLL input */
        SCU_PLL->PLLCON2 &= (uint32_t)~SCU_PLL_PLLCON2_PINSEL_Msk;
 801f08e:	f244 7310 	movw	r3, #18192	; 0x4710
 801f092:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f096:	f244 7210 	movw	r2, #18192	; 0x4710
 801f09a:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f09e:	68d2      	ldr	r2, [r2, #12]
 801f0a0:	f022 0201 	bic.w	r2, r2, #1
 801f0a4:	60da      	str	r2, [r3, #12]
        /* restart OSC Watchdog */
        SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 801f0a6:	f244 7310 	movw	r3, #18192	; 0x4710
 801f0aa:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f0ae:	f244 7210 	movw	r2, #18192	; 0x4710
 801f0b2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f0b6:	6852      	ldr	r2, [r2, #4]
 801f0b8:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 801f0bc:	605a      	str	r2, [r3, #4]

        /*approx loop count for 150ms @ max untrimmed Backup clock freq*/
        timeout_count = CLK001_LOOP_CNT_150MS; 
 801f0be:	f244 6350 	movw	r3, #18000	; 0x4650
 801f0c2:	607b      	str	r3, [r7, #4]
        do 
        {
          /* time out after ~150ms  */
          Delay(CLK001_DELAY_CNT_8US_50MHZ);  
 801f0c4:	f04f 000a 	mov.w	r0, #10
 801f0c8:	f7ff ff2a 	bl	801ef20 <Delay>
          timeout_count--;
 801f0cc:	687b      	ldr	r3, [r7, #4]
 801f0ce:	f103 33ff 	add.w	r3, r3, #4294967295
 801f0d2:	607b      	str	r3, [r7, #4]

        }while((((SCU_PLL->PLLSTAT) & CLK001_PLLSTAT_OSC_USABLE_MASK) != \
 801f0d4:	f244 7310 	movw	r3, #18192	; 0x4710
 801f0d8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f0dc:	681b      	ldr	r3, [r3, #0]
 801f0de:	f403 7360 	and.w	r3, r3, #896	; 0x380
 801f0e2:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 801f0e6:	d002      	beq.n	801f0ee <System_Clock_init+0x15e>
              CLK001_PLLSTAT_OSC_USABLE_MASK) && (timeout_count !=0U));
 801f0e8:	687b      	ldr	r3, [r7, #4]
 801f0ea:	2b00      	cmp	r3, #0
 801f0ec:	d1ea      	bne.n	801f0c4 <System_Clock_init+0x134>

        if (((SCU_PLL->PLLSTAT) & CLK001_PLLSTAT_OSC_USABLE_MASK) != \
 801f0ee:	f244 7310 	movw	r3, #18192	; 0x4710
 801f0f2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f0f6:	681b      	ldr	r3, [r3, #0]
 801f0f8:	f403 7360 	and.w	r3, r3, #896	; 0x380
 801f0fc:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 801f100:	d002      	beq.n	801f108 <System_Clock_init+0x178>
              CLK001_PLLSTAT_OSC_USABLE_MASK)
        {
           /* Return Error */
        	Return_status = 0U;
 801f102:	f04f 0300 	mov.w	r3, #0
 801f106:	60fb      	str	r3, [r7, #12]
    /*   Setup and lock the main PLL (PLL is in normal mode)                  */
    /**************************************************************************/
#if ((CLK001_CLOCK_SYS_SRC == CLK001_CLOCK_SRC_PLL) && \
    (CLK001_CLOCK_PLL_MODE == CLK001_CLOCK_PLL_NORMAL))
    {
      if ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)!= \
 801f108:	f244 7310 	movw	r3, #18192	; 0x4710
 801f10c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f110:	681b      	ldr	r3, [r3, #0]
 801f112:	f003 0304 	and.w	r3, r3, #4
 801f116:	2b00      	cmp	r3, #0
 801f118:	f040 8087 	bne.w	801f22a <System_Clock_init+0x29a>
       
        /*Calculation for stepping*/
#if((CLK001_PLL_CLOCK_INPUT == CLK001_CLOCK_CRYSTAL)||\
   (CLK001_PLL_CLOCK_INPUT == CLK001_CLOCK_EXT_CLOCK))
        {
          VCO = (CLK001_CLOCK_CRYSTAL_FREQUENCY/ \
 801f11c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 801f120:	f6c1 439c 	movt	r3, #7324	; 0x1c9c
 801f124:	60bb      	str	r3, [r7, #8]
#else /*PLL clcok source is back up clock in normal mode*/
        {
          VCO = (CLK001_CLOCK_BACK_UP/(CLK001_PLL_PDIV+1U))*(CLK001_PLL_NDIV+1U);
        }
#endif /*End of PLL clock source check in normal mode*/
        stepping_K2DIV = (VCO/CLK001_PLL_FREQ_STEP1)-1U;
 801f126:	68ba      	ldr	r2, [r7, #8]
 801f128:	f649 7381 	movw	r3, #40833	; 0x9f81
 801f12c:	f2c1 635e 	movt	r3, #5726	; 0x165e
 801f130:	fba3 1302 	umull	r1, r3, r3, r2
 801f134:	ea4f 5353 	mov.w	r3, r3, lsr #21
 801f138:	f103 33ff 	add.w	r3, r3, #4294967295
 801f13c:	603b      	str	r3, [r7, #0]
           
        /* Go to bypass the Main PLL */
        SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 801f13e:	f244 7310 	movw	r3, #18192	; 0x4710
 801f142:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f146:	f244 7210 	movw	r2, #18192	; 0x4710
 801f14a:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f14e:	6852      	ldr	r2, [r2, #4]
 801f150:	f042 0201 	orr.w	r2, r2, #1
 801f154:	605a      	str	r2, [r3, #4]
        /* disconnect Oscillator from PLL */
        SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 801f156:	f244 7310 	movw	r3, #18192	; 0x4710
 801f15a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f15e:	f244 7210 	movw	r2, #18192	; 0x4710
 801f162:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f166:	6852      	ldr	r2, [r2, #4]
 801f168:	f042 0210 	orr.w	r2, r2, #16
 801f16c:	605a      	str	r2, [r3, #4]
        /* Setup divider settings for main PLL */
        SCU_PLL->PLLCON1 =(((uint32_t)CLK001_PLL_K1DIV) | \
 801f16e:	f244 7310 	movw	r3, #18192	; 0x4710
 801f172:	f2c5 0300 	movt	r3, #20480	; 0x5000
               ((uint32_t)CLK001_PLL_NDIV<<SCU_PLL_PLLCON1_NDIV_Pos) | \
               ((uint32_t)stepping_K2DIV<<SCU_PLL_PLLCON1_K2DIV_Pos) | \
 801f176:	683a      	ldr	r2, [r7, #0]
 801f178:	ea4f 4202 	mov.w	r2, r2, lsl #16
 801f17c:	f442 521c 	orr.w	r2, r2, #9984	; 0x2700
        /* Go to bypass the Main PLL */
        SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
        /* disconnect Oscillator from PLL */
        SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
        /* Setup divider settings for main PLL */
        SCU_PLL->PLLCON1 =(((uint32_t)CLK001_PLL_K1DIV) | \
 801f180:	609a      	str	r2, [r3, #8]
               ((uint32_t)CLK001_PLL_NDIV<<SCU_PLL_PLLCON1_NDIV_Pos) | \
               ((uint32_t)stepping_K2DIV<<SCU_PLL_PLLCON1_K2DIV_Pos) | \
               ((uint32_t)CLK001_PLL_PDIV<<SCU_PLL_PLLCON1_PDIV_Pos));
        /* Set OSCDISCDIS */
        SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 801f182:	f244 7310 	movw	r3, #18192	; 0x4710
 801f186:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f18a:	f244 7210 	movw	r2, #18192	; 0x4710
 801f18e:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f192:	6852      	ldr	r2, [r2, #4]
 801f194:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801f198:	605a      	str	r2, [r3, #4]
        /* connect Oscillator to PLL */
        SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 801f19a:	f244 7310 	movw	r3, #18192	; 0x4710
 801f19e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f1a2:	f244 7210 	movw	r2, #18192	; 0x4710
 801f1a6:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f1aa:	6852      	ldr	r2, [r2, #4]
 801f1ac:	f022 0210 	bic.w	r2, r2, #16
 801f1b0:	605a      	str	r2, [r3, #4]
        /* restart PLL Lock detection */
        SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 801f1b2:	f244 7310 	movw	r3, #18192	; 0x4710
 801f1b6:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f1ba:	f244 7210 	movw	r2, #18192	; 0x4710
 801f1be:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f1c2:	6852      	ldr	r2, [r2, #4]
 801f1c4:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 801f1c8:	605a      	str	r2, [r3, #4]
        /* wait for PLL Lock */

        /* Timeout for wait loop ~150ms */
        /*approx loop count for 150ms @ Backup Clock freq*/
        timeout_count = CLK001_LOOP_CNT_150MS;
 801f1ca:	f244 6350 	movw	r3, #18000	; 0x4650
 801f1ce:	607b      	str	r3, [r7, #4]
        do
        {
          Delay(CLK001_DELAY_CNT_8US_50MHZ);  /*~8us Delay*/
 801f1d0:	f04f 000a 	mov.w	r0, #10
 801f1d4:	f7ff fea4 	bl	801ef20 <Delay>
          timeout_count--;
 801f1d8:	687b      	ldr	r3, [r7, #4]
 801f1da:	f103 33ff 	add.w	r3, r3, #4294967295
 801f1de:	607b      	str	r3, [r7, #4]
        } while (((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)!= \
 801f1e0:	f244 7310 	movw	r3, #18192	; 0x4710
 801f1e4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f1e8:	681b      	ldr	r3, [r3, #0]
 801f1ea:	f003 0304 	and.w	r3, r3, #4
 801f1ee:	2b00      	cmp	r3, #0
 801f1f0:	d102      	bne.n	801f1f8 <System_Clock_init+0x268>
		           SCU_PLL_PLLSTAT_VCOLOCK_Msk)&& (timeout_count !=0U));
 801f1f2:	687b      	ldr	r3, [r7, #4]
 801f1f4:	2b00      	cmp	r3, #0
 801f1f6:	d1eb      	bne.n	801f1d0 <System_Clock_init+0x240>

        if ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)== \
 801f1f8:	f244 7310 	movw	r3, #18192	; 0x4710
 801f1fc:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f200:	681b      	ldr	r3, [r3, #0]
 801f202:	f003 0304 	and.w	r3, r3, #4
 801f206:	2b00      	cmp	r3, #0
 801f208:	d00c      	beq.n	801f224 <System_Clock_init+0x294>
            SCU_PLL_PLLSTAT_VCOLOCK_Msk)
        {
          /* Disable bypass- put pll clock back */
          SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 801f20a:	f244 7310 	movw	r3, #18192	; 0x4710
 801f20e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f212:	f244 7210 	movw	r2, #18192	; 0x4710
 801f216:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f21a:	6852      	ldr	r2, [r2, #4]
 801f21c:	f022 0201 	bic.w	r2, r2, #1
 801f220:	605a      	str	r2, [r3, #4]
 801f222:	e002      	b.n	801f22a <System_Clock_init+0x29a>
        }
        else
        {
          
        	Return_status =0U;
 801f224:	f04f 0300 	mov.w	r3, #0
 801f228:	60fb      	str	r3, [r7, #12]
      /* Setup K1 divider for main PLL */
      SCU_PLL->PLLCON1 = CLK001_PLL_K1DIV;
    }
#endif /*end of Prescaler mode settings*/
	    /* Switch system clock to PLL */
    SCU_CLK->SYSCLKCR |=  (uint32_t)1 << SCU_CLK_SYSCLKCR_SYSSEL_Pos;
 801f22a:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 801f22e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f232:	f44f 428c 	mov.w	r2, #17920	; 0x4600
 801f236:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f23a:	68d2      	ldr	r2, [r2, #12]
 801f23c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 801f240:	60da      	str	r2, [r3, #12]
#if ((CLK001_CLOCK_SYS_SRC == CLK001_CLOCK_SRC_PLL) && \
    (CLK001_CLOCK_PLL_MODE == CLK001_CLOCK_PLL_NORMAL))
  {

    /* Reset OSCDISCDIS */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 801f242:	f244 7310 	movw	r3, #18192	; 0x4710
 801f246:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f24a:	f244 7210 	movw	r2, #18192	; 0x4710
 801f24e:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f252:	6852      	ldr	r2, [r2, #4]
 801f254:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 801f258:	605a      	str	r2, [r3, #4]
#if (CLK001_CLOCK_FSYS > CLK001_PLL_FREQ_STEP2)
    {
      /*********************************************************/
      /* Delay for next K2 step ~50?s */
      /*********************************************************/
      Delay(CLK001_DELAY_CNT_50US_50MHZ); /*~50us Backup clock*/
 801f25a:	f04f 0064 	mov.w	r0, #100	; 0x64
 801f25e:	f7ff fe5f 	bl	801ef20 <Delay>

      /*calculation for stepping*/
      stepping_K2DIV = (VCO/CLK001_PLL_FREQ_STEP2)-1;	
 801f262:	68bb      	ldr	r3, [r7, #8]
 801f264:	ea4f 2213 	mov.w	r2, r3, lsr #8
 801f268:	f245 43c7 	movw	r3, #21703	; 0x54c7
 801f26c:	f2c0 131e 	movt	r3, #286	; 0x11e
 801f270:	fba3 1302 	umull	r1, r3, r3, r2
 801f274:	ea4f 2393 	mov.w	r3, r3, lsr #10
 801f278:	f103 33ff 	add.w	r3, r3, #4294967295
 801f27c:	603b      	str	r3, [r7, #0]

      /*Setup divider settings for main PLL */
      SCU_PLL->PLLCON1 =(((uint32_t)CLK001_PLL_K1DIV) | \
 801f27e:	f244 7310 	movw	r3, #18192	; 0x4710
 801f282:	f2c5 0300 	movt	r3, #20480	; 0x5000
               ((uint32_t)CLK001_PLL_NDIV<<SCU_PLL_PLLCON1_NDIV_Pos)|\
               ((uint32_t)stepping_K2DIV<<SCU_PLL_PLLCON1_K2DIV_Pos)|\
 801f286:	683a      	ldr	r2, [r7, #0]
 801f288:	ea4f 4202 	mov.w	r2, r2, lsl #16
 801f28c:	f442 521c 	orr.w	r2, r2, #9984	; 0x2700

      /*calculation for stepping*/
      stepping_K2DIV = (VCO/CLK001_PLL_FREQ_STEP2)-1;	

      /*Setup divider settings for main PLL */
      SCU_PLL->PLLCON1 =(((uint32_t)CLK001_PLL_K1DIV) | \
 801f290:	609a      	str	r2, [r3, #8]
    {
      
      /*********************************************************/
      /* Delay for next K2 step ~50us */
      /*********************************************************/
      Delay(CLK001_DELAY_CNT_50US_50MHZ); /*~50?s @ 60MHz clock*/
 801f292:	f04f 0064 	mov.w	r0, #100	; 0x64
 801f296:	f7ff fe43 	bl	801ef20 <Delay>
      
      /*calulation for stepping*/
      stepping_K2DIV = (VCO/CLK001_PLL_FREQ_STEP3)-1;			
 801f29a:	68bb      	ldr	r3, [r7, #8]
 801f29c:	ea4f 12d3 	mov.w	r2, r3, lsr #7
 801f2a0:	f24e 332f 	movw	r3, #58159	; 0xe32f
 801f2a4:	f2c0 03be 	movt	r3, #190	; 0xbe
 801f2a8:	fba3 1302 	umull	r1, r3, r3, r2
 801f2ac:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 801f2b0:	f103 33ff 	add.w	r3, r3, #4294967295
 801f2b4:	603b      	str	r3, [r7, #0]

      /* Setup Divider settings for main PLL */

      SCU_PLL->PLLCON1 = (((uint32_t)CLK001_PLL_K1DIV) | \
 801f2b6:	f244 7310 	movw	r3, #18192	; 0x4710
 801f2ba:	f2c5 0300 	movt	r3, #20480	; 0x5000
                        ((uint32_t)CLK001_PLL_NDIV<<SCU_PLL_PLLCON1_NDIV_Pos)| \
              ((uint32_t)stepping_K2DIV<<SCU_PLL_PLLCON1_K2DIV_Pos)| \
 801f2be:	683a      	ldr	r2, [r7, #0]
 801f2c0:	ea4f 4202 	mov.w	r2, r2, lsl #16
 801f2c4:	f442 521c 	orr.w	r2, r2, #9984	; 0x2700
      /*calulation for stepping*/
      stepping_K2DIV = (VCO/CLK001_PLL_FREQ_STEP3)-1;			

      /* Setup Divider settings for main PLL */

      SCU_PLL->PLLCON1 = (((uint32_t)CLK001_PLL_K1DIV) | \
 801f2c8:	609a      	str	r2, [r3, #8]

    /*********************************************************/
    /* Delay for next K2 step ~50?s */
    /*********************************************************/

    Delay(CLK001_DELAY_CNT_50US_90MHZ); /*~50us @ 90 MHz clock*/
 801f2ca:	f04f 0096 	mov.w	r0, #150	; 0x96
 801f2ce:	f7ff fe27 	bl	801ef20 <Delay>

    /*********************************************************/

    /* Setup Divider settings for main PLL */
    SCU_PLL->PLLCON1 = (((uint32_t)CLK001_PLL_K1DIV) | \
 801f2d2:	f244 7310 	movw	r3, #18192	; 0x4710
 801f2d6:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f2da:	f44f 521c 	mov.w	r2, #9984	; 0x2700
 801f2de:	f2c0 0203 	movt	r2, #3
 801f2e2:	609a      	str	r2, [r3, #8]
            ((uint32_t)CLK001_PLL_NDIV<<SCU_PLL_PLLCON1_NDIV_Pos)  | \
            ((uint32_t)CLK001_PLL_K2DIV<<SCU_PLL_PLLCON1_K2DIV_Pos)| \
            ((uint32_t)CLK001_PLL_PDIV<<SCU_PLL_PLLCON1_PDIV_Pos));
            
    /* clear request for System OCS Watchdog Trap and System VCO Lock Trap  */
    SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_SOSCWDGT_Msk |\
 801f2e4:	f244 1360 	movw	r3, #16736	; 0x4160
 801f2e8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f2ec:	f04f 0205 	mov.w	r2, #5
 801f2f0:	60da      	str	r2, [r3, #12]
                        SCU_TRAP_TRAPCLR_SVCOLCKT_Msk; 
  }/*end PLL frequency stepping...*/
#endif /*end of PLL frequency stepping in case of PLL normal mode*/
   /*return success*/
  return Return_status;
 801f2f2:	68fb      	ldr	r3, [r7, #12]
}
 801f2f4:	4618      	mov	r0, r3
 801f2f6:	f107 0710 	add.w	r7, r7, #16
 801f2fa:	46bd      	mov	sp, r7
 801f2fc:	bd80      	pop	{r7, pc}
 801f2fe:	bf00      	nop

0801f300 <USB_Clock_valid>:
  * @note   -  
  * @param  None
  * @retval PASS/FAIL
  */
static uint32_t	USB_Clock_valid(void)
{
 801f300:	b480      	push	{r7}
 801f302:	b083      	sub	sp, #12
 801f304:	af00      	add	r7, sp, #0
  uint32_t USB_clock_status = 1U;
 801f306:	f04f 0301 	mov.w	r3, #1
 801f30a:	607b      	str	r3, [r7, #4]
  /* check if PLL is switched on */
  if((SCU_PLL->USBPLLCON &(SCU_PLL_USBPLLCON_VCOPWD_Msk | \
 801f30c:	f244 7310 	movw	r3, #18192	; 0x4710
 801f310:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f314:	695a      	ldr	r2, [r3, #20]
 801f316:	f04f 0302 	mov.w	r3, #2
 801f31a:	f2c0 0301 	movt	r3, #1
 801f31e:	4013      	ands	r3, r2
 801f320:	2b00      	cmp	r3, #0
 801f322:	d002      	beq.n	801f32a <USB_Clock_valid+0x2a>
                           SCU_PLL_USBPLLCON_PLLPWD_Msk)) != 0U)
  {
    USB_clock_status=0U;
 801f324:	f04f 0300 	mov.w	r3, #0
 801f328:	607b      	str	r3, [r7, #4]
  }
  return(USB_clock_status);
 801f32a:	687b      	ldr	r3, [r7, #4]
}
 801f32c:	4618      	mov	r0, r3
 801f32e:	f107 070c 	add.w	r7, r7, #12
 801f332:	46bd      	mov	sp, r7
 801f334:	bc80      	pop	{r7}
 801f336:	4770      	bx	lr

0801f338 <USB_Clock_init>:
  * @note   -  
  * @param  None
  * @retval PASS/FAIL
  */
static uint32_t	USB_Clock_init(void)
{
 801f338:	b580      	push	{r7, lr}
 801f33a:	b082      	sub	sp, #8
 801f33c:	af00      	add	r7, sp, #0

  uint32_t timeout_count;
  uint32_t Return_status = 1U;
 801f33e:	f04f 0301 	mov.w	r3, #1
 801f342:	603b      	str	r3, [r7, #0]
  /* enable USB PLL first */
  SCU_PLL->USBPLLCON &= (uint32_t)~(SCU_PLL_USBPLLCON_VCOPWD_Msk | \
 801f344:	f244 7310 	movw	r3, #18192	; 0x4710
 801f348:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f34c:	f244 7210 	movw	r2, #18192	; 0x4710
 801f350:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f354:	6952      	ldr	r2, [r2, #20]
 801f356:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 801f35a:	f022 0202 	bic.w	r2, r2, #2
 801f35e:	615a      	str	r2, [r3, #20]
                         SCU_PLL_USBPLLCON_PLLPWD_Msk);

  /* check and if not already running enable OSC_HP */
  if ((SCU_OSC->OSCHPCTRL & SCU_OSC_OSCHPCTRL_MODE_Msk) != \
 801f360:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 801f364:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f368:	685b      	ldr	r3, [r3, #4]
 801f36a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 801f36e:	2b00      	cmp	r3, #0
 801f370:	d062      	beq.n	801f438 <USB_Clock_init+0x100>
     ((uint32_t)CLK001_OSC_HP_MODE << SCU_OSC_OSCHPCTRL_MODE_Pos))
  {
    /* check if Main PLL is switched on for OSC WD*/
    if ((SCU_PLL->PLLCON0 &(SCU_PLL_PLLCON0_VCOPWD_Msk | \
 801f372:	f244 7310 	movw	r3, #18192	; 0x4710
 801f376:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f37a:	685a      	ldr	r2, [r3, #4]
 801f37c:	f04f 0302 	mov.w	r3, #2
 801f380:	f2c0 0301 	movt	r3, #1
 801f384:	4013      	ands	r3, r2
 801f386:	2b00      	cmp	r3, #0
 801f388:	d00d      	beq.n	801f3a6 <USB_Clock_init+0x6e>
        SCU_PLL_PLLCON0_PLLPWD_Msk)) != 0U)
    {
      /* enable PLL first */
      SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | \
 801f38a:	f244 7310 	movw	r3, #18192	; 0x4710
 801f38e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f392:	f244 7210 	movw	r2, #18192	; 0x4710
 801f396:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f39a:	6852      	ldr	r2, [r2, #4]
 801f39c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 801f3a0:	f022 0202 	bic.w	r2, r2, #2
 801f3a4:	605a      	str	r2, [r3, #4]
    }

    /*The OSC HP mode is guaranteed to  be = 11b at this point
    * so we can just clear the bit(s) as per the selected mode
    */
    SCU_OSC->OSCHPCTRL &= (((uint32_t)(~(uint32_t)SCU_OSC_OSCHPCTRL_MODE_Msk)) | \
 801f3a6:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 801f3aa:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f3ae:	f44f 428e 	mov.w	r2, #18176	; 0x4700
 801f3b2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f3b6:	6852      	ldr	r2, [r2, #4]
 801f3b8:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 801f3bc:	605a      	str	r2, [r3, #4]
       ((uint32_t)CLK001_OSC_HP_MODE << SCU_OSC_OSCHPCTRL_MODE_Pos));
   
    /* setup OSC WDG Divider */
    SCU_OSC->OSCHPCTRL|=
 801f3be:	f44f 438e 	mov.w	r3, #18176	; 0x4700
 801f3c2:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f3c6:	f44f 428e 	mov.w	r2, #18176	; 0x4700
 801f3ca:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f3ce:	6852      	ldr	r2, [r2, #4]
 801f3d0:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
 801f3d4:	605a      	str	r2, [r3, #4]
      ((uint32_t)((CLK001_CLOCK_CRYSTAL_FREQUENCY/CLK001_SOSCWDG_FREF)-1U)\
                                           <<SCU_OSC_OSCHPCTRL_OSCVAL_Pos);
   
    /* restart OSC Watchdog */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;  
 801f3d6:	f244 7310 	movw	r3, #18192	; 0x4710
 801f3da:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f3de:	f244 7210 	movw	r2, #18192	; 0x4710
 801f3e2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f3e6:	6852      	ldr	r2, [r2, #4]
 801f3e8:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 801f3ec:	605a      	str	r2, [r3, #4]

     /* Timeout for wait loo ~150ms */
    /********************************/	  
    /*approx loop count for 150ms @ Backup Clock freq*/
    timeout_count = CLK001_LOOP_CNT_150MS;
 801f3ee:	f244 6350 	movw	r3, #18000	; 0x4650
 801f3f2:	607b      	str	r3, [r7, #4]
    do
    {
      Delay(CLK001_DELAY_CNT_8US_50MHZ);  /*~8us Delay*/
 801f3f4:	f04f 000a 	mov.w	r0, #10
 801f3f8:	f7ff fd92 	bl	801ef20 <Delay>
      timeout_count--;
 801f3fc:	687b      	ldr	r3, [r7, #4]
 801f3fe:	f103 33ff 	add.w	r3, r3, #4294967295
 801f402:	607b      	str	r3, [r7, #4]

    }while((((SCU_PLL->PLLSTAT) & CLK001_PLLSTAT_OSC_USABLE_MASK) != \
 801f404:	f244 7310 	movw	r3, #18192	; 0x4710
 801f408:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f40c:	681b      	ldr	r3, [r3, #0]
 801f40e:	f403 7360 	and.w	r3, r3, #896	; 0x380
 801f412:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 801f416:	d002      	beq.n	801f41e <USB_Clock_init+0xe6>
          CLK001_PLLSTAT_OSC_USABLE_MASK) && (timeout_count !=0U));
 801f418:	687b      	ldr	r3, [r7, #4]
 801f41a:	2b00      	cmp	r3, #0
 801f41c:	d1ea      	bne.n	801f3f4 <USB_Clock_init+0xbc>

    if (((SCU_PLL->PLLSTAT) & CLK001_PLLSTAT_OSC_USABLE_MASK) != \
 801f41e:	f244 7310 	movw	r3, #18192	; 0x4710
 801f422:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f426:	681b      	ldr	r3, [r3, #0]
 801f428:	f403 7360 	and.w	r3, r3, #896	; 0x380
 801f42c:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 801f430:	d002      	beq.n	801f438 <USB_Clock_init+0x100>
          CLK001_PLLSTAT_OSC_USABLE_MASK)
    {
      Return_status =0U;/* Return Error */
 801f432:	f04f 0300 	mov.w	r3, #0
 801f436:	603b      	str	r3, [r7, #0]
    }
  }

  /* Setup USB PLL */
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 801f438:	f244 7310 	movw	r3, #18192	; 0x4710
 801f43c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f440:	f244 7210 	movw	r2, #18192	; 0x4710
 801f444:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f448:	6952      	ldr	r2, [r2, #20]
 801f44a:	f042 0201 	orr.w	r2, r2, #1
 801f44e:	615a      	str	r2, [r3, #20]
  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 801f450:	f244 7310 	movw	r3, #18192	; 0x4710
 801f454:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f458:	f244 7210 	movw	r2, #18192	; 0x4710
 801f45c:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f460:	6952      	ldr	r2, [r2, #20]
 801f462:	f042 0210 	orr.w	r2, r2, #16
 801f466:	615a      	str	r2, [r3, #20]
  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON =(((uint32_t)CLK001_USBPLL_NDIV<<SCU_PLL_USBPLLCON_NDIV_Pos)|\
 801f468:	f244 7310 	movw	r3, #18192	; 0x4710
 801f46c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f470:	f44f 527c 	mov.w	r2, #16128	; 0x3f00
 801f474:	f2c0 1200 	movt	r2, #256	; 0x100
 801f478:	615a      	str	r2, [r3, #20]
                      ((uint32_t)CLK001_USBPLL_PDIV<<SCU_PLL_USBPLLCON_PDIV_Pos));
  /* Setup USBDIV settings USB clock */
  SCU_CLK->USBCLKCR = CLK001_USBDIV;
 801f47a:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 801f47e:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f482:	f04f 0203 	mov.w	r2, #3
 801f486:	619a      	str	r2, [r3, #24]
  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 801f488:	f244 7310 	movw	r3, #18192	; 0x4710
 801f48c:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f490:	f244 7210 	movw	r2, #18192	; 0x4710
 801f494:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f498:	6952      	ldr	r2, [r2, #20]
 801f49a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 801f49e:	615a      	str	r2, [r3, #20]
  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 801f4a0:	f244 7310 	movw	r3, #18192	; 0x4710
 801f4a4:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f4a8:	f244 7210 	movw	r2, #18192	; 0x4710
 801f4ac:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f4b0:	6952      	ldr	r2, [r2, #20]
 801f4b2:	f022 0210 	bic.w	r2, r2, #16
 801f4b6:	615a      	str	r2, [r3, #20]
  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 801f4b8:	f244 7310 	movw	r3, #18192	; 0x4710
 801f4bc:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f4c0:	f244 7210 	movw	r2, #18192	; 0x4710
 801f4c4:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f4c8:	6952      	ldr	r2, [r2, #20]
 801f4ca:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 801f4ce:	615a      	str	r2, [r3, #20]

  /* wait for PLL Lock */
  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk)!= \
 801f4d0:	bf00      	nop
 801f4d2:	f244 7310 	movw	r3, #18192	; 0x4710
 801f4d6:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f4da:	691b      	ldr	r3, [r3, #16]
 801f4dc:	f003 0304 	and.w	r3, r3, #4
 801f4e0:	2b00      	cmp	r3, #0
 801f4e2:	d0f6      	beq.n	801f4d2 <USB_Clock_init+0x19a>
          SCU_PLL_USBPLLSTAT_VCOLOCK_Msk)
  {}

  /* Enable USB Clock */
  SCU_CLK->CLKSET |= (uint32_t)SCU_CLK_CLKSET_USBCEN_Msk;
 801f4e4:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 801f4e8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f4ec:	f44f 428c 	mov.w	r2, #17920	; 0x4600
 801f4f0:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f4f4:	6852      	ldr	r2, [r2, #4]
 801f4f6:	f042 0201 	orr.w	r2, r2, #1
 801f4fa:	605a      	str	r2, [r3, #4]

  return Return_status;
 801f4fc:	683b      	ldr	r3, [r7, #0]
} 
 801f4fe:	4618      	mov	r0, r3
 801f500:	f107 0708 	add.w	r7, r7, #8
 801f504:	46bd      	mov	sp, r7
 801f506:	bd80      	pop	{r7, pc}

0801f508 <MMC_Clock_init>:
  * @brief  Function to enable the MMC clock 
  * @note   -  
  * @param  None
  * @retval None
  */
static void MMC_Clock_init(void){
 801f508:	b480      	push	{r7}
 801f50a:	af00      	add	r7, sp, #0
  /* Enable MMC Clock */
  SCU_CLK->CLKSET |= (uint32_t)SCU_CLK_CLKSET_MMCCEN_Msk;
 801f50c:	f44f 438c 	mov.w	r3, #17920	; 0x4600
 801f510:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f514:	f44f 428c 	mov.w	r2, #17920	; 0x4600
 801f518:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f51c:	6852      	ldr	r2, [r2, #4]
 801f51e:	f042 0202 	orr.w	r2, r2, #2
 801f522:	605a      	str	r2, [r3, #4]
}
 801f524:	46bd      	mov	sp, r7
 801f526:	bc80      	pop	{r7}
 801f528:	4770      	bx	lr
 801f52a:	bf00      	nop

0801f52c <RTC_Clock_init>:
  * @note   -  
  * @param  None
  * @retval None
  */
static void RTC_Clock_init(void)
{
 801f52c:	b480      	push	{r7}
 801f52e:	af00      	add	r7, sp, #0
  /*before enabling hibernate domain (if opted), check if it is already enabled.
  we do not repeat the enable if already done*/
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0U )
 801f530:	f44f 4384 	mov.w	r3, #16896	; 0x4200
 801f534:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f538:	681b      	ldr	r3, [r3, #0]
 801f53a:	f003 0301 	and.w	r3, r3, #1
 801f53e:	2b00      	cmp	r3, #0
 801f540:	d110      	bne.n	801f564 <RTC_Clock_init+0x38>
  {
    /* Enable hibernate domain */
    SCU_POWER->PWRSET = (uint32_t)(SCU_POWER_PWRSET_HIB_Msk);
 801f542:	f44f 4384 	mov.w	r3, #16896	; 0x4200
 801f546:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f54a:	f04f 0201 	mov.w	r2, #1
 801f54e:	605a      	str	r2, [r3, #4]
    
    /* Wait until hibernate enable status is set */
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk)!= \
 801f550:	bf00      	nop
 801f552:	f44f 4384 	mov.w	r3, #16896	; 0x4200
 801f556:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f55a:	681b      	ldr	r3, [r3, #0]
 801f55c:	f003 0301 	and.w	r3, r3, #1
 801f560:	2b00      	cmp	r3, #0
 801f562:	d0f6      	beq.n	801f552 <RTC_Clock_init+0x26>
         SCU_POWER_PWRSTAT_HIBEN_Msk)
    {}
  }
  /* check for HIB Domain is not in reset state  */
  if ((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0U)
 801f564:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 801f568:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f56c:	681b      	ldr	r3, [r3, #0]
 801f56e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 801f572:	2b00      	cmp	r3, #0
 801f574:	d00b      	beq.n	801f58e <RTC_Clock_init+0x62>
  {
	  SCU_RESET->RSTCLR |= (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk; /*de-assert hibernate reset*/
 801f576:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 801f57a:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f57e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 801f582:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f586:	6892      	ldr	r2, [r2, #8]
 801f588:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 801f58c:	609a      	str	r2, [r3, #8]
  }
  /*RTC Clock Source Selection*/   
    /* Enable internal slow clock */
	/*Selecting RTC Clock Source*/
  SCU_HIBERNATE->HDCR |= ((0U << SCU_HIBERNATE_HDCR_RCS_Pos) & \
 801f58e:	f44f 4386 	mov.w	r3, #17152	; 0x4300
 801f592:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f596:	f44f 4286 	mov.w	r2, #17152	; 0x4300
 801f59a:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f59e:	68d2      	ldr	r2, [r2, #12]
 801f5a0:	60da      	str	r2, [r3, #12]
                         SCU_HIBERNATE_HDCR_RCS_Msk); 
  while((SCU_INTERRUPT->SRRAW & SCU_INTERRUPT_SRRAW_HDCR_Msk)!= \
 801f5a2:	bf00      	nop
 801f5a4:	f244 0374 	movw	r3, #16500	; 0x4074
 801f5a8:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f5ac:	685b      	ldr	r3, [r3, #4]
 801f5ae:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 801f5b2:	2b00      	cmp	r3, #0
 801f5b4:	d0f6      	beq.n	801f5a4 <RTC_Clock_init+0x78>
         SCU_INTERRUPT_SRRAW_HDCR_Msk)
  {}
  SCU_INTERRUPT->SRCLR |= (uint32_t)SCU_INTERRUPT_SRCLR_HDCR_Msk;
 801f5b6:	f244 0374 	movw	r3, #16500	; 0x4074
 801f5ba:	f2c5 0300 	movt	r3, #20480	; 0x5000
 801f5be:	f244 0274 	movw	r2, #16500	; 0x4074
 801f5c2:	f2c5 0200 	movt	r2, #20480	; 0x5000
 801f5c6:	68d2      	ldr	r2, [r2, #12]
 801f5c8:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 801f5cc:	60da      	str	r2, [r3, #12]
	
}
 801f5ce:	46bd      	mov	sp, r7
 801f5d0:	bc80      	pop	{r7}
 801f5d2:	4770      	bx	lr

0801f5d4 <CLK001_Init>:
  * @note   -  
  * @param  None
  * @retval None
  */
void CLK001_Init(void)
{
 801f5d4:	b580      	push	{r7, lr}
 801f5d6:	af00      	add	r7, sp, #0
  /*<<<DD_CLK001_API_1>>>*/
 /*  Function to check the clock status based on UI configuration */
  if(System_Clock_valid() == 0U)
 801f5d8:	f7ff fcbe 	bl	801ef58 <System_Clock_valid>
 801f5dc:	4603      	mov	r3, r0
 801f5de:	2b00      	cmp	r3, #0
 801f5e0:	d101      	bne.n	801f5e6 <CLK001_Init+0x12>
  {   
    /*  Function to initialize the System Clock based on UI configuration */
    System_Clock_init();
 801f5e2:	f7ff fcd5 	bl	801ef90 <System_Clock_init>
  }     
  /*  Function to initialize the USB Clock based on UI configuration */     
  if(USB_Clock_valid() == 0U)
 801f5e6:	f7ff fe8b 	bl	801f300 <USB_Clock_valid>
 801f5ea:	4603      	mov	r3, r0
 801f5ec:	2b00      	cmp	r3, #0
 801f5ee:	d101      	bne.n	801f5f4 <CLK001_Init+0x20>
  {   
  	USB_Clock_init();
 801f5f0:	f7ff fea2 	bl	801f338 <USB_Clock_init>
  } 


  /*  Function to enable the MMC Clock based on UI configuration */
  MMC_Clock_init();
 801f5f4:	f7ff ff88 	bl	801f508 <MMC_Clock_init>
 
   /*  Function to initialize the RTC Clock based on UI configuration */     
  RTC_Clock_init();   
 801f5f8:	f7ff ff98 	bl	801f52c <RTC_Clock_init>
  /* Update the clock variable */
  SystemCoreClockUpdate();
 801f5fc:	f7e1 fabe 	bl	8000b7c <SystemCoreClockUpdate>
}
 801f600:	bd80      	pop	{r7, pc}
 801f602:	bf00      	nop

0801f604 <AllowPLLInitByStartup>:
 * loading.
 *
 * Return 0 to disallow CStart from performing clock tree setup.
 */
uint32_t AllowPLLInitByStartup(void)
{
 801f604:	b480      	push	{r7}
 801f606:	af00      	add	r7, sp, #0
	/*
	 * Let the CStart know that there is no more a need to perform clock tree
	 * initialization.
	 */
	return 0U;
 801f608:	f04f 0300 	mov.w	r3, #0
}
 801f60c:	4618      	mov	r0, r3
 801f60e:	46bd      	mov	sp, r7
 801f610:	bc80      	pop	{r7}
 801f612:	4770      	bx	lr

0801f614 <ADCGROUP001_Init>:



/** This function initializes the app */
void ADCGROUP001_Init(void)
{
 801f614:	b580      	push	{r7, lr}
 801f616:	af00      	add	r7, sp, #0
/*Initialize the global app */
  ADCGLOB001_Init();    
 801f618:	f000 fd20 	bl	802005c <ADCGLOB001_Init>
  ADCGROUP001_lInit(&ADCGROUP001_Handle0);   
 801f61c:	f646 0090 	movw	r0, #26768	; 0x6890
 801f620:	f6c0 0002 	movt	r0, #2050	; 0x802
 801f624:	f000 f802 	bl	801f62c <ADCGROUP001_lInit>
}
 801f628:	bd80      	pop	{r7, pc}
 801f62a:	bf00      	nop

0801f62c <ADCGROUP001_lInit>:
/* 
 * This Function initializes the adcgroup App. Local function is used to 
 * initialize all the instances of the app.
 */
void ADCGROUP001_lInit(const ADCGROUP001_HandleType *HandlePtr )
{
 801f62c:	b580      	push	{r7, lr}
 801f62e:	b084      	sub	sp, #16
 801f630:	af00      	add	r7, sp, #0
 801f632:	6078      	str	r0, [r7, #4]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;     
  /* Pointer to the VADC Kernel Structure */   
  VADC_GLOBAL_TypeDef *VADCGlobalPtr; 
  
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;
 801f634:	687b      	ldr	r3, [r7, #4]
 801f636:	691b      	ldr	r3, [r3, #16]
 801f638:	60fb      	str	r3, [r7, #12]
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801f63a:	687b      	ldr	r3, [r7, #4]
 801f63c:	695b      	ldr	r3, [r3, #20]
 801f63e:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);
  
  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_UNINITIALIZED))
 801f640:	687b      	ldr	r3, [r7, #4]
 801f642:	68db      	ldr	r3, [r3, #12]
 801f644:	781b      	ldrb	r3, [r3, #0]
 801f646:	2b00      	cmp	r3, #0
 801f648:	f040 80b9 	bne.w	801f7be <ADCGROUP001_lInit+0x192>
  {
    
    /* Set the Post calibration enable\disable */
    WR_REG(VADCGlobalPtr->GLOBCFG, VADC_GLOBCFG_DPCAL0_Msk, 
 801f64c:	687b      	ldr	r3, [r7, #4]
 801f64e:	785b      	ldrb	r3, [r3, #1]
 801f650:	461a      	mov	r2, r3
 801f652:	687b      	ldr	r3, [r7, #4]
 801f654:	781b      	ldrb	r3, [r3, #0]
 801f656:	f103 0310 	add.w	r3, r3, #16
 801f65a:	fa02 f303 	lsl.w	r3, r2, r3
 801f65e:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
 801f662:	68fb      	ldr	r3, [r7, #12]
 801f664:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801f668:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 801f66c:	431a      	orrs	r2, r3
 801f66e:	68fb      	ldr	r3, [r7, #12]
 801f670:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
          ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + HandlePtr->kGroupNo),
            HandlePtr->kPostCalibration);

    /*  Converter is permanently on */
    WR_REG(VADCGroupPtr->ARBCFG, VADC_G_ARBCFG_ANONC_Msk, 
 801f674:	687b      	ldr	r3, [r7, #4]
 801f676:	7adb      	ldrb	r3, [r3, #11]
 801f678:	f003 0203 	and.w	r2, r3, #3
 801f67c:	68bb      	ldr	r3, [r7, #8]
 801f67e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801f682:	f023 0303 	bic.w	r3, r3, #3
 801f686:	431a      	orrs	r2, r3
 801f688:	68bb      	ldr	r3, [r7, #8]
 801f68a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
           VADC_G_ARBCFG_ANONC_Pos, (uint32_t)HandlePtr->kAnalogConverterCtrl);

    /* Set the Arbitration mode */
    WR_REG(VADCGroupPtr->ARBCFG, VADC_G_ARBCFG_ARBM_Msk, VADC_G_ARBCFG_ARBM_Pos,
 801f68e:	687b      	ldr	r3, [r7, #4]
 801f690:	789b      	ldrb	r3, [r3, #2]
 801f692:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 801f696:	b2da      	uxtb	r2, r3
 801f698:	68bb      	ldr	r3, [r7, #8]
 801f69a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801f69e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 801f6a2:	431a      	orrs	r2, r3
 801f6a4:	68bb      	ldr	r3, [r7, #8]
 801f6a6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                                         (uint32_t)HandlePtr->kArbitrationMode);

    /* Set the Group specific boundary 0 */
    WR_REG(VADCGroupPtr->BOUND, VADC_G_BOUND_BOUNDARY0_Msk,
 801f6aa:	687b      	ldr	r3, [r7, #4]
 801f6ac:	889b      	ldrh	r3, [r3, #4]
 801f6ae:	ea4f 5203 	mov.w	r2, r3, lsl #20
 801f6b2:	ea4f 5212 	mov.w	r2, r2, lsr #20
 801f6b6:	68bb      	ldr	r3, [r7, #8]
 801f6b8:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801f6bc:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 801f6c0:	f023 030f 	bic.w	r3, r3, #15
 801f6c4:	431a      	orrs	r2, r3
 801f6c6:	68bb      	ldr	r3, [r7, #8]
 801f6c8:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
               VADC_G_BOUND_BOUNDARY0_Pos, (uint32_t)HandlePtr->kGrpBoundary0);
    
    /* Set the Group specific boundary 1 */
    WR_REG(VADCGroupPtr->BOUND, VADC_G_BOUND_BOUNDARY1_Msk,
 801f6cc:	687b      	ldr	r3, [r7, #4]
 801f6ce:	88db      	ldrh	r3, [r3, #6]
 801f6d0:	ea4f 4203 	mov.w	r2, r3, lsl #16
 801f6d4:	f04f 0300 	mov.w	r3, #0
 801f6d8:	f6c0 73ff 	movt	r3, #4095	; 0xfff
 801f6dc:	4013      	ands	r3, r2
 801f6de:	68ba      	ldr	r2, [r7, #8]
 801f6e0:	f8d2 20b8 	ldr.w	r2, [r2, #184]	; 0xb8
 801f6e4:	f022 627f 	bic.w	r2, r2, #267386880	; 0xff00000
 801f6e8:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 801f6ec:	431a      	orrs	r2, r3
 801f6ee:	68bb      	ldr	r3, [r7, #8]
 801f6f0:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
                                                
    /*
     * Enable write control for EMUX configuration.
     * Set the EMUX coding scheme, EMUX mode, EMUX start select.
     */
    VADCGroupPtr->EMUXCTR |= (uint32_t)((((uint32_t)1 << VADC_G_EMUXCTR_EMXWC_Pos) & VADC_G_EMUXCTR_EMXWC_Msk) | \
 801f6f4:	68bb      	ldr	r3, [r7, #8]
 801f6f6:	f8d3 21f0 	ldr.w	r2, [r3, #496]	; 0x1f0
                                        (((uint32_t)HandlePtr->kEMUXCodeScheme \
 801f6fa:	687b      	ldr	r3, [r7, #4]
 801f6fc:	7a1b      	ldrb	r3, [r3, #8]
                                                << VADC_G_EMUXCTR_EMXCOD_Pos) & VADC_G_EMUXCTR_EMXCOD_Msk) | \
 801f6fe:	ea4f 7303 	mov.w	r3, r3, lsl #28
 801f702:	f003 5180 	and.w	r1, r3, #268435456	; 0x10000000
                                        (((uint32_t)HandlePtr->kEMUXStartSelect  \
 801f706:	687b      	ldr	r3, [r7, #4]
 801f708:	7a5b      	ldrb	r3, [r3, #9]
                                              << VADC_G_EMUXCTR_EMUXSET_Pos) & VADC_G_EMUXCTR_EMUXSET_Msk) | \
 801f70a:	f003 0307 	and.w	r3, r3, #7
     * Enable write control for EMUX configuration.
     * Set the EMUX coding scheme, EMUX mode, EMUX start select.
     */
    VADCGroupPtr->EMUXCTR |= (uint32_t)((((uint32_t)1 << VADC_G_EMUXCTR_EMXWC_Pos) & VADC_G_EMUXCTR_EMXWC_Msk) | \
                                        (((uint32_t)HandlePtr->kEMUXCodeScheme \
                                                << VADC_G_EMUXCTR_EMXCOD_Pos) & VADC_G_EMUXCTR_EMXCOD_Msk) | \
 801f70e:	4319      	orrs	r1, r3
                                        (((uint32_t)HandlePtr->kEMUXStartSelect  \
                                              << VADC_G_EMUXCTR_EMUXSET_Pos) & VADC_G_EMUXCTR_EMUXSET_Msk) | \
                                        (((uint32_t)HandlePtr->kEMUXMode \
 801f710:	687b      	ldr	r3, [r7, #4]
 801f712:	7a9b      	ldrb	r3, [r3, #10]
                                              << VADC_G_EMUXCTR_EMUXMODE_Pos) & VADC_G_EMUXCTR_EMUXMODE_Msk));
 801f714:	ea4f 6383 	mov.w	r3, r3, lsl #26
 801f718:	f003 6340 	and.w	r3, r3, #201326592	; 0xc000000
                                                
    /*
     * Enable write control for EMUX configuration.
     * Set the EMUX coding scheme, EMUX mode, EMUX start select.
     */
    VADCGroupPtr->EMUXCTR |= (uint32_t)((((uint32_t)1 << VADC_G_EMUXCTR_EMXWC_Pos) & VADC_G_EMUXCTR_EMXWC_Msk) | \
 801f71c:	430b      	orrs	r3, r1
 801f71e:	4313      	orrs	r3, r2
 801f720:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 801f724:	68bb      	ldr	r3, [r7, #8]
 801f726:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
  
    /*
     * Set conversion mode, EMUX conversion mode, sample time control,
     * Set EMUX sample time control for class 0. 
     */
    VADCGroupPtr->ICLASS[0] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass0 \
 801f72a:	68bb      	ldr	r3, [r7, #8]
 801f72c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 801f730:	687b      	ldr	r3, [r7, #4]
 801f732:	7e1b      	ldrb	r3, [r3, #24]
                                                << VADC_G_ICLASS_CMS_Pos) & VADC_G_ICLASS_CMS_Msk) | \
 801f734:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801f738:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                                          (((uint32_t)HandlePtr->kEMUXConversionModeClass0 \
 801f73c:	687b      	ldr	r3, [r7, #4]
 801f73e:	7f1b      	ldrb	r3, [r3, #28]
                                                << VADC_G_ICLASS_CME_Pos) & VADC_G_ICLASS_CME_Msk) | \
 801f740:	ea4f 6303 	mov.w	r3, r3, lsl #24
 801f744:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    /*
     * Set conversion mode, EMUX conversion mode, sample time control,
     * Set EMUX sample time control for class 0. 
     */
    VADCGroupPtr->ICLASS[0] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass0 \
                                                << VADC_G_ICLASS_CMS_Pos) & VADC_G_ICLASS_CMS_Msk) | \
 801f748:	4319      	orrs	r1, r3
                                          (((uint32_t)HandlePtr->kEMUXConversionModeClass0 \
                                                << VADC_G_ICLASS_CME_Pos) & VADC_G_ICLASS_CME_Msk) | \
                                          (((uint32_t)HandlePtr->kSampleTimeControlClass0 \
 801f74a:	687b      	ldr	r3, [r7, #4]
 801f74c:	7e9b      	ldrb	r3, [r3, #26]
                                                << VADC_G_ICLASS_STCS_Pos) & VADC_G_ICLASS_STCS_Msk) | \
 801f74e:	f003 031f 	and.w	r3, r3, #31
     * Set EMUX sample time control for class 0. 
     */
    VADCGroupPtr->ICLASS[0] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass0 \
                                                << VADC_G_ICLASS_CMS_Pos) & VADC_G_ICLASS_CMS_Msk) | \
                                          (((uint32_t)HandlePtr->kEMUXConversionModeClass0 \
                                                << VADC_G_ICLASS_CME_Pos) & VADC_G_ICLASS_CME_Msk) | \
 801f752:	4319      	orrs	r1, r3
                                          (((uint32_t)HandlePtr->kSampleTimeControlClass0 \
                                                << VADC_G_ICLASS_STCS_Pos) & VADC_G_ICLASS_STCS_Msk) | \
                                          (((uint32_t)HandlePtr->kEMUXSampleTimeControlClass0 \
 801f754:	687b      	ldr	r3, [r7, #4]
 801f756:	7f9b      	ldrb	r3, [r3, #30]
                                                << VADC_G_ICLASS_STCE_Pos) & VADC_G_ICLASS_STCE_Msk));
 801f758:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801f75c:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
  
    /*
     * Set conversion mode, EMUX conversion mode, sample time control,
     * Set EMUX sample time control for class 0. 
     */
    VADCGroupPtr->ICLASS[0] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass0 \
 801f760:	430b      	orrs	r3, r1
 801f762:	431a      	orrs	r2, r3
 801f764:	68bb      	ldr	r3, [r7, #8]
 801f766:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
                                                
    /*
     * Set conversion mode, EMUX conversion mode, sample time control,  
     * EMUX sample time control for class 1. 
     */
    VADCGroupPtr->ICLASS[1] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass1 \
 801f76a:	68bb      	ldr	r3, [r7, #8]
 801f76c:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 801f770:	687b      	ldr	r3, [r7, #4]
 801f772:	7e5b      	ldrb	r3, [r3, #25]
                                                << VADC_G_ICLASS_CMS_Pos) & VADC_G_ICLASS_CMS_Msk) | \
 801f774:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801f778:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                                          (((uint32_t)HandlePtr->kEMUXConversionModeClass1 \
 801f77c:	687b      	ldr	r3, [r7, #4]
 801f77e:	7f5b      	ldrb	r3, [r3, #29]
                                                << VADC_G_ICLASS_CME_Pos) & VADC_G_ICLASS_CME_Msk) | \
 801f780:	ea4f 6303 	mov.w	r3, r3, lsl #24
 801f784:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    /*
     * Set conversion mode, EMUX conversion mode, sample time control,  
     * EMUX sample time control for class 1. 
     */
    VADCGroupPtr->ICLASS[1] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass1 \
                                                << VADC_G_ICLASS_CMS_Pos) & VADC_G_ICLASS_CMS_Msk) | \
 801f788:	4319      	orrs	r1, r3
                                          (((uint32_t)HandlePtr->kEMUXConversionModeClass1 \
                                                << VADC_G_ICLASS_CME_Pos) & VADC_G_ICLASS_CME_Msk) | \
                                          (((uint32_t)HandlePtr->kSampleTimeControlClass1 \
 801f78a:	687b      	ldr	r3, [r7, #4]
 801f78c:	7edb      	ldrb	r3, [r3, #27]
                                                << VADC_G_ICLASS_STCS_Pos) & VADC_G_ICLASS_STCS_Msk)  | \
 801f78e:	f003 031f 	and.w	r3, r3, #31
     * EMUX sample time control for class 1. 
     */
    VADCGroupPtr->ICLASS[1] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass1 \
                                                << VADC_G_ICLASS_CMS_Pos) & VADC_G_ICLASS_CMS_Msk) | \
                                          (((uint32_t)HandlePtr->kEMUXConversionModeClass1 \
                                                << VADC_G_ICLASS_CME_Pos) & VADC_G_ICLASS_CME_Msk) | \
 801f792:	4319      	orrs	r1, r3
                                          (((uint32_t)HandlePtr->kSampleTimeControlClass1 \
                                                << VADC_G_ICLASS_STCS_Pos) & VADC_G_ICLASS_STCS_Msk)  | \
                                          (((uint32_t)HandlePtr->kEMUXSampleTimeControlClass1 \
 801f794:	687b      	ldr	r3, [r7, #4]
 801f796:	7fdb      	ldrb	r3, [r3, #31]
                                                    << VADC_G_ICLASS_STCE_Pos) & VADC_G_ICLASS_STCE_Msk));
 801f798:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801f79c:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
                                                
    /*
     * Set conversion mode, EMUX conversion mode, sample time control,  
     * EMUX sample time control for class 1. 
     */
    VADCGroupPtr->ICLASS[1] |= (uint32_t)((((uint32_t)HandlePtr->kConversionModeClass1 \
 801f7a0:	430b      	orrs	r3, r1
 801f7a2:	431a      	orrs	r2, r3
 801f7a4:	68bb      	ldr	r3, [r7, #8]
 801f7a6:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                                          (((uint32_t)HandlePtr->kSampleTimeControlClass1 \
                                                << VADC_G_ICLASS_STCS_Pos) & VADC_G_ICLASS_STCS_Msk)  | \
                                          (((uint32_t)HandlePtr->kEMUXSampleTimeControlClass1 \
                                                    << VADC_G_ICLASS_STCE_Pos) & VADC_G_ICLASS_STCE_Msk));
     /* Enable/Disable Startup Calibration */     
    if(ADCGLOB001_StartUpCalibrationInit() == (uint32_t)DAVEApp_SUCCESS)
 801f7aa:	f000 fdd9 	bl	8020360 <ADCGLOB001_StartUpCalibrationInit>
 801f7ae:	4603      	mov	r3, r0
 801f7b0:	2b00      	cmp	r3, #0
 801f7b2:	d104      	bne.n	801f7be <ADCGROUP001_lInit+0x192>
    {
      /* Set the App State to Initialized */
      HandlePtr->DynamicHandlePtr->State = ADCGROUP001_INITIALIZED;
 801f7b4:	687b      	ldr	r3, [r7, #4]
 801f7b6:	68db      	ldr	r3, [r3, #12]
 801f7b8:	f04f 0201 	mov.w	r2, #1
 801f7bc:	701a      	strb	r2, [r3, #0]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
}
 801f7be:	f107 0710 	add.w	r7, r7, #16
 801f7c2:	46bd      	mov	sp, r7
 801f7c4:	bd80      	pop	{r7, pc}
 801f7c6:	bf00      	nop

0801f7c8 <ADCGROUP001_Deinit>:

/* This Function resets the adcgroup001 app */
status_t ADCGROUP001_Deinit(const ADCGROUP001_HandleType *HandlePtr )
{
 801f7c8:	b480      	push	{r7}
 801f7ca:	b087      	sub	sp, #28
 801f7cc:	af00      	add	r7, sp, #0
 801f7ce:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801f7d0:	f04f 0301 	mov.w	r3, #1
 801f7d4:	617b      	str	r3, [r7, #20]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;            
  /* Pointer to the VADC Kernel Structure */
  VADC_GLOBAL_TypeDef *VADCGlobalPtr;     
  
  VADCGlobalPtr = HandlePtr->VADCGlobalPtr;
 801f7d6:	687b      	ldr	r3, [r7, #4]
 801f7d8:	691b      	ldr	r3, [r3, #16]
 801f7da:	613b      	str	r3, [r7, #16]
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801f7dc:	687b      	ldr	r3, [r7, #4]
 801f7de:	695b      	ldr	r3, [r3, #20]
 801f7e0:	60fb      	str	r3, [r7, #12]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801f7e2:	687b      	ldr	r3, [r7, #4]
 801f7e4:	68db      	ldr	r3, [r3, #12]
 801f7e6:	781b      	ldrb	r3, [r3, #0]
 801f7e8:	2b01      	cmp	r3, #1
 801f7ea:	d128      	bne.n	801f83e <ADCGROUP001_Deinit+0x76>
  {
    /* Reset the Post calibration enable\disable */
    CLR_BIT(VADCGlobalPtr->GLOBCFG, VADC_GLOBCFG_DPCAL0_Pos);
 801f7ec:	693b      	ldr	r3, [r7, #16]
 801f7ee:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 801f7f2:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 801f7f6:	693b      	ldr	r3, [r7, #16]
 801f7f8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  
    /* Reset the Arbitration mode */
    VADCGroupPtr->ARBCFG = (uint32_t)0x00;
 801f7fc:	68fb      	ldr	r3, [r7, #12]
 801f7fe:	f04f 0200 	mov.w	r2, #0
 801f802:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  
    /* Reset the Group specific boundary */
    VADCGroupPtr->BOUND = (uint32_t)0x00;
 801f806:	68fb      	ldr	r3, [r7, #12]
 801f808:	f04f 0200 	mov.w	r2, #0
 801f80c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  
    /* ReSet the EMUX control register */
    VADCGroupPtr->EMUXCTR = (uint32_t)(0X80000000);
 801f810:	68fb      	ldr	r3, [r7, #12]
 801f812:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801f816:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
  
    /* Reset class 0 input register*/
    VADCGroupPtr->ICLASS[0] = (uint32_t)0x00;
 801f81a:	68fb      	ldr	r3, [r7, #12]
 801f81c:	f04f 0200 	mov.w	r2, #0
 801f820:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    /* Reset class 1 input register*/
    VADCGroupPtr->ICLASS[1] = (uint32_t)0x00;
 801f824:	68fb      	ldr	r3, [r7, #12]
 801f826:	f04f 0200 	mov.w	r2, #0
 801f82a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  
    /* Set the App State to Initialized */
    HandlePtr->DynamicHandlePtr->State = ADCGROUP001_UNINITIALIZED;
 801f82e:	687b      	ldr	r3, [r7, #4]
 801f830:	68db      	ldr	r3, [r3, #12]
 801f832:	f04f 0200 	mov.w	r2, #0
 801f836:	701a      	strb	r2, [r3, #0]
  
    Status = (uint32_t)DAVEApp_SUCCESS;
 801f838:	f04f 0300 	mov.w	r3, #0
 801f83c:	617b      	str	r3, [r7, #20]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801f83e:	697b      	ldr	r3, [r7, #20]
}
 801f840:	4618      	mov	r0, r3
 801f842:	f107 071c 	add.w	r7, r7, #28
 801f846:	46bd      	mov	sp, r7
 801f848:	bc80      	pop	{r7}
 801f84a:	4770      	bx	lr

0801f84c <ADCGROUP001_SetGroupBound0>:


/* This Function sets the group specific boundary 0 */
status_t ADCGROUP001_SetGroupBound0(const ADCGROUP001_HandleType *HandlePtr,
                                                         uint16_t BoundaryValue)
{
 801f84c:	b480      	push	{r7}
 801f84e:	b085      	sub	sp, #20
 801f850:	af00      	add	r7, sp, #0
 801f852:	6078      	str	r0, [r7, #4]
 801f854:	460b      	mov	r3, r1
 801f856:	807b      	strh	r3, [r7, #2]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801f858:	f04f 0301 	mov.w	r3, #1
 801f85c:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801f85e:	687b      	ldr	r3, [r7, #4]
 801f860:	695b      	ldr	r3, [r3, #20]
 801f862:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if(HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED)
 801f864:	687b      	ldr	r3, [r7, #4]
 801f866:	68db      	ldr	r3, [r3, #12]
 801f868:	781b      	ldrb	r3, [r3, #0]
 801f86a:	2b01      	cmp	r3, #1
 801f86c:	d11a      	bne.n	801f8a4 <ADCGROUP001_SetGroupBound0+0x58>
  {
    if(BoundaryValue <= (uint16_t)ADCGROUP001_MAX_BOUNDARY_VALUE)
 801f86e:	887b      	ldrh	r3, [r7, #2]
 801f870:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 801f874:	d813      	bhi.n	801f89e <ADCGROUP001_SetGroupBound0+0x52>
    {
      /* Set the Group specific boundary 0 */
      WR_REG(VADCGroupPtr->BOUND, VADC_G_BOUND_BOUNDARY0_Msk, 
 801f876:	887b      	ldrh	r3, [r7, #2]
 801f878:	ea4f 5203 	mov.w	r2, r3, lsl #20
 801f87c:	ea4f 5212 	mov.w	r2, r2, lsr #20
 801f880:	68bb      	ldr	r3, [r7, #8]
 801f882:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 801f886:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 801f88a:	f023 030f 	bic.w	r3, r3, #15
 801f88e:	431a      	orrs	r2, r3
 801f890:	68bb      	ldr	r3, [r7, #8]
 801f892:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
                           VADC_G_BOUND_BOUNDARY0_Pos, (uint32_t)BoundaryValue);  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801f896:	f04f 0300 	mov.w	r3, #0
 801f89a:	60fb      	str	r3, [r7, #12]
 801f89c:	e002      	b.n	801f8a4 <ADCGROUP001_SetGroupBound0+0x58>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801f89e:	f04f 0302 	mov.w	r3, #2
 801f8a2:	60fb      	str	r3, [r7, #12]
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }  

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);

  return Status;
 801f8a4:	68fb      	ldr	r3, [r7, #12]
}
 801f8a6:	4618      	mov	r0, r3
 801f8a8:	f107 0714 	add.w	r7, r7, #20
 801f8ac:	46bd      	mov	sp, r7
 801f8ae:	bc80      	pop	{r7}
 801f8b0:	4770      	bx	lr
 801f8b2:	bf00      	nop

0801f8b4 <ADCGROUP001_SetGroupBound1>:


/* This Function sets the group specific boundary 1 */
status_t ADCGROUP001_SetGroupBound1(const ADCGROUP001_HandleType *HandlePtr,
                                                         uint16_t BoundaryValue)
{
 801f8b4:	b480      	push	{r7}
 801f8b6:	b085      	sub	sp, #20
 801f8b8:	af00      	add	r7, sp, #0
 801f8ba:	6078      	str	r0, [r7, #4]
 801f8bc:	460b      	mov	r3, r1
 801f8be:	807b      	strh	r3, [r7, #2]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801f8c0:	f04f 0301 	mov.w	r3, #1
 801f8c4:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801f8c6:	687b      	ldr	r3, [r7, #4]
 801f8c8:	695b      	ldr	r3, [r3, #20]
 801f8ca:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);
  
  if(HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED)
 801f8cc:	687b      	ldr	r3, [r7, #4]
 801f8ce:	68db      	ldr	r3, [r3, #12]
 801f8d0:	781b      	ldrb	r3, [r3, #0]
 801f8d2:	2b01      	cmp	r3, #1
 801f8d4:	d11d      	bne.n	801f912 <ADCGROUP001_SetGroupBound1+0x5e>
  {
    if(BoundaryValue <= (uint16_t)ADCGROUP001_MAX_BOUNDARY_VALUE)
 801f8d6:	887b      	ldrh	r3, [r7, #2]
 801f8d8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 801f8dc:	d816      	bhi.n	801f90c <ADCGROUP001_SetGroupBound1+0x58>
    {
      /* Set the Group specific boundary 0 */
      WR_REG(VADCGroupPtr->BOUND, VADC_G_BOUND_BOUNDARY1_Msk, 
 801f8de:	887b      	ldrh	r3, [r7, #2]
 801f8e0:	ea4f 4203 	mov.w	r2, r3, lsl #16
 801f8e4:	f04f 0300 	mov.w	r3, #0
 801f8e8:	f6c0 73ff 	movt	r3, #4095	; 0xfff
 801f8ec:	4013      	ands	r3, r2
 801f8ee:	68ba      	ldr	r2, [r7, #8]
 801f8f0:	f8d2 20b8 	ldr.w	r2, [r2, #184]	; 0xb8
 801f8f4:	f022 627f 	bic.w	r2, r2, #267386880	; 0xff00000
 801f8f8:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 801f8fc:	431a      	orrs	r2, r3
 801f8fe:	68bb      	ldr	r3, [r7, #8]
 801f900:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
                           VADC_G_BOUND_BOUNDARY1_Pos, (uint32_t)BoundaryValue);  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801f904:	f04f 0300 	mov.w	r3, #0
 801f908:	60fb      	str	r3, [r7, #12]
 801f90a:	e002      	b.n	801f912 <ADCGROUP001_SetGroupBound1+0x5e>
    }
    else
    {
      ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801f90c:	f04f 0302 	mov.w	r3, #2
 801f910:	60fb      	str	r3, [r7, #12]
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }  
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  
  return Status;
 801f912:	68fb      	ldr	r3, [r7, #12]
}
 801f914:	4618      	mov	r0, r3
 801f916:	f107 0714 	add.w	r7, r7, #20
 801f91a:	46bd      	mov	sp, r7
 801f91c:	bc80      	pop	{r7}
 801f91e:	4770      	bx	lr

0801f920 <ADCGROUP001_ActiveGroupServiceRequestNode>:


/* This function activates group specific service request node */
status_t ADCGROUP001_ActiveGroupServiceRequestNode(
                          const ADCGROUP001_HandleType *HandlePtr, uint8_t Node)
{
 801f920:	b480      	push	{r7}
 801f922:	b085      	sub	sp, #20
 801f924:	af00      	add	r7, sp, #0
 801f926:	6078      	str	r0, [r7, #4]
 801f928:	460b      	mov	r3, r1
 801f92a:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801f92c:	f04f 0301 	mov.w	r3, #1
 801f930:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801f932:	687b      	ldr	r3, [r7, #4]
 801f934:	695b      	ldr	r3, [r3, #20]
 801f936:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801f938:	687b      	ldr	r3, [r7, #4]
 801f93a:	68db      	ldr	r3, [r3, #12]
 801f93c:	781b      	ldrb	r3, [r3, #0]
 801f93e:	2b01      	cmp	r3, #1
 801f940:	d123      	bne.n	801f98a <ADCGROUP001_ActiveGroupServiceRequestNode+0x6a>
  {
    if( Node <= (uint8_t)(ADCGROUP001_MAX_SERVICE_REQUEST_NODE - 1))
 801f942:	78fb      	ldrb	r3, [r7, #3]
 801f944:	2b03      	cmp	r3, #3
 801f946:	d81d      	bhi.n	801f984 <ADCGROUP001_ActiveGroupServiceRequestNode+0x64>
    {
      /* Activate the Group specific service request node */
      CLR_BIT(VADCGroupPtr->SRACT, ((uint32_t)VADC_G_SRACT_AGSR0_Pos + (uint32_t)Node));
 801f948:	68bb      	ldr	r3, [r7, #8]
 801f94a:	f8d3 21c8 	ldr.w	r2, [r3, #456]	; 0x1c8
 801f94e:	78fb      	ldrb	r3, [r7, #3]
 801f950:	f04f 0101 	mov.w	r1, #1
 801f954:	fa01 f303 	lsl.w	r3, r1, r3
 801f958:	ea6f 0303 	mvn.w	r3, r3
 801f95c:	401a      	ands	r2, r3
 801f95e:	68bb      	ldr	r3, [r7, #8]
 801f960:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
      SET_BIT(VADCGroupPtr->SRACT, ((uint32_t)VADC_G_SRACT_AGSR0_Pos + (uint32_t)Node));
 801f964:	68bb      	ldr	r3, [r7, #8]
 801f966:	f8d3 21c8 	ldr.w	r2, [r3, #456]	; 0x1c8
 801f96a:	78fb      	ldrb	r3, [r7, #3]
 801f96c:	f04f 0101 	mov.w	r1, #1
 801f970:	fa01 f303 	lsl.w	r3, r1, r3
 801f974:	431a      	orrs	r2, r3
 801f976:	68bb      	ldr	r3, [r7, #8]
 801f978:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
      Status = (uint32_t)DAVEApp_SUCCESS;
 801f97c:	f04f 0300 	mov.w	r3, #0
 801f980:	60fb      	str	r3, [r7, #12]
 801f982:	e002      	b.n	801f98a <ADCGROUP001_ActiveGroupServiceRequestNode+0x6a>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801f984:	f04f 0302 	mov.w	r3, #2
 801f988:	60fb      	str	r3, [r7, #12]
  {
   ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801f98a:	68fb      	ldr	r3, [r7, #12]
}
 801f98c:	4618      	mov	r0, r3
 801f98e:	f107 0714 	add.w	r7, r7, #20
 801f992:	46bd      	mov	sp, r7
 801f994:	bc80      	pop	{r7}
 801f996:	4770      	bx	lr

0801f998 <ADCGROUP001_DeActiveGroupServiceRequestNode>:

/* This function deactivates group specific service request node */
status_t ADCGROUP001_DeActiveGroupServiceRequestNode(
                          const ADCGROUP001_HandleType *HandlePtr, uint8_t Node)
{
 801f998:	b480      	push	{r7}
 801f99a:	b085      	sub	sp, #20
 801f99c:	af00      	add	r7, sp, #0
 801f99e:	6078      	str	r0, [r7, #4]
 801f9a0:	460b      	mov	r3, r1
 801f9a2:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801f9a4:	f04f 0301 	mov.w	r3, #1
 801f9a8:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801f9aa:	687b      	ldr	r3, [r7, #4]
 801f9ac:	695b      	ldr	r3, [r3, #20]
 801f9ae:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801f9b0:	687b      	ldr	r3, [r7, #4]
 801f9b2:	68db      	ldr	r3, [r3, #12]
 801f9b4:	781b      	ldrb	r3, [r3, #0]
 801f9b6:	2b01      	cmp	r3, #1
 801f9b8:	d117      	bne.n	801f9ea <ADCGROUP001_DeActiveGroupServiceRequestNode+0x52>
  {
    if( Node <= (uint8_t)(ADCGROUP001_MAX_SERVICE_REQUEST_NODE - 1))
 801f9ba:	78fb      	ldrb	r3, [r7, #3]
 801f9bc:	2b03      	cmp	r3, #3
 801f9be:	d811      	bhi.n	801f9e4 <ADCGROUP001_DeActiveGroupServiceRequestNode+0x4c>
    {
      /* Deactivate the Group specific service request node */
      CLR_BIT(VADCGroupPtr->SRACT, ((uint32_t)VADC_G_SRACT_AGSR0_Pos + (uint32_t)Node));
 801f9c0:	68bb      	ldr	r3, [r7, #8]
 801f9c2:	f8d3 21c8 	ldr.w	r2, [r3, #456]	; 0x1c8
 801f9c6:	78fb      	ldrb	r3, [r7, #3]
 801f9c8:	f04f 0101 	mov.w	r1, #1
 801f9cc:	fa01 f303 	lsl.w	r3, r1, r3
 801f9d0:	ea6f 0303 	mvn.w	r3, r3
 801f9d4:	401a      	ands	r2, r3
 801f9d6:	68bb      	ldr	r3, [r7, #8]
 801f9d8:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
      Status = (uint32_t)DAVEApp_SUCCESS;    
 801f9dc:	f04f 0300 	mov.w	r3, #0
 801f9e0:	60fb      	str	r3, [r7, #12]
 801f9e2:	e002      	b.n	801f9ea <ADCGROUP001_DeActiveGroupServiceRequestNode+0x52>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801f9e4:	f04f 0302 	mov.w	r3, #2
 801f9e8:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL); 
  }

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801f9ea:	68fb      	ldr	r3, [r7, #12]
}
 801f9ec:	4618      	mov	r0, r3
 801f9ee:	f107 0714 	add.w	r7, r7, #20
 801f9f2:	46bd      	mov	sp, r7
 801f9f4:	bc80      	pop	{r7}
 801f9f6:	4770      	bx	lr

0801f9f8 <ADCGROUP001_ActiveSharedServiceRequestNode>:

/* This function activates the shared service request node. */
status_t ADCGROUP001_ActiveSharedServiceRequestNode(
                          const ADCGROUP001_HandleType *HandlePtr, uint8_t Node)
{
 801f9f8:	b480      	push	{r7}
 801f9fa:	b085      	sub	sp, #20
 801f9fc:	af00      	add	r7, sp, #0
 801f9fe:	6078      	str	r0, [r7, #4]
 801fa00:	460b      	mov	r3, r1
 801fa02:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fa04:	f04f 0301 	mov.w	r3, #1
 801fa08:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fa0a:	687b      	ldr	r3, [r7, #4]
 801fa0c:	695b      	ldr	r3, [r3, #20]
 801fa0e:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fa10:	687b      	ldr	r3, [r7, #4]
 801fa12:	68db      	ldr	r3, [r3, #12]
 801fa14:	781b      	ldrb	r3, [r3, #0]
 801fa16:	2b01      	cmp	r3, #1
 801fa18:	d127      	bne.n	801fa6a <ADCGROUP001_ActiveSharedServiceRequestNode+0x72>
  {
    if( Node <= (uint8_t)(ADCGROUP001_MAX_SERVICE_REQUEST_NODE - 1))
 801fa1a:	78fb      	ldrb	r3, [r7, #3]
 801fa1c:	2b03      	cmp	r3, #3
 801fa1e:	d821      	bhi.n	801fa64 <ADCGROUP001_ActiveSharedServiceRequestNode+0x6c>
    {
      /* Activates the shared service request node. */
      CLR_BIT(VADCGroupPtr->SRACT, ((uint32_t)VADC_G_SRACT_ASSR0_Pos + (uint32_t)Node));
 801fa20:	68bb      	ldr	r3, [r7, #8]
 801fa22:	f8d3 21c8 	ldr.w	r2, [r3, #456]	; 0x1c8
 801fa26:	78fb      	ldrb	r3, [r7, #3]
 801fa28:	f103 0308 	add.w	r3, r3, #8
 801fa2c:	f04f 0101 	mov.w	r1, #1
 801fa30:	fa01 f303 	lsl.w	r3, r1, r3
 801fa34:	ea6f 0303 	mvn.w	r3, r3
 801fa38:	401a      	ands	r2, r3
 801fa3a:	68bb      	ldr	r3, [r7, #8]
 801fa3c:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
      SET_BIT(VADCGroupPtr->SRACT, ((uint32_t)VADC_G_SRACT_ASSR0_Pos + (uint32_t)Node));    
 801fa40:	68bb      	ldr	r3, [r7, #8]
 801fa42:	f8d3 21c8 	ldr.w	r2, [r3, #456]	; 0x1c8
 801fa46:	78fb      	ldrb	r3, [r7, #3]
 801fa48:	f103 0308 	add.w	r3, r3, #8
 801fa4c:	f04f 0101 	mov.w	r1, #1
 801fa50:	fa01 f303 	lsl.w	r3, r1, r3
 801fa54:	431a      	orrs	r2, r3
 801fa56:	68bb      	ldr	r3, [r7, #8]
 801fa58:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fa5c:	f04f 0300 	mov.w	r3, #0
 801fa60:	60fb      	str	r3, [r7, #12]
 801fa62:	e002      	b.n	801fa6a <ADCGROUP001_ActiveSharedServiceRequestNode+0x72>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fa64:	f04f 0302 	mov.w	r3, #2
 801fa68:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);    
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fa6a:	68fb      	ldr	r3, [r7, #12]
}
 801fa6c:	4618      	mov	r0, r3
 801fa6e:	f107 0714 	add.w	r7, r7, #20
 801fa72:	46bd      	mov	sp, r7
 801fa74:	bc80      	pop	{r7}
 801fa76:	4770      	bx	lr

0801fa78 <ADCGROUP001_DeActiveSharedServiceRequestNode>:

/* This deactivates the shared service request node.*/
status_t ADCGROUP001_DeActiveSharedServiceRequestNode(
                          const ADCGROUP001_HandleType *HandlePtr, uint8_t Node)
{
 801fa78:	b480      	push	{r7}
 801fa7a:	b085      	sub	sp, #20
 801fa7c:	af00      	add	r7, sp, #0
 801fa7e:	6078      	str	r0, [r7, #4]
 801fa80:	460b      	mov	r3, r1
 801fa82:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fa84:	f04f 0301 	mov.w	r3, #1
 801fa88:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fa8a:	687b      	ldr	r3, [r7, #4]
 801fa8c:	695b      	ldr	r3, [r3, #20]
 801fa8e:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fa90:	687b      	ldr	r3, [r7, #4]
 801fa92:	68db      	ldr	r3, [r3, #12]
 801fa94:	781b      	ldrb	r3, [r3, #0]
 801fa96:	2b01      	cmp	r3, #1
 801fa98:	d119      	bne.n	801face <ADCGROUP001_DeActiveSharedServiceRequestNode+0x56>
  {
    if( Node <= (uint8_t)(ADCGROUP001_MAX_SERVICE_REQUEST_NODE - 1))
 801fa9a:	78fb      	ldrb	r3, [r7, #3]
 801fa9c:	2b03      	cmp	r3, #3
 801fa9e:	d813      	bhi.n	801fac8 <ADCGROUP001_DeActiveSharedServiceRequestNode+0x50>
    {
      /* Deactivate the shared service request node.*/
      CLR_BIT(VADCGroupPtr->SRACT, ((uint32_t)VADC_G_SRACT_ASSR0_Pos + (uint32_t)Node));                          
 801faa0:	68bb      	ldr	r3, [r7, #8]
 801faa2:	f8d3 21c8 	ldr.w	r2, [r3, #456]	; 0x1c8
 801faa6:	78fb      	ldrb	r3, [r7, #3]
 801faa8:	f103 0308 	add.w	r3, r3, #8
 801faac:	f04f 0101 	mov.w	r1, #1
 801fab0:	fa01 f303 	lsl.w	r3, r1, r3
 801fab4:	ea6f 0303 	mvn.w	r3, r3
 801fab8:	401a      	ands	r2, r3
 801faba:	68bb      	ldr	r3, [r7, #8]
 801fabc:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fac0:	f04f 0300 	mov.w	r3, #0
 801fac4:	60fb      	str	r3, [r7, #12]
 801fac6:	e002      	b.n	801face <ADCGROUP001_DeActiveSharedServiceRequestNode+0x56>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fac8:	f04f 0302 	mov.w	r3, #2
 801facc:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);    
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801face:	68fb      	ldr	r3, [r7, #12]
}
 801fad0:	4618      	mov	r0, r3
 801fad2:	f107 0714 	add.w	r7, r7, #20
 801fad6:	46bd      	mov	sp, r7
 801fad8:	bc80      	pop	{r7}
 801fada:	4770      	bx	lr

0801fadc <ADCGROUP001_EMUXStartSelection>:


/* This Function sets the value of EMUX start selection. */
status_t ADCGROUP001_EMUXStartSelection(
          const ADCGROUP001_HandleType *HandlePtr, uint8_t StartSelectionValue)
{
 801fadc:	b480      	push	{r7}
 801fade:	b085      	sub	sp, #20
 801fae0:	af00      	add	r7, sp, #0
 801fae2:	6078      	str	r0, [r7, #4]
 801fae4:	460b      	mov	r3, r1
 801fae6:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fae8:	f04f 0301 	mov.w	r3, #1
 801faec:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801faee:	687b      	ldr	r3, [r7, #4]
 801faf0:	695b      	ldr	r3, [r3, #20]
 801faf2:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801faf4:	687b      	ldr	r3, [r7, #4]
 801faf6:	68db      	ldr	r3, [r3, #12]
 801faf8:	781b      	ldrb	r3, [r3, #0]
 801fafa:	2b01      	cmp	r3, #1
 801fafc:	d115      	bne.n	801fb2a <ADCGROUP001_EMUXStartSelection+0x4e>
  {
    if( StartSelectionValue <= (uint8_t)ADCGROUP001_MAX_ADC_GROUP_CHANNEL)
 801fafe:	78fb      	ldrb	r3, [r7, #3]
 801fb00:	2b08      	cmp	r3, #8
 801fb02:	d80f      	bhi.n	801fb24 <ADCGROUP001_EMUXStartSelection+0x48>
    {
      /* Set the EMUX start selection */
      WR_REG(VADCGroupPtr->EMUXCTR, VADC_G_EMUXCTR_EMUXSET_Msk,
 801fb04:	78fb      	ldrb	r3, [r7, #3]
 801fb06:	f003 0207 	and.w	r2, r3, #7
 801fb0a:	68bb      	ldr	r3, [r7, #8]
 801fb0c:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 801fb10:	f023 0307 	bic.w	r3, r3, #7
 801fb14:	431a      	orrs	r2, r3
 801fb16:	68bb      	ldr	r3, [r7, #8]
 801fb18:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
                     VADC_G_EMUXCTR_EMUXSET_Pos, (uint32_t)StartSelectionValue);
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fb1c:	f04f 0300 	mov.w	r3, #0
 801fb20:	60fb      	str	r3, [r7, #12]
 801fb22:	e002      	b.n	801fb2a <ADCGROUP001_EMUXStartSelection+0x4e>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fb24:	f04f 0302 	mov.w	r3, #2
 801fb28:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fb2a:	68fb      	ldr	r3, [r7, #12]
}
 801fb2c:	4618      	mov	r0, r3
 801fb2e:	f107 0714 	add.w	r7, r7, #20
 801fb32:	46bd      	mov	sp, r7
 801fb34:	bc80      	pop	{r7}
 801fb36:	4770      	bx	lr

0801fb38 <ADCGROUP001_GetEMUXStartSelection>:

/* This function gets the value of EMUX start selection. */
status_t ADCGROUP001_GetEMUXStartSelection(
       const ADCGROUP001_HandleType *HandlePtr, uint8_t *StartSelectionValuePtr)
{
 801fb38:	b480      	push	{r7}
 801fb3a:	b085      	sub	sp, #20
 801fb3c:	af00      	add	r7, sp, #0
 801fb3e:	6078      	str	r0, [r7, #4]
 801fb40:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fb42:	f04f 0301 	mov.w	r3, #1
 801fb46:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fb48:	687b      	ldr	r3, [r7, #4]
 801fb4a:	695b      	ldr	r3, [r3, #20]
 801fb4c:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fb4e:	687b      	ldr	r3, [r7, #4]
 801fb50:	68db      	ldr	r3, [r3, #12]
 801fb52:	781b      	ldrb	r3, [r3, #0]
 801fb54:	2b01      	cmp	r3, #1
 801fb56:	d112      	bne.n	801fb7e <ADCGROUP001_GetEMUXStartSelection+0x46>
  {
    if(StartSelectionValuePtr != NULL)
 801fb58:	683b      	ldr	r3, [r7, #0]
 801fb5a:	2b00      	cmp	r3, #0
 801fb5c:	d00c      	beq.n	801fb78 <ADCGROUP001_GetEMUXStartSelection+0x40>
    {
      /* Get the EMUX start selection*/
      *StartSelectionValuePtr = (uint8_t)RD_REG( VADCGroupPtr->EMUXCTR, 
 801fb5e:	68bb      	ldr	r3, [r7, #8]
 801fb60:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 801fb64:	b2db      	uxtb	r3, r3
 801fb66:	f003 0307 	and.w	r3, r3, #7
 801fb6a:	b2da      	uxtb	r2, r3
 801fb6c:	683b      	ldr	r3, [r7, #0]
 801fb6e:	701a      	strb	r2, [r3, #0]
                        VADC_G_EMUXCTR_EMUXSET_Msk, VADC_G_EMUXCTR_EMUXSET_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fb70:	f04f 0300 	mov.w	r3, #0
 801fb74:	60fb      	str	r3, [r7, #12]
 801fb76:	e002      	b.n	801fb7e <ADCGROUP001_GetEMUXStartSelection+0x46>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fb78:	f04f 0302 	mov.w	r3, #2
 801fb7c:	60fb      	str	r3, [r7, #12]
  else  
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fb7e:	68fb      	ldr	r3, [r7, #12]
}
 801fb80:	4618      	mov	r0, r3
 801fb82:	f107 0714 	add.w	r7, r7, #20
 801fb86:	46bd      	mov	sp, r7
 801fb88:	bc80      	pop	{r7}
 801fb8a:	4770      	bx	lr

0801fb8c <ADCGROUP001_SetEMUXChannelSelect>:

/* This function sets the value of EMUX channel select. */
status_t ADCGROUP001_SetEMUXChannelSelect(
          const ADCGROUP001_HandleType *HandlePtr, uint8_t ChannelSelectValue)
{
 801fb8c:	b480      	push	{r7}
 801fb8e:	b085      	sub	sp, #20
 801fb90:	af00      	add	r7, sp, #0
 801fb92:	6078      	str	r0, [r7, #4]
 801fb94:	460b      	mov	r3, r1
 801fb96:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fb98:	f04f 0301 	mov.w	r3, #1
 801fb9c:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;                
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fb9e:	687b      	ldr	r3, [r7, #4]
 801fba0:	695b      	ldr	r3, [r3, #20]
 801fba2:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fba4:	687b      	ldr	r3, [r7, #4]
 801fba6:	68db      	ldr	r3, [r3, #12]
 801fba8:	781b      	ldrb	r3, [r3, #0]
 801fbaa:	2b01      	cmp	r3, #1
 801fbac:	d117      	bne.n	801fbde <ADCGROUP001_SetEMUXChannelSelect+0x52>
  {
    if( ChannelSelectValue <= (uint8_t)ADCGROUP001_TOTAL_ADC_CHANNEL )
 801fbae:	78fb      	ldrb	r3, [r7, #3]
 801fbb0:	2b20      	cmp	r3, #32
 801fbb2:	d811      	bhi.n	801fbd8 <ADCGROUP001_SetEMUXChannelSelect+0x4c>
    {
      /* Set the EMUX channel select*/
      WR_REG(VADCGroupPtr->EMUXCTR, VADC_G_EMUXCTR_EMUXCH_Msk,
 801fbb4:	78fb      	ldrb	r3, [r7, #3]
 801fbb6:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801fbba:	f403 12f8 	and.w	r2, r3, #2031616	; 0x1f0000
 801fbbe:	68bb      	ldr	r3, [r7, #8]
 801fbc0:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 801fbc4:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 801fbc8:	431a      	orrs	r2, r3
 801fbca:	68bb      	ldr	r3, [r7, #8]
 801fbcc:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
                       VADC_G_EMUXCTR_EMUXCH_Pos, (uint32_t)ChannelSelectValue);
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fbd0:	f04f 0300 	mov.w	r3, #0
 801fbd4:	60fb      	str	r3, [r7, #12]
 801fbd6:	e002      	b.n	801fbde <ADCGROUP001_SetEMUXChannelSelect+0x52>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fbd8:	f04f 0302 	mov.w	r3, #2
 801fbdc:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fbde:	68fb      	ldr	r3, [r7, #12]
}
 801fbe0:	4618      	mov	r0, r3
 801fbe2:	f107 0714 	add.w	r7, r7, #20
 801fbe6:	46bd      	mov	sp, r7
 801fbe8:	bc80      	pop	{r7}
 801fbea:	4770      	bx	lr

0801fbec <ADCGROUP001_SetEMUXMode>:

/* This function sets the value of EMUX mode. */
status_t ADCGROUP001_SetEMUXMode(const ADCGROUP001_HandleType *HandlePtr, 
                                                                  uint8_t Mode)
{
 801fbec:	b480      	push	{r7}
 801fbee:	b087      	sub	sp, #28
 801fbf0:	af00      	add	r7, sp, #0
 801fbf2:	6078      	str	r0, [r7, #4]
 801fbf4:	460b      	mov	r3, r1
 801fbf6:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fbf8:	f04f 0301 	mov.w	r3, #1
 801fbfc:	617b      	str	r3, [r7, #20]
  uint32_t ModeTemp;
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fbfe:	687b      	ldr	r3, [r7, #4]
 801fc00:	695b      	ldr	r3, [r3, #20]
 801fc02:	613b      	str	r3, [r7, #16]

  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fc04:	687b      	ldr	r3, [r7, #4]
 801fc06:	68db      	ldr	r3, [r3, #12]
 801fc08:	781b      	ldrb	r3, [r3, #0]
 801fc0a:	2b01      	cmp	r3, #1
 801fc0c:	d11f      	bne.n	801fc4e <ADCGROUP001_SetEMUXMode+0x62>
  {
    if(Mode <= (uint8_t)ADCGROUP001_SEQUENCEMODE)
 801fc0e:	78fb      	ldrb	r3, [r7, #3]
 801fc10:	2b03      	cmp	r3, #3
 801fc12:	d819      	bhi.n	801fc48 <ADCGROUP001_SetEMUXMode+0x5c>
    {
      /* Set the EMUX mode*/
      ModeTemp = VADCGroupPtr->EMUXCTR;
 801fc14:	693b      	ldr	r3, [r7, #16]
 801fc16:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 801fc1a:	60fb      	str	r3, [r7, #12]
      ModeTemp &= (uint32_t)~(VADC_G_EMUXCTR_EMUXMODE_Msk);
 801fc1c:	68fb      	ldr	r3, [r7, #12]
 801fc1e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 801fc22:	60fb      	str	r3, [r7, #12]
      ModeTemp |= (VADC_G_EMUXCTR_EMXWC_Msk) |
                      (((uint32_t)Mode << VADC_G_EMUXCTR_EMUXMODE_Pos) & VADC_G_EMUXCTR_EMUXMODE_Msk);
 801fc24:	78fb      	ldrb	r3, [r7, #3]
 801fc26:	ea4f 6383 	mov.w	r3, r3, lsl #26
 801fc2a:	f003 6240 	and.w	r2, r3, #201326592	; 0xc000000
    if(Mode <= (uint8_t)ADCGROUP001_SEQUENCEMODE)
    {
      /* Set the EMUX mode*/
      ModeTemp = VADCGroupPtr->EMUXCTR;
      ModeTemp &= (uint32_t)~(VADC_G_EMUXCTR_EMUXMODE_Msk);
      ModeTemp |= (VADC_G_EMUXCTR_EMXWC_Msk) |
 801fc2e:	68fb      	ldr	r3, [r7, #12]
 801fc30:	4313      	orrs	r3, r2
 801fc32:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 801fc36:	60fb      	str	r3, [r7, #12]
                      (((uint32_t)Mode << VADC_G_EMUXCTR_EMUXMODE_Pos) & VADC_G_EMUXCTR_EMUXMODE_Msk);
      VADCGroupPtr->EMUXCTR = ModeTemp;
 801fc38:	693b      	ldr	r3, [r7, #16]
 801fc3a:	68fa      	ldr	r2, [r7, #12]
 801fc3c:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fc40:	f04f 0300 	mov.w	r3, #0
 801fc44:	617b      	str	r3, [r7, #20]
 801fc46:	e002      	b.n	801fc4e <ADCGROUP001_SetEMUXMode+0x62>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fc48:	f04f 0302 	mov.w	r3, #2
 801fc4c:	617b      	str	r3, [r7, #20]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fc4e:	697b      	ldr	r3, [r7, #20]
}
 801fc50:	4618      	mov	r0, r3
 801fc52:	f107 071c 	add.w	r7, r7, #28
 801fc56:	46bd      	mov	sp, r7
 801fc58:	bc80      	pop	{r7}
 801fc5a:	4770      	bx	lr

0801fc5c <ADCGROUP001_SetEMUXCodeScheme>:


/* This function sets the value of EMUX coding scheme. */
status_t ADCGROUP001_SetEMUXCodeScheme(const ADCGROUP001_HandleType *HandlePtr, 
                                                            uint8_t CodeScheme)
{
 801fc5c:	b480      	push	{r7}
 801fc5e:	b087      	sub	sp, #28
 801fc60:	af00      	add	r7, sp, #0
 801fc62:	6078      	str	r0, [r7, #4]
 801fc64:	460b      	mov	r3, r1
 801fc66:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fc68:	f04f 0301 	mov.w	r3, #1
 801fc6c:	617b      	str	r3, [r7, #20]
  uint32_t CodeSchemeTemp = (uint32_t)0;
 801fc6e:	f04f 0300 	mov.w	r3, #0
 801fc72:	613b      	str	r3, [r7, #16]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fc74:	687b      	ldr	r3, [r7, #4]
 801fc76:	695b      	ldr	r3, [r3, #20]
 801fc78:	60fb      	str	r3, [r7, #12]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fc7a:	687b      	ldr	r3, [r7, #4]
 801fc7c:	68db      	ldr	r3, [r3, #12]
 801fc7e:	781b      	ldrb	r3, [r3, #0]
 801fc80:	2b01      	cmp	r3, #1
 801fc82:	d11f      	bne.n	801fcc4 <ADCGROUP001_SetEMUXCodeScheme+0x68>
  {
    if(CodeScheme <= (uint8_t)ADCGROUP001_GRAYCODE)
 801fc84:	78fb      	ldrb	r3, [r7, #3]
 801fc86:	2b01      	cmp	r3, #1
 801fc88:	d819      	bhi.n	801fcbe <ADCGROUP001_SetEMUXCodeScheme+0x62>
    {
      /* Set the EMUX code scheme*/
      CodeSchemeTemp = VADCGroupPtr->EMUXCTR;
 801fc8a:	68fb      	ldr	r3, [r7, #12]
 801fc8c:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 801fc90:	613b      	str	r3, [r7, #16]
      CodeSchemeTemp &= (uint32_t)~(VADC_G_EMUXCTR_EMXCOD_Msk);
 801fc92:	693b      	ldr	r3, [r7, #16]
 801fc94:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 801fc98:	613b      	str	r3, [r7, #16]
      CodeSchemeTemp |= (VADC_G_EMUXCTR_EMXWC_Msk) |
                    (((uint32_t)CodeScheme << VADC_G_EMUXCTR_EMXCOD_Pos) & VADC_G_EMUXCTR_EMXCOD_Msk);
 801fc9a:	78fb      	ldrb	r3, [r7, #3]
 801fc9c:	ea4f 7303 	mov.w	r3, r3, lsl #28
 801fca0:	f003 5280 	and.w	r2, r3, #268435456	; 0x10000000
    if(CodeScheme <= (uint8_t)ADCGROUP001_GRAYCODE)
    {
      /* Set the EMUX code scheme*/
      CodeSchemeTemp = VADCGroupPtr->EMUXCTR;
      CodeSchemeTemp &= (uint32_t)~(VADC_G_EMUXCTR_EMXCOD_Msk);
      CodeSchemeTemp |= (VADC_G_EMUXCTR_EMXWC_Msk) |
 801fca4:	693b      	ldr	r3, [r7, #16]
 801fca6:	4313      	orrs	r3, r2
 801fca8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 801fcac:	613b      	str	r3, [r7, #16]
                    (((uint32_t)CodeScheme << VADC_G_EMUXCTR_EMXCOD_Pos) & VADC_G_EMUXCTR_EMXCOD_Msk);
      VADCGroupPtr->EMUXCTR = CodeSchemeTemp;
 801fcae:	68fb      	ldr	r3, [r7, #12]
 801fcb0:	693a      	ldr	r2, [r7, #16]
 801fcb2:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0

      Status = (uint32_t)DAVEApp_SUCCESS;
 801fcb6:	f04f 0300 	mov.w	r3, #0
 801fcba:	617b      	str	r3, [r7, #20]
 801fcbc:	e002      	b.n	801fcc4 <ADCGROUP001_SetEMUXCodeScheme+0x68>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fcbe:	f04f 0302 	mov.w	r3, #2
 801fcc2:	617b      	str	r3, [r7, #20]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fcc4:	697b      	ldr	r3, [r7, #20]
}
 801fcc6:	4618      	mov	r0, r3
 801fcc8:	f107 071c 	add.w	r7, r7, #28
 801fccc:	46bd      	mov	sp, r7
 801fcce:	bc80      	pop	{r7}
 801fcd0:	4770      	bx	lr
 801fcd2:	bf00      	nop

0801fcd4 <ADCGROUP001_SetGroupClass0SampleTime>:

/* This function sets the sample time for standard conversion mode */
status_t ADCGROUP001_SetGroupClass0SampleTime(
                                        const ADCGROUP001_HandleType *HandlePtr, 
                                                             uint8_t SampleTime)
{
 801fcd4:	b480      	push	{r7}
 801fcd6:	b085      	sub	sp, #20
 801fcd8:	af00      	add	r7, sp, #0
 801fcda:	6078      	str	r0, [r7, #4]
 801fcdc:	460b      	mov	r3, r1
 801fcde:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fce0:	f04f 0301 	mov.w	r3, #1
 801fce4:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fce6:	687b      	ldr	r3, [r7, #4]
 801fce8:	695b      	ldr	r3, [r3, #20]
 801fcea:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fcec:	687b      	ldr	r3, [r7, #4]
 801fcee:	68db      	ldr	r3, [r3, #12]
 801fcf0:	781b      	ldrb	r3, [r3, #0]
 801fcf2:	2b01      	cmp	r3, #1
 801fcf4:	d115      	bne.n	801fd22 <ADCGROUP001_SetGroupClass0SampleTime+0x4e>
  {
    if(SampleTime < (uint8_t)ADCGROUP001_MAX_SAMPLE_TIME_CONTROL_VAL)
 801fcf6:	78fb      	ldrb	r3, [r7, #3]
 801fcf8:	2b1f      	cmp	r3, #31
 801fcfa:	d80f      	bhi.n	801fd1c <ADCGROUP001_SetGroupClass0SampleTime+0x48>
    {
      /* Set standard sample time control for class 0 */
      WR_REG(VADCGroupPtr->ICLASS[0], VADC_G_ICLASS_STCS_Msk,
 801fcfc:	78fb      	ldrb	r3, [r7, #3]
 801fcfe:	f003 021f 	and.w	r2, r3, #31
 801fd02:	68bb      	ldr	r3, [r7, #8]
 801fd04:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 801fd08:	f023 031f 	bic.w	r3, r3, #31
 801fd0c:	431a      	orrs	r2, r3
 801fd0e:	68bb      	ldr	r3, [r7, #8]
 801fd10:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
                                 VADC_G_ICLASS_STCS_Pos, (uint32_t)SampleTime);
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fd14:	f04f 0300 	mov.w	r3, #0
 801fd18:	60fb      	str	r3, [r7, #12]
 801fd1a:	e002      	b.n	801fd22 <ADCGROUP001_SetGroupClass0SampleTime+0x4e>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fd1c:	f04f 0302 	mov.w	r3, #2
 801fd20:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
 
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fd22:	68fb      	ldr	r3, [r7, #12]
}
 801fd24:	4618      	mov	r0, r3
 801fd26:	f107 0714 	add.w	r7, r7, #20
 801fd2a:	46bd      	mov	sp, r7
 801fd2c:	bc80      	pop	{r7}
 801fd2e:	4770      	bx	lr

0801fd30 <ADCGROUP001_SetGroupClass1SampleTime>:

/* This function sets the sample time for standard conversion mode */
status_t ADCGROUP001_SetGroupClass1SampleTime(
                                        const ADCGROUP001_HandleType *HandlePtr, 
                                                             uint8_t SampleTime)
{
 801fd30:	b480      	push	{r7}
 801fd32:	b085      	sub	sp, #20
 801fd34:	af00      	add	r7, sp, #0
 801fd36:	6078      	str	r0, [r7, #4]
 801fd38:	460b      	mov	r3, r1
 801fd3a:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fd3c:	f04f 0301 	mov.w	r3, #1
 801fd40:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fd42:	687b      	ldr	r3, [r7, #4]
 801fd44:	695b      	ldr	r3, [r3, #20]
 801fd46:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fd48:	687b      	ldr	r3, [r7, #4]
 801fd4a:	68db      	ldr	r3, [r3, #12]
 801fd4c:	781b      	ldrb	r3, [r3, #0]
 801fd4e:	2b01      	cmp	r3, #1
 801fd50:	d115      	bne.n	801fd7e <ADCGROUP001_SetGroupClass1SampleTime+0x4e>
  {
    if(SampleTime < (uint8_t)ADCGROUP001_MAX_SAMPLE_TIME_CONTROL_VAL)
 801fd52:	78fb      	ldrb	r3, [r7, #3]
 801fd54:	2b1f      	cmp	r3, #31
 801fd56:	d80f      	bhi.n	801fd78 <ADCGROUP001_SetGroupClass1SampleTime+0x48>
    {
      /* Set standard sample time control for class 1 */
      WR_REG(VADCGroupPtr->ICLASS[1], VADC_G_ICLASS_STCS_Msk,
 801fd58:	78fb      	ldrb	r3, [r7, #3]
 801fd5a:	f003 021f 	and.w	r2, r3, #31
 801fd5e:	68bb      	ldr	r3, [r7, #8]
 801fd60:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801fd64:	f023 031f 	bic.w	r3, r3, #31
 801fd68:	431a      	orrs	r2, r3
 801fd6a:	68bb      	ldr	r3, [r7, #8]
 801fd6c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                                 VADC_G_ICLASS_STCS_Pos, (uint32_t)SampleTime);                              
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fd70:	f04f 0300 	mov.w	r3, #0
 801fd74:	60fb      	str	r3, [r7, #12]
 801fd76:	e002      	b.n	801fd7e <ADCGROUP001_SetGroupClass1SampleTime+0x4e>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fd78:	f04f 0302 	mov.w	r3, #2
 801fd7c:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fd7e:	68fb      	ldr	r3, [r7, #12]
}
 801fd80:	4618      	mov	r0, r3
 801fd82:	f107 0714 	add.w	r7, r7, #20
 801fd86:	46bd      	mov	sp, r7
 801fd88:	bc80      	pop	{r7}
 801fd8a:	4770      	bx	lr

0801fd8c <ADCGROUP001_SetGroupClass0EmuxSampleTime>:

/* This function sets the sample time for EMUX conversion mode*/
status_t ADCGROUP001_SetGroupClass0EmuxSampleTime(
                                        const ADCGROUP001_HandleType *HandlePtr, 
                                        uint8_t SampleTime)
{
 801fd8c:	b480      	push	{r7}
 801fd8e:	b085      	sub	sp, #20
 801fd90:	af00      	add	r7, sp, #0
 801fd92:	6078      	str	r0, [r7, #4]
 801fd94:	460b      	mov	r3, r1
 801fd96:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fd98:	f04f 0301 	mov.w	r3, #1
 801fd9c:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fd9e:	687b      	ldr	r3, [r7, #4]
 801fda0:	695b      	ldr	r3, [r3, #20]
 801fda2:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fda4:	687b      	ldr	r3, [r7, #4]
 801fda6:	68db      	ldr	r3, [r3, #12]
 801fda8:	781b      	ldrb	r3, [r3, #0]
 801fdaa:	2b01      	cmp	r3, #1
 801fdac:	d117      	bne.n	801fdde <ADCGROUP001_SetGroupClass0EmuxSampleTime+0x52>
  {
    if(SampleTime < (uint8_t)ADCGROUP001_MAX_SAMPLE_TIME_CONTROL_VAL)
 801fdae:	78fb      	ldrb	r3, [r7, #3]
 801fdb0:	2b1f      	cmp	r3, #31
 801fdb2:	d811      	bhi.n	801fdd8 <ADCGROUP001_SetGroupClass0EmuxSampleTime+0x4c>
    {
      /* Set EMUX sample time control for class 0 */
      WR_REG(VADCGroupPtr->ICLASS[0], VADC_G_ICLASS_STCE_Msk,
 801fdb4:	78fb      	ldrb	r3, [r7, #3]
 801fdb6:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801fdba:	f403 12f8 	and.w	r2, r3, #2031616	; 0x1f0000
 801fdbe:	68bb      	ldr	r3, [r7, #8]
 801fdc0:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 801fdc4:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 801fdc8:	431a      	orrs	r2, r3
 801fdca:	68bb      	ldr	r3, [r7, #8]
 801fdcc:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
                                 VADC_G_ICLASS_STCE_Pos, (uint32_t)SampleTime);
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fdd0:	f04f 0300 	mov.w	r3, #0
 801fdd4:	60fb      	str	r3, [r7, #12]
 801fdd6:	e002      	b.n	801fdde <ADCGROUP001_SetGroupClass0EmuxSampleTime+0x52>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fdd8:	f04f 0302 	mov.w	r3, #2
 801fddc:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);  
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fdde:	68fb      	ldr	r3, [r7, #12]
}
 801fde0:	4618      	mov	r0, r3
 801fde2:	f107 0714 	add.w	r7, r7, #20
 801fde6:	46bd      	mov	sp, r7
 801fde8:	bc80      	pop	{r7}
 801fdea:	4770      	bx	lr

0801fdec <ADCGROUP001_SetGroupClass1EmuxSampleTime>:

/* This function sets the sample time for EMUX conversion mode*/
status_t ADCGROUP001_SetGroupClass1EmuxSampleTime(
                                        const ADCGROUP001_HandleType *HandlePtr, 
                                        uint8_t SampleTime)
{
 801fdec:	b480      	push	{r7}
 801fdee:	b085      	sub	sp, #20
 801fdf0:	af00      	add	r7, sp, #0
 801fdf2:	6078      	str	r0, [r7, #4]
 801fdf4:	460b      	mov	r3, r1
 801fdf6:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fdf8:	f04f 0301 	mov.w	r3, #1
 801fdfc:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fdfe:	687b      	ldr	r3, [r7, #4]
 801fe00:	695b      	ldr	r3, [r3, #20]
 801fe02:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fe04:	687b      	ldr	r3, [r7, #4]
 801fe06:	68db      	ldr	r3, [r3, #12]
 801fe08:	781b      	ldrb	r3, [r3, #0]
 801fe0a:	2b01      	cmp	r3, #1
 801fe0c:	d117      	bne.n	801fe3e <ADCGROUP001_SetGroupClass1EmuxSampleTime+0x52>
  {
    if(SampleTime < (uint8_t)ADCGROUP001_MAX_SAMPLE_TIME_CONTROL_VAL)
 801fe0e:	78fb      	ldrb	r3, [r7, #3]
 801fe10:	2b1f      	cmp	r3, #31
 801fe12:	d811      	bhi.n	801fe38 <ADCGROUP001_SetGroupClass1EmuxSampleTime+0x4c>
    {
      /* Set EMUX sample time control for class 1 */
      WR_REG(VADCGroupPtr->ICLASS[1], VADC_G_ICLASS_STCE_Msk,
 801fe14:	78fb      	ldrb	r3, [r7, #3]
 801fe16:	ea4f 4303 	mov.w	r3, r3, lsl #16
 801fe1a:	f403 12f8 	and.w	r2, r3, #2031616	; 0x1f0000
 801fe1e:	68bb      	ldr	r3, [r7, #8]
 801fe20:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801fe24:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 801fe28:	431a      	orrs	r2, r3
 801fe2a:	68bb      	ldr	r3, [r7, #8]
 801fe2c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                                  VADC_G_ICLASS_STCE_Pos, (uint32_t)SampleTime);
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fe30:	f04f 0300 	mov.w	r3, #0
 801fe34:	60fb      	str	r3, [r7, #12]
 801fe36:	e002      	b.n	801fe3e <ADCGROUP001_SetGroupClass1EmuxSampleTime+0x52>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fe38:	f04f 0302 	mov.w	r3, #2
 801fe3c:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
 
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fe3e:	68fb      	ldr	r3, [r7, #12]
}
 801fe40:	4618      	mov	r0, r3
 801fe42:	f107 0714 	add.w	r7, r7, #20
 801fe46:	46bd      	mov	sp, r7
 801fe48:	bc80      	pop	{r7}
 801fe4a:	4770      	bx	lr

0801fe4c <ADCGROUP001_SetGroupClass0ConvMode>:

/* This function sets the standard conversion mode in group class 0 */
status_t ADCGROUP001_SetGroupClass0ConvMode(
                                      const ADCGROUP001_HandleType *HandlePtr, 
                                      uint8_t ConversionModeVal)
{
 801fe4c:	b480      	push	{r7}
 801fe4e:	b085      	sub	sp, #20
 801fe50:	af00      	add	r7, sp, #0
 801fe52:	6078      	str	r0, [r7, #4]
 801fe54:	460b      	mov	r3, r1
 801fe56:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fe58:	f04f 0301 	mov.w	r3, #1
 801fe5c:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fe5e:	687b      	ldr	r3, [r7, #4]
 801fe60:	695b      	ldr	r3, [r3, #20]
 801fe62:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fe64:	687b      	ldr	r3, [r7, #4]
 801fe66:	68db      	ldr	r3, [r3, #12]
 801fe68:	781b      	ldrb	r3, [r3, #0]
 801fe6a:	2b01      	cmp	r3, #1
 801fe6c:	d11a      	bne.n	801fea4 <ADCGROUP001_SetGroupClass0ConvMode+0x58>
  {
    if((ConversionModeVal <= (uint8_t)ADCGROUP001_8BIT) ||
 801fe6e:	78fb      	ldrb	r3, [r7, #3]
 801fe70:	2b02      	cmp	r3, #2
 801fe72:	d902      	bls.n	801fe7a <ADCGROUP001_SetGroupClass0ConvMode+0x2e>
 801fe74:	78fb      	ldrb	r3, [r7, #3]
 801fe76:	2b05      	cmp	r3, #5
 801fe78:	d111      	bne.n	801fe9e <ADCGROUP001_SetGroupClass0ConvMode+0x52>
        (ConversionModeVal == (uint8_t)ADCGROUP001_10BITFAST))
    {
      /* Set conversion mode for class 0 */
      WR_REG(VADCGroupPtr->ICLASS[0], VADC_G_ICLASS_CMS_Msk,
 801fe7a:	78fb      	ldrb	r3, [r7, #3]
 801fe7c:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801fe80:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 801fe84:	68bb      	ldr	r3, [r7, #8]
 801fe86:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 801fe8a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 801fe8e:	431a      	orrs	r2, r3
 801fe90:	68bb      	ldr	r3, [r7, #8]
 801fe92:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
                            VADC_G_ICLASS_CMS_Pos, (uint32_t)ConversionModeVal);
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fe96:	f04f 0300 	mov.w	r3, #0
 801fe9a:	60fb      	str	r3, [r7, #12]
 801fe9c:	e002      	b.n	801fea4 <ADCGROUP001_SetGroupClass0ConvMode+0x58>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801fe9e:	f04f 0302 	mov.w	r3, #2
 801fea2:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);   
  }
  
  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801fea4:	68fb      	ldr	r3, [r7, #12]
}
 801fea6:	4618      	mov	r0, r3
 801fea8:	f107 0714 	add.w	r7, r7, #20
 801feac:	46bd      	mov	sp, r7
 801feae:	bc80      	pop	{r7}
 801feb0:	4770      	bx	lr
 801feb2:	bf00      	nop

0801feb4 <ADCGROUP001_SetGroupClass1ConvMode>:

/* This function sets the standard conversion mode */
status_t ADCGROUP001_SetGroupClass1ConvMode(
                                      const ADCGROUP001_HandleType *HandlePtr, 
                                      uint8_t ConversionModeVal)
{
 801feb4:	b480      	push	{r7}
 801feb6:	b085      	sub	sp, #20
 801feb8:	af00      	add	r7, sp, #0
 801feba:	6078      	str	r0, [r7, #4]
 801febc:	460b      	mov	r3, r1
 801febe:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fec0:	f04f 0301 	mov.w	r3, #1
 801fec4:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fec6:	687b      	ldr	r3, [r7, #4]
 801fec8:	695b      	ldr	r3, [r3, #20]
 801feca:	60bb      	str	r3, [r7, #8]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801fecc:	687b      	ldr	r3, [r7, #4]
 801fece:	68db      	ldr	r3, [r3, #12]
 801fed0:	781b      	ldrb	r3, [r3, #0]
 801fed2:	2b01      	cmp	r3, #1
 801fed4:	d11a      	bne.n	801ff0c <ADCGROUP001_SetGroupClass1ConvMode+0x58>
  {
    if((ConversionModeVal <= (uint8_t)ADCGROUP001_8BIT) ||
 801fed6:	78fb      	ldrb	r3, [r7, #3]
 801fed8:	2b02      	cmp	r3, #2
 801feda:	d902      	bls.n	801fee2 <ADCGROUP001_SetGroupClass1ConvMode+0x2e>
 801fedc:	78fb      	ldrb	r3, [r7, #3]
 801fede:	2b05      	cmp	r3, #5
 801fee0:	d111      	bne.n	801ff06 <ADCGROUP001_SetGroupClass1ConvMode+0x52>
        (ConversionModeVal == (uint8_t)ADCGROUP001_10BITFAST))
    {
      /* Set conversion mode for class 1 */
      WR_REG(VADCGroupPtr->ICLASS[1], VADC_G_ICLASS_CMS_Msk,
 801fee2:	78fb      	ldrb	r3, [r7, #3]
 801fee4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 801fee8:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 801feec:	68bb      	ldr	r3, [r7, #8]
 801feee:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801fef2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 801fef6:	431a      	orrs	r2, r3
 801fef8:	68bb      	ldr	r3, [r7, #8]
 801fefa:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                            VADC_G_ICLASS_CMS_Pos, (uint32_t)ConversionModeVal);
      Status = (uint32_t)DAVEApp_SUCCESS;
 801fefe:	f04f 0300 	mov.w	r3, #0
 801ff02:	60fb      	str	r3, [r7, #12]
 801ff04:	e002      	b.n	801ff0c <ADCGROUP001_SetGroupClass1ConvMode+0x58>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801ff06:	f04f 0302 	mov.w	r3, #2
 801ff0a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);    
  }

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801ff0c:	68fb      	ldr	r3, [r7, #12]
}
 801ff0e:	4618      	mov	r0, r3
 801ff10:	f107 0714 	add.w	r7, r7, #20
 801ff14:	46bd      	mov	sp, r7
 801ff16:	bc80      	pop	{r7}
 801ff18:	4770      	bx	lr
 801ff1a:	bf00      	nop

0801ff1c <ADCGROUP001_SetGroupClass0EmuxConvMode>:
/* This function sets the emux conversion mode */
status_t ADCGROUP001_SetGroupClass0EmuxConvMode(
                                        const ADCGROUP001_HandleType *HandlePtr, 
                                        uint8_t ConversionModeVal
                                          )
{
 801ff1c:	b480      	push	{r7}
 801ff1e:	b085      	sub	sp, #20
 801ff20:	af00      	add	r7, sp, #0
 801ff22:	6078      	str	r0, [r7, #4]
 801ff24:	460b      	mov	r3, r1
 801ff26:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801ff28:	f04f 0301 	mov.w	r3, #1
 801ff2c:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801ff2e:	687b      	ldr	r3, [r7, #4]
 801ff30:	695b      	ldr	r3, [r3, #20]
 801ff32:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801ff34:	687b      	ldr	r3, [r7, #4]
 801ff36:	68db      	ldr	r3, [r3, #12]
 801ff38:	781b      	ldrb	r3, [r3, #0]
 801ff3a:	2b01      	cmp	r3, #1
 801ff3c:	d11a      	bne.n	801ff74 <ADCGROUP001_SetGroupClass0EmuxConvMode+0x58>
  {
    if((ConversionModeVal <= (uint8_t)ADCGROUP001_8BIT) ||
 801ff3e:	78fb      	ldrb	r3, [r7, #3]
 801ff40:	2b02      	cmp	r3, #2
 801ff42:	d902      	bls.n	801ff4a <ADCGROUP001_SetGroupClass0EmuxConvMode+0x2e>
 801ff44:	78fb      	ldrb	r3, [r7, #3]
 801ff46:	2b05      	cmp	r3, #5
 801ff48:	d111      	bne.n	801ff6e <ADCGROUP001_SetGroupClass0EmuxConvMode+0x52>
        (ConversionModeVal == (uint8_t)ADCGROUP001_10BITFAST))
    {
      /* Set EMUX conversion mode for class 0 */
      WR_REG(VADCGroupPtr->ICLASS[0], VADC_G_ICLASS_CME_Msk,
 801ff4a:	78fb      	ldrb	r3, [r7, #3]
 801ff4c:	ea4f 6303 	mov.w	r3, r3, lsl #24
 801ff50:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
 801ff54:	68bb      	ldr	r3, [r7, #8]
 801ff56:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 801ff5a:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 801ff5e:	431a      	orrs	r2, r3
 801ff60:	68bb      	ldr	r3, [r7, #8]
 801ff62:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
                            VADC_G_ICLASS_CME_Pos, (uint32_t)ConversionModeVal);
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801ff66:	f04f 0300 	mov.w	r3, #0
 801ff6a:	60fb      	str	r3, [r7, #12]
 801ff6c:	e002      	b.n	801ff74 <ADCGROUP001_SetGroupClass0EmuxConvMode+0x58>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801ff6e:	f04f 0302 	mov.w	r3, #2
 801ff72:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);    
  }

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801ff74:	68fb      	ldr	r3, [r7, #12]
}
 801ff76:	4618      	mov	r0, r3
 801ff78:	f107 0714 	add.w	r7, r7, #20
 801ff7c:	46bd      	mov	sp, r7
 801ff7e:	bc80      	pop	{r7}
 801ff80:	4770      	bx	lr
 801ff82:	bf00      	nop

0801ff84 <ADCGROUP001_SetGroupClass1EmuxConvMode>:
/* This function sets the emux conversion mode */
status_t ADCGROUP001_SetGroupClass1EmuxConvMode(
                                        const ADCGROUP001_HandleType *HandlePtr, 
                                        uint8_t ConversionModeVal
                                          )
{
 801ff84:	b480      	push	{r7}
 801ff86:	b085      	sub	sp, #20
 801ff88:	af00      	add	r7, sp, #0
 801ff8a:	6078      	str	r0, [r7, #4]
 801ff8c:	460b      	mov	r3, r1
 801ff8e:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801ff90:	f04f 0301 	mov.w	r3, #1
 801ff94:	60fb      	str	r3, [r7, #12]
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801ff96:	687b      	ldr	r3, [r7, #4]
 801ff98:	695b      	ldr	r3, [r3, #20]
 801ff9a:	60bb      	str	r3, [r7, #8]
 
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 801ff9c:	687b      	ldr	r3, [r7, #4]
 801ff9e:	68db      	ldr	r3, [r3, #12]
 801ffa0:	781b      	ldrb	r3, [r3, #0]
 801ffa2:	2b01      	cmp	r3, #1
 801ffa4:	d11a      	bne.n	801ffdc <ADCGROUP001_SetGroupClass1EmuxConvMode+0x58>
  {
    if((ConversionModeVal <= (uint8_t)ADCGROUP001_8BIT) ||
 801ffa6:	78fb      	ldrb	r3, [r7, #3]
 801ffa8:	2b02      	cmp	r3, #2
 801ffaa:	d902      	bls.n	801ffb2 <ADCGROUP001_SetGroupClass1EmuxConvMode+0x2e>
 801ffac:	78fb      	ldrb	r3, [r7, #3]
 801ffae:	2b05      	cmp	r3, #5
 801ffb0:	d111      	bne.n	801ffd6 <ADCGROUP001_SetGroupClass1EmuxConvMode+0x52>
        (ConversionModeVal == (uint8_t)ADCGROUP001_10BITFAST))
    {
      /* Set EMUX conversion mode for class 1 */
      WR_REG(VADCGroupPtr->ICLASS[1], VADC_G_ICLASS_CME_Msk,
 801ffb2:	78fb      	ldrb	r3, [r7, #3]
 801ffb4:	ea4f 6303 	mov.w	r3, r3, lsl #24
 801ffb8:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
 801ffbc:	68bb      	ldr	r3, [r7, #8]
 801ffbe:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 801ffc2:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 801ffc6:	431a      	orrs	r2, r3
 801ffc8:	68bb      	ldr	r3, [r7, #8]
 801ffca:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                           VADC_G_ICLASS_CME_Pos, (uint32_t)ConversionModeVal);
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 801ffce:	f04f 0300 	mov.w	r3, #0
 801ffd2:	60fb      	str	r3, [r7, #12]
 801ffd4:	e002      	b.n	801ffdc <ADCGROUP001_SetGroupClass1EmuxConvMode+0x58>
    }
    else
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 801ffd6:	f04f 0302 	mov.w	r3, #2
 801ffda:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL); 
  }

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 801ffdc:	68fb      	ldr	r3, [r7, #12]
}
 801ffde:	4618      	mov	r0, r3
 801ffe0:	f107 0714 	add.w	r7, r7, #20
 801ffe4:	46bd      	mov	sp, r7
 801ffe6:	bc80      	pop	{r7}
 801ffe8:	4770      	bx	lr
 801ffea:	bf00      	nop

0801ffec <ADCGROUP001_SetEMUXSampleTimeControl>:


/* This function sets the value of EMUX sample time control. */
status_t ADCGROUP001_SetEMUXSampleTimeControl(
                  const ADCGROUP001_HandleType *HandlePtr, uint8_t ControlValue)
{
 801ffec:	b480      	push	{r7}
 801ffee:	b087      	sub	sp, #28
 801fff0:	af00      	add	r7, sp, #0
 801fff2:	6078      	str	r0, [r7, #4]
 801fff4:	460b      	mov	r3, r1
 801fff6:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGROUP001_OPER_NOT_ALLOWED_ERROR;
 801fff8:	f04f 0301 	mov.w	r3, #1
 801fffc:	617b      	str	r3, [r7, #20]
  uint32_t SampleTimeCtrl;
  /*Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr;              
  VADCGroupPtr = HandlePtr->VADCGroupPtr;
 801fffe:	687b      	ldr	r3, [r7, #4]
 8020000:	695b      	ldr	r3, [r3, #20]
 8020002:	613b      	str	r3, [r7, #16]
  
  FUNCTION_ENTRY(GID_ADCGROUP001, ADCGROUP001_FUNCTION_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCGROUP001_INITIALIZED))
 8020004:	687b      	ldr	r3, [r7, #4]
 8020006:	68db      	ldr	r3, [r3, #12]
 8020008:	781b      	ldrb	r3, [r3, #0]
 802000a:	2b01      	cmp	r3, #1
 802000c:	d11f      	bne.n	802004e <ADCGROUP001_SetEMUXSampleTimeControl+0x62>
  {
    if(ControlValue <= (uint8_t)SET)
 802000e:	78fb      	ldrb	r3, [r7, #3]
 8020010:	2b01      	cmp	r3, #1
 8020012:	d819      	bhi.n	8020048 <ADCGROUP001_SetEMUXSampleTimeControl+0x5c>
    {
      /* Set the EMUX sample time control */
      SampleTimeCtrl = VADCGroupPtr->EMUXCTR;
 8020014:	693b      	ldr	r3, [r7, #16]
 8020016:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 802001a:	60fb      	str	r3, [r7, #12]
      SampleTimeCtrl &= (uint32_t)~(VADC_G_EMUXCTR_EMXST_Msk);
 802001c:	68fb      	ldr	r3, [r7, #12]
 802001e:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8020022:	60fb      	str	r3, [r7, #12]
      SampleTimeCtrl |= (VADC_G_EMUXCTR_EMXWC_Msk) | \
                    (((uint32_t)ControlValue << VADC_G_EMUXCTR_EMXST_Pos) & VADC_G_EMUXCTR_EMXST_Msk);
 8020024:	78fb      	ldrb	r3, [r7, #3]
 8020026:	ea4f 7343 	mov.w	r3, r3, lsl #29
 802002a:	f003 5200 	and.w	r2, r3, #536870912	; 0x20000000
    if(ControlValue <= (uint8_t)SET)
    {
      /* Set the EMUX sample time control */
      SampleTimeCtrl = VADCGroupPtr->EMUXCTR;
      SampleTimeCtrl &= (uint32_t)~(VADC_G_EMUXCTR_EMXST_Msk);
      SampleTimeCtrl |= (VADC_G_EMUXCTR_EMXWC_Msk) | \
 802002e:	68fb      	ldr	r3, [r7, #12]
 8020030:	4313      	orrs	r3, r2
 8020032:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8020036:	60fb      	str	r3, [r7, #12]
                    (((uint32_t)ControlValue << VADC_G_EMUXCTR_EMXST_Pos) & VADC_G_EMUXCTR_EMXST_Msk);
      VADCGroupPtr->EMUXCTR = SampleTimeCtrl;
 8020038:	693b      	ldr	r3, [r7, #16]
 802003a:	68fa      	ldr	r2, [r7, #12]
 802003c:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
  
      Status = (uint32_t)DAVEApp_SUCCESS;
 8020040:	f04f 0300 	mov.w	r3, #0
 8020044:	617b      	str	r3, [r7, #20]
 8020046:	e002      	b.n	802004e <ADCGROUP001_SetEMUXSampleTimeControl+0x62>
    }
    else 
    {
      Status = (uint32_t)ADCGROUP001_INVALID_PARAM_ERROR;
 8020048:	f04f 0302 	mov.w	r3, #2
 802004c:	617b      	str	r3, [r7, #20]
  {
    ERROR(GID_ADCGROUP001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADCGROUP001, ADCGROUP001_FUNCTION_EXIT);
  return Status;
 802004e:	697b      	ldr	r3, [r7, #20]
}
 8020050:	4618      	mov	r0, r3
 8020052:	f107 071c 	add.w	r7, r7, #28
 8020056:	46bd      	mov	sp, r7
 8020058:	bc80      	pop	{r7}
 802005a:	4770      	bx	lr

0802005c <ADCGLOB001_Init>:

/**
 *This function initialize all VADC Global registers based on GUI configuration.
 */
void ADCGLOB001_Init(void)
{
 802005c:	b580      	push	{r7, lr}
 802005e:	af00      	add	r7, sp, #0
  FUNCTION_ENTRY(GID_ADCGLOB001,(uint32_t)ADCGLOB001_FUNCTION_ENTRY);
  
  if(ADCGLOB001_Handle0.kDynamicDataPtr->StateType == ADCGLOB001_UNINITIALIZED )
 8020060:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020064:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020068:	685b      	ldr	r3, [r3, #4]
 802006a:	781b      	ldrb	r3, [r3, #0]
 802006c:	2b00      	cmp	r3, #0
 802006e:	f040 80c4 	bne.w	80201fa <ADCGLOB001_Init+0x19e>
  {
      
    /* Initialise clock init.*/
    CLK001_Init();  
 8020072:	f7ff faaf 	bl	801f5d4 <CLK001_Init>
        
    /* Bring ADC Module Out of Reset */
    RESET001_DeassertReset(PER0_VADC);
 8020076:	f04f 0001 	mov.w	r0, #1
 802007a:	f7e9 fc9b 	bl	80099b4 <RESET001_DeassertReset>
      
    /* Bring the module out of disabled state.*/
    CLR_BIT( ADCGLOB001_Handle0.kGlobalPtr->CLC, VADC_CLC_DISR_Pos);
 802007e:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020082:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020086:	681a      	ldr	r2, [r3, #0]
 8020088:	f646 03b0 	movw	r3, #26800	; 0x68b0
 802008c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020090:	681b      	ldr	r3, [r3, #0]
 8020092:	681b      	ldr	r3, [r3, #0]
 8020094:	f023 0301 	bic.w	r3, r3, #1
 8020098:	6013      	str	r3, [r2, #0]
     * Make divider bit fields writable.
     * Configure Divider Factor for the Analog Internal Clock.
     * Configure Divider Factor for the Arbiter Clock.
     * Configure Double Clock for the MSB Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG = \
 802009a:	f646 03b0 	movw	r3, #26800	; 0x68b0
 802009e:	f6c0 0302 	movt	r3, #2050	; 0x802
 80200a2:	681a      	ldr	r2, [r3, #0]
                (uint32_t)(((uint32_t)1<<VADC_GLOBCFG_DIVWC_Pos)| \
                (((uint32_t)ADCGLOB001_Handle0.kArbiterClkDivider <<VADC_GLOBCFG_DIVD_Pos) & VADC_GLOBCFG_DIVD_Msk)| \
 80200a4:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80200a8:	f6c0 0302 	movt	r3, #2050	; 0x802
 80200ac:	7b5b      	ldrb	r3, [r3, #13]
 80200ae:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80200b2:	f403 7140 	and.w	r1, r3, #768	; 0x300
                (((uint32_t)ADCGLOB001_Handle0.keDoubleClkMSBConver <<VADC_GLOBCFG_DCMSB_Pos)&VADC_GLOBCFG_DCMSB_Msk)| \
 80200b6:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80200ba:	f6c0 0302 	movt	r3, #2050	; 0x802
 80200be:	7ddb      	ldrb	r3, [r3, #23]
 80200c0:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 80200c4:	b2db      	uxtb	r3, r3
     * Configure Divider Factor for the Arbiter Clock.
     * Configure Double Clock for the MSB Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG = \
                (uint32_t)(((uint32_t)1<<VADC_GLOBCFG_DIVWC_Pos)| \
                (((uint32_t)ADCGLOB001_Handle0.kArbiterClkDivider <<VADC_GLOBCFG_DIVD_Pos) & VADC_GLOBCFG_DIVD_Msk)| \
 80200c6:	4319      	orrs	r1, r3
                (((uint32_t)ADCGLOB001_Handle0.keDoubleClkMSBConver <<VADC_GLOBCFG_DCMSB_Pos)&VADC_GLOBCFG_DCMSB_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kAnalogClkDivider <<VADC_GLOBCFG_DIVA_Pos)&VADC_GLOBCFG_DIVA_Msk));
 80200c8:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80200cc:	f6c0 0302 	movt	r3, #2050	; 0x802
 80200d0:	7b1b      	ldrb	r3, [r3, #12]
 80200d2:	f003 031f 	and.w	r3, r3, #31
     * Configure Divider Factor for the Analog Internal Clock.
     * Configure Divider Factor for the Arbiter Clock.
     * Configure Double Clock for the MSB Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG = \
                (uint32_t)(((uint32_t)1<<VADC_GLOBCFG_DIVWC_Pos)| \
 80200d6:	430b      	orrs	r3, r1
 80200d8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
     * Make divider bit fields writable.
     * Configure Divider Factor for the Analog Internal Clock.
     * Configure Divider Factor for the Arbiter Clock.
     * Configure Double Clock for the MSB Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG = \
 80200dc:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
                (uint32_t)(((uint32_t)1<<VADC_GLOBCFG_DIVWC_Pos)| \
                (((uint32_t)ADCGLOB001_Handle0.kArbiterClkDivider <<VADC_GLOBCFG_DIVD_Pos) & VADC_GLOBCFG_DIVD_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.keDoubleClkMSBConver <<VADC_GLOBCFG_DCMSB_Pos)&VADC_GLOBCFG_DCMSB_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kAnalogClkDivider <<VADC_GLOBCFG_DIVA_Pos)&VADC_GLOBCFG_DIVA_Msk));
    /* Make the divider bit fields write protected */
    CLR_BIT( ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG, VADC_GLOBCFG_DIVWC_Pos);
 80200e0:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80200e4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80200e8:	681a      	ldr	r2, [r3, #0]
 80200ea:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80200ee:	f6c0 0302 	movt	r3, #2050	; 0x802
 80200f2:	681b      	ldr	r3, [r3, #0]
 80200f4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80200f8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80200fc:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
     * Configure Class0 Sample Time Control for Standard Conversion.
     * Configure Class0 Sample Time Control for EMUX Conversion.
     * Configure Class0 Conversion Mode for Standard Conversion.
     * Configure Class0 Conversion Mode for EMUX Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[0] = \
 8020100:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020104:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020108:	681a      	ldr	r2, [r3, #0]
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass0 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
 802010a:	f646 03b0 	movw	r3, #26800	; 0x68b0
 802010e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020112:	7d1b      	ldrb	r3, [r3, #20]
 8020114:	ea4f 6303 	mov.w	r3, r3, lsl #24
 8020118:	f003 61e0 	and.w	r1, r3, #117440512	; 0x7000000
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass0 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
 802011c:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020120:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020124:	7c1b      	ldrb	r3, [r3, #16]
 8020126:	ea4f 4303 	mov.w	r3, r3, lsl #16
 802012a:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
     * Configure Class0 Sample Time Control for EMUX Conversion.
     * Configure Class0 Conversion Mode for Standard Conversion.
     * Configure Class0 Conversion Mode for EMUX Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[0] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass0 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
 802012e:	4319      	orrs	r1, r3
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass0 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass0 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
 8020130:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020134:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020138:	7c9b      	ldrb	r3, [r3, #18]
 802013a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 802013e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
     * Configure Class0 Conversion Mode for Standard Conversion.
     * Configure Class0 Conversion Mode for EMUX Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[0] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass0 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass0 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
 8020142:	4319      	orrs	r1, r3
                (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass0 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kSampleTimeControlClass0 <<VADC_GLOBICLASS_STCS_Pos)&VADC_GLOBICLASS_STCS_Msk));
 8020144:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020148:	f6c0 0302 	movt	r3, #2050	; 0x802
 802014c:	7b9b      	ldrb	r3, [r3, #14]
 802014e:	f003 031f 	and.w	r3, r3, #31
     * Configure Class0 Sample Time Control for EMUX Conversion.
     * Configure Class0 Conversion Mode for Standard Conversion.
     * Configure Class0 Conversion Mode for EMUX Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[0] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass0 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
 8020152:	430b      	orrs	r3, r1
     * Configure Class0 Sample Time Control for Standard Conversion.
     * Configure Class0 Sample Time Control for EMUX Conversion.
     * Configure Class0 Conversion Mode for Standard Conversion.
     * Configure Class0 Conversion Mode for EMUX Conversion.
     */
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[0] = \
 8020154:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
     * Configure Class1 Sample Time Control for Standard Conversion.
     * Configure Class1 Sample Time Control for EMUX Conversion.
     * Configure Class1 Conversion Mode for Standard Conversion.
     * Configure Class1 Conversion Mode for EMUX Conversion.
     */    
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[1] = \
 8020158:	f646 03b0 	movw	r3, #26800	; 0x68b0
 802015c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020160:	681a      	ldr	r2, [r3, #0]
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass1 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
 8020162:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020166:	f6c0 0302 	movt	r3, #2050	; 0x802
 802016a:	7d5b      	ldrb	r3, [r3, #21]
 802016c:	ea4f 6303 	mov.w	r3, r3, lsl #24
 8020170:	f003 61e0 	and.w	r1, r3, #117440512	; 0x7000000
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass1 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
 8020174:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020178:	f6c0 0302 	movt	r3, #2050	; 0x802
 802017c:	7c5b      	ldrb	r3, [r3, #17]
 802017e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8020182:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
     * Configure Class1 Sample Time Control for EMUX Conversion.
     * Configure Class1 Conversion Mode for Standard Conversion.
     * Configure Class1 Conversion Mode for EMUX Conversion.
     */    
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[1] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass1 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
 8020186:	4319      	orrs	r1, r3
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass1 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass1 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
 8020188:	f646 03b0 	movw	r3, #26800	; 0x68b0
 802018c:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020190:	7cdb      	ldrb	r3, [r3, #19]
 8020192:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8020196:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
     * Configure Class1 Conversion Mode for Standard Conversion.
     * Configure Class1 Conversion Mode for EMUX Conversion.
     */    
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[1] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass1 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass1 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
 802019a:	4319      	orrs	r1, r3
                (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass1 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kSampleTimeControlClass1<<VADC_GLOBICLASS_STCS_Pos)&VADC_GLOBICLASS_STCS_Msk));
 802019c:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80201a0:	f6c0 0302 	movt	r3, #2050	; 0x802
 80201a4:	7bdb      	ldrb	r3, [r3, #15]
 80201a6:	f003 031f 	and.w	r3, r3, #31
     * Configure Class1 Sample Time Control for EMUX Conversion.
     * Configure Class1 Conversion Mode for Standard Conversion.
     * Configure Class1 Conversion Mode for EMUX Conversion.
     */    
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[1] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass1 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
 80201aa:	430b      	orrs	r3, r1
     * Configure Class1 Sample Time Control for Standard Conversion.
     * Configure Class1 Sample Time Control for EMUX Conversion.
     * Configure Class1 Conversion Mode for Standard Conversion.
     * Configure Class1 Conversion Mode for EMUX Conversion.
     */    
    ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[1] = \
 80201ac:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass1 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass1 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kSampleTimeControlClass1<<VADC_GLOBICLASS_STCS_Pos)&VADC_GLOBICLASS_STCS_Msk));
          
    /* Configure the lower and upper boundary based on the GUI configuration.*/
    ADCGLOB001_Handle0.kGlobalPtr->GLOBBOUND = \
 80201b0:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80201b4:	f6c0 0302 	movt	r3, #2050	; 0x802
 80201b8:	6819      	ldr	r1, [r3, #0]
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.KGlobBoundary1 <<VADC_GLOBBOUND_BOUNDARY1_Pos)&VADC_GLOBBOUND_BOUNDARY1_Msk)| \
 80201ba:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80201be:	f6c0 0302 	movt	r3, #2050	; 0x802
 80201c2:	895b      	ldrh	r3, [r3, #10]
 80201c4:	ea4f 4203 	mov.w	r2, r3, lsl #16
 80201c8:	f04f 0300 	mov.w	r3, #0
 80201cc:	f6c0 73ff 	movt	r3, #4095	; 0xfff
 80201d0:	4013      	ands	r3, r2
                (((uint32_t)ADCGLOB001_Handle0.KGlobBoundary0 <<VADC_GLOBBOUND_BOUNDARY0_Pos)&VADC_GLOBBOUND_BOUNDARY0_Msk));
 80201d2:	f646 02b0 	movw	r2, #26800	; 0x68b0
 80201d6:	f6c0 0202 	movt	r2, #2050	; 0x802
 80201da:	8912      	ldrh	r2, [r2, #8]
 80201dc:	ea4f 5202 	mov.w	r2, r2, lsl #20
 80201e0:	ea4f 5212 	mov.w	r2, r2, lsr #20
                (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass1 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kSampleTimeControlClass1<<VADC_GLOBICLASS_STCS_Pos)&VADC_GLOBICLASS_STCS_Msk));
          
    /* Configure the lower and upper boundary based on the GUI configuration.*/
    ADCGLOB001_Handle0.kGlobalPtr->GLOBBOUND = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.KGlobBoundary1 <<VADC_GLOBBOUND_BOUNDARY1_Pos)&VADC_GLOBBOUND_BOUNDARY1_Msk)| \
 80201e4:	4313      	orrs	r3, r2
                (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass1 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass1 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.kSampleTimeControlClass1<<VADC_GLOBICLASS_STCS_Pos)&VADC_GLOBICLASS_STCS_Msk));
          
    /* Configure the lower and upper boundary based on the GUI configuration.*/
    ADCGLOB001_Handle0.kGlobalPtr->GLOBBOUND = \
 80201e6:	f8c1 30b8 	str.w	r3, [r1, #184]	; 0xb8
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.KGlobBoundary1 <<VADC_GLOBBOUND_BOUNDARY1_Pos)&VADC_GLOBBOUND_BOUNDARY1_Msk)| \
                (((uint32_t)ADCGLOB001_Handle0.KGlobBoundary0 <<VADC_GLOBBOUND_BOUNDARY0_Pos)&VADC_GLOBBOUND_BOUNDARY0_Msk));
             
    ADCGLOB001_Handle0.kDynamicDataPtr->StateType = ADCGLOB001_INITIALIZED;
 80201ea:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80201ee:	f6c0 0302 	movt	r3, #2050	; 0x802
 80201f2:	685b      	ldr	r3, [r3, #4]
 80201f4:	f04f 0201 	mov.w	r2, #1
 80201f8:	701a      	strb	r2, [r3, #0]
  } else {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
}
 80201fa:	bd80      	pop	{r7, pc}

080201fc <ADCGLOB001_DeInit>:

/**
 * This function will de-initialize VADC Global registers.
 */
status_t ADCGLOB001_DeInit(const ADCGLOB001_HandleType * HandlePtr)
{
 80201fc:	b480      	push	{r7}
 80201fe:	b085      	sub	sp, #20
 8020200:	af00      	add	r7, sp, #0
 8020202:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020204:	f04f 0301 	mov.w	r3, #1
 8020208:	60fb      	str	r3, [r7, #12]
  
  FUNCTION_ENTRY(GID_ADCGLOB001,(uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if(HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED )
 802020a:	687b      	ldr	r3, [r7, #4]
 802020c:	685b      	ldr	r3, [r3, #4]
 802020e:	781b      	ldrb	r3, [r3, #0]
 8020210:	2b01      	cmp	r3, #1
 8020212:	d137      	bne.n	8020284 <ADCGLOB001_DeInit+0x88>
  {
    /* Bring the module out of disabled state */
    CLR_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_DISR_Pos);
 8020214:	687b      	ldr	r3, [r7, #4]
 8020216:	681b      	ldr	r3, [r3, #0]
 8020218:	687a      	ldr	r2, [r7, #4]
 802021a:	6812      	ldr	r2, [r2, #0]
 802021c:	6812      	ldr	r2, [r2, #0]
 802021e:	f022 0201 	bic.w	r2, r2, #1
 8020222:	601a      	str	r2, [r3, #0]
        
    /* Make divider bit fields writable and deconfigure Analog Internal Clock, 
     Arbiter Clock & MSB Conversion bits.*/
    HandlePtr->kGlobalPtr->GLOBCFG = \
 8020224:	687b      	ldr	r3, [r7, #4]
 8020226:	681a      	ldr	r2, [r3, #0]
 8020228:	f64f 4360 	movw	r3, #64608	; 0xfc60
 802022c:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8020230:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
                    (((uint32_t)1<<VADC_GLOBCFG_DIVWC_Pos)|((~(VADC_GLOBCFG_DIVD_Msk))& \
                    (~(VADC_GLOBCFG_DCMSB_Msk)) & (~(VADC_GLOBCFG_DIVA_Msk))));
        
    /* Again make the divider bit fields write protected */
    CLR_BIT( HandlePtr->kGlobalPtr->GLOBCFG, VADC_GLOBCFG_DIVWC_Pos);  
 8020234:	687b      	ldr	r3, [r7, #4]
 8020236:	681b      	ldr	r3, [r3, #0]
 8020238:	687a      	ldr	r2, [r7, #4]
 802023a:	6812      	ldr	r2, [r2, #0]
 802023c:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 8020240:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8020244:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
     *  mode.
     * Configure Class0 Conversion Mode for Standard Conversion into default mode.
     * Configure Class0 Sample Time Control for EMUX Conversion into default mode.
     * Configure Class0  Conversion Mode for EMUX Conversion into default mode.
     */
    HandlePtr->kGlobalPtr->GLOBICLASS[0] = \
 8020248:	687b      	ldr	r3, [r7, #4]
 802024a:	681a      	ldr	r2, [r3, #0]
 802024c:	f64f 03e0 	movw	r3, #63712	; 0xf8e0
 8020250:	f6cf 03e0 	movt	r3, #63712	; 0xf8e0
 8020254:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
     *  mode.
     * Configure Class1 Conversion Mode for Standard Conversion into default mode.
     * Configure Class1 Sample Time Control for EMUX Conversion into default mode.
     * Configure Class1  Conversion Mode for EMUX Conversion into default mode.
     */
    HandlePtr->kGlobalPtr->GLOBICLASS[1] = \
 8020258:	687b      	ldr	r3, [r7, #4]
 802025a:	681a      	ldr	r2, [r3, #0]
 802025c:	f64f 03e0 	movw	r3, #63712	; 0xf8e0
 8020260:	f6cf 03e0 	movt	r3, #63712	; 0xf8e0
 8020264:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
                    ((~(VADC_GLOBICLASS_CME_Msk))&(~(VADC_GLOBICLASS_STCE_Msk))& \
                    (~(VADC_GLOBICLASS_CMS_Msk))&(~(VADC_GLOBICLASS_STCS_Msk)));
        
    /* Configure global lower and upper boundary value into default value.*/
    HandlePtr->kGlobalPtr->GLOBBOUND = \
 8020268:	687b      	ldr	r3, [r7, #4]
 802026a:	681b      	ldr	r3, [r3, #0]
 802026c:	f04f 22f0 	mov.w	r2, #4026593280	; 0xf000f000
 8020270:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
                    ((~(VADC_GLOBBOUND_BOUNDARY1_Msk))&(~(VADC_GLOBBOUND_BOUNDARY0_Msk)));
         
    HandlePtr->kDynamicDataPtr->StateType = ADCGLOB001_UNINITIALIZED;
 8020274:	687b      	ldr	r3, [r7, #4]
 8020276:	685b      	ldr	r3, [r3, #4]
 8020278:	f04f 0200 	mov.w	r2, #0
 802027c:	701a      	strb	r2, [r3, #0]
    Status = (uint32_t)DAVEApp_SUCCESS;
 802027e:	f04f 0300 	mov.w	r3, #0
 8020282:	60fb      	str	r3, [r7, #12]
      ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  
  return Status;
 8020284:	68fb      	ldr	r3, [r7, #12]
}
 8020286:	4618      	mov	r0, r3
 8020288:	f107 0714 	add.w	r7, r7, #20
 802028c:	46bd      	mov	sp, r7
 802028e:	bc80      	pop	{r7}
 8020290:	4770      	bx	lr
 8020292:	bf00      	nop

08020294 <ADCGLOB001_CLKRequestDisable>:

/**
 * This function disable the control of the module.
 */
status_t ADCGLOB001_CLKRequestDisable(const ADCGLOB001_HandleType * HandlePtr)
{
 8020294:	b480      	push	{r7}
 8020296:	b085      	sub	sp, #20
 8020298:	af00      	add	r7, sp, #0
 802029a:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 802029c:	f04f 0301 	mov.w	r3, #1
 80202a0:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80202a2:	687b      	ldr	r3, [r7, #4]
 80202a4:	685b      	ldr	r3, [r3, #4]
 80202a6:	781b      	ldrb	r3, [r3, #0]
 80202a8:	2b01      	cmp	r3, #1
 80202aa:	d10a      	bne.n	80202c2 <ADCGLOB001_CLKRequestDisable+0x2e>
    /* Bring the module in disabled state
    * Module Disable Request Bit
    * 0 : enable the module clock  
    * 1 : stop the module clock */
      
    SET_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_DISR_Pos);
 80202ac:	687b      	ldr	r3, [r7, #4]
 80202ae:	681b      	ldr	r3, [r3, #0]
 80202b0:	687a      	ldr	r2, [r7, #4]
 80202b2:	6812      	ldr	r2, [r2, #0]
 80202b4:	6812      	ldr	r2, [r2, #0]
 80202b6:	f042 0201 	orr.w	r2, r2, #1
 80202ba:	601a      	str	r2, [r3, #0]

    Status = (uint32_t)DAVEApp_SUCCESS;
 80202bc:	f04f 0300 	mov.w	r3, #0
 80202c0:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 80202c2:	68fb      	ldr	r3, [r7, #12]
}
 80202c4:	4618      	mov	r0, r3
 80202c6:	f107 0714 	add.w	r7, r7, #20
 80202ca:	46bd      	mov	sp, r7
 80202cc:	bc80      	pop	{r7}
 80202ce:	4770      	bx	lr

080202d0 <ADCGLOB001_CLKRequestEnable>:
/**
 * This function enable the control of the module.
 */
status_t ADCGLOB001_CLKRequestEnable(const ADCGLOB001_HandleType * HandlePtr)
{
 80202d0:	b480      	push	{r7}
 80202d2:	b085      	sub	sp, #20
 80202d4:	af00      	add	r7, sp, #0
 80202d6:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80202d8:	f04f 0301 	mov.w	r3, #1
 80202dc:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80202de:	687b      	ldr	r3, [r7, #4]
 80202e0:	685b      	ldr	r3, [r3, #4]
 80202e2:	781b      	ldrb	r3, [r3, #0]
 80202e4:	2b01      	cmp	r3, #1
 80202e6:	d10a      	bne.n	80202fe <ADCGLOB001_CLKRequestEnable+0x2e>
  {
    /* Bring the module out of disabled state */
      
    CLR_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_DISR_Pos);
 80202e8:	687b      	ldr	r3, [r7, #4]
 80202ea:	681b      	ldr	r3, [r3, #0]
 80202ec:	687a      	ldr	r2, [r7, #4]
 80202ee:	6812      	ldr	r2, [r2, #0]
 80202f0:	6812      	ldr	r2, [r2, #0]
 80202f2:	f022 0201 	bic.w	r2, r2, #1
 80202f6:	601a      	str	r2, [r3, #0]

    Status = (uint32_t)DAVEApp_SUCCESS;
 80202f8:	f04f 0300 	mov.w	r3, #0
 80202fc:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 80202fe:	68fb      	ldr	r3, [r7, #12]
}
 8020300:	4618      	mov	r0, r3
 8020302:	f107 0714 	add.w	r7, r7, #20
 8020306:	46bd      	mov	sp, r7
 8020308:	bc80      	pop	{r7}
 802030a:	4770      	bx	lr

0802030c <ADCGLOB001_SetStartUpCalibration>:
 */

status_t ADCGLOB001_SetStartUpCalibration(
    const ADCGLOB001_HandleType *HandlePtr
    )
{
 802030c:	b480      	push	{r7}
 802030e:	b085      	sub	sp, #20
 8020310:	af00      	add	r7, sp, #0
 8020312:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020314:	f04f 0301 	mov.w	r3, #1
 8020318:	60fb      	str	r3, [r7, #12]
  uint32_t  CalibrationStatus;

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 802031a:	687b      	ldr	r3, [r7, #4]
 802031c:	685b      	ldr	r3, [r3, #4]
 802031e:	781b      	ldrb	r3, [r3, #0]
 8020320:	2b01      	cmp	r3, #1
 8020322:	d116      	bne.n	8020352 <ADCGLOB001_SetStartUpCalibration+0x46>
  {
    /* Initiate Start-Up Calibration */
      
    SET_BIT( HandlePtr->kGlobalPtr->GLOBCFG, VADC_GLOBCFG_SUCAL_Pos);
 8020324:	687b      	ldr	r3, [r7, #4]
 8020326:	681b      	ldr	r3, [r3, #0]
 8020328:	687a      	ldr	r2, [r7, #4]
 802032a:	6812      	ldr	r2, [r2, #0]
 802032c:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 8020330:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8020334:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    
    /*Wait for calibration to be finished*/
    
    do{
        CalibrationStatus= (HandlePtr->kGlobalPtr->GLOBCFG & 0x80000000);
 8020338:	687b      	ldr	r3, [r7, #4]
 802033a:	681b      	ldr	r3, [r3, #0]
 802033c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8020340:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8020344:	60bb      	str	r3, [r7, #8]
    }while (CalibrationStatus!=(uint32_t)0);
 8020346:	68bb      	ldr	r3, [r7, #8]
 8020348:	2b00      	cmp	r3, #0
 802034a:	d1f5      	bne.n	8020338 <ADCGLOB001_SetStartUpCalibration+0x2c>
    Status = (uint32_t)DAVEApp_SUCCESS;
 802034c:	f04f 0300 	mov.w	r3, #0
 8020350:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020352:	68fb      	ldr	r3, [r7, #12]
}
 8020354:	4618      	mov	r0, r3
 8020356:	f107 0714 	add.w	r7, r7, #20
 802035a:	46bd      	mov	sp, r7
 802035c:	bc80      	pop	{r7}
 802035e:	4770      	bx	lr

08020360 <ADCGLOB001_StartUpCalibrationInit>:
/**
 * This function Initialise the calibration based based on GUI configuration.
 */
status_t ADCGLOB001_StartUpCalibrationInit(void)
{
 8020360:	b480      	push	{r7}
 8020362:	b083      	sub	sp, #12
 8020364:	af00      	add	r7, sp, #0
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020366:	f04f 0301 	mov.w	r3, #1
 802036a:	607b      	str	r3, [r7, #4]
  uint32_t  CalibrationStatus;
    
  FUNCTION_ENTRY(GID_ADCGLOB001,(uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if(ADCGLOB001_Handle0.kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED )
 802036c:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020370:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020374:	685b      	ldr	r3, [r3, #4]
 8020376:	781b      	ldrb	r3, [r3, #0]
 8020378:	2b01      	cmp	r3, #1
 802037a:	d126      	bne.n	80203ca <ADCGLOB001_StartUpCalibrationInit+0x6a>
  {
    /* Initialise Calibration */
        
      if(ADCGLOB001_Handle0.keStartCalib == (uint8_t)1)
 802037c:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020380:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020384:	7d9b      	ldrb	r3, [r3, #22]
 8020386:	2b01      	cmp	r3, #1
 8020388:	d11c      	bne.n	80203c4 <ADCGLOB001_StartUpCalibrationInit+0x64>
      {
          /* Initiate Start-Up Calibration */
          SET_BIT( 
 802038a:	f646 03b0 	movw	r3, #26800	; 0x68b0
 802038e:	f6c0 0302 	movt	r3, #2050	; 0x802
 8020392:	681a      	ldr	r2, [r3, #0]
 8020394:	f646 03b0 	movw	r3, #26800	; 0x68b0
 8020398:	f6c0 0302 	movt	r3, #2050	; 0x802
 802039c:	681b      	ldr	r3, [r3, #0]
 802039e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80203a2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80203a6:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
              VADC_GLOBCFG_SUCAL_Pos
              ); 
          /*Wait for calibration to be finished*/ 
          do{
              CalibrationStatus= \
                  (ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG & 0x80000000);
 80203aa:	f646 03b0 	movw	r3, #26800	; 0x68b0
 80203ae:	f6c0 0302 	movt	r3, #2050	; 0x802
 80203b2:	681b      	ldr	r3, [r3, #0]
 80203b4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
              ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG,
              VADC_GLOBCFG_SUCAL_Pos
              ); 
          /*Wait for calibration to be finished*/ 
          do{
              CalibrationStatus= \
 80203b8:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80203bc:	603b      	str	r3, [r7, #0]
                  (ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG & 0x80000000);
          }while (CalibrationStatus!=(uint32_t)0);
 80203be:	683b      	ldr	r3, [r7, #0]
 80203c0:	2b00      	cmp	r3, #0
 80203c2:	d1f2      	bne.n	80203aa <ADCGLOB001_StartUpCalibrationInit+0x4a>
      } 
      
    Status = (uint32_t)DAVEApp_SUCCESS; 
 80203c4:	f04f 0300 	mov.w	r3, #0
 80203c8:	607b      	str	r3, [r7, #4]
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  
  return Status;
 80203ca:	687b      	ldr	r3, [r7, #4]
}
 80203cc:	4618      	mov	r0, r3
 80203ce:	f107 070c 	add.w	r7, r7, #12
 80203d2:	46bd      	mov	sp, r7
 80203d4:	bc80      	pop	{r7}
 80203d6:	4770      	bx	lr

080203d8 <ADCGLOB001_EnableSleepModeControl>:
 * reaction to sleep mode.
 */
status_t ADCGLOB001_EnableSleepModeControl(
    const ADCGLOB001_HandleType * HandlePtr
    )
{
 80203d8:	b480      	push	{r7}
 80203da:	b085      	sub	sp, #20
 80203dc:	af00      	add	r7, sp, #0
 80203de:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80203e0:	f04f 0301 	mov.w	r3, #1
 80203e4:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80203e6:	687b      	ldr	r3, [r7, #4]
 80203e8:	685b      	ldr	r3, [r3, #4]
 80203ea:	781b      	ldrb	r3, [r3, #0]
 80203ec:	2b01      	cmp	r3, #1
 80203ee:	d10a      	bne.n	8020406 <ADCGLOB001_EnableSleepModeControl+0x2e>
  {
      /* Reset  Sleep Mode Enable Control bit*/
      CLR_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_EDIS_Pos);
 80203f0:	687b      	ldr	r3, [r7, #4]
 80203f2:	681b      	ldr	r3, [r3, #0]
 80203f4:	687a      	ldr	r2, [r7, #4]
 80203f6:	6812      	ldr	r2, [r2, #0]
 80203f8:	6812      	ldr	r2, [r2, #0]
 80203fa:	f022 0208 	bic.w	r2, r2, #8
 80203fe:	601a      	str	r2, [r3, #0]

    Status = (uint32_t)DAVEApp_SUCCESS;
 8020400:	f04f 0300 	mov.w	r3, #0
 8020404:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020406:	68fb      	ldr	r3, [r7, #12]
}
 8020408:	4618      	mov	r0, r3
 802040a:	f107 0714 	add.w	r7, r7, #20
 802040e:	46bd      	mov	sp, r7
 8020410:	bc80      	pop	{r7}
 8020412:	4770      	bx	lr

08020414 <ADCGLOB001_DisregardSleepModeControl>:
 * This function disregards Sleep Mode Control.
 */
status_t ADCGLOB001_DisregardSleepModeControl(
    const ADCGLOB001_HandleType * HandlePtr
    )
{
 8020414:	b480      	push	{r7}
 8020416:	b085      	sub	sp, #20
 8020418:	af00      	add	r7, sp, #0
 802041a:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 802041c:	f04f 0301 	mov.w	r3, #1
 8020420:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 8020422:	687b      	ldr	r3, [r7, #4]
 8020424:	685b      	ldr	r3, [r3, #4]
 8020426:	781b      	ldrb	r3, [r3, #0]
 8020428:	2b01      	cmp	r3, #1
 802042a:	d10a      	bne.n	8020442 <ADCGLOB001_DisregardSleepModeControl+0x2e>
  {
    /* set  Sleep Mode Enable Control bit*/
    SET_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_EDIS_Pos);
 802042c:	687b      	ldr	r3, [r7, #4]
 802042e:	681b      	ldr	r3, [r3, #0]
 8020430:	687a      	ldr	r2, [r7, #4]
 8020432:	6812      	ldr	r2, [r2, #0]
 8020434:	6812      	ldr	r2, [r2, #0]
 8020436:	f042 0208 	orr.w	r2, r2, #8
 802043a:	601a      	str	r2, [r3, #0]

    Status = (uint32_t)DAVEApp_SUCCESS;
 802043c:	f04f 0300 	mov.w	r3, #0
 8020440:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020442:	68fb      	ldr	r3, [r7, #12]
}
 8020444:	4618      	mov	r0, r3
 8020446:	f107 0714 	add.w	r7, r7, #20
 802044a:	46bd      	mov	sp, r7
 802044c:	bc80      	pop	{r7}
 802044e:	4770      	bx	lr

08020450 <ADCGLOB001_SetGlobClass0ConvMode>:
 */
status_t ADCGLOB001_SetGlobClass0ConvMode(
    const ADCGLOB001_HandleType * HandlePtr,
    ADCGLOB001_ConversionMode ConversionModeVal
    )
{
 8020450:	b480      	push	{r7}
 8020452:	b085      	sub	sp, #20
 8020454:	af00      	add	r7, sp, #0
 8020456:	6078      	str	r0, [r7, #4]
 8020458:	460b      	mov	r3, r1
 802045a:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 802045c:	f04f 0301 	mov.w	r3, #1
 8020460:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 8020462:	687b      	ldr	r3, [r7, #4]
 8020464:	685b      	ldr	r3, [r3, #4]
 8020466:	781b      	ldrb	r3, [r3, #0]
 8020468:	2b01      	cmp	r3, #1
 802046a:	d11c      	bne.n	80204a6 <ADCGLOB001_SetGlobClass0ConvMode+0x56>
  {
      if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) || 
 802046c:	78fb      	ldrb	r3, [r7, #3]
 802046e:	2b02      	cmp	r3, #2
 8020470:	d902      	bls.n	8020478 <ADCGLOB001_SetGlobClass0ConvMode+0x28>
 8020472:	78fb      	ldrb	r3, [r7, #3]
 8020474:	2b05      	cmp	r3, #5
 8020476:	d113      	bne.n	80204a0 <ADCGLOB001_SetGlobClass0ConvMode+0x50>
          (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) { 
        /* Set the global class0 conversion mode */
        WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
 8020478:	687b      	ldr	r3, [r7, #4]
 802047a:	681b      	ldr	r3, [r3, #0]
 802047c:	78fa      	ldrb	r2, [r7, #3]
 802047e:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8020482:	f402 61e0 	and.w	r1, r2, #1792	; 0x700
 8020486:	687a      	ldr	r2, [r7, #4]
 8020488:	6812      	ldr	r2, [r2, #0]
 802048a:	f8d2 20a0 	ldr.w	r2, [r2, #160]	; 0xa0
 802048e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8020492:	430a      	orrs	r2, r1
 8020494:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
                VADC_GLOBICLASS_CMS_Msk,
                VADC_GLOBICLASS_CMS_Pos,
                (uint32_t)ConversionModeVal
              );

        Status = (uint32_t)DAVEApp_SUCCESS;
 8020498:	f04f 0300 	mov.w	r3, #0
 802049c:	60fb      	str	r3, [r7, #12]
 802049e:	e002      	b.n	80204a6 <ADCGLOB001_SetGlobClass0ConvMode+0x56>
      } else {
        Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 80204a0:	f04f 0302 	mov.w	r3, #2
 80204a4:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 80204a6:	68fb      	ldr	r3, [r7, #12]
}
 80204a8:	4618      	mov	r0, r3
 80204aa:	f107 0714 	add.w	r7, r7, #20
 80204ae:	46bd      	mov	sp, r7
 80204b0:	bc80      	pop	{r7}
 80204b2:	4770      	bx	lr

080204b4 <ADCGLOB001_SetGlobClass0SampleTime>:

status_t ADCGLOB001_SetGlobClass0SampleTime(
    const ADCGLOB001_HandleType * HandlePtr,
    uint8_t SampleTime
    )
{
 80204b4:	b480      	push	{r7}
 80204b6:	b085      	sub	sp, #20
 80204b8:	af00      	add	r7, sp, #0
 80204ba:	6078      	str	r0, [r7, #4]
 80204bc:	460b      	mov	r3, r1
 80204be:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80204c0:	f04f 0301 	mov.w	r3, #1
 80204c4:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80204c6:	687b      	ldr	r3, [r7, #4]
 80204c8:	685b      	ldr	r3, [r3, #4]
 80204ca:	781b      	ldrb	r3, [r3, #0]
 80204cc:	2b01      	cmp	r3, #1
 80204ce:	d117      	bne.n	8020500 <ADCGLOB001_SetGlobClass0SampleTime+0x4c>
  {
    if(SampleTime < (uint8_t)32){ 
 80204d0:	78fb      	ldrb	r3, [r7, #3]
 80204d2:	2b1f      	cmp	r3, #31
 80204d4:	d811      	bhi.n	80204fa <ADCGLOB001_SetGlobClass0SampleTime+0x46>
      /* Set the global class0 Sample Time */
      WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
 80204d6:	687b      	ldr	r3, [r7, #4]
 80204d8:	681b      	ldr	r3, [r3, #0]
 80204da:	78fa      	ldrb	r2, [r7, #3]
 80204dc:	f002 011f 	and.w	r1, r2, #31
 80204e0:	687a      	ldr	r2, [r7, #4]
 80204e2:	6812      	ldr	r2, [r2, #0]
 80204e4:	f8d2 20a0 	ldr.w	r2, [r2, #160]	; 0xa0
 80204e8:	f022 021f 	bic.w	r2, r2, #31
 80204ec:	430a      	orrs	r2, r1
 80204ee:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
              VADC_GLOBICLASS_STCS_Msk,
              VADC_GLOBICLASS_STCS_Pos,
              (uint32_t)SampleTime
            );

      Status = (uint32_t)DAVEApp_SUCCESS;
 80204f2:	f04f 0300 	mov.w	r3, #0
 80204f6:	60fb      	str	r3, [r7, #12]
 80204f8:	e002      	b.n	8020500 <ADCGLOB001_SetGlobClass0SampleTime+0x4c>
    } else {
      Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 80204fa:	f04f 0302 	mov.w	r3, #2
 80204fe:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020500:	68fb      	ldr	r3, [r7, #12]

}
 8020502:	4618      	mov	r0, r3
 8020504:	f107 0714 	add.w	r7, r7, #20
 8020508:	46bd      	mov	sp, r7
 802050a:	bc80      	pop	{r7}
 802050c:	4770      	bx	lr
 802050e:	bf00      	nop

08020510 <ADCGLOB001_SetGlobClass0EmuxConvMode>:
 */
status_t ADCGLOB001_SetGlobClass0EmuxConvMode(
    const ADCGLOB001_HandleType * HandlePtr,
    ADCGLOB001_ConversionMode ConversionModeVal
    )
{
 8020510:	b480      	push	{r7}
 8020512:	b085      	sub	sp, #20
 8020514:	af00      	add	r7, sp, #0
 8020516:	6078      	str	r0, [r7, #4]
 8020518:	460b      	mov	r3, r1
 802051a:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 802051c:	f04f 0301 	mov.w	r3, #1
 8020520:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 8020522:	687b      	ldr	r3, [r7, #4]
 8020524:	685b      	ldr	r3, [r3, #4]
 8020526:	781b      	ldrb	r3, [r3, #0]
 8020528:	2b01      	cmp	r3, #1
 802052a:	d11c      	bne.n	8020566 <ADCGLOB001_SetGlobClass0EmuxConvMode+0x56>
  {  
    if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) || 
 802052c:	78fb      	ldrb	r3, [r7, #3]
 802052e:	2b02      	cmp	r3, #2
 8020530:	d902      	bls.n	8020538 <ADCGLOB001_SetGlobClass0EmuxConvMode+0x28>
 8020532:	78fb      	ldrb	r3, [r7, #3]
 8020534:	2b05      	cmp	r3, #5
 8020536:	d113      	bne.n	8020560 <ADCGLOB001_SetGlobClass0EmuxConvMode+0x50>
        (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) { 
      /* Set the global class0 External Multiplexer conversion mode*/
      WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
 8020538:	687b      	ldr	r3, [r7, #4]
 802053a:	681b      	ldr	r3, [r3, #0]
 802053c:	78fa      	ldrb	r2, [r7, #3]
 802053e:	ea4f 6202 	mov.w	r2, r2, lsl #24
 8020542:	f002 61e0 	and.w	r1, r2, #117440512	; 0x7000000
 8020546:	687a      	ldr	r2, [r7, #4]
 8020548:	6812      	ldr	r2, [r2, #0]
 802054a:	f8d2 20a0 	ldr.w	r2, [r2, #160]	; 0xa0
 802054e:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 8020552:	430a      	orrs	r2, r1
 8020554:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
              VADC_GLOBICLASS_CME_Msk,
              VADC_GLOBICLASS_CME_Pos,
              (uint32_t)ConversionModeVal
            );
      Status = (uint32_t)DAVEApp_SUCCESS;
 8020558:	f04f 0300 	mov.w	r3, #0
 802055c:	60fb      	str	r3, [r7, #12]
 802055e:	e002      	b.n	8020566 <ADCGLOB001_SetGlobClass0EmuxConvMode+0x56>
              
    } else {
      Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 8020560:	f04f 0302 	mov.w	r3, #2
 8020564:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020566:	68fb      	ldr	r3, [r7, #12]

}
 8020568:	4618      	mov	r0, r3
 802056a:	f107 0714 	add.w	r7, r7, #20
 802056e:	46bd      	mov	sp, r7
 8020570:	bc80      	pop	{r7}
 8020572:	4770      	bx	lr

08020574 <ADCGLOB001_SetGlobClass0EmuxSampleTime>:
 */
status_t ADCGLOB001_SetGlobClass0EmuxSampleTime(
    const ADCGLOB001_HandleType * HandlePtr,
    uint8_t SampleTime
    )
{
 8020574:	b480      	push	{r7}
 8020576:	b085      	sub	sp, #20
 8020578:	af00      	add	r7, sp, #0
 802057a:	6078      	str	r0, [r7, #4]
 802057c:	460b      	mov	r3, r1
 802057e:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020580:	f04f 0301 	mov.w	r3, #1
 8020584:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 8020586:	687b      	ldr	r3, [r7, #4]
 8020588:	685b      	ldr	r3, [r3, #4]
 802058a:	781b      	ldrb	r3, [r3, #0]
 802058c:	2b01      	cmp	r3, #1
 802058e:	d119      	bne.n	80205c4 <ADCGLOB001_SetGlobClass0EmuxSampleTime+0x50>
  {
    if(SampleTime < (uint8_t)32){
 8020590:	78fb      	ldrb	r3, [r7, #3]
 8020592:	2b1f      	cmp	r3, #31
 8020594:	d813      	bhi.n	80205be <ADCGLOB001_SetGlobClass0EmuxSampleTime+0x4a>
         
      /* Set the global class0 External Multiplexer Sample Time */
      WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
 8020596:	687b      	ldr	r3, [r7, #4]
 8020598:	681b      	ldr	r3, [r3, #0]
 802059a:	78fa      	ldrb	r2, [r7, #3]
 802059c:	ea4f 4202 	mov.w	r2, r2, lsl #16
 80205a0:	f402 11f8 	and.w	r1, r2, #2031616	; 0x1f0000
 80205a4:	687a      	ldr	r2, [r7, #4]
 80205a6:	6812      	ldr	r2, [r2, #0]
 80205a8:	f8d2 20a0 	ldr.w	r2, [r2, #160]	; 0xa0
 80205ac:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80205b0:	430a      	orrs	r2, r1
 80205b2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
              VADC_GLOBICLASS_STCE_Msk,
              VADC_GLOBICLASS_STCE_Pos,
              (uint32_t)SampleTime
             );

      Status = (uint32_t)DAVEApp_SUCCESS;
 80205b6:	f04f 0300 	mov.w	r3, #0
 80205ba:	60fb      	str	r3, [r7, #12]
 80205bc:	e002      	b.n	80205c4 <ADCGLOB001_SetGlobClass0EmuxSampleTime+0x50>
         
     } else {
         
       Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 80205be:	f04f 0302 	mov.w	r3, #2
 80205c2:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 80205c4:	68fb      	ldr	r3, [r7, #12]
}
 80205c6:	4618      	mov	r0, r3
 80205c8:	f107 0714 	add.w	r7, r7, #20
 80205cc:	46bd      	mov	sp, r7
 80205ce:	bc80      	pop	{r7}
 80205d0:	4770      	bx	lr
 80205d2:	bf00      	nop

080205d4 <ADCGLOB001_SetGlobClass1ConvMode>:
 */
status_t ADCGLOB001_SetGlobClass1ConvMode(
    const ADCGLOB001_HandleType * HandlePtr,
    ADCGLOB001_ConversionMode ConversionModeVal
    )
{
 80205d4:	b480      	push	{r7}
 80205d6:	b085      	sub	sp, #20
 80205d8:	af00      	add	r7, sp, #0
 80205da:	6078      	str	r0, [r7, #4]
 80205dc:	460b      	mov	r3, r1
 80205de:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80205e0:	f04f 0301 	mov.w	r3, #1
 80205e4:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80205e6:	687b      	ldr	r3, [r7, #4]
 80205e8:	685b      	ldr	r3, [r3, #4]
 80205ea:	781b      	ldrb	r3, [r3, #0]
 80205ec:	2b01      	cmp	r3, #1
 80205ee:	d11c      	bne.n	802062a <ADCGLOB001_SetGlobClass1ConvMode+0x56>
  {
      if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) ||
 80205f0:	78fb      	ldrb	r3, [r7, #3]
 80205f2:	2b02      	cmp	r3, #2
 80205f4:	d902      	bls.n	80205fc <ADCGLOB001_SetGlobClass1ConvMode+0x28>
 80205f6:	78fb      	ldrb	r3, [r7, #3]
 80205f8:	2b05      	cmp	r3, #5
 80205fa:	d113      	bne.n	8020624 <ADCGLOB001_SetGlobClass1ConvMode+0x50>
          (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) { 
      /* Set the global class 1 conversion mode */
       WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
 80205fc:	687b      	ldr	r3, [r7, #4]
 80205fe:	681b      	ldr	r3, [r3, #0]
 8020600:	78fa      	ldrb	r2, [r7, #3]
 8020602:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8020606:	f402 61e0 	and.w	r1, r2, #1792	; 0x700
 802060a:	687a      	ldr	r2, [r7, #4]
 802060c:	6812      	ldr	r2, [r2, #0]
 802060e:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
 8020612:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8020616:	430a      	orrs	r2, r1
 8020618:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
               VADC_GLOBICLASS_CMS_Msk,
               VADC_GLOBICLASS_CMS_Pos,
               (uint32_t)ConversionModeVal
             );

       Status = (uint32_t)DAVEApp_SUCCESS;
 802061c:	f04f 0300 	mov.w	r3, #0
 8020620:	60fb      	str	r3, [r7, #12]
 8020622:	e002      	b.n	802062a <ADCGLOB001_SetGlobClass1ConvMode+0x56>
              
          } else {
                   Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 8020624:	f04f 0302 	mov.w	r3, #2
 8020628:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 802062a:	68fb      	ldr	r3, [r7, #12]
}
 802062c:	4618      	mov	r0, r3
 802062e:	f107 0714 	add.w	r7, r7, #20
 8020632:	46bd      	mov	sp, r7
 8020634:	bc80      	pop	{r7}
 8020636:	4770      	bx	lr

08020638 <ADCGLOB001_SetGlobClass1SampleTime>:
 */
status_t ADCGLOB001_SetGlobClass1SampleTime(
    const ADCGLOB001_HandleType * HandlePtr,
    uint8_t SampleTime
    )
{
 8020638:	b480      	push	{r7}
 802063a:	b085      	sub	sp, #20
 802063c:	af00      	add	r7, sp, #0
 802063e:	6078      	str	r0, [r7, #4]
 8020640:	460b      	mov	r3, r1
 8020642:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020644:	f04f 0301 	mov.w	r3, #1
 8020648:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 802064a:	687b      	ldr	r3, [r7, #4]
 802064c:	685b      	ldr	r3, [r3, #4]
 802064e:	781b      	ldrb	r3, [r3, #0]
 8020650:	2b01      	cmp	r3, #1
 8020652:	d117      	bne.n	8020684 <ADCGLOB001_SetGlobClass1SampleTime+0x4c>
  {
      
      if(SampleTime < (uint8_t)32){
 8020654:	78fb      	ldrb	r3, [r7, #3]
 8020656:	2b1f      	cmp	r3, #31
 8020658:	d811      	bhi.n	802067e <ADCGLOB001_SetGlobClass1SampleTime+0x46>
        /* Write the global class 1 Sample Time */        
        WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
 802065a:	687b      	ldr	r3, [r7, #4]
 802065c:	681b      	ldr	r3, [r3, #0]
 802065e:	78fa      	ldrb	r2, [r7, #3]
 8020660:	f002 011f 	and.w	r1, r2, #31
 8020664:	687a      	ldr	r2, [r7, #4]
 8020666:	6812      	ldr	r2, [r2, #0]
 8020668:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
 802066c:	f022 021f 	bic.w	r2, r2, #31
 8020670:	430a      	orrs	r2, r1
 8020672:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                VADC_GLOBICLASS_STCS_Msk,
                VADC_GLOBICLASS_STCS_Pos,
                (uint32_t)SampleTime
              );
        
        Status = (uint32_t)DAVEApp_SUCCESS;      
 8020676:	f04f 0300 	mov.w	r3, #0
 802067a:	60fb      	str	r3, [r7, #12]
 802067c:	e002      	b.n	8020684 <ADCGLOB001_SetGlobClass1SampleTime+0x4c>
        
      } else {
          
        Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 802067e:	f04f 0302 	mov.w	r3, #2
 8020682:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020684:	68fb      	ldr	r3, [r7, #12]
}
 8020686:	4618      	mov	r0, r3
 8020688:	f107 0714 	add.w	r7, r7, #20
 802068c:	46bd      	mov	sp, r7
 802068e:	bc80      	pop	{r7}
 8020690:	4770      	bx	lr
 8020692:	bf00      	nop

08020694 <ADCGLOB001_SetGlobClass1EmuxConvMode>:
 */
status_t ADCGLOB001_SetGlobClass1EmuxConvMode(
    const ADCGLOB001_HandleType * HandlePtr,
    ADCGLOB001_ConversionMode ConversionModeVal
    )
{
 8020694:	b480      	push	{r7}
 8020696:	b085      	sub	sp, #20
 8020698:	af00      	add	r7, sp, #0
 802069a:	6078      	str	r0, [r7, #4]
 802069c:	460b      	mov	r3, r1
 802069e:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80206a0:	f04f 0301 	mov.w	r3, #1
 80206a4:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80206a6:	687b      	ldr	r3, [r7, #4]
 80206a8:	685b      	ldr	r3, [r3, #4]
 80206aa:	781b      	ldrb	r3, [r3, #0]
 80206ac:	2b01      	cmp	r3, #1
 80206ae:	d11c      	bne.n	80206ea <ADCGLOB001_SetGlobClass1EmuxConvMode+0x56>
  {
    if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) ||
 80206b0:	78fb      	ldrb	r3, [r7, #3]
 80206b2:	2b02      	cmp	r3, #2
 80206b4:	d902      	bls.n	80206bc <ADCGLOB001_SetGlobClass1EmuxConvMode+0x28>
 80206b6:	78fb      	ldrb	r3, [r7, #3]
 80206b8:	2b05      	cmp	r3, #5
 80206ba:	d113      	bne.n	80206e4 <ADCGLOB001_SetGlobClass1EmuxConvMode+0x50>
        (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) { 
        /* Write the global class1 External Multiplexer conversion mode */
              
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
 80206bc:	687b      	ldr	r3, [r7, #4]
 80206be:	681b      	ldr	r3, [r3, #0]
 80206c0:	78fa      	ldrb	r2, [r7, #3]
 80206c2:	ea4f 6202 	mov.w	r2, r2, lsl #24
 80206c6:	f002 61e0 	and.w	r1, r2, #117440512	; 0x7000000
 80206ca:	687a      	ldr	r2, [r7, #4]
 80206cc:	6812      	ldr	r2, [r2, #0]
 80206ce:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
 80206d2:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 80206d6:	430a      	orrs	r2, r1
 80206d8:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                    VADC_GLOBICLASS_CME_Msk,
                    VADC_GLOBICLASS_CME_Pos,
                    (uint32_t)ConversionModeVal
                  );
            Status = (uint32_t)DAVEApp_SUCCESS;
 80206dc:	f04f 0300 	mov.w	r3, #0
 80206e0:	60fb      	str	r3, [r7, #12]
 80206e2:	e002      	b.n	80206ea <ADCGLOB001_SetGlobClass1EmuxConvMode+0x56>
     } else {
                Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 80206e4:	f04f 0302 	mov.w	r3, #2
 80206e8:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 80206ea:	68fb      	ldr	r3, [r7, #12]
}
 80206ec:	4618      	mov	r0, r3
 80206ee:	f107 0714 	add.w	r7, r7, #20
 80206f2:	46bd      	mov	sp, r7
 80206f4:	bc80      	pop	{r7}
 80206f6:	4770      	bx	lr

080206f8 <ADCGLOB001_SetGlobClass1EmuxSampleTime>:
 */
status_t ADCGLOB001_SetGlobClass1EmuxSampleTime(
    const ADCGLOB001_HandleType * HandlePtr,
    uint8_t SampleTime
    )
{
 80206f8:	b480      	push	{r7}
 80206fa:	b085      	sub	sp, #20
 80206fc:	af00      	add	r7, sp, #0
 80206fe:	6078      	str	r0, [r7, #4]
 8020700:	460b      	mov	r3, r1
 8020702:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020704:	f04f 0301 	mov.w	r3, #1
 8020708:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 802070a:	687b      	ldr	r3, [r7, #4]
 802070c:	685b      	ldr	r3, [r3, #4]
 802070e:	781b      	ldrb	r3, [r3, #0]
 8020710:	2b01      	cmp	r3, #1
 8020712:	d119      	bne.n	8020748 <ADCGLOB001_SetGlobClass1EmuxSampleTime+0x50>
  {      
      if(SampleTime < (uint8_t)32){
 8020714:	78fb      	ldrb	r3, [r7, #3]
 8020716:	2b1f      	cmp	r3, #31
 8020718:	d813      	bhi.n	8020742 <ADCGLOB001_SetGlobClass1EmuxSampleTime+0x4a>
        /* Write the global class1 External Multiplexer Sample Time */
        WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
 802071a:	687b      	ldr	r3, [r7, #4]
 802071c:	681b      	ldr	r3, [r3, #0]
 802071e:	78fa      	ldrb	r2, [r7, #3]
 8020720:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8020724:	f402 11f8 	and.w	r1, r2, #2031616	; 0x1f0000
 8020728:	687a      	ldr	r2, [r7, #4]
 802072a:	6812      	ldr	r2, [r2, #0]
 802072c:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
 8020730:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8020734:	430a      	orrs	r2, r1
 8020736:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                VADC_GLOBICLASS_STCE_Msk,
                VADC_GLOBICLASS_STCE_Pos,
                (uint32_t)SampleTime
              );
        Status = (uint32_t)DAVEApp_SUCCESS;
 802073a:	f04f 0300 	mov.w	r3, #0
 802073e:	60fb      	str	r3, [r7, #12]
 8020740:	e002      	b.n	8020748 <ADCGLOB001_SetGlobClass1EmuxSampleTime+0x50>
         
      } else {
        
        Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 8020742:	f04f 0302 	mov.w	r3, #2
 8020746:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020748:	68fb      	ldr	r3, [r7, #12]
}
 802074a:	4618      	mov	r0, r3
 802074c:	f107 0714 	add.w	r7, r7, #20
 8020750:	46bd      	mov	sp, r7
 8020752:	bc80      	pop	{r7}
 8020754:	4770      	bx	lr
 8020756:	bf00      	nop

08020758 <ADCGLOB001_GetDisableBitStatus>:
 */
status_t ADCGLOB001_GetDisableBitStatus(
    const ADCGLOB001_HandleType * HandlePtr,
    uint8_t *StatusValue
    )
{
 8020758:	b480      	push	{r7}
 802075a:	b085      	sub	sp, #20
 802075c:	af00      	add	r7, sp, #0
 802075e:	6078      	str	r0, [r7, #4]
 8020760:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020762:	f04f 0301 	mov.w	r3, #1
 8020766:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 8020768:	687b      	ldr	r3, [r7, #4]
 802076a:	685b      	ldr	r3, [r3, #4]
 802076c:	781b      	ldrb	r3, [r3, #0]
 802076e:	2b01      	cmp	r3, #1
 8020770:	d10c      	bne.n	802078c <ADCGLOB001_GetDisableBitStatus+0x34>
  {
      /*Read the status value */
      
      *StatusValue = (uint8_t) RD_REG( HandlePtr->kGlobalPtr->CLC,
 8020772:	687b      	ldr	r3, [r7, #4]
 8020774:	681b      	ldr	r3, [r3, #0]
 8020776:	681b      	ldr	r3, [r3, #0]
 8020778:	f003 0302 	and.w	r3, r3, #2
 802077c:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8020780:	b2da      	uxtb	r2, r3
 8020782:	683b      	ldr	r3, [r7, #0]
 8020784:	701a      	strb	r2, [r3, #0]
                                       VADC_CLC_DISS_Msk,
                                       VADC_CLC_DISS_Pos
                                     );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020786:	f04f 0300 	mov.w	r3, #0
 802078a:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 802078c:	68fb      	ldr	r3, [r7, #12]
}
 802078e:	4618      	mov	r0, r3
 8020790:	f107 0714 	add.w	r7, r7, #20
 8020794:	46bd      	mov	sp, r7
 8020796:	bc80      	pop	{r7}
 8020798:	4770      	bx	lr
 802079a:	bf00      	nop

0802079c <ADCGLOB001_GetIdValue>:

status_t ADCGLOB001_GetIdValue(
    const ADCGLOB001_HandleType * HandlePtr,
    uint32_t *IDValue
    )
{
 802079c:	b480      	push	{r7}
 802079e:	b085      	sub	sp, #20
 80207a0:	af00      	add	r7, sp, #0
 80207a2:	6078      	str	r0, [r7, #4]
 80207a4:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80207a6:	f04f 0301 	mov.w	r3, #1
 80207aa:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80207ac:	687b      	ldr	r3, [r7, #4]
 80207ae:	685b      	ldr	r3, [r3, #4]
 80207b0:	781b      	ldrb	r3, [r3, #0]
 80207b2:	2b01      	cmp	r3, #1
 80207b4:	d107      	bne.n	80207c6 <ADCGLOB001_GetIdValue+0x2a>
  {
    /*Read the ID value */
    *IDValue =(uint32_t)HandlePtr->kGlobalPtr->ID;     
 80207b6:	687b      	ldr	r3, [r7, #4]
 80207b8:	681b      	ldr	r3, [r3, #0]
 80207ba:	689a      	ldr	r2, [r3, #8]
 80207bc:	683b      	ldr	r3, [r7, #0]
 80207be:	601a      	str	r2, [r3, #0]
    
    Status = (uint32_t)DAVEApp_SUCCESS;
 80207c0:	f04f 0300 	mov.w	r3, #0
 80207c4:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 80207c6:	68fb      	ldr	r3, [r7, #12]
}
 80207c8:	4618      	mov	r0, r3
 80207ca:	f107 0714 	add.w	r7, r7, #20
 80207ce:	46bd      	mov	sp, r7
 80207d0:	bc80      	pop	{r7}
 80207d2:	4770      	bx	lr

080207d4 <ADCGLOB001_GTFRConvtrDiagnoGrp>:
 */

status_t ADCGLOB001_GTFRConvtrDiagnoGrp(const ADCGLOB001_HandleType * HandlePtr,
    uint8_t GroupValue
    )
{
 80207d4:	b480      	push	{r7}
 80207d6:	b085      	sub	sp, #20
 80207d8:	af00      	add	r7, sp, #0
 80207da:	6078      	str	r0, [r7, #4]
 80207dc:	460b      	mov	r3, r1
 80207de:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80207e0:	f04f 0301 	mov.w	r3, #1
 80207e4:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80207e6:	687b      	ldr	r3, [r7, #4]
 80207e8:	685b      	ldr	r3, [r3, #4]
 80207ea:	781b      	ldrb	r3, [r3, #0]
 80207ec:	2b01      	cmp	r3, #1
 80207ee:	d130      	bne.n	8020852 <ADCGLOB001_GTFRConvtrDiagnoGrp+0x7e>
  {      
    if(GroupValue < (uint8_t)16){
 80207f0:	78fb      	ldrb	r3, [r7, #3]
 80207f2:	2b0f      	cmp	r3, #15
 80207f4:	d82a      	bhi.n	802084c <ADCGLOB001_GTFRConvtrDiagnoGrp+0x78>
      /*clear the group number.*/  
      HandlePtr->kGlobalPtr->GLOBTF = (VADC_GLOBTF_CDWC_Msk|
 80207f6:	687b      	ldr	r3, [r7, #4]
 80207f8:	681a      	ldr	r2, [r3, #0]
              ((HandlePtr->kGlobalPtr->GLOBTF)& (~(VADC_GLOBTF_CDGR_Msk))));
 80207fa:	687b      	ldr	r3, [r7, #4]
 80207fc:	681b      	ldr	r3, [r3, #0]
 80207fe:	f8d3 3160 	ldr.w	r3, [r3, #352]	; 0x160

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
  {      
    if(GroupValue < (uint8_t)16){
      /*clear the group number.*/  
      HandlePtr->kGlobalPtr->GLOBTF = (VADC_GLOBTF_CDWC_Msk|
 8020802:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8020806:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802080a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 802080e:	f8c2 3160 	str.w	r3, [r2, #352]	; 0x160
              ((HandlePtr->kGlobalPtr->GLOBTF)& (~(VADC_GLOBTF_CDGR_Msk))));
      /*Write the group number to be used for converter diagnostics conversions.*/ 
      HandlePtr->kGlobalPtr->GLOBTF |= (VADC_GLOBTF_CDWC_Msk |
 8020812:	687b      	ldr	r3, [r7, #4]
 8020814:	681b      	ldr	r3, [r3, #0]
 8020816:	687a      	ldr	r2, [r7, #4]
 8020818:	6812      	ldr	r2, [r2, #0]
 802081a:	f8d2 1160 	ldr.w	r1, [r2, #352]	; 0x160
              (((uint32_t)GroupValue << VADC_GLOBTF_CDGR_Pos) & VADC_GLOBTF_CDGR_Msk));
 802081e:	78fa      	ldrb	r2, [r7, #3]
 8020820:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8020824:	b2d2      	uxtb	r2, r2
    if(GroupValue < (uint8_t)16){
      /*clear the group number.*/  
      HandlePtr->kGlobalPtr->GLOBTF = (VADC_GLOBTF_CDWC_Msk|
              ((HandlePtr->kGlobalPtr->GLOBTF)& (~(VADC_GLOBTF_CDGR_Msk))));
      /*Write the group number to be used for converter diagnostics conversions.*/ 
      HandlePtr->kGlobalPtr->GLOBTF |= (VADC_GLOBTF_CDWC_Msk |
 8020826:	430a      	orrs	r2, r1
 8020828:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802082c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
              (((uint32_t)GroupValue << VADC_GLOBTF_CDGR_Pos) & VADC_GLOBTF_CDGR_Msk));
            
      /*Clear the Write Control for Conversion Diagnostics*/   
      CLR_BIT(HandlePtr->kGlobalPtr->GLOBTF, VADC_GLOBTF_CDWC_Pos);        
 8020830:	687b      	ldr	r3, [r7, #4]
 8020832:	681b      	ldr	r3, [r3, #0]
 8020834:	687a      	ldr	r2, [r7, #4]
 8020836:	6812      	ldr	r2, [r2, #0]
 8020838:	f8d2 2160 	ldr.w	r2, [r2, #352]	; 0x160
 802083c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8020840:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
      Status = (uint32_t)DAVEApp_SUCCESS;             
 8020844:	f04f 0300 	mov.w	r3, #0
 8020848:	60fb      	str	r3, [r7, #12]
 802084a:	e002      	b.n	8020852 <ADCGLOB001_GTFRConvtrDiagnoGrp+0x7e>
    } else {      
      Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 802084c:	f04f 0302 	mov.w	r3, #2
 8020850:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020852:	68fb      	ldr	r3, [r7, #12]
}
 8020854:	4618      	mov	r0, r3
 8020856:	f107 0714 	add.w	r7, r7, #20
 802085a:	46bd      	mov	sp, r7
 802085c:	bc80      	pop	{r7}
 802085e:	4770      	bx	lr

08020860 <ADCGLOB001_GTFRConvtrDiagnoEnable>:
 * selected by bitfield CDSEL.
 */
status_t ADCGLOB001_GTFRConvtrDiagnoEnable(
    const ADCGLOB001_HandleType * HandlePtr
    )
{
 8020860:	b480      	push	{r7}
 8020862:	b085      	sub	sp, #20
 8020864:	af00      	add	r7, sp, #0
 8020866:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020868:	f04f 0301 	mov.w	r3, #1
 802086c:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 802086e:	687b      	ldr	r3, [r7, #4]
 8020870:	685b      	ldr	r3, [r3, #4]
 8020872:	781b      	ldrb	r3, [r3, #0]
 8020874:	2b01      	cmp	r3, #1
 8020876:	d116      	bne.n	80208a6 <ADCGLOB001_GTFRConvtrDiagnoEnable+0x46>
  {
    /*Enable the Converter Diagnostics*/
    HandlePtr->kGlobalPtr->GLOBTF |= 
 8020878:	687b      	ldr	r3, [r7, #4]
 802087a:	681b      	ldr	r3, [r3, #0]
 802087c:	687a      	ldr	r2, [r7, #4]
 802087e:	6812      	ldr	r2, [r2, #0]
 8020880:	f8d2 2160 	ldr.w	r2, [r2, #352]	; 0x160
 8020884:	f442 4201 	orr.w	r2, r2, #33024	; 0x8100
 8020888:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
        (VADC_GLOBTF_CDWC_Msk | VADC_GLOBTF_CDEN_Msk);
    /*Clear the Write Control for Conversion Diagnostics*/   
    CLR_BIT(HandlePtr->kGlobalPtr->GLOBTF, VADC_GLOBTF_CDWC_Pos);      
 802088c:	687b      	ldr	r3, [r7, #4]
 802088e:	681b      	ldr	r3, [r3, #0]
 8020890:	687a      	ldr	r2, [r7, #4]
 8020892:	6812      	ldr	r2, [r2, #0]
 8020894:	f8d2 2160 	ldr.w	r2, [r2, #352]	; 0x160
 8020898:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802089c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    Status = (uint32_t)DAVEApp_SUCCESS;
 80208a0:	f04f 0300 	mov.w	r3, #0
 80208a4:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 80208a6:	68fb      	ldr	r3, [r7, #12]
}
 80208a8:	4618      	mov	r0, r3
 80208aa:	f107 0714 	add.w	r7, r7, #20
 80208ae:	46bd      	mov	sp, r7
 80208b0:	bc80      	pop	{r7}
 80208b2:	4770      	bx	lr

080208b4 <ADCGLOB001_GTFRConvtrDiagnoPullDevicesSelect>:
 */
status_t ADCGLOB001_GTFRConvtrDiagnoPullDevicesSelect(
    const ADCGLOB001_HandleType * HandlePtr,
    uint8_t SelectValue
    )
{
 80208b4:	b480      	push	{r7}
 80208b6:	b085      	sub	sp, #20
 80208b8:	af00      	add	r7, sp, #0
 80208ba:	6078      	str	r0, [r7, #4]
 80208bc:	460b      	mov	r3, r1
 80208be:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 80208c0:	f04f 0301 	mov.w	r3, #1
 80208c4:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 80208c6:	687b      	ldr	r3, [r7, #4]
 80208c8:	685b      	ldr	r3, [r3, #4]
 80208ca:	781b      	ldrb	r3, [r3, #0]
 80208cc:	2b01      	cmp	r3, #1
 80208ce:	d12f      	bne.n	8020930 <ADCGLOB001_GTFRConvtrDiagnoPullDevicesSelect+0x7c>
  {
    if(SelectValue < (uint8_t)4){
 80208d0:	78fb      	ldrb	r3, [r7, #3]
 80208d2:	2b03      	cmp	r3, #3
 80208d4:	d829      	bhi.n	802092a <ADCGLOB001_GTFRConvtrDiagnoPullDevicesSelect+0x76>
      /*Clear Converter Diagnostics Pull-Devices Select value  */  
       HandlePtr->kGlobalPtr->GLOBTF = (VADC_GLOBTF_CDWC_Msk|
 80208d6:	687b      	ldr	r3, [r7, #4]
 80208d8:	681b      	ldr	r3, [r3, #0]
               ((HandlePtr->kGlobalPtr->GLOBTF)& (~(VADC_GLOBTF_CDSEL_Msk))));
 80208da:	687a      	ldr	r2, [r7, #4]
 80208dc:	6812      	ldr	r2, [r2, #0]
 80208de:	f8d2 2160 	ldr.w	r2, [r2, #352]	; 0x160

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
  {
    if(SelectValue < (uint8_t)4){
      /*Clear Converter Diagnostics Pull-Devices Select value  */  
       HandlePtr->kGlobalPtr->GLOBTF = (VADC_GLOBTF_CDWC_Msk|
 80208e2:	f422 4206 	bic.w	r2, r2, #34304	; 0x8600
 80208e6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80208ea:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
               ((HandlePtr->kGlobalPtr->GLOBTF)& (~(VADC_GLOBTF_CDSEL_Msk))));
              
      /* Write the Converter Diagnostics Pull-Devices Select value */
       HandlePtr->kGlobalPtr->GLOBTF |= (VADC_GLOBTF_CDWC_Msk |
 80208ee:	687b      	ldr	r3, [r7, #4]
 80208f0:	681b      	ldr	r3, [r3, #0]
 80208f2:	687a      	ldr	r2, [r7, #4]
 80208f4:	6812      	ldr	r2, [r2, #0]
 80208f6:	f8d2 1160 	ldr.w	r1, [r2, #352]	; 0x160
               (((uint32_t)SelectValue << VADC_GLOBTF_CDSEL_Pos) & VADC_GLOBTF_CDSEL_Msk));
 80208fa:	78fa      	ldrb	r2, [r7, #3]
 80208fc:	ea4f 2242 	mov.w	r2, r2, lsl #9
 8020900:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
      /*Clear Converter Diagnostics Pull-Devices Select value  */  
       HandlePtr->kGlobalPtr->GLOBTF = (VADC_GLOBTF_CDWC_Msk|
               ((HandlePtr->kGlobalPtr->GLOBTF)& (~(VADC_GLOBTF_CDSEL_Msk))));
              
      /* Write the Converter Diagnostics Pull-Devices Select value */
       HandlePtr->kGlobalPtr->GLOBTF |= (VADC_GLOBTF_CDWC_Msk |
 8020904:	430a      	orrs	r2, r1
 8020906:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802090a:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
               (((uint32_t)SelectValue << VADC_GLOBTF_CDSEL_Pos) & VADC_GLOBTF_CDSEL_Msk));
      /*Clear the Write Control for Conversion Diagnostics*/    
       
       CLR_BIT(HandlePtr->kGlobalPtr->GLOBTF, VADC_GLOBTF_CDWC_Pos);    
 802090e:	687b      	ldr	r3, [r7, #4]
 8020910:	681b      	ldr	r3, [r3, #0]
 8020912:	687a      	ldr	r2, [r7, #4]
 8020914:	6812      	ldr	r2, [r2, #0]
 8020916:	f8d2 2160 	ldr.w	r2, [r2, #352]	; 0x160
 802091a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802091e:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
       Status = (uint32_t)DAVEApp_SUCCESS;    
 8020922:	f04f 0300 	mov.w	r3, #0
 8020926:	60fb      	str	r3, [r7, #12]
 8020928:	e002      	b.n	8020930 <ADCGLOB001_GTFRConvtrDiagnoPullDevicesSelect+0x7c>
     } else {          
        Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
 802092a:	f04f 0302 	mov.w	r3, #2
 802092e:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020930:	68fb      	ldr	r3, [r7, #12]
}
 8020932:	4618      	mov	r0, r3
 8020934:	f107 0714 	add.w	r7, r7, #20
 8020938:	46bd      	mov	sp, r7
 802093a:	bc80      	pop	{r7}
 802093c:	4770      	bx	lr
 802093e:	bf00      	nop

08020940 <ADCGLOB001_GTFRPullDwnDiagnoEnable>:
 * This function configure the Pull-Down Diagnostics Enable register.
 */
status_t ADCGLOB001_GTFRPullDwnDiagnoEnable(
    const ADCGLOB001_HandleType * HandlePtr
    )
{
 8020940:	b480      	push	{r7}
 8020942:	b085      	sub	sp, #20
 8020944:	af00      	add	r7, sp, #0
 8020946:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;
 8020948:	f04f 0301 	mov.w	r3, #1
 802094c:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_ENTRY);

  if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
 802094e:	687b      	ldr	r3, [r7, #4]
 8020950:	685b      	ldr	r3, [r3, #4]
 8020952:	781b      	ldrb	r3, [r3, #0]
 8020954:	2b01      	cmp	r3, #1
 8020956:	d116      	bne.n	8020986 <ADCGLOB001_GTFRPullDwnDiagnoEnable+0x46>
  { 
   /*Enable the Pull-Down Diagnostics */  
    HandlePtr->kGlobalPtr->GLOBTF |=
 8020958:	687b      	ldr	r3, [r7, #4]
 802095a:	681b      	ldr	r3, [r3, #0]
 802095c:	687a      	ldr	r2, [r7, #4]
 802095e:	6812      	ldr	r2, [r2, #0]
 8020960:	f8d2 2160 	ldr.w	r2, [r2, #352]	; 0x160
 8020964:	f442 0201 	orr.w	r2, r2, #8454144	; 0x810000
 8020968:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
        (VADC_GLOBTF_MDWC_Msk | VADC_GLOBTF_PDD_Msk);
    /*Clear the Write Control for Multiplexer Diagnostics*/  
    CLR_BIT(HandlePtr->kGlobalPtr->GLOBTF, VADC_GLOBTF_MDWC_Pos);    
 802096c:	687b      	ldr	r3, [r7, #4]
 802096e:	681b      	ldr	r3, [r3, #0]
 8020970:	687a      	ldr	r2, [r7, #4]
 8020972:	6812      	ldr	r2, [r2, #0]
 8020974:	f8d2 2160 	ldr.w	r2, [r2, #352]	; 0x160
 8020978:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 802097c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020980:	f04f 0300 	mov.w	r3, #0
 8020984:	60fb      	str	r3, [r7, #12]
  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
    ERROR(GID_ADCGLOB001, (uint8_t)Status, 0, NULL);
  }
  FUNCTION_EXIT(GID_ADCGLOB001, (uint32_t)ADCGLOB001_FUNCTION_EXIT);
  return Status;
 8020986:	68fb      	ldr	r3, [r7, #12]
}
 8020988:	4618      	mov	r0, r3
 802098a:	f107 0714 	add.w	r7, r7, #20
 802098e:	46bd      	mov	sp, r7
 8020990:	bc80      	pop	{r7}
 8020992:	4770      	bx	lr

08020994 <ADCCH001_lInit>:
 **********************************************************************************/
/**
 * This function initializes ADC channel and result registers as per UI configurations. 
 */
static void ADCCH001_lInit(const ADCCH001_HandleType* HandlePtr)
{
 8020994:	b480      	push	{r7}
 8020996:	b085      	sub	sp, #20
 8020998:	af00      	add	r7, sp, #0
 802099a:	6078      	str	r0, [r7, #4]
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
 802099c:	687b      	ldr	r3, [r7, #4]
 802099e:	681b      	ldr	r3, [r3, #0]
 80209a0:	60bb      	str	r3, [r7, #8]
  uint8_t Index = (uint8_t)0;
 80209a2:	f04f 0300 	mov.w	r3, #0
 80209a6:	73fb      	strb	r3, [r7, #15]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCCH001_UNINITIALIZED))
 80209a8:	687b      	ldr	r3, [r7, #4]
 80209aa:	685b      	ldr	r3, [r3, #4]
 80209ac:	78db      	ldrb	r3, [r3, #3]
 80209ae:	2b00      	cmp	r3, #0
 80209b0:	f040 8158 	bne.w	8020c64 <ADCCH001_lInit+0x2d0>
  {
    /* Priority Channel */
    WR_REG( GroupPtr->CHASS, 
 80209b4:	687b      	ldr	r3, [r7, #4]
 80209b6:	7a1b      	ldrb	r3, [r3, #8]
 80209b8:	461a      	mov	r2, r3
 80209ba:	687b      	ldr	r3, [r7, #4]
 80209bc:	7d9b      	ldrb	r3, [r3, #22]
 80209be:	fa02 f203 	lsl.w	r2, r2, r3
 80209c2:	687b      	ldr	r3, [r7, #4]
 80209c4:	7d9b      	ldrb	r3, [r3, #22]
 80209c6:	f04f 0101 	mov.w	r1, #1
 80209ca:	fa01 f303 	lsl.w	r3, r1, r3
 80209ce:	401a      	ands	r2, r3
 80209d0:	68bb      	ldr	r3, [r7, #8]
 80209d2:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 80209d6:	687b      	ldr	r3, [r7, #4]
 80209d8:	7d9b      	ldrb	r3, [r3, #22]
 80209da:	f04f 0001 	mov.w	r0, #1
 80209de:	fa00 f303 	lsl.w	r3, r0, r3
 80209e2:	ea6f 0303 	mvn.w	r3, r3
 80209e6:	400b      	ands	r3, r1
 80209e8:	431a      	orrs	r2, r3
 80209ea:	68bb      	ldr	r3, [r7, #8]
 80209ec:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            ((uint32_t)0x01 << HandlePtr->kChannelNo),
            HandlePtr->kChannelNo,
            (uint32_t)HandlePtr->kPrioChannel
           );    
    /* Input class */
    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
 80209f0:	687b      	ldr	r3, [r7, #4]
 80209f2:	7d9b      	ldrb	r3, [r3, #22]
 80209f4:	461a      	mov	r2, r3
 80209f6:	687b      	ldr	r3, [r7, #4]
 80209f8:	7a5b      	ldrb	r3, [r3, #9]
 80209fa:	f003 0103 	and.w	r1, r3, #3
 80209fe:	687b      	ldr	r3, [r7, #4]
 8020a00:	7d9b      	ldrb	r3, [r3, #22]
 8020a02:	4618      	mov	r0, r3
 8020a04:	68bb      	ldr	r3, [r7, #8]
 8020a06:	f100 0080 	add.w	r0, r0, #128	; 0x80
 8020a0a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020a0e:	f023 0303 	bic.w	r3, r3, #3
 8020a12:	4319      	orrs	r1, r3
 8020a14:	68bb      	ldr	r3, [r7, #8]
 8020a16:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020a1a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_ICLSEL_Msk,
            VADC_G_CHCTR_ICLSEL_Pos,
            (uint32_t)HandlePtr->kIpClassSel
           );
    /* Channel event mode */
    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
 8020a1e:	687b      	ldr	r3, [r7, #4]
 8020a20:	7d9b      	ldrb	r3, [r3, #22]
 8020a22:	461a      	mov	r2, r3
 8020a24:	687b      	ldr	r3, [r7, #4]
 8020a26:	7adb      	ldrb	r3, [r3, #11]
 8020a28:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8020a2c:	f403 7140 	and.w	r1, r3, #768	; 0x300
 8020a30:	687b      	ldr	r3, [r7, #4]
 8020a32:	7d9b      	ldrb	r3, [r3, #22]
 8020a34:	4618      	mov	r0, r3
 8020a36:	68bb      	ldr	r3, [r7, #8]
 8020a38:	f100 0080 	add.w	r0, r0, #128	; 0x80
 8020a3c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020a40:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8020a44:	4319      	orrs	r1, r3
 8020a46:	68bb      	ldr	r3, [r7, #8]
 8020a48:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020a4c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_CHEVMODE_Msk,
            VADC_G_CHCTR_CHEVMODE_Pos,
            (uint32_t)HandlePtr->kChEvtmode
           );    
    /* reference input selection */
    WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
 8020a50:	687b      	ldr	r3, [r7, #4]
 8020a52:	7d9b      	ldrb	r3, [r3, #22]
 8020a54:	461a      	mov	r2, r3
 8020a56:	687b      	ldr	r3, [r7, #4]
 8020a58:	7b1b      	ldrb	r3, [r3, #12]
 8020a5a:	ea4f 23c3 	mov.w	r3, r3, lsl #11
 8020a5e:	f403 6100 	and.w	r1, r3, #2048	; 0x800
 8020a62:	687b      	ldr	r3, [r7, #4]
 8020a64:	7d9b      	ldrb	r3, [r3, #22]
 8020a66:	4618      	mov	r0, r3
 8020a68:	68bb      	ldr	r3, [r7, #8]
 8020a6a:	f100 0080 	add.w	r0, r0, #128	; 0x80
 8020a6e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020a72:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8020a76:	4319      	orrs	r1, r3
 8020a78:	68bb      	ldr	r3, [r7, #8]
 8020a7a:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020a7e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_REFSEL_Msk,
            VADC_G_CHCTR_REFSEL_Pos,
            (uint32_t)HandlePtr->kRefInput
           );
    /* XMC4500: EMUXCSS is not present.  */
    if(HandlePtr->kExtMuxControl == (uint8_t)1)
 8020a82:	687b      	ldr	r3, [r7, #4]
 8020a84:	7d5b      	ldrb	r3, [r3, #21]
 8020a86:	2b01      	cmp	r3, #1
 8020a88:	d10e      	bne.n	8020aa8 <ADCCH001_lInit+0x114>
      /*WR_REG( GroupPtr->EMUXCTR,
              VADC_G_EMUXCTR_EMXCSS_Msk,
              VADC_G_EMUXCTR_EMXCSS_Pos,
              (0x01)
             );     */
      WR_REG( GroupPtr->EMUXCTR,
 8020a8a:	687b      	ldr	r3, [r7, #4]
 8020a8c:	7d9b      	ldrb	r3, [r3, #22]
 8020a8e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8020a92:	f403 12f8 	and.w	r2, r3, #2031616	; 0x1f0000
 8020a96:	68bb      	ldr	r3, [r7, #8]
 8020a98:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 8020a9c:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8020aa0:	431a      	orrs	r2, r3
 8020aa2:	68bb      	ldr	r3, [r7, #8]
 8020aa4:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
              VADC_G_EMUXCTR_EMUXCH_Pos,
              (uint32_t)(HandlePtr->kChannelNo)
             );  
    }
    /*Configure result registers if Fast Compare Mode is not selected */
    if(HandlePtr->kCompareMode == (uint8_t)0)
 8020aa8:	687b      	ldr	r3, [r7, #4]
 8020aaa:	7ddb      	ldrb	r3, [r3, #23]
 8020aac:	2b00      	cmp	r3, #0
 8020aae:	f040 809e 	bne.w	8020bee <ADCCH001_lInit+0x25a>
    {
      /* Upper and Lower Boundary Select */ 
      WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
 8020ab2:	687b      	ldr	r3, [r7, #4]
 8020ab4:	7d9b      	ldrb	r3, [r3, #22]
 8020ab6:	461a      	mov	r2, r3
 8020ab8:	687b      	ldr	r3, [r7, #4]
 8020aba:	7a9b      	ldrb	r3, [r3, #10]
 8020abc:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8020ac0:	b2d9      	uxtb	r1, r3
 8020ac2:	687b      	ldr	r3, [r7, #4]
 8020ac4:	7d9b      	ldrb	r3, [r3, #22]
 8020ac6:	4618      	mov	r0, r3
 8020ac8:	68bb      	ldr	r3, [r7, #8]
 8020aca:	f100 0080 	add.w	r0, r0, #128	; 0x80
 8020ace:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020ad2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8020ad6:	4319      	orrs	r1, r3
 8020ad8:	68bb      	ldr	r3, [r7, #8]
 8020ada:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020ade:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              ((uint32_t)0xF << VADC_G_CHCTR_BNDSELL_Pos),
              VADC_G_CHCTR_BNDSELL_Pos,
              (uint32_t)HandlePtr->kBoundarySel
             ); 
      /*Result Alignment */
      WR_REG( GroupPtr->CHCTR[HandlePtr->kChannelNo],
 8020ae2:	687b      	ldr	r3, [r7, #4]
 8020ae4:	7d9b      	ldrb	r3, [r3, #22]
 8020ae6:	461a      	mov	r2, r3
 8020ae8:	687b      	ldr	r3, [r7, #4]
 8020aea:	7b5b      	ldrb	r3, [r3, #13]
 8020aec:	ea4f 5343 	mov.w	r3, r3, lsl #21
 8020af0:	f403 1100 	and.w	r1, r3, #2097152	; 0x200000
 8020af4:	687b      	ldr	r3, [r7, #4]
 8020af6:	7d9b      	ldrb	r3, [r3, #22]
 8020af8:	4618      	mov	r0, r3
 8020afa:	68bb      	ldr	r3, [r7, #8]
 8020afc:	f100 0080 	add.w	r0, r0, #128	; 0x80
 8020b00:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020b04:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8020b08:	4319      	orrs	r1, r3
 8020b0a:	68bb      	ldr	r3, [r7, #8]
 8020b0c:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020b10:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              VADC_G_CHCTR_RESPOS_Msk,
              VADC_G_CHCTR_RESPOS_Pos,
              (uint32_t)HandlePtr->kResultControl
             );
      /* Data modification mode */
      WR_REG( GroupPtr->RCR[HandlePtr->kStartResultRegNo],
 8020b14:	687b      	ldr	r3, [r7, #4]
 8020b16:	7cdb      	ldrb	r3, [r3, #19]
 8020b18:	461a      	mov	r2, r3
 8020b1a:	687b      	ldr	r3, [r7, #4]
 8020b1c:	7b9b      	ldrb	r3, [r3, #14]
 8020b1e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8020b22:	f403 117c 	and.w	r1, r3, #4128768	; 0x3f0000
 8020b26:	687b      	ldr	r3, [r7, #4]
 8020b28:	7cdb      	ldrb	r3, [r3, #19]
 8020b2a:	4618      	mov	r0, r3
 8020b2c:	68bb      	ldr	r3, [r7, #8]
 8020b2e:	f100 00a0 	add.w	r0, r0, #160	; 0xa0
 8020b32:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020b36:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8020b3a:	4319      	orrs	r1, r3
 8020b3c:	68bb      	ldr	r3, [r7, #8]
 8020b3e:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 8020b42:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              ((uint32_t)0x3F << VADC_G_RCR_DRCTR_Pos),
              VADC_G_RCR_DRCTR_Pos,
              (uint32_t)HandlePtr->kDataModification
             );
      /* Wait for read mode */
      WR_REG( GroupPtr->RCR[HandlePtr->kStartResultRegNo],
 8020b46:	687b      	ldr	r3, [r7, #4]
 8020b48:	7cdb      	ldrb	r3, [r3, #19]
 8020b4a:	461a      	mov	r2, r3
 8020b4c:	687b      	ldr	r3, [r7, #4]
 8020b4e:	7bdb      	ldrb	r3, [r3, #15]
 8020b50:	ea4f 6303 	mov.w	r3, r3, lsl #24
 8020b54:	f003 7180 	and.w	r1, r3, #16777216	; 0x1000000
 8020b58:	687b      	ldr	r3, [r7, #4]
 8020b5a:	7cdb      	ldrb	r3, [r3, #19]
 8020b5c:	4618      	mov	r0, r3
 8020b5e:	68bb      	ldr	r3, [r7, #8]
 8020b60:	f100 00a0 	add.w	r0, r0, #160	; 0xa0
 8020b64:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020b68:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8020b6c:	4319      	orrs	r1, r3
 8020b6e:	68bb      	ldr	r3, [r7, #8]
 8020b70:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 8020b74:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              VADC_G_RCR_WFR_Msk,
              VADC_G_RCR_WFR_Pos,
              (uint32_t)HandlePtr->kWaitForRead
             );
  /* result interrupt */    
      WR_REG( GroupPtr->RCR[HandlePtr->kEndResultRegNo],
 8020b78:	687b      	ldr	r3, [r7, #4]
 8020b7a:	7d1b      	ldrb	r3, [r3, #20]
 8020b7c:	461a      	mov	r2, r3
 8020b7e:	687b      	ldr	r3, [r7, #4]
 8020b80:	7c5b      	ldrb	r3, [r3, #17]
 8020b82:	ea4f 71c3 	mov.w	r1, r3, lsl #31
 8020b86:	687b      	ldr	r3, [r7, #4]
 8020b88:	7d1b      	ldrb	r3, [r3, #20]
 8020b8a:	4618      	mov	r0, r3
 8020b8c:	68bb      	ldr	r3, [r7, #8]
 8020b8e:	f100 00a0 	add.w	r0, r0, #160	; 0xa0
 8020b92:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020b96:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8020b9a:	4319      	orrs	r1, r3
 8020b9c:	68bb      	ldr	r3, [r7, #8]
 8020b9e:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 8020ba2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              VADC_G_RCR_SRGEN_Msk,
              VADC_G_RCR_SRGEN_Pos,
              (uint32_t)HandlePtr->kResultEvtEnable
             );
  /* Setting FEN bit in all result registers except start result register */    
      if(HandlePtr->kFIFOEnable == (uint8_t)1)
 8020ba6:	687b      	ldr	r3, [r7, #4]
 8020ba8:	7c1b      	ldrb	r3, [r3, #16]
 8020baa:	2b01      	cmp	r3, #1
 8020bac:	d137      	bne.n	8020c1e <ADCCH001_lInit+0x28a>
      {
        for(Index = (HandlePtr->kEndResultRegNo); Index <= (HandlePtr->kStartResultRegNo -(uint8_t)1); Index++)
 8020bae:	687b      	ldr	r3, [r7, #4]
 8020bb0:	7d1b      	ldrb	r3, [r3, #20]
 8020bb2:	73fb      	strb	r3, [r7, #15]
 8020bb4:	e013      	b.n	8020bde <ADCCH001_lInit+0x24a>
        {
           WR_REG( GroupPtr->RCR[Index],
 8020bb6:	7bfa      	ldrb	r2, [r7, #15]
 8020bb8:	7bf9      	ldrb	r1, [r7, #15]
 8020bba:	68bb      	ldr	r3, [r7, #8]
 8020bbc:	f101 01a0 	add.w	r1, r1, #160	; 0xa0
 8020bc0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8020bc4:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8020bc8:	f043 7100 	orr.w	r1, r3, #33554432	; 0x2000000
 8020bcc:	68bb      	ldr	r3, [r7, #8]
 8020bce:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 8020bd2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              (uint32_t)HandlePtr->kResultEvtEnable
             );
  /* Setting FEN bit in all result registers except start result register */    
      if(HandlePtr->kFIFOEnable == (uint8_t)1)
      {
        for(Index = (HandlePtr->kEndResultRegNo); Index <= (HandlePtr->kStartResultRegNo -(uint8_t)1); Index++)
 8020bd6:	7bfb      	ldrb	r3, [r7, #15]
 8020bd8:	f103 0301 	add.w	r3, r3, #1
 8020bdc:	73fb      	strb	r3, [r7, #15]
 8020bde:	7bfa      	ldrb	r2, [r7, #15]
 8020be0:	687b      	ldr	r3, [r7, #4]
 8020be2:	7cdb      	ldrb	r3, [r3, #19]
 8020be4:	f103 33ff 	add.w	r3, r3, #4294967295
 8020be8:	429a      	cmp	r2, r3
 8020bea:	dde4      	ble.n	8020bb6 <ADCCH001_lInit+0x222>
 8020bec:	e017      	b.n	8020c1e <ADCCH001_lInit+0x28a>
      }
    }
/* Write compare value in the result register for the Fast Compare Mode */    
    else
    {
      WR_REG( GroupPtr->RES[HandlePtr->kStartResultRegNo],
 8020bee:	687b      	ldr	r3, [r7, #4]
 8020bf0:	7cdb      	ldrb	r3, [r3, #19]
 8020bf2:	461a      	mov	r2, r3
 8020bf4:	687b      	ldr	r3, [r7, #4]
 8020bf6:	8b1b      	ldrh	r3, [r3, #24]
 8020bf8:	4619      	mov	r1, r3
 8020bfa:	687b      	ldr	r3, [r7, #4]
 8020bfc:	7cdb      	ldrb	r3, [r3, #19]
 8020bfe:	4618      	mov	r0, r3
 8020c00:	68bb      	ldr	r3, [r7, #8]
 8020c02:	f100 00c0 	add.w	r0, r0, #192	; 0xc0
 8020c06:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8020c0a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8020c0e:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8020c12:	4319      	orrs	r1, r3
 8020c14:	68bb      	ldr	r3, [r7, #8]
 8020c16:	f102 02c0 	add.w	r2, r2, #192	; 0xc0
 8020c1a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              VADC_G_RES_RESULT_Pos,
              (uint32_t)(HandlePtr->kResultCompVal)
            );      
    }
    /* Set boundary flag for all the advanced result registers */
    if(HandlePtr->kBoundaryFlagEnable == (uint8_t)1)
 8020c1e:	687b      	ldr	r3, [r7, #4]
 8020c20:	7c9b      	ldrb	r3, [r3, #18]
 8020c22:	2b01      	cmp	r3, #1
 8020c24:	d119      	bne.n	8020c5a <ADCCH001_lInit+0x2c6>
    {
      WR_REG( GroupPtr->BFL,
 8020c26:	687b      	ldr	r3, [r7, #4]
 8020c28:	7cdb      	ldrb	r3, [r3, #19]
 8020c2a:	f103 0310 	add.w	r3, r3, #16
 8020c2e:	f04f 0201 	mov.w	r2, #1
 8020c32:	fa02 f203 	lsl.w	r2, r2, r3
 8020c36:	68bb      	ldr	r3, [r7, #8]
 8020c38:	f8d3 10c8 	ldr.w	r1, [r3, #200]	; 0xc8
 8020c3c:	687b      	ldr	r3, [r7, #4]
 8020c3e:	7cdb      	ldrb	r3, [r3, #19]
 8020c40:	f103 0310 	add.w	r3, r3, #16
 8020c44:	f04f 0001 	mov.w	r0, #1
 8020c48:	fa00 f303 	lsl.w	r3, r0, r3
 8020c4c:	ea6f 0303 	mvn.w	r3, r3
 8020c50:	400b      	ands	r3, r1
 8020c52:	431a      	orrs	r2, r3
 8020c54:	68bb      	ldr	r3, [r7, #8]
 8020c56:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
              (HandlePtr->kStartResultRegNo + (uint8_t)16),
              (uint32_t)(0x1)
            );
    }
    /* change the state to the Initialized */
    HandlePtr->DynamicHandlePtr->State = ADCCH001_INITIALIZED;
 8020c5a:	687b      	ldr	r3, [r7, #4]
 8020c5c:	685b      	ldr	r3, [r3, #4]
 8020c5e:	f04f 0201 	mov.w	r2, #1
 8020c62:	70da      	strb	r2, [r3, #3]
  {
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_OPERATION_NOT_ALLOWED, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
}
 8020c64:	f107 0714 	add.w	r7, r7, #20
 8020c68:	46bd      	mov	sp, r7
 8020c6a:	bc80      	pop	{r7}
 8020c6c:	4770      	bx	lr
 8020c6e:	bf00      	nop

08020c70 <ADCCH001_Init>:

/**
 * This function initializes all instances of the ADCCH001 App
 */
void ADCCH001_Init(void)
{
 8020c70:	b580      	push	{r7, lr}
 8020c72:	af00      	add	r7, sp, #0
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);  
  ADCGLOB001_Init();
 8020c74:	f7ff f9f2 	bl	802005c <ADCGLOB001_Init>
/* Call the local function with the handle pointer for each instance */
  ADCCH001_lInit(&ADCCH001_Handle0);
 8020c78:	f646 00c8 	movw	r0, #26824	; 0x68c8
 8020c7c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020c80:	f7ff fe88 	bl	8020994 <ADCCH001_lInit>
  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
}
 8020c84:	bd80      	pop	{r7, pc}
 8020c86:	bf00      	nop

08020c88 <ADCCH001_Deinit>:

/**
 * This function resets all the channel and result registers. 
 */
status_t ADCCH001_Deinit(const ADCCH001_HandleType* HandlePtr)
{
 8020c88:	b480      	push	{r7}
 8020c8a:	b087      	sub	sp, #28
 8020c8c:	af00      	add	r7, sp, #0
 8020c8e:	6078      	str	r0, [r7, #4]
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
 8020c90:	687b      	ldr	r3, [r7, #4]
 8020c92:	681b      	ldr	r3, [r3, #0]
 8020c94:	60fb      	str	r3, [r7, #12]
  uint8_t Index;
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8020c96:	f04f 0301 	mov.w	r3, #1
 8020c9a:	613b      	str	r3, [r7, #16]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State == ADCCH001_INITIALIZED))
 8020c9c:	687b      	ldr	r3, [r7, #4]
 8020c9e:	685b      	ldr	r3, [r3, #4]
 8020ca0:	78db      	ldrb	r3, [r3, #3]
 8020ca2:	2b01      	cmp	r3, #1
 8020ca4:	d14b      	bne.n	8020d3e <ADCCH001_Deinit+0xb6>
  {
    GroupPtr->CHCTR[HandlePtr->kChannelNo] = (uint32_t)0x00;
 8020ca6:	687b      	ldr	r3, [r7, #4]
 8020ca8:	7d9b      	ldrb	r3, [r3, #22]
 8020caa:	461a      	mov	r2, r3
 8020cac:	68fb      	ldr	r3, [r7, #12]
 8020cae:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020cb2:	f04f 0100 	mov.w	r1, #0
 8020cb6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    WR_REG( GroupPtr->EMUXCTR, 
 8020cba:	68fb      	ldr	r3, [r7, #12]
 8020cbc:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
 8020cc0:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 8020cc4:	68fb      	ldr	r3, [r7, #12]
 8020cc6:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
            VADC_G_EMUXCTR_EMUXCH_Msk,
            VADC_G_EMUXCTR_EMUXCH_Pos,
            (uint32_t)0x00
          );
  
    for(Index = (HandlePtr->kEndResultRegNo); Index <= (HandlePtr->kStartResultRegNo); Index++)
 8020cca:	687b      	ldr	r3, [r7, #4]
 8020ccc:	7d1b      	ldrb	r3, [r3, #20]
 8020cce:	75fb      	strb	r3, [r7, #23]
 8020cd0:	e013      	b.n	8020cfa <ADCCH001_Deinit+0x72>
    {
      GroupPtr->RCR[Index] = (uint32_t)0x00;
 8020cd2:	7dfa      	ldrb	r2, [r7, #23]
 8020cd4:	68fb      	ldr	r3, [r7, #12]
 8020cd6:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 8020cda:	f04f 0100 	mov.w	r1, #0
 8020cde:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      GroupPtr->RES[Index] = (uint32_t)0x00;
 8020ce2:	7dfa      	ldrb	r2, [r7, #23]
 8020ce4:	68fb      	ldr	r3, [r7, #12]
 8020ce6:	f102 02c0 	add.w	r2, r2, #192	; 0xc0
 8020cea:	f04f 0100 	mov.w	r1, #0
 8020cee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_EMUXCTR_EMUXCH_Msk,
            VADC_G_EMUXCTR_EMUXCH_Pos,
            (uint32_t)0x00
          );
  
    for(Index = (HandlePtr->kEndResultRegNo); Index <= (HandlePtr->kStartResultRegNo); Index++)
 8020cf2:	7dfb      	ldrb	r3, [r7, #23]
 8020cf4:	f103 0301 	add.w	r3, r3, #1
 8020cf8:	75fb      	strb	r3, [r7, #23]
 8020cfa:	687b      	ldr	r3, [r7, #4]
 8020cfc:	7cdb      	ldrb	r3, [r3, #19]
 8020cfe:	7dfa      	ldrb	r2, [r7, #23]
 8020d00:	429a      	cmp	r2, r3
 8020d02:	d9e6      	bls.n	8020cd2 <ADCCH001_Deinit+0x4a>
    {
      GroupPtr->RCR[Index] = (uint32_t)0x00;
      GroupPtr->RES[Index] = (uint32_t)0x00;
    }
    if(HandlePtr->kBoundaryFlagEnable == (uint8_t)1)
 8020d04:	687b      	ldr	r3, [r7, #4]
 8020d06:	7c9b      	ldrb	r3, [r3, #18]
 8020d08:	2b01      	cmp	r3, #1
 8020d0a:	d110      	bne.n	8020d2e <ADCCH001_Deinit+0xa6>
    {
      CLR_BIT(GroupPtr->BFL, (((uint32_t)16 + (uint32_t)HandlePtr->kStartResultRegNo)));
 8020d0c:	68fb      	ldr	r3, [r7, #12]
 8020d0e:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 8020d12:	687b      	ldr	r3, [r7, #4]
 8020d14:	7cdb      	ldrb	r3, [r3, #19]
 8020d16:	f103 0310 	add.w	r3, r3, #16
 8020d1a:	f04f 0101 	mov.w	r1, #1
 8020d1e:	fa01 f303 	lsl.w	r3, r1, r3
 8020d22:	ea6f 0303 	mvn.w	r3, r3
 8020d26:	401a      	ands	r2, r3
 8020d28:	68fb      	ldr	r3, [r7, #12]
 8020d2a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    }
    HandlePtr->DynamicHandlePtr->State = ADCCH001_UNINITIALIZED;
 8020d2e:	687b      	ldr	r3, [r7, #4]
 8020d30:	685b      	ldr	r3, [r3, #4]
 8020d32:	f04f 0200 	mov.w	r2, #0
 8020d36:	70da      	strb	r2, [r3, #3]
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020d38:	f04f 0300 	mov.w	r3, #0
 8020d3c:	613b      	str	r3, [r7, #16]
  else
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }
  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8020d3e:	693b      	ldr	r3, [r7, #16]
}
 8020d40:	4618      	mov	r0, r3
 8020d42:	f107 071c 	add.w	r7, r7, #28
 8020d46:	46bd      	mov	sp, r7
 8020d48:	bc80      	pop	{r7}
 8020d4a:	4770      	bx	lr

08020d4c <ADCCH001_SetAlias>:

/**
 * This function assigns the alias channel number
 */
status_t ADCCH001_SetAlias(const ADCCH001_HandleType* HandlePtr, uint8_t ChannelNo)
{
 8020d4c:	b480      	push	{r7}
 8020d4e:	b085      	sub	sp, #20
 8020d50:	af00      	add	r7, sp, #0
 8020d52:	6078      	str	r0, [r7, #4]
 8020d54:	460b      	mov	r3, r1
 8020d56:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8020d58:	f04f 0301 	mov.w	r3, #1
 8020d5c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((ChannelNo > (uint8_t)7))
 8020d5e:	78fb      	ldrb	r3, [r7, #3]
 8020d60:	2b07      	cmp	r3, #7
 8020d62:	d903      	bls.n	8020d6c <ADCCH001_SetAlias+0x20>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8020d64:	f04f 0302 	mov.w	r3, #2
 8020d68:	60fb      	str	r3, [r7, #12]
 8020d6a:	e032      	b.n	8020dd2 <ADCCH001_SetAlias+0x86>
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8020d6c:	687b      	ldr	r3, [r7, #4]
 8020d6e:	685b      	ldr	r3, [r3, #4]
 8020d70:	78db      	ldrb	r3, [r3, #3]
 8020d72:	2b00      	cmp	r3, #0
 8020d74:	d02d      	beq.n	8020dd2 <ADCCH001_SetAlias+0x86>
      ((HandlePtr->kChannelNo == (uint8_t)0) || (HandlePtr->kChannelNo == (uint8_t)1)))
 8020d76:	687b      	ldr	r3, [r7, #4]
 8020d78:	7d9b      	ldrb	r3, [r3, #22]
  if((ChannelNo > (uint8_t)7))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8020d7a:	2b00      	cmp	r3, #0
 8020d7c:	d003      	beq.n	8020d86 <ADCCH001_SetAlias+0x3a>
      ((HandlePtr->kChannelNo == (uint8_t)0) || (HandlePtr->kChannelNo == (uint8_t)1)))
 8020d7e:	687b      	ldr	r3, [r7, #4]
 8020d80:	7d9b      	ldrb	r3, [r3, #22]
 8020d82:	2b01      	cmp	r3, #1
 8020d84:	d125      	bne.n	8020dd2 <ADCCH001_SetAlias+0x86>
  {
    HandlePtr->ADCGrPtr->ALIAS &= ~((uint32_t)0x1F << (HandlePtr->kChannelNo * (uint8_t)8));
 8020d86:	687b      	ldr	r3, [r7, #4]
 8020d88:	681b      	ldr	r3, [r3, #0]
 8020d8a:	687a      	ldr	r2, [r7, #4]
 8020d8c:	6812      	ldr	r2, [r2, #0]
 8020d8e:	f8d2 10b0 	ldr.w	r1, [r2, #176]	; 0xb0
 8020d92:	687a      	ldr	r2, [r7, #4]
 8020d94:	7d92      	ldrb	r2, [r2, #22]
 8020d96:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8020d9a:	f04f 001f 	mov.w	r0, #31
 8020d9e:	fa00 f202 	lsl.w	r2, r0, r2
 8020da2:	ea6f 0202 	mvn.w	r2, r2
 8020da6:	400a      	ands	r2, r1
 8020da8:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    HandlePtr->ADCGrPtr->ALIAS |= ((uint32_t)ChannelNo << (HandlePtr->kChannelNo * (uint8_t)8));
 8020dac:	687b      	ldr	r3, [r7, #4]
 8020dae:	681b      	ldr	r3, [r3, #0]
 8020db0:	687a      	ldr	r2, [r7, #4]
 8020db2:	6812      	ldr	r2, [r2, #0]
 8020db4:	f8d2 10b0 	ldr.w	r1, [r2, #176]	; 0xb0
 8020db8:	78f8      	ldrb	r0, [r7, #3]
 8020dba:	687a      	ldr	r2, [r7, #4]
 8020dbc:	7d92      	ldrb	r2, [r2, #22]
 8020dbe:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8020dc2:	fa00 f202 	lsl.w	r2, r0, r2
 8020dc6:	430a      	orrs	r2, r1
 8020dc8:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020dcc:	f04f 0300 	mov.w	r3, #0
 8020dd0:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);  
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8020dd2:	68fb      	ldr	r3, [r7, #12]
}
 8020dd4:	4618      	mov	r0, r3
 8020dd6:	f107 0714 	add.w	r7, r7, #20
 8020dda:	46bd      	mov	sp, r7
 8020ddc:	bc80      	pop	{r7}
 8020dde:	4770      	bx	lr

08020de0 <ADCCH001_EnableBoundaryFlag>:

/**
 * This function enables the boundary flag for result register 0, 1, 2 or 3.
 */
status_t ADCCH001_EnableBoundaryFlag(const ADCCH001_HandleType* HandlePtr, uint8_t FlagNo)
{
 8020de0:	b480      	push	{r7}
 8020de2:	b085      	sub	sp, #20
 8020de4:	af00      	add	r7, sp, #0
 8020de6:	6078      	str	r0, [r7, #4]
 8020de8:	460b      	mov	r3, r1
 8020dea:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8020dec:	f04f 0301 	mov.w	r3, #1
 8020df0:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((FlagNo > (uint8_t)3))
 8020df2:	78fb      	ldrb	r3, [r7, #3]
 8020df4:	2b03      	cmp	r3, #3
 8020df6:	d903      	bls.n	8020e00 <ADCCH001_EnableBoundaryFlag+0x20>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8020df8:	f04f 0302 	mov.w	r3, #2
 8020dfc:	60fb      	str	r3, [r7, #12]
 8020dfe:	e017      	b.n	8020e30 <ADCCH001_EnableBoundaryFlag+0x50>
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
 8020e00:	687b      	ldr	r3, [r7, #4]
 8020e02:	685b      	ldr	r3, [r3, #4]
 8020e04:	78db      	ldrb	r3, [r3, #3]
 8020e06:	2b00      	cmp	r3, #0
 8020e08:	d012      	beq.n	8020e30 <ADCCH001_EnableBoundaryFlag+0x50>
  {
    SET_BIT(HandlePtr->ADCGrPtr->BFL, ((uint32_t)FlagNo + (uint32_t)16));
 8020e0a:	687b      	ldr	r3, [r7, #4]
 8020e0c:	681b      	ldr	r3, [r3, #0]
 8020e0e:	687a      	ldr	r2, [r7, #4]
 8020e10:	6812      	ldr	r2, [r2, #0]
 8020e12:	f8d2 10c8 	ldr.w	r1, [r2, #200]	; 0xc8
 8020e16:	78fa      	ldrb	r2, [r7, #3]
 8020e18:	f102 0210 	add.w	r2, r2, #16
 8020e1c:	f04f 0001 	mov.w	r0, #1
 8020e20:	fa00 f202 	lsl.w	r2, r0, r2
 8020e24:	430a      	orrs	r2, r1
 8020e26:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020e2a:	f04f 0300 	mov.w	r3, #0
 8020e2e:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);  
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8020e30:	68fb      	ldr	r3, [r7, #12]
}
 8020e32:	4618      	mov	r0, r3
 8020e34:	f107 0714 	add.w	r7, r7, #20
 8020e38:	46bd      	mov	sp, r7
 8020e3a:	bc80      	pop	{r7}
 8020e3c:	4770      	bx	lr
 8020e3e:	bf00      	nop

08020e40 <ADCCH001_DisableBoundaryFlag>:

/**
 * This function disables the boundary flag for result register 0, 1, 2 or 3.
 */
status_t ADCCH001_DisableBoundaryFlag(const ADCCH001_HandleType* HandlePtr, uint8_t FlagNo)
{
 8020e40:	b480      	push	{r7}
 8020e42:	b085      	sub	sp, #20
 8020e44:	af00      	add	r7, sp, #0
 8020e46:	6078      	str	r0, [r7, #4]
 8020e48:	460b      	mov	r3, r1
 8020e4a:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8020e4c:	f04f 0301 	mov.w	r3, #1
 8020e50:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  
  if((FlagNo > (uint8_t)3))
 8020e52:	78fb      	ldrb	r3, [r7, #3]
 8020e54:	2b03      	cmp	r3, #3
 8020e56:	d903      	bls.n	8020e60 <ADCCH001_DisableBoundaryFlag+0x20>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8020e58:	f04f 0302 	mov.w	r3, #2
 8020e5c:	60fb      	str	r3, [r7, #12]
 8020e5e:	e019      	b.n	8020e94 <ADCCH001_DisableBoundaryFlag+0x54>
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
 8020e60:	687b      	ldr	r3, [r7, #4]
 8020e62:	685b      	ldr	r3, [r3, #4]
 8020e64:	78db      	ldrb	r3, [r3, #3]
 8020e66:	2b00      	cmp	r3, #0
 8020e68:	d014      	beq.n	8020e94 <ADCCH001_DisableBoundaryFlag+0x54>
  {
    CLR_BIT(HandlePtr->ADCGrPtr->BFL, ((uint32_t)FlagNo + (uint32_t)16));
 8020e6a:	687b      	ldr	r3, [r7, #4]
 8020e6c:	681b      	ldr	r3, [r3, #0]
 8020e6e:	687a      	ldr	r2, [r7, #4]
 8020e70:	6812      	ldr	r2, [r2, #0]
 8020e72:	f8d2 10c8 	ldr.w	r1, [r2, #200]	; 0xc8
 8020e76:	78fa      	ldrb	r2, [r7, #3]
 8020e78:	f102 0210 	add.w	r2, r2, #16
 8020e7c:	f04f 0001 	mov.w	r0, #1
 8020e80:	fa00 f202 	lsl.w	r2, r0, r2
 8020e84:	ea6f 0202 	mvn.w	r2, r2
 8020e88:	400a      	ands	r2, r1
 8020e8a:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020e8e:	f04f 0300 	mov.w	r3, #0
 8020e92:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);  
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;  
 8020e94:	68fb      	ldr	r3, [r7, #12]
}
 8020e96:	4618      	mov	r0, r3
 8020e98:	f107 0714 	add.w	r7, r7, #20
 8020e9c:	46bd      	mov	sp, r7
 8020e9e:	bc80      	pop	{r7}
 8020ea0:	4770      	bx	lr
 8020ea2:	bf00      	nop

08020ea4 <ADCCH001_SelectInputClass>:

/**
 * This function selects the input class for the channel. 
 */
status_t ADCCH001_SelectInputClass(const ADCCH001_HandleType* HandlePtr, ADCCH001_InputClassType Class)
{
 8020ea4:	b490      	push	{r4, r7}
 8020ea6:	b084      	sub	sp, #16
 8020ea8:	af00      	add	r7, sp, #0
 8020eaa:	6078      	str	r0, [r7, #4]
 8020eac:	460b      	mov	r3, r1
 8020eae:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8020eb0:	f04f 0301 	mov.w	r3, #1
 8020eb4:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  
  if((Class > (ADCCH001_InputClassType)3))
 8020eb6:	78fb      	ldrb	r3, [r7, #3]
 8020eb8:	2b03      	cmp	r3, #3
 8020eba:	d903      	bls.n	8020ec4 <ADCCH001_SelectInputClass+0x20>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8020ebc:	f04f 0302 	mov.w	r3, #2
 8020ec0:	60fb      	str	r3, [r7, #12]
 8020ec2:	e021      	b.n	8020f08 <ADCCH001_SelectInputClass+0x64>
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }  
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) && 
 8020ec4:	687b      	ldr	r3, [r7, #4]
 8020ec6:	685b      	ldr	r3, [r3, #4]
 8020ec8:	78db      	ldrb	r3, [r3, #3]
 8020eca:	2b00      	cmp	r3, #0
 8020ecc:	d01c      	beq.n	8020f08 <ADCCH001_SelectInputClass+0x64>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8020ece:	687b      	ldr	r3, [r7, #4]
 8020ed0:	7ddb      	ldrb	r3, [r3, #23]
  if((Class > (ADCCH001_InputClassType)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }  
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) && 
 8020ed2:	2b00      	cmp	r3, #0
 8020ed4:	d118      	bne.n	8020f08 <ADCCH001_SelectInputClass+0x64>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], 
 8020ed6:	687b      	ldr	r3, [r7, #4]
 8020ed8:	681b      	ldr	r3, [r3, #0]
 8020eda:	687a      	ldr	r2, [r7, #4]
 8020edc:	7d92      	ldrb	r2, [r2, #22]
 8020ede:	78f9      	ldrb	r1, [r7, #3]
 8020ee0:	f001 0003 	and.w	r0, r1, #3
 8020ee4:	6879      	ldr	r1, [r7, #4]
 8020ee6:	6809      	ldr	r1, [r1, #0]
 8020ee8:	687c      	ldr	r4, [r7, #4]
 8020eea:	7da4      	ldrb	r4, [r4, #22]
 8020eec:	f104 0480 	add.w	r4, r4, #128	; 0x80
 8020ef0:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
 8020ef4:	f021 0103 	bic.w	r1, r1, #3
 8020ef8:	4301      	orrs	r1, r0
 8020efa:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020efe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_ICLSEL_Msk,
            VADC_G_CHCTR_ICLSEL_Pos,
            (uint32_t)Class
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020f02:	f04f 0300 	mov.w	r3, #0
 8020f06:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8020f08:	68fb      	ldr	r3, [r7, #12]
}
 8020f0a:	4618      	mov	r0, r3
 8020f0c:	f107 0710 	add.w	r7, r7, #16
 8020f10:	46bd      	mov	sp, r7
 8020f12:	bc90      	pop	{r4, r7}
 8020f14:	4770      	bx	lr
 8020f16:	bf00      	nop

08020f18 <ADCCH001_SelectChEvtMode>:

/**
 * This function configures the channel event mode to generate the channel interrupt
 */
status_t ADCCH001_SelectChEvtMode(const ADCCH001_HandleType* HandlePtr, ADCCH001_ChanEvtModeType Mode)
{
 8020f18:	b490      	push	{r4, r7}
 8020f1a:	b084      	sub	sp, #16
 8020f1c:	af00      	add	r7, sp, #0
 8020f1e:	6078      	str	r0, [r7, #4]
 8020f20:	460b      	mov	r3, r1
 8020f22:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8020f24:	f04f 0301 	mov.w	r3, #1
 8020f28:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((Mode > (ADCCH001_ChanEvtModeType)3))
 8020f2a:	78fb      	ldrb	r3, [r7, #3]
 8020f2c:	2b03      	cmp	r3, #3
 8020f2e:	d903      	bls.n	8020f38 <ADCCH001_SelectChEvtMode+0x20>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8020f30:	f04f 0302 	mov.w	r3, #2
 8020f34:	60fb      	str	r3, [r7, #12]
 8020f36:	e01f      	b.n	8020f78 <ADCCH001_SelectChEvtMode+0x60>
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }   
  else if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
 8020f38:	687b      	ldr	r3, [r7, #4]
 8020f3a:	685b      	ldr	r3, [r3, #4]
 8020f3c:	78db      	ldrb	r3, [r3, #3]
 8020f3e:	2b00      	cmp	r3, #0
 8020f40:	d01a      	beq.n	8020f78 <ADCCH001_SelectChEvtMode+0x60>
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], 
 8020f42:	687b      	ldr	r3, [r7, #4]
 8020f44:	681b      	ldr	r3, [r3, #0]
 8020f46:	687a      	ldr	r2, [r7, #4]
 8020f48:	7d92      	ldrb	r2, [r2, #22]
 8020f4a:	78f9      	ldrb	r1, [r7, #3]
 8020f4c:	ea4f 2101 	mov.w	r1, r1, lsl #8
 8020f50:	f401 7040 	and.w	r0, r1, #768	; 0x300
 8020f54:	6879      	ldr	r1, [r7, #4]
 8020f56:	6809      	ldr	r1, [r1, #0]
 8020f58:	687c      	ldr	r4, [r7, #4]
 8020f5a:	7da4      	ldrb	r4, [r4, #22]
 8020f5c:	f104 0480 	add.w	r4, r4, #128	; 0x80
 8020f60:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
 8020f64:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 8020f68:	4301      	orrs	r1, r0
 8020f6a:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020f6e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_CHEVMODE_Msk,
            VADC_G_CHCTR_CHEVMODE_Pos,
            (uint32_t)Mode
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020f72:	f04f 0300 	mov.w	r3, #0
 8020f76:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8020f78:	68fb      	ldr	r3, [r7, #12]
}
 8020f7a:	4618      	mov	r0, r3
 8020f7c:	f107 0710 	add.w	r7, r7, #16
 8020f80:	46bd      	mov	sp, r7
 8020f82:	bc90      	pop	{r4, r7}
 8020f84:	4770      	bx	lr
 8020f86:	bf00      	nop

08020f88 <ADCCH001_SelectUpperBoundary>:
/**
 * This function selects the upper boundary for limit checking function. 
 * This is the upper delta for Fast Compare Mode.
 */
status_t ADCCH001_SelectUpperBoundary(const ADCCH001_HandleType* HandlePtr, ADCCH001_BoundaryType UBoundary)
{
 8020f88:	b490      	push	{r4, r7}
 8020f8a:	b084      	sub	sp, #16
 8020f8c:	af00      	add	r7, sp, #0
 8020f8e:	6078      	str	r0, [r7, #4]
 8020f90:	460b      	mov	r3, r1
 8020f92:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8020f94:	f04f 0301 	mov.w	r3, #1
 8020f98:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((UBoundary > (ADCCH001_BoundaryType)3))
 8020f9a:	78fb      	ldrb	r3, [r7, #3]
 8020f9c:	2b03      	cmp	r3, #3
 8020f9e:	d903      	bls.n	8020fa8 <ADCCH001_SelectUpperBoundary+0x20>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8020fa0:	f04f 0302 	mov.w	r3, #2
 8020fa4:	60fb      	str	r3, [r7, #12]
 8020fa6:	e022      	b.n	8020fee <ADCCH001_SelectUpperBoundary+0x66>
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }   
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8020fa8:	687b      	ldr	r3, [r7, #4]
 8020faa:	685b      	ldr	r3, [r3, #4]
 8020fac:	78db      	ldrb	r3, [r3, #3]
 8020fae:	2b00      	cmp	r3, #0
 8020fb0:	d01d      	beq.n	8020fee <ADCCH001_SelectUpperBoundary+0x66>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8020fb2:	687b      	ldr	r3, [r7, #4]
 8020fb4:	7ddb      	ldrb	r3, [r3, #23]
  if((UBoundary > (ADCCH001_BoundaryType)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }   
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8020fb6:	2b00      	cmp	r3, #0
 8020fb8:	d119      	bne.n	8020fee <ADCCH001_SelectUpperBoundary+0x66>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], 
 8020fba:	687b      	ldr	r3, [r7, #4]
 8020fbc:	681b      	ldr	r3, [r3, #0]
 8020fbe:	687a      	ldr	r2, [r7, #4]
 8020fc0:	7d92      	ldrb	r2, [r2, #22]
 8020fc2:	78f9      	ldrb	r1, [r7, #3]
 8020fc4:	ea4f 1181 	mov.w	r1, r1, lsl #6
 8020fc8:	b2c8      	uxtb	r0, r1
 8020fca:	6879      	ldr	r1, [r7, #4]
 8020fcc:	6809      	ldr	r1, [r1, #0]
 8020fce:	687c      	ldr	r4, [r7, #4]
 8020fd0:	7da4      	ldrb	r4, [r4, #22]
 8020fd2:	f104 0480 	add.w	r4, r4, #128	; 0x80
 8020fd6:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
 8020fda:	f021 01c0 	bic.w	r1, r1, #192	; 0xc0
 8020fde:	4301      	orrs	r1, r0
 8020fe0:	f102 0280 	add.w	r2, r2, #128	; 0x80
 8020fe4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_BNDSELU_Msk,
            VADC_G_CHCTR_BNDSELU_Pos,
            (uint32_t)UBoundary
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8020fe8:	f04f 0300 	mov.w	r3, #0
 8020fec:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT); 
  return Status;
 8020fee:	68fb      	ldr	r3, [r7, #12]
}
 8020ff0:	4618      	mov	r0, r3
 8020ff2:	f107 0710 	add.w	r7, r7, #16
 8020ff6:	46bd      	mov	sp, r7
 8020ff8:	bc90      	pop	{r4, r7}
 8020ffa:	4770      	bx	lr

08020ffc <ADCCH001_SelectLowerBoundary>:
/**
 * This function selects the lower boundary for limit checking function. 
 * This is the lower delta for Fast Compare Mode.
 */
status_t ADCCH001_SelectLowerBoundary(const ADCCH001_HandleType* HandlePtr, ADCCH001_BoundaryType LBoundary)
{
 8020ffc:	b490      	push	{r4, r7}
 8020ffe:	b084      	sub	sp, #16
 8021000:	af00      	add	r7, sp, #0
 8021002:	6078      	str	r0, [r7, #4]
 8021004:	460b      	mov	r3, r1
 8021006:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021008:	f04f 0301 	mov.w	r3, #1
 802100c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((LBoundary > (ADCCH001_BoundaryType)3))
 802100e:	78fb      	ldrb	r3, [r7, #3]
 8021010:	2b03      	cmp	r3, #3
 8021012:	d903      	bls.n	802101c <ADCCH001_SelectLowerBoundary+0x20>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8021014:	f04f 0302 	mov.w	r3, #2
 8021018:	60fb      	str	r3, [r7, #12]
 802101a:	e023      	b.n	8021064 <ADCCH001_SelectLowerBoundary+0x68>
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }   
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802101c:	687b      	ldr	r3, [r7, #4]
 802101e:	685b      	ldr	r3, [r3, #4]
 8021020:	78db      	ldrb	r3, [r3, #3]
 8021022:	2b00      	cmp	r3, #0
 8021024:	d01e      	beq.n	8021064 <ADCCH001_SelectLowerBoundary+0x68>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8021026:	687b      	ldr	r3, [r7, #4]
 8021028:	7ddb      	ldrb	r3, [r3, #23]
  if((LBoundary > (ADCCH001_BoundaryType)3))
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    ERROR(GID_ADCCH001, (uint8_t)ADCCH001_INVALID_PARAM, 0, (uint8_t*) NULL);    
  }   
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802102a:	2b00      	cmp	r3, #0
 802102c:	d11a      	bne.n	8021064 <ADCCH001_SelectLowerBoundary+0x68>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], 
 802102e:	687b      	ldr	r3, [r7, #4]
 8021030:	681b      	ldr	r3, [r3, #0]
 8021032:	687a      	ldr	r2, [r7, #4]
 8021034:	7d92      	ldrb	r2, [r2, #22]
 8021036:	78f9      	ldrb	r1, [r7, #3]
 8021038:	ea4f 1101 	mov.w	r1, r1, lsl #4
 802103c:	f001 0030 	and.w	r0, r1, #48	; 0x30
 8021040:	6879      	ldr	r1, [r7, #4]
 8021042:	6809      	ldr	r1, [r1, #0]
 8021044:	687c      	ldr	r4, [r7, #4]
 8021046:	7da4      	ldrb	r4, [r4, #22]
 8021048:	f104 0480 	add.w	r4, r4, #128	; 0x80
 802104c:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
 8021050:	f021 0130 	bic.w	r1, r1, #48	; 0x30
 8021054:	4301      	orrs	r1, r0
 8021056:	f102 0280 	add.w	r2, r2, #128	; 0x80
 802105a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_BNDSELL_Msk,
            VADC_G_CHCTR_BNDSELL_Pos,
            (uint32_t)LBoundary
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
 802105e:	f04f 0300 	mov.w	r3, #0
 8021062:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8021064:	68fb      	ldr	r3, [r7, #12]
}
 8021066:	4618      	mov	r0, r3
 8021068:	f107 0710 	add.w	r7, r7, #16
 802106c:	46bd      	mov	sp, r7
 802106e:	bc90      	pop	{r4, r7}
 8021070:	4770      	bx	lr
 8021072:	bf00      	nop

08021074 <ADCCH001_GetResult>:

/**
 * This function returns the result of the normal mode ADC conversion. 
 */
status_t ADCCH001_GetResult(const ADCCH001_HandleType* HandlePtr, uint16_t* ResultPtr)
{
 8021074:	b480      	push	{r7}
 8021076:	b087      	sub	sp, #28
 8021078:	af00      	add	r7, sp, #0
 802107a:	6078      	str	r0, [r7, #4]
 802107c:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 802107e:	f04f 0301 	mov.w	r3, #1
 8021082:	617b      	str	r3, [r7, #20]
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
 8021084:	687b      	ldr	r3, [r7, #4]
 8021086:	681b      	ldr	r3, [r3, #0]
 8021088:	613b      	str	r3, [r7, #16]
  uint32_t TempResult;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802108a:	687b      	ldr	r3, [r7, #4]
 802108c:	685b      	ldr	r3, [r3, #4]
 802108e:	78db      	ldrb	r3, [r3, #3]
 8021090:	2b00      	cmp	r3, #0
 8021092:	d027      	beq.n	80210e4 <ADCCH001_GetResult+0x70>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8021094:	687b      	ldr	r3, [r7, #4]
 8021096:	7ddb      	ldrb	r3, [r3, #23]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
  uint32_t TempResult;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021098:	2b00      	cmp	r3, #0
 802109a:	d123      	bne.n	80210e4 <ADCCH001_GetResult+0x70>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    TempResult = GroupPtr->RES[HandlePtr->kEndResultRegNo];
 802109c:	687b      	ldr	r3, [r7, #4]
 802109e:	7d1b      	ldrb	r3, [r3, #20]
 80210a0:	461a      	mov	r2, r3
 80210a2:	693b      	ldr	r3, [r7, #16]
 80210a4:	f102 02c0 	add.w	r2, r2, #192	; 0xc0
 80210a8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80210ac:	60fb      	str	r3, [r7, #12]
    /* If valid flag is set */
    if(((TempResult & VADC_G_RES_VF_Msk) >> VADC_G_RES_VF_Pos) == (uint32_t)1)
 80210ae:	68fb      	ldr	r3, [r7, #12]
 80210b0:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 80210b4:	2b01      	cmp	r3, #1
 80210b6:	d10d      	bne.n	80210d4 <ADCCH001_GetResult+0x60>
    {
      HandlePtr->DynamicHandlePtr->Result = 
 80210b8:	687b      	ldr	r3, [r7, #4]
 80210ba:	685b      	ldr	r3, [r3, #4]
          (uint16_t)(TempResult & VADC_G_RES_RESULT_Msk);
 80210bc:	68fa      	ldr	r2, [r7, #12]
 80210be:	b292      	uxth	r2, r2
  {
    TempResult = GroupPtr->RES[HandlePtr->kEndResultRegNo];
    /* If valid flag is set */
    if(((TempResult & VADC_G_RES_VF_Msk) >> VADC_G_RES_VF_Pos) == (uint32_t)1)
    {
      HandlePtr->DynamicHandlePtr->Result = 
 80210c0:	801a      	strh	r2, [r3, #0]
          (uint16_t)(TempResult & VADC_G_RES_RESULT_Msk);
      *ResultPtr = HandlePtr->DynamicHandlePtr->Result;
 80210c2:	687b      	ldr	r3, [r7, #4]
 80210c4:	685b      	ldr	r3, [r3, #4]
 80210c6:	881a      	ldrh	r2, [r3, #0]
 80210c8:	683b      	ldr	r3, [r7, #0]
 80210ca:	801a      	strh	r2, [r3, #0]
      Status = (uint32_t)DAVEApp_SUCCESS;
 80210cc:	f04f 0300 	mov.w	r3, #0
 80210d0:	617b      	str	r3, [r7, #20]
 80210d2:	e007      	b.n	80210e4 <ADCCH001_GetResult+0x70>
    }
    /* If data is old, then send error as invalid result */
    else
    {
      *ResultPtr = HandlePtr->DynamicHandlePtr->Result;
 80210d4:	687b      	ldr	r3, [r7, #4]
 80210d6:	685b      	ldr	r3, [r3, #4]
 80210d8:	881a      	ldrh	r2, [r3, #0]
 80210da:	683b      	ldr	r3, [r7, #0]
 80210dc:	801a      	strh	r2, [r3, #0]
      Status = (uint32_t)ADCCH001_INVALID_RESULT;
 80210de:	f04f 0303 	mov.w	r3, #3
 80210e2:	617b      	str	r3, [r7, #20]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 80210e4:	697b      	ldr	r3, [r7, #20]
}
 80210e6:	4618      	mov	r0, r3
 80210e8:	f107 071c 	add.w	r7, r7, #28
 80210ec:	46bd      	mov	sp, r7
 80210ee:	bc80      	pop	{r7}
 80210f0:	4770      	bx	lr
 80210f2:	bf00      	nop

080210f4 <ADCCH001_GetFastCompareResult>:

/**
 * This function returns the result of the fast compare ADC conversion. 
 */
status_t ADCCH001_GetFastCompareResult(const ADCCH001_HandleType* HandlePtr, uint8_t* ResultPtr)
{
 80210f4:	b480      	push	{r7}
 80210f6:	b087      	sub	sp, #28
 80210f8:	af00      	add	r7, sp, #0
 80210fa:	6078      	str	r0, [r7, #4]
 80210fc:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80210fe:	f04f 0301 	mov.w	r3, #1
 8021102:	617b      	str	r3, [r7, #20]
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
 8021104:	687b      	ldr	r3, [r7, #4]
 8021106:	681b      	ldr	r3, [r3, #0]
 8021108:	613b      	str	r3, [r7, #16]
  uint32_t TempResult;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802110a:	687b      	ldr	r3, [r7, #4]
 802110c:	685b      	ldr	r3, [r3, #4]
 802110e:	78db      	ldrb	r3, [r3, #3]
 8021110:	2b00      	cmp	r3, #0
 8021112:	d02b      	beq.n	802116c <ADCCH001_GetFastCompareResult+0x78>
      (HandlePtr->kCompareMode == (uint8_t)1))
 8021114:	687b      	ldr	r3, [r7, #4]
 8021116:	7ddb      	ldrb	r3, [r3, #23]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  VADC_G_TypeDef* GroupPtr = HandlePtr->ADCGrPtr;
  uint32_t TempResult;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021118:	2b01      	cmp	r3, #1
 802111a:	d127      	bne.n	802116c <ADCCH001_GetFastCompareResult+0x78>
      (HandlePtr->kCompareMode == (uint8_t)1))
  {
    TempResult = GroupPtr->RES[HandlePtr->kEndResultRegNo];
 802111c:	687b      	ldr	r3, [r7, #4]
 802111e:	7d1b      	ldrb	r3, [r3, #20]
 8021120:	461a      	mov	r2, r3
 8021122:	693b      	ldr	r3, [r7, #16]
 8021124:	f102 02c0 	add.w	r2, r2, #192	; 0xc0
 8021128:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802112c:	60fb      	str	r3, [r7, #12]
    /* If valid flag is set */
    if(((TempResult & VADC_G_RES_VF_Msk) >> VADC_G_RES_VF_Pos) == (uint32_t)1)
 802112e:	68fb      	ldr	r3, [r7, #12]
 8021130:	ea4f 73d3 	mov.w	r3, r3, lsr #31
 8021134:	2b01      	cmp	r3, #1
 8021136:	d111      	bne.n	802115c <ADCCH001_GetFastCompareResult+0x68>
    {
      HandlePtr->DynamicHandlePtr->FastCompResult = (uint8_t)RD_REG(TempResult, 
 8021138:	687b      	ldr	r3, [r7, #4]
 802113a:	685b      	ldr	r3, [r3, #4]
 802113c:	68fa      	ldr	r2, [r7, #12]
 802113e:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 8021142:	ea4f 7292 	mov.w	r2, r2, lsr #30
 8021146:	b2d2      	uxtb	r2, r2
 8021148:	709a      	strb	r2, [r3, #2]
                                                    VADC_G_RES_FCR_Msk,
                                                    VADC_G_RES_FCR_Pos
                                                   );
      *ResultPtr = HandlePtr->DynamicHandlePtr->FastCompResult;
 802114a:	687b      	ldr	r3, [r7, #4]
 802114c:	685b      	ldr	r3, [r3, #4]
 802114e:	789a      	ldrb	r2, [r3, #2]
 8021150:	683b      	ldr	r3, [r7, #0]
 8021152:	701a      	strb	r2, [r3, #0]
      Status = (uint32_t)DAVEApp_SUCCESS;
 8021154:	f04f 0300 	mov.w	r3, #0
 8021158:	617b      	str	r3, [r7, #20]
 802115a:	e007      	b.n	802116c <ADCCH001_GetFastCompareResult+0x78>
    }
    /* If data is old, then send error as invalid result */
    else
    {
      *ResultPtr = HandlePtr->DynamicHandlePtr->FastCompResult;
 802115c:	687b      	ldr	r3, [r7, #4]
 802115e:	685b      	ldr	r3, [r3, #4]
 8021160:	789a      	ldrb	r2, [r3, #2]
 8021162:	683b      	ldr	r3, [r7, #0]
 8021164:	701a      	strb	r2, [r3, #0]
      Status = (uint32_t)ADCCH001_INVALID_RESULT;
 8021166:	f04f 0303 	mov.w	r3, #3
 802116a:	617b      	str	r3, [r7, #20]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 802116c:	697b      	ldr	r3, [r7, #20]
}
 802116e:	4618      	mov	r0, r3
 8021170:	f107 071c 	add.w	r7, r7, #28
 8021174:	46bd      	mov	sp, r7
 8021176:	bc80      	pop	{r7}
 8021178:	4770      	bx	lr
 802117a:	bf00      	nop

0802117c <ADCCH001_SetCompareValue>:
/**
 * This function sets the compare value for the Fast Compare Mode. 
 * Compare value should 10-bit value.
 */
status_t ADCCH001_SetCompareValue(const ADCCH001_HandleType* HandlePtr, uint16_t CompVal)
{
 802117c:	b490      	push	{r4, r7}
 802117e:	b084      	sub	sp, #16
 8021180:	af00      	add	r7, sp, #0
 8021182:	6078      	str	r0, [r7, #4]
 8021184:	460b      	mov	r3, r1
 8021186:	807b      	strh	r3, [r7, #2]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021188:	f04f 0301 	mov.w	r3, #1
 802118c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if(CompVal > (uint16_t)0x3FF)
 802118e:	887a      	ldrh	r2, [r7, #2]
 8021190:	f240 33ff 	movw	r3, #1023	; 0x3ff
 8021194:	429a      	cmp	r2, r3
 8021196:	d903      	bls.n	80211a0 <ADCCH001_SetCompareValue+0x24>
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
 8021198:	f04f 0302 	mov.w	r3, #2
 802119c:	60fb      	str	r3, [r7, #12]
 802119e:	e028      	b.n	80211f2 <ADCCH001_SetCompareValue+0x76>
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL); 
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80211a0:	687b      	ldr	r3, [r7, #4]
 80211a2:	685b      	ldr	r3, [r3, #4]
 80211a4:	78db      	ldrb	r3, [r3, #3]
 80211a6:	2b00      	cmp	r3, #0
 80211a8:	d023      	beq.n	80211f2 <ADCCH001_SetCompareValue+0x76>
      ((HandlePtr->kCompareMode == (uint8_t)1)))
 80211aa:	687b      	ldr	r3, [r7, #4]
 80211ac:	7ddb      	ldrb	r3, [r3, #23]
  if(CompVal > (uint16_t)0x3FF)
  {
    Status = (uint32_t)ADCCH001_INVALID_PARAM;
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL); 
  }
  else if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80211ae:	2b01      	cmp	r3, #1
 80211b0:	d11f      	bne.n	80211f2 <ADCCH001_SetCompareValue+0x76>
      ((HandlePtr->kCompareMode == (uint8_t)1)))
  {
    WR_REG( HandlePtr->ADCGrPtr->RES[HandlePtr->kStartResultRegNo], 
 80211b2:	687b      	ldr	r3, [r7, #4]
 80211b4:	6819      	ldr	r1, [r3, #0]
 80211b6:	687b      	ldr	r3, [r7, #4]
 80211b8:	7cdb      	ldrb	r3, [r3, #19]
 80211ba:	4618      	mov	r0, r3
 80211bc:	887b      	ldrh	r3, [r7, #2]
 80211be:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80211c2:	ea4f 4203 	mov.w	r2, r3, lsl #16
 80211c6:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80211ca:	687b      	ldr	r3, [r7, #4]
 80211cc:	681b      	ldr	r3, [r3, #0]
 80211ce:	687c      	ldr	r4, [r7, #4]
 80211d0:	7ce4      	ldrb	r4, [r4, #19]
 80211d2:	f104 04c0 	add.w	r4, r4, #192	; 0xc0
 80211d6:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80211da:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80211de:	ea4f 4303 	mov.w	r3, r3, lsl #16
 80211e2:	431a      	orrs	r2, r3
 80211e4:	f100 03c0 	add.w	r3, r0, #192	; 0xc0
 80211e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            VADC_G_RES_RESULT_Msk,
            VADC_G_RES_RESULT_Pos,
            ((uint32_t)CompVal << (uint8_t)2)
          );
    Status = (uint32_t)DAVEApp_SUCCESS;
 80211ec:	f04f 0300 	mov.w	r3, #0
 80211f0:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 80211f2:	68fb      	ldr	r3, [r7, #12]
}
 80211f4:	4618      	mov	r0, r3
 80211f6:	f107 0710 	add.w	r7, r7, #16
 80211fa:	46bd      	mov	sp, r7
 80211fc:	bc90      	pop	{r4, r7}
 80211fe:	4770      	bx	lr

08021200 <ADCCH001_EnablePriorityChannel>:

/**
 * This function enables the channel as a priority channel. 
 */
status_t ADCCH001_EnablePriorityChannel(const ADCCH001_HandleType* HandlePtr)
{
 8021200:	b480      	push	{r7}
 8021202:	b085      	sub	sp, #20
 8021204:	af00      	add	r7, sp, #0
 8021206:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021208:	f04f 0301 	mov.w	r3, #1
 802120c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
 802120e:	687b      	ldr	r3, [r7, #4]
 8021210:	685b      	ldr	r3, [r3, #4]
 8021212:	78db      	ldrb	r3, [r3, #3]
 8021214:	2b00      	cmp	r3, #0
 8021216:	d011      	beq.n	802123c <ADCCH001_EnablePriorityChannel+0x3c>
  {
    SET_BIT(HandlePtr->ADCGrPtr->CHASS, (HandlePtr->kChannelNo));
 8021218:	687b      	ldr	r3, [r7, #4]
 802121a:	681b      	ldr	r3, [r3, #0]
 802121c:	687a      	ldr	r2, [r7, #4]
 802121e:	6812      	ldr	r2, [r2, #0]
 8021220:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 8021224:	687a      	ldr	r2, [r7, #4]
 8021226:	7d92      	ldrb	r2, [r2, #22]
 8021228:	f04f 0001 	mov.w	r0, #1
 802122c:	fa00 f202 	lsl.w	r2, r0, r2
 8021230:	430a      	orrs	r2, r1
 8021232:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021236:	f04f 0300 	mov.w	r3, #0
 802123a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;  
 802123c:	68fb      	ldr	r3, [r7, #12]
}
 802123e:	4618      	mov	r0, r3
 8021240:	f107 0714 	add.w	r7, r7, #20
 8021244:	46bd      	mov	sp, r7
 8021246:	bc80      	pop	{r7}
 8021248:	4770      	bx	lr
 802124a:	bf00      	nop

0802124c <ADCCH001_DisablePriorityChannel>:

/**
 * This function disables the channel as a priority channel. 
 */
status_t ADCCH001_DisablePriorityChannel(const ADCCH001_HandleType* HandlePtr)
{
 802124c:	b480      	push	{r7}
 802124e:	b085      	sub	sp, #20
 8021250:	af00      	add	r7, sp, #0
 8021252:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021254:	f04f 0301 	mov.w	r3, #1
 8021258:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED))
 802125a:	687b      	ldr	r3, [r7, #4]
 802125c:	685b      	ldr	r3, [r3, #4]
 802125e:	78db      	ldrb	r3, [r3, #3]
 8021260:	2b00      	cmp	r3, #0
 8021262:	d013      	beq.n	802128c <ADCCH001_DisablePriorityChannel+0x40>
  {
    CLR_BIT(HandlePtr->ADCGrPtr->CHASS, (HandlePtr->kChannelNo));  
 8021264:	687b      	ldr	r3, [r7, #4]
 8021266:	681b      	ldr	r3, [r3, #0]
 8021268:	687a      	ldr	r2, [r7, #4]
 802126a:	6812      	ldr	r2, [r2, #0]
 802126c:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
 8021270:	687a      	ldr	r2, [r7, #4]
 8021272:	7d92      	ldrb	r2, [r2, #22]
 8021274:	f04f 0001 	mov.w	r0, #1
 8021278:	fa00 f202 	lsl.w	r2, r0, r2
 802127c:	ea6f 0202 	mvn.w	r2, r2
 8021280:	400a      	ands	r2, r1
 8021282:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021286:	f04f 0300 	mov.w	r3, #0
 802128a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;  
 802128c:	68fb      	ldr	r3, [r7, #12]
}
 802128e:	4618      	mov	r0, r3
 8021290:	f107 0714 	add.w	r7, r7, #20
 8021294:	46bd      	mov	sp, r7
 8021296:	bc80      	pop	{r7}
 8021298:	4770      	bx	lr
 802129a:	bf00      	nop

0802129c <ADCCH001_EnableResultEvt>:

/**
 * This function enables the  Result event. 
 */
status_t ADCCH001_EnableResultEvt(const ADCCH001_HandleType* HandlePtr)
{
 802129c:	b480      	push	{r7}
 802129e:	b085      	sub	sp, #20
 80212a0:	af00      	add	r7, sp, #0
 80212a2:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80212a4:	f04f 0301 	mov.w	r3, #1
 80212a8:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80212aa:	687b      	ldr	r3, [r7, #4]
 80212ac:	685b      	ldr	r3, [r3, #4]
 80212ae:	78db      	ldrb	r3, [r3, #3]
 80212b0:	2b00      	cmp	r3, #0
 80212b2:	d018      	beq.n	80212e6 <ADCCH001_EnableResultEvt+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
 80212b4:	687b      	ldr	r3, [r7, #4]
 80212b6:	7ddb      	ldrb	r3, [r3, #23]
 */
status_t ADCCH001_EnableResultEvt(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80212b8:	2b00      	cmp	r3, #0
 80212ba:	d114      	bne.n	80212e6 <ADCCH001_EnableResultEvt+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->RCR[HandlePtr->kEndResultRegNo],
 80212bc:	687b      	ldr	r3, [r7, #4]
 80212be:	681b      	ldr	r3, [r3, #0]
 80212c0:	687a      	ldr	r2, [r7, #4]
 80212c2:	7d12      	ldrb	r2, [r2, #20]
 80212c4:	6879      	ldr	r1, [r7, #4]
 80212c6:	6809      	ldr	r1, [r1, #0]
 80212c8:	6878      	ldr	r0, [r7, #4]
 80212ca:	7d00      	ldrb	r0, [r0, #20]
 80212cc:	f100 00a0 	add.w	r0, r0, #160	; 0xa0
 80212d0:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 80212d4:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 80212d8:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 80212dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
             VADC_G_RCR_SRGEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 80212e0:	f04f 0300 	mov.w	r3, #0
 80212e4:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 80212e6:	68fb      	ldr	r3, [r7, #12]
}
 80212e8:	4618      	mov	r0, r3
 80212ea:	f107 0714 	add.w	r7, r7, #20
 80212ee:	46bd      	mov	sp, r7
 80212f0:	bc80      	pop	{r7}
 80212f2:	4770      	bx	lr

080212f4 <ADCCH001_DisableResultEvt>:

/**
 * This function disables the  Result event. 
 */
status_t ADCCH001_DisableResultEvt(const ADCCH001_HandleType* HandlePtr)
{
 80212f4:	b480      	push	{r7}
 80212f6:	b085      	sub	sp, #20
 80212f8:	af00      	add	r7, sp, #0
 80212fa:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80212fc:	f04f 0301 	mov.w	r3, #1
 8021300:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021302:	687b      	ldr	r3, [r7, #4]
 8021304:	685b      	ldr	r3, [r3, #4]
 8021306:	78db      	ldrb	r3, [r3, #3]
 8021308:	2b00      	cmp	r3, #0
 802130a:	d018      	beq.n	802133e <ADCCH001_DisableResultEvt+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
 802130c:	687b      	ldr	r3, [r7, #4]
 802130e:	7ddb      	ldrb	r3, [r3, #23]
 */
status_t ADCCH001_DisableResultEvt(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021310:	2b00      	cmp	r3, #0
 8021312:	d114      	bne.n	802133e <ADCCH001_DisableResultEvt+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    CLR_BIT( HandlePtr->ADCGrPtr->RCR[HandlePtr->kEndResultRegNo],
 8021314:	687b      	ldr	r3, [r7, #4]
 8021316:	681b      	ldr	r3, [r3, #0]
 8021318:	687a      	ldr	r2, [r7, #4]
 802131a:	7d12      	ldrb	r2, [r2, #20]
 802131c:	6879      	ldr	r1, [r7, #4]
 802131e:	6809      	ldr	r1, [r1, #0]
 8021320:	6878      	ldr	r0, [r7, #4]
 8021322:	7d00      	ldrb	r0, [r0, #20]
 8021324:	f100 00a0 	add.w	r0, r0, #160	; 0xa0
 8021328:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 802132c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8021330:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 8021334:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
             VADC_G_RCR_SRGEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021338:	f04f 0300 	mov.w	r3, #0
 802133c:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 802133e:	68fb      	ldr	r3, [r7, #12]
}
 8021340:	4618      	mov	r0, r3
 8021342:	f107 0714 	add.w	r7, r7, #20
 8021346:	46bd      	mov	sp, r7
 8021348:	bc80      	pop	{r7}
 802134a:	4770      	bx	lr

0802134c <ADCCH001_GetResultEvtFlag>:

/**
 * This function checks whether Result event flag is set.
 */
status_t ADCCH001_GetResultEvtFlag(const ADCCH001_HandleType* HandlePtr, uint8_t* EvtStatus)
{
 802134c:	b480      	push	{r7}
 802134e:	b085      	sub	sp, #20
 8021350:	af00      	add	r7, sp, #0
 8021352:	6078      	str	r0, [r7, #4]
 8021354:	6039      	str	r1, [r7, #0]

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021356:	f04f 0301 	mov.w	r3, #1
 802135a:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802135c:	687b      	ldr	r3, [r7, #4]
 802135e:	685b      	ldr	r3, [r3, #4]
 8021360:	78db      	ldrb	r3, [r3, #3]
 8021362:	2b00      	cmp	r3, #0
 8021364:	d018      	beq.n	8021398 <ADCCH001_GetResultEvtFlag+0x4c>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8021366:	687b      	ldr	r3, [r7, #4]
 8021368:	7ddb      	ldrb	r3, [r3, #23]
status_t ADCCH001_GetResultEvtFlag(const ADCCH001_HandleType* HandlePtr, uint8_t* EvtStatus)
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802136a:	2b00      	cmp	r3, #0
 802136c:	d114      	bne.n	8021398 <ADCCH001_GetResultEvtFlag+0x4c>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    *EvtStatus = (uint8_t)RD_REG( HandlePtr->ADCGrPtr->REFLAG, 
 802136e:	687b      	ldr	r3, [r7, #4]
 8021370:	681b      	ldr	r3, [r3, #0]
 8021372:	f8d3 2184 	ldr.w	r2, [r3, #388]	; 0x184
 8021376:	687b      	ldr	r3, [r7, #4]
 8021378:	7d1b      	ldrb	r3, [r3, #20]
 802137a:	f04f 0101 	mov.w	r1, #1
 802137e:	fa01 f303 	lsl.w	r3, r1, r3
 8021382:	401a      	ands	r2, r3
 8021384:	687b      	ldr	r3, [r7, #4]
 8021386:	7d1b      	ldrb	r3, [r3, #20]
 8021388:	fa22 f303 	lsr.w	r3, r2, r3
 802138c:	b2da      	uxtb	r2, r3
 802138e:	683b      	ldr	r3, [r7, #0]
 8021390:	701a      	strb	r2, [r3, #0]
                        ((uint32_t)0x01 << HandlePtr->kEndResultRegNo), 
                        (uint32_t)HandlePtr->kEndResultRegNo
                 );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021392:	f04f 0300 	mov.w	r3, #0
 8021396:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8021398:	68fb      	ldr	r3, [r7, #12]
}
 802139a:	4618      	mov	r0, r3
 802139c:	f107 0714 	add.w	r7, r7, #20
 80213a0:	46bd      	mov	sp, r7
 80213a2:	bc80      	pop	{r7}
 80213a4:	4770      	bx	lr
 80213a6:	bf00      	nop

080213a8 <ADCCH001_GetChannelEvtFlag>:

/**
 * This function checks whether Channel event flag is set.
 */
status_t ADCCH001_GetChannelEvtFlag(const ADCCH001_HandleType* HandlePtr, uint8_t* EvtStatus)
{
 80213a8:	b480      	push	{r7}
 80213aa:	b085      	sub	sp, #20
 80213ac:	af00      	add	r7, sp, #0
 80213ae:	6078      	str	r0, [r7, #4]
 80213b0:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80213b2:	f04f 0301 	mov.w	r3, #1
 80213b6:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
 80213b8:	687b      	ldr	r3, [r7, #4]
 80213ba:	685b      	ldr	r3, [r3, #4]
 80213bc:	78db      	ldrb	r3, [r3, #3]
 80213be:	2b00      	cmp	r3, #0
 80213c0:	d014      	beq.n	80213ec <ADCCH001_GetChannelEvtFlag+0x44>
  {
    *EvtStatus = (uint8_t)RD_REG(HandlePtr->ADCGrPtr->CEFLAG, 
 80213c2:	687b      	ldr	r3, [r7, #4]
 80213c4:	681b      	ldr	r3, [r3, #0]
 80213c6:	f8d3 2180 	ldr.w	r2, [r3, #384]	; 0x180
 80213ca:	687b      	ldr	r3, [r7, #4]
 80213cc:	7d9b      	ldrb	r3, [r3, #22]
 80213ce:	f04f 0101 	mov.w	r1, #1
 80213d2:	fa01 f303 	lsl.w	r3, r1, r3
 80213d6:	401a      	ands	r2, r3
 80213d8:	687b      	ldr	r3, [r7, #4]
 80213da:	7d9b      	ldrb	r3, [r3, #22]
 80213dc:	fa22 f303 	lsr.w	r3, r2, r3
 80213e0:	b2da      	uxtb	r2, r3
 80213e2:	683b      	ldr	r3, [r7, #0]
 80213e4:	701a      	strb	r2, [r3, #0]
                        ((uint32_t)0x01 << HandlePtr->kChannelNo), 
                        (uint32_t)HandlePtr->kChannelNo
                 );
    Status = (uint32_t)DAVEApp_SUCCESS;
 80213e6:	f04f 0300 	mov.w	r3, #0
 80213ea:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 80213ec:	68fb      	ldr	r3, [r7, #12]
}
 80213ee:	4618      	mov	r0, r3
 80213f0:	f107 0714 	add.w	r7, r7, #20
 80213f4:	46bd      	mov	sp, r7
 80213f6:	bc80      	pop	{r7}
 80213f8:	4770      	bx	lr
 80213fa:	bf00      	nop

080213fc <ADCCH001_SetResultEvtFlag>:

/**
 * This will set the result event flag through software.
 */
status_t ADCCH001_SetResultEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
 80213fc:	b480      	push	{r7}
 80213fe:	b085      	sub	sp, #20
 8021400:	af00      	add	r7, sp, #0
 8021402:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021404:	f04f 0301 	mov.w	r3, #1
 8021408:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802140a:	687b      	ldr	r3, [r7, #4]
 802140c:	685b      	ldr	r3, [r3, #4]
 802140e:	78db      	ldrb	r3, [r3, #3]
 8021410:	2b00      	cmp	r3, #0
 8021412:	d015      	beq.n	8021440 <ADCCH001_SetResultEvtFlag+0x44>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8021414:	687b      	ldr	r3, [r7, #4]
 8021416:	7ddb      	ldrb	r3, [r3, #23]
 */
status_t ADCCH001_SetResultEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021418:	2b00      	cmp	r3, #0
 802141a:	d111      	bne.n	8021440 <ADCCH001_SetResultEvtFlag+0x44>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->REFLAG, 
 802141c:	687b      	ldr	r3, [r7, #4]
 802141e:	681b      	ldr	r3, [r3, #0]
 8021420:	687a      	ldr	r2, [r7, #4]
 8021422:	6812      	ldr	r2, [r2, #0]
 8021424:	f8d2 1184 	ldr.w	r1, [r2, #388]	; 0x184
 8021428:	687a      	ldr	r2, [r7, #4]
 802142a:	7d12      	ldrb	r2, [r2, #20]
 802142c:	f04f 0001 	mov.w	r0, #1
 8021430:	fa00 f202 	lsl.w	r2, r0, r2
 8021434:	430a      	orrs	r2, r1
 8021436:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
             HandlePtr->kEndResultRegNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 802143a:	f04f 0300 	mov.w	r3, #0
 802143e:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8021440:	68fb      	ldr	r3, [r7, #12]
}
 8021442:	4618      	mov	r0, r3
 8021444:	f107 0714 	add.w	r7, r7, #20
 8021448:	46bd      	mov	sp, r7
 802144a:	bc80      	pop	{r7}
 802144c:	4770      	bx	lr
 802144e:	bf00      	nop

08021450 <ADCCH001_SetChannelEvtFlag>:

/**
 * This will set the channel event flagv through software
 */
status_t ADCCH001_SetChannelEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
 8021450:	b480      	push	{r7}
 8021452:	b085      	sub	sp, #20
 8021454:	af00      	add	r7, sp, #0
 8021456:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021458:	f04f 0301 	mov.w	r3, #1
 802145c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
 802145e:	687b      	ldr	r3, [r7, #4]
 8021460:	685b      	ldr	r3, [r3, #4]
 8021462:	78db      	ldrb	r3, [r3, #3]
 8021464:	2b00      	cmp	r3, #0
 8021466:	d011      	beq.n	802148c <ADCCH001_SetChannelEvtFlag+0x3c>
  {
    SET_BIT( HandlePtr->ADCGrPtr->CEFLAG, 
 8021468:	687b      	ldr	r3, [r7, #4]
 802146a:	681b      	ldr	r3, [r3, #0]
 802146c:	687a      	ldr	r2, [r7, #4]
 802146e:	6812      	ldr	r2, [r2, #0]
 8021470:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
 8021474:	687a      	ldr	r2, [r7, #4]
 8021476:	7d92      	ldrb	r2, [r2, #22]
 8021478:	f04f 0001 	mov.w	r0, #1
 802147c:	fa00 f202 	lsl.w	r2, r0, r2
 8021480:	430a      	orrs	r2, r1
 8021482:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
             HandlePtr->kChannelNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021486:	f04f 0300 	mov.w	r3, #0
 802148a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 802148c:	68fb      	ldr	r3, [r7, #12]
}
 802148e:	4618      	mov	r0, r3
 8021490:	f107 0714 	add.w	r7, r7, #20
 8021494:	46bd      	mov	sp, r7
 8021496:	bc80      	pop	{r7}
 8021498:	4770      	bx	lr
 802149a:	bf00      	nop

0802149c <ADCCH001_ClearResultEvtFlag>:

/**
 * This will clear the pending result event flag
 */
status_t ADCCH001_ClearResultEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
 802149c:	b480      	push	{r7}
 802149e:	b085      	sub	sp, #20
 80214a0:	af00      	add	r7, sp, #0
 80214a2:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80214a4:	f04f 0301 	mov.w	r3, #1
 80214a8:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80214aa:	687b      	ldr	r3, [r7, #4]
 80214ac:	685b      	ldr	r3, [r3, #4]
 80214ae:	78db      	ldrb	r3, [r3, #3]
 80214b0:	2b00      	cmp	r3, #0
 80214b2:	d015      	beq.n	80214e0 <ADCCH001_ClearResultEvtFlag+0x44>
      (HandlePtr->kCompareMode == (uint8_t)0))
 80214b4:	687b      	ldr	r3, [r7, #4]
 80214b6:	7ddb      	ldrb	r3, [r3, #23]
 */
status_t ADCCH001_ClearResultEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80214b8:	2b00      	cmp	r3, #0
 80214ba:	d111      	bne.n	80214e0 <ADCCH001_ClearResultEvtFlag+0x44>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->REFCLR, 
 80214bc:	687b      	ldr	r3, [r7, #4]
 80214be:	681b      	ldr	r3, [r3, #0]
 80214c0:	687a      	ldr	r2, [r7, #4]
 80214c2:	6812      	ldr	r2, [r2, #0]
 80214c4:	f8d2 1194 	ldr.w	r1, [r2, #404]	; 0x194
 80214c8:	687a      	ldr	r2, [r7, #4]
 80214ca:	7d12      	ldrb	r2, [r2, #20]
 80214cc:	f04f 0001 	mov.w	r0, #1
 80214d0:	fa00 f202 	lsl.w	r2, r0, r2
 80214d4:	430a      	orrs	r2, r1
 80214d6:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
             HandlePtr->kEndResultRegNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 80214da:	f04f 0300 	mov.w	r3, #0
 80214de:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 80214e0:	68fb      	ldr	r3, [r7, #12]
}
 80214e2:	4618      	mov	r0, r3
 80214e4:	f107 0714 	add.w	r7, r7, #20
 80214e8:	46bd      	mov	sp, r7
 80214ea:	bc80      	pop	{r7}
 80214ec:	4770      	bx	lr
 80214ee:	bf00      	nop

080214f0 <ADCCH001_ClearChannelEvtFlag>:

/**
 * This will clear the pending channel event flag
 */
status_t ADCCH001_ClearChannelEvtFlag(const ADCCH001_HandleType* HandlePtr)
{
 80214f0:	b480      	push	{r7}
 80214f2:	b085      	sub	sp, #20
 80214f4:	af00      	add	r7, sp, #0
 80214f6:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80214f8:	f04f 0301 	mov.w	r3, #1
 80214fc:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);
  if(HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED)
 80214fe:	687b      	ldr	r3, [r7, #4]
 8021500:	685b      	ldr	r3, [r3, #4]
 8021502:	78db      	ldrb	r3, [r3, #3]
 8021504:	2b00      	cmp	r3, #0
 8021506:	d011      	beq.n	802152c <ADCCH001_ClearChannelEvtFlag+0x3c>
  {
    SET_BIT( HandlePtr->ADCGrPtr->CEFCLR, 
 8021508:	687b      	ldr	r3, [r7, #4]
 802150a:	681b      	ldr	r3, [r3, #0]
 802150c:	687a      	ldr	r2, [r7, #4]
 802150e:	6812      	ldr	r2, [r2, #0]
 8021510:	f8d2 1190 	ldr.w	r1, [r2, #400]	; 0x190
 8021514:	687a      	ldr	r2, [r7, #4]
 8021516:	7d92      	ldrb	r2, [r2, #22]
 8021518:	f04f 0001 	mov.w	r0, #1
 802151c:	fa00 f202 	lsl.w	r2, r0, r2
 8021520:	430a      	orrs	r2, r1
 8021522:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
             HandlePtr->kChannelNo
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021526:	f04f 0300 	mov.w	r3, #0
 802152a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 802152c:	68fb      	ldr	r3, [r7, #12]
}
 802152e:	4618      	mov	r0, r3
 8021530:	f107 0714 	add.w	r7, r7, #20
 8021534:	46bd      	mov	sp, r7
 8021536:	bc80      	pop	{r7}
 8021538:	4770      	bx	lr
 802153a:	bf00      	nop

0802153c <ADCCH001_SetBWDChannel>:

/**
 * This function slects the Broken Wire Detection Channel. 
 */
status_t ADCCH001_SetBWDChannel(const ADCCH001_HandleType* HandlePtr, ADCCH001_BWDType BWDChannel)
{
 802153c:	b490      	push	{r4, r7}
 802153e:	b084      	sub	sp, #16
 8021540:	af00      	add	r7, sp, #0
 8021542:	6078      	str	r0, [r7, #4]
 8021544:	460b      	mov	r3, r1
 8021546:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021548:	f04f 0301 	mov.w	r3, #1
 802154c:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802154e:	687b      	ldr	r3, [r7, #4]
 8021550:	685b      	ldr	r3, [r3, #4]
 8021552:	78db      	ldrb	r3, [r3, #3]
 8021554:	2b00      	cmp	r3, #0
 8021556:	d01e      	beq.n	8021596 <ADCCH001_SetBWDChannel+0x5a>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8021558:	687b      	ldr	r3, [r7, #4]
 802155a:	7ddb      	ldrb	r3, [r3, #23]
status_t ADCCH001_SetBWDChannel(const ADCCH001_HandleType* HandlePtr, ADCCH001_BWDType BWDChannel)
{
  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802155c:	2b00      	cmp	r3, #0
 802155e:	d11a      	bne.n	8021596 <ADCCH001_SetBWDChannel+0x5a>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    WR_REG( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], 
 8021560:	687b      	ldr	r3, [r7, #4]
 8021562:	681b      	ldr	r3, [r3, #0]
 8021564:	687a      	ldr	r2, [r7, #4]
 8021566:	7d92      	ldrb	r2, [r2, #22]
 8021568:	78f9      	ldrb	r1, [r7, #3]
 802156a:	ea4f 7101 	mov.w	r1, r1, lsl #28
 802156e:	f001 5040 	and.w	r0, r1, #805306368	; 0x30000000
 8021572:	6879      	ldr	r1, [r7, #4]
 8021574:	6809      	ldr	r1, [r1, #0]
 8021576:	687c      	ldr	r4, [r7, #4]
 8021578:	7da4      	ldrb	r4, [r4, #22]
 802157a:	f104 0480 	add.w	r4, r4, #128	; 0x80
 802157e:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
 8021582:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 8021586:	4301      	orrs	r1, r0
 8021588:	f102 0280 	add.w	r2, r2, #128	; 0x80
 802158c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
            VADC_G_CHCTR_BWDCH_Msk,
            VADC_G_CHCTR_BWDCH_Pos,
            (uint32_t)BWDChannel
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021590:	f04f 0300 	mov.w	r3, #0
 8021594:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8021596:	68fb      	ldr	r3, [r7, #12]
}
 8021598:	4618      	mov	r0, r3
 802159a:	f107 0710 	add.w	r7, r7, #16
 802159e:	46bd      	mov	sp, r7
 80215a0:	bc90      	pop	{r4, r7}
 80215a2:	4770      	bx	lr

080215a4 <ADCCH001_EnableBWD>:

/**
 * This will enable the Broken Wire Detection feature.
 */
status_t ADCCH001_EnableBWD(const ADCCH001_HandleType* HandlePtr)
{
 80215a4:	b480      	push	{r7}
 80215a6:	b085      	sub	sp, #20
 80215a8:	af00      	add	r7, sp, #0
 80215aa:	6078      	str	r0, [r7, #4]

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80215ac:	f04f 0301 	mov.w	r3, #1
 80215b0:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80215b2:	687b      	ldr	r3, [r7, #4]
 80215b4:	685b      	ldr	r3, [r3, #4]
 80215b6:	78db      	ldrb	r3, [r3, #3]
 80215b8:	2b00      	cmp	r3, #0
 80215ba:	d018      	beq.n	80215ee <ADCCH001_EnableBWD+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
 80215bc:	687b      	ldr	r3, [r7, #4]
 80215be:	7ddb      	ldrb	r3, [r3, #23]
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80215c0:	2b00      	cmp	r3, #0
 80215c2:	d114      	bne.n	80215ee <ADCCH001_EnableBWD+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    SET_BIT( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], 
 80215c4:	687b      	ldr	r3, [r7, #4]
 80215c6:	681b      	ldr	r3, [r3, #0]
 80215c8:	687a      	ldr	r2, [r7, #4]
 80215ca:	7d92      	ldrb	r2, [r2, #22]
 80215cc:	6879      	ldr	r1, [r7, #4]
 80215ce:	6809      	ldr	r1, [r1, #0]
 80215d0:	6878      	ldr	r0, [r7, #4]
 80215d2:	7d80      	ldrb	r0, [r0, #22]
 80215d4:	f100 0080 	add.w	r0, r0, #128	; 0x80
 80215d8:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 80215dc:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 80215e0:	f102 0280 	add.w	r2, r2, #128	; 0x80
 80215e4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
             VADC_G_CHCTR_BWDEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 80215e8:	f04f 0300 	mov.w	r3, #0
 80215ec:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 80215ee:	68fb      	ldr	r3, [r7, #12]
}
 80215f0:	4618      	mov	r0, r3
 80215f2:	f107 0714 	add.w	r7, r7, #20
 80215f6:	46bd      	mov	sp, r7
 80215f8:	bc80      	pop	{r7}
 80215fa:	4770      	bx	lr

080215fc <ADCCH001_DisableBWD>:

/**
 * This will disable the Broken Wire Detection feature.
 */
status_t ADCCH001_DisableBWD(const ADCCH001_HandleType* HandlePtr)
{
 80215fc:	b480      	push	{r7}
 80215fe:	b085      	sub	sp, #20
 8021600:	af00      	add	r7, sp, #0
 8021602:	6078      	str	r0, [r7, #4]

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 8021604:	f04f 0301 	mov.w	r3, #1
 8021608:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 802160a:	687b      	ldr	r3, [r7, #4]
 802160c:	685b      	ldr	r3, [r3, #4]
 802160e:	78db      	ldrb	r3, [r3, #3]
 8021610:	2b00      	cmp	r3, #0
 8021612:	d018      	beq.n	8021646 <ADCCH001_DisableBWD+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
 8021614:	687b      	ldr	r3, [r7, #4]
 8021616:	7ddb      	ldrb	r3, [r3, #23]
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021618:	2b00      	cmp	r3, #0
 802161a:	d114      	bne.n	8021646 <ADCCH001_DisableBWD+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
    CLR_BIT( HandlePtr->ADCGrPtr->CHCTR[HandlePtr->kChannelNo], 
 802161c:	687b      	ldr	r3, [r7, #4]
 802161e:	681b      	ldr	r3, [r3, #0]
 8021620:	687a      	ldr	r2, [r7, #4]
 8021622:	7d92      	ldrb	r2, [r2, #22]
 8021624:	6879      	ldr	r1, [r7, #4]
 8021626:	6809      	ldr	r1, [r1, #0]
 8021628:	6878      	ldr	r0, [r7, #4]
 802162a:	7d80      	ldrb	r0, [r0, #22]
 802162c:	f100 0080 	add.w	r0, r0, #128	; 0x80
 8021630:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 8021634:	f021 4180 	bic.w	r1, r1, #1073741824	; 0x40000000
 8021638:	f102 0280 	add.w	r2, r2, #128	; 0x80
 802163c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
             VADC_G_CHCTR_BWDEN_Pos
           );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021640:	f04f 0300 	mov.w	r3, #0
 8021644:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 8021646:	68fb      	ldr	r3, [r7, #12]
}
 8021648:	4618      	mov	r0, r3
 802164a:	f107 0714 	add.w	r7, r7, #20
 802164e:	46bd      	mov	sp, r7
 8021650:	bc80      	pop	{r7}
 8021652:	4770      	bx	lr

08021654 <ADCCH001_EnableWaitForRead>:

/**
 * This will enable wait for read mode of the result register
 */
status_t ADCCH001_EnableWaitForRead(const ADCCH001_HandleType* HandlePtr)
{
 8021654:	b480      	push	{r7}
 8021656:	b085      	sub	sp, #20
 8021658:	af00      	add	r7, sp, #0
 802165a:	6078      	str	r0, [r7, #4]

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 802165c:	f04f 0301 	mov.w	r3, #1
 8021660:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021662:	687b      	ldr	r3, [r7, #4]
 8021664:	685b      	ldr	r3, [r3, #4]
 8021666:	78db      	ldrb	r3, [r3, #3]
 8021668:	2b00      	cmp	r3, #0
 802166a:	d018      	beq.n	802169e <ADCCH001_EnableWaitForRead+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
 802166c:	687b      	ldr	r3, [r7, #4]
 802166e:	7ddb      	ldrb	r3, [r3, #23]
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 8021670:	2b00      	cmp	r3, #0
 8021672:	d114      	bne.n	802169e <ADCCH001_EnableWaitForRead+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
      WR_REG( HandlePtr->ADCGrPtr->RCR[HandlePtr->kStartResultRegNo],
 8021674:	687b      	ldr	r3, [r7, #4]
 8021676:	681b      	ldr	r3, [r3, #0]
 8021678:	687a      	ldr	r2, [r7, #4]
 802167a:	7cd2      	ldrb	r2, [r2, #19]
 802167c:	6879      	ldr	r1, [r7, #4]
 802167e:	6809      	ldr	r1, [r1, #0]
 8021680:	6878      	ldr	r0, [r7, #4]
 8021682:	7cc0      	ldrb	r0, [r0, #19]
 8021684:	f100 00a0 	add.w	r0, r0, #160	; 0xa0
 8021688:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 802168c:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8021690:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 8021694:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              VADC_G_RCR_WFR_Msk,
              VADC_G_RCR_WFR_Pos,
              (uint32_t)0x1
             );
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021698:	f04f 0300 	mov.w	r3, #0
 802169c:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 802169e:	68fb      	ldr	r3, [r7, #12]
}
 80216a0:	4618      	mov	r0, r3
 80216a2:	f107 0714 	add.w	r7, r7, #20
 80216a6:	46bd      	mov	sp, r7
 80216a8:	bc80      	pop	{r7}
 80216aa:	4770      	bx	lr

080216ac <ADCCH001_DisableWaitForRead>:

/**
 * This will disable wait for read mode of the result register
 */
status_t ADCCH001_DisableWaitForRead(const ADCCH001_HandleType* HandlePtr)
{
 80216ac:	b480      	push	{r7}
 80216ae:	b085      	sub	sp, #20
 80216b0:	af00      	add	r7, sp, #0
 80216b2:	6078      	str	r0, [r7, #4]

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
 80216b4:	f04f 0301 	mov.w	r3, #1
 80216b8:	60fb      	str	r3, [r7, #12]
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80216ba:	687b      	ldr	r3, [r7, #4]
 80216bc:	685b      	ldr	r3, [r3, #4]
 80216be:	78db      	ldrb	r3, [r3, #3]
 80216c0:	2b00      	cmp	r3, #0
 80216c2:	d018      	beq.n	80216f6 <ADCCH001_DisableWaitForRead+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
 80216c4:	687b      	ldr	r3, [r7, #4]
 80216c6:	7ddb      	ldrb	r3, [r3, #23]
{

  status_t Status = (uint32_t)ADCCH001_OPERATION_NOT_ALLOWED;
  FUNCTION_ENTRY(GID_ADCCH001, (uint32_t)ADCCH001_FUN_ENTRY);

  if((HandlePtr->DynamicHandlePtr->State != ADCCH001_UNINITIALIZED) &&
 80216c8:	2b00      	cmp	r3, #0
 80216ca:	d114      	bne.n	80216f6 <ADCCH001_DisableWaitForRead+0x4a>
      (HandlePtr->kCompareMode == (uint8_t)0))
  {
      WR_REG( HandlePtr->ADCGrPtr->RCR[HandlePtr->kStartResultRegNo],
 80216cc:	687b      	ldr	r3, [r7, #4]
 80216ce:	681b      	ldr	r3, [r3, #0]
 80216d0:	687a      	ldr	r2, [r7, #4]
 80216d2:	7cd2      	ldrb	r2, [r2, #19]
 80216d4:	6879      	ldr	r1, [r7, #4]
 80216d6:	6809      	ldr	r1, [r1, #0]
 80216d8:	6878      	ldr	r0, [r7, #4]
 80216da:	7cc0      	ldrb	r0, [r0, #19]
 80216dc:	f100 00a0 	add.w	r0, r0, #160	; 0xa0
 80216e0:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 80216e4:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 80216e8:	f102 02a0 	add.w	r2, r2, #160	; 0xa0
 80216ec:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
              VADC_G_RCR_WFR_Msk,
              VADC_G_RCR_WFR_Pos,
              (uint32_t)0x0
             );
    Status = (uint32_t)DAVEApp_SUCCESS;
 80216f0:	f04f 0300 	mov.w	r3, #0
 80216f4:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADCCH001, (uint8_t)Status, 0, (uint8_t*) NULL);    
  }

  FUNCTION_EXIT(GID_ADCCH001, (uint32_t)ADCCH001_FUN_EXIT);  
  return Status;
 80216f6:	68fb      	ldr	r3, [r7, #12]
}
 80216f8:	4618      	mov	r0, r3
 80216fa:	f107 0714 	add.w	r7, r7, #20
 80216fe:	46bd      	mov	sp, r7
 8021700:	bc80      	pop	{r7}
 8021702:	4770      	bx	lr

08021704 <ADC002_Init>:



/** This function initializes the app */
void ADC002_Init(void)
{
 8021704:	b580      	push	{r7, lr}
 8021706:	af00      	add	r7, sp, #0
   /*Initialization of app 'ADCGLOB001'*/         
  ADCGLOB001_Init();  
 8021708:	f7fe fca8 	bl	802005c <ADCGLOB001_Init>
  ADC002_lInit(&ADC002_Handle0);    
 802170c:	f646 00e4 	movw	r0, #26852	; 0x68e4
 8021710:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021714:	f000 f802 	bl	802171c <ADC002_lInit>
}
 8021718:	bd80      	pop	{r7, pc}
 802171a:	bf00      	nop

0802171c <ADC002_lInit>:
/* 
 * This function initializes the queue App. Local function is used to 
 * initialize all the instances of the app.
 */
static void ADC002_lInit(const ADC002_HandleType *HandlePtr )
{
 802171c:	b480      	push	{r7}
 802171e:	b085      	sub	sp, #20
 8021720:	af00      	add	r7, sp, #0
 8021722:	6078      	str	r0, [r7, #4]
  /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021724:	687b      	ldr	r3, [r7, #4]
 8021726:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021728:	60fb      	str	r3, [r7, #12]
  
  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_UNINITIALIZED)
 802172a:	687b      	ldr	r3, [r7, #4]
 802172c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802172e:	781b      	ldrb	r3, [r3, #0]
 8021730:	2b00      	cmp	r3, #0
 8021732:	d15a      	bne.n	80217ea <ADC002_lInit+0xce>
  {
    /* Flush the Queue */
    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_FLUSH_Pos);
 8021734:	68fb      	ldr	r3, [r7, #12]
 8021736:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 802173a:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 802173e:	68fb      	ldr	r3, [r7, #12]
 8021740:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    
    /* Sets the priority of the queue request source */
    WR_REG( VADCGroupPtr->ARBPR, VADC_G_ARBPR_PRIO0_Msk, 
 8021744:	687b      	ldr	r3, [r7, #4]
 8021746:	7adb      	ldrb	r3, [r3, #11]
 8021748:	f003 0203 	and.w	r2, r3, #3
 802174c:	68fb      	ldr	r3, [r7, #12]
 802174e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8021752:	f023 0303 	bic.w	r3, r3, #3
 8021756:	431a      	orrs	r2, r3
 8021758:	68fb      	ldr	r3, [r7, #12]
 802175a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            VADC_G_ARBPR_PRIO0_Pos,(uint32_t)HandlePtr->kPriority);                                                        
    /*
     * Enable XTWC Bitfield so that XTMODE and XTSEL can be written 
     * Selects trigger mode .
     */
    VADCGroupPtr->QCTRL0 |= (uint32_t)
 802175e:	68fb      	ldr	r3, [r7, #12]
 8021760:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
        ((((uint32_t)1 << VADC_G_QCTRL0_XTWC_Pos) & VADC_G_QCTRL0_XTWC_Msk)|\
        (((uint32_t)HandlePtr->kTriggerMode << VADC_G_QCTRL0_XTMODE_Pos) &\
 8021764:	687b      	ldr	r3, [r7, #4]
 8021766:	7a9b      	ldrb	r3, [r3, #10]
 8021768:	ea4f 3343 	mov.w	r3, r3, lsl #13
 802176c:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
            VADC_G_ARBPR_PRIO0_Pos,(uint32_t)HandlePtr->kPriority);                                                        
    /*
     * Enable XTWC Bitfield so that XTMODE and XTSEL can be written 
     * Selects trigger mode .
     */
    VADCGroupPtr->QCTRL0 |= (uint32_t)
 8021770:	4313      	orrs	r3, r2
 8021772:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8021776:	68fb      	ldr	r3, [r7, #12]
 8021778:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
        (((uint32_t)HandlePtr->kTriggerMode << VADC_G_QCTRL0_XTMODE_Pos) &\
         VADC_G_QCTRL0_XTMODE_Msk));
    /*
     *Selects the gating mode and enables trigger mode
     */
    VADCGroupPtr->QMR0 |=(uint32_t)
 802177c:	68fb      	ldr	r3, [r7, #12]
 802177e:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        ((((uint32_t)HandlePtr->kTriggerEn << VADC_G_QMR0_ENTR_Pos)& VADC_G_QMR0_ENTR_Msk)|\
 8021782:	687b      	ldr	r3, [r7, #4]
 8021784:	7a5b      	ldrb	r3, [r3, #9]
 8021786:	ea4f 0383 	mov.w	r3, r3, lsl #2
 802178a:	f003 0104 	and.w	r1, r3, #4
        (((uint32_t)HandlePtr->kGatingMode << VADC_G_QMR0_ENGT_Pos)& VADC_G_QMR0_ENGT_Msk));
 802178e:	687b      	ldr	r3, [r7, #4]
 8021790:	7a1b      	ldrb	r3, [r3, #8]
 8021792:	f003 0303 	and.w	r3, r3, #3
        (((uint32_t)HandlePtr->kTriggerMode << VADC_G_QCTRL0_XTMODE_Pos) &\
         VADC_G_QCTRL0_XTMODE_Msk));
    /*
     *Selects the gating mode and enables trigger mode
     */
    VADCGroupPtr->QMR0 |=(uint32_t)
 8021796:	430b      	orrs	r3, r1
 8021798:	431a      	orrs	r2, r3
 802179a:	68fb      	ldr	r3, [r7, #12]
 802179c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
        (((uint32_t)HandlePtr->kGatingMode << VADC_G_QMR0_ENGT_Pos)& VADC_G_QMR0_ENGT_Msk));
    /*
     * Enable Arbitration slot.
     * Select conversion start mode for request source. 
     */
    VADCGroupPtr->ARBPR |= (uint32_t)
 80217a0:	68fb      	ldr	r3, [r7, #12]
 80217a2:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
        ((((uint32_t)HandlePtr->kAsenEnable << VADC_G_ARBPR_ASEN0_Pos)&VADC_G_ARBPR_ASEN0_Msk)|\
 80217a6:	687b      	ldr	r3, [r7, #4]
 80217a8:	7b5b      	ldrb	r3, [r3, #13]
 80217aa:	ea4f 6303 	mov.w	r3, r3, lsl #24
 80217ae:	f003 7180 	and.w	r1, r3, #16777216	; 0x1000000
        (((uint32_t)HandlePtr->kStartmode << VADC_G_ARBPR_CSM0_Pos) & VADC_G_ARBPR_CSM0_Msk));
 80217b2:	687b      	ldr	r3, [r7, #4]
 80217b4:	7b1b      	ldrb	r3, [r3, #12]
 80217b6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80217ba:	f003 0308 	and.w	r3, r3, #8
        (((uint32_t)HandlePtr->kGatingMode << VADC_G_QMR0_ENGT_Pos)& VADC_G_QMR0_ENGT_Msk));
    /*
     * Enable Arbitration slot.
     * Select conversion start mode for request source. 
     */
    VADCGroupPtr->ARBPR |= (uint32_t)
 80217be:	430b      	orrs	r3, r1
 80217c0:	431a      	orrs	r2, r3
 80217c2:	68fb      	ldr	r3, [r7, #12]
 80217c4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        (((uint32_t)HandlePtr->kStartmode << VADC_G_ARBPR_CSM0_Pos) & VADC_G_ARBPR_CSM0_Msk));
    /*
     * Enable cancel mode.
     * Sets the bit rptdis of QMR0 Register 
     */
    if(HandlePtr->kStartmode == (uint8_t)ADC002_CANCEL_INJECT_REPEAT_WITH_CANCEL)
 80217c8:	687b      	ldr	r3, [r7, #4]
 80217ca:	7b1b      	ldrb	r3, [r3, #12]
 80217cc:	2b02      	cmp	r3, #2
 80217ce:	d107      	bne.n	80217e0 <ADC002_lInit+0xc4>
    {
      SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_RPTDIS_Pos);
 80217d0:	68fb      	ldr	r3, [r7, #12]
 80217d2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80217d6:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80217da:	68fb      	ldr	r3, [r7, #12]
 80217dc:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    }
    /* Set the App State to Initialized */
    HandlePtr->DynamicHandlePtr->State = ADC002_INITIALIZED;                            
 80217e0:	687b      	ldr	r3, [r7, #4]
 80217e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80217e4:	f04f 0201 	mov.w	r2, #1
 80217e8:	701a      	strb	r2, [r3, #0]
  else
  {
    ERROR(GID_ADC002, (uint8_t)ADC002_OPER_NOT_ALLOWED_ERROR, 0, (uint8_t*)NULL);
  }
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
}
 80217ea:	f107 0714 	add.w	r7, r7, #20
 80217ee:	46bd      	mov	sp, r7
 80217f0:	bc80      	pop	{r7}
 80217f2:	4770      	bx	lr

080217f4 <ADC002_InitializeQueue>:
/*This function initializes queue entries*/
status_t ADC002_InitializeQueue(const ADC002_HandleType *HandlePtr )
{
 80217f4:	b480      	push	{r7}
 80217f6:	b087      	sub	sp, #28
 80217f8:	af00      	add	r7, sp, #0
 80217fa:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 80217fc:	f04f 0301 	mov.w	r3, #1
 8021800:	617b      	str	r3, [r7, #20]

  /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021802:	687b      	ldr	r3, [r7, #4]
 8021804:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021806:	60fb      	str	r3, [r7, #12]
  uint8_t QueueEntryNum;
  uint32_t QINR0Val;

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);
  
  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021808:	687b      	ldr	r3, [r7, #4]
 802180a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802180c:	781b      	ldrb	r3, [r3, #0]
 802180e:	2b01      	cmp	r3, #1
 8021810:	d16a      	bne.n	80218e8 <ADC002_InitializeQueue+0xf4>
  { 
   /* Inserts the selected entries to the Queue. */
    for(QueueEntryNum = (uint8_t)0; QueueEntryNum <= (uint8_t)7; QueueEntryNum++)
 8021812:	f04f 0300 	mov.w	r3, #0
 8021816:	74fb      	strb	r3, [r7, #19]
 8021818:	e051      	b.n	80218be <ADC002_InitializeQueue+0xca>
    {
      /* Register the queue entry */
      if((&HandlePtr->kQueueEntryHandlePtr[QueueEntryNum] != NULL) &&
 802181a:	687b      	ldr	r3, [r7, #4]
 802181c:	6859      	ldr	r1, [r3, #4]
 802181e:	7cfa      	ldrb	r2, [r7, #19]
 8021820:	4613      	mov	r3, r2
 8021822:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8021826:	189b      	adds	r3, r3, r2
 8021828:	18cb      	adds	r3, r1, r3
 802182a:	2b00      	cmp	r3, #0
 802182c:	d043      	beq.n	80218b6 <ADC002_InitializeQueue+0xc2>
        (HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Active == (uint8_t)1))
 802182e:	687b      	ldr	r3, [r7, #4]
 8021830:	6859      	ldr	r1, [r3, #4]
 8021832:	7cfa      	ldrb	r2, [r7, #19]
 8021834:	4613      	mov	r3, r2
 8021836:	ea4f 0383 	mov.w	r3, r3, lsl #2
 802183a:	189b      	adds	r3, r3, r2
 802183c:	18cb      	adds	r3, r1, r3
 802183e:	781b      	ldrb	r3, [r3, #0]
  { 
   /* Inserts the selected entries to the Queue. */
    for(QueueEntryNum = (uint8_t)0; QueueEntryNum <= (uint8_t)7; QueueEntryNum++)
    {
      /* Register the queue entry */
      if((&HandlePtr->kQueueEntryHandlePtr[QueueEntryNum] != NULL) &&
 8021840:	2b01      	cmp	r3, #1
 8021842:	d138      	bne.n	80218b6 <ADC002_InitializeQueue+0xc2>
        (HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Active == (uint8_t)1))
      {
        QINR0Val = (uint32_t) 
             ((((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].ChannelNumber\
 8021844:	687b      	ldr	r3, [r7, #4]
 8021846:	6859      	ldr	r1, [r3, #4]
 8021848:	7cfa      	ldrb	r2, [r7, #19]
 802184a:	4613      	mov	r3, r2
 802184c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8021850:	189b      	adds	r3, r3, r2
 8021852:	18cb      	adds	r3, r1, r3
 8021854:	785b      	ldrb	r3, [r3, #1]
                   << VADC_G_QINR0_REQCHNR_Pos) &VADC_G_QINR0_REQCHNR_Msk ) |\
 8021856:	f003 011f 	and.w	r1, r3, #31
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Refill\
 802185a:	687b      	ldr	r3, [r7, #4]
 802185c:	6858      	ldr	r0, [r3, #4]
 802185e:	7cfa      	ldrb	r2, [r7, #19]
 8021860:	4613      	mov	r3, r2
 8021862:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8021866:	189b      	adds	r3, r3, r2
 8021868:	18c3      	adds	r3, r0, r3
 802186a:	789b      	ldrb	r3, [r3, #2]
                   << VADC_G_QINR0_RF_Pos) &VADC_G_QINR0_RF_Msk)|\
 802186c:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8021870:	f003 0320 	and.w	r3, r3, #32
      if((&HandlePtr->kQueueEntryHandlePtr[QueueEntryNum] != NULL) &&
        (HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Active == (uint8_t)1))
      {
        QINR0Val = (uint32_t) 
             ((((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].ChannelNumber\
                   << VADC_G_QINR0_REQCHNR_Pos) &VADC_G_QINR0_REQCHNR_Msk ) |\
 8021874:	4319      	orrs	r1, r3
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Refill\
                   << VADC_G_QINR0_RF_Pos) &VADC_G_QINR0_RF_Msk)|\
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Interrupt\
 8021876:	687b      	ldr	r3, [r7, #4]
 8021878:	6858      	ldr	r0, [r3, #4]
 802187a:	7cfa      	ldrb	r2, [r7, #19]
 802187c:	4613      	mov	r3, r2
 802187e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8021882:	189b      	adds	r3, r3, r2
 8021884:	18c3      	adds	r3, r0, r3
 8021886:	791b      	ldrb	r3, [r3, #4]
                   << VADC_G_QINR0_ENSI_Pos) &VADC_G_QINR0_ENSI_Msk )     |\
 8021888:	ea4f 1383 	mov.w	r3, r3, lsl #6
 802188c:	f003 0340 	and.w	r3, r3, #64	; 0x40
      {
        QINR0Val = (uint32_t) 
             ((((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].ChannelNumber\
                   << VADC_G_QINR0_REQCHNR_Pos) &VADC_G_QINR0_REQCHNR_Msk ) |\
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Refill\
                   << VADC_G_QINR0_RF_Pos) &VADC_G_QINR0_RF_Msk)|\
 8021890:	4319      	orrs	r1, r3
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Interrupt\
                   << VADC_G_QINR0_ENSI_Pos) &VADC_G_QINR0_ENSI_Msk )     |\
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].ExternalTrigger\
 8021892:	687b      	ldr	r3, [r7, #4]
 8021894:	6858      	ldr	r0, [r3, #4]
 8021896:	7cfa      	ldrb	r2, [r7, #19]
 8021898:	4613      	mov	r3, r2
 802189a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 802189e:	189b      	adds	r3, r3, r2
 80218a0:	18c3      	adds	r3, r0, r3
 80218a2:	78db      	ldrb	r3, [r3, #3]
                   << VADC_G_QINR0_EXTR_Pos) & VADC_G_QINR0_EXTR_Msk))  ;
 80218a4:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 80218a8:	b2db      	uxtb	r3, r3
    {
      /* Register the queue entry */
      if((&HandlePtr->kQueueEntryHandlePtr[QueueEntryNum] != NULL) &&
        (HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Active == (uint8_t)1))
      {
        QINR0Val = (uint32_t) 
 80218aa:	430b      	orrs	r3, r1
 80218ac:	60bb      	str	r3, [r7, #8]
                   << VADC_G_QINR0_RF_Pos) &VADC_G_QINR0_RF_Msk)|\
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].Interrupt\
                   << VADC_G_QINR0_ENSI_Pos) &VADC_G_QINR0_ENSI_Msk )     |\
             (((uint32_t)HandlePtr->kQueueEntryHandlePtr[QueueEntryNum].ExternalTrigger\
                   << VADC_G_QINR0_EXTR_Pos) & VADC_G_QINR0_EXTR_Msk))  ;
        VADCGroupPtr->QINR0 = QINR0Val;
 80218ae:	68fb      	ldr	r3, [r7, #12]
 80218b0:	68ba      	ldr	r2, [r7, #8]
 80218b2:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);
  
  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
  { 
   /* Inserts the selected entries to the Queue. */
    for(QueueEntryNum = (uint8_t)0; QueueEntryNum <= (uint8_t)7; QueueEntryNum++)
 80218b6:	7cfb      	ldrb	r3, [r7, #19]
 80218b8:	f103 0301 	add.w	r3, r3, #1
 80218bc:	74fb      	strb	r3, [r7, #19]
 80218be:	7cfb      	ldrb	r3, [r7, #19]
 80218c0:	2b07      	cmp	r3, #7
 80218c2:	d9aa      	bls.n	802181a <ADC002_InitializeQueue+0x26>
        VADCGroupPtr->QINR0 = QINR0Val;
      }
    }
    
    /* Generate a trigger event by software */
    WR_REG(VADCGroupPtr->QMR0, VADC_G_QMR0_TREV_Msk, VADC_G_QMR0_TREV_Pos,
 80218c4:	687b      	ldr	r3, [r7, #4]
 80218c6:	7b9b      	ldrb	r3, [r3, #14]
 80218c8:	ea4f 2343 	mov.w	r3, r3, lsl #9
 80218cc:	f403 7200 	and.w	r2, r3, #512	; 0x200
 80218d0:	68fb      	ldr	r3, [r7, #12]
 80218d2:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80218d6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80218da:	431a      	orrs	r2, r3
 80218dc:	68fb      	ldr	r3, [r7, #12]
 80218de:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
                                                 (uint32_t)HandlePtr->kStart);
  
    Status = (uint32_t)DAVEApp_SUCCESS;
 80218e2:	f04f 0300 	mov.w	r3, #0
 80218e6:	617b      	str	r3, [r7, #20]
  else
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 80218e8:	697b      	ldr	r3, [r7, #20]
}
 80218ea:	4618      	mov	r0, r3
 80218ec:	f107 071c 	add.w	r7, r7, #28
 80218f0:	46bd      	mov	sp, r7
 80218f2:	bc80      	pop	{r7}
 80218f4:	4770      	bx	lr
 80218f6:	bf00      	nop

080218f8 <ADC002_Deinit>:


/* This function resets the ADC002 app */
status_t ADC002_Deinit(const ADC002_HandleType *HandlePtr )
{
 80218f8:	b480      	push	{r7}
 80218fa:	b085      	sub	sp, #20
 80218fc:	af00      	add	r7, sp, #0
 80218fe:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021900:	f04f 0301 	mov.w	r3, #1
 8021904:	60fb      	str	r3, [r7, #12]

    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021906:	687b      	ldr	r3, [r7, #4]
 8021908:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802190a:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);
  
  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 802190c:	687b      	ldr	r3, [r7, #4]
 802190e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021910:	781b      	ldrb	r3, [r3, #0]
 8021912:	2b01      	cmp	r3, #1
 8021914:	d12e      	bne.n	8021974 <ADC002_Deinit+0x7c>
  { 
    /* Reset the queue input Register */
     VADCGroupPtr->QINR0 = (uint32_t)0x00000000; 
 8021916:	68bb      	ldr	r3, [r7, #8]
 8021918:	f04f 0200 	mov.w	r2, #0
 802191c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
      
    /* Reset ARBPR Register */
     VADCGroupPtr->ARBPR &= (uint32_t)0x06000BB4;
 8021920:	68bb      	ldr	r3, [r7, #8]
 8021922:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8021926:	f640 33b4 	movw	r3, #2996	; 0xbb4
 802192a:	f2c0 6300 	movt	r3, #1536	; 0x600
 802192e:	4013      	ands	r3, r2
 8021930:	68ba      	ldr	r2, [r7, #8]
 8021932:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  
    /* Reset QCTRL0 Register*/
    /* set write control bit and clear other bits*/
     VADCGroupPtr->QCTRL0 = (uint32_t)0x80008000;
 8021936:	68bb      	ldr	r3, [r7, #8]
 8021938:	f04f 2280 	mov.w	r2, #2147516416	; 0x80008000
 802193c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
     
    /* Flush the Queue */
     SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_FLUSH_Pos);
 8021940:	68bb      	ldr	r3, [r7, #8]
 8021942:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021946:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 802194a:	68bb      	ldr	r3, [r7, #8]
 802194c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    
    /* Reset QMR0 Register */
    VADCGroupPtr->QMR0 = (uint32_t)0x00000000;
 8021950:	68bb      	ldr	r3, [r7, #8]
 8021952:	f04f 0200 	mov.w	r2, #0
 8021956:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    
    /* Reset the source event flag */
    VADCGroupPtr->SEFCLR = (uint32_t)0x1;
 802195a:	68bb      	ldr	r3, [r7, #8]
 802195c:	f04f 0201 	mov.w	r2, #1
 8021960:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    
    /* Set the App State to Uninitialized */
    HandlePtr->DynamicHandlePtr->State = ADC002_UNINITIALIZED;
 8021964:	687b      	ldr	r3, [r7, #4]
 8021966:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021968:	f04f 0200 	mov.w	r2, #0
 802196c:	701a      	strb	r2, [r3, #0]
  
    Status = (uint32_t)DAVEApp_SUCCESS;
 802196e:	f04f 0300 	mov.w	r3, #0
 8021972:	60fb      	str	r3, [r7, #12]
  else
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021974:	68fb      	ldr	r3, [r7, #12]
}
 8021976:	4618      	mov	r0, r3
 8021978:	f107 0714 	add.w	r7, r7, #20
 802197c:	46bd      	mov	sp, r7
 802197e:	bc80      	pop	{r7}
 8021980:	4770      	bx	lr
 8021982:	bf00      	nop

08021984 <ADC002_ClearEvent>:


/* This function clears the Event flag. */
status_t ADC002_ClearEvent(const ADC002_HandleType *HandlePtr)
{
 8021984:	b480      	push	{r7}
 8021986:	b085      	sub	sp, #20
 8021988:	af00      	add	r7, sp, #0
 802198a:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 802198c:	f04f 0301 	mov.w	r3, #1
 8021990:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021992:	687b      	ldr	r3, [r7, #4]
 8021994:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021996:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021998:	687b      	ldr	r3, [r7, #4]
 802199a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802199c:	781b      	ldrb	r3, [r3, #0]
 802199e:	2b01      	cmp	r3, #1
 80219a0:	d10a      	bne.n	80219b8 <ADC002_ClearEvent+0x34>
  {
    /* Clear event flag */
    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_CEV_Pos);
 80219a2:	68bb      	ldr	r3, [r7, #8]
 80219a4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80219a8:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 80219ac:	68bb      	ldr	r3, [r7, #8]
 80219ae:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  
    Status = (uint32_t)DAVEApp_SUCCESS;
 80219b2:	f04f 0300 	mov.w	r3, #0
 80219b6:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 80219b8:	68fb      	ldr	r3, [r7, #12]
}
 80219ba:	4618      	mov	r0, r3
 80219bc:	f107 0714 	add.w	r7, r7, #20
 80219c0:	46bd      	mov	sp, r7
 80219c2:	bc80      	pop	{r7}
 80219c4:	4770      	bx	lr
 80219c6:	bf00      	nop

080219c8 <ADC002_FlushQueue>:


/* This function clears the queue entries. */
status_t ADC002_FlushQueue(const ADC002_HandleType *HandlePtr)
{
 80219c8:	b480      	push	{r7}
 80219ca:	b085      	sub	sp, #20
 80219cc:	af00      	add	r7, sp, #0
 80219ce:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 80219d0:	f04f 0301 	mov.w	r3, #1
 80219d4:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 80219d6:	687b      	ldr	r3, [r7, #4]
 80219d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80219da:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 80219dc:	687b      	ldr	r3, [r7, #4]
 80219de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80219e0:	781b      	ldrb	r3, [r3, #0]
 80219e2:	2b01      	cmp	r3, #1
 80219e4:	d10a      	bne.n	80219fc <ADC002_FlushQueue+0x34>
  {
    /* Clear the queue entries */
    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_FLUSH_Pos);
 80219e6:	68bb      	ldr	r3, [r7, #8]
 80219e8:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80219ec:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 80219f0:	68bb      	ldr	r3, [r7, #8]
 80219f2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    Status = (uint32_t)DAVEApp_SUCCESS;    
 80219f6:	f04f 0300 	mov.w	r3, #0
 80219fa:	60fb      	str	r3, [r7, #12]
  {
      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 80219fc:	68fb      	ldr	r3, [r7, #12]
}
 80219fe:	4618      	mov	r0, r3
 8021a00:	f107 0714 	add.w	r7, r7, #20
 8021a04:	46bd      	mov	sp, r7
 8021a06:	bc80      	pop	{r7}
 8021a08:	4770      	bx	lr
 8021a0a:	bf00      	nop

08021a0c <ADC002_TriggerEvent>:


/* This function generates a trigger event.*/
status_t ADC002_TriggerEvent(const ADC002_HandleType *HandlePtr)
{
 8021a0c:	b480      	push	{r7}
 8021a0e:	b085      	sub	sp, #20
 8021a10:	af00      	add	r7, sp, #0
 8021a12:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021a14:	f04f 0301 	mov.w	r3, #1
 8021a18:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021a1a:	687b      	ldr	r3, [r7, #4]
 8021a1c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021a1e:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021a20:	687b      	ldr	r3, [r7, #4]
 8021a22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021a24:	781b      	ldrb	r3, [r3, #0]
 8021a26:	2b01      	cmp	r3, #1
 8021a28:	d10a      	bne.n	8021a40 <ADC002_TriggerEvent+0x34>
  {
    /* Generate a trigger event */
    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_TREV_Pos);
 8021a2a:	68bb      	ldr	r3, [r7, #8]
 8021a2c:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021a30:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8021a34:	68bb      	ldr	r3, [r7, #8]
 8021a36:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021a3a:	f04f 0300 	mov.w	r3, #0
 8021a3e:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021a40:	68fb      	ldr	r3, [r7, #12]
}
 8021a42:	4618      	mov	r0, r3
 8021a44:	f107 0714 	add.w	r7, r7, #20
 8021a48:	46bd      	mov	sp, r7
 8021a4a:	bc80      	pop	{r7}
 8021a4c:	4770      	bx	lr
 8021a4e:	bf00      	nop

08021a50 <ADC002_ClearValidBit>:
/*
 * This function clears the next pending valid queue entry in the
 * sequence and the event flag EV.
 */
status_t ADC002_ClearValidBit(const ADC002_HandleType *HandlePtr)
{
 8021a50:	b480      	push	{r7}
 8021a52:	b085      	sub	sp, #20
 8021a54:	af00      	add	r7, sp, #0
 8021a56:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021a58:	f04f 0301 	mov.w	r3, #1
 8021a5c:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021a5e:	687b      	ldr	r3, [r7, #4]
 8021a60:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021a62:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021a64:	687b      	ldr	r3, [r7, #4]
 8021a66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021a68:	781b      	ldrb	r3, [r3, #0]
 8021a6a:	2b01      	cmp	r3, #1
 8021a6c:	d10a      	bne.n	8021a84 <ADC002_ClearValidBit+0x34>
  {
    /* Generate a trigger event */
    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_CLRV_Pos);
 8021a6e:	68bb      	ldr	r3, [r7, #8]
 8021a70:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021a74:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8021a78:	68bb      	ldr	r3, [r7, #8]
 8021a7a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021a7e:	f04f 0300 	mov.w	r3, #0
 8021a82:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021a84:	68fb      	ldr	r3, [r7, #12]
}
 8021a86:	4618      	mov	r0, r3
 8021a88:	f107 0714 	add.w	r7, r7, #20
 8021a8c:	46bd      	mov	sp, r7
 8021a8e:	bc80      	pop	{r7}
 8021a90:	4770      	bx	lr
 8021a92:	bf00      	nop

08021a94 <ADC002_EnableGate>:
/*
 * This function enables the gating.
 */
status_t ADC002_EnableGate(const ADC002_HandleType *HandlePtr, 
                                              uint8_t GateSelectVal)
{
 8021a94:	b480      	push	{r7}
 8021a96:	b085      	sub	sp, #20
 8021a98:	af00      	add	r7, sp, #0
 8021a9a:	6078      	str	r0, [r7, #4]
 8021a9c:	460b      	mov	r3, r1
 8021a9e:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021aa0:	f04f 0301 	mov.w	r3, #1
 8021aa4:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021aa6:	687b      	ldr	r3, [r7, #4]
 8021aa8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021aaa:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021aac:	687b      	ldr	r3, [r7, #4]
 8021aae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021ab0:	781b      	ldrb	r3, [r3, #0]
 8021ab2:	2b01      	cmp	r3, #1
 8021ab4:	d115      	bne.n	8021ae2 <ADC002_EnableGate+0x4e>
  {
    if(GateSelectVal <= (uint8_t)3)
 8021ab6:	78fb      	ldrb	r3, [r7, #3]
 8021ab8:	2b03      	cmp	r3, #3
 8021aba:	d80f      	bhi.n	8021adc <ADC002_EnableGate+0x48>
    {
      /* Selects the gating functionality */
     WR_REG(VADCGroupPtr->QMR0, VADC_G_QMR0_ENGT_Msk, VADC_G_QMR0_ENGT_Pos,\
 8021abc:	78fb      	ldrb	r3, [r7, #3]
 8021abe:	f003 0203 	and.w	r2, r3, #3
 8021ac2:	68bb      	ldr	r3, [r7, #8]
 8021ac4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021ac8:	f023 0303 	bic.w	r3, r3, #3
 8021acc:	431a      	orrs	r2, r3
 8021ace:	68bb      	ldr	r3, [r7, #8]
 8021ad0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
                                                     (uint32_t)GateSelectVal);
      Status = (uint32_t)DAVEApp_SUCCESS;
 8021ad4:	f04f 0300 	mov.w	r3, #0
 8021ad8:	60fb      	str	r3, [r7, #12]
 8021ada:	e002      	b.n	8021ae2 <ADC002_EnableGate+0x4e>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021adc:	f04f 0302 	mov.w	r3, #2
 8021ae0:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021ae2:	68fb      	ldr	r3, [r7, #12]
}
 8021ae4:	4618      	mov	r0, r3
 8021ae6:	f107 0714 	add.w	r7, r7, #20
 8021aea:	46bd      	mov	sp, r7
 8021aec:	bc80      	pop	{r7}
 8021aee:	4770      	bx	lr

08021af0 <ADC002_EnableQueueArbitrationSlot>:

/*
 * This function enables queue arbitration slot.
 */
status_t ADC002_EnableQueueArbitrationSlot(const ADC002_HandleType *HandlePtr)
{
 8021af0:	b480      	push	{r7}
 8021af2:	b085      	sub	sp, #20
 8021af4:	af00      	add	r7, sp, #0
 8021af6:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021af8:	f04f 0301 	mov.w	r3, #1
 8021afc:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021afe:	687b      	ldr	r3, [r7, #4]
 8021b00:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021b02:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021b04:	687b      	ldr	r3, [r7, #4]
 8021b06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021b08:	781b      	ldrb	r3, [r3, #0]
 8021b0a:	2b01      	cmp	r3, #1
 8021b0c:	d10a      	bne.n	8021b24 <ADC002_EnableQueueArbitrationSlot+0x34>
  {
    /* Enables Queue Arbitration Slot */
    SET_BIT(VADCGroupPtr->ARBPR,VADC_G_ARBPR_ASEN0_Pos);    
 8021b0e:	68bb      	ldr	r3, [r7, #8]
 8021b10:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8021b14:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 8021b18:	68bb      	ldr	r3, [r7, #8]
 8021b1a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021b1e:	f04f 0300 	mov.w	r3, #0
 8021b22:	60fb      	str	r3, [r7, #12]
  {
      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021b24:	68fb      	ldr	r3, [r7, #12]
}
 8021b26:	4618      	mov	r0, r3
 8021b28:	f107 0714 	add.w	r7, r7, #20
 8021b2c:	46bd      	mov	sp, r7
 8021b2e:	bc80      	pop	{r7}
 8021b30:	4770      	bx	lr
 8021b32:	bf00      	nop

08021b34 <ADC002_DisableQueueArbitrationSlot>:

/*
 * This function disables queue arbitration slot.
 */
status_t ADC002_DisableQueueArbitrationSlot(const ADC002_HandleType *HandlePtr)
{
 8021b34:	b480      	push	{r7}
 8021b36:	b085      	sub	sp, #20
 8021b38:	af00      	add	r7, sp, #0
 8021b3a:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021b3c:	f04f 0301 	mov.w	r3, #1
 8021b40:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021b42:	687b      	ldr	r3, [r7, #4]
 8021b44:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021b46:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021b48:	687b      	ldr	r3, [r7, #4]
 8021b4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021b4c:	781b      	ldrb	r3, [r3, #0]
 8021b4e:	2b01      	cmp	r3, #1
 8021b50:	d10a      	bne.n	8021b68 <ADC002_DisableQueueArbitrationSlot+0x34>
  {
    /* Disables Queue Arbitration Slot */
    CLR_BIT(VADCGroupPtr->ARBPR,VADC_G_ARBPR_ASEN0_Pos);    
 8021b52:	68bb      	ldr	r3, [r7, #8]
 8021b54:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8021b58:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 8021b5c:	68bb      	ldr	r3, [r7, #8]
 8021b5e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021b62:	f04f 0300 	mov.w	r3, #0
 8021b66:	60fb      	str	r3, [r7, #12]
  {
      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021b68:	68fb      	ldr	r3, [r7, #12]
}
 8021b6a:	4618      	mov	r0, r3
 8021b6c:	f107 0714 	add.w	r7, r7, #20
 8021b70:	46bd      	mov	sp, r7
 8021b72:	bc80      	pop	{r7}
 8021b74:	4770      	bx	lr
 8021b76:	bf00      	nop

08021b78 <ADC002_SetExternalTriggerMode>:
/*
 * This function selects the External trigger mode.
 */
status_t ADC002_SetExternalTriggerMode(const ADC002_HandleType *HandlePtr,
                                                                   uint8_t Mode)
{
 8021b78:	b480      	push	{r7}
 8021b7a:	b085      	sub	sp, #20
 8021b7c:	af00      	add	r7, sp, #0
 8021b7e:	6078      	str	r0, [r7, #4]
 8021b80:	460b      	mov	r3, r1
 8021b82:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021b84:	f04f 0301 	mov.w	r3, #1
 8021b88:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021b8a:	687b      	ldr	r3, [r7, #4]
 8021b8c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021b8e:	60bb      	str	r3, [r7, #8]
  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if(HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021b90:	687b      	ldr	r3, [r7, #4]
 8021b92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021b94:	781b      	ldrb	r3, [r3, #0]
 8021b96:	2b01      	cmp	r3, #1
 8021b98:	d12d      	bne.n	8021bf6 <ADC002_SetExternalTriggerMode+0x7e>
  {
    if(Mode <= (uint8_t)ADC002_TRIGGER_UPON_BOTH_EDGE)
 8021b9a:	78fb      	ldrb	r3, [r7, #3]
 8021b9c:	2b03      	cmp	r3, #3
 8021b9e:	d827      	bhi.n	8021bf0 <ADC002_SetExternalTriggerMode+0x78>
    {
      if(Mode == (uint8_t)ADC002_NOTRIGGER)
 8021ba0:	78fb      	ldrb	r3, [r7, #3]
 8021ba2:	2b00      	cmp	r3, #0
 8021ba4:	d108      	bne.n	8021bb8 <ADC002_SetExternalTriggerMode+0x40>
      {
        /* Disables external trigger */
        CLR_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);
 8021ba6:	68bb      	ldr	r3, [r7, #8]
 8021ba8:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021bac:	f023 0204 	bic.w	r2, r3, #4
 8021bb0:	68bb      	ldr	r3, [r7, #8]
 8021bb2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
 8021bb6:	e007      	b.n	8021bc8 <ADC002_SetExternalTriggerMode+0x50>
      }
      else
      {
        /* Enables external trigger */
        SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);      
 8021bb8:	68bb      	ldr	r3, [r7, #8]
 8021bba:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021bbe:	f043 0204 	orr.w	r2, r3, #4
 8021bc2:	68bb      	ldr	r3, [r7, #8]
 8021bc4:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   * Enable XTWC Bitfield so that XTMODE and XTSEL can be written
   * Selects trigger mode .
   */
      VADCGroupPtr->QCTRL0 = (uint32_t)
        ((((uint32_t)1 << VADC_G_QCTRL0_XTWC_Pos) & VADC_G_QCTRL0_XTWC_Msk)|\
        (((uint32_t)Mode<< VADC_G_QCTRL0_XTMODE_Pos) & VADC_G_QCTRL0_XTMODE_Msk)|\
 8021bc8:	78fb      	ldrb	r3, [r7, #3]
 8021bca:	ea4f 3343 	mov.w	r3, r3, lsl #13
 8021bce:	f403 42c0 	and.w	r2, r3, #24576	; 0x6000
        (VADCGroupPtr->QCTRL0 & (((uint32_t)0xF)<< VADC_G_QCTRL0_XTSEL_Pos)));
 8021bd2:	68bb      	ldr	r3, [r7, #8]
 8021bd4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8021bd8:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
      }   
  /*
   * Enable XTWC Bitfield so that XTMODE and XTSEL can be written
   * Selects trigger mode .
   */
      VADCGroupPtr->QCTRL0 = (uint32_t)
 8021bdc:	4313      	orrs	r3, r2
 8021bde:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8021be2:	68bb      	ldr	r3, [r7, #8]
 8021be4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
        ((((uint32_t)1 << VADC_G_QCTRL0_XTWC_Pos) & VADC_G_QCTRL0_XTWC_Msk)|\
        (((uint32_t)Mode<< VADC_G_QCTRL0_XTMODE_Pos) & VADC_G_QCTRL0_XTMODE_Msk)|\
        (VADCGroupPtr->QCTRL0 & (((uint32_t)0xF)<< VADC_G_QCTRL0_XTSEL_Pos)));

      Status = (uint32_t)DAVEApp_SUCCESS;
 8021be8:	f04f 0300 	mov.w	r3, #0
 8021bec:	60fb      	str	r3, [r7, #12]
 8021bee:	e002      	b.n	8021bf6 <ADC002_SetExternalTriggerMode+0x7e>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021bf0:	f04f 0302 	mov.w	r3, #2
 8021bf4:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021bf6:	68fb      	ldr	r3, [r7, #12]
}
 8021bf8:	4618      	mov	r0, r3
 8021bfa:	f107 0714 	add.w	r7, r7, #20
 8021bfe:	46bd      	mov	sp, r7
 8021c00:	bc80      	pop	{r7}
 8021c02:	4770      	bx	lr

08021c04 <ADC002_EnableExternalTrigger>:

/*
 * This function enables external trigger.
 */
status_t ADC002_EnableExternalTrigger(const ADC002_HandleType *HandlePtr)
{
 8021c04:	b480      	push	{r7}
 8021c06:	b085      	sub	sp, #20
 8021c08:	af00      	add	r7, sp, #0
 8021c0a:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021c0c:	f04f 0301 	mov.w	r3, #1
 8021c10:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021c12:	687b      	ldr	r3, [r7, #4]
 8021c14:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021c16:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021c18:	687b      	ldr	r3, [r7, #4]
 8021c1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021c1c:	781b      	ldrb	r3, [r3, #0]
 8021c1e:	2b01      	cmp	r3, #1
 8021c20:	d10a      	bne.n	8021c38 <ADC002_EnableExternalTrigger+0x34>
  {
    /* Enables external trigger */
    SET_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);
 8021c22:	68bb      	ldr	r3, [r7, #8]
 8021c24:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021c28:	f043 0204 	orr.w	r2, r3, #4
 8021c2c:	68bb      	ldr	r3, [r7, #8]
 8021c2e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021c32:	f04f 0300 	mov.w	r3, #0
 8021c36:	60fb      	str	r3, [r7, #12]
  {
      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021c38:	68fb      	ldr	r3, [r7, #12]
}
 8021c3a:	4618      	mov	r0, r3
 8021c3c:	f107 0714 	add.w	r7, r7, #20
 8021c40:	46bd      	mov	sp, r7
 8021c42:	bc80      	pop	{r7}
 8021c44:	4770      	bx	lr
 8021c46:	bf00      	nop

08021c48 <ADC002_DisableExternalTrigger>:

/*
 * This function disables external trigger.
 */
status_t ADC002_DisableExternalTrigger(const ADC002_HandleType *HandlePtr)
{
 8021c48:	b480      	push	{r7}
 8021c4a:	b085      	sub	sp, #20
 8021c4c:	af00      	add	r7, sp, #0
 8021c4e:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021c50:	f04f 0301 	mov.w	r3, #1
 8021c54:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021c56:	687b      	ldr	r3, [r7, #4]
 8021c58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021c5a:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021c5c:	687b      	ldr	r3, [r7, #4]
 8021c5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021c60:	781b      	ldrb	r3, [r3, #0]
 8021c62:	2b01      	cmp	r3, #1
 8021c64:	d10a      	bne.n	8021c7c <ADC002_DisableExternalTrigger+0x34>
  {
    /* Disables external trigger */
    CLR_BIT(VADCGroupPtr->QMR0, VADC_G_QMR0_ENTR_Pos);
 8021c66:	68bb      	ldr	r3, [r7, #8]
 8021c68:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021c6c:	f023 0204 	bic.w	r2, r3, #4
 8021c70:	68bb      	ldr	r3, [r7, #8]
 8021c72:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    Status = (uint32_t)DAVEApp_SUCCESS;
 8021c76:	f04f 0300 	mov.w	r3, #0
 8021c7a:	60fb      	str	r3, [r7, #12]
  {
      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021c7c:	68fb      	ldr	r3, [r7, #12]
}
 8021c7e:	4618      	mov	r0, r3
 8021c80:	f107 0714 	add.w	r7, r7, #20
 8021c84:	46bd      	mov	sp, r7
 8021c86:	bc80      	pop	{r7}
 8021c88:	4770      	bx	lr
 8021c8a:	bf00      	nop

08021c8c <ADC002_IsEmpty>:


/* This function checks if there is valid entry in the queue. */
status_t ADC002_IsEmpty(const ADC002_HandleType *HandlePtr, 
                                                    uint8_t *VailidEntryPtr)
{
 8021c8c:	b480      	push	{r7}
 8021c8e:	b085      	sub	sp, #20
 8021c90:	af00      	add	r7, sp, #0
 8021c92:	6078      	str	r0, [r7, #4]
 8021c94:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021c96:	f04f 0301 	mov.w	r3, #1
 8021c9a:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021c9c:	687b      	ldr	r3, [r7, #4]
 8021c9e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021ca0:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021ca2:	687b      	ldr	r3, [r7, #4]
 8021ca4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021ca6:	781b      	ldrb	r3, [r3, #0]
 8021ca8:	2b01      	cmp	r3, #1
 8021caa:	d113      	bne.n	8021cd4 <ADC002_IsEmpty+0x48>
  {
    /*Checks if there is valid entry in the queue*/
    if(VailidEntryPtr != NULL)
 8021cac:	683b      	ldr	r3, [r7, #0]
 8021cae:	2b00      	cmp	r3, #0
 8021cb0:	d00d      	beq.n	8021cce <ADC002_IsEmpty+0x42>
    {
        *VailidEntryPtr = (uint8_t)RD_REG( VADCGroupPtr->QSR0, 
 8021cb2:	68bb      	ldr	r3, [r7, #8]
 8021cb4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8021cb8:	f003 0320 	and.w	r3, r3, #32
 8021cbc:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8021cc0:	b2da      	uxtb	r2, r3
 8021cc2:	683b      	ldr	r3, [r7, #0]
 8021cc4:	701a      	strb	r2, [r3, #0]
                          VADC_G_QSR0_EMPTY_Msk, VADC_G_QSR0_EMPTY_Pos);
        Status = (uint32_t)DAVEApp_SUCCESS;                          
 8021cc6:	f04f 0300 	mov.w	r3, #0
 8021cca:	60fb      	str	r3, [r7, #12]
 8021ccc:	e002      	b.n	8021cd4 <ADC002_IsEmpty+0x48>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021cce:	f04f 0302 	mov.w	r3, #2
 8021cd2:	60fb      	str	r3, [r7, #12]
  {
      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021cd4:	68fb      	ldr	r3, [r7, #12]
}
 8021cd6:	4618      	mov	r0, r3
 8021cd8:	f107 0714 	add.w	r7, r7, #20
 8021cdc:	46bd      	mov	sp, r7
 8021cde:	bc80      	pop	{r7}
 8021ce0:	4770      	bx	lr
 8021ce2:	bf00      	nop

08021ce4 <ADC002_GetFillingLevel>:

/* This function indicates number of valid entries in the queue. */
status_t ADC002_GetFillingLevel(const ADC002_HandleType *HandlePtr, 
                                                    uint8_t *FillLevelPtr)
{
 8021ce4:	b580      	push	{r7, lr}
 8021ce6:	b086      	sub	sp, #24
 8021ce8:	af00      	add	r7, sp, #0
 8021cea:	6078      	str	r0, [r7, #4]
 8021cec:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021cee:	f04f 0301 	mov.w	r3, #1
 8021cf2:	617b      	str	r3, [r7, #20]
  /* Pointer to the VADC Structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021cf4:	687b      	ldr	r3, [r7, #4]
 8021cf6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021cf8:	613b      	str	r3, [r7, #16]
  /* Status of valid entry in the queue */            
  uint8_t VailidEntry; 
  /* Fill level of queue */
  uint8_t FillLevelValue = (uint8_t)0;
 8021cfa:	f04f 0300 	mov.w	r3, #0
 8021cfe:	73fb      	strb	r3, [r7, #15]
  
  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021d00:	687b      	ldr	r3, [r7, #4]
 8021d02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021d04:	781b      	ldrb	r3, [r3, #0]
 8021d06:	2b01      	cmp	r3, #1
 8021d08:	d139      	bne.n	8021d7e <ADC002_GetFillingLevel+0x9a>
  {
    /*Checks if there is valid entry in the queue*/
    if(FillLevelPtr != NULL)
 8021d0a:	683b      	ldr	r3, [r7, #0]
 8021d0c:	2b00      	cmp	r3, #0
 8021d0e:	d033      	beq.n	8021d78 <ADC002_GetFillingLevel+0x94>
    {
        FillLevelValue = (uint8_t)RD_REG( VADCGroupPtr->QSR0, 
 8021d10:	693b      	ldr	r3, [r7, #16]
 8021d12:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8021d16:	b2db      	uxtb	r3, r3
 8021d18:	f003 030f 	and.w	r3, r3, #15
 8021d1c:	73fb      	strb	r3, [r7, #15]
                          VADC_G_QSR0_FILL_Msk, VADC_G_QSR0_FILL_Pos);
                          
        if(FillLevelValue == (uint8_t)0)
 8021d1e:	7bfb      	ldrb	r3, [r7, #15]
 8021d20:	2b00      	cmp	r3, #0
 8021d22:	d11f      	bne.n	8021d64 <ADC002_GetFillingLevel+0x80>
        {
          if(ADC002_IsEmpty(HandlePtr, &VailidEntry) == 
 8021d24:	f107 030e 	add.w	r3, r7, #14
 8021d28:	6878      	ldr	r0, [r7, #4]
 8021d2a:	4619      	mov	r1, r3
 8021d2c:	f7ff ffae 	bl	8021c8c <ADC002_IsEmpty>
 8021d30:	4603      	mov	r3, r0
 8021d32:	2b00      	cmp	r3, #0
 8021d34:	d112      	bne.n	8021d5c <ADC002_GetFillingLevel+0x78>
                                                      (uint32_t)DAVEApp_SUCCESS)
          {
          
            if(VailidEntry == (uint8_t)1)
 8021d36:	7bbb      	ldrb	r3, [r7, #14]
 8021d38:	2b01      	cmp	r3, #1
 8021d3a:	d107      	bne.n	8021d4c <ADC002_GetFillingLevel+0x68>
            {
              /* If  VailidEntry==1 then queue is empty */
              *FillLevelPtr = (uint8_t)0;
 8021d3c:	683b      	ldr	r3, [r7, #0]
 8021d3e:	f04f 0200 	mov.w	r2, #0
 8021d42:	701a      	strb	r2, [r3, #0]
              Status = (uint32_t)DAVEApp_SUCCESS;
 8021d44:	f04f 0300 	mov.w	r3, #0
 8021d48:	617b      	str	r3, [r7, #20]
 8021d4a:	e018      	b.n	8021d7e <ADC002_GetFillingLevel+0x9a>
            }
            else
            {
              /* If  VailidEntry==1 then queue has one valid entry */
              *FillLevelPtr = (uint8_t)1;
 8021d4c:	683b      	ldr	r3, [r7, #0]
 8021d4e:	f04f 0201 	mov.w	r2, #1
 8021d52:	701a      	strb	r2, [r3, #0]
              Status = (uint32_t)DAVEApp_SUCCESS;
 8021d54:	f04f 0300 	mov.w	r3, #0
 8021d58:	617b      	str	r3, [r7, #20]
 8021d5a:	e010      	b.n	8021d7e <ADC002_GetFillingLevel+0x9a>
            }
          }
          else
          {
            Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021d5c:	f04f 0302 	mov.w	r3, #2
 8021d60:	617b      	str	r3, [r7, #20]
 8021d62:	e00c      	b.n	8021d7e <ADC002_GetFillingLevel+0x9a>
        
        }
        else
        {
          /* Entries in the queue will be register read value plus one */
          *FillLevelPtr = FillLevelValue + (uint8_t)1;
 8021d64:	7bfb      	ldrb	r3, [r7, #15]
 8021d66:	f103 0301 	add.w	r3, r3, #1
 8021d6a:	b2da      	uxtb	r2, r3
 8021d6c:	683b      	ldr	r3, [r7, #0]
 8021d6e:	701a      	strb	r2, [r3, #0]
          Status = (uint32_t)DAVEApp_SUCCESS;
 8021d70:	f04f 0300 	mov.w	r3, #0
 8021d74:	617b      	str	r3, [r7, #20]
 8021d76:	e002      	b.n	8021d7e <ADC002_GetFillingLevel+0x9a>
        

    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021d78:	f04f 0302 	mov.w	r3, #2
 8021d7c:	617b      	str	r3, [r7, #20]
  {
      ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
    
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021d7e:	697b      	ldr	r3, [r7, #20]
}
 8021d80:	4618      	mov	r0, r3
 8021d82:	f107 0718 	add.w	r7, r7, #24
 8021d86:	46bd      	mov	sp, r7
 8021d88:	bd80      	pop	{r7, pc}
 8021d8a:	bf00      	nop

08021d8c <ADC002_GetGateLevel>:

/* This function gets the current level of the selected gate input */
status_t ADC002_GetGateLevel(const ADC002_HandleType *HandlePtr, 
                                                    uint8_t *GateLevelPtr)
{
 8021d8c:	b480      	push	{r7}
 8021d8e:	b085      	sub	sp, #20
 8021d90:	af00      	add	r7, sp, #0
 8021d92:	6078      	str	r0, [r7, #4]
 8021d94:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021d96:	f04f 0301 	mov.w	r3, #1
 8021d9a:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021d9c:	687b      	ldr	r3, [r7, #4]
 8021d9e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021da0:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021da2:	687b      	ldr	r3, [r7, #4]
 8021da4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021da6:	781b      	ldrb	r3, [r3, #0]
 8021da8:	2b01      	cmp	r3, #1
 8021daa:	d113      	bne.n	8021dd4 <ADC002_GetGateLevel+0x48>
  {
    /* Get the input level of selected gate input */
    if(GateLevelPtr != NULL)
 8021dac:	683b      	ldr	r3, [r7, #0]
 8021dae:	2b00      	cmp	r3, #0
 8021db0:	d00d      	beq.n	8021dce <ADC002_GetGateLevel+0x42>
    {
      *GateLevelPtr = (uint8_t)RD_REG( VADCGroupPtr->QSR0, 
 8021db2:	68bb      	ldr	r3, [r7, #8]
 8021db4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8021db8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8021dbc:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 8021dc0:	b2da      	uxtb	r2, r3
 8021dc2:	683b      	ldr	r3, [r7, #0]
 8021dc4:	701a      	strb	r2, [r3, #0]
                          VADC_G_QSR0_REQGT_Msk, VADC_G_QSR0_REQGT_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
 8021dc6:	f04f 0300 	mov.w	r3, #0
 8021dca:	60fb      	str	r3, [r7, #12]
 8021dcc:	e002      	b.n	8021dd4 <ADC002_GetGateLevel+0x48>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021dce:	f04f 0302 	mov.w	r3, #2
 8021dd2:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021dd4:	68fb      	ldr	r3, [r7, #12]
}
 8021dd6:	4618      	mov	r0, r3
 8021dd8:	f107 0714 	add.w	r7, r7, #20
 8021ddc:	46bd      	mov	sp, r7
 8021dde:	bc80      	pop	{r7}
 8021de0:	4770      	bx	lr
 8021de2:	bf00      	nop

08021de4 <ADC002_IsEventDetected>:
 * This function indicates whether an event has been detected while at
 * least one valid entry has been in the queue. 
 */
status_t ADC002_IsEventDetected(const ADC002_HandleType *HandlePtr, 
                                                    uint8_t *EventPtr)
{
 8021de4:	b480      	push	{r7}
 8021de6:	b085      	sub	sp, #20
 8021de8:	af00      	add	r7, sp, #0
 8021dea:	6078      	str	r0, [r7, #4]
 8021dec:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021dee:	f04f 0301 	mov.w	r3, #1
 8021df2:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021df4:	687b      	ldr	r3, [r7, #4]
 8021df6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021df8:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021dfa:	687b      	ldr	r3, [r7, #4]
 8021dfc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021dfe:	781b      	ldrb	r3, [r3, #0]
 8021e00:	2b01      	cmp	r3, #1
 8021e02:	d113      	bne.n	8021e2c <ADC002_IsEventDetected+0x48>
  {
    /* Get the event detection. */
    if(EventPtr != NULL)
 8021e04:	683b      	ldr	r3, [r7, #0]
 8021e06:	2b00      	cmp	r3, #0
 8021e08:	d00d      	beq.n	8021e26 <ADC002_IsEventDetected+0x42>
    {
        *EventPtr = (uint8_t)RD_REG( VADCGroupPtr->QSR0, 
 8021e0a:	68bb      	ldr	r3, [r7, #8]
 8021e0c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8021e10:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8021e14:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8021e18:	b2da      	uxtb	r2, r3
 8021e1a:	683b      	ldr	r3, [r7, #0]
 8021e1c:	701a      	strb	r2, [r3, #0]
                                    VADC_G_QSR0_EV_Msk, VADC_G_QSR0_EV_Pos);
        Status = (uint32_t)DAVEApp_SUCCESS;                                    
 8021e1e:	f04f 0300 	mov.w	r3, #0
 8021e22:	60fb      	str	r3, [r7, #12]
 8021e24:	e002      	b.n	8021e2c <ADC002_IsEventDetected+0x48>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021e26:	f04f 0302 	mov.w	r3, #2
 8021e2a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021e2c:	68fb      	ldr	r3, [r7, #12]
}
 8021e2e:	4618      	mov	r0, r3
 8021e30:	f107 0714 	add.w	r7, r7, #20
 8021e34:	46bd      	mov	sp, r7
 8021e36:	bc80      	pop	{r7}
 8021e38:	4770      	bx	lr
 8021e3a:	bf00      	nop

08021e3c <ADC002_AddQueueEntry>:
/*
 * This function makes the entry to the queue request
 */
status_t ADC002_AddQueueEntry(const ADC002_HandleType *HandlePtr, 
                               const ADC002_QueueEntryHandleType *QueueEntryPtr)
{
 8021e3c:	b480      	push	{r7}
 8021e3e:	b087      	sub	sp, #28
 8021e40:	af00      	add	r7, sp, #0
 8021e42:	6078      	str	r0, [r7, #4]
 8021e44:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021e46:	f04f 0301 	mov.w	r3, #1
 8021e4a:	617b      	str	r3, [r7, #20]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8021e4c:	687b      	ldr	r3, [r7, #4]
 8021e4e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8021e50:	613b      	str	r3, [r7, #16]
  uint32_t QINR0Val;

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021e52:	687b      	ldr	r3, [r7, #4]
 8021e54:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021e56:	781b      	ldrb	r3, [r3, #0]
 8021e58:	2b01      	cmp	r3, #1
 8021e5a:	d131      	bne.n	8021ec0 <ADC002_AddQueueEntry+0x84>
  {
    /* Register the queue entry */
    if((QueueEntryPtr != NULL) && (QueueEntryPtr->ChannelNumber <= (uint8_t)7) &&\
 8021e5c:	683b      	ldr	r3, [r7, #0]
 8021e5e:	2b00      	cmp	r3, #0
 8021e60:	d02b      	beq.n	8021eba <ADC002_AddQueueEntry+0x7e>
 8021e62:	683b      	ldr	r3, [r7, #0]
 8021e64:	785b      	ldrb	r3, [r3, #1]
 8021e66:	2b07      	cmp	r3, #7
 8021e68:	d827      	bhi.n	8021eba <ADC002_AddQueueEntry+0x7e>
              (HandlePtr->kActiveChannels[QueueEntryPtr->ChannelNumber] == (uint8_t)1))
 8021e6a:	683b      	ldr	r3, [r7, #0]
 8021e6c:	785b      	ldrb	r3, [r3, #1]
 8021e6e:	687a      	ldr	r2, [r7, #4]
 8021e70:	18d3      	adds	r3, r2, r3
 8021e72:	7bdb      	ldrb	r3, [r3, #15]
  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
  {
    /* Register the queue entry */
    if((QueueEntryPtr != NULL) && (QueueEntryPtr->ChannelNumber <= (uint8_t)7) &&\
 8021e74:	2b01      	cmp	r3, #1
 8021e76:	d120      	bne.n	8021eba <ADC002_AddQueueEntry+0x7e>
              (HandlePtr->kActiveChannels[QueueEntryPtr->ChannelNumber] == (uint8_t)1))
    {
      QINR0Val = (uint32_t)
        (((uint32_t)QueueEntryPtr->ChannelNumber << VADC_G_QINR0_REQCHNR_Pos) & VADC_G_QINR0_REQCHNR_Msk)  |\
 8021e78:	683b      	ldr	r3, [r7, #0]
 8021e7a:	785b      	ldrb	r3, [r3, #1]
  {
    /* Register the queue entry */
    if((QueueEntryPtr != NULL) && (QueueEntryPtr->ChannelNumber <= (uint8_t)7) &&\
              (HandlePtr->kActiveChannels[QueueEntryPtr->ChannelNumber] == (uint8_t)1))
    {
      QINR0Val = (uint32_t)
 8021e7c:	f003 021f 	and.w	r2, r3, #31
        (((uint32_t)QueueEntryPtr->ChannelNumber << VADC_G_QINR0_REQCHNR_Pos) & VADC_G_QINR0_REQCHNR_Msk)  |\
        (((uint32_t)QueueEntryPtr->Refill << VADC_G_QINR0_RF_Pos) & VADC_G_QINR0_RF_Msk)|\
 8021e80:	683b      	ldr	r3, [r7, #0]
 8021e82:	789b      	ldrb	r3, [r3, #2]
 8021e84:	ea4f 1343 	mov.w	r3, r3, lsl #5
 8021e88:	f003 0320 	and.w	r3, r3, #32
    /* Register the queue entry */
    if((QueueEntryPtr != NULL) && (QueueEntryPtr->ChannelNumber <= (uint8_t)7) &&\
              (HandlePtr->kActiveChannels[QueueEntryPtr->ChannelNumber] == (uint8_t)1))
    {
      QINR0Val = (uint32_t)
        (((uint32_t)QueueEntryPtr->ChannelNumber << VADC_G_QINR0_REQCHNR_Pos) & VADC_G_QINR0_REQCHNR_Msk)  |\
 8021e8c:	431a      	orrs	r2, r3
        (((uint32_t)QueueEntryPtr->Refill << VADC_G_QINR0_RF_Pos) & VADC_G_QINR0_RF_Msk)|\
        (((uint32_t)QueueEntryPtr->Interrupt << VADC_G_QINR0_ENSI_Pos)& VADC_G_QINR0_ENSI_Msk)|\
 8021e8e:	683b      	ldr	r3, [r7, #0]
 8021e90:	791b      	ldrb	r3, [r3, #4]
 8021e92:	ea4f 1383 	mov.w	r3, r3, lsl #6
 8021e96:	f003 0340 	and.w	r3, r3, #64	; 0x40
    if((QueueEntryPtr != NULL) && (QueueEntryPtr->ChannelNumber <= (uint8_t)7) &&\
              (HandlePtr->kActiveChannels[QueueEntryPtr->ChannelNumber] == (uint8_t)1))
    {
      QINR0Val = (uint32_t)
        (((uint32_t)QueueEntryPtr->ChannelNumber << VADC_G_QINR0_REQCHNR_Pos) & VADC_G_QINR0_REQCHNR_Msk)  |\
        (((uint32_t)QueueEntryPtr->Refill << VADC_G_QINR0_RF_Pos) & VADC_G_QINR0_RF_Msk)|\
 8021e9a:	431a      	orrs	r2, r3
        (((uint32_t)QueueEntryPtr->Interrupt << VADC_G_QINR0_ENSI_Pos)& VADC_G_QINR0_ENSI_Msk)|\
        (((uint32_t)QueueEntryPtr->ExternalTrigger << VADC_G_QINR0_EXTR_Pos) & VADC_G_QINR0_EXTR_Msk);
 8021e9c:	683b      	ldr	r3, [r7, #0]
 8021e9e:	78db      	ldrb	r3, [r3, #3]
 8021ea0:	ea4f 13c3 	mov.w	r3, r3, lsl #7
 8021ea4:	b2db      	uxtb	r3, r3
  {
    /* Register the queue entry */
    if((QueueEntryPtr != NULL) && (QueueEntryPtr->ChannelNumber <= (uint8_t)7) &&\
              (HandlePtr->kActiveChannels[QueueEntryPtr->ChannelNumber] == (uint8_t)1))
    {
      QINR0Val = (uint32_t)
 8021ea6:	4313      	orrs	r3, r2
 8021ea8:	60fb      	str	r3, [r7, #12]
        (((uint32_t)QueueEntryPtr->ChannelNumber << VADC_G_QINR0_REQCHNR_Pos) & VADC_G_QINR0_REQCHNR_Msk)  |\
        (((uint32_t)QueueEntryPtr->Refill << VADC_G_QINR0_RF_Pos) & VADC_G_QINR0_RF_Msk)|\
        (((uint32_t)QueueEntryPtr->Interrupt << VADC_G_QINR0_ENSI_Pos)& VADC_G_QINR0_ENSI_Msk)|\
        (((uint32_t)QueueEntryPtr->ExternalTrigger << VADC_G_QINR0_EXTR_Pos) & VADC_G_QINR0_EXTR_Msk);
                  
      VADCGroupPtr->QINR0 = QINR0Val;
 8021eaa:	693b      	ldr	r3, [r7, #16]
 8021eac:	68fa      	ldr	r2, [r7, #12]
 8021eae:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
      
      Status = (uint32_t)DAVEApp_SUCCESS;               
 8021eb2:	f04f 0300 	mov.w	r3, #0
 8021eb6:	617b      	str	r3, [r7, #20]
 8021eb8:	e002      	b.n	8021ec0 <ADC002_AddQueueEntry+0x84>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021eba:	f04f 0302 	mov.w	r3, #2
 8021ebe:	617b      	str	r3, [r7, #20]
  else
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021ec0:	697b      	ldr	r3, [r7, #20]
}
 8021ec2:	4618      	mov	r0, r3
 8021ec4:	f107 071c 	add.w	r7, r7, #28
 8021ec8:	46bd      	mov	sp, r7
 8021eca:	bc80      	pop	{r7}
 8021ecc:	4770      	bx	lr
 8021ece:	bf00      	nop

08021ed0 <ADC002_SetConversionMode>:
/*
 * This function sets standard conversion mode.
 */
status_t ADC002_SetConversionMode(const ADC002_HandleType *HandlePtr,
                                                        uint8_t ConversionMode)
{
 8021ed0:	b580      	push	{r7, lr}
 8021ed2:	b084      	sub	sp, #16
 8021ed4:	af00      	add	r7, sp, #0
 8021ed6:	6078      	str	r0, [r7, #4]
 8021ed8:	460b      	mov	r3, r1
 8021eda:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021edc:	f04f 0301 	mov.w	r3, #1
 8021ee0:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021ee2:	687b      	ldr	r3, [r7, #4]
 8021ee4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021ee6:	781b      	ldrb	r3, [r3, #0]
 8021ee8:	2b01      	cmp	r3, #1
 8021eea:	d10f      	bne.n	8021f0c <ADC002_SetConversionMode+0x3c>
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
 8021eec:	687b      	ldr	r3, [r7, #4]
 8021eee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8021ef0:	2b00      	cmp	r3, #0
 8021ef2:	d008      	beq.n	8021f06 <ADC002_SetConversionMode+0x36>
    {
      /* Set standard conversion mode */
      Status = (uint32_t)ADCGROUP001_SetGroupClass0ConvMode(
                           HandlePtr->kGroup_HandlePtr,ConversionMode);
 8021ef4:	687b      	ldr	r3, [r7, #4]
  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
    {
      /* Set standard conversion mode */
      Status = (uint32_t)ADCGROUP001_SetGroupClass0ConvMode(
 8021ef6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8021ef8:	78fb      	ldrb	r3, [r7, #3]
 8021efa:	4610      	mov	r0, r2
 8021efc:	4619      	mov	r1, r3
 8021efe:	f7fd ffa5 	bl	801fe4c <ADCGROUP001_SetGroupClass0ConvMode>
 8021f02:	60f8      	str	r0, [r7, #12]
 8021f04:	e002      	b.n	8021f0c <ADC002_SetConversionMode+0x3c>
                           HandlePtr->kGroup_HandlePtr,ConversionMode);
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021f06:	f04f 0302 	mov.w	r3, #2
 8021f0a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021f0c:	68fb      	ldr	r3, [r7, #12]
}
 8021f0e:	4618      	mov	r0, r3
 8021f10:	f107 0710 	add.w	r7, r7, #16
 8021f14:	46bd      	mov	sp, r7
 8021f16:	bd80      	pop	{r7, pc}

08021f18 <ADC002_SetSampleTime>:
/*
 * This function sets sample time for standard conversion.
 */
status_t ADC002_SetSampleTime(const ADC002_HandleType *HandlePtr,
                                                            uint8_t SampleTime)
{
 8021f18:	b580      	push	{r7, lr}
 8021f1a:	b084      	sub	sp, #16
 8021f1c:	af00      	add	r7, sp, #0
 8021f1e:	6078      	str	r0, [r7, #4]
 8021f20:	460b      	mov	r3, r1
 8021f22:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021f24:	f04f 0301 	mov.w	r3, #1
 8021f28:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021f2a:	687b      	ldr	r3, [r7, #4]
 8021f2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021f2e:	781b      	ldrb	r3, [r3, #0]
 8021f30:	2b01      	cmp	r3, #1
 8021f32:	d10f      	bne.n	8021f54 <ADC002_SetSampleTime+0x3c>
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
 8021f34:	687b      	ldr	r3, [r7, #4]
 8021f36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8021f38:	2b00      	cmp	r3, #0
 8021f3a:	d008      	beq.n	8021f4e <ADC002_SetSampleTime+0x36>
    {
      /* Set sample time for standard conversion. */
      Status =(uint32_t)ADCGROUP001_SetGroupClass0SampleTime(
                            HandlePtr->kGroup_HandlePtr,SampleTime);
 8021f3c:	687b      	ldr	r3, [r7, #4]
  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
    {
      /* Set sample time for standard conversion. */
      Status =(uint32_t)ADCGROUP001_SetGroupClass0SampleTime(
 8021f3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8021f40:	78fb      	ldrb	r3, [r7, #3]
 8021f42:	4610      	mov	r0, r2
 8021f44:	4619      	mov	r1, r3
 8021f46:	f7fd fec5 	bl	801fcd4 <ADCGROUP001_SetGroupClass0SampleTime>
 8021f4a:	60f8      	str	r0, [r7, #12]
 8021f4c:	e002      	b.n	8021f54 <ADC002_SetSampleTime+0x3c>
                            HandlePtr->kGroup_HandlePtr,SampleTime);
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021f4e:	f04f 0302 	mov.w	r3, #2
 8021f52:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021f54:	68fb      	ldr	r3, [r7, #12]
}
 8021f56:	4618      	mov	r0, r3
 8021f58:	f107 0710 	add.w	r7, r7, #16
 8021f5c:	46bd      	mov	sp, r7
 8021f5e:	bd80      	pop	{r7, pc}

08021f60 <ADC002_SetEMUXConversionMode>:
/*
 * This function sets EMUX conversion mode.
 */
status_t ADC002_SetEMUXConversionMode(const ADC002_HandleType *HandlePtr,
                                                      uint8_t ConversionMode)
{
 8021f60:	b580      	push	{r7, lr}
 8021f62:	b084      	sub	sp, #16
 8021f64:	af00      	add	r7, sp, #0
 8021f66:	6078      	str	r0, [r7, #4]
 8021f68:	460b      	mov	r3, r1
 8021f6a:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021f6c:	f04f 0301 	mov.w	r3, #1
 8021f70:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021f72:	687b      	ldr	r3, [r7, #4]
 8021f74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021f76:	781b      	ldrb	r3, [r3, #0]
 8021f78:	2b01      	cmp	r3, #1
 8021f7a:	d10f      	bne.n	8021f9c <ADC002_SetEMUXConversionMode+0x3c>
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
 8021f7c:	687b      	ldr	r3, [r7, #4]
 8021f7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8021f80:	2b00      	cmp	r3, #0
 8021f82:	d008      	beq.n	8021f96 <ADC002_SetEMUXConversionMode+0x36>
    {
      /* Set EMUX conversion mode */
      Status = (uint32_t)ADCGROUP001_SetGroupClass0EmuxConvMode(
                        HandlePtr->kGroup_HandlePtr,ConversionMode);
 8021f84:	687b      	ldr	r3, [r7, #4]
  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
    {
      /* Set EMUX conversion mode */
      Status = (uint32_t)ADCGROUP001_SetGroupClass0EmuxConvMode(
 8021f86:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8021f88:	78fb      	ldrb	r3, [r7, #3]
 8021f8a:	4610      	mov	r0, r2
 8021f8c:	4619      	mov	r1, r3
 8021f8e:	f7fd ffc5 	bl	801ff1c <ADCGROUP001_SetGroupClass0EmuxConvMode>
 8021f92:	60f8      	str	r0, [r7, #12]
 8021f94:	e002      	b.n	8021f9c <ADC002_SetEMUXConversionMode+0x3c>
                        HandlePtr->kGroup_HandlePtr,ConversionMode);
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021f96:	f04f 0302 	mov.w	r3, #2
 8021f9a:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021f9c:	68fb      	ldr	r3, [r7, #12]
}
 8021f9e:	4618      	mov	r0, r3
 8021fa0:	f107 0710 	add.w	r7, r7, #16
 8021fa4:	46bd      	mov	sp, r7
 8021fa6:	bd80      	pop	{r7, pc}

08021fa8 <ADC002_EMUXSetSampleTime>:
/*
 * This function sets sample time for EMUX conversion.
 */
status_t ADC002_EMUXSetSampleTime(const ADC002_HandleType *HandlePtr,
                                                            uint8_t SampleTime)
{
 8021fa8:	b580      	push	{r7, lr}
 8021faa:	b084      	sub	sp, #16
 8021fac:	af00      	add	r7, sp, #0
 8021fae:	6078      	str	r0, [r7, #4]
 8021fb0:	460b      	mov	r3, r1
 8021fb2:	70fb      	strb	r3, [r7, #3]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021fb4:	f04f 0301 	mov.w	r3, #1
 8021fb8:	60fb      	str	r3, [r7, #12]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8021fba:	687b      	ldr	r3, [r7, #4]
 8021fbc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021fbe:	781b      	ldrb	r3, [r3, #0]
 8021fc0:	2b01      	cmp	r3, #1
 8021fc2:	d10f      	bne.n	8021fe4 <ADC002_EMUXSetSampleTime+0x3c>
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
 8021fc4:	687b      	ldr	r3, [r7, #4]
 8021fc6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8021fc8:	2b00      	cmp	r3, #0
 8021fca:	d008      	beq.n	8021fde <ADC002_EMUXSetSampleTime+0x36>
    {
      /* Set sample time for EMUX conversion*/
      Status = (uint32_t)ADCGROUP001_SetGroupClass0EmuxSampleTime(
                              HandlePtr->kGroup_HandlePtr,SampleTime);
 8021fcc:	687b      	ldr	r3, [r7, #4]
  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
  {
    if(HandlePtr->kGroup_HandlePtr != NULL)
    {
      /* Set sample time for EMUX conversion*/
      Status = (uint32_t)ADCGROUP001_SetGroupClass0EmuxSampleTime(
 8021fce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8021fd0:	78fb      	ldrb	r3, [r7, #3]
 8021fd2:	4610      	mov	r0, r2
 8021fd4:	4619      	mov	r1, r3
 8021fd6:	f7fd fed9 	bl	801fd8c <ADCGROUP001_SetGroupClass0EmuxSampleTime>
 8021fda:	60f8      	str	r0, [r7, #12]
 8021fdc:	e002      	b.n	8021fe4 <ADC002_EMUXSetSampleTime+0x3c>
                              HandlePtr->kGroup_HandlePtr,SampleTime);
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8021fde:	f04f 0302 	mov.w	r3, #2
 8021fe2:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }

  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8021fe4:	68fb      	ldr	r3, [r7, #12]
}
 8021fe6:	4618      	mov	r0, r3
 8021fe8:	f107 0710 	add.w	r7, r7, #16
 8021fec:	46bd      	mov	sp, r7
 8021fee:	bd80      	pop	{r7, pc}

08021ff0 <ADC002_GetQueueStage0Entry>:


/* This function gets the current level of the selected gate input */
status_t ADC002_GetQueueStage0Entry(const ADC002_HandleType *HandlePtr, 
                                                    uint32_t *EntryPtr)
{
 8021ff0:	b480      	push	{r7}
 8021ff2:	b085      	sub	sp, #20
 8021ff4:	af00      	add	r7, sp, #0
 8021ff6:	6078      	str	r0, [r7, #4]
 8021ff8:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8021ffa:	f04f 0301 	mov.w	r3, #1
 8021ffe:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8022000:	687b      	ldr	r3, [r7, #4]
 8022002:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8022004:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8022006:	687b      	ldr	r3, [r7, #4]
 8022008:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802200a:	781b      	ldrb	r3, [r3, #0]
 802200c:	2b01      	cmp	r3, #1
 802200e:	d10e      	bne.n	802202e <ADC002_GetQueueStage0Entry+0x3e>
  {
    /* Get the queue stage 0 entry 0 */
    if(EntryPtr != NULL)
 8022010:	683b      	ldr	r3, [r7, #0]
 8022012:	2b00      	cmp	r3, #0
 8022014:	d008      	beq.n	8022028 <ADC002_GetQueueStage0Entry+0x38>
    {
        *EntryPtr = (uint32_t)VADCGroupPtr->Q0R0;
 8022016:	68bb      	ldr	r3, [r7, #8]
 8022018:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 802201c:	683b      	ldr	r3, [r7, #0]
 802201e:	601a      	str	r2, [r3, #0]
        Status = (uint32_t)DAVEApp_SUCCESS;
 8022020:	f04f 0300 	mov.w	r3, #0
 8022024:	60fb      	str	r3, [r7, #12]
 8022026:	e002      	b.n	802202e <ADC002_GetQueueStage0Entry+0x3e>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8022028:	f04f 0302 	mov.w	r3, #2
 802202c:	60fb      	str	r3, [r7, #12]
  else
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 802202e:	68fb      	ldr	r3, [r7, #12]
}
 8022030:	4618      	mov	r0, r3
 8022032:	f107 0714 	add.w	r7, r7, #20
 8022036:	46bd      	mov	sp, r7
 8022038:	bc80      	pop	{r7}
 802203a:	4770      	bx	lr

0802203c <ADC002_GetQueueBackupStageEntry>:


/* This function gets the current level of the selected gate input */
status_t ADC002_GetQueueBackupStageEntry(const ADC002_HandleType *HandlePtr, 
                                                    uint32_t *EntryPtr)
{
 802203c:	b480      	push	{r7}
 802203e:	b085      	sub	sp, #20
 8022040:	af00      	add	r7, sp, #0
 8022042:	6078      	str	r0, [r7, #4]
 8022044:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8022046:	f04f 0301 	mov.w	r3, #1
 802204a:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 802204c:	687b      	ldr	r3, [r7, #4]
 802204e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8022050:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8022052:	687b      	ldr	r3, [r7, #4]
 8022054:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8022056:	781b      	ldrb	r3, [r3, #0]
 8022058:	2b01      	cmp	r3, #1
 802205a:	d10e      	bne.n	802207a <ADC002_GetQueueBackupStageEntry+0x3e>
  {
    /* Get the queue backup stage entry */
    if(EntryPtr != NULL)
 802205c:	683b      	ldr	r3, [r7, #0]
 802205e:	2b00      	cmp	r3, #0
 8022060:	d008      	beq.n	8022074 <ADC002_GetQueueBackupStageEntry+0x38>
    {
      *EntryPtr = (uint32_t)VADCGroupPtr->QBUR0;
 8022062:	68bb      	ldr	r3, [r7, #8]
 8022064:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 8022068:	683b      	ldr	r3, [r7, #0]
 802206a:	601a      	str	r2, [r3, #0]
      Status = (uint32_t)DAVEApp_SUCCESS;
 802206c:	f04f 0300 	mov.w	r3, #0
 8022070:	60fb      	str	r3, [r7, #12]
 8022072:	e002      	b.n	802207a <ADC002_GetQueueBackupStageEntry+0x3e>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 8022074:	f04f 0302 	mov.w	r3, #2
 8022078:	60fb      	str	r3, [r7, #12]
  else
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 802207a:	68fb      	ldr	r3, [r7, #12]
}
 802207c:	4618      	mov	r0, r3
 802207e:	f107 0714 	add.w	r7, r7, #20
 8022082:	46bd      	mov	sp, r7
 8022084:	bc80      	pop	{r7}
 8022086:	4770      	bx	lr

08022088 <ADC002_GetSourceEventFlag>:


/* This function gets the Event flag. */
status_t ADC002_GetSourceEventFlag(const ADC002_HandleType *HandlePtr, 
                                                            uint8_t *Flagptr)
{
 8022088:	b480      	push	{r7}
 802208a:	b085      	sub	sp, #20
 802208c:	af00      	add	r7, sp, #0
 802208e:	6078      	str	r0, [r7, #4]
 8022090:	6039      	str	r1, [r7, #0]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8022092:	f04f 0301 	mov.w	r3, #1
 8022096:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 8022098:	687b      	ldr	r3, [r7, #4]
 802209a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802209c:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 802209e:	687b      	ldr	r3, [r7, #4]
 80220a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80220a2:	781b      	ldrb	r3, [r3, #0]
 80220a4:	2b01      	cmp	r3, #1
 80220a6:	d112      	bne.n	80220ce <ADC002_GetSourceEventFlag+0x46>
  {
    if(Flagptr != NULL)
 80220a8:	683b      	ldr	r3, [r7, #0]
 80220aa:	2b00      	cmp	r3, #0
 80220ac:	d00c      	beq.n	80220c8 <ADC002_GetSourceEventFlag+0x40>
    {
      /* Gets event flag */
      *Flagptr = (uint8_t)RD_REG( VADCGroupPtr->SEFLAG, 
 80220ae:	68bb      	ldr	r3, [r7, #8]
 80220b0:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 80220b4:	b2db      	uxtb	r3, r3
 80220b6:	f003 0301 	and.w	r3, r3, #1
 80220ba:	b2da      	uxtb	r2, r3
 80220bc:	683b      	ldr	r3, [r7, #0]
 80220be:	701a      	strb	r2, [r3, #0]
                               VADC_G_SEFLAG_SEV0_Msk, VADC_G_SEFLAG_SEV0_Pos);
      Status = (uint32_t)DAVEApp_SUCCESS;
 80220c0:	f04f 0300 	mov.w	r3, #0
 80220c4:	60fb      	str	r3, [r7, #12]
 80220c6:	e002      	b.n	80220ce <ADC002_GetSourceEventFlag+0x46>
    }
    else
    {
      Status = (uint32_t)ADC002_INVALID_PARAM_ERROR;
 80220c8:	f04f 0302 	mov.w	r3, #2
 80220cc:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 80220ce:	68fb      	ldr	r3, [r7, #12]
}
 80220d0:	4618      	mov	r0, r3
 80220d2:	f107 0714 	add.w	r7, r7, #20
 80220d6:	46bd      	mov	sp, r7
 80220d8:	bc80      	pop	{r7}
 80220da:	4770      	bx	lr

080220dc <ADC002_SetSourceEventFlag>:

/* This function sets the Event flag. */
status_t ADC002_SetSourceEventFlag(const ADC002_HandleType *HandlePtr)
{
 80220dc:	b480      	push	{r7}
 80220de:	b085      	sub	sp, #20
 80220e0:	af00      	add	r7, sp, #0
 80220e2:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 80220e4:	f04f 0301 	mov.w	r3, #1
 80220e8:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 80220ea:	687b      	ldr	r3, [r7, #4]
 80220ec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80220ee:	60bb      	str	r3, [r7, #8]

  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 80220f0:	687b      	ldr	r3, [r7, #4]
 80220f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80220f4:	781b      	ldrb	r3, [r3, #0]
 80220f6:	2b01      	cmp	r3, #1
 80220f8:	d10a      	bne.n	8022110 <ADC002_SetSourceEventFlag+0x34>
  {
    /* Sets event flag */
    SET_BIT(VADCGroupPtr->SEFLAG, VADC_G_SEFLAG_SEV0_Pos);
 80220fa:	68bb      	ldr	r3, [r7, #8]
 80220fc:	f8d3 3188 	ldr.w	r3, [r3, #392]	; 0x188
 8022100:	f043 0201 	orr.w	r2, r3, #1
 8022104:	68bb      	ldr	r3, [r7, #8]
 8022106:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    Status = (uint32_t)DAVEApp_SUCCESS;
 802210a:	f04f 0300 	mov.w	r3, #0
 802210e:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8022110:	68fb      	ldr	r3, [r7, #12]
}
 8022112:	4618      	mov	r0, r3
 8022114:	f107 0714 	add.w	r7, r7, #20
 8022118:	46bd      	mov	sp, r7
 802211a:	bc80      	pop	{r7}
 802211c:	4770      	bx	lr
 802211e:	bf00      	nop

08022120 <ADC002_ClearSourceEventFlag>:


/* This function clears the source Event flag. */
status_t ADC002_ClearSourceEventFlag(const ADC002_HandleType *HandlePtr) 
{
 8022120:	b480      	push	{r7}
 8022122:	b085      	sub	sp, #20
 8022124:	af00      	add	r7, sp, #0
 8022126:	6078      	str	r0, [r7, #4]
  status_t Status = (uint32_t)ADC002_OPER_NOT_ALLOWED_ERROR;
 8022128:	f04f 0301 	mov.w	r3, #1
 802212c:	60fb      	str	r3, [r7, #12]
    /*Pointer to the VADC Group register structure */
  VADC_G_TypeDef *VADCGroupPtr = HandlePtr->VADCGroupPtr;
 802212e:	687b      	ldr	r3, [r7, #4]
 8022130:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8022132:	60bb      	str	r3, [r7, #8]
  FUNCTION_ENTRY(GID_ADC002, ADC002_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == ADC002_INITIALIZED)
 8022134:	687b      	ldr	r3, [r7, #4]
 8022136:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8022138:	781b      	ldrb	r3, [r3, #0]
 802213a:	2b01      	cmp	r3, #1
 802213c:	d10a      	bne.n	8022154 <ADC002_ClearSourceEventFlag+0x34>
  {
      /* Sets event flag */
      SET_BIT(VADCGroupPtr->SEFCLR, VADC_G_SEFCLR_SEV0_Pos);
 802213e:	68bb      	ldr	r3, [r7, #8]
 8022140:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 8022144:	f043 0201 	orr.w	r2, r3, #1
 8022148:	68bb      	ldr	r3, [r7, #8]
 802214a:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
      Status = (uint32_t)DAVEApp_SUCCESS;
 802214e:	f04f 0300 	mov.w	r3, #0
 8022152:	60fb      	str	r3, [r7, #12]
  {
    ERROR(GID_ADC002, (uint8_t)Status, 0, (uint8_t*)NULL);
  }
  
  FUNCTION_EXIT(GID_ADC002, ADC002_FUNCTION_EXIT);
  return Status;
 8022154:	68fb      	ldr	r3, [r7, #12]
}
 8022156:	4618      	mov	r0, r3
 8022158:	f107 0714 	add.w	r7, r7, #20
 802215c:	46bd      	mov	sp, r7
 802215e:	bc80      	pop	{r7}
 8022160:	4770      	bx	lr
 8022162:	bf00      	nop

08022164 <__aeabi_drsub>:
 8022164:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8022168:	e002      	b.n	8022170 <__adddf3>
 802216a:	bf00      	nop

0802216c <__aeabi_dsub>:
 802216c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08022170 <__adddf3>:
 8022170:	b530      	push	{r4, r5, lr}
 8022172:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8022176:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802217a:	ea94 0f05 	teq	r4, r5
 802217e:	bf08      	it	eq
 8022180:	ea90 0f02 	teqeq	r0, r2
 8022184:	bf1f      	itttt	ne
 8022186:	ea54 0c00 	orrsne.w	ip, r4, r0
 802218a:	ea55 0c02 	orrsne.w	ip, r5, r2
 802218e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8022192:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8022196:	f000 80e2 	beq.w	802235e <__adddf3+0x1ee>
 802219a:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802219e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80221a2:	bfb8      	it	lt
 80221a4:	426d      	neglt	r5, r5
 80221a6:	dd0c      	ble.n	80221c2 <__adddf3+0x52>
 80221a8:	442c      	add	r4, r5
 80221aa:	ea80 0202 	eor.w	r2, r0, r2
 80221ae:	ea81 0303 	eor.w	r3, r1, r3
 80221b2:	ea82 0000 	eor.w	r0, r2, r0
 80221b6:	ea83 0101 	eor.w	r1, r3, r1
 80221ba:	ea80 0202 	eor.w	r2, r0, r2
 80221be:	ea81 0303 	eor.w	r3, r1, r3
 80221c2:	2d36      	cmp	r5, #54	; 0x36
 80221c4:	bf88      	it	hi
 80221c6:	bd30      	pophi	{r4, r5, pc}
 80221c8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80221cc:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80221d0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80221d4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80221d8:	d002      	beq.n	80221e0 <__adddf3+0x70>
 80221da:	4240      	negs	r0, r0
 80221dc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80221e0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80221e4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80221e8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80221ec:	d002      	beq.n	80221f4 <__adddf3+0x84>
 80221ee:	4252      	negs	r2, r2
 80221f0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80221f4:	ea94 0f05 	teq	r4, r5
 80221f8:	f000 80a7 	beq.w	802234a <__adddf3+0x1da>
 80221fc:	f1a4 0401 	sub.w	r4, r4, #1
 8022200:	f1d5 0e20 	rsbs	lr, r5, #32
 8022204:	db0d      	blt.n	8022222 <__adddf3+0xb2>
 8022206:	fa02 fc0e 	lsl.w	ip, r2, lr
 802220a:	fa22 f205 	lsr.w	r2, r2, r5
 802220e:	1880      	adds	r0, r0, r2
 8022210:	f141 0100 	adc.w	r1, r1, #0
 8022214:	fa03 f20e 	lsl.w	r2, r3, lr
 8022218:	1880      	adds	r0, r0, r2
 802221a:	fa43 f305 	asr.w	r3, r3, r5
 802221e:	4159      	adcs	r1, r3
 8022220:	e00e      	b.n	8022240 <__adddf3+0xd0>
 8022222:	f1a5 0520 	sub.w	r5, r5, #32
 8022226:	f10e 0e20 	add.w	lr, lr, #32
 802222a:	2a01      	cmp	r2, #1
 802222c:	fa03 fc0e 	lsl.w	ip, r3, lr
 8022230:	bf28      	it	cs
 8022232:	f04c 0c02 	orrcs.w	ip, ip, #2
 8022236:	fa43 f305 	asr.w	r3, r3, r5
 802223a:	18c0      	adds	r0, r0, r3
 802223c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8022240:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8022244:	d507      	bpl.n	8022256 <__adddf3+0xe6>
 8022246:	f04f 0e00 	mov.w	lr, #0
 802224a:	f1dc 0c00 	rsbs	ip, ip, #0
 802224e:	eb7e 0000 	sbcs.w	r0, lr, r0
 8022252:	eb6e 0101 	sbc.w	r1, lr, r1
 8022256:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802225a:	d31b      	bcc.n	8022294 <__adddf3+0x124>
 802225c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8022260:	d30c      	bcc.n	802227c <__adddf3+0x10c>
 8022262:	0849      	lsrs	r1, r1, #1
 8022264:	ea5f 0030 	movs.w	r0, r0, rrx
 8022268:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802226c:	f104 0401 	add.w	r4, r4, #1
 8022270:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8022274:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8022278:	f080 809a 	bcs.w	80223b0 <__adddf3+0x240>
 802227c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8022280:	bf08      	it	eq
 8022282:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8022286:	f150 0000 	adcs.w	r0, r0, #0
 802228a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802228e:	ea41 0105 	orr.w	r1, r1, r5
 8022292:	bd30      	pop	{r4, r5, pc}
 8022294:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8022298:	4140      	adcs	r0, r0
 802229a:	eb41 0101 	adc.w	r1, r1, r1
 802229e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80222a2:	f1a4 0401 	sub.w	r4, r4, #1
 80222a6:	d1e9      	bne.n	802227c <__adddf3+0x10c>
 80222a8:	f091 0f00 	teq	r1, #0
 80222ac:	bf04      	itt	eq
 80222ae:	4601      	moveq	r1, r0
 80222b0:	2000      	moveq	r0, #0
 80222b2:	fab1 f381 	clz	r3, r1
 80222b6:	bf08      	it	eq
 80222b8:	3320      	addeq	r3, #32
 80222ba:	f1a3 030b 	sub.w	r3, r3, #11
 80222be:	f1b3 0220 	subs.w	r2, r3, #32
 80222c2:	da0c      	bge.n	80222de <__adddf3+0x16e>
 80222c4:	320c      	adds	r2, #12
 80222c6:	dd08      	ble.n	80222da <__adddf3+0x16a>
 80222c8:	f102 0c14 	add.w	ip, r2, #20
 80222cc:	f1c2 020c 	rsb	r2, r2, #12
 80222d0:	fa01 f00c 	lsl.w	r0, r1, ip
 80222d4:	fa21 f102 	lsr.w	r1, r1, r2
 80222d8:	e00c      	b.n	80222f4 <__adddf3+0x184>
 80222da:	f102 0214 	add.w	r2, r2, #20
 80222de:	bfd8      	it	le
 80222e0:	f1c2 0c20 	rsble	ip, r2, #32
 80222e4:	fa01 f102 	lsl.w	r1, r1, r2
 80222e8:	fa20 fc0c 	lsr.w	ip, r0, ip
 80222ec:	bfdc      	itt	le
 80222ee:	ea41 010c 	orrle.w	r1, r1, ip
 80222f2:	4090      	lslle	r0, r2
 80222f4:	1ae4      	subs	r4, r4, r3
 80222f6:	bfa2      	ittt	ge
 80222f8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80222fc:	4329      	orrge	r1, r5
 80222fe:	bd30      	popge	{r4, r5, pc}
 8022300:	ea6f 0404 	mvn.w	r4, r4
 8022304:	3c1f      	subs	r4, #31
 8022306:	da1c      	bge.n	8022342 <__adddf3+0x1d2>
 8022308:	340c      	adds	r4, #12
 802230a:	dc0e      	bgt.n	802232a <__adddf3+0x1ba>
 802230c:	f104 0414 	add.w	r4, r4, #20
 8022310:	f1c4 0220 	rsb	r2, r4, #32
 8022314:	fa20 f004 	lsr.w	r0, r0, r4
 8022318:	fa01 f302 	lsl.w	r3, r1, r2
 802231c:	ea40 0003 	orr.w	r0, r0, r3
 8022320:	fa21 f304 	lsr.w	r3, r1, r4
 8022324:	ea45 0103 	orr.w	r1, r5, r3
 8022328:	bd30      	pop	{r4, r5, pc}
 802232a:	f1c4 040c 	rsb	r4, r4, #12
 802232e:	f1c4 0220 	rsb	r2, r4, #32
 8022332:	fa20 f002 	lsr.w	r0, r0, r2
 8022336:	fa01 f304 	lsl.w	r3, r1, r4
 802233a:	ea40 0003 	orr.w	r0, r0, r3
 802233e:	4629      	mov	r1, r5
 8022340:	bd30      	pop	{r4, r5, pc}
 8022342:	fa21 f004 	lsr.w	r0, r1, r4
 8022346:	4629      	mov	r1, r5
 8022348:	bd30      	pop	{r4, r5, pc}
 802234a:	f094 0f00 	teq	r4, #0
 802234e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8022352:	bf06      	itte	eq
 8022354:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8022358:	3401      	addeq	r4, #1
 802235a:	3d01      	subne	r5, #1
 802235c:	e74e      	b.n	80221fc <__adddf3+0x8c>
 802235e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8022362:	bf18      	it	ne
 8022364:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8022368:	d029      	beq.n	80223be <__adddf3+0x24e>
 802236a:	ea94 0f05 	teq	r4, r5
 802236e:	bf08      	it	eq
 8022370:	ea90 0f02 	teqeq	r0, r2
 8022374:	d005      	beq.n	8022382 <__adddf3+0x212>
 8022376:	ea54 0c00 	orrs.w	ip, r4, r0
 802237a:	bf04      	itt	eq
 802237c:	4619      	moveq	r1, r3
 802237e:	4610      	moveq	r0, r2
 8022380:	bd30      	pop	{r4, r5, pc}
 8022382:	ea91 0f03 	teq	r1, r3
 8022386:	bf1e      	ittt	ne
 8022388:	2100      	movne	r1, #0
 802238a:	2000      	movne	r0, #0
 802238c:	bd30      	popne	{r4, r5, pc}
 802238e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8022392:	d105      	bne.n	80223a0 <__adddf3+0x230>
 8022394:	0040      	lsls	r0, r0, #1
 8022396:	4149      	adcs	r1, r1
 8022398:	bf28      	it	cs
 802239a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802239e:	bd30      	pop	{r4, r5, pc}
 80223a0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80223a4:	bf3c      	itt	cc
 80223a6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80223aa:	bd30      	popcc	{r4, r5, pc}
 80223ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80223b0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80223b4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80223b8:	f04f 0000 	mov.w	r0, #0
 80223bc:	bd30      	pop	{r4, r5, pc}
 80223be:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80223c2:	bf1a      	itte	ne
 80223c4:	4619      	movne	r1, r3
 80223c6:	4610      	movne	r0, r2
 80223c8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80223cc:	bf1c      	itt	ne
 80223ce:	460b      	movne	r3, r1
 80223d0:	4602      	movne	r2, r0
 80223d2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80223d6:	bf06      	itte	eq
 80223d8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80223dc:	ea91 0f03 	teqeq	r1, r3
 80223e0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80223e4:	bd30      	pop	{r4, r5, pc}
 80223e6:	bf00      	nop

080223e8 <__aeabi_ui2d>:
 80223e8:	f090 0f00 	teq	r0, #0
 80223ec:	bf04      	itt	eq
 80223ee:	2100      	moveq	r1, #0
 80223f0:	4770      	bxeq	lr
 80223f2:	b530      	push	{r4, r5, lr}
 80223f4:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80223f8:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80223fc:	f04f 0500 	mov.w	r5, #0
 8022400:	f04f 0100 	mov.w	r1, #0
 8022404:	e750      	b.n	80222a8 <__adddf3+0x138>
 8022406:	bf00      	nop

08022408 <__aeabi_i2d>:
 8022408:	f090 0f00 	teq	r0, #0
 802240c:	bf04      	itt	eq
 802240e:	2100      	moveq	r1, #0
 8022410:	4770      	bxeq	lr
 8022412:	b530      	push	{r4, r5, lr}
 8022414:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8022418:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802241c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8022420:	bf48      	it	mi
 8022422:	4240      	negmi	r0, r0
 8022424:	f04f 0100 	mov.w	r1, #0
 8022428:	e73e      	b.n	80222a8 <__adddf3+0x138>
 802242a:	bf00      	nop

0802242c <__aeabi_f2d>:
 802242c:	0042      	lsls	r2, r0, #1
 802242e:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8022432:	ea4f 0131 	mov.w	r1, r1, rrx
 8022436:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802243a:	bf1f      	itttt	ne
 802243c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8022440:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8022444:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8022448:	4770      	bxne	lr
 802244a:	f092 0f00 	teq	r2, #0
 802244e:	bf14      	ite	ne
 8022450:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8022454:	4770      	bxeq	lr
 8022456:	b530      	push	{r4, r5, lr}
 8022458:	f44f 7460 	mov.w	r4, #896	; 0x380
 802245c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8022460:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8022464:	e720      	b.n	80222a8 <__adddf3+0x138>
 8022466:	bf00      	nop

08022468 <__aeabi_ul2d>:
 8022468:	ea50 0201 	orrs.w	r2, r0, r1
 802246c:	bf08      	it	eq
 802246e:	4770      	bxeq	lr
 8022470:	b530      	push	{r4, r5, lr}
 8022472:	f04f 0500 	mov.w	r5, #0
 8022476:	e00a      	b.n	802248e <__aeabi_l2d+0x16>

08022478 <__aeabi_l2d>:
 8022478:	ea50 0201 	orrs.w	r2, r0, r1
 802247c:	bf08      	it	eq
 802247e:	4770      	bxeq	lr
 8022480:	b530      	push	{r4, r5, lr}
 8022482:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8022486:	d502      	bpl.n	802248e <__aeabi_l2d+0x16>
 8022488:	4240      	negs	r0, r0
 802248a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802248e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8022492:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8022496:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802249a:	f43f aedc 	beq.w	8022256 <__adddf3+0xe6>
 802249e:	f04f 0203 	mov.w	r2, #3
 80224a2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80224a6:	bf18      	it	ne
 80224a8:	3203      	addne	r2, #3
 80224aa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80224ae:	bf18      	it	ne
 80224b0:	3203      	addne	r2, #3
 80224b2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80224b6:	f1c2 0320 	rsb	r3, r2, #32
 80224ba:	fa00 fc03 	lsl.w	ip, r0, r3
 80224be:	fa20 f002 	lsr.w	r0, r0, r2
 80224c2:	fa01 fe03 	lsl.w	lr, r1, r3
 80224c6:	ea40 000e 	orr.w	r0, r0, lr
 80224ca:	fa21 f102 	lsr.w	r1, r1, r2
 80224ce:	4414      	add	r4, r2
 80224d0:	e6c1      	b.n	8022256 <__adddf3+0xe6>
 80224d2:	bf00      	nop

080224d4 <__aeabi_dmul>:
 80224d4:	b570      	push	{r4, r5, r6, lr}
 80224d6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80224da:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80224de:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80224e2:	bf1d      	ittte	ne
 80224e4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80224e8:	ea94 0f0c 	teqne	r4, ip
 80224ec:	ea95 0f0c 	teqne	r5, ip
 80224f0:	f000 f8de 	bleq	80226b0 <__aeabi_dmul+0x1dc>
 80224f4:	442c      	add	r4, r5
 80224f6:	ea81 0603 	eor.w	r6, r1, r3
 80224fa:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80224fe:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8022502:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8022506:	bf18      	it	ne
 8022508:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 802250c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8022510:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8022514:	d038      	beq.n	8022588 <__aeabi_dmul+0xb4>
 8022516:	fba0 ce02 	umull	ip, lr, r0, r2
 802251a:	f04f 0500 	mov.w	r5, #0
 802251e:	fbe1 e502 	umlal	lr, r5, r1, r2
 8022522:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8022526:	fbe0 e503 	umlal	lr, r5, r0, r3
 802252a:	f04f 0600 	mov.w	r6, #0
 802252e:	fbe1 5603 	umlal	r5, r6, r1, r3
 8022532:	f09c 0f00 	teq	ip, #0
 8022536:	bf18      	it	ne
 8022538:	f04e 0e01 	orrne.w	lr, lr, #1
 802253c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8022540:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8022544:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8022548:	d204      	bcs.n	8022554 <__aeabi_dmul+0x80>
 802254a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 802254e:	416d      	adcs	r5, r5
 8022550:	eb46 0606 	adc.w	r6, r6, r6
 8022554:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8022558:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 802255c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8022560:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8022564:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8022568:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802256c:	bf88      	it	hi
 802256e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8022572:	d81e      	bhi.n	80225b2 <__aeabi_dmul+0xde>
 8022574:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8022578:	bf08      	it	eq
 802257a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 802257e:	f150 0000 	adcs.w	r0, r0, #0
 8022582:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8022586:	bd70      	pop	{r4, r5, r6, pc}
 8022588:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 802258c:	ea46 0101 	orr.w	r1, r6, r1
 8022590:	ea40 0002 	orr.w	r0, r0, r2
 8022594:	ea81 0103 	eor.w	r1, r1, r3
 8022598:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 802259c:	bfc2      	ittt	gt
 802259e:	ebd4 050c 	rsbsgt	r5, r4, ip
 80225a2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80225a6:	bd70      	popgt	{r4, r5, r6, pc}
 80225a8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80225ac:	f04f 0e00 	mov.w	lr, #0
 80225b0:	3c01      	subs	r4, #1
 80225b2:	f300 80ab 	bgt.w	802270c <__aeabi_dmul+0x238>
 80225b6:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80225ba:	bfde      	ittt	le
 80225bc:	2000      	movle	r0, #0
 80225be:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80225c2:	bd70      	pople	{r4, r5, r6, pc}
 80225c4:	f1c4 0400 	rsb	r4, r4, #0
 80225c8:	3c20      	subs	r4, #32
 80225ca:	da35      	bge.n	8022638 <__aeabi_dmul+0x164>
 80225cc:	340c      	adds	r4, #12
 80225ce:	dc1b      	bgt.n	8022608 <__aeabi_dmul+0x134>
 80225d0:	f104 0414 	add.w	r4, r4, #20
 80225d4:	f1c4 0520 	rsb	r5, r4, #32
 80225d8:	fa00 f305 	lsl.w	r3, r0, r5
 80225dc:	fa20 f004 	lsr.w	r0, r0, r4
 80225e0:	fa01 f205 	lsl.w	r2, r1, r5
 80225e4:	ea40 0002 	orr.w	r0, r0, r2
 80225e8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80225ec:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80225f0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80225f4:	fa21 f604 	lsr.w	r6, r1, r4
 80225f8:	eb42 0106 	adc.w	r1, r2, r6
 80225fc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8022600:	bf08      	it	eq
 8022602:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8022606:	bd70      	pop	{r4, r5, r6, pc}
 8022608:	f1c4 040c 	rsb	r4, r4, #12
 802260c:	f1c4 0520 	rsb	r5, r4, #32
 8022610:	fa00 f304 	lsl.w	r3, r0, r4
 8022614:	fa20 f005 	lsr.w	r0, r0, r5
 8022618:	fa01 f204 	lsl.w	r2, r1, r4
 802261c:	ea40 0002 	orr.w	r0, r0, r2
 8022620:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8022624:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8022628:	f141 0100 	adc.w	r1, r1, #0
 802262c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8022630:	bf08      	it	eq
 8022632:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8022636:	bd70      	pop	{r4, r5, r6, pc}
 8022638:	f1c4 0520 	rsb	r5, r4, #32
 802263c:	fa00 f205 	lsl.w	r2, r0, r5
 8022640:	ea4e 0e02 	orr.w	lr, lr, r2
 8022644:	fa20 f304 	lsr.w	r3, r0, r4
 8022648:	fa01 f205 	lsl.w	r2, r1, r5
 802264c:	ea43 0302 	orr.w	r3, r3, r2
 8022650:	fa21 f004 	lsr.w	r0, r1, r4
 8022654:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8022658:	fa21 f204 	lsr.w	r2, r1, r4
 802265c:	ea20 0002 	bic.w	r0, r0, r2
 8022660:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8022664:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8022668:	bf08      	it	eq
 802266a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802266e:	bd70      	pop	{r4, r5, r6, pc}
 8022670:	f094 0f00 	teq	r4, #0
 8022674:	d10f      	bne.n	8022696 <__aeabi_dmul+0x1c2>
 8022676:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 802267a:	0040      	lsls	r0, r0, #1
 802267c:	eb41 0101 	adc.w	r1, r1, r1
 8022680:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8022684:	bf08      	it	eq
 8022686:	3c01      	subeq	r4, #1
 8022688:	d0f7      	beq.n	802267a <__aeabi_dmul+0x1a6>
 802268a:	ea41 0106 	orr.w	r1, r1, r6
 802268e:	f095 0f00 	teq	r5, #0
 8022692:	bf18      	it	ne
 8022694:	4770      	bxne	lr
 8022696:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 802269a:	0052      	lsls	r2, r2, #1
 802269c:	eb43 0303 	adc.w	r3, r3, r3
 80226a0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80226a4:	bf08      	it	eq
 80226a6:	3d01      	subeq	r5, #1
 80226a8:	d0f7      	beq.n	802269a <__aeabi_dmul+0x1c6>
 80226aa:	ea43 0306 	orr.w	r3, r3, r6
 80226ae:	4770      	bx	lr
 80226b0:	ea94 0f0c 	teq	r4, ip
 80226b4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80226b8:	bf18      	it	ne
 80226ba:	ea95 0f0c 	teqne	r5, ip
 80226be:	d00c      	beq.n	80226da <__aeabi_dmul+0x206>
 80226c0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80226c4:	bf18      	it	ne
 80226c6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80226ca:	d1d1      	bne.n	8022670 <__aeabi_dmul+0x19c>
 80226cc:	ea81 0103 	eor.w	r1, r1, r3
 80226d0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80226d4:	f04f 0000 	mov.w	r0, #0
 80226d8:	bd70      	pop	{r4, r5, r6, pc}
 80226da:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80226de:	bf06      	itte	eq
 80226e0:	4610      	moveq	r0, r2
 80226e2:	4619      	moveq	r1, r3
 80226e4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80226e8:	d019      	beq.n	802271e <__aeabi_dmul+0x24a>
 80226ea:	ea94 0f0c 	teq	r4, ip
 80226ee:	d102      	bne.n	80226f6 <__aeabi_dmul+0x222>
 80226f0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80226f4:	d113      	bne.n	802271e <__aeabi_dmul+0x24a>
 80226f6:	ea95 0f0c 	teq	r5, ip
 80226fa:	d105      	bne.n	8022708 <__aeabi_dmul+0x234>
 80226fc:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8022700:	bf1c      	itt	ne
 8022702:	4610      	movne	r0, r2
 8022704:	4619      	movne	r1, r3
 8022706:	d10a      	bne.n	802271e <__aeabi_dmul+0x24a>
 8022708:	ea81 0103 	eor.w	r1, r1, r3
 802270c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8022710:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8022714:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8022718:	f04f 0000 	mov.w	r0, #0
 802271c:	bd70      	pop	{r4, r5, r6, pc}
 802271e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8022722:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8022726:	bd70      	pop	{r4, r5, r6, pc}

08022728 <__aeabi_ddiv>:
 8022728:	b570      	push	{r4, r5, r6, lr}
 802272a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802272e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8022732:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8022736:	bf1d      	ittte	ne
 8022738:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802273c:	ea94 0f0c 	teqne	r4, ip
 8022740:	ea95 0f0c 	teqne	r5, ip
 8022744:	f000 f8a7 	bleq	8022896 <__aeabi_ddiv+0x16e>
 8022748:	eba4 0405 	sub.w	r4, r4, r5
 802274c:	ea81 0e03 	eor.w	lr, r1, r3
 8022750:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8022754:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8022758:	f000 8088 	beq.w	802286c <__aeabi_ddiv+0x144>
 802275c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8022760:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8022764:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8022768:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 802276c:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8022770:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8022774:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8022778:	ea4f 2600 	mov.w	r6, r0, lsl #8
 802277c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8022780:	429d      	cmp	r5, r3
 8022782:	bf08      	it	eq
 8022784:	4296      	cmpeq	r6, r2
 8022786:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 802278a:	f504 7440 	add.w	r4, r4, #768	; 0x300
 802278e:	d202      	bcs.n	8022796 <__aeabi_ddiv+0x6e>
 8022790:	085b      	lsrs	r3, r3, #1
 8022792:	ea4f 0232 	mov.w	r2, r2, rrx
 8022796:	1ab6      	subs	r6, r6, r2
 8022798:	eb65 0503 	sbc.w	r5, r5, r3
 802279c:	085b      	lsrs	r3, r3, #1
 802279e:	ea4f 0232 	mov.w	r2, r2, rrx
 80227a2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80227a6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80227aa:	ebb6 0e02 	subs.w	lr, r6, r2
 80227ae:	eb75 0e03 	sbcs.w	lr, r5, r3
 80227b2:	bf22      	ittt	cs
 80227b4:	1ab6      	subcs	r6, r6, r2
 80227b6:	4675      	movcs	r5, lr
 80227b8:	ea40 000c 	orrcs.w	r0, r0, ip
 80227bc:	085b      	lsrs	r3, r3, #1
 80227be:	ea4f 0232 	mov.w	r2, r2, rrx
 80227c2:	ebb6 0e02 	subs.w	lr, r6, r2
 80227c6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80227ca:	bf22      	ittt	cs
 80227cc:	1ab6      	subcs	r6, r6, r2
 80227ce:	4675      	movcs	r5, lr
 80227d0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80227d4:	085b      	lsrs	r3, r3, #1
 80227d6:	ea4f 0232 	mov.w	r2, r2, rrx
 80227da:	ebb6 0e02 	subs.w	lr, r6, r2
 80227de:	eb75 0e03 	sbcs.w	lr, r5, r3
 80227e2:	bf22      	ittt	cs
 80227e4:	1ab6      	subcs	r6, r6, r2
 80227e6:	4675      	movcs	r5, lr
 80227e8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80227ec:	085b      	lsrs	r3, r3, #1
 80227ee:	ea4f 0232 	mov.w	r2, r2, rrx
 80227f2:	ebb6 0e02 	subs.w	lr, r6, r2
 80227f6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80227fa:	bf22      	ittt	cs
 80227fc:	1ab6      	subcs	r6, r6, r2
 80227fe:	4675      	movcs	r5, lr
 8022800:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8022804:	ea55 0e06 	orrs.w	lr, r5, r6
 8022808:	d018      	beq.n	802283c <__aeabi_ddiv+0x114>
 802280a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 802280e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8022812:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8022816:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 802281a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 802281e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8022822:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8022826:	d1c0      	bne.n	80227aa <__aeabi_ddiv+0x82>
 8022828:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802282c:	d10b      	bne.n	8022846 <__aeabi_ddiv+0x11e>
 802282e:	ea41 0100 	orr.w	r1, r1, r0
 8022832:	f04f 0000 	mov.w	r0, #0
 8022836:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 802283a:	e7b6      	b.n	80227aa <__aeabi_ddiv+0x82>
 802283c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8022840:	bf04      	itt	eq
 8022842:	4301      	orreq	r1, r0
 8022844:	2000      	moveq	r0, #0
 8022846:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802284a:	bf88      	it	hi
 802284c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8022850:	f63f aeaf 	bhi.w	80225b2 <__aeabi_dmul+0xde>
 8022854:	ebb5 0c03 	subs.w	ip, r5, r3
 8022858:	bf04      	itt	eq
 802285a:	ebb6 0c02 	subseq.w	ip, r6, r2
 802285e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8022862:	f150 0000 	adcs.w	r0, r0, #0
 8022866:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802286a:	bd70      	pop	{r4, r5, r6, pc}
 802286c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8022870:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8022874:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8022878:	bfc2      	ittt	gt
 802287a:	ebd4 050c 	rsbsgt	r5, r4, ip
 802287e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8022882:	bd70      	popgt	{r4, r5, r6, pc}
 8022884:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8022888:	f04f 0e00 	mov.w	lr, #0
 802288c:	3c01      	subs	r4, #1
 802288e:	e690      	b.n	80225b2 <__aeabi_dmul+0xde>
 8022890:	ea45 0e06 	orr.w	lr, r5, r6
 8022894:	e68d      	b.n	80225b2 <__aeabi_dmul+0xde>
 8022896:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802289a:	ea94 0f0c 	teq	r4, ip
 802289e:	bf08      	it	eq
 80228a0:	ea95 0f0c 	teqeq	r5, ip
 80228a4:	f43f af3b 	beq.w	802271e <__aeabi_dmul+0x24a>
 80228a8:	ea94 0f0c 	teq	r4, ip
 80228ac:	d10a      	bne.n	80228c4 <__aeabi_ddiv+0x19c>
 80228ae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80228b2:	f47f af34 	bne.w	802271e <__aeabi_dmul+0x24a>
 80228b6:	ea95 0f0c 	teq	r5, ip
 80228ba:	f47f af25 	bne.w	8022708 <__aeabi_dmul+0x234>
 80228be:	4610      	mov	r0, r2
 80228c0:	4619      	mov	r1, r3
 80228c2:	e72c      	b.n	802271e <__aeabi_dmul+0x24a>
 80228c4:	ea95 0f0c 	teq	r5, ip
 80228c8:	d106      	bne.n	80228d8 <__aeabi_ddiv+0x1b0>
 80228ca:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80228ce:	f43f aefd 	beq.w	80226cc <__aeabi_dmul+0x1f8>
 80228d2:	4610      	mov	r0, r2
 80228d4:	4619      	mov	r1, r3
 80228d6:	e722      	b.n	802271e <__aeabi_dmul+0x24a>
 80228d8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80228dc:	bf18      	it	ne
 80228de:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80228e2:	f47f aec5 	bne.w	8022670 <__aeabi_dmul+0x19c>
 80228e6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80228ea:	f47f af0d 	bne.w	8022708 <__aeabi_dmul+0x234>
 80228ee:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80228f2:	f47f aeeb 	bne.w	80226cc <__aeabi_dmul+0x1f8>
 80228f6:	e712      	b.n	802271e <__aeabi_dmul+0x24a>

080228f8 <__aeabi_d2uiz>:
 80228f8:	004a      	lsls	r2, r1, #1
 80228fa:	d211      	bcs.n	8022920 <__aeabi_d2uiz+0x28>
 80228fc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8022900:	d211      	bcs.n	8022926 <__aeabi_d2uiz+0x2e>
 8022902:	d50d      	bpl.n	8022920 <__aeabi_d2uiz+0x28>
 8022904:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8022908:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802290c:	d40e      	bmi.n	802292c <__aeabi_d2uiz+0x34>
 802290e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8022912:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8022916:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802291a:	fa23 f002 	lsr.w	r0, r3, r2
 802291e:	4770      	bx	lr
 8022920:	f04f 0000 	mov.w	r0, #0
 8022924:	4770      	bx	lr
 8022926:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802292a:	d102      	bne.n	8022932 <__aeabi_d2uiz+0x3a>
 802292c:	f04f 30ff 	mov.w	r0, #4294967295
 8022930:	4770      	bx	lr
 8022932:	f04f 0000 	mov.w	r0, #0
 8022936:	4770      	bx	lr

08022938 <calloc>:
 8022938:	b410      	push	{r4}
 802293a:	f646 3380 	movw	r3, #27520	; 0x6b80
 802293e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022942:	4604      	mov	r4, r0
 8022944:	6818      	ldr	r0, [r3, #0]
 8022946:	460a      	mov	r2, r1
 8022948:	4621      	mov	r1, r4
 802294a:	bc10      	pop	{r4}
 802294c:	f7e1 beb6 	b.w	80046bc <_calloc_r>

08022950 <__errno>:
 8022950:	f646 3380 	movw	r3, #27520	; 0x6b80
 8022954:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022958:	6818      	ldr	r0, [r3, #0]
 802295a:	4770      	bx	lr

0802295c <_fclose_r>:
 802295c:	b570      	push	{r4, r5, r6, lr}
 802295e:	460c      	mov	r4, r1
 8022960:	4605      	mov	r5, r0
 8022962:	2900      	cmp	r1, #0
 8022964:	d034      	beq.n	80229d0 <_fclose_r+0x74>
 8022966:	f000 f9d9 	bl	8022d1c <__sfp_lock_acquire>
 802296a:	b115      	cbz	r5, 8022972 <_fclose_r+0x16>
 802296c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 802296e:	2b00      	cmp	r3, #0
 8022970:	d031      	beq.n	80229d6 <_fclose_r+0x7a>
 8022972:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 8022976:	b33e      	cbz	r6, 80229c8 <_fclose_r+0x6c>
 8022978:	4628      	mov	r0, r5
 802297a:	4621      	mov	r1, r4
 802297c:	f000 f840 	bl	8022a00 <_fflush_r>
 8022980:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8022982:	4606      	mov	r6, r0
 8022984:	b13a      	cbz	r2, 8022996 <_fclose_r+0x3a>
 8022986:	4628      	mov	r0, r5
 8022988:	69e1      	ldr	r1, [r4, #28]
 802298a:	4790      	blx	r2
 802298c:	ea36 0620 	bics.w	r6, r6, r0, asr #32
 8022990:	bf28      	it	cs
 8022992:	f04f 36ff 	movcs.w	r6, #4294967295
 8022996:	89a0      	ldrh	r0, [r4, #12]
 8022998:	f000 0180 	and.w	r1, r0, #128	; 0x80
 802299c:	b20b      	sxth	r3, r1
 802299e:	bb13      	cbnz	r3, 80229e6 <_fclose_r+0x8a>
 80229a0:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80229a2:	b141      	cbz	r1, 80229b6 <_fclose_r+0x5a>
 80229a4:	f104 0240 	add.w	r2, r4, #64	; 0x40
 80229a8:	4291      	cmp	r1, r2
 80229aa:	d002      	beq.n	80229b2 <_fclose_r+0x56>
 80229ac:	4628      	mov	r0, r5
 80229ae:	f7e1 fea7 	bl	8004700 <_free_r>
 80229b2:	2000      	movs	r0, #0
 80229b4:	6320      	str	r0, [r4, #48]	; 0x30
 80229b6:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80229b8:	b121      	cbz	r1, 80229c4 <_fclose_r+0x68>
 80229ba:	4628      	mov	r0, r5
 80229bc:	f7e1 fea0 	bl	8004700 <_free_r>
 80229c0:	2100      	movs	r1, #0
 80229c2:	6461      	str	r1, [r4, #68]	; 0x44
 80229c4:	2300      	movs	r3, #0
 80229c6:	81a3      	strh	r3, [r4, #12]
 80229c8:	f000 f9aa 	bl	8022d20 <__sfp_lock_release>
 80229cc:	4630      	mov	r0, r6
 80229ce:	bd70      	pop	{r4, r5, r6, pc}
 80229d0:	460e      	mov	r6, r1
 80229d2:	4630      	mov	r0, r6
 80229d4:	bd70      	pop	{r4, r5, r6, pc}
 80229d6:	4628      	mov	r0, r5
 80229d8:	f000 f928 	bl	8022c2c <__sinit>
 80229dc:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 80229e0:	2e00      	cmp	r6, #0
 80229e2:	d1c9      	bne.n	8022978 <_fclose_r+0x1c>
 80229e4:	e7f0      	b.n	80229c8 <_fclose_r+0x6c>
 80229e6:	4628      	mov	r0, r5
 80229e8:	6921      	ldr	r1, [r4, #16]
 80229ea:	f7e1 fe89 	bl	8004700 <_free_r>
 80229ee:	e7d7      	b.n	80229a0 <_fclose_r+0x44>

080229f0 <fclose>:
 80229f0:	f646 3380 	movw	r3, #27520	; 0x6b80
 80229f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80229f8:	4601      	mov	r1, r0
 80229fa:	6818      	ldr	r0, [r3, #0]
 80229fc:	f7ff bfae 	b.w	802295c <_fclose_r>

08022a00 <_fflush_r>:
 8022a00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022a04:	460d      	mov	r5, r1
 8022a06:	4680      	mov	r8, r0
 8022a08:	b110      	cbz	r0, 8022a10 <_fflush_r+0x10>
 8022a0a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8022a0c:	2b00      	cmp	r3, #0
 8022a0e:	d062      	beq.n	8022ad6 <_fflush_r+0xd6>
 8022a10:	89a8      	ldrh	r0, [r5, #12]
 8022a12:	b1e0      	cbz	r0, 8022a4e <_fflush_r+0x4e>
 8022a14:	f000 0208 	and.w	r2, r0, #8
 8022a18:	b211      	sxth	r1, r2
 8022a1a:	b1d9      	cbz	r1, 8022a54 <_fflush_r+0x54>
 8022a1c:	692e      	ldr	r6, [r5, #16]
 8022a1e:	b1b6      	cbz	r6, 8022a4e <_fflush_r+0x4e>
 8022a20:	0783      	lsls	r3, r0, #30
 8022a22:	682c      	ldr	r4, [r5, #0]
 8022a24:	bf08      	it	eq
 8022a26:	696b      	ldreq	r3, [r5, #20]
 8022a28:	602e      	str	r6, [r5, #0]
 8022a2a:	bf18      	it	ne
 8022a2c:	2300      	movne	r3, #0
 8022a2e:	1ba4      	subs	r4, r4, r6
 8022a30:	60ab      	str	r3, [r5, #8]
 8022a32:	e00a      	b.n	8022a4a <_fflush_r+0x4a>
 8022a34:	4632      	mov	r2, r6
 8022a36:	4623      	mov	r3, r4
 8022a38:	6a6f      	ldr	r7, [r5, #36]	; 0x24
 8022a3a:	69e9      	ldr	r1, [r5, #28]
 8022a3c:	4640      	mov	r0, r8
 8022a3e:	47b8      	blx	r7
 8022a40:	2800      	cmp	r0, #0
 8022a42:	ebc0 0404 	rsb	r4, r0, r4
 8022a46:	4406      	add	r6, r0
 8022a48:	dd52      	ble.n	8022af0 <_fflush_r+0xf0>
 8022a4a:	2c00      	cmp	r4, #0
 8022a4c:	dcf2      	bgt.n	8022a34 <_fflush_r+0x34>
 8022a4e:	2000      	movs	r0, #0
 8022a50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8022a54:	686a      	ldr	r2, [r5, #4]
 8022a56:	f440 6100 	orr.w	r1, r0, #2048	; 0x800
 8022a5a:	2a00      	cmp	r2, #0
 8022a5c:	81a9      	strh	r1, [r5, #12]
 8022a5e:	dd4f      	ble.n	8022b00 <_fflush_r+0x100>
 8022a60:	6aac      	ldr	r4, [r5, #40]	; 0x28
 8022a62:	2c00      	cmp	r4, #0
 8022a64:	d0f3      	beq.n	8022a4e <_fflush_r+0x4e>
 8022a66:	f400 5680 	and.w	r6, r0, #4096	; 0x1000
 8022a6a:	b232      	sxth	r2, r6
 8022a6c:	2000      	movs	r0, #0
 8022a6e:	f8d8 6000 	ldr.w	r6, [r8]
 8022a72:	f8c8 0000 	str.w	r0, [r8]
 8022a76:	2a00      	cmp	r2, #0
 8022a78:	d030      	beq.n	8022adc <_fflush_r+0xdc>
 8022a7a:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8022a7c:	f001 0004 	and.w	r0, r1, #4
 8022a80:	b201      	sxth	r1, r0
 8022a82:	b129      	cbz	r1, 8022a90 <_fflush_r+0x90>
 8022a84:	6868      	ldr	r0, [r5, #4]
 8022a86:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8022a88:	1a12      	subs	r2, r2, r0
 8022a8a:	b10b      	cbz	r3, 8022a90 <_fflush_r+0x90>
 8022a8c:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 8022a8e:	1a52      	subs	r2, r2, r1
 8022a90:	2300      	movs	r3, #0
 8022a92:	4640      	mov	r0, r8
 8022a94:	69e9      	ldr	r1, [r5, #28]
 8022a96:	47a0      	blx	r4
 8022a98:	1c42      	adds	r2, r0, #1
 8022a9a:	d035      	beq.n	8022b08 <_fflush_r+0x108>
 8022a9c:	89ab      	ldrh	r3, [r5, #12]
 8022a9e:	692a      	ldr	r2, [r5, #16]
 8022aa0:	f403 5180 	and.w	r1, r3, #4096	; 0x1000
 8022aa4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8022aa8:	81ab      	strh	r3, [r5, #12]
 8022aaa:	b209      	sxth	r1, r1
 8022aac:	2300      	movs	r3, #0
 8022aae:	e885 000c 	stmia.w	r5, {r2, r3}
 8022ab2:	2900      	cmp	r1, #0
 8022ab4:	d144      	bne.n	8022b40 <_fflush_r+0x140>
 8022ab6:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8022ab8:	f8c8 6000 	str.w	r6, [r8]
 8022abc:	2900      	cmp	r1, #0
 8022abe:	d0c6      	beq.n	8022a4e <_fflush_r+0x4e>
 8022ac0:	f105 0040 	add.w	r0, r5, #64	; 0x40
 8022ac4:	4281      	cmp	r1, r0
 8022ac6:	d002      	beq.n	8022ace <_fflush_r+0xce>
 8022ac8:	4640      	mov	r0, r8
 8022aca:	f7e1 fe19 	bl	8004700 <_free_r>
 8022ace:	2000      	movs	r0, #0
 8022ad0:	6328      	str	r0, [r5, #48]	; 0x30
 8022ad2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8022ad6:	f000 f8a9 	bl	8022c2c <__sinit>
 8022ada:	e799      	b.n	8022a10 <_fflush_r+0x10>
 8022adc:	69e9      	ldr	r1, [r5, #28]
 8022ade:	2301      	movs	r3, #1
 8022ae0:	4640      	mov	r0, r8
 8022ae2:	47a0      	blx	r4
 8022ae4:	1c41      	adds	r1, r0, #1
 8022ae6:	4602      	mov	r2, r0
 8022ae8:	d02c      	beq.n	8022b44 <_fflush_r+0x144>
 8022aea:	89a9      	ldrh	r1, [r5, #12]
 8022aec:	6aac      	ldr	r4, [r5, #40]	; 0x28
 8022aee:	e7c5      	b.n	8022a7c <_fflush_r+0x7c>
 8022af0:	89aa      	ldrh	r2, [r5, #12]
 8022af2:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8022af6:	81ab      	strh	r3, [r5, #12]
 8022af8:	f04f 30ff 	mov.w	r0, #4294967295
 8022afc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8022b00:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8022b02:	2b00      	cmp	r3, #0
 8022b04:	dcac      	bgt.n	8022a60 <_fflush_r+0x60>
 8022b06:	e7a2      	b.n	8022a4e <_fflush_r+0x4e>
 8022b08:	f8d8 3000 	ldr.w	r3, [r8]
 8022b0c:	b163      	cbz	r3, 8022b28 <_fflush_r+0x128>
 8022b0e:	2b1d      	cmp	r3, #29
 8022b10:	d001      	beq.n	8022b16 <_fflush_r+0x116>
 8022b12:	2b16      	cmp	r3, #22
 8022b14:	d121      	bne.n	8022b5a <_fflush_r+0x15a>
 8022b16:	89a8      	ldrh	r0, [r5, #12]
 8022b18:	692b      	ldr	r3, [r5, #16]
 8022b1a:	f420 6200 	bic.w	r2, r0, #2048	; 0x800
 8022b1e:	2100      	movs	r1, #0
 8022b20:	81aa      	strh	r2, [r5, #12]
 8022b22:	6069      	str	r1, [r5, #4]
 8022b24:	602b      	str	r3, [r5, #0]
 8022b26:	e7c6      	b.n	8022ab6 <_fflush_r+0xb6>
 8022b28:	89aa      	ldrh	r2, [r5, #12]
 8022b2a:	6929      	ldr	r1, [r5, #16]
 8022b2c:	606b      	str	r3, [r5, #4]
 8022b2e:	f402 5380 	and.w	r3, r2, #4096	; 0x1000
 8022b32:	b21b      	sxth	r3, r3
 8022b34:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8022b38:	81aa      	strh	r2, [r5, #12]
 8022b3a:	6029      	str	r1, [r5, #0]
 8022b3c:	2b00      	cmp	r3, #0
 8022b3e:	d0ba      	beq.n	8022ab6 <_fflush_r+0xb6>
 8022b40:	6528      	str	r0, [r5, #80]	; 0x50
 8022b42:	e7b8      	b.n	8022ab6 <_fflush_r+0xb6>
 8022b44:	f8d8 1000 	ldr.w	r1, [r8]
 8022b48:	2900      	cmp	r1, #0
 8022b4a:	d0ce      	beq.n	8022aea <_fflush_r+0xea>
 8022b4c:	291d      	cmp	r1, #29
 8022b4e:	d001      	beq.n	8022b54 <_fflush_r+0x154>
 8022b50:	2916      	cmp	r1, #22
 8022b52:	d1cd      	bne.n	8022af0 <_fflush_r+0xf0>
 8022b54:	f8c8 6000 	str.w	r6, [r8]
 8022b58:	e779      	b.n	8022a4e <_fflush_r+0x4e>
 8022b5a:	89aa      	ldrh	r2, [r5, #12]
 8022b5c:	f042 0140 	orr.w	r1, r2, #64	; 0x40
 8022b60:	81a9      	strh	r1, [r5, #12]
 8022b62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8022b66:	bf00      	nop

08022b68 <fflush>:
 8022b68:	b120      	cbz	r0, 8022b74 <fflush+0xc>
 8022b6a:	4b05      	ldr	r3, [pc, #20]	; (8022b80 <fflush+0x18>)
 8022b6c:	4601      	mov	r1, r0
 8022b6e:	6818      	ldr	r0, [r3, #0]
 8022b70:	f7ff bf46 	b.w	8022a00 <_fflush_r>
 8022b74:	4803      	ldr	r0, [pc, #12]	; (8022b84 <fflush+0x1c>)
 8022b76:	4904      	ldr	r1, [pc, #16]	; (8022b88 <fflush+0x20>)
 8022b78:	6800      	ldr	r0, [r0, #0]
 8022b7a:	f000 bc1d 	b.w	80233b8 <_fwalk_reent>
 8022b7e:	bf00      	nop
 8022b80:	20006b80 	.word	0x20006b80
 8022b84:	08026944 	.word	0x08026944
 8022b88:	08022a01 	.word	0x08022a01

08022b8c <__fp_lock>:
 8022b8c:	2000      	movs	r0, #0
 8022b8e:	4770      	bx	lr

08022b90 <__fp_unlock>:
 8022b90:	2000      	movs	r0, #0
 8022b92:	4770      	bx	lr

08022b94 <_cleanup_r>:
 8022b94:	f642 11f1 	movw	r1, #10737	; 0x29f1
 8022b98:	f6c0 0102 	movt	r1, #2050	; 0x802
 8022b9c:	f000 bbb0 	b.w	8023300 <_fwalk>

08022ba0 <std.isra.0>:
 8022ba0:	2300      	movs	r3, #0
 8022ba2:	b510      	push	{r4, lr}
 8022ba4:	4604      	mov	r4, r0
 8022ba6:	8181      	strh	r1, [r0, #12]
 8022ba8:	81c2      	strh	r2, [r0, #14]
 8022baa:	6003      	str	r3, [r0, #0]
 8022bac:	6043      	str	r3, [r0, #4]
 8022bae:	6083      	str	r3, [r0, #8]
 8022bb0:	6643      	str	r3, [r0, #100]	; 0x64
 8022bb2:	6103      	str	r3, [r0, #16]
 8022bb4:	6143      	str	r3, [r0, #20]
 8022bb6:	6183      	str	r3, [r0, #24]
 8022bb8:	4619      	mov	r1, r3
 8022bba:	2208      	movs	r2, #8
 8022bbc:	f100 005c 	add.w	r0, r0, #92	; 0x5c
 8022bc0:	f000 fe96 	bl	80238f0 <memset>
 8022bc4:	f244 7015 	movw	r0, #18197	; 0x4715
 8022bc8:	f244 713d 	movw	r1, #18237	; 0x473d
 8022bcc:	f244 7281 	movw	r2, #18305	; 0x4781
 8022bd0:	f244 73a5 	movw	r3, #18341	; 0x47a5
 8022bd4:	f6c0 0002 	movt	r0, #2050	; 0x802
 8022bd8:	f6c0 0102 	movt	r1, #2050	; 0x802
 8022bdc:	f6c0 0202 	movt	r2, #2050	; 0x802
 8022be0:	f6c0 0302 	movt	r3, #2050	; 0x802
 8022be4:	61e4      	str	r4, [r4, #28]
 8022be6:	6220      	str	r0, [r4, #32]
 8022be8:	6261      	str	r1, [r4, #36]	; 0x24
 8022bea:	62a2      	str	r2, [r4, #40]	; 0x28
 8022bec:	62e3      	str	r3, [r4, #44]	; 0x2c
 8022bee:	bd10      	pop	{r4, pc}

08022bf0 <__sfmoreglue>:
 8022bf0:	b570      	push	{r4, r5, r6, lr}
 8022bf2:	2568      	movs	r5, #104	; 0x68
 8022bf4:	fb05 f501 	mul.w	r5, r5, r1
 8022bf8:	460e      	mov	r6, r1
 8022bfa:	f105 010c 	add.w	r1, r5, #12
 8022bfe:	f7e1 fd4f 	bl	80046a0 <_malloc_r>
 8022c02:	4604      	mov	r4, r0
 8022c04:	b140      	cbz	r0, 8022c18 <__sfmoreglue+0x28>
 8022c06:	f100 000c 	add.w	r0, r0, #12
 8022c0a:	2100      	movs	r1, #0
 8022c0c:	e884 0042 	stmia.w	r4, {r1, r6}
 8022c10:	60a0      	str	r0, [r4, #8]
 8022c12:	462a      	mov	r2, r5
 8022c14:	f000 fe6c 	bl	80238f0 <memset>
 8022c18:	4620      	mov	r0, r4
 8022c1a:	bd70      	pop	{r4, r5, r6, pc}

08022c1c <_cleanup>:
 8022c1c:	f646 1344 	movw	r3, #26948	; 0x6944
 8022c20:	f6c0 0302 	movt	r3, #2050	; 0x802
 8022c24:	6818      	ldr	r0, [r3, #0]
 8022c26:	f7ff bfb5 	b.w	8022b94 <_cleanup_r>
 8022c2a:	bf00      	nop

08022c2c <__sinit>:
 8022c2c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8022c2e:	b570      	push	{r4, r5, r6, lr}
 8022c30:	4604      	mov	r4, r0
 8022c32:	b103      	cbz	r3, 8022c36 <__sinit+0xa>
 8022c34:	bd70      	pop	{r4, r5, r6, pc}
 8022c36:	4a0f      	ldr	r2, [pc, #60]	; (8022c74 <__sinit+0x48>)
 8022c38:	f8c4 32e0 	str.w	r3, [r4, #736]	; 0x2e0
 8022c3c:	63e2      	str	r2, [r4, #60]	; 0x3c
 8022c3e:	2501      	movs	r5, #1
 8022c40:	461a      	mov	r2, r3
 8022c42:	f504 763b 	add.w	r6, r4, #748	; 0x2ec
 8022c46:	2303      	movs	r3, #3
 8022c48:	2104      	movs	r1, #4
 8022c4a:	f8c4 32e4 	str.w	r3, [r4, #740]	; 0x2e4
 8022c4e:	6840      	ldr	r0, [r0, #4]
 8022c50:	63a5      	str	r5, [r4, #56]	; 0x38
 8022c52:	f8c4 62e8 	str.w	r6, [r4, #744]	; 0x2e8
 8022c56:	f7ff ffa3 	bl	8022ba0 <std.isra.0>
 8022c5a:	68a0      	ldr	r0, [r4, #8]
 8022c5c:	2109      	movs	r1, #9
 8022c5e:	462a      	mov	r2, r5
 8022c60:	f7ff ff9e 	bl	8022ba0 <std.isra.0>
 8022c64:	68e0      	ldr	r0, [r4, #12]
 8022c66:	2112      	movs	r1, #18
 8022c68:	2202      	movs	r2, #2
 8022c6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8022c6e:	f7ff bf97 	b.w	8022ba0 <std.isra.0>
 8022c72:	bf00      	nop
 8022c74:	08022b95 	.word	0x08022b95

08022c78 <__sfp>:
 8022c78:	4b27      	ldr	r3, [pc, #156]	; (8022d18 <__sfp+0xa0>)
 8022c7a:	b570      	push	{r4, r5, r6, lr}
 8022c7c:	681d      	ldr	r5, [r3, #0]
 8022c7e:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8022c80:	4606      	mov	r6, r0
 8022c82:	2900      	cmp	r1, #0
 8022c84:	d039      	beq.n	8022cfa <__sfp+0x82>
 8022c86:	f505 7538 	add.w	r5, r5, #736	; 0x2e0
 8022c8a:	6868      	ldr	r0, [r5, #4]
 8022c8c:	68ac      	ldr	r4, [r5, #8]
 8022c8e:	1e43      	subs	r3, r0, #1
 8022c90:	d416      	bmi.n	8022cc0 <__sfp+0x48>
 8022c92:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8022c96:	b1ba      	cbz	r2, 8022cc8 <__sfp+0x50>
 8022c98:	07da      	lsls	r2, r3, #31
 8022c9a:	d50d      	bpl.n	8022cb8 <__sfp+0x40>
 8022c9c:	3468      	adds	r4, #104	; 0x68
 8022c9e:	3b01      	subs	r3, #1
 8022ca0:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 8022ca4:	b941      	cbnz	r1, 8022cb8 <__sfp+0x40>
 8022ca6:	e00f      	b.n	8022cc8 <__sfp+0x50>
 8022ca8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8022cac:	b163      	cbz	r3, 8022cc8 <__sfp+0x50>
 8022cae:	3468      	adds	r4, #104	; 0x68
 8022cb0:	1e43      	subs	r3, r0, #1
 8022cb2:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8022cb6:	b13a      	cbz	r2, 8022cc8 <__sfp+0x50>
 8022cb8:	3468      	adds	r4, #104	; 0x68
 8022cba:	1e58      	subs	r0, r3, #1
 8022cbc:	2b00      	cmp	r3, #0
 8022cbe:	d1f3      	bne.n	8022ca8 <__sfp+0x30>
 8022cc0:	6828      	ldr	r0, [r5, #0]
 8022cc2:	b1f0      	cbz	r0, 8022d02 <__sfp+0x8a>
 8022cc4:	4605      	mov	r5, r0
 8022cc6:	e7e0      	b.n	8022c8a <__sfp+0x12>
 8022cc8:	2500      	movs	r5, #0
 8022cca:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8022cce:	2001      	movs	r0, #1
 8022cd0:	81e1      	strh	r1, [r4, #14]
 8022cd2:	81a0      	strh	r0, [r4, #12]
 8022cd4:	6665      	str	r5, [r4, #100]	; 0x64
 8022cd6:	6025      	str	r5, [r4, #0]
 8022cd8:	60a5      	str	r5, [r4, #8]
 8022cda:	6065      	str	r5, [r4, #4]
 8022cdc:	6125      	str	r5, [r4, #16]
 8022cde:	6165      	str	r5, [r4, #20]
 8022ce0:	61a5      	str	r5, [r4, #24]
 8022ce2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8022ce6:	4629      	mov	r1, r5
 8022ce8:	2208      	movs	r2, #8
 8022cea:	f000 fe01 	bl	80238f0 <memset>
 8022cee:	6325      	str	r5, [r4, #48]	; 0x30
 8022cf0:	6365      	str	r5, [r4, #52]	; 0x34
 8022cf2:	6465      	str	r5, [r4, #68]	; 0x44
 8022cf4:	64a5      	str	r5, [r4, #72]	; 0x48
 8022cf6:	4620      	mov	r0, r4
 8022cf8:	bd70      	pop	{r4, r5, r6, pc}
 8022cfa:	4628      	mov	r0, r5
 8022cfc:	f7ff ff96 	bl	8022c2c <__sinit>
 8022d00:	e7c1      	b.n	8022c86 <__sfp+0xe>
 8022d02:	4630      	mov	r0, r6
 8022d04:	2104      	movs	r1, #4
 8022d06:	f7ff ff73 	bl	8022bf0 <__sfmoreglue>
 8022d0a:	6028      	str	r0, [r5, #0]
 8022d0c:	2800      	cmp	r0, #0
 8022d0e:	d1d9      	bne.n	8022cc4 <__sfp+0x4c>
 8022d10:	240c      	movs	r4, #12
 8022d12:	6034      	str	r4, [r6, #0]
 8022d14:	4604      	mov	r4, r0
 8022d16:	e7ee      	b.n	8022cf6 <__sfp+0x7e>
 8022d18:	08026944 	.word	0x08026944

08022d1c <__sfp_lock_acquire>:
 8022d1c:	4770      	bx	lr
 8022d1e:	bf00      	nop

08022d20 <__sfp_lock_release>:
 8022d20:	4770      	bx	lr
 8022d22:	bf00      	nop

08022d24 <__sinit_lock_acquire>:
 8022d24:	4770      	bx	lr
 8022d26:	bf00      	nop

08022d28 <__sinit_lock_release>:
 8022d28:	4770      	bx	lr
 8022d2a:	bf00      	nop

08022d2c <__fp_lock_all>:
 8022d2c:	f646 3380 	movw	r3, #27520	; 0x6b80
 8022d30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022d34:	f642 318d 	movw	r1, #11149	; 0x2b8d
 8022d38:	6818      	ldr	r0, [r3, #0]
 8022d3a:	f6c0 0102 	movt	r1, #2050	; 0x802
 8022d3e:	f000 badf 	b.w	8023300 <_fwalk>
 8022d42:	bf00      	nop

08022d44 <__fp_unlock_all>:
 8022d44:	f646 3380 	movw	r3, #27520	; 0x6b80
 8022d48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022d4c:	f642 3191 	movw	r1, #11153	; 0x2b91
 8022d50:	6818      	ldr	r0, [r3, #0]
 8022d52:	f6c0 0102 	movt	r1, #2050	; 0x802
 8022d56:	f000 bad3 	b.w	8023300 <_fwalk>
 8022d5a:	bf00      	nop

08022d5c <_fopen_r>:
 8022d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022d5e:	b083      	sub	sp, #12
 8022d60:	460f      	mov	r7, r1
 8022d62:	4611      	mov	r1, r2
 8022d64:	aa01      	add	r2, sp, #4
 8022d66:	4606      	mov	r6, r0
 8022d68:	f002 fb44 	bl	80253f4 <__sflags>
 8022d6c:	4605      	mov	r5, r0
 8022d6e:	2800      	cmp	r0, #0
 8022d70:	d01f      	beq.n	8022db2 <_fopen_r+0x56>
 8022d72:	4630      	mov	r0, r6
 8022d74:	f7ff ff80 	bl	8022c78 <__sfp>
 8022d78:	4604      	mov	r4, r0
 8022d7a:	b1d0      	cbz	r0, 8022db2 <_fopen_r+0x56>
 8022d7c:	4630      	mov	r0, r6
 8022d7e:	4639      	mov	r1, r7
 8022d80:	9a01      	ldr	r2, [sp, #4]
 8022d82:	f44f 73db 	mov.w	r3, #438	; 0x1b6
 8022d86:	f001 fb91 	bl	80244ac <_open_r>
 8022d8a:	2800      	cmp	r0, #0
 8022d8c:	db1a      	blt.n	8022dc4 <_fopen_r+0x68>
 8022d8e:	4a11      	ldr	r2, [pc, #68]	; (8022dd4 <_fopen_r+0x78>)
 8022d90:	81e0      	strh	r0, [r4, #14]
 8022d92:	f405 7380 	and.w	r3, r5, #256	; 0x100
 8022d96:	b218      	sxth	r0, r3
 8022d98:	6222      	str	r2, [r4, #32]
 8022d9a:	490f      	ldr	r1, [pc, #60]	; (8022dd8 <_fopen_r+0x7c>)
 8022d9c:	4b0f      	ldr	r3, [pc, #60]	; (8022ddc <_fopen_r+0x80>)
 8022d9e:	4a10      	ldr	r2, [pc, #64]	; (8022de0 <_fopen_r+0x84>)
 8022da0:	81a5      	strh	r5, [r4, #12]
 8022da2:	61e4      	str	r4, [r4, #28]
 8022da4:	6261      	str	r1, [r4, #36]	; 0x24
 8022da6:	62a3      	str	r3, [r4, #40]	; 0x28
 8022da8:	62e2      	str	r2, [r4, #44]	; 0x2c
 8022daa:	b920      	cbnz	r0, 8022db6 <_fopen_r+0x5a>
 8022dac:	4620      	mov	r0, r4
 8022dae:	b003      	add	sp, #12
 8022db0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022db2:	2400      	movs	r4, #0
 8022db4:	e7fa      	b.n	8022dac <_fopen_r+0x50>
 8022db6:	4630      	mov	r0, r6
 8022db8:	4621      	mov	r1, r4
 8022dba:	2200      	movs	r2, #0
 8022dbc:	2302      	movs	r3, #2
 8022dbe:	f000 f901 	bl	8022fc4 <_fseek_r>
 8022dc2:	e7f3      	b.n	8022dac <_fopen_r+0x50>
 8022dc4:	2500      	movs	r5, #0
 8022dc6:	f7ff ffa9 	bl	8022d1c <__sfp_lock_acquire>
 8022dca:	81a5      	strh	r5, [r4, #12]
 8022dcc:	f7ff ffa8 	bl	8022d20 <__sfp_lock_release>
 8022dd0:	462c      	mov	r4, r5
 8022dd2:	e7eb      	b.n	8022dac <_fopen_r+0x50>
 8022dd4:	08024715 	.word	0x08024715
 8022dd8:	0802473d 	.word	0x0802473d
 8022ddc:	08024781 	.word	0x08024781
 8022de0:	080247a5 	.word	0x080247a5

08022de4 <fopen>:
 8022de4:	b410      	push	{r4}
 8022de6:	f646 3380 	movw	r3, #27520	; 0x6b80
 8022dea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8022dee:	4604      	mov	r4, r0
 8022df0:	6818      	ldr	r0, [r3, #0]
 8022df2:	460a      	mov	r2, r1
 8022df4:	4621      	mov	r1, r4
 8022df6:	bc10      	pop	{r4}
 8022df8:	f7ff bfb0 	b.w	8022d5c <_fopen_r>

08022dfc <_fread_r>:
 8022dfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022e00:	b085      	sub	sp, #20
 8022e02:	fb02 f603 	mul.w	r6, r2, r3
 8022e06:	4617      	mov	r7, r2
 8022e08:	461d      	mov	r5, r3
 8022e0a:	4604      	mov	r4, r0
 8022e0c:	468a      	mov	sl, r1
 8022e0e:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 8022e12:	2e00      	cmp	r6, #0
 8022e14:	d047      	beq.n	8022ea6 <_fread_r+0xaa>
 8022e16:	b118      	cbz	r0, 8022e20 <_fread_r+0x24>
 8022e18:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8022e1a:	2a00      	cmp	r2, #0
 8022e1c:	f000 80a7 	beq.w	8022f6e <_fread_r+0x172>
 8022e20:	f7ff ff7c 	bl	8022d1c <__sfp_lock_acquire>
 8022e24:	f8bb 100c 	ldrh.w	r1, [fp, #12]
 8022e28:	f401 5000 	and.w	r0, r1, #8192	; 0x2000
 8022e2c:	b203      	sxth	r3, r0
 8022e2e:	b94b      	cbnz	r3, 8022e44 <_fread_r+0x48>
 8022e30:	f8db 2064 	ldr.w	r2, [fp, #100]	; 0x64
 8022e34:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8022e38:	f422 5000 	bic.w	r0, r2, #8192	; 0x2000
 8022e3c:	f8ab 100c 	strh.w	r1, [fp, #12]
 8022e40:	f8cb 0064 	str.w	r0, [fp, #100]	; 0x64
 8022e44:	f8db 8004 	ldr.w	r8, [fp, #4]
 8022e48:	f1b8 0f00 	cmp.w	r8, #0
 8022e4c:	db2d      	blt.n	8022eaa <_fread_r+0xae>
 8022e4e:	f001 0202 	and.w	r2, r1, #2
 8022e52:	b211      	sxth	r1, r2
 8022e54:	46c1      	mov	r9, r8
 8022e56:	2900      	cmp	r1, #0
 8022e58:	d131      	bne.n	8022ebe <_fread_r+0xc2>
 8022e5a:	46b1      	mov	r9, r6
 8022e5c:	e001      	b.n	8022e62 <_fread_r+0x66>
 8022e5e:	f8db 8004 	ldr.w	r8, [fp, #4]
 8022e62:	45c1      	cmp	r9, r8
 8022e64:	4642      	mov	r2, r8
 8022e66:	4650      	mov	r0, sl
 8022e68:	f8db 1000 	ldr.w	r1, [fp]
 8022e6c:	f240 8082 	bls.w	8022f74 <_fread_r+0x178>
 8022e70:	f000 fbd0 	bl	8023614 <memcpy>
 8022e74:	f8db 0000 	ldr.w	r0, [fp]
 8022e78:	eb00 0308 	add.w	r3, r0, r8
 8022e7c:	f8cb 3000 	str.w	r3, [fp]
 8022e80:	4620      	mov	r0, r4
 8022e82:	4659      	mov	r1, fp
 8022e84:	44c2      	add	sl, r8
 8022e86:	ebc8 0909 	rsb	r9, r8, r9
 8022e8a:	f001 fbbb 	bl	8024604 <__srefill_r>
 8022e8e:	2800      	cmp	r0, #0
 8022e90:	d0e5      	beq.n	8022e5e <_fread_r+0x62>
 8022e92:	ebc9 0506 	rsb	r5, r9, r6
 8022e96:	f7ff ff43 	bl	8022d20 <__sfp_lock_release>
 8022e9a:	fbb5 f5f7 	udiv	r5, r5, r7
 8022e9e:	4628      	mov	r0, r5
 8022ea0:	b005      	add	sp, #20
 8022ea2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022ea6:	4635      	mov	r5, r6
 8022ea8:	e7f9      	b.n	8022e9e <_fread_r+0xa2>
 8022eaa:	f001 0202 	and.w	r2, r1, #2
 8022eae:	2300      	movs	r3, #0
 8022eb0:	b211      	sxth	r1, r2
 8022eb2:	4699      	mov	r9, r3
 8022eb4:	f8cb 3004 	str.w	r3, [fp, #4]
 8022eb8:	4698      	mov	r8, r3
 8022eba:	2900      	cmp	r1, #0
 8022ebc:	d0cd      	beq.n	8022e5a <_fread_r+0x5e>
 8022ebe:	45b1      	cmp	r9, r6
 8022ec0:	bf28      	it	cs
 8022ec2:	46b1      	movcs	r9, r6
 8022ec4:	4650      	mov	r0, sl
 8022ec6:	f8db 1000 	ldr.w	r1, [fp]
 8022eca:	464a      	mov	r2, r9
 8022ecc:	f000 fba2 	bl	8023614 <memcpy>
 8022ed0:	e89b 0005 	ldmia.w	fp, {r0, r2}
 8022ed4:	f8db 1030 	ldr.w	r1, [fp, #48]	; 0x30
 8022ed8:	4448      	add	r0, r9
 8022eda:	ebc9 0202 	rsb	r2, r9, r2
 8022ede:	eb0a 0809 	add.w	r8, sl, r9
 8022ee2:	9001      	str	r0, [sp, #4]
 8022ee4:	e88b 0005 	stmia.w	fp, {r0, r2}
 8022ee8:	ebc9 0a06 	rsb	sl, r9, r6
 8022eec:	2900      	cmp	r1, #0
 8022eee:	d053      	beq.n	8022f98 <_fread_r+0x19c>
 8022ef0:	f1ba 0f00 	cmp.w	sl, #0
 8022ef4:	d04d      	beq.n	8022f92 <_fread_r+0x196>
 8022ef6:	f10b 0240 	add.w	r2, fp, #64	; 0x40
 8022efa:	4291      	cmp	r1, r2
 8022efc:	d005      	beq.n	8022f0a <_fread_r+0x10e>
 8022efe:	4620      	mov	r0, r4
 8022f00:	f7e1 fbfe 	bl	8004700 <_free_r>
 8022f04:	f8db 1000 	ldr.w	r1, [fp]
 8022f08:	9101      	str	r1, [sp, #4]
 8022f0a:	2000      	movs	r0, #0
 8022f0c:	f8cb 0030 	str.w	r0, [fp, #48]	; 0x30
 8022f10:	f8db 3010 	ldr.w	r3, [fp, #16]
 8022f14:	f8db 2014 	ldr.w	r2, [fp, #20]
 8022f18:	9302      	str	r3, [sp, #8]
 8022f1a:	9203      	str	r2, [sp, #12]
 8022f1c:	f04f 0900 	mov.w	r9, #0
 8022f20:	e002      	b.n	8022f28 <_fread_r+0x12c>
 8022f22:	f1ba 0f00 	cmp.w	sl, #0
 8022f26:	d034      	beq.n	8022f92 <_fread_r+0x196>
 8022f28:	f8cb 8010 	str.w	r8, [fp, #16]
 8022f2c:	f8cb a014 	str.w	sl, [fp, #20]
 8022f30:	f8cb 8000 	str.w	r8, [fp]
 8022f34:	4659      	mov	r1, fp
 8022f36:	4620      	mov	r0, r4
 8022f38:	f001 fb64 	bl	8024604 <__srefill_r>
 8022f3c:	9b02      	ldr	r3, [sp, #8]
 8022f3e:	f8db 1004 	ldr.w	r1, [fp, #4]
 8022f42:	f8cb 3010 	str.w	r3, [fp, #16]
 8022f46:	9a03      	ldr	r2, [sp, #12]
 8022f48:	9b01      	ldr	r3, [sp, #4]
 8022f4a:	f8cb 2014 	str.w	r2, [fp, #20]
 8022f4e:	f8cb 3000 	str.w	r3, [fp]
 8022f52:	ebc1 0a0a 	rsb	sl, r1, sl
 8022f56:	f8cb 9004 	str.w	r9, [fp, #4]
 8022f5a:	4488      	add	r8, r1
 8022f5c:	2800      	cmp	r0, #0
 8022f5e:	d0e0      	beq.n	8022f22 <_fread_r+0x126>
 8022f60:	ebca 0506 	rsb	r5, sl, r6
 8022f64:	f7ff fedc 	bl	8022d20 <__sfp_lock_release>
 8022f68:	fbb5 f5f7 	udiv	r5, r5, r7
 8022f6c:	e797      	b.n	8022e9e <_fread_r+0xa2>
 8022f6e:	f7ff fe5d 	bl	8022c2c <__sinit>
 8022f72:	e755      	b.n	8022e20 <_fread_r+0x24>
 8022f74:	464a      	mov	r2, r9
 8022f76:	f000 fb4d 	bl	8023614 <memcpy>
 8022f7a:	f8db 0004 	ldr.w	r0, [fp, #4]
 8022f7e:	f8db 3000 	ldr.w	r3, [fp]
 8022f82:	ebc9 0100 	rsb	r1, r9, r0
 8022f86:	eb03 0209 	add.w	r2, r3, r9
 8022f8a:	f8cb 1004 	str.w	r1, [fp, #4]
 8022f8e:	f8cb 2000 	str.w	r2, [fp]
 8022f92:	f7ff fec5 	bl	8022d20 <__sfp_lock_release>
 8022f96:	e782      	b.n	8022e9e <_fread_r+0xa2>
 8022f98:	f1ba 0f00 	cmp.w	sl, #0
 8022f9c:	d1b8      	bne.n	8022f10 <_fread_r+0x114>
 8022f9e:	e7f8      	b.n	8022f92 <_fread_r+0x196>

08022fa0 <fread>:
 8022fa0:	b530      	push	{r4, r5, lr}
 8022fa2:	f646 3480 	movw	r4, #27520	; 0x6b80
 8022fa6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8022faa:	b083      	sub	sp, #12
 8022fac:	4605      	mov	r5, r0
 8022fae:	6820      	ldr	r0, [r4, #0]
 8022fb0:	9300      	str	r3, [sp, #0]
 8022fb2:	460c      	mov	r4, r1
 8022fb4:	4613      	mov	r3, r2
 8022fb6:	4629      	mov	r1, r5
 8022fb8:	4622      	mov	r2, r4
 8022fba:	f7ff ff1f 	bl	8022dfc <_fread_r>
 8022fbe:	b003      	add	sp, #12
 8022fc0:	bd30      	pop	{r4, r5, pc}
 8022fc2:	bf00      	nop

08022fc4 <_fseek_r>:
 8022fc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022fc8:	460c      	mov	r4, r1
 8022fca:	b091      	sub	sp, #68	; 0x44
 8022fcc:	4690      	mov	r8, r2
 8022fce:	461e      	mov	r6, r3
 8022fd0:	4605      	mov	r5, r0
 8022fd2:	b110      	cbz	r0, 8022fda <_fseek_r+0x16>
 8022fd4:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8022fd6:	2b00      	cmp	r3, #0
 8022fd8:	d07e      	beq.n	80230d8 <_fseek_r+0x114>
 8022fda:	f7ff fe9f 	bl	8022d1c <__sfp_lock_acquire>
 8022fde:	89a0      	ldrh	r0, [r4, #12]
 8022fe0:	f400 7184 	and.w	r1, r0, #264	; 0x108
 8022fe4:	f5b1 7f84 	cmp.w	r1, #264	; 0x108
 8022fe8:	f000 80e6 	beq.w	80231b8 <_fseek_r+0x1f4>
 8022fec:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 8022fee:	2f00      	cmp	r7, #0
 8022ff0:	f000 815b 	beq.w	80232aa <_fseek_r+0x2e6>
 8022ff4:	2e01      	cmp	r6, #1
 8022ff6:	d04d      	beq.n	8023094 <_fseek_r+0xd0>
 8022ff8:	2e02      	cmp	r6, #2
 8022ffa:	d009      	beq.n	8023010 <_fseek_r+0x4c>
 8022ffc:	b146      	cbz	r6, 8023010 <_fseek_r+0x4c>
 8022ffe:	2216      	movs	r2, #22
 8023000:	602a      	str	r2, [r5, #0]
 8023002:	f7ff fe8d 	bl	8022d20 <__sfp_lock_release>
 8023006:	f04f 30ff 	mov.w	r0, #4294967295
 802300a:	b011      	add	sp, #68	; 0x44
 802300c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023010:	f04f 0a00 	mov.w	sl, #0
 8023014:	6923      	ldr	r3, [r4, #16]
 8023016:	46d1      	mov	r9, sl
 8023018:	2b00      	cmp	r3, #0
 802301a:	f000 811d 	beq.w	8023258 <_fseek_r+0x294>
 802301e:	89a0      	ldrh	r0, [r4, #12]
 8023020:	f640 011a 	movw	r1, #2074	; 0x81a
 8023024:	4001      	ands	r1, r0
 8023026:	b959      	cbnz	r1, 8023040 <_fseek_r+0x7c>
 8023028:	f400 6280 	and.w	r2, r0, #1024	; 0x400
 802302c:	b213      	sxth	r3, r2
 802302e:	2b00      	cmp	r3, #0
 8023030:	d15c      	bne.n	80230ec <_fseek_r+0x128>
 8023032:	49a1      	ldr	r1, [pc, #644]	; (80232b8 <_fseek_r+0x2f4>)
 8023034:	428f      	cmp	r7, r1
 8023036:	f000 8114 	beq.w	8023262 <_fseek_r+0x29e>
 802303a:	f440 6100 	orr.w	r1, r0, #2048	; 0x800
 802303e:	81a1      	strh	r1, [r4, #12]
 8023040:	4628      	mov	r0, r5
 8023042:	4621      	mov	r1, r4
 8023044:	f7ff fcdc 	bl	8022a00 <_fflush_r>
 8023048:	2800      	cmp	r0, #0
 802304a:	d1da      	bne.n	8023002 <_fseek_r+0x3e>
 802304c:	4628      	mov	r0, r5
 802304e:	69e1      	ldr	r1, [r4, #28]
 8023050:	4642      	mov	r2, r8
 8023052:	4633      	mov	r3, r6
 8023054:	47b8      	blx	r7
 8023056:	3001      	adds	r0, #1
 8023058:	d0d3      	beq.n	8023002 <_fseek_r+0x3e>
 802305a:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802305c:	b141      	cbz	r1, 8023070 <_fseek_r+0xac>
 802305e:	f104 0240 	add.w	r2, r4, #64	; 0x40
 8023062:	4291      	cmp	r1, r2
 8023064:	d002      	beq.n	802306c <_fseek_r+0xa8>
 8023066:	4628      	mov	r0, r5
 8023068:	f7e1 fb4a 	bl	8004700 <_free_r>
 802306c:	2500      	movs	r5, #0
 802306e:	6325      	str	r5, [r4, #48]	; 0x30
 8023070:	89a0      	ldrh	r0, [r4, #12]
 8023072:	6923      	ldr	r3, [r4, #16]
 8023074:	2500      	movs	r5, #0
 8023076:	f420 6002 	bic.w	r0, r0, #2080	; 0x820
 802307a:	4629      	mov	r1, r5
 802307c:	2208      	movs	r2, #8
 802307e:	e884 0028 	stmia.w	r4, {r3, r5}
 8023082:	81a0      	strh	r0, [r4, #12]
 8023084:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8023088:	f000 fc32 	bl	80238f0 <memset>
 802308c:	f7ff fe48 	bl	8022d20 <__sfp_lock_release>
 8023090:	4628      	mov	r0, r5
 8023092:	e7ba      	b.n	802300a <_fseek_r+0x46>
 8023094:	4621      	mov	r1, r4
 8023096:	4628      	mov	r0, r5
 8023098:	f7ff fcb2 	bl	8022a00 <_fflush_r>
 802309c:	89a1      	ldrh	r1, [r4, #12]
 802309e:	f401 5080 	and.w	r0, r1, #4096	; 0x1000
 80230a2:	b202      	sxth	r2, r0
 80230a4:	2a00      	cmp	r2, #0
 80230a6:	f000 80cc 	beq.w	8023242 <_fseek_r+0x27e>
 80230aa:	f8d4 9050 	ldr.w	r9, [r4, #80]	; 0x50
 80230ae:	f001 0604 	and.w	r6, r1, #4
 80230b2:	b232      	sxth	r2, r6
 80230b4:	2a00      	cmp	r2, #0
 80230b6:	d15e      	bne.n	8023176 <_fseek_r+0x1b2>
 80230b8:	f001 0308 	and.w	r3, r1, #8
 80230bc:	b218      	sxth	r0, r3
 80230be:	2800      	cmp	r0, #0
 80230c0:	f000 80bd 	beq.w	802323e <_fseek_r+0x27a>
 80230c4:	6821      	ldr	r1, [r4, #0]
 80230c6:	6923      	ldr	r3, [r4, #16]
 80230c8:	b109      	cbz	r1, 80230ce <_fseek_r+0x10a>
 80230ca:	1ace      	subs	r6, r1, r3
 80230cc:	44b1      	add	r9, r6
 80230ce:	44c8      	add	r8, r9
 80230d0:	f04f 0a01 	mov.w	sl, #1
 80230d4:	2600      	movs	r6, #0
 80230d6:	e79f      	b.n	8023018 <_fseek_r+0x54>
 80230d8:	f7ff fda8 	bl	8022c2c <__sinit>
 80230dc:	e77d      	b.n	8022fda <_fseek_r+0x16>
 80230de:	89a3      	ldrh	r3, [r4, #12]
 80230e0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80230e4:	f443 6180 	orr.w	r1, r3, #1024	; 0x400
 80230e8:	64e0      	str	r0, [r4, #76]	; 0x4c
 80230ea:	81a1      	strh	r1, [r4, #12]
 80230ec:	2e00      	cmp	r6, #0
 80230ee:	d14d      	bne.n	802318c <_fseek_r+0x1c8>
 80230f0:	46c3      	mov	fp, r8
 80230f2:	f1ba 0f00 	cmp.w	sl, #0
 80230f6:	d158      	bne.n	80231aa <_fseek_r+0x1e6>
 80230f8:	89a3      	ldrh	r3, [r4, #12]
 80230fa:	f403 5180 	and.w	r1, r3, #4096	; 0x1000
 80230fe:	b208      	sxth	r0, r1
 8023100:	2800      	cmp	r0, #0
 8023102:	f000 80c1 	beq.w	8023288 <_fseek_r+0x2c4>
 8023106:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8023108:	6862      	ldr	r2, [r4, #4]
 802310a:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802310c:	ebc2 0900 	rsb	r9, r2, r0
 8023110:	2900      	cmp	r1, #0
 8023112:	f000 80c2 	beq.w	802329a <_fseek_r+0x2d6>
 8023116:	f8d4 e03c 	ldr.w	lr, [r4, #60]	; 0x3c
 802311a:	ebce 0909 	rsb	r9, lr, r9
 802311e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8023120:	6920      	ldr	r0, [r4, #16]
 8023122:	444a      	add	r2, r9
 8023124:	1a1b      	subs	r3, r3, r0
 8023126:	ebc3 0902 	rsb	r9, r3, r2
 802312a:	4473      	add	r3, lr
 802312c:	45cb      	cmp	fp, r9
 802312e:	db48      	blt.n	80231c2 <_fseek_r+0x1fe>
 8023130:	eb09 0203 	add.w	r2, r9, r3
 8023134:	4593      	cmp	fp, r2
 8023136:	d244      	bcs.n	80231c2 <_fseek_r+0x1fe>
 8023138:	ebc9 090b 	rsb	r9, r9, fp
 802313c:	4448      	add	r0, r9
 802313e:	ebc9 0303 	rsb	r3, r9, r3
 8023142:	e884 0009 	stmia.w	r4, {r0, r3}
 8023146:	b141      	cbz	r1, 802315a <_fseek_r+0x196>
 8023148:	f104 0240 	add.w	r2, r4, #64	; 0x40
 802314c:	4291      	cmp	r1, r2
 802314e:	d002      	beq.n	8023156 <_fseek_r+0x192>
 8023150:	4628      	mov	r0, r5
 8023152:	f7e1 fad5 	bl	8004700 <_free_r>
 8023156:	2000      	movs	r0, #0
 8023158:	6320      	str	r0, [r4, #48]	; 0x30
 802315a:	89a3      	ldrh	r3, [r4, #12]
 802315c:	f023 0020 	bic.w	r0, r3, #32
 8023160:	2100      	movs	r1, #0
 8023162:	2208      	movs	r2, #8
 8023164:	81a0      	strh	r0, [r4, #12]
 8023166:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 802316a:	f000 fbc1 	bl	80238f0 <memset>
 802316e:	f7ff fdd7 	bl	8022d20 <__sfp_lock_release>
 8023172:	2000      	movs	r0, #0
 8023174:	e749      	b.n	802300a <_fseek_r+0x46>
 8023176:	6862      	ldr	r2, [r4, #4]
 8023178:	6b23      	ldr	r3, [r4, #48]	; 0x30
 802317a:	ebc2 0909 	rsb	r9, r2, r9
 802317e:	2b00      	cmp	r3, #0
 8023180:	d05d      	beq.n	802323e <_fseek_r+0x27a>
 8023182:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8023184:	6923      	ldr	r3, [r4, #16]
 8023186:	ebc0 0909 	rsb	r9, r0, r9
 802318a:	e7a0      	b.n	80230ce <_fseek_r+0x10a>
 802318c:	4628      	mov	r0, r5
 802318e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8023192:	aa01      	add	r2, sp, #4
 8023194:	f000 f8a0 	bl	80232d8 <_fstat_r>
 8023198:	2800      	cmp	r0, #0
 802319a:	f47f af51 	bne.w	8023040 <_fseek_r+0x7c>
 802319e:	9a05      	ldr	r2, [sp, #20]
 80231a0:	eb08 0b02 	add.w	fp, r8, r2
 80231a4:	f1ba 0f00 	cmp.w	sl, #0
 80231a8:	d0a6      	beq.n	80230f8 <_fseek_r+0x134>
 80231aa:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80231ac:	6862      	ldr	r2, [r4, #4]
 80231ae:	2900      	cmp	r1, #0
 80231b0:	d073      	beq.n	802329a <_fseek_r+0x2d6>
 80231b2:	f8d4 e03c 	ldr.w	lr, [r4, #60]	; 0x3c
 80231b6:	e7b2      	b.n	802311e <_fseek_r+0x15a>
 80231b8:	4628      	mov	r0, r5
 80231ba:	4621      	mov	r1, r4
 80231bc:	f7ff fc20 	bl	8022a00 <_fflush_r>
 80231c0:	e714      	b.n	8022fec <_fseek_r+0x28>
 80231c2:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 80231c4:	69e1      	ldr	r1, [r4, #28]
 80231c6:	4243      	negs	r3, r0
 80231c8:	ea0b 0903 	and.w	r9, fp, r3
 80231cc:	4628      	mov	r0, r5
 80231ce:	2300      	movs	r3, #0
 80231d0:	464a      	mov	r2, r9
 80231d2:	47b8      	blx	r7
 80231d4:	3001      	adds	r0, #1
 80231d6:	f43f af33 	beq.w	8023040 <_fseek_r+0x7c>
 80231da:	6922      	ldr	r2, [r4, #16]
 80231dc:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80231de:	6022      	str	r2, [r4, #0]
 80231e0:	2000      	movs	r0, #0
 80231e2:	6060      	str	r0, [r4, #4]
 80231e4:	b141      	cbz	r1, 80231f8 <_fseek_r+0x234>
 80231e6:	f104 0340 	add.w	r3, r4, #64	; 0x40
 80231ea:	4299      	cmp	r1, r3
 80231ec:	d002      	beq.n	80231f4 <_fseek_r+0x230>
 80231ee:	4628      	mov	r0, r5
 80231f0:	f7e1 fa86 	bl	8004700 <_free_r>
 80231f4:	2100      	movs	r1, #0
 80231f6:	6321      	str	r1, [r4, #48]	; 0x30
 80231f8:	89a2      	ldrh	r2, [r4, #12]
 80231fa:	ebbb 0b09 	subs.w	fp, fp, r9
 80231fe:	f022 0020 	bic.w	r0, r2, #32
 8023202:	81a0      	strh	r0, [r4, #12]
 8023204:	d011      	beq.n	802322a <_fseek_r+0x266>
 8023206:	4628      	mov	r0, r5
 8023208:	4621      	mov	r1, r4
 802320a:	f001 f9fb 	bl	8024604 <__srefill_r>
 802320e:	2800      	cmp	r0, #0
 8023210:	f47f af16 	bne.w	8023040 <_fseek_r+0x7c>
 8023214:	6863      	ldr	r3, [r4, #4]
 8023216:	459b      	cmp	fp, r3
 8023218:	f63f af12 	bhi.w	8023040 <_fseek_r+0x7c>
 802321c:	6821      	ldr	r1, [r4, #0]
 802321e:	ebcb 0303 	rsb	r3, fp, r3
 8023222:	eb01 020b 	add.w	r2, r1, fp
 8023226:	e884 000c 	stmia.w	r4, {r2, r3}
 802322a:	2100      	movs	r1, #0
 802322c:	2208      	movs	r2, #8
 802322e:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8023232:	f000 fb5d 	bl	80238f0 <memset>
 8023236:	f7ff fd73 	bl	8022d20 <__sfp_lock_release>
 802323a:	2000      	movs	r0, #0
 802323c:	e6e5      	b.n	802300a <_fseek_r+0x46>
 802323e:	6923      	ldr	r3, [r4, #16]
 8023240:	e745      	b.n	80230ce <_fseek_r+0x10a>
 8023242:	4628      	mov	r0, r5
 8023244:	69e1      	ldr	r1, [r4, #28]
 8023246:	4633      	mov	r3, r6
 8023248:	47b8      	blx	r7
 802324a:	f1b0 3fff 	cmp.w	r0, #4294967295
 802324e:	4681      	mov	r9, r0
 8023250:	f43f aed7 	beq.w	8023002 <_fseek_r+0x3e>
 8023254:	89a1      	ldrh	r1, [r4, #12]
 8023256:	e72a      	b.n	80230ae <_fseek_r+0xea>
 8023258:	4628      	mov	r0, r5
 802325a:	4621      	mov	r1, r4
 802325c:	f000 f956 	bl	802350c <__smakebuf_r>
 8023260:	e6dd      	b.n	802301e <_fseek_r+0x5a>
 8023262:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8023266:	2900      	cmp	r1, #0
 8023268:	f6ff aee7 	blt.w	802303a <_fseek_r+0x76>
 802326c:	4628      	mov	r0, r5
 802326e:	aa01      	add	r2, sp, #4
 8023270:	f000 f832 	bl	80232d8 <_fstat_r>
 8023274:	b930      	cbnz	r0, 8023284 <_fseek_r+0x2c0>
 8023276:	9802      	ldr	r0, [sp, #8]
 8023278:	f400 4270 	and.w	r2, r0, #61440	; 0xf000
 802327c:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8023280:	f43f af2d 	beq.w	80230de <_fseek_r+0x11a>
 8023284:	89a0      	ldrh	r0, [r4, #12]
 8023286:	e6d8      	b.n	802303a <_fseek_r+0x76>
 8023288:	2301      	movs	r3, #1
 802328a:	4628      	mov	r0, r5
 802328c:	69e1      	ldr	r1, [r4, #28]
 802328e:	4652      	mov	r2, sl
 8023290:	47b8      	blx	r7
 8023292:	1c43      	adds	r3, r0, #1
 8023294:	f47f af38 	bne.w	8023108 <_fseek_r+0x144>
 8023298:	e6d2      	b.n	8023040 <_fseek_r+0x7c>
 802329a:	6823      	ldr	r3, [r4, #0]
 802329c:	6920      	ldr	r0, [r4, #16]
 802329e:	1a19      	subs	r1, r3, r0
 80232a0:	ebc1 0909 	rsb	r9, r1, r9
 80232a4:	1853      	adds	r3, r2, r1
 80232a6:	2100      	movs	r1, #0
 80232a8:	e740      	b.n	802312c <_fseek_r+0x168>
 80232aa:	231d      	movs	r3, #29
 80232ac:	602b      	str	r3, [r5, #0]
 80232ae:	f7ff fd37 	bl	8022d20 <__sfp_lock_release>
 80232b2:	f04f 30ff 	mov.w	r0, #4294967295
 80232b6:	e6a8      	b.n	802300a <_fseek_r+0x46>
 80232b8:	08024781 	.word	0x08024781

080232bc <fseek>:
 80232bc:	b470      	push	{r4, r5, r6}
 80232be:	f646 3480 	movw	r4, #27520	; 0x6b80
 80232c2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80232c6:	4606      	mov	r6, r0
 80232c8:	460d      	mov	r5, r1
 80232ca:	6820      	ldr	r0, [r4, #0]
 80232cc:	4613      	mov	r3, r2
 80232ce:	4631      	mov	r1, r6
 80232d0:	462a      	mov	r2, r5
 80232d2:	bc70      	pop	{r4, r5, r6}
 80232d4:	f7ff be76 	b.w	8022fc4 <_fseek_r>

080232d8 <_fstat_r>:
 80232d8:	b538      	push	{r3, r4, r5, lr}
 80232da:	4c08      	ldr	r4, [pc, #32]	; (80232fc <_fstat_r+0x24>)
 80232dc:	2300      	movs	r3, #0
 80232de:	4605      	mov	r5, r0
 80232e0:	4608      	mov	r0, r1
 80232e2:	4611      	mov	r1, r2
 80232e4:	6023      	str	r3, [r4, #0]
 80232e6:	f7e2 f8c7 	bl	8005478 <_fstat>
 80232ea:	1c43      	adds	r3, r0, #1
 80232ec:	d000      	beq.n	80232f0 <_fstat_r+0x18>
 80232ee:	bd38      	pop	{r3, r4, r5, pc}
 80232f0:	6821      	ldr	r1, [r4, #0]
 80232f2:	2900      	cmp	r1, #0
 80232f4:	d0fb      	beq.n	80232ee <_fstat_r+0x16>
 80232f6:	6029      	str	r1, [r5, #0]
 80232f8:	bd38      	pop	{r3, r4, r5, pc}
 80232fa:	bf00      	nop
 80232fc:	2000664c 	.word	0x2000664c

08023300 <_fwalk>:
 8023300:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023304:	4680      	mov	r8, r0
 8023306:	4689      	mov	r9, r1
 8023308:	f7ff fd08 	bl	8022d1c <__sfp_lock_acquire>
 802330c:	f518 7838 	adds.w	r8, r8, #736	; 0x2e0
 8023310:	d04f      	beq.n	80233b2 <_fwalk+0xb2>
 8023312:	f04f 0a00 	mov.w	sl, #0
 8023316:	f8d8 5004 	ldr.w	r5, [r8, #4]
 802331a:	f8d8 4008 	ldr.w	r4, [r8, #8]
 802331e:	3d01      	subs	r5, #1
 8023320:	d43d      	bmi.n	802339e <_fwalk+0x9e>
 8023322:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023326:	f005 0601 	and.w	r6, r5, #1
 802332a:	b13b      	cbz	r3, 802333c <_fwalk+0x3c>
 802332c:	f9b4 000e 	ldrsh.w	r0, [r4, #14]
 8023330:	1c43      	adds	r3, r0, #1
 8023332:	d003      	beq.n	802333c <_fwalk+0x3c>
 8023334:	4620      	mov	r0, r4
 8023336:	47c8      	blx	r9
 8023338:	ea4a 0a00 	orr.w	sl, sl, r0
 802333c:	3468      	adds	r4, #104	; 0x68
 802333e:	1e6f      	subs	r7, r5, #1
 8023340:	b36d      	cbz	r5, 802339e <_fwalk+0x9e>
 8023342:	b176      	cbz	r6, 8023362 <_fwalk+0x62>
 8023344:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 8023348:	b139      	cbz	r1, 802335a <_fwalk+0x5a>
 802334a:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
 802334e:	1c53      	adds	r3, r2, #1
 8023350:	d003      	beq.n	802335a <_fwalk+0x5a>
 8023352:	4620      	mov	r0, r4
 8023354:	47c8      	blx	r9
 8023356:	ea4a 0a00 	orr.w	sl, sl, r0
 802335a:	3f01      	subs	r7, #1
 802335c:	3468      	adds	r4, #104	; 0x68
 802335e:	1c7b      	adds	r3, r7, #1
 8023360:	d01d      	beq.n	802339e <_fwalk+0x9e>
 8023362:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 8023366:	f104 0568 	add.w	r5, r4, #104	; 0x68
 802336a:	b13e      	cbz	r6, 802337c <_fwalk+0x7c>
 802336c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8023370:	3301      	adds	r3, #1
 8023372:	4620      	mov	r0, r4
 8023374:	d002      	beq.n	802337c <_fwalk+0x7c>
 8023376:	47c8      	blx	r9
 8023378:	ea4a 0a00 	orr.w	sl, sl, r0
 802337c:	f9b5 400c 	ldrsh.w	r4, [r5, #12]
 8023380:	1e7e      	subs	r6, r7, #1
 8023382:	b13c      	cbz	r4, 8023394 <_fwalk+0x94>
 8023384:	f9b5 700e 	ldrsh.w	r7, [r5, #14]
 8023388:	1c7b      	adds	r3, r7, #1
 802338a:	4628      	mov	r0, r5
 802338c:	d002      	beq.n	8023394 <_fwalk+0x94>
 802338e:	47c8      	blx	r9
 8023390:	ea4a 0a00 	orr.w	sl, sl, r0
 8023394:	f105 0468 	add.w	r4, r5, #104	; 0x68
 8023398:	1e77      	subs	r7, r6, #1
 802339a:	2e00      	cmp	r6, #0
 802339c:	d1e1      	bne.n	8023362 <_fwalk+0x62>
 802339e:	f8d8 8000 	ldr.w	r8, [r8]
 80233a2:	f1b8 0f00 	cmp.w	r8, #0
 80233a6:	d1b6      	bne.n	8023316 <_fwalk+0x16>
 80233a8:	f7ff fcba 	bl	8022d20 <__sfp_lock_release>
 80233ac:	4650      	mov	r0, sl
 80233ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80233b2:	46c2      	mov	sl, r8
 80233b4:	e7f8      	b.n	80233a8 <_fwalk+0xa8>
 80233b6:	bf00      	nop

080233b8 <_fwalk_reent>:
 80233b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80233bc:	4680      	mov	r8, r0
 80233be:	4689      	mov	r9, r1
 80233c0:	f7ff fcac 	bl	8022d1c <__sfp_lock_acquire>
 80233c4:	f518 7a38 	adds.w	sl, r8, #736	; 0x2e0
 80233c8:	d053      	beq.n	8023472 <_fwalk_reent+0xba>
 80233ca:	f04f 0b00 	mov.w	fp, #0
 80233ce:	f8da 5004 	ldr.w	r5, [sl, #4]
 80233d2:	f8da 4008 	ldr.w	r4, [sl, #8]
 80233d6:	3d01      	subs	r5, #1
 80233d8:	d441      	bmi.n	802345e <_fwalk_reent+0xa6>
 80233da:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80233de:	f005 0601 	and.w	r6, r5, #1
 80233e2:	b143      	cbz	r3, 80233f6 <_fwalk_reent+0x3e>
 80233e4:	f9b4 000e 	ldrsh.w	r0, [r4, #14]
 80233e8:	1c43      	adds	r3, r0, #1
 80233ea:	d004      	beq.n	80233f6 <_fwalk_reent+0x3e>
 80233ec:	4640      	mov	r0, r8
 80233ee:	4621      	mov	r1, r4
 80233f0:	47c8      	blx	r9
 80233f2:	ea4b 0b00 	orr.w	fp, fp, r0
 80233f6:	3468      	adds	r4, #104	; 0x68
 80233f8:	1e6f      	subs	r7, r5, #1
 80233fa:	b385      	cbz	r5, 802345e <_fwalk_reent+0xa6>
 80233fc:	b17e      	cbz	r6, 802341e <_fwalk_reent+0x66>
 80233fe:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 8023402:	b141      	cbz	r1, 8023416 <_fwalk_reent+0x5e>
 8023404:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
 8023408:	1c53      	adds	r3, r2, #1
 802340a:	d004      	beq.n	8023416 <_fwalk_reent+0x5e>
 802340c:	4640      	mov	r0, r8
 802340e:	4621      	mov	r1, r4
 8023410:	47c8      	blx	r9
 8023412:	ea4b 0b00 	orr.w	fp, fp, r0
 8023416:	3f01      	subs	r7, #1
 8023418:	3468      	adds	r4, #104	; 0x68
 802341a:	1c7a      	adds	r2, r7, #1
 802341c:	d01f      	beq.n	802345e <_fwalk_reent+0xa6>
 802341e:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
 8023422:	f104 0568 	add.w	r5, r4, #104	; 0x68
 8023426:	b146      	cbz	r6, 802343a <_fwalk_reent+0x82>
 8023428:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 802342c:	3301      	adds	r3, #1
 802342e:	4621      	mov	r1, r4
 8023430:	4640      	mov	r0, r8
 8023432:	d002      	beq.n	802343a <_fwalk_reent+0x82>
 8023434:	47c8      	blx	r9
 8023436:	ea4b 0b00 	orr.w	fp, fp, r0
 802343a:	f9b5 400c 	ldrsh.w	r4, [r5, #12]
 802343e:	1e7e      	subs	r6, r7, #1
 8023440:	b144      	cbz	r4, 8023454 <_fwalk_reent+0x9c>
 8023442:	f9b5 700e 	ldrsh.w	r7, [r5, #14]
 8023446:	1c7b      	adds	r3, r7, #1
 8023448:	4640      	mov	r0, r8
 802344a:	4629      	mov	r1, r5
 802344c:	d002      	beq.n	8023454 <_fwalk_reent+0x9c>
 802344e:	47c8      	blx	r9
 8023450:	ea4b 0b00 	orr.w	fp, fp, r0
 8023454:	f105 0468 	add.w	r4, r5, #104	; 0x68
 8023458:	1e77      	subs	r7, r6, #1
 802345a:	2e00      	cmp	r6, #0
 802345c:	d1df      	bne.n	802341e <_fwalk_reent+0x66>
 802345e:	f8da a000 	ldr.w	sl, [sl]
 8023462:	f1ba 0f00 	cmp.w	sl, #0
 8023466:	d1b2      	bne.n	80233ce <_fwalk_reent+0x16>
 8023468:	f7ff fc5a 	bl	8022d20 <__sfp_lock_release>
 802346c:	4658      	mov	r0, fp
 802346e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023472:	46d3      	mov	fp, sl
 8023474:	e7f8      	b.n	8023468 <_fwalk_reent+0xb0>
 8023476:	bf00      	nop

08023478 <__libc_init_array>:
 8023478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802347a:	4f20      	ldr	r7, [pc, #128]	; (80234fc <__libc_init_array+0x84>)
 802347c:	4c20      	ldr	r4, [pc, #128]	; (8023500 <__libc_init_array+0x88>)
 802347e:	1b38      	subs	r0, r7, r4
 8023480:	1087      	asrs	r7, r0, #2
 8023482:	d017      	beq.n	80234b4 <__libc_init_array+0x3c>
 8023484:	1e7a      	subs	r2, r7, #1
 8023486:	6823      	ldr	r3, [r4, #0]
 8023488:	2501      	movs	r5, #1
 802348a:	f002 0601 	and.w	r6, r2, #1
 802348e:	4798      	blx	r3
 8023490:	42af      	cmp	r7, r5
 8023492:	d00f      	beq.n	80234b4 <__libc_init_array+0x3c>
 8023494:	b12e      	cbz	r6, 80234a2 <__libc_init_array+0x2a>
 8023496:	f854 1f04 	ldr.w	r1, [r4, #4]!
 802349a:	2502      	movs	r5, #2
 802349c:	4788      	blx	r1
 802349e:	42af      	cmp	r7, r5
 80234a0:	d008      	beq.n	80234b4 <__libc_init_array+0x3c>
 80234a2:	6860      	ldr	r0, [r4, #4]
 80234a4:	4780      	blx	r0
 80234a6:	3502      	adds	r5, #2
 80234a8:	68a2      	ldr	r2, [r4, #8]
 80234aa:	1d26      	adds	r6, r4, #4
 80234ac:	4790      	blx	r2
 80234ae:	3408      	adds	r4, #8
 80234b0:	42af      	cmp	r7, r5
 80234b2:	d1f6      	bne.n	80234a2 <__libc_init_array+0x2a>
 80234b4:	4f13      	ldr	r7, [pc, #76]	; (8023504 <__libc_init_array+0x8c>)
 80234b6:	4c14      	ldr	r4, [pc, #80]	; (8023508 <__libc_init_array+0x90>)
 80234b8:	f7de faf4 	bl	8001aa4 <_init>
 80234bc:	1b3b      	subs	r3, r7, r4
 80234be:	109f      	asrs	r7, r3, #2
 80234c0:	d018      	beq.n	80234f4 <__libc_init_array+0x7c>
 80234c2:	1e7d      	subs	r5, r7, #1
 80234c4:	6821      	ldr	r1, [r4, #0]
 80234c6:	f005 0601 	and.w	r6, r5, #1
 80234ca:	2501      	movs	r5, #1
 80234cc:	4788      	blx	r1
 80234ce:	42af      	cmp	r7, r5
 80234d0:	d011      	beq.n	80234f6 <__libc_init_array+0x7e>
 80234d2:	b12e      	cbz	r6, 80234e0 <__libc_init_array+0x68>
 80234d4:	f854 0f04 	ldr.w	r0, [r4, #4]!
 80234d8:	2502      	movs	r5, #2
 80234da:	4780      	blx	r0
 80234dc:	42af      	cmp	r7, r5
 80234de:	d00b      	beq.n	80234f8 <__libc_init_array+0x80>
 80234e0:	6862      	ldr	r2, [r4, #4]
 80234e2:	4790      	blx	r2
 80234e4:	3502      	adds	r5, #2
 80234e6:	68a3      	ldr	r3, [r4, #8]
 80234e8:	1d26      	adds	r6, r4, #4
 80234ea:	4798      	blx	r3
 80234ec:	3408      	adds	r4, #8
 80234ee:	42af      	cmp	r7, r5
 80234f0:	d1f6      	bne.n	80234e0 <__libc_init_array+0x68>
 80234f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80234f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80234f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80234f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80234fa:	bf00      	nop
 80234fc:	080256d8 	.word	0x080256d8
 8023500:	080256d8 	.word	0x080256d8
 8023504:	080256d8 	.word	0x080256d8
 8023508:	080256d8 	.word	0x080256d8

0802350c <__smakebuf_r>:
 802350c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802350e:	898b      	ldrh	r3, [r1, #12]
 8023510:	f003 0202 	and.w	r2, r3, #2
 8023514:	460c      	mov	r4, r1
 8023516:	b211      	sxth	r1, r2
 8023518:	b091      	sub	sp, #68	; 0x44
 802351a:	4605      	mov	r5, r0
 802351c:	2900      	cmp	r1, #0
 802351e:	d138      	bne.n	8023592 <__smakebuf_r+0x86>
 8023520:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8023524:	2900      	cmp	r1, #0
 8023526:	db16      	blt.n	8023556 <__smakebuf_r+0x4a>
 8023528:	aa01      	add	r2, sp, #4
 802352a:	f7ff fed5 	bl	80232d8 <_fstat_r>
 802352e:	2800      	cmp	r0, #0
 8023530:	db10      	blt.n	8023554 <__smakebuf_r+0x48>
 8023532:	9b02      	ldr	r3, [sp, #8]
 8023534:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
 8023538:	f5b0 5600 	subs.w	r6, r0, #8192	; 0x2000
 802353c:	4277      	negs	r7, r6
 802353e:	4177      	adcs	r7, r6
 8023540:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8023544:	d02c      	beq.n	80235a0 <__smakebuf_r+0x94>
 8023546:	89a3      	ldrh	r3, [r4, #12]
 8023548:	f443 6000 	orr.w	r0, r3, #2048	; 0x800
 802354c:	81a0      	strh	r0, [r4, #12]
 802354e:	f44f 6680 	mov.w	r6, #1024	; 0x400
 8023552:	e00c      	b.n	802356e <__smakebuf_r+0x62>
 8023554:	89a3      	ldrh	r3, [r4, #12]
 8023556:	f003 0680 	and.w	r6, r3, #128	; 0x80
 802355a:	b237      	sxth	r7, r6
 802355c:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
 8023560:	2f00      	cmp	r7, #0
 8023562:	bf0c      	ite	eq
 8023564:	f44f 6680 	moveq.w	r6, #1024	; 0x400
 8023568:	2640      	movne	r6, #64	; 0x40
 802356a:	81a2      	strh	r2, [r4, #12]
 802356c:	2700      	movs	r7, #0
 802356e:	4631      	mov	r1, r6
 8023570:	4628      	mov	r0, r5
 8023572:	f7e1 f895 	bl	80046a0 <_malloc_r>
 8023576:	89a1      	ldrh	r1, [r4, #12]
 8023578:	2800      	cmp	r0, #0
 802357a:	d028      	beq.n	80235ce <__smakebuf_r+0xc2>
 802357c:	4a1b      	ldr	r2, [pc, #108]	; (80235ec <__smakebuf_r+0xe0>)
 802357e:	f041 0380 	orr.w	r3, r1, #128	; 0x80
 8023582:	63ea      	str	r2, [r5, #60]	; 0x3c
 8023584:	81a3      	strh	r3, [r4, #12]
 8023586:	6020      	str	r0, [r4, #0]
 8023588:	6120      	str	r0, [r4, #16]
 802358a:	6166      	str	r6, [r4, #20]
 802358c:	b99f      	cbnz	r7, 80235b6 <__smakebuf_r+0xaa>
 802358e:	b011      	add	sp, #68	; 0x44
 8023590:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023592:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8023596:	2001      	movs	r0, #1
 8023598:	6022      	str	r2, [r4, #0]
 802359a:	6122      	str	r2, [r4, #16]
 802359c:	6160      	str	r0, [r4, #20]
 802359e:	e7f6      	b.n	802358e <__smakebuf_r+0x82>
 80235a0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80235a2:	4a13      	ldr	r2, [pc, #76]	; (80235f0 <__smakebuf_r+0xe4>)
 80235a4:	4291      	cmp	r1, r2
 80235a6:	d1ce      	bne.n	8023546 <__smakebuf_r+0x3a>
 80235a8:	89a1      	ldrh	r1, [r4, #12]
 80235aa:	f44f 6680 	mov.w	r6, #1024	; 0x400
 80235ae:	4331      	orrs	r1, r6
 80235b0:	81a1      	strh	r1, [r4, #12]
 80235b2:	64e6      	str	r6, [r4, #76]	; 0x4c
 80235b4:	e7db      	b.n	802356e <__smakebuf_r+0x62>
 80235b6:	4628      	mov	r0, r5
 80235b8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80235bc:	f001 ff56 	bl	802546c <_isatty_r>
 80235c0:	2800      	cmp	r0, #0
 80235c2:	d0e4      	beq.n	802358e <__smakebuf_r+0x82>
 80235c4:	89a0      	ldrh	r0, [r4, #12]
 80235c6:	f040 0101 	orr.w	r1, r0, #1
 80235ca:	81a1      	strh	r1, [r4, #12]
 80235cc:	e7df      	b.n	802358e <__smakebuf_r+0x82>
 80235ce:	f401 7300 	and.w	r3, r1, #512	; 0x200
 80235d2:	b21a      	sxth	r2, r3
 80235d4:	2a00      	cmp	r2, #0
 80235d6:	d1da      	bne.n	802358e <__smakebuf_r+0x82>
 80235d8:	f104 0043 	add.w	r0, r4, #67	; 0x43
 80235dc:	f041 0102 	orr.w	r1, r1, #2
 80235e0:	2301      	movs	r3, #1
 80235e2:	81a1      	strh	r1, [r4, #12]
 80235e4:	6020      	str	r0, [r4, #0]
 80235e6:	6120      	str	r0, [r4, #16]
 80235e8:	6163      	str	r3, [r4, #20]
 80235ea:	e7d0      	b.n	802358e <__smakebuf_r+0x82>
 80235ec:	08022b95 	.word	0x08022b95
 80235f0:	08024781 	.word	0x08024781

080235f4 <malloc>:
 80235f4:	f646 3380 	movw	r3, #27520	; 0x6b80
 80235f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80235fc:	4601      	mov	r1, r0
 80235fe:	6818      	ldr	r0, [r3, #0]
 8023600:	f7e1 b84e 	b.w	80046a0 <_malloc_r>

08023604 <free>:
 8023604:	f646 3380 	movw	r3, #27520	; 0x6b80
 8023608:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802360c:	4601      	mov	r1, r0
 802360e:	6818      	ldr	r0, [r3, #0]
 8023610:	f7e1 b876 	b.w	8004700 <_free_r>

08023614 <memcpy>:
 8023614:	2a0f      	cmp	r2, #15
 8023616:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 802361a:	f240 8095 	bls.w	8023748 <memcpy+0x134>
 802361e:	ea41 0300 	orr.w	r3, r1, r0
 8023622:	079b      	lsls	r3, r3, #30
 8023624:	f040 8092 	bne.w	802374c <memcpy+0x138>
 8023628:	680c      	ldr	r4, [r1, #0]
 802362a:	6004      	str	r4, [r0, #0]
 802362c:	684d      	ldr	r5, [r1, #4]
 802362e:	6045      	str	r5, [r0, #4]
 8023630:	688e      	ldr	r6, [r1, #8]
 8023632:	f1a2 0310 	sub.w	r3, r2, #16
 8023636:	6086      	str	r6, [r0, #8]
 8023638:	68cc      	ldr	r4, [r1, #12]
 802363a:	461d      	mov	r5, r3
 802363c:	2d0f      	cmp	r5, #15
 802363e:	60c4      	str	r4, [r0, #12]
 8023640:	f3c3 1600 	ubfx	r6, r3, #4, #1
 8023644:	f101 0410 	add.w	r4, r1, #16
 8023648:	f100 0310 	add.w	r3, r0, #16
 802364c:	d922      	bls.n	8023694 <memcpy+0x80>
 802364e:	b166      	cbz	r6, 802366a <memcpy+0x56>
 8023650:	6826      	ldr	r6, [r4, #0]
 8023652:	601e      	str	r6, [r3, #0]
 8023654:	6866      	ldr	r6, [r4, #4]
 8023656:	605e      	str	r6, [r3, #4]
 8023658:	68a6      	ldr	r6, [r4, #8]
 802365a:	609e      	str	r6, [r3, #8]
 802365c:	68e6      	ldr	r6, [r4, #12]
 802365e:	3d10      	subs	r5, #16
 8023660:	60de      	str	r6, [r3, #12]
 8023662:	3410      	adds	r4, #16
 8023664:	3310      	adds	r3, #16
 8023666:	2d0f      	cmp	r5, #15
 8023668:	d914      	bls.n	8023694 <memcpy+0x80>
 802366a:	6826      	ldr	r6, [r4, #0]
 802366c:	601e      	str	r6, [r3, #0]
 802366e:	6866      	ldr	r6, [r4, #4]
 8023670:	605e      	str	r6, [r3, #4]
 8023672:	68a6      	ldr	r6, [r4, #8]
 8023674:	609e      	str	r6, [r3, #8]
 8023676:	68e6      	ldr	r6, [r4, #12]
 8023678:	60de      	str	r6, [r3, #12]
 802367a:	6926      	ldr	r6, [r4, #16]
 802367c:	611e      	str	r6, [r3, #16]
 802367e:	6966      	ldr	r6, [r4, #20]
 8023680:	615e      	str	r6, [r3, #20]
 8023682:	69a6      	ldr	r6, [r4, #24]
 8023684:	619e      	str	r6, [r3, #24]
 8023686:	69e6      	ldr	r6, [r4, #28]
 8023688:	3d20      	subs	r5, #32
 802368a:	61de      	str	r6, [r3, #28]
 802368c:	3420      	adds	r4, #32
 802368e:	3320      	adds	r3, #32
 8023690:	2d0f      	cmp	r5, #15
 8023692:	d8ea      	bhi.n	802366a <memcpy+0x56>
 8023694:	f1a2 0310 	sub.w	r3, r2, #16
 8023698:	f023 040f 	bic.w	r4, r3, #15
 802369c:	f002 030f 	and.w	r3, r2, #15
 80236a0:	3410      	adds	r4, #16
 80236a2:	2b03      	cmp	r3, #3
 80236a4:	eb00 0804 	add.w	r8, r0, r4
 80236a8:	4421      	add	r1, r4
 80236aa:	d951      	bls.n	8023750 <memcpy+0x13c>
 80236ac:	f1a3 0904 	sub.w	r9, r3, #4
 80236b0:	460b      	mov	r3, r1
 80236b2:	ea4f 0999 	mov.w	r9, r9, lsr #2
 80236b6:	eb01 0c89 	add.w	ip, r1, r9, lsl #2
 80236ba:	f853 6b04 	ldr.w	r6, [r3], #4
 80236be:	ebc1 050c 	rsb	r5, r1, ip
 80236c2:	4644      	mov	r4, r8
 80236c4:	f10c 0c04 	add.w	ip, ip, #4
 80236c8:	4563      	cmp	r3, ip
 80236ca:	f844 6b04 	str.w	r6, [r4], #4
 80236ce:	f3c5 0580 	ubfx	r5, r5, #2, #1
 80236d2:	d012      	beq.n	80236fa <memcpy+0xe6>
 80236d4:	b12d      	cbz	r5, 80236e2 <memcpy+0xce>
 80236d6:	f853 5b04 	ldr.w	r5, [r3], #4
 80236da:	4563      	cmp	r3, ip
 80236dc:	f844 5b04 	str.w	r5, [r4], #4
 80236e0:	d00b      	beq.n	80236fa <memcpy+0xe6>
 80236e2:	461e      	mov	r6, r3
 80236e4:	4625      	mov	r5, r4
 80236e6:	f856 7b04 	ldr.w	r7, [r6], #4
 80236ea:	f845 7b04 	str.w	r7, [r5], #4
 80236ee:	685f      	ldr	r7, [r3, #4]
 80236f0:	1d33      	adds	r3, r6, #4
 80236f2:	6067      	str	r7, [r4, #4]
 80236f4:	1d2c      	adds	r4, r5, #4
 80236f6:	4563      	cmp	r3, ip
 80236f8:	d1f3      	bne.n	80236e2 <memcpy+0xce>
 80236fa:	f109 0301 	add.w	r3, r9, #1
 80236fe:	009c      	lsls	r4, r3, #2
 8023700:	1909      	adds	r1, r1, r4
 8023702:	f002 0203 	and.w	r2, r2, #3
 8023706:	4444      	add	r4, r8
 8023708:	b1da      	cbz	r2, 8023742 <memcpy+0x12e>
 802370a:	4623      	mov	r3, r4
 802370c:	780d      	ldrb	r5, [r1, #0]
 802370e:	f803 5b01 	strb.w	r5, [r3], #1
 8023712:	18a2      	adds	r2, r4, r2
 8023714:	43e4      	mvns	r4, r4
 8023716:	1914      	adds	r4, r2, r4
 8023718:	4293      	cmp	r3, r2
 802371a:	f004 0401 	and.w	r4, r4, #1
 802371e:	d010      	beq.n	8023742 <memcpy+0x12e>
 8023720:	b12c      	cbz	r4, 802372e <memcpy+0x11a>
 8023722:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8023726:	f803 4b01 	strb.w	r4, [r3], #1
 802372a:	4293      	cmp	r3, r2
 802372c:	d009      	beq.n	8023742 <memcpy+0x12e>
 802372e:	784d      	ldrb	r5, [r1, #1]
 8023730:	461c      	mov	r4, r3
 8023732:	f804 5b01 	strb.w	r5, [r4], #1
 8023736:	788d      	ldrb	r5, [r1, #2]
 8023738:	705d      	strb	r5, [r3, #1]
 802373a:	1c63      	adds	r3, r4, #1
 802373c:	3102      	adds	r1, #2
 802373e:	4293      	cmp	r3, r2
 8023740:	d1f5      	bne.n	802372e <memcpy+0x11a>
 8023742:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8023746:	4770      	bx	lr
 8023748:	4604      	mov	r4, r0
 802374a:	e7dd      	b.n	8023708 <memcpy+0xf4>
 802374c:	4604      	mov	r4, r0
 802374e:	e7dc      	b.n	802370a <memcpy+0xf6>
 8023750:	4644      	mov	r4, r8
 8023752:	461a      	mov	r2, r3
 8023754:	e7d8      	b.n	8023708 <memcpy+0xf4>
 8023756:	bf00      	nop

08023758 <memmove>:
 8023758:	4288      	cmp	r0, r1
 802375a:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 802375e:	d926      	bls.n	80237ae <memmove+0x56>
 8023760:	188c      	adds	r4, r1, r2
 8023762:	42a0      	cmp	r0, r4
 8023764:	d223      	bcs.n	80237ae <memmove+0x56>
 8023766:	1883      	adds	r3, r0, r2
 8023768:	1e55      	subs	r5, r2, #1
 802376a:	b1ea      	cbz	r2, 80237a8 <memmove+0x50>
 802376c:	4622      	mov	r2, r4
 802376e:	f005 0401 	and.w	r4, r5, #1
 8023772:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
 8023776:	f803 1d01 	strb.w	r1, [r3, #-1]!
 802377a:	1e69      	subs	r1, r5, #1
 802377c:	b1a5      	cbz	r5, 80237a8 <memmove+0x50>
 802377e:	b13c      	cbz	r4, 8023790 <memmove+0x38>
 8023780:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
 8023784:	3901      	subs	r1, #1
 8023786:	f1b1 3fff 	cmp.w	r1, #4294967295
 802378a:	f803 4d01 	strb.w	r4, [r3, #-1]!
 802378e:	d00b      	beq.n	80237a8 <memmove+0x50>
 8023790:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
 8023794:	f803 4d01 	strb.w	r4, [r3, #-1]!
 8023798:	3902      	subs	r1, #2
 802379a:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
 802379e:	f1b1 3fff 	cmp.w	r1, #4294967295
 80237a2:	f803 4d01 	strb.w	r4, [r3, #-1]!
 80237a6:	d1f3      	bne.n	8023790 <memmove+0x38>
 80237a8:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 80237ac:	4770      	bx	lr
 80237ae:	2a0f      	cmp	r2, #15
 80237b0:	f240 8096 	bls.w	80238e0 <memmove+0x188>
 80237b4:	ea41 0300 	orr.w	r3, r1, r0
 80237b8:	079b      	lsls	r3, r3, #30
 80237ba:	f040 8093 	bne.w	80238e4 <memmove+0x18c>
 80237be:	680c      	ldr	r4, [r1, #0]
 80237c0:	6004      	str	r4, [r0, #0]
 80237c2:	684d      	ldr	r5, [r1, #4]
 80237c4:	6045      	str	r5, [r0, #4]
 80237c6:	688e      	ldr	r6, [r1, #8]
 80237c8:	f1a2 0310 	sub.w	r3, r2, #16
 80237cc:	6086      	str	r6, [r0, #8]
 80237ce:	68cc      	ldr	r4, [r1, #12]
 80237d0:	461d      	mov	r5, r3
 80237d2:	2d0f      	cmp	r5, #15
 80237d4:	60c4      	str	r4, [r0, #12]
 80237d6:	f3c3 1600 	ubfx	r6, r3, #4, #1
 80237da:	f101 0410 	add.w	r4, r1, #16
 80237de:	f100 0310 	add.w	r3, r0, #16
 80237e2:	d922      	bls.n	802382a <memmove+0xd2>
 80237e4:	b166      	cbz	r6, 8023800 <memmove+0xa8>
 80237e6:	6826      	ldr	r6, [r4, #0]
 80237e8:	601e      	str	r6, [r3, #0]
 80237ea:	6866      	ldr	r6, [r4, #4]
 80237ec:	605e      	str	r6, [r3, #4]
 80237ee:	68a6      	ldr	r6, [r4, #8]
 80237f0:	609e      	str	r6, [r3, #8]
 80237f2:	68e6      	ldr	r6, [r4, #12]
 80237f4:	3d10      	subs	r5, #16
 80237f6:	60de      	str	r6, [r3, #12]
 80237f8:	3410      	adds	r4, #16
 80237fa:	3310      	adds	r3, #16
 80237fc:	2d0f      	cmp	r5, #15
 80237fe:	d914      	bls.n	802382a <memmove+0xd2>
 8023800:	6826      	ldr	r6, [r4, #0]
 8023802:	601e      	str	r6, [r3, #0]
 8023804:	6866      	ldr	r6, [r4, #4]
 8023806:	605e      	str	r6, [r3, #4]
 8023808:	68a6      	ldr	r6, [r4, #8]
 802380a:	609e      	str	r6, [r3, #8]
 802380c:	68e6      	ldr	r6, [r4, #12]
 802380e:	60de      	str	r6, [r3, #12]
 8023810:	6926      	ldr	r6, [r4, #16]
 8023812:	611e      	str	r6, [r3, #16]
 8023814:	6966      	ldr	r6, [r4, #20]
 8023816:	615e      	str	r6, [r3, #20]
 8023818:	69a6      	ldr	r6, [r4, #24]
 802381a:	619e      	str	r6, [r3, #24]
 802381c:	69e6      	ldr	r6, [r4, #28]
 802381e:	3d20      	subs	r5, #32
 8023820:	61de      	str	r6, [r3, #28]
 8023822:	3420      	adds	r4, #32
 8023824:	3320      	adds	r3, #32
 8023826:	2d0f      	cmp	r5, #15
 8023828:	d8ea      	bhi.n	8023800 <memmove+0xa8>
 802382a:	f1a2 0310 	sub.w	r3, r2, #16
 802382e:	f023 040f 	bic.w	r4, r3, #15
 8023832:	f002 030f 	and.w	r3, r2, #15
 8023836:	3410      	adds	r4, #16
 8023838:	2b03      	cmp	r3, #3
 802383a:	eb00 0804 	add.w	r8, r0, r4
 802383e:	4421      	add	r1, r4
 8023840:	d952      	bls.n	80238e8 <memmove+0x190>
 8023842:	f1a3 0904 	sub.w	r9, r3, #4
 8023846:	460b      	mov	r3, r1
 8023848:	ea4f 0999 	mov.w	r9, r9, lsr #2
 802384c:	eb01 0c89 	add.w	ip, r1, r9, lsl #2
 8023850:	f853 6b04 	ldr.w	r6, [r3], #4
 8023854:	ebc1 050c 	rsb	r5, r1, ip
 8023858:	4644      	mov	r4, r8
 802385a:	f10c 0c04 	add.w	ip, ip, #4
 802385e:	4563      	cmp	r3, ip
 8023860:	f844 6b04 	str.w	r6, [r4], #4
 8023864:	f3c5 0580 	ubfx	r5, r5, #2, #1
 8023868:	d012      	beq.n	8023890 <memmove+0x138>
 802386a:	b12d      	cbz	r5, 8023878 <memmove+0x120>
 802386c:	f853 5b04 	ldr.w	r5, [r3], #4
 8023870:	4563      	cmp	r3, ip
 8023872:	f844 5b04 	str.w	r5, [r4], #4
 8023876:	d00b      	beq.n	8023890 <memmove+0x138>
 8023878:	461e      	mov	r6, r3
 802387a:	4625      	mov	r5, r4
 802387c:	f856 7b04 	ldr.w	r7, [r6], #4
 8023880:	f845 7b04 	str.w	r7, [r5], #4
 8023884:	685f      	ldr	r7, [r3, #4]
 8023886:	1d33      	adds	r3, r6, #4
 8023888:	6067      	str	r7, [r4, #4]
 802388a:	1d2c      	adds	r4, r5, #4
 802388c:	4563      	cmp	r3, ip
 802388e:	d1f3      	bne.n	8023878 <memmove+0x120>
 8023890:	f109 0301 	add.w	r3, r9, #1
 8023894:	009c      	lsls	r4, r3, #2
 8023896:	1909      	adds	r1, r1, r4
 8023898:	f002 0203 	and.w	r2, r2, #3
 802389c:	4444      	add	r4, r8
 802389e:	2a00      	cmp	r2, #0
 80238a0:	d082      	beq.n	80237a8 <memmove+0x50>
 80238a2:	4623      	mov	r3, r4
 80238a4:	780d      	ldrb	r5, [r1, #0]
 80238a6:	f803 5b01 	strb.w	r5, [r3], #1
 80238aa:	18a2      	adds	r2, r4, r2
 80238ac:	43e4      	mvns	r4, r4
 80238ae:	1914      	adds	r4, r2, r4
 80238b0:	4293      	cmp	r3, r2
 80238b2:	f004 0401 	and.w	r4, r4, #1
 80238b6:	f43f af77 	beq.w	80237a8 <memmove+0x50>
 80238ba:	b134      	cbz	r4, 80238ca <memmove+0x172>
 80238bc:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80238c0:	f803 4b01 	strb.w	r4, [r3], #1
 80238c4:	4293      	cmp	r3, r2
 80238c6:	f43f af6f 	beq.w	80237a8 <memmove+0x50>
 80238ca:	784d      	ldrb	r5, [r1, #1]
 80238cc:	461c      	mov	r4, r3
 80238ce:	f804 5b01 	strb.w	r5, [r4], #1
 80238d2:	788d      	ldrb	r5, [r1, #2]
 80238d4:	705d      	strb	r5, [r3, #1]
 80238d6:	1c63      	adds	r3, r4, #1
 80238d8:	3102      	adds	r1, #2
 80238da:	4293      	cmp	r3, r2
 80238dc:	d1f5      	bne.n	80238ca <memmove+0x172>
 80238de:	e763      	b.n	80237a8 <memmove+0x50>
 80238e0:	4604      	mov	r4, r0
 80238e2:	e7dc      	b.n	802389e <memmove+0x146>
 80238e4:	4604      	mov	r4, r0
 80238e6:	e7dc      	b.n	80238a2 <memmove+0x14a>
 80238e8:	4644      	mov	r4, r8
 80238ea:	461a      	mov	r2, r3
 80238ec:	e7d7      	b.n	802389e <memmove+0x146>
 80238ee:	bf00      	nop

080238f0 <memset>:
 80238f0:	b4f0      	push	{r4, r5, r6, r7}
 80238f2:	0784      	lsls	r4, r0, #30
 80238f4:	4603      	mov	r3, r0
 80238f6:	f000 808e 	beq.w	8023a16 <memset+0x126>
 80238fa:	1e54      	subs	r4, r2, #1
 80238fc:	2a00      	cmp	r2, #0
 80238fe:	f000 8088 	beq.w	8023a12 <memset+0x122>
 8023902:	07e5      	lsls	r5, r4, #31
 8023904:	b2ce      	uxtb	r6, r1
 8023906:	d411      	bmi.n	802392c <memset+0x3c>
 8023908:	461a      	mov	r2, r3
 802390a:	1e67      	subs	r7, r4, #1
 802390c:	f802 6b01 	strb.w	r6, [r2], #1
 8023910:	4613      	mov	r3, r2
 8023912:	4615      	mov	r5, r2
 8023914:	0792      	lsls	r2, r2, #30
 8023916:	d00f      	beq.n	8023938 <memset+0x48>
 8023918:	2c00      	cmp	r4, #0
 802391a:	d07a      	beq.n	8023a12 <memset+0x122>
 802391c:	f803 6b01 	strb.w	r6, [r3], #1
 8023920:	079a      	lsls	r2, r3, #30
 8023922:	463c      	mov	r4, r7
 8023924:	461d      	mov	r5, r3
 8023926:	d007      	beq.n	8023938 <memset+0x48>
 8023928:	3c01      	subs	r4, #1
 802392a:	e7ed      	b.n	8023908 <memset+0x18>
 802392c:	4603      	mov	r3, r0
 802392e:	f803 6b01 	strb.w	r6, [r3], #1
 8023932:	079a      	lsls	r2, r3, #30
 8023934:	461d      	mov	r5, r3
 8023936:	d1f7      	bne.n	8023928 <memset+0x38>
 8023938:	2c03      	cmp	r4, #3
 802393a:	d952      	bls.n	80239e2 <memset+0xf2>
 802393c:	b2ce      	uxtb	r6, r1
 802393e:	ea46 2706 	orr.w	r7, r6, r6, lsl #8
 8023942:	2c0f      	cmp	r4, #15
 8023944:	ea47 4307 	orr.w	r3, r7, r7, lsl #16
 8023948:	d92d      	bls.n	80239a6 <memset+0xb6>
 802394a:	f1a4 0210 	sub.w	r2, r4, #16
 802394e:	4617      	mov	r7, r2
 8023950:	2f0f      	cmp	r7, #15
 8023952:	f3c2 1600 	ubfx	r6, r2, #4, #1
 8023956:	602b      	str	r3, [r5, #0]
 8023958:	606b      	str	r3, [r5, #4]
 802395a:	60ab      	str	r3, [r5, #8]
 802395c:	60eb      	str	r3, [r5, #12]
 802395e:	f105 0210 	add.w	r2, r5, #16
 8023962:	d916      	bls.n	8023992 <memset+0xa2>
 8023964:	b13e      	cbz	r6, 8023976 <memset+0x86>
 8023966:	3f10      	subs	r7, #16
 8023968:	6013      	str	r3, [r2, #0]
 802396a:	6053      	str	r3, [r2, #4]
 802396c:	6093      	str	r3, [r2, #8]
 802396e:	60d3      	str	r3, [r2, #12]
 8023970:	3210      	adds	r2, #16
 8023972:	2f0f      	cmp	r7, #15
 8023974:	d90d      	bls.n	8023992 <memset+0xa2>
 8023976:	3f20      	subs	r7, #32
 8023978:	f102 0610 	add.w	r6, r2, #16
 802397c:	6013      	str	r3, [r2, #0]
 802397e:	6053      	str	r3, [r2, #4]
 8023980:	6093      	str	r3, [r2, #8]
 8023982:	60d3      	str	r3, [r2, #12]
 8023984:	6113      	str	r3, [r2, #16]
 8023986:	6153      	str	r3, [r2, #20]
 8023988:	6193      	str	r3, [r2, #24]
 802398a:	61d3      	str	r3, [r2, #28]
 802398c:	3220      	adds	r2, #32
 802398e:	2f0f      	cmp	r7, #15
 8023990:	d8f1      	bhi.n	8023976 <memset+0x86>
 8023992:	f1a4 0210 	sub.w	r2, r4, #16
 8023996:	f022 020f 	bic.w	r2, r2, #15
 802399a:	f004 040f 	and.w	r4, r4, #15
 802399e:	3210      	adds	r2, #16
 80239a0:	2c03      	cmp	r4, #3
 80239a2:	4415      	add	r5, r2
 80239a4:	d91d      	bls.n	80239e2 <memset+0xf2>
 80239a6:	1f27      	subs	r7, r4, #4
 80239a8:	463e      	mov	r6, r7
 80239aa:	462a      	mov	r2, r5
 80239ac:	2e03      	cmp	r6, #3
 80239ae:	f842 3b04 	str.w	r3, [r2], #4
 80239b2:	f3c7 0780 	ubfx	r7, r7, #2, #1
 80239b6:	d90d      	bls.n	80239d4 <memset+0xe4>
 80239b8:	b127      	cbz	r7, 80239c4 <memset+0xd4>
 80239ba:	3e04      	subs	r6, #4
 80239bc:	2e03      	cmp	r6, #3
 80239be:	f842 3b04 	str.w	r3, [r2], #4
 80239c2:	d907      	bls.n	80239d4 <memset+0xe4>
 80239c4:	4617      	mov	r7, r2
 80239c6:	3e08      	subs	r6, #8
 80239c8:	f847 3b04 	str.w	r3, [r7], #4
 80239cc:	6053      	str	r3, [r2, #4]
 80239ce:	1d3a      	adds	r2, r7, #4
 80239d0:	2e03      	cmp	r6, #3
 80239d2:	d8f7      	bhi.n	80239c4 <memset+0xd4>
 80239d4:	1f23      	subs	r3, r4, #4
 80239d6:	f023 0203 	bic.w	r2, r3, #3
 80239da:	1d13      	adds	r3, r2, #4
 80239dc:	f004 0403 	and.w	r4, r4, #3
 80239e0:	18ed      	adds	r5, r5, r3
 80239e2:	b1b4      	cbz	r4, 8023a12 <memset+0x122>
 80239e4:	462b      	mov	r3, r5
 80239e6:	b2c9      	uxtb	r1, r1
 80239e8:	f803 1b01 	strb.w	r1, [r3], #1
 80239ec:	192c      	adds	r4, r5, r4
 80239ee:	43ed      	mvns	r5, r5
 80239f0:	1962      	adds	r2, r4, r5
 80239f2:	42a3      	cmp	r3, r4
 80239f4:	f002 0501 	and.w	r5, r2, #1
 80239f8:	d00b      	beq.n	8023a12 <memset+0x122>
 80239fa:	b11d      	cbz	r5, 8023a04 <memset+0x114>
 80239fc:	f803 1b01 	strb.w	r1, [r3], #1
 8023a00:	42a3      	cmp	r3, r4
 8023a02:	d006      	beq.n	8023a12 <memset+0x122>
 8023a04:	461a      	mov	r2, r3
 8023a06:	f802 1b01 	strb.w	r1, [r2], #1
 8023a0a:	7059      	strb	r1, [r3, #1]
 8023a0c:	1c53      	adds	r3, r2, #1
 8023a0e:	42a3      	cmp	r3, r4
 8023a10:	d1f8      	bne.n	8023a04 <memset+0x114>
 8023a12:	bcf0      	pop	{r4, r5, r6, r7}
 8023a14:	4770      	bx	lr
 8023a16:	4605      	mov	r5, r0
 8023a18:	4614      	mov	r4, r2
 8023a1a:	e78d      	b.n	8023938 <memset+0x48>

08023a1c <validate_structure>:
 8023a1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023a20:	6801      	ldr	r1, [r0, #0]
 8023a22:	293b      	cmp	r1, #59	; 0x3b
 8023a24:	b082      	sub	sp, #8
 8023a26:	4604      	mov	r4, r0
 8023a28:	f200 80cf 	bhi.w	8023bca <validate_structure+0x1ae>
 8023a2c:	6841      	ldr	r1, [r0, #4]
 8023a2e:	293b      	cmp	r1, #59	; 0x3b
 8023a30:	f200 80bd 	bhi.w	8023bae <validate_structure+0x192>
 8023a34:	68a1      	ldr	r1, [r4, #8]
 8023a36:	2917      	cmp	r1, #23
 8023a38:	f200 80a7 	bhi.w	8023b8a <validate_structure+0x16e>
 8023a3c:	6925      	ldr	r5, [r4, #16]
 8023a3e:	2d0b      	cmp	r5, #11
 8023a40:	f300 8095 	bgt.w	8023b6e <validate_structure+0x152>
 8023a44:	6963      	ldr	r3, [r4, #20]
 8023a46:	079f      	lsls	r7, r3, #30
 8023a48:	d146      	bne.n	8023ad8 <validate_structure+0xbc>
 8023a4a:	f248 521f 	movw	r2, #34079	; 0x851f
 8023a4e:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
 8023a52:	fb82 1003 	smull	r1, r0, r2, r3
 8023a56:	17d9      	asrs	r1, r3, #31
 8023a58:	ebc1 1660 	rsb	r6, r1, r0, asr #5
 8023a5c:	2764      	movs	r7, #100	; 0x64
 8023a5e:	fb07 3016 	mls	r0, r7, r6, r3
 8023a62:	b360      	cbz	r0, 8023abe <validate_structure+0xa2>
 8023a64:	68e2      	ldr	r2, [r4, #12]
 8023a66:	261d      	movs	r6, #29
 8023a68:	2a00      	cmp	r2, #0
 8023a6a:	dc39      	bgt.n	8023ae0 <validate_structure+0xc4>
 8023a6c:	f248 571f 	movw	r7, #34079	; 0x851f
 8023a70:	486c      	ldr	r0, [pc, #432]	; (8023c24 <validate_structure+0x208>)
 8023a72:	4629      	mov	r1, r5
 8023a74:	f2c5 17eb 	movt	r7, #20971	; 0x51eb
 8023a78:	f04f 0c64 	mov.w	ip, #100	; 0x64
 8023a7c:	f44f 78c8 	mov.w	r8, #400	; 0x190
 8023a80:	e007      	b.n	8023a92 <validate_structure+0x76>
 8023a82:	2901      	cmp	r1, #1
 8023a84:	f000 80ae 	beq.w	8023be4 <validate_structure+0x1c8>
 8023a88:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 8023a8c:	18d2      	adds	r2, r2, r3
 8023a8e:	2a00      	cmp	r2, #0
 8023a90:	dc68      	bgt.n	8023b64 <validate_structure+0x148>
 8023a92:	f111 31ff 	adds.w	r1, r1, #4294967295
 8023a96:	d2f4      	bcs.n	8023a82 <validate_structure+0x66>
 8023a98:	6961      	ldr	r1, [r4, #20]
 8023a9a:	1e4b      	subs	r3, r1, #1
 8023a9c:	079e      	lsls	r6, r3, #30
 8023a9e:	6163      	str	r3, [r4, #20]
 8023aa0:	f040 80ae 	bne.w	8023c00 <validate_structure+0x1e4>
 8023aa4:	fb87 5603 	smull	r5, r6, r7, r3
 8023aa8:	17dd      	asrs	r5, r3, #31
 8023aaa:	ebc5 1566 	rsb	r5, r5, r6, asr #5
 8023aae:	fb0c 3315 	mls	r3, ip, r5, r3
 8023ab2:	2b00      	cmp	r3, #0
 8023ab4:	f000 8098 	beq.w	8023be8 <validate_structure+0x1cc>
 8023ab8:	261d      	movs	r6, #29
 8023aba:	210b      	movs	r1, #11
 8023abc:	e7e4      	b.n	8023a88 <validate_structure+0x6c>
 8023abe:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8023ac2:	fb82 0203 	smull	r0, r2, r2, r3
 8023ac6:	17d9      	asrs	r1, r3, #31
 8023ac8:	ebc1 16e2 	rsb	r6, r1, r2, asr #7
 8023acc:	f44f 77c8 	mov.w	r7, #400	; 0x190
 8023ad0:	fb07 3016 	mls	r0, r7, r6, r3
 8023ad4:	2800      	cmp	r0, #0
 8023ad6:	d0c5      	beq.n	8023a64 <validate_structure+0x48>
 8023ad8:	68e2      	ldr	r2, [r4, #12]
 8023ada:	261c      	movs	r6, #28
 8023adc:	2a00      	cmp	r2, #0
 8023ade:	ddc5      	ble.n	8023a6c <validate_structure+0x50>
 8023ae0:	f248 5c1f 	movw	ip, #34079	; 0x851f
 8023ae4:	4f4f      	ldr	r7, [pc, #316]	; (8023c24 <validate_structure+0x208>)
 8023ae6:	f04f 0800 	mov.w	r8, #0
 8023aea:	f2c5 1ceb 	movt	ip, #20971	; 0x51eb
 8023aee:	f04f 0964 	mov.w	r9, #100	; 0x64
 8023af2:	f44f 7ac8 	mov.w	sl, #400	; 0x190
 8023af6:	1c6b      	adds	r3, r5, #1
 8023af8:	2100      	movs	r1, #0
 8023afa:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8023afe:	e00a      	b.n	8023b16 <validate_structure+0xfa>
 8023b00:	5868      	ldr	r0, [r5, r1]
 8023b02:	4290      	cmp	r0, r2
 8023b04:	ebc0 0202 	rsb	r2, r0, r2
 8023b08:	da2e      	bge.n	8023b68 <validate_structure+0x14c>
 8023b0a:	2b0c      	cmp	r3, #12
 8023b0c:	6123      	str	r3, [r4, #16]
 8023b0e:	60e2      	str	r2, [r4, #12]
 8023b10:	d009      	beq.n	8023b26 <validate_structure+0x10a>
 8023b12:	3301      	adds	r3, #1
 8023b14:	3104      	adds	r1, #4
 8023b16:	2b02      	cmp	r3, #2
 8023b18:	d1f2      	bne.n	8023b00 <validate_structure+0xe4>
 8023b1a:	4296      	cmp	r6, r2
 8023b1c:	da24      	bge.n	8023b68 <validate_structure+0x14c>
 8023b1e:	1b92      	subs	r2, r2, r6
 8023b20:	60e2      	str	r2, [r4, #12]
 8023b22:	6123      	str	r3, [r4, #16]
 8023b24:	e7f5      	b.n	8023b12 <validate_structure+0xf6>
 8023b26:	6966      	ldr	r6, [r4, #20]
 8023b28:	f8c4 8010 	str.w	r8, [r4, #16]
 8023b2c:	1c71      	adds	r1, r6, #1
 8023b2e:	0788      	lsls	r0, r1, #30
 8023b30:	6161      	str	r1, [r4, #20]
 8023b32:	d114      	bne.n	8023b5e <validate_structure+0x142>
 8023b34:	fb8c 0501 	smull	r0, r5, ip, r1
 8023b38:	17cb      	asrs	r3, r1, #31
 8023b3a:	ebc3 1065 	rsb	r0, r3, r5, asr #5
 8023b3e:	fb09 1110 	mls	r1, r9, r0, r1
 8023b42:	b949      	cbnz	r1, 8023b58 <validate_structure+0x13c>
 8023b44:	f206 766d 	addw	r6, r6, #1901	; 0x76d
 8023b48:	fb8c 3506 	smull	r3, r5, ip, r6
 8023b4c:	17f3      	asrs	r3, r6, #31
 8023b4e:	ebc3 10e5 	rsb	r0, r3, r5, asr #7
 8023b52:	fb0a 6110 	mls	r1, sl, r0, r6
 8023b56:	b911      	cbnz	r1, 8023b5e <validate_structure+0x142>
 8023b58:	261d      	movs	r6, #29
 8023b5a:	2500      	movs	r5, #0
 8023b5c:	e7cb      	b.n	8023af6 <validate_structure+0xda>
 8023b5e:	261c      	movs	r6, #28
 8023b60:	2500      	movs	r5, #0
 8023b62:	e7c8      	b.n	8023af6 <validate_structure+0xda>
 8023b64:	6121      	str	r1, [r4, #16]
 8023b66:	60e2      	str	r2, [r4, #12]
 8023b68:	b002      	add	sp, #8
 8023b6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023b6e:	4629      	mov	r1, r5
 8023b70:	220c      	movs	r2, #12
 8023b72:	4668      	mov	r0, sp
 8023b74:	f001 fc28 	bl	80253c8 <div>
 8023b78:	e89d 0028 	ldmia.w	sp, {r3, r5}
 8023b7c:	6967      	ldr	r7, [r4, #20]
 8023b7e:	2d00      	cmp	r5, #0
 8023b80:	443b      	add	r3, r7
 8023b82:	6163      	str	r3, [r4, #20]
 8023b84:	db3f      	blt.n	8023c06 <validate_structure+0x1ea>
 8023b86:	6125      	str	r5, [r4, #16]
 8023b88:	e75d      	b.n	8023a46 <validate_structure+0x2a>
 8023b8a:	2218      	movs	r2, #24
 8023b8c:	4668      	mov	r0, sp
 8023b8e:	f001 fc1b 	bl	80253c8 <div>
 8023b92:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8023b96:	68e5      	ldr	r5, [r4, #12]
 8023b98:	60a3      	str	r3, [r4, #8]
 8023b9a:	18aa      	adds	r2, r5, r2
 8023b9c:	2b00      	cmp	r3, #0
 8023b9e:	60e2      	str	r2, [r4, #12]
 8023ba0:	f6bf af4c 	bge.w	8023a3c <validate_structure+0x20>
 8023ba4:	3318      	adds	r3, #24
 8023ba6:	1e56      	subs	r6, r2, #1
 8023ba8:	60a3      	str	r3, [r4, #8]
 8023baa:	60e6      	str	r6, [r4, #12]
 8023bac:	e746      	b.n	8023a3c <validate_structure+0x20>
 8023bae:	223c      	movs	r2, #60	; 0x3c
 8023bb0:	4668      	mov	r0, sp
 8023bb2:	f001 fc09 	bl	80253c8 <div>
 8023bb6:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8023bba:	68a0      	ldr	r0, [r4, #8]
 8023bbc:	2b00      	cmp	r3, #0
 8023bbe:	eb00 0102 	add.w	r1, r0, r2
 8023bc2:	60a1      	str	r1, [r4, #8]
 8023bc4:	db29      	blt.n	8023c1a <validate_structure+0x1fe>
 8023bc6:	6063      	str	r3, [r4, #4]
 8023bc8:	e735      	b.n	8023a36 <validate_structure+0x1a>
 8023bca:	223c      	movs	r2, #60	; 0x3c
 8023bcc:	4668      	mov	r0, sp
 8023bce:	f001 fbfb 	bl	80253c8 <div>
 8023bd2:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8023bd6:	6861      	ldr	r1, [r4, #4]
 8023bd8:	2b00      	cmp	r3, #0
 8023bda:	4411      	add	r1, r2
 8023bdc:	6061      	str	r1, [r4, #4]
 8023bde:	db17      	blt.n	8023c10 <validate_structure+0x1f4>
 8023be0:	6023      	str	r3, [r4, #0]
 8023be2:	e724      	b.n	8023a2e <validate_structure+0x12>
 8023be4:	4633      	mov	r3, r6
 8023be6:	e751      	b.n	8023a8c <validate_structure+0x70>
 8023be8:	f201 716b 	addw	r1, r1, #1899	; 0x76b
 8023bec:	fb87 3501 	smull	r3, r5, r7, r1
 8023bf0:	17ce      	asrs	r6, r1, #31
 8023bf2:	ebc6 13e5 	rsb	r3, r6, r5, asr #7
 8023bf6:	fb08 1113 	mls	r1, r8, r3, r1
 8023bfa:	2900      	cmp	r1, #0
 8023bfc:	f43f af5c 	beq.w	8023ab8 <validate_structure+0x9c>
 8023c00:	261c      	movs	r6, #28
 8023c02:	210b      	movs	r1, #11
 8023c04:	e740      	b.n	8023a88 <validate_structure+0x6c>
 8023c06:	350c      	adds	r5, #12
 8023c08:	3b01      	subs	r3, #1
 8023c0a:	6125      	str	r5, [r4, #16]
 8023c0c:	6163      	str	r3, [r4, #20]
 8023c0e:	e71a      	b.n	8023a46 <validate_structure+0x2a>
 8023c10:	333c      	adds	r3, #60	; 0x3c
 8023c12:	3901      	subs	r1, #1
 8023c14:	6023      	str	r3, [r4, #0]
 8023c16:	6061      	str	r1, [r4, #4]
 8023c18:	e709      	b.n	8023a2e <validate_structure+0x12>
 8023c1a:	333c      	adds	r3, #60	; 0x3c
 8023c1c:	3901      	subs	r1, #1
 8023c1e:	6063      	str	r3, [r4, #4]
 8023c20:	60a1      	str	r1, [r4, #8]
 8023c22:	e708      	b.n	8023a36 <validate_structure+0x1a>
 8023c24:	08026978 	.word	0x08026978

08023c28 <mktime>:
 8023c28:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023c2c:	4604      	mov	r4, r0
 8023c2e:	f001 fc17 	bl	8025460 <__gettzinfo>
 8023c32:	4606      	mov	r6, r0
 8023c34:	4620      	mov	r0, r4
 8023c36:	f7ff fef1 	bl	8023a1c <validate_structure>
 8023c3a:	6923      	ldr	r3, [r4, #16]
 8023c3c:	6861      	ldr	r1, [r4, #4]
 8023c3e:	4ac1      	ldr	r2, [pc, #772]	; (8023f44 <mktime+0x31c>)
 8023c40:	6827      	ldr	r7, [r4, #0]
 8023c42:	68e5      	ldr	r5, [r4, #12]
 8023c44:	68a0      	ldr	r0, [r4, #8]
 8023c46:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8023c4a:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
 8023c4e:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8023c52:	3d01      	subs	r5, #1
 8023c54:	f44f 6761 	mov.w	r7, #3600	; 0xe10
 8023c58:	2b01      	cmp	r3, #1
 8023c5a:	fb07 1700 	mla	r7, r7, r0, r1
 8023c5e:	442a      	add	r2, r5
 8023c60:	6961      	ldr	r1, [r4, #20]
 8023c62:	dd02      	ble.n	8023c6a <mktime+0x42>
 8023c64:	078b      	lsls	r3, r1, #30
 8023c66:	f000 80ed 	beq.w	8023e44 <mktime+0x21c>
 8023c6a:	f501 531c 	add.w	r3, r1, #9984	; 0x2700
 8023c6e:	3310      	adds	r3, #16
 8023c70:	f644 6020 	movw	r0, #20000	; 0x4e20
 8023c74:	4283      	cmp	r3, r0
 8023c76:	61e2      	str	r2, [r4, #28]
 8023c78:	f200 8187 	bhi.w	8023f8a <mktime+0x362>
 8023c7c:	2946      	cmp	r1, #70	; 0x46
 8023c7e:	f340 8088 	ble.w	8023d92 <mktime+0x16a>
 8023c82:	2347      	movs	r3, #71	; 0x47
 8023c84:	f248 5c1f 	movw	ip, #34079	; 0x851f
 8023c88:	f1a1 0547 	sub.w	r5, r1, #71	; 0x47
 8023c8c:	428b      	cmp	r3, r1
 8023c8e:	f2c5 1ceb 	movt	ip, #20971	; 0x51eb
 8023c92:	f04f 0864 	mov.w	r8, #100	; 0x64
 8023c96:	f44f 79c8 	mov.w	r9, #400	; 0x190
 8023c9a:	f005 0001 	and.w	r0, r5, #1
 8023c9e:	f202 126d 	addw	r2, r2, #365	; 0x16d
 8023ca2:	d044      	beq.n	8023d2e <mktime+0x106>
 8023ca4:	b3a8      	cbz	r0, 8023d12 <mktime+0xea>
 8023ca6:	3301      	adds	r3, #1
 8023ca8:	428b      	cmp	r3, r1
 8023caa:	f202 126d 	addw	r2, r2, #365	; 0x16d
 8023cae:	d130      	bne.n	8023d12 <mktime+0xea>
 8023cb0:	e03d      	b.n	8023d2e <mktime+0x106>
 8023cb2:	fb8c 0503 	smull	r0, r5, ip, r3
 8023cb6:	17d8      	asrs	r0, r3, #31
 8023cb8:	ebc0 1565 	rsb	r5, r0, r5, asr #5
 8023cbc:	fb08 3015 	mls	r0, r8, r5, r3
 8023cc0:	b948      	cbnz	r0, 8023cd6 <mktime+0xae>
 8023cc2:	f203 706c 	addw	r0, r3, #1900	; 0x76c
 8023cc6:	fb8c 5a00 	smull	r5, sl, ip, r0
 8023cca:	17c5      	asrs	r5, r0, #31
 8023ccc:	ebc5 15ea 	rsb	r5, r5, sl, asr #7
 8023cd0:	fb09 0015 	mls	r0, r9, r5, r0
 8023cd4:	b9f8      	cbnz	r0, 8023d16 <mktime+0xee>
 8023cd6:	f44f 70b7 	mov.w	r0, #366	; 0x16e
 8023cda:	1c5d      	adds	r5, r3, #1
 8023cdc:	1812      	adds	r2, r2, r0
 8023cde:	07a8      	lsls	r0, r5, #30
 8023ce0:	d11f      	bne.n	8023d22 <mktime+0xfa>
 8023ce2:	fb8c 0a05 	smull	r0, sl, ip, r5
 8023ce6:	17e8      	asrs	r0, r5, #31
 8023ce8:	ebc0 106a 	rsb	r0, r0, sl, asr #5
 8023cec:	fb08 5010 	mls	r0, r8, r0, r5
 8023cf0:	b948      	cbnz	r0, 8023d06 <mktime+0xde>
 8023cf2:	f203 736d 	addw	r3, r3, #1901	; 0x76d
 8023cf6:	fb8c 0a03 	smull	r0, sl, ip, r3
 8023cfa:	17d8      	asrs	r0, r3, #31
 8023cfc:	ebc0 10ea 	rsb	r0, r0, sl, asr #7
 8023d00:	fb09 3310 	mls	r3, r9, r0, r3
 8023d04:	b96b      	cbnz	r3, 8023d22 <mktime+0xfa>
 8023d06:	1c6b      	adds	r3, r5, #1
 8023d08:	f44f 70b7 	mov.w	r0, #366	; 0x16e
 8023d0c:	428b      	cmp	r3, r1
 8023d0e:	4402      	add	r2, r0
 8023d10:	d00d      	beq.n	8023d2e <mktime+0x106>
 8023d12:	079d      	lsls	r5, r3, #30
 8023d14:	d0cd      	beq.n	8023cb2 <mktime+0x8a>
 8023d16:	f240 106d 	movw	r0, #365	; 0x16d
 8023d1a:	1c5d      	adds	r5, r3, #1
 8023d1c:	1812      	adds	r2, r2, r0
 8023d1e:	07a8      	lsls	r0, r5, #30
 8023d20:	d0df      	beq.n	8023ce2 <mktime+0xba>
 8023d22:	1c6b      	adds	r3, r5, #1
 8023d24:	f240 106d 	movw	r0, #365	; 0x16d
 8023d28:	428b      	cmp	r3, r1
 8023d2a:	4402      	add	r2, r0
 8023d2c:	d1f1      	bne.n	8023d12 <mktime+0xea>
 8023d2e:	f242 4593 	movw	r5, #9363	; 0x2493
 8023d32:	1d13      	adds	r3, r2, #4
 8023d34:	f2c9 2549 	movt	r5, #37449	; 0x9249
 8023d38:	fb85 c003 	smull	ip, r0, r5, r3
 8023d3c:	18c0      	adds	r0, r0, r3
 8023d3e:	17dd      	asrs	r5, r3, #31
 8023d40:	ebc5 00a0 	rsb	r0, r5, r0, asr #2
 8023d44:	ebc0 05c0 	rsb	r5, r0, r0, lsl #3
 8023d48:	1b5b      	subs	r3, r3, r5
 8023d4a:	4d7f      	ldr	r5, [pc, #508]	; (8023f48 <mktime+0x320>)
 8023d4c:	6a20      	ldr	r0, [r4, #32]
 8023d4e:	682d      	ldr	r5, [r5, #0]
 8023d50:	bf48      	it	mi
 8023d52:	3307      	addmi	r3, #7
 8023d54:	61a3      	str	r3, [r4, #24]
 8023d56:	f44f 43a3 	mov.w	r3, #20864	; 0x5180
 8023d5a:	f2c0 0301 	movt	r3, #1
 8023d5e:	fb03 7702 	mla	r7, r3, r2, r7
 8023d62:	2801      	cmp	r0, #1
 8023d64:	bfb4      	ite	lt
 8023d66:	4680      	movlt	r8, r0
 8023d68:	f04f 0801 	movge.w	r8, #1
 8023d6c:	b145      	cbz	r5, 8023d80 <mktime+0x158>
 8023d6e:	6872      	ldr	r2, [r6, #4]
 8023d70:	f201 706c 	addw	r0, r1, #1900	; 0x76c
 8023d74:	4282      	cmp	r2, r0
 8023d76:	d075      	beq.n	8023e64 <mktime+0x23c>
 8023d78:	f000 f90c 	bl	8023f94 <__tzcalc_limits>
 8023d7c:	2800      	cmp	r0, #0
 8023d7e:	d171      	bne.n	8023e64 <mktime+0x23c>
 8023d80:	4645      	mov	r5, r8
 8023d82:	2d01      	cmp	r5, #1
 8023d84:	bf0c      	ite	eq
 8023d86:	6bf0      	ldreq	r0, [r6, #60]	; 0x3c
 8023d88:	6a30      	ldrne	r0, [r6, #32]
 8023d8a:	6225      	str	r5, [r4, #32]
 8023d8c:	1838      	adds	r0, r7, r0
 8023d8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023d92:	d0cc      	beq.n	8023d2e <mktime+0x106>
 8023d94:	2945      	cmp	r1, #69	; 0x45
 8023d96:	d051      	beq.n	8023e3c <mktime+0x214>
 8023d98:	f1a1 0545 	sub.w	r5, r1, #69	; 0x45
 8023d9c:	2344      	movs	r3, #68	; 0x44
 8023d9e:	43ed      	mvns	r5, r5
 8023da0:	f248 501f 	movw	r0, #34079	; 0x851f
 8023da4:	f46f 7cb6 	mvn.w	ip, #364	; 0x16c
 8023da8:	428b      	cmp	r3, r1
 8023daa:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 8023dae:	f04f 0864 	mov.w	r8, #100	; 0x64
 8023db2:	f44f 79c8 	mov.w	r9, #400	; 0x190
 8023db6:	f005 0501 	and.w	r5, r5, #1
 8023dba:	4462      	add	r2, ip
 8023dbc:	d01f      	beq.n	8023dfe <mktime+0x1d6>
 8023dbe:	2d00      	cmp	r5, #0
 8023dc0:	f000 80b3 	beq.w	8023f2a <mktime+0x302>
 8023dc4:	fb80 5e03 	smull	r5, lr, r0, r3
 8023dc8:	17dd      	asrs	r5, r3, #31
 8023dca:	ebc5 156e 	rsb	r5, r5, lr, asr #5
 8023dce:	fb08 3515 	mls	r5, r8, r5, r3
 8023dd2:	b965      	cbnz	r5, 8023dee <mktime+0x1c6>
 8023dd4:	f203 756c 	addw	r5, r3, #1900	; 0x76c
 8023dd8:	fb80 ca05 	smull	ip, sl, r0, r5
 8023ddc:	ea4f 7ce5 	mov.w	ip, r5, asr #31
 8023de0:	ebcc 1eea 	rsb	lr, ip, sl, asr #7
 8023de4:	fb09 551e 	mls	r5, r9, lr, r5
 8023de8:	2d00      	cmp	r5, #0
 8023dea:	f040 80cb 	bne.w	8023f84 <mktime+0x35c>
 8023dee:	f44f 75b7 	mov.w	r5, #366	; 0x16e
 8023df2:	3b01      	subs	r3, #1
 8023df4:	428b      	cmp	r3, r1
 8023df6:	ebc5 0202 	rsb	r2, r5, r2
 8023dfa:	f040 8096 	bne.w	8023f2a <mktime+0x302>
 8023dfe:	078b      	lsls	r3, r1, #30
 8023e00:	d11c      	bne.n	8023e3c <mktime+0x214>
 8023e02:	f248 531f 	movw	r3, #34079	; 0x851f
 8023e06:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8023e0a:	fb83 0501 	smull	r0, r5, r3, r1
 8023e0e:	17c8      	asrs	r0, r1, #31
 8023e10:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 8023e14:	2564      	movs	r5, #100	; 0x64
 8023e16:	fb05 1010 	mls	r0, r5, r0, r1
 8023e1a:	2800      	cmp	r0, #0
 8023e1c:	f040 80aa 	bne.w	8023f74 <mktime+0x34c>
 8023e20:	f201 706c 	addw	r0, r1, #1900	; 0x76c
 8023e24:	fb83 5300 	smull	r5, r3, r3, r0
 8023e28:	17c5      	asrs	r5, r0, #31
 8023e2a:	ebc5 13e3 	rsb	r3, r5, r3, asr #7
 8023e2e:	f44f 75c8 	mov.w	r5, #400	; 0x190
 8023e32:	fb05 0013 	mls	r0, r5, r3, r0
 8023e36:	2800      	cmp	r0, #0
 8023e38:	f000 809c 	beq.w	8023f74 <mktime+0x34c>
 8023e3c:	f240 136d 	movw	r3, #365	; 0x16d
 8023e40:	1ad2      	subs	r2, r2, r3
 8023e42:	e774      	b.n	8023d2e <mktime+0x106>
 8023e44:	f248 531f 	movw	r3, #34079	; 0x851f
 8023e48:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8023e4c:	fb83 c501 	smull	ip, r5, r3, r1
 8023e50:	17c8      	asrs	r0, r1, #31
 8023e52:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 8023e56:	2564      	movs	r5, #100	; 0x64
 8023e58:	fb05 1010 	mls	r0, r5, r0, r1
 8023e5c:	2800      	cmp	r0, #0
 8023e5e:	d075      	beq.n	8023f4c <mktime+0x324>
 8023e60:	3201      	adds	r2, #1
 8023e62:	e702      	b.n	8023c6a <mktime+0x42>
 8023e64:	6bb2      	ldr	r2, [r6, #56]	; 0x38
 8023e66:	6a30      	ldr	r0, [r6, #32]
 8023e68:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8023e6a:	69f1      	ldr	r1, [r6, #28]
 8023e6c:	1a15      	subs	r5, r2, r0
 8023e6e:	42af      	cmp	r7, r5
 8023e70:	ebc3 0101 	rsb	r1, r3, r1
 8023e74:	db02      	blt.n	8023e7c <mktime+0x254>
 8023e76:	1ad2      	subs	r2, r2, r3
 8023e78:	4297      	cmp	r7, r2
 8023e7a:	db81      	blt.n	8023d80 <mktime+0x158>
 8023e7c:	6832      	ldr	r2, [r6, #0]
 8023e7e:	2a00      	cmp	r2, #0
 8023e80:	d074      	beq.n	8023f6c <mktime+0x344>
 8023e82:	428f      	cmp	r7, r1
 8023e84:	da79      	bge.n	8023f7a <mktime+0x352>
 8023e86:	2500      	movs	r5, #0
 8023e88:	f1b8 0f00 	cmp.w	r8, #0
 8023e8c:	f6ff af79 	blt.w	8023d82 <mktime+0x15a>
 8023e90:	ea85 0808 	eor.w	r8, r5, r8
 8023e94:	f1b8 0f01 	cmp.w	r8, #1
 8023e98:	f47f af73 	bne.w	8023d82 <mktime+0x15a>
 8023e9c:	ebc3 0800 	rsb	r8, r3, r0
 8023ea0:	b90d      	cbnz	r5, 8023ea6 <mktime+0x27e>
 8023ea2:	f1c8 0800 	rsb	r8, r8, #0
 8023ea6:	6820      	ldr	r0, [r4, #0]
 8023ea8:	eb00 0308 	add.w	r3, r0, r8
 8023eac:	6023      	str	r3, [r4, #0]
 8023eae:	4620      	mov	r0, r4
 8023eb0:	f7ff fdb4 	bl	8023a1c <validate_structure>
 8023eb4:	4447      	add	r7, r8
 8023eb6:	e764      	b.n	8023d82 <mktime+0x15a>
 8023eb8:	fb80 5c03 	smull	r5, ip, r0, r3
 8023ebc:	17dd      	asrs	r5, r3, #31
 8023ebe:	ebc5 156c 	rsb	r5, r5, ip, asr #5
 8023ec2:	fb08 3515 	mls	r5, r8, r5, r3
 8023ec6:	b955      	cbnz	r5, 8023ede <mktime+0x2b6>
 8023ec8:	f203 756c 	addw	r5, r3, #1900	; 0x76c
 8023ecc:	fb80 ca05 	smull	ip, sl, r0, r5
 8023ed0:	ea4f 7ee5 	mov.w	lr, r5, asr #31
 8023ed4:	ebce 1cea 	rsb	ip, lr, sl, asr #7
 8023ed8:	fb09 551c 	mls	r5, r9, ip, r5
 8023edc:	bb3d      	cbnz	r5, 8023f2e <mktime+0x306>
 8023ede:	1e5d      	subs	r5, r3, #1
 8023ee0:	f44f 7eb7 	mov.w	lr, #366	; 0x16e
 8023ee4:	f015 0f03 	tst.w	r5, #3
 8023ee8:	ebce 0202 	rsb	r2, lr, r2
 8023eec:	d127      	bne.n	8023f3e <mktime+0x316>
 8023eee:	fb80 ca05 	smull	ip, sl, r0, r5
 8023ef2:	ea4f 7ce5 	mov.w	ip, r5, asr #31
 8023ef6:	ebcc 1e6a 	rsb	lr, ip, sl, asr #5
 8023efa:	fb08 5c1e 	mls	ip, r8, lr, r5
 8023efe:	f1bc 0f00 	cmp.w	ip, #0
 8023f02:	d10a      	bne.n	8023f1a <mktime+0x2f2>
 8023f04:	f203 736b 	addw	r3, r3, #1899	; 0x76b
 8023f08:	fb80 ca03 	smull	ip, sl, r0, r3
 8023f0c:	ea4f 7ee3 	mov.w	lr, r3, asr #31
 8023f10:	ebce 1cea 	rsb	ip, lr, sl, asr #7
 8023f14:	fb09 331c 	mls	r3, r9, ip, r3
 8023f18:	b98b      	cbnz	r3, 8023f3e <mktime+0x316>
 8023f1a:	f44f 7eb7 	mov.w	lr, #366	; 0x16e
 8023f1e:	1e6b      	subs	r3, r5, #1
 8023f20:	428b      	cmp	r3, r1
 8023f22:	ebce 0202 	rsb	r2, lr, r2
 8023f26:	f43f af6a 	beq.w	8023dfe <mktime+0x1d6>
 8023f2a:	079d      	lsls	r5, r3, #30
 8023f2c:	d0c4      	beq.n	8023eb8 <mktime+0x290>
 8023f2e:	1e5d      	subs	r5, r3, #1
 8023f30:	f240 1e6d 	movw	lr, #365	; 0x16d
 8023f34:	f015 0f03 	tst.w	r5, #3
 8023f38:	ebce 0202 	rsb	r2, lr, r2
 8023f3c:	d0d7      	beq.n	8023eee <mktime+0x2c6>
 8023f3e:	f240 1e6d 	movw	lr, #365	; 0x16d
 8023f42:	e7ec      	b.n	8023f1e <mktime+0x2f6>
 8023f44:	08026948 	.word	0x08026948
 8023f48:	20005bb0 	.word	0x20005bb0
 8023f4c:	f201 706c 	addw	r0, r1, #1900	; 0x76c
 8023f50:	fb83 5300 	smull	r5, r3, r3, r0
 8023f54:	17c5      	asrs	r5, r0, #31
 8023f56:	ebc5 13e3 	rsb	r3, r5, r3, asr #7
 8023f5a:	f44f 75c8 	mov.w	r5, #400	; 0x190
 8023f5e:	fb05 0013 	mls	r0, r5, r3, r0
 8023f62:	2800      	cmp	r0, #0
 8023f64:	f47f ae81 	bne.w	8023c6a <mktime+0x42>
 8023f68:	3201      	adds	r2, #1
 8023f6a:	e67e      	b.n	8023c6a <mktime+0x42>
 8023f6c:	428f      	cmp	r7, r1
 8023f6e:	db04      	blt.n	8023f7a <mktime+0x352>
 8023f70:	2501      	movs	r5, #1
 8023f72:	e789      	b.n	8023e88 <mktime+0x260>
 8023f74:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 8023f78:	e762      	b.n	8023e40 <mktime+0x218>
 8023f7a:	42af      	cmp	r7, r5
 8023f7c:	bfac      	ite	ge
 8023f7e:	2500      	movge	r5, #0
 8023f80:	2501      	movlt	r5, #1
 8023f82:	e781      	b.n	8023e88 <mktime+0x260>
 8023f84:	f240 156d 	movw	r5, #365	; 0x16d
 8023f88:	e733      	b.n	8023df2 <mktime+0x1ca>
 8023f8a:	f04f 30ff 	mov.w	r0, #4294967295
 8023f8e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8023f92:	bf00      	nop

08023f94 <__tzcalc_limits>:
 8023f94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023f98:	b085      	sub	sp, #20
 8023f9a:	4604      	mov	r4, r0
 8023f9c:	f001 fa60 	bl	8025460 <__gettzinfo>
 8023fa0:	f240 73b1 	movw	r3, #1969	; 0x7b1
 8023fa4:	429c      	cmp	r4, r3
 8023fa6:	f340 80b4 	ble.w	8024112 <__tzcalc_limits+0x17e>
 8023faa:	f46f 62f6 	mvn.w	r2, #1968	; 0x7b0
 8023fae:	f248 531f 	movw	r3, #34079	; 0x851f
 8023fb2:	eb04 0c02 	add.w	ip, r4, r2
 8023fb6:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8023fba:	f2a4 766d 	subw	r6, r4, #1901	; 0x76d
 8023fbe:	f46f 61c8 	mvn.w	r1, #1600	; 0x640
 8023fc2:	fb83 8706 	smull	r8, r7, r3, r6
 8023fc6:	1865      	adds	r5, r4, r1
 8023fc8:	f2a4 79b2 	subw	r9, r4, #1970	; 0x7b2
 8023fcc:	fb83 2104 	smull	r2, r1, r3, r4
 8023fd0:	ea4f 0eac 	mov.w	lr, ip, asr #2
 8023fd4:	17e2      	asrs	r2, r4, #31
 8023fd6:	17f6      	asrs	r6, r6, #31
 8023fd8:	f240 186d 	movw	r8, #365	; 0x16d
 8023fdc:	fb08 ec09 	mla	ip, r8, r9, lr
 8023fe0:	eba6 1667 	sub.w	r6, r6, r7, asr #5
 8023fe4:	fb83 7305 	smull	r7, r3, r3, r5
 8023fe8:	ebc2 17e1 	rsb	r7, r2, r1, asr #7
 8023fec:	17ed      	asrs	r5, r5, #31
 8023fee:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 8023ff2:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8023ff6:	fb02 4917 	mls	r9, r2, r7, r4
 8023ffa:	eb0c 0e06 	add.w	lr, ip, r6
 8023ffe:	ebc5 16e3 	rsb	r6, r5, r3, asr #7
 8024002:	eb0e 0806 	add.w	r8, lr, r6
 8024006:	2364      	movs	r3, #100	; 0x64
 8024008:	f1d9 0601 	rsbs	r6, r9, #1
 802400c:	fb03 4511 	mls	r5, r3, r1, r4
 8024010:	bf38      	it	cc
 8024012:	2600      	movcc	r6, #0
 8024014:	f242 4c93 	movw	ip, #9363	; 0x2493
 8024018:	f44f 47a3 	mov.w	r7, #20864	; 0x5180
 802401c:	6044      	str	r4, [r0, #4]
 802401e:	f004 0403 	and.w	r4, r4, #3
 8024022:	9601      	str	r6, [sp, #4]
 8024024:	9503      	str	r5, [sp, #12]
 8024026:	4602      	mov	r2, r0
 8024028:	2600      	movs	r6, #0
 802402a:	9402      	str	r4, [sp, #8]
 802402c:	f2c9 2c49 	movt	ip, #37449	; 0x9249
 8024030:	f2c0 0701 	movt	r7, #1
 8024034:	7a11      	ldrb	r1, [r2, #8]
 8024036:	294a      	cmp	r1, #74	; 0x4a
 8024038:	d06d      	beq.n	8024116 <__tzcalc_limits+0x182>
 802403a:	2944      	cmp	r1, #68	; 0x44
 802403c:	d07d      	beq.n	802413a <__tzcalc_limits+0x1a6>
 802403e:	9d02      	ldr	r5, [sp, #8]
 8024040:	9b01      	ldr	r3, [sp, #4]
 8024042:	2d00      	cmp	r5, #0
 8024044:	d060      	beq.n	8024108 <__tzcalc_limits+0x174>
 8024046:	0059      	lsls	r1, r3, #1
 8024048:	f8d2 a00c 	ldr.w	sl, [r2, #12]
 802404c:	18cd      	adds	r5, r1, r3
 802404e:	f646 14a8 	movw	r4, #27048	; 0x69a8
 8024052:	012b      	lsls	r3, r5, #4
 8024054:	f6c0 0402 	movt	r4, #2050	; 0x802
 8024058:	f1ba 0f01 	cmp.w	sl, #1
 802405c:	eb04 0503 	add.w	r5, r4, r3
 8024060:	dd6f      	ble.n	8024142 <__tzcalc_limits+0x1ae>
 8024062:	f1a5 0908 	sub.w	r9, r5, #8
 8024066:	58e1      	ldr	r1, [r4, r3]
 8024068:	eb09 0e8a 	add.w	lr, r9, sl, lsl #2
 802406c:	ebc5 030e 	rsb	r3, r5, lr
 8024070:	4575      	cmp	r5, lr
 8024072:	f3c3 0480 	ubfx	r4, r3, #2, #1
 8024076:	4441      	add	r1, r8
 8024078:	462b      	mov	r3, r5
 802407a:	d00f      	beq.n	802409c <__tzcalc_limits+0x108>
 802407c:	b124      	cbz	r4, 8024088 <__tzcalc_limits+0xf4>
 802407e:	686c      	ldr	r4, [r5, #4]
 8024080:	1d2b      	adds	r3, r5, #4
 8024082:	4573      	cmp	r3, lr
 8024084:	4421      	add	r1, r4
 8024086:	d009      	beq.n	802409c <__tzcalc_limits+0x108>
 8024088:	4693      	mov	fp, r2
 802408a:	1d1c      	adds	r4, r3, #4
 802408c:	685b      	ldr	r3, [r3, #4]
 802408e:	6862      	ldr	r2, [r4, #4]
 8024090:	18c9      	adds	r1, r1, r3
 8024092:	1d23      	adds	r3, r4, #4
 8024094:	4573      	cmp	r3, lr
 8024096:	4411      	add	r1, r2
 8024098:	d1f7      	bne.n	802408a <__tzcalc_limits+0xf6>
 802409a:	465a      	mov	r2, fp
 802409c:	f10a 39ff 	add.w	r9, sl, #4294967295
 80240a0:	ea4f 0a89 	mov.w	sl, r9, lsl #2
 80240a4:	1d0c      	adds	r4, r1, #4
 80240a6:	fb8c 3e04 	smull	r3, lr, ip, r4
 80240aa:	eb0e 0904 	add.w	r9, lr, r4
 80240ae:	17e3      	asrs	r3, r4, #31
 80240b0:	ebc3 0ea9 	rsb	lr, r3, r9, asr #2
 80240b4:	ebce 09ce 	rsb	r9, lr, lr, lsl #3
 80240b8:	6953      	ldr	r3, [r2, #20]
 80240ba:	f855 500a 	ldr.w	r5, [r5, sl]
 80240be:	ebc9 0404 	rsb	r4, r9, r4
 80240c2:	1b1b      	subs	r3, r3, r4
 80240c4:	6914      	ldr	r4, [r2, #16]
 80240c6:	bf48      	it	mi
 80240c8:	3307      	addmi	r3, #7
 80240ca:	3c01      	subs	r4, #1
 80240cc:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 80240d0:	18e3      	adds	r3, r4, r3
 80240d2:	42ab      	cmp	r3, r5
 80240d4:	db02      	blt.n	80240dc <__tzcalc_limits+0x148>
 80240d6:	3b07      	subs	r3, #7
 80240d8:	42ab      	cmp	r3, r5
 80240da:	dafc      	bge.n	80240d6 <__tzcalc_limits+0x142>
 80240dc:	18c9      	adds	r1, r1, r3
 80240de:	6995      	ldr	r5, [r2, #24]
 80240e0:	6a13      	ldr	r3, [r2, #32]
 80240e2:	fb07 5501 	mla	r5, r7, r1, r5
 80240e6:	3601      	adds	r6, #1
 80240e8:	18ec      	adds	r4, r5, r3
 80240ea:	2e02      	cmp	r6, #2
 80240ec:	f842 4f1c 	str.w	r4, [r2, #28]!
 80240f0:	d1a0      	bne.n	8024034 <__tzcalc_limits+0xa0>
 80240f2:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80240f4:	69c2      	ldr	r2, [r0, #28]
 80240f6:	428a      	cmp	r2, r1
 80240f8:	bfac      	ite	ge
 80240fa:	2100      	movge	r1, #0
 80240fc:	2101      	movlt	r1, #1
 80240fe:	6001      	str	r1, [r0, #0]
 8024100:	2001      	movs	r0, #1
 8024102:	b005      	add	sp, #20
 8024104:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024108:	9c03      	ldr	r4, [sp, #12]
 802410a:	2c00      	cmp	r4, #0
 802410c:	bf18      	it	ne
 802410e:	2301      	movne	r3, #1
 8024110:	e799      	b.n	8024046 <__tzcalc_limits+0xb2>
 8024112:	2000      	movs	r0, #0
 8024114:	e7f5      	b.n	8024102 <__tzcalc_limits+0x16e>
 8024116:	6954      	ldr	r4, [r2, #20]
 8024118:	9b02      	ldr	r3, [sp, #8]
 802411a:	eb04 0108 	add.w	r1, r4, r8
 802411e:	b93b      	cbnz	r3, 8024130 <__tzcalc_limits+0x19c>
 8024120:	9d03      	ldr	r5, [sp, #12]
 8024122:	b12d      	cbz	r5, 8024130 <__tzcalc_limits+0x19c>
 8024124:	2c3b      	cmp	r4, #59	; 0x3b
 8024126:	bfd4      	ite	le
 8024128:	2400      	movle	r4, #0
 802412a:	2401      	movgt	r4, #1
 802412c:	1909      	adds	r1, r1, r4
 802412e:	e7d6      	b.n	80240de <__tzcalc_limits+0x14a>
 8024130:	9b01      	ldr	r3, [sp, #4]
 8024132:	2b00      	cmp	r3, #0
 8024134:	d1f6      	bne.n	8024124 <__tzcalc_limits+0x190>
 8024136:	9c01      	ldr	r4, [sp, #4]
 8024138:	e7f8      	b.n	802412c <__tzcalc_limits+0x198>
 802413a:	6955      	ldr	r5, [r2, #20]
 802413c:	eb08 0105 	add.w	r1, r8, r5
 8024140:	e7cd      	b.n	80240de <__tzcalc_limits+0x14a>
 8024142:	4641      	mov	r1, r8
 8024144:	f04f 0a00 	mov.w	sl, #0
 8024148:	e7ac      	b.n	80240a4 <__tzcalc_limits+0x110>
 802414a:	bf00      	nop

0802414c <_mktm_r>:
 802414c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024150:	4681      	mov	r9, r0
 8024152:	460f      	mov	r7, r1
 8024154:	4690      	mov	r8, r2
 8024156:	f001 f983 	bl	8025460 <__gettzinfo>
 802415a:	f8d9 2000 	ldr.w	r2, [r9]
 802415e:	f244 5307 	movw	r3, #17671	; 0x4507
 8024162:	f2cc 232e 	movt	r3, #49710	; 0xc22e
 8024166:	4682      	mov	sl, r0
 8024168:	fb83 0102 	smull	r0, r1, r3, r2
 802416c:	188c      	adds	r4, r1, r2
 802416e:	17d0      	asrs	r0, r2, #31
 8024170:	f44f 45a3 	mov.w	r5, #20864	; 0x5180
 8024174:	ebc0 4324 	rsb	r3, r0, r4, asr #16
 8024178:	f2c0 0501 	movt	r5, #1
 802417c:	fb05 2213 	mls	r2, r5, r3, r2
 8024180:	2a00      	cmp	r2, #0
 8024182:	da04      	bge.n	802418e <_mktm_r+0x42>
 8024184:	f502 36a8 	add.w	r6, r2, #86016	; 0x15000
 8024188:	f506 72c0 	add.w	r2, r6, #384	; 0x180
 802418c:	3b01      	subs	r3, #1
 802418e:	f24b 31c5 	movw	r1, #46021	; 0xb3c5
 8024192:	f2c9 11a2 	movt	r1, #37282	; 0x91a2
 8024196:	fb81 1402 	smull	r1, r4, r1, r2
 802419a:	18a0      	adds	r0, r4, r2
 802419c:	17d5      	asrs	r5, r2, #31
 802419e:	ebc5 25e0 	rsb	r5, r5, r0, asr #11
 80241a2:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80241a6:	f648 0689 	movw	r6, #34953	; 0x8889
 80241aa:	fb01 2215 	mls	r2, r1, r5, r2
 80241ae:	f6c8 0688 	movt	r6, #34952	; 0x8888
 80241b2:	f242 4493 	movw	r4, #9363	; 0x2493
 80241b6:	1d19      	adds	r1, r3, #4
 80241b8:	fb86 6002 	smull	r6, r0, r6, r2
 80241bc:	f2c9 2449 	movt	r4, #37449	; 0x9249
 80241c0:	17d6      	asrs	r6, r2, #31
 80241c2:	1880      	adds	r0, r0, r2
 80241c4:	fb84 b401 	smull	fp, r4, r4, r1
 80241c8:	ebc6 1060 	rsb	r0, r6, r0, asr #5
 80241cc:	1864      	adds	r4, r4, r1
 80241ce:	ea4f 7ce1 	mov.w	ip, r1, asr #31
 80241d2:	ebc0 1600 	rsb	r6, r0, r0, lsl #4
 80241d6:	ebcc 04a4 	rsb	r4, ip, r4, asr #2
 80241da:	eba2 0286 	sub.w	r2, r2, r6, lsl #2
 80241de:	ebc4 06c4 	rsb	r6, r4, r4, lsl #3
 80241e2:	60bd      	str	r5, [r7, #8]
 80241e4:	1b8d      	subs	r5, r1, r6
 80241e6:	bf48      	it	mi
 80241e8:	3507      	addmi	r5, #7
 80241ea:	6078      	str	r0, [r7, #4]
 80241ec:	2b00      	cmp	r3, #0
 80241ee:	f248 501f 	movw	r0, #34079	; 0x851f
 80241f2:	61bd      	str	r5, [r7, #24]
 80241f4:	603a      	str	r2, [r7, #0]
 80241f6:	4daa      	ldr	r5, [pc, #680]	; (80244a0 <_mktm_r+0x354>)
 80241f8:	f240 74b2 	movw	r4, #1970	; 0x7b2
 80241fc:	f2c5 10eb 	movt	r0, #20971	; 0x51eb
 8024200:	f44f 76c8 	mov.w	r6, #400	; 0x190
 8024204:	f04f 0e64 	mov.w	lr, #100	; 0x64
 8024208:	da0c      	bge.n	8024224 <_mktm_r+0xd8>
 802420a:	e050      	b.n	80242ae <_mktm_r+0x162>
 802420c:	ebc1 1262 	rsb	r2, r1, r2, asr #5
 8024210:	fb0e 4212 	mls	r2, lr, r2, r4
 8024214:	b16a      	cbz	r2, 8024232 <_mktm_r+0xe6>
 8024216:	2201      	movs	r2, #1
 8024218:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
 802421c:	428b      	cmp	r3, r1
 802421e:	db16      	blt.n	802424e <_mktm_r+0x102>
 8024220:	3401      	adds	r4, #1
 8024222:	1a5b      	subs	r3, r3, r1
 8024224:	f014 0f03 	tst.w	r4, #3
 8024228:	ea4f 71e4 	mov.w	r1, r4, asr #31
 802422c:	fb80 b204 	smull	fp, r2, r0, r4
 8024230:	d0ec      	beq.n	802420c <_mktm_r+0xc0>
 8024232:	fb80 b204 	smull	fp, r2, r0, r4
 8024236:	ebc1 11e2 	rsb	r1, r1, r2, asr #7
 802423a:	fb06 4211 	mls	r2, r6, r1, r4
 802423e:	f1d2 0201 	rsbs	r2, r2, #1
 8024242:	bf38      	it	cc
 8024244:	2200      	movcc	r2, #0
 8024246:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
 802424a:	428b      	cmp	r3, r1
 802424c:	dae8      	bge.n	8024220 <_mktm_r+0xd4>
 802424e:	0050      	lsls	r0, r2, #1
 8024250:	1885      	adds	r5, r0, r2
 8024252:	012a      	lsls	r2, r5, #4
 8024254:	4993      	ldr	r1, [pc, #588]	; (80244a4 <_mktm_r+0x358>)
 8024256:	61fb      	str	r3, [r7, #28]
 8024258:	2500      	movs	r5, #0
 802425a:	f2a4 706c 	subw	r0, r4, #1900	; 0x76c
 802425e:	6178      	str	r0, [r7, #20]
 8024260:	613d      	str	r5, [r7, #16]
 8024262:	588d      	ldr	r5, [r1, r2]
 8024264:	42ab      	cmp	r3, r5
 8024266:	eb01 0b02 	add.w	fp, r1, r2
 802426a:	db08      	blt.n	802427e <_mktm_r+0x132>
 802426c:	4659      	mov	r1, fp
 802426e:	2601      	movs	r6, #1
 8024270:	613e      	str	r6, [r7, #16]
 8024272:	1b5b      	subs	r3, r3, r5
 8024274:	f851 5f04 	ldr.w	r5, [r1, #4]!
 8024278:	3601      	adds	r6, #1
 802427a:	429d      	cmp	r5, r3
 802427c:	ddf8      	ble.n	8024270 <_mktm_r+0x124>
 802427e:	1c5a      	adds	r2, r3, #1
 8024280:	60fa      	str	r2, [r7, #12]
 8024282:	f1b8 0f00 	cmp.w	r8, #0
 8024286:	d022      	beq.n	80242ce <_mktm_r+0x182>
 8024288:	2000      	movs	r0, #0
 802428a:	6238      	str	r0, [r7, #32]
 802428c:	4638      	mov	r0, r7
 802428e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024292:	fb80 b104 	smull	fp, r1, r0, r4
 8024296:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 802429a:	fb06 4112 	mls	r1, r6, r2, r4
 802429e:	f1d1 0201 	rsbs	r2, r1, #1
 80242a2:	bf38      	it	cc
 80242a4:	2200      	movcc	r2, #0
 80242a6:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
 80242aa:	185b      	adds	r3, r3, r1
 80242ac:	d5cf      	bpl.n	802424e <_mktm_r+0x102>
 80242ae:	3c01      	subs	r4, #1
 80242b0:	f014 0f03 	tst.w	r4, #3
 80242b4:	ea4f 72e4 	mov.w	r2, r4, asr #31
 80242b8:	fb80 b104 	smull	fp, r1, r0, r4
 80242bc:	d1e9      	bne.n	8024292 <_mktm_r+0x146>
 80242be:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 80242c2:	fb0e 4111 	mls	r1, lr, r1, r4
 80242c6:	2900      	cmp	r1, #0
 80242c8:	d0e3      	beq.n	8024292 <_mktm_r+0x146>
 80242ca:	2201      	movs	r2, #1
 80242cc:	e7eb      	b.n	80242a6 <_mktm_r+0x15a>
 80242ce:	4e76      	ldr	r6, [pc, #472]	; (80244a8 <_mktm_r+0x35c>)
 80242d0:	f001 f864 	bl	802539c <__tz_lock>
 80242d4:	6835      	ldr	r5, [r6, #0]
 80242d6:	2d00      	cmp	r5, #0
 80242d8:	d159      	bne.n	802438e <_mktm_r+0x242>
 80242da:	f8c7 8020 	str.w	r8, [r7, #32]
 80242de:	f8da 2020 	ldr.w	r2, [sl, #32]
 80242e2:	f24b 36c5 	movw	r6, #46021	; 0xb3c5
 80242e6:	f2c9 16a2 	movt	r6, #37282	; 0x91a2
 80242ea:	fb86 c502 	smull	ip, r5, r6, r2
 80242ee:	17d1      	asrs	r1, r2, #31
 80242f0:	18ac      	adds	r4, r5, r2
 80242f2:	ebc1 23e4 	rsb	r3, r1, r4, asr #11
 80242f6:	f44f 6661 	mov.w	r6, #3600	; 0xe10
 80242fa:	f648 0089 	movw	r0, #34953	; 0x8889
 80242fe:	fb06 2113 	mls	r1, r6, r3, r2
 8024302:	f6c8 0088 	movt	r0, #34952	; 0x8888
 8024306:	fb80 2501 	smull	r2, r5, r0, r1
 802430a:	186c      	adds	r4, r5, r1
 802430c:	17ca      	asrs	r2, r1, #31
 802430e:	ebc2 1264 	rsb	r2, r2, r4, asr #5
 8024312:	683d      	ldr	r5, [r7, #0]
 8024314:	687c      	ldr	r4, [r7, #4]
 8024316:	68b8      	ldr	r0, [r7, #8]
 8024318:	ebc2 1602 	rsb	r6, r2, r2, lsl #4
 802431c:	eba1 0186 	sub.w	r1, r1, r6, lsl #2
 8024320:	1a69      	subs	r1, r5, r1
 8024322:	1aa2      	subs	r2, r4, r2
 8024324:	1ac3      	subs	r3, r0, r3
 8024326:	293b      	cmp	r1, #59	; 0x3b
 8024328:	e887 000e 	stmia.w	r7, {r1, r2, r3}
 802432c:	dd52      	ble.n	80243d4 <_mktm_r+0x288>
 802432e:	3201      	adds	r2, #1
 8024330:	393c      	subs	r1, #60	; 0x3c
 8024332:	e887 0006 	stmia.w	r7, {r1, r2}
 8024336:	2a3b      	cmp	r2, #59	; 0x3b
 8024338:	dd45      	ble.n	80243c6 <_mktm_r+0x27a>
 802433a:	3301      	adds	r3, #1
 802433c:	3a3c      	subs	r2, #60	; 0x3c
 802433e:	60bb      	str	r3, [r7, #8]
 8024340:	607a      	str	r2, [r7, #4]
 8024342:	2b17      	cmp	r3, #23
 8024344:	dd4d      	ble.n	80243e2 <_mktm_r+0x296>
 8024346:	69f8      	ldr	r0, [r7, #28]
 8024348:	69ba      	ldr	r2, [r7, #24]
 802434a:	1c41      	adds	r1, r0, #1
 802434c:	1c50      	adds	r0, r2, #1
 802434e:	2806      	cmp	r0, #6
 8024350:	68fa      	ldr	r2, [r7, #12]
 8024352:	61f9      	str	r1, [r7, #28]
 8024354:	bfc8      	it	gt
 8024356:	2000      	movgt	r0, #0
 8024358:	61b8      	str	r0, [r7, #24]
 802435a:	3b18      	subs	r3, #24
 802435c:	1c50      	adds	r0, r2, #1
 802435e:	6939      	ldr	r1, [r7, #16]
 8024360:	60f8      	str	r0, [r7, #12]
 8024362:	60bb      	str	r3, [r7, #8]
 8024364:	f85b 3021 	ldr.w	r3, [fp, r1, lsl #2]
 8024368:	4298      	cmp	r0, r3
 802436a:	dd0b      	ble.n	8024384 <_mktm_r+0x238>
 802436c:	3101      	adds	r1, #1
 802436e:	1ac2      	subs	r2, r0, r3
 8024370:	290c      	cmp	r1, #12
 8024372:	60fa      	str	r2, [r7, #12]
 8024374:	6139      	str	r1, [r7, #16]
 8024376:	d105      	bne.n	8024384 <_mktm_r+0x238>
 8024378:	6978      	ldr	r0, [r7, #20]
 802437a:	2300      	movs	r3, #0
 802437c:	1c42      	adds	r2, r0, #1
 802437e:	613b      	str	r3, [r7, #16]
 8024380:	617a      	str	r2, [r7, #20]
 8024382:	61fb      	str	r3, [r7, #28]
 8024384:	f001 f80c 	bl	80253a0 <__tz_unlock>
 8024388:	4638      	mov	r0, r7
 802438a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802438e:	f8da 1004 	ldr.w	r1, [sl, #4]
 8024392:	42a1      	cmp	r1, r4
 8024394:	d004      	beq.n	80243a0 <_mktm_r+0x254>
 8024396:	4620      	mov	r0, r4
 8024398:	f7ff fdfc 	bl	8023f94 <__tzcalc_limits>
 802439c:	2800      	cmp	r0, #0
 802439e:	d04a      	beq.n	8024436 <_mktm_r+0x2ea>
 80243a0:	f8da 3000 	ldr.w	r3, [sl]
 80243a4:	2b00      	cmp	r3, #0
 80243a6:	d036      	beq.n	8024416 <_mktm_r+0x2ca>
 80243a8:	f8d9 5000 	ldr.w	r5, [r9]
 80243ac:	f8da 101c 	ldr.w	r1, [sl, #28]
 80243b0:	428d      	cmp	r5, r1
 80243b2:	db44      	blt.n	802443e <_mktm_r+0x2f2>
 80243b4:	f8da 4038 	ldr.w	r4, [sl, #56]	; 0x38
 80243b8:	42a5      	cmp	r5, r4
 80243ba:	da40      	bge.n	802443e <_mktm_r+0x2f2>
 80243bc:	2001      	movs	r0, #1
 80243be:	6238      	str	r0, [r7, #32]
 80243c0:	f8da 203c 	ldr.w	r2, [sl, #60]	; 0x3c
 80243c4:	e78d      	b.n	80242e2 <_mktm_r+0x196>
 80243c6:	2a00      	cmp	r2, #0
 80243c8:	dabb      	bge.n	8024342 <_mktm_r+0x1f6>
 80243ca:	3b01      	subs	r3, #1
 80243cc:	323c      	adds	r2, #60	; 0x3c
 80243ce:	60bb      	str	r3, [r7, #8]
 80243d0:	607a      	str	r2, [r7, #4]
 80243d2:	e7b6      	b.n	8024342 <_mktm_r+0x1f6>
 80243d4:	2900      	cmp	r1, #0
 80243d6:	daae      	bge.n	8024336 <_mktm_r+0x1ea>
 80243d8:	3a01      	subs	r2, #1
 80243da:	313c      	adds	r1, #60	; 0x3c
 80243dc:	e887 0006 	stmia.w	r7, {r1, r2}
 80243e0:	e7a9      	b.n	8024336 <_mktm_r+0x1ea>
 80243e2:	2b00      	cmp	r3, #0
 80243e4:	dace      	bge.n	8024384 <_mktm_r+0x238>
 80243e6:	69f8      	ldr	r0, [r7, #28]
 80243e8:	69ba      	ldr	r2, [r7, #24]
 80243ea:	1e41      	subs	r1, r0, #1
 80243ec:	1e50      	subs	r0, r2, #1
 80243ee:	68fa      	ldr	r2, [r7, #12]
 80243f0:	61f9      	str	r1, [r7, #28]
 80243f2:	bf48      	it	mi
 80243f4:	2006      	movmi	r0, #6
 80243f6:	3318      	adds	r3, #24
 80243f8:	1e51      	subs	r1, r2, #1
 80243fa:	61b8      	str	r0, [r7, #24]
 80243fc:	60f9      	str	r1, [r7, #12]
 80243fe:	60bb      	str	r3, [r7, #8]
 8024400:	2900      	cmp	r1, #0
 8024402:	d1bf      	bne.n	8024384 <_mktm_r+0x238>
 8024404:	693b      	ldr	r3, [r7, #16]
 8024406:	1e58      	subs	r0, r3, #1
 8024408:	d41c      	bmi.n	8024444 <_mktm_r+0x2f8>
 802440a:	6138      	str	r0, [r7, #16]
 802440c:	0081      	lsls	r1, r0, #2
 802440e:	f85b 3001 	ldr.w	r3, [fp, r1]
 8024412:	60fb      	str	r3, [r7, #12]
 8024414:	e7b6      	b.n	8024384 <_mktm_r+0x238>
 8024416:	f8d9 0000 	ldr.w	r0, [r9]
 802441a:	f8da 201c 	ldr.w	r2, [sl, #28]
 802441e:	4290      	cmp	r0, r2
 8024420:	dacc      	bge.n	80243bc <_mktm_r+0x270>
 8024422:	f8da 6038 	ldr.w	r6, [sl, #56]	; 0x38
 8024426:	42b0      	cmp	r0, r6
 8024428:	bfac      	ite	ge
 802442a:	2000      	movge	r0, #0
 802442c:	2001      	movlt	r0, #1
 802442e:	6238      	str	r0, [r7, #32]
 8024430:	2800      	cmp	r0, #0
 8024432:	d1c5      	bne.n	80243c0 <_mktm_r+0x274>
 8024434:	e753      	b.n	80242de <_mktm_r+0x192>
 8024436:	f04f 34ff 	mov.w	r4, #4294967295
 802443a:	623c      	str	r4, [r7, #32]
 802443c:	e74f      	b.n	80242de <_mktm_r+0x192>
 802443e:	2300      	movs	r3, #0
 8024440:	623b      	str	r3, [r7, #32]
 8024442:	e74c      	b.n	80242de <_mktm_r+0x192>
 8024444:	697a      	ldr	r2, [r7, #20]
 8024446:	1e53      	subs	r3, r2, #1
 8024448:	210b      	movs	r1, #11
 802444a:	0798      	lsls	r0, r3, #30
 802444c:	6139      	str	r1, [r7, #16]
 802444e:	617b      	str	r3, [r7, #20]
 8024450:	d015      	beq.n	802447e <_mktm_r+0x332>
 8024452:	17da      	asrs	r2, r3, #31
 8024454:	f248 511f 	movw	r1, #34079	; 0x851f
 8024458:	f2c5 11eb 	movt	r1, #20971	; 0x51eb
 802445c:	fb81 c003 	smull	ip, r0, r1, r3
 8024460:	ebc2 12e0 	rsb	r2, r2, r0, asr #7
 8024464:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8024468:	fb01 3312 	mls	r3, r1, r2, r3
 802446c:	f1d3 0001 	rsbs	r0, r3, #1
 8024470:	bf38      	it	cc
 8024472:	2000      	movcc	r0, #0
 8024474:	f200 126d 	addw	r2, r0, #365	; 0x16d
 8024478:	61fa      	str	r2, [r7, #28]
 802447a:	212c      	movs	r1, #44	; 0x2c
 802447c:	e7c7      	b.n	802440e <_mktm_r+0x2c2>
 802447e:	f248 561f 	movw	r6, #34079	; 0x851f
 8024482:	f2c5 16eb 	movt	r6, #20971	; 0x51eb
 8024486:	fb86 6003 	smull	r6, r0, r6, r3
 802448a:	17da      	asrs	r2, r3, #31
 802448c:	ebc2 1160 	rsb	r1, r2, r0, asr #5
 8024490:	2664      	movs	r6, #100	; 0x64
 8024492:	fb06 3011 	mls	r0, r6, r1, r3
 8024496:	2800      	cmp	r0, #0
 8024498:	d0dc      	beq.n	8024454 <_mktm_r+0x308>
 802449a:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 802449e:	e7eb      	b.n	8024478 <_mktm_r+0x32c>
 80244a0:	08026a08 	.word	0x08026a08
 80244a4:	080269a8 	.word	0x080269a8
 80244a8:	20005bb0 	.word	0x20005bb0

080244ac <_open_r>:
 80244ac:	b538      	push	{r3, r4, r5, lr}
 80244ae:	4c08      	ldr	r4, [pc, #32]	; (80244d0 <_open_r+0x24>)
 80244b0:	4605      	mov	r5, r0
 80244b2:	4608      	mov	r0, r1
 80244b4:	4611      	mov	r1, r2
 80244b6:	461a      	mov	r2, r3
 80244b8:	2300      	movs	r3, #0
 80244ba:	6023      	str	r3, [r4, #0]
 80244bc:	f7e0 fb24 	bl	8004b08 <_open>
 80244c0:	1c43      	adds	r3, r0, #1
 80244c2:	d000      	beq.n	80244c6 <_open_r+0x1a>
 80244c4:	bd38      	pop	{r3, r4, r5, pc}
 80244c6:	6821      	ldr	r1, [r4, #0]
 80244c8:	2900      	cmp	r1, #0
 80244ca:	d0fb      	beq.n	80244c4 <_open_r+0x18>
 80244cc:	6029      	str	r1, [r5, #0]
 80244ce:	bd38      	pop	{r3, r4, r5, pc}
 80244d0:	2000664c 	.word	0x2000664c

080244d4 <cleanup_glue>:
 80244d4:	b538      	push	{r3, r4, r5, lr}
 80244d6:	460c      	mov	r4, r1
 80244d8:	6809      	ldr	r1, [r1, #0]
 80244da:	4605      	mov	r5, r0
 80244dc:	b109      	cbz	r1, 80244e2 <cleanup_glue+0xe>
 80244de:	f7ff fff9 	bl	80244d4 <cleanup_glue>
 80244e2:	4628      	mov	r0, r5
 80244e4:	4621      	mov	r1, r4
 80244e6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80244ea:	f7e0 b909 	b.w	8004700 <_free_r>
 80244ee:	bf00      	nop

080244f0 <_reclaim_reent>:
 80244f0:	4b21      	ldr	r3, [pc, #132]	; (8024578 <_reclaim_reent+0x88>)
 80244f2:	6819      	ldr	r1, [r3, #0]
 80244f4:	4288      	cmp	r0, r1
 80244f6:	b570      	push	{r4, r5, r6, lr}
 80244f8:	4605      	mov	r5, r0
 80244fa:	d030      	beq.n	802455e <_reclaim_reent+0x6e>
 80244fc:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 80244fe:	b1a2      	cbz	r2, 802452a <_reclaim_reent+0x3a>
 8024500:	2000      	movs	r0, #0
 8024502:	4606      	mov	r6, r0
 8024504:	f852 1020 	ldr.w	r1, [r2, r0, lsl #2]
 8024508:	b139      	cbz	r1, 802451a <_reclaim_reent+0x2a>
 802450a:	680c      	ldr	r4, [r1, #0]
 802450c:	4628      	mov	r0, r5
 802450e:	f7e0 f8f7 	bl	8004700 <_free_r>
 8024512:	4621      	mov	r1, r4
 8024514:	2c00      	cmp	r4, #0
 8024516:	d1f8      	bne.n	802450a <_reclaim_reent+0x1a>
 8024518:	6cea      	ldr	r2, [r5, #76]	; 0x4c
 802451a:	3601      	adds	r6, #1
 802451c:	2e20      	cmp	r6, #32
 802451e:	4630      	mov	r0, r6
 8024520:	d1f0      	bne.n	8024504 <_reclaim_reent+0x14>
 8024522:	4628      	mov	r0, r5
 8024524:	4611      	mov	r1, r2
 8024526:	f7e0 f8eb 	bl	8004700 <_free_r>
 802452a:	6c29      	ldr	r1, [r5, #64]	; 0x40
 802452c:	b111      	cbz	r1, 8024534 <_reclaim_reent+0x44>
 802452e:	4628      	mov	r0, r5
 8024530:	f7e0 f8e6 	bl	8004700 <_free_r>
 8024534:	f8d5 1148 	ldr.w	r1, [r5, #328]	; 0x148
 8024538:	b151      	cbz	r1, 8024550 <_reclaim_reent+0x60>
 802453a:	f505 76a6 	add.w	r6, r5, #332	; 0x14c
 802453e:	42b1      	cmp	r1, r6
 8024540:	d006      	beq.n	8024550 <_reclaim_reent+0x60>
 8024542:	680c      	ldr	r4, [r1, #0]
 8024544:	4628      	mov	r0, r5
 8024546:	f7e0 f8db 	bl	8004700 <_free_r>
 802454a:	42a6      	cmp	r6, r4
 802454c:	4621      	mov	r1, r4
 802454e:	d1f8      	bne.n	8024542 <_reclaim_reent+0x52>
 8024550:	6d69      	ldr	r1, [r5, #84]	; 0x54
 8024552:	b111      	cbz	r1, 802455a <_reclaim_reent+0x6a>
 8024554:	4628      	mov	r0, r5
 8024556:	f7e0 f8d3 	bl	8004700 <_free_r>
 802455a:	6bab      	ldr	r3, [r5, #56]	; 0x38
 802455c:	b903      	cbnz	r3, 8024560 <_reclaim_reent+0x70>
 802455e:	bd70      	pop	{r4, r5, r6, pc}
 8024560:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 8024562:	4628      	mov	r0, r5
 8024564:	4788      	blx	r1
 8024566:	f8d5 12e0 	ldr.w	r1, [r5, #736]	; 0x2e0
 802456a:	2900      	cmp	r1, #0
 802456c:	d0f7      	beq.n	802455e <_reclaim_reent+0x6e>
 802456e:	4628      	mov	r0, r5
 8024570:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8024574:	f7ff bfae 	b.w	80244d4 <cleanup_glue>
 8024578:	20006b80 	.word	0x20006b80

0802457c <_wrapup_reent>:
 802457c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8024580:	4680      	mov	r8, r0
 8024582:	2800      	cmp	r0, #0
 8024584:	d02e      	beq.n	80245e4 <_wrapup_reent+0x68>
 8024586:	f8d8 7148 	ldr.w	r7, [r8, #328]	; 0x148
 802458a:	b317      	cbz	r7, 80245d2 <_wrapup_reent+0x56>
 802458c:	687c      	ldr	r4, [r7, #4]
 802458e:	1e65      	subs	r5, r4, #1
 8024590:	d41c      	bmi.n	80245cc <_wrapup_reent+0x50>
 8024592:	3402      	adds	r4, #2
 8024594:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 8024598:	f005 0901 	and.w	r9, r5, #1
 802459c:	f854 0d04 	ldr.w	r0, [r4, #-4]!
 80245a0:	4780      	blx	r0
 80245a2:	1e6e      	subs	r6, r5, #1
 80245a4:	b195      	cbz	r5, 80245cc <_wrapup_reent+0x50>
 80245a6:	f1b9 0f00 	cmp.w	r9, #0
 80245aa:	d005      	beq.n	80245b8 <_wrapup_reent+0x3c>
 80245ac:	f854 1d04 	ldr.w	r1, [r4, #-4]!
 80245b0:	3e01      	subs	r6, #1
 80245b2:	4788      	blx	r1
 80245b4:	1c73      	adds	r3, r6, #1
 80245b6:	d009      	beq.n	80245cc <_wrapup_reent+0x50>
 80245b8:	f854 2d04 	ldr.w	r2, [r4, #-4]!
 80245bc:	4790      	blx	r2
 80245be:	1e75      	subs	r5, r6, #1
 80245c0:	f854 3d04 	ldr.w	r3, [r4, #-4]!
 80245c4:	4798      	blx	r3
 80245c6:	3e02      	subs	r6, #2
 80245c8:	2d00      	cmp	r5, #0
 80245ca:	d1f5      	bne.n	80245b8 <_wrapup_reent+0x3c>
 80245cc:	683f      	ldr	r7, [r7, #0]
 80245ce:	2f00      	cmp	r7, #0
 80245d0:	d1dc      	bne.n	802458c <_wrapup_reent+0x10>
 80245d2:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
 80245d6:	b119      	cbz	r1, 80245e0 <_wrapup_reent+0x64>
 80245d8:	4640      	mov	r0, r8
 80245da:	4788      	blx	r1
 80245dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80245e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80245e4:	4b01      	ldr	r3, [pc, #4]	; (80245ec <_wrapup_reent+0x70>)
 80245e6:	f8d3 8000 	ldr.w	r8, [r3]
 80245ea:	e7cc      	b.n	8024586 <_wrapup_reent+0xa>
 80245ec:	20006b80 	.word	0x20006b80

080245f0 <lflush>:
 80245f0:	8983      	ldrh	r3, [r0, #12]
 80245f2:	f003 0109 	and.w	r1, r3, #9
 80245f6:	2909      	cmp	r1, #9
 80245f8:	d001      	beq.n	80245fe <lflush+0xe>
 80245fa:	2000      	movs	r0, #0
 80245fc:	4770      	bx	lr
 80245fe:	f7fe bab3 	b.w	8022b68 <fflush>
 8024602:	bf00      	nop

08024604 <__srefill_r>:
 8024604:	b570      	push	{r4, r5, r6, lr}
 8024606:	460c      	mov	r4, r1
 8024608:	4605      	mov	r5, r0
 802460a:	b110      	cbz	r0, 8024612 <__srefill_r+0xe>
 802460c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 802460e:	2b00      	cmp	r3, #0
 8024610:	d04d      	beq.n	80246ae <__srefill_r+0xaa>
 8024612:	89a3      	ldrh	r3, [r4, #12]
 8024614:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 8024618:	b210      	sxth	r0, r2
 802461a:	b930      	cbnz	r0, 802462a <__srefill_r+0x26>
 802461c:	6e61      	ldr	r1, [r4, #100]	; 0x64
 802461e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8024622:	f421 5200 	bic.w	r2, r1, #8192	; 0x2000
 8024626:	81a3      	strh	r3, [r4, #12]
 8024628:	6662      	str	r2, [r4, #100]	; 0x64
 802462a:	f003 0020 	and.w	r0, r3, #32
 802462e:	b202      	sxth	r2, r0
 8024630:	2100      	movs	r1, #0
 8024632:	6061      	str	r1, [r4, #4]
 8024634:	4618      	mov	r0, r3
 8024636:	2a00      	cmp	r2, #0
 8024638:	d136      	bne.n	80246a8 <__srefill_r+0xa4>
 802463a:	f003 0204 	and.w	r2, r3, #4
 802463e:	b211      	sxth	r1, r2
 8024640:	b301      	cbz	r1, 8024684 <__srefill_r+0x80>
 8024642:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8024644:	b161      	cbz	r1, 8024660 <__srefill_r+0x5c>
 8024646:	f104 0340 	add.w	r3, r4, #64	; 0x40
 802464a:	4299      	cmp	r1, r3
 802464c:	d002      	beq.n	8024654 <__srefill_r+0x50>
 802464e:	4628      	mov	r0, r5
 8024650:	f7e0 f856 	bl	8004700 <_free_r>
 8024654:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8024656:	2000      	movs	r0, #0
 8024658:	6320      	str	r0, [r4, #48]	; 0x30
 802465a:	6062      	str	r2, [r4, #4]
 802465c:	2a00      	cmp	r2, #0
 802465e:	d137      	bne.n	80246d0 <__srefill_r+0xcc>
 8024660:	6922      	ldr	r2, [r4, #16]
 8024662:	2a00      	cmp	r2, #0
 8024664:	d045      	beq.n	80246f2 <__srefill_r+0xee>
 8024666:	89a6      	ldrh	r6, [r4, #12]
 8024668:	07b3      	lsls	r3, r6, #30
 802466a:	d123      	bne.n	80246b4 <__srefill_r+0xb0>
 802466c:	6922      	ldr	r2, [r4, #16]
 802466e:	6a26      	ldr	r6, [r4, #32]
 8024670:	6022      	str	r2, [r4, #0]
 8024672:	4628      	mov	r0, r5
 8024674:	69e1      	ldr	r1, [r4, #28]
 8024676:	6963      	ldr	r3, [r4, #20]
 8024678:	47b0      	blx	r6
 802467a:	2800      	cmp	r0, #0
 802467c:	6060      	str	r0, [r4, #4]
 802467e:	dd0e      	ble.n	802469e <__srefill_r+0x9a>
 8024680:	2000      	movs	r0, #0
 8024682:	bd70      	pop	{r4, r5, r6, pc}
 8024684:	f000 0210 	and.w	r2, r0, #16
 8024688:	b211      	sxth	r1, r2
 802468a:	2900      	cmp	r1, #0
 802468c:	d036      	beq.n	80246fc <__srefill_r+0xf8>
 802468e:	f000 0008 	and.w	r0, r0, #8
 8024692:	b202      	sxth	r2, r0
 8024694:	b9fa      	cbnz	r2, 80246d6 <__srefill_r+0xd2>
 8024696:	f043 0004 	orr.w	r0, r3, #4
 802469a:	81a0      	strh	r0, [r4, #12]
 802469c:	e7e0      	b.n	8024660 <__srefill_r+0x5c>
 802469e:	89a1      	ldrh	r1, [r4, #12]
 80246a0:	d10e      	bne.n	80246c0 <__srefill_r+0xbc>
 80246a2:	f041 0320 	orr.w	r3, r1, #32
 80246a6:	81a3      	strh	r3, [r4, #12]
 80246a8:	f04f 30ff 	mov.w	r0, #4294967295
 80246ac:	bd70      	pop	{r4, r5, r6, pc}
 80246ae:	f7fe fabd 	bl	8022c2c <__sinit>
 80246b2:	e7ae      	b.n	8024612 <__srefill_r+0xe>
 80246b4:	4b15      	ldr	r3, [pc, #84]	; (802470c <__srefill_r+0x108>)
 80246b6:	4916      	ldr	r1, [pc, #88]	; (8024710 <__srefill_r+0x10c>)
 80246b8:	6818      	ldr	r0, [r3, #0]
 80246ba:	f7fe fe21 	bl	8023300 <_fwalk>
 80246be:	e7d5      	b.n	802466c <__srefill_r+0x68>
 80246c0:	f041 0040 	orr.w	r0, r1, #64	; 0x40
 80246c4:	2200      	movs	r2, #0
 80246c6:	81a0      	strh	r0, [r4, #12]
 80246c8:	6062      	str	r2, [r4, #4]
 80246ca:	f04f 30ff 	mov.w	r0, #4294967295
 80246ce:	bd70      	pop	{r4, r5, r6, pc}
 80246d0:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80246d2:	6021      	str	r1, [r4, #0]
 80246d4:	bd70      	pop	{r4, r5, r6, pc}
 80246d6:	4628      	mov	r0, r5
 80246d8:	4621      	mov	r1, r4
 80246da:	f7fe f991 	bl	8022a00 <_fflush_r>
 80246de:	2800      	cmp	r0, #0
 80246e0:	d1e2      	bne.n	80246a8 <__srefill_r+0xa4>
 80246e2:	89a6      	ldrh	r6, [r4, #12]
 80246e4:	60a0      	str	r0, [r4, #8]
 80246e6:	f026 0308 	bic.w	r3, r6, #8
 80246ea:	0419      	lsls	r1, r3, #16
 80246ec:	0c0b      	lsrs	r3, r1, #16
 80246ee:	61a0      	str	r0, [r4, #24]
 80246f0:	e7d1      	b.n	8024696 <__srefill_r+0x92>
 80246f2:	4628      	mov	r0, r5
 80246f4:	4621      	mov	r1, r4
 80246f6:	f7fe ff09 	bl	802350c <__smakebuf_r>
 80246fa:	e7b4      	b.n	8024666 <__srefill_r+0x62>
 80246fc:	f040 0140 	orr.w	r1, r0, #64	; 0x40
 8024700:	2009      	movs	r0, #9
 8024702:	6028      	str	r0, [r5, #0]
 8024704:	f04f 30ff 	mov.w	r0, #4294967295
 8024708:	81a1      	strh	r1, [r4, #12]
 802470a:	bd70      	pop	{r4, r5, r6, pc}
 802470c:	08026944 	.word	0x08026944
 8024710:	080245f1 	.word	0x080245f1

08024714 <__sread>:
 8024714:	b510      	push	{r4, lr}
 8024716:	460c      	mov	r4, r1
 8024718:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802471c:	f7e0 fc5a 	bl	8004fd4 <_read_r>
 8024720:	2800      	cmp	r0, #0
 8024722:	db03      	blt.n	802472c <__sread+0x18>
 8024724:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8024726:	1813      	adds	r3, r2, r0
 8024728:	6523      	str	r3, [r4, #80]	; 0x50
 802472a:	bd10      	pop	{r4, pc}
 802472c:	89a3      	ldrh	r3, [r4, #12]
 802472e:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 8024732:	81a1      	strh	r1, [r4, #12]
 8024734:	bd10      	pop	{r4, pc}
 8024736:	bf00      	nop

08024738 <__seofread>:
 8024738:	2000      	movs	r0, #0
 802473a:	4770      	bx	lr

0802473c <__swrite>:
 802473c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8024740:	460c      	mov	r4, r1
 8024742:	8989      	ldrh	r1, [r1, #12]
 8024744:	f401 7c80 	and.w	ip, r1, #256	; 0x100
 8024748:	fa0f fc8c 	sxth.w	ip, ip
 802474c:	4607      	mov	r7, r0
 802474e:	4616      	mov	r6, r2
 8024750:	461d      	mov	r5, r3
 8024752:	f1bc 0f00 	cmp.w	ip, #0
 8024756:	d006      	beq.n	8024766 <__swrite+0x2a>
 8024758:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802475c:	2200      	movs	r2, #0
 802475e:	2302      	movs	r3, #2
 8024760:	f000 fe96 	bl	8025490 <_lseek_r>
 8024764:	89a1      	ldrh	r1, [r4, #12]
 8024766:	f421 5080 	bic.w	r0, r1, #4096	; 0x1000
 802476a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802476e:	81a0      	strh	r0, [r4, #12]
 8024770:	4632      	mov	r2, r6
 8024772:	4638      	mov	r0, r7
 8024774:	462b      	mov	r3, r5
 8024776:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802477a:	f7e0 bcdd 	b.w	8005138 <_write_r>
 802477e:	bf00      	nop

08024780 <__sseek>:
 8024780:	b510      	push	{r4, lr}
 8024782:	460c      	mov	r4, r1
 8024784:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8024788:	f000 fe82 	bl	8025490 <_lseek_r>
 802478c:	1c42      	adds	r2, r0, #1
 802478e:	89a3      	ldrh	r3, [r4, #12]
 8024790:	d004      	beq.n	802479c <__sseek+0x1c>
 8024792:	f443 5180 	orr.w	r1, r3, #4096	; 0x1000
 8024796:	6520      	str	r0, [r4, #80]	; 0x50
 8024798:	81a1      	strh	r1, [r4, #12]
 802479a:	bd10      	pop	{r4, pc}
 802479c:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 80247a0:	81a2      	strh	r2, [r4, #12]
 80247a2:	bd10      	pop	{r4, pc}

080247a4 <__sclose>:
 80247a4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80247a8:	f000 bdfc 	b.w	80253a4 <_close_r>

080247ac <strchr>:
 80247ac:	b2c9      	uxtb	r1, r1
 80247ae:	b4f0      	push	{r4, r5, r6, r7}
 80247b0:	2900      	cmp	r1, #0
 80247b2:	d04b      	beq.n	802484c <strchr+0xa0>
 80247b4:	0782      	lsls	r2, r0, #30
 80247b6:	d00f      	beq.n	80247d8 <strchr+0x2c>
 80247b8:	7802      	ldrb	r2, [r0, #0]
 80247ba:	2a00      	cmp	r2, #0
 80247bc:	d071      	beq.n	80248a2 <strchr+0xf6>
 80247be:	4291      	cmp	r1, r2
 80247c0:	d042      	beq.n	8024848 <strchr+0x9c>
 80247c2:	1c43      	adds	r3, r0, #1
 80247c4:	e005      	b.n	80247d2 <strchr+0x26>
 80247c6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80247ca:	2a00      	cmp	r2, #0
 80247cc:	d03b      	beq.n	8024846 <strchr+0x9a>
 80247ce:	4291      	cmp	r1, r2
 80247d0:	d03a      	beq.n	8024848 <strchr+0x9c>
 80247d2:	079a      	lsls	r2, r3, #30
 80247d4:	4618      	mov	r0, r3
 80247d6:	d1f6      	bne.n	80247c6 <strchr+0x1a>
 80247d8:	6803      	ldr	r3, [r0, #0]
 80247da:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80247de:	ea22 0203 	bic.w	r2, r2, r3
 80247e2:	ea41 2701 	orr.w	r7, r1, r1, lsl #8
 80247e6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80247ea:	ea47 4707 	orr.w	r7, r7, r7, lsl #16
 80247ee:	d11c      	bne.n	802482a <strchr+0x7e>
 80247f0:	407b      	eors	r3, r7
 80247f2:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80247f6:	ea22 0303 	bic.w	r3, r2, r3
 80247fa:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80247fe:	d114      	bne.n	802482a <strchr+0x7e>
 8024800:	1d02      	adds	r2, r0, #4
 8024802:	e002      	b.n	802480a <strchr+0x5e>
 8024804:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8024808:	d10f      	bne.n	802482a <strchr+0x7e>
 802480a:	4610      	mov	r0, r2
 802480c:	f852 3b04 	ldr.w	r3, [r2], #4
 8024810:	f1a3 3601 	sub.w	r6, r3, #16843009	; 0x1010101
 8024814:	ea87 0403 	eor.w	r4, r7, r3
 8024818:	ea26 0303 	bic.w	r3, r6, r3
 802481c:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8024820:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8024824:	ea25 0404 	bic.w	r4, r5, r4
 8024828:	d0ec      	beq.n	8024804 <strchr+0x58>
 802482a:	7802      	ldrb	r2, [r0, #0]
 802482c:	2a00      	cmp	r2, #0
 802482e:	d038      	beq.n	80248a2 <strchr+0xf6>
 8024830:	4291      	cmp	r1, r2
 8024832:	d009      	beq.n	8024848 <strchr+0x9c>
 8024834:	1c43      	adds	r3, r0, #1
 8024836:	e001      	b.n	802483c <strchr+0x90>
 8024838:	4291      	cmp	r1, r2
 802483a:	d005      	beq.n	8024848 <strchr+0x9c>
 802483c:	4618      	mov	r0, r3
 802483e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8024842:	2a00      	cmp	r2, #0
 8024844:	d1f8      	bne.n	8024838 <strchr+0x8c>
 8024846:	4610      	mov	r0, r2
 8024848:	bcf0      	pop	{r4, r5, r6, r7}
 802484a:	4770      	bx	lr
 802484c:	0783      	lsls	r3, r0, #30
 802484e:	d00b      	beq.n	8024868 <strchr+0xbc>
 8024850:	7802      	ldrb	r2, [r0, #0]
 8024852:	2a00      	cmp	r2, #0
 8024854:	d0f8      	beq.n	8024848 <strchr+0x9c>
 8024856:	1c43      	adds	r3, r0, #1
 8024858:	e003      	b.n	8024862 <strchr+0xb6>
 802485a:	7801      	ldrb	r1, [r0, #0]
 802485c:	3301      	adds	r3, #1
 802485e:	2900      	cmp	r1, #0
 8024860:	d0f2      	beq.n	8024848 <strchr+0x9c>
 8024862:	0799      	lsls	r1, r3, #30
 8024864:	4618      	mov	r0, r3
 8024866:	d1f8      	bne.n	802485a <strchr+0xae>
 8024868:	6801      	ldr	r1, [r0, #0]
 802486a:	f1a1 3301 	sub.w	r3, r1, #16843009	; 0x1010101
 802486e:	ea23 0201 	bic.w	r2, r3, r1
 8024872:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8024876:	d10a      	bne.n	802488e <strchr+0xe2>
 8024878:	1d03      	adds	r3, r0, #4
 802487a:	4618      	mov	r0, r3
 802487c:	f853 1b04 	ldr.w	r1, [r3], #4
 8024880:	f1a1 3401 	sub.w	r4, r1, #16843009	; 0x1010101
 8024884:	ea24 0201 	bic.w	r2, r4, r1
 8024888:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 802488c:	d0f5      	beq.n	802487a <strchr+0xce>
 802488e:	7803      	ldrb	r3, [r0, #0]
 8024890:	2b00      	cmp	r3, #0
 8024892:	d0d9      	beq.n	8024848 <strchr+0x9c>
 8024894:	1c41      	adds	r1, r0, #1
 8024896:	4608      	mov	r0, r1
 8024898:	3101      	adds	r1, #1
 802489a:	7802      	ldrb	r2, [r0, #0]
 802489c:	2a00      	cmp	r2, #0
 802489e:	d1fa      	bne.n	8024896 <strchr+0xea>
 80248a0:	e7d2      	b.n	8024848 <strchr+0x9c>
 80248a2:	4610      	mov	r0, r2
 80248a4:	e7d0      	b.n	8024848 <strchr+0x9c>
 80248a6:	bf00      	nop

080248a8 <strcmp>:
 80248a8:	ea80 0201 	eor.w	r2, r0, r1
 80248ac:	f012 0f03 	tst.w	r2, #3
 80248b0:	f040 803a 	bne.w	8024928 <strcmp_unaligned>
 80248b4:	f010 0203 	ands.w	r2, r0, #3
 80248b8:	f020 0003 	bic.w	r0, r0, #3
 80248bc:	f021 0103 	bic.w	r1, r1, #3
 80248c0:	f850 cb04 	ldr.w	ip, [r0], #4
 80248c4:	bf08      	it	eq
 80248c6:	f851 3b04 	ldreq.w	r3, [r1], #4
 80248ca:	d00d      	beq.n	80248e8 <strcmp+0x40>
 80248cc:	f082 0203 	eor.w	r2, r2, #3
 80248d0:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80248d4:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 80248d8:	fa23 f202 	lsr.w	r2, r3, r2
 80248dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80248e0:	ea4c 0c02 	orr.w	ip, ip, r2
 80248e4:	ea43 0302 	orr.w	r3, r3, r2
 80248e8:	f1ac 3201 	sub.w	r2, ip, #16843009	; 0x1010101
 80248ec:	459c      	cmp	ip, r3
 80248ee:	bf01      	itttt	eq
 80248f0:	ea22 020c 	biceq.w	r2, r2, ip
 80248f4:	f012 3f80 	tsteq.w	r2, #2155905152	; 0x80808080
 80248f8:	f850 cb04 	ldreq.w	ip, [r0], #4
 80248fc:	f851 3b04 	ldreq.w	r3, [r1], #4
 8024900:	d0f2      	beq.n	80248e8 <strcmp+0x40>
 8024902:	ea4f 600c 	mov.w	r0, ip, lsl #24
 8024906:	ea4f 2c1c 	mov.w	ip, ip, lsr #8
 802490a:	2801      	cmp	r0, #1
 802490c:	bf28      	it	cs
 802490e:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 8024912:	bf08      	it	eq
 8024914:	0a1b      	lsreq	r3, r3, #8
 8024916:	d0f4      	beq.n	8024902 <strcmp+0x5a>
 8024918:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 802491c:	ea4f 6010 	mov.w	r0, r0, lsr #24
 8024920:	eba0 0003 	sub.w	r0, r0, r3
 8024924:	4770      	bx	lr
 8024926:	bf00      	nop

08024928 <strcmp_unaligned>:
 8024928:	f010 0f03 	tst.w	r0, #3
 802492c:	d00a      	beq.n	8024944 <strcmp_unaligned+0x1c>
 802492e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8024932:	f811 3b01 	ldrb.w	r3, [r1], #1
 8024936:	2a01      	cmp	r2, #1
 8024938:	bf28      	it	cs
 802493a:	429a      	cmpcs	r2, r3
 802493c:	d0f4      	beq.n	8024928 <strcmp_unaligned>
 802493e:	eba2 0003 	sub.w	r0, r2, r3
 8024942:	4770      	bx	lr
 8024944:	f84d 5d04 	str.w	r5, [sp, #-4]!
 8024948:	f84d 4d04 	str.w	r4, [sp, #-4]!
 802494c:	f04f 0201 	mov.w	r2, #1
 8024950:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 8024954:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 8024958:	f001 0c03 	and.w	ip, r1, #3
 802495c:	f021 0103 	bic.w	r1, r1, #3
 8024960:	f850 4b04 	ldr.w	r4, [r0], #4
 8024964:	f851 5b04 	ldr.w	r5, [r1], #4
 8024968:	f1bc 0f02 	cmp.w	ip, #2
 802496c:	d026      	beq.n	80249bc <strcmp_unaligned+0x94>
 802496e:	d84b      	bhi.n	8024a08 <strcmp_unaligned+0xe0>
 8024970:	f024 4c7f 	bic.w	ip, r4, #4278190080	; 0xff000000
 8024974:	ebbc 2f15 	cmp.w	ip, r5, lsr #8
 8024978:	eba4 0302 	sub.w	r3, r4, r2
 802497c:	ea23 0304 	bic.w	r3, r3, r4
 8024980:	d10d      	bne.n	802499e <strcmp_unaligned+0x76>
 8024982:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8024986:	bf08      	it	eq
 8024988:	f851 5b04 	ldreq.w	r5, [r1], #4
 802498c:	d10a      	bne.n	80249a4 <strcmp_unaligned+0x7c>
 802498e:	ea8c 0c04 	eor.w	ip, ip, r4
 8024992:	ebbc 6f05 	cmp.w	ip, r5, lsl #24
 8024996:	d10c      	bne.n	80249b2 <strcmp_unaligned+0x8a>
 8024998:	f850 4b04 	ldr.w	r4, [r0], #4
 802499c:	e7e8      	b.n	8024970 <strcmp_unaligned+0x48>
 802499e:	ea4f 2515 	mov.w	r5, r5, lsr #8
 80249a2:	e05c      	b.n	8024a5e <strcmp_unaligned+0x136>
 80249a4:	f033 437f 	bics.w	r3, r3, #4278190080	; 0xff000000
 80249a8:	d152      	bne.n	8024a50 <strcmp_unaligned+0x128>
 80249aa:	780d      	ldrb	r5, [r1, #0]
 80249ac:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 80249b0:	e055      	b.n	8024a5e <strcmp_unaligned+0x136>
 80249b2:	ea4f 6c14 	mov.w	ip, r4, lsr #24
 80249b6:	f005 05ff 	and.w	r5, r5, #255	; 0xff
 80249ba:	e050      	b.n	8024a5e <strcmp_unaligned+0x136>
 80249bc:	ea4f 4c04 	mov.w	ip, r4, lsl #16
 80249c0:	eba4 0302 	sub.w	r3, r4, r2
 80249c4:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
 80249c8:	ea23 0304 	bic.w	r3, r3, r4
 80249cc:	ebbc 4f15 	cmp.w	ip, r5, lsr #16
 80249d0:	d117      	bne.n	8024a02 <strcmp_unaligned+0xda>
 80249d2:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 80249d6:	bf08      	it	eq
 80249d8:	f851 5b04 	ldreq.w	r5, [r1], #4
 80249dc:	d107      	bne.n	80249ee <strcmp_unaligned+0xc6>
 80249de:	ea8c 0c04 	eor.w	ip, ip, r4
 80249e2:	ebbc 4f05 	cmp.w	ip, r5, lsl #16
 80249e6:	d108      	bne.n	80249fa <strcmp_unaligned+0xd2>
 80249e8:	f850 4b04 	ldr.w	r4, [r0], #4
 80249ec:	e7e6      	b.n	80249bc <strcmp_unaligned+0x94>
 80249ee:	041b      	lsls	r3, r3, #16
 80249f0:	d12e      	bne.n	8024a50 <strcmp_unaligned+0x128>
 80249f2:	880d      	ldrh	r5, [r1, #0]
 80249f4:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 80249f8:	e031      	b.n	8024a5e <strcmp_unaligned+0x136>
 80249fa:	ea4f 4505 	mov.w	r5, r5, lsl #16
 80249fe:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 8024a02:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8024a06:	e02a      	b.n	8024a5e <strcmp_unaligned+0x136>
 8024a08:	f004 0cff 	and.w	ip, r4, #255	; 0xff
 8024a0c:	ebbc 6f15 	cmp.w	ip, r5, lsr #24
 8024a10:	eba4 0302 	sub.w	r3, r4, r2
 8024a14:	ea23 0304 	bic.w	r3, r3, r4
 8024a18:	d10d      	bne.n	8024a36 <strcmp_unaligned+0x10e>
 8024a1a:	ea13 13c2 	ands.w	r3, r3, r2, lsl #7
 8024a1e:	bf08      	it	eq
 8024a20:	f851 5b04 	ldreq.w	r5, [r1], #4
 8024a24:	d10a      	bne.n	8024a3c <strcmp_unaligned+0x114>
 8024a26:	ea8c 0c04 	eor.w	ip, ip, r4
 8024a2a:	ebbc 2f05 	cmp.w	ip, r5, lsl #8
 8024a2e:	d10a      	bne.n	8024a46 <strcmp_unaligned+0x11e>
 8024a30:	f850 4b04 	ldr.w	r4, [r0], #4
 8024a34:	e7e8      	b.n	8024a08 <strcmp_unaligned+0xe0>
 8024a36:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8024a3a:	e010      	b.n	8024a5e <strcmp_unaligned+0x136>
 8024a3c:	f014 0fff 	tst.w	r4, #255	; 0xff
 8024a40:	d006      	beq.n	8024a50 <strcmp_unaligned+0x128>
 8024a42:	f851 5b04 	ldr.w	r5, [r1], #4
 8024a46:	ea4f 2c14 	mov.w	ip, r4, lsr #8
 8024a4a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8024a4e:	e006      	b.n	8024a5e <strcmp_unaligned+0x136>
 8024a50:	f04f 0000 	mov.w	r0, #0
 8024a54:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024a58:	f85d 5b04 	ldr.w	r5, [sp], #4
 8024a5c:	4770      	bx	lr
 8024a5e:	f00c 02ff 	and.w	r2, ip, #255	; 0xff
 8024a62:	f005 00ff 	and.w	r0, r5, #255	; 0xff
 8024a66:	2801      	cmp	r0, #1
 8024a68:	bf28      	it	cs
 8024a6a:	4290      	cmpcs	r0, r2
 8024a6c:	bf04      	itt	eq
 8024a6e:	ea4f 2c1c 	moveq.w	ip, ip, lsr #8
 8024a72:	0a2d      	lsreq	r5, r5, #8
 8024a74:	d0f3      	beq.n	8024a5e <strcmp_unaligned+0x136>
 8024a76:	eba2 0000 	sub.w	r0, r2, r0
 8024a7a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024a7e:	f85d 5b04 	ldr.w	r5, [sp], #4
 8024a82:	4770      	bx	lr

08024a84 <strcpy>:
 8024a84:	ea80 0201 	eor.w	r2, r0, r1
 8024a88:	4684      	mov	ip, r0
 8024a8a:	f012 0f03 	tst.w	r2, #3
 8024a8e:	d14f      	bne.n	8024b30 <strcpy+0xac>
 8024a90:	f011 0f03 	tst.w	r1, #3
 8024a94:	d132      	bne.n	8024afc <strcpy+0x78>
 8024a96:	f84d 4d04 	str.w	r4, [sp, #-4]!
 8024a9a:	f011 0f04 	tst.w	r1, #4
 8024a9e:	f851 3b04 	ldr.w	r3, [r1], #4
 8024aa2:	d00b      	beq.n	8024abc <strcpy+0x38>
 8024aa4:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8024aa8:	439a      	bics	r2, r3
 8024aaa:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8024aae:	bf04      	itt	eq
 8024ab0:	f84c 3b04 	streq.w	r3, [ip], #4
 8024ab4:	f851 3b04 	ldreq.w	r3, [r1], #4
 8024ab8:	d116      	bne.n	8024ae8 <strcpy+0x64>
 8024aba:	bf00      	nop
 8024abc:	f851 4b04 	ldr.w	r4, [r1], #4
 8024ac0:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8024ac4:	439a      	bics	r2, r3
 8024ac6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8024aca:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8024ace:	d10b      	bne.n	8024ae8 <strcpy+0x64>
 8024ad0:	f84c 3b04 	str.w	r3, [ip], #4
 8024ad4:	43a2      	bics	r2, r4
 8024ad6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8024ada:	bf04      	itt	eq
 8024adc:	f851 3b04 	ldreq.w	r3, [r1], #4
 8024ae0:	f84c 4b04 	streq.w	r4, [ip], #4
 8024ae4:	d0ea      	beq.n	8024abc <strcpy+0x38>
 8024ae6:	4623      	mov	r3, r4
 8024ae8:	f80c 3b01 	strb.w	r3, [ip], #1
 8024aec:	f013 0fff 	tst.w	r3, #255	; 0xff
 8024af0:	ea4f 2333 	mov.w	r3, r3, ror #8
 8024af4:	d1f8      	bne.n	8024ae8 <strcpy+0x64>
 8024af6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024afa:	4770      	bx	lr
 8024afc:	f011 0f01 	tst.w	r1, #1
 8024b00:	d006      	beq.n	8024b10 <strcpy+0x8c>
 8024b02:	f811 2b01 	ldrb.w	r2, [r1], #1
 8024b06:	f80c 2b01 	strb.w	r2, [ip], #1
 8024b0a:	2a00      	cmp	r2, #0
 8024b0c:	bf08      	it	eq
 8024b0e:	4770      	bxeq	lr
 8024b10:	f011 0f02 	tst.w	r1, #2
 8024b14:	d0bf      	beq.n	8024a96 <strcpy+0x12>
 8024b16:	f831 2b02 	ldrh.w	r2, [r1], #2
 8024b1a:	f012 0fff 	tst.w	r2, #255	; 0xff
 8024b1e:	bf16      	itet	ne
 8024b20:	f82c 2b02 	strhne.w	r2, [ip], #2
 8024b24:	f88c 2000 	strbeq.w	r2, [ip]
 8024b28:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 8024b2c:	d1b3      	bne.n	8024a96 <strcpy+0x12>
 8024b2e:	4770      	bx	lr
 8024b30:	f811 2b01 	ldrb.w	r2, [r1], #1
 8024b34:	f80c 2b01 	strb.w	r2, [ip], #1
 8024b38:	2a00      	cmp	r2, #0
 8024b3a:	d1f9      	bne.n	8024b30 <strcpy+0xac>
 8024b3c:	4770      	bx	lr
 8024b3e:	bf00      	nop

08024b40 <strlen>:
 8024b40:	f020 0103 	bic.w	r1, r0, #3
 8024b44:	f010 0003 	ands.w	r0, r0, #3
 8024b48:	f1c0 0000 	rsb	r0, r0, #0
 8024b4c:	f851 3b04 	ldr.w	r3, [r1], #4
 8024b50:	f100 0c04 	add.w	ip, r0, #4
 8024b54:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8024b58:	f06f 0200 	mvn.w	r2, #0
 8024b5c:	bf1c      	itt	ne
 8024b5e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8024b62:	4313      	orrne	r3, r2
 8024b64:	f04f 0c01 	mov.w	ip, #1
 8024b68:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8024b6c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8024b70:	eba3 020c 	sub.w	r2, r3, ip
 8024b74:	ea22 0203 	bic.w	r2, r2, r3
 8024b78:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8024b7c:	bf04      	itt	eq
 8024b7e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8024b82:	3004      	addeq	r0, #4
 8024b84:	d0f4      	beq.n	8024b70 <strlen+0x30>
 8024b86:	f013 0fff 	tst.w	r3, #255	; 0xff
 8024b8a:	bf1f      	itttt	ne
 8024b8c:	3001      	addne	r0, #1
 8024b8e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8024b92:	3001      	addne	r0, #1
 8024b94:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8024b98:	bf18      	it	ne
 8024b9a:	3001      	addne	r0, #1
 8024b9c:	4770      	bx	lr
 8024b9e:	bf00      	nop

08024ba0 <strncmp>:
 8024ba0:	b4f0      	push	{r4, r5, r6, r7}
 8024ba2:	2a00      	cmp	r2, #0
 8024ba4:	f000 8083 	beq.w	8024cae <strncmp+0x10e>
 8024ba8:	ea41 0300 	orr.w	r3, r1, r0
 8024bac:	f013 0503 	ands.w	r5, r3, #3
 8024bb0:	d02e      	beq.n	8024c10 <strncmp+0x70>
 8024bb2:	1e55      	subs	r5, r2, #1
 8024bb4:	7803      	ldrb	r3, [r0, #0]
 8024bb6:	780a      	ldrb	r2, [r1, #0]
 8024bb8:	4293      	cmp	r3, r2
 8024bba:	d126      	bne.n	8024c0a <strncmp+0x6a>
 8024bbc:	2d00      	cmp	r5, #0
 8024bbe:	d07a      	beq.n	8024cb6 <strncmp+0x116>
 8024bc0:	2b00      	cmp	r3, #0
 8024bc2:	d07a      	beq.n	8024cba <strncmp+0x11a>
 8024bc4:	3501      	adds	r5, #1
 8024bc6:	1c8c      	adds	r4, r1, #2
 8024bc8:	194d      	adds	r5, r1, r5
 8024bca:	1b2b      	subs	r3, r5, r4
 8024bcc:	07db      	lsls	r3, r3, #31
 8024bce:	d516      	bpl.n	8024bfe <strncmp+0x5e>
 8024bd0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8024bd4:	f814 2c01 	ldrb.w	r2, [r4, #-1]
 8024bd8:	4293      	cmp	r3, r2
 8024bda:	d116      	bne.n	8024c0a <strncmp+0x6a>
 8024bdc:	1ccc      	adds	r4, r1, #3
 8024bde:	b973      	cbnz	r3, 8024bfe <strncmp+0x5e>
 8024be0:	e036      	b.n	8024c50 <strncmp+0xb0>
 8024be2:	42ac      	cmp	r4, r5
 8024be4:	d034      	beq.n	8024c50 <strncmp+0xb0>
 8024be6:	3401      	adds	r4, #1
 8024be8:	2b00      	cmp	r3, #0
 8024bea:	d031      	beq.n	8024c50 <strncmp+0xb0>
 8024bec:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8024bf0:	f814 2c01 	ldrb.w	r2, [r4, #-1]
 8024bf4:	4293      	cmp	r3, r2
 8024bf6:	d108      	bne.n	8024c0a <strncmp+0x6a>
 8024bf8:	3401      	adds	r4, #1
 8024bfa:	2b00      	cmp	r3, #0
 8024bfc:	d028      	beq.n	8024c50 <strncmp+0xb0>
 8024bfe:	f814 2c01 	ldrb.w	r2, [r4, #-1]
 8024c02:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8024c06:	4293      	cmp	r3, r2
 8024c08:	d0eb      	beq.n	8024be2 <strncmp+0x42>
 8024c0a:	1a98      	subs	r0, r3, r2
 8024c0c:	bcf0      	pop	{r4, r5, r6, r7}
 8024c0e:	4770      	bx	lr
 8024c10:	2a03      	cmp	r2, #3
 8024c12:	d9ce      	bls.n	8024bb2 <strncmp+0x12>
 8024c14:	6804      	ldr	r4, [r0, #0]
 8024c16:	680b      	ldr	r3, [r1, #0]
 8024c18:	429c      	cmp	r4, r3
 8024c1a:	d1ca      	bne.n	8024bb2 <strncmp+0x12>
 8024c1c:	1f13      	subs	r3, r2, #4
 8024c1e:	d04c      	beq.n	8024cba <strncmp+0x11a>
 8024c20:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8024c24:	ea22 0404 	bic.w	r4, r2, r4
 8024c28:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8024c2c:	d143      	bne.n	8024cb6 <strncmp+0x116>
 8024c2e:	075a      	lsls	r2, r3, #29
 8024c30:	d52f      	bpl.n	8024c92 <strncmp+0xf2>
 8024c32:	684c      	ldr	r4, [r1, #4]
 8024c34:	6842      	ldr	r2, [r0, #4]
 8024c36:	3104      	adds	r1, #4
 8024c38:	3004      	adds	r0, #4
 8024c3a:	42a2      	cmp	r2, r4
 8024c3c:	d139      	bne.n	8024cb2 <strncmp+0x112>
 8024c3e:	3b04      	subs	r3, #4
 8024c40:	d006      	beq.n	8024c50 <strncmp+0xb0>
 8024c42:	f1a2 3401 	sub.w	r4, r2, #16843009	; 0x1010101
 8024c46:	ea24 0202 	bic.w	r2, r4, r2
 8024c4a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8024c4e:	d020      	beq.n	8024c92 <strncmp+0xf2>
 8024c50:	2000      	movs	r0, #0
 8024c52:	e7db      	b.n	8024c0c <strncmp+0x6c>
 8024c54:	6872      	ldr	r2, [r6, #4]
 8024c56:	6864      	ldr	r4, [r4, #4]
 8024c58:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
 8024c5c:	42a2      	cmp	r2, r4
 8024c5e:	ea25 0502 	bic.w	r5, r5, r2
 8024c62:	d126      	bne.n	8024cb2 <strncmp+0x112>
 8024c64:	3b04      	subs	r3, #4
 8024c66:	f100 0004 	add.w	r0, r0, #4
 8024c6a:	f101 0104 	add.w	r1, r1, #4
 8024c6e:	d0ef      	beq.n	8024c50 <strncmp+0xb0>
 8024c70:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8024c74:	d1ec      	bne.n	8024c50 <strncmp+0xb0>
 8024c76:	f8dc 2004 	ldr.w	r2, [ip, #4]
 8024c7a:	687c      	ldr	r4, [r7, #4]
 8024c7c:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
 8024c80:	42a2      	cmp	r2, r4
 8024c82:	ea25 0502 	bic.w	r5, r5, r2
 8024c86:	d114      	bne.n	8024cb2 <strncmp+0x112>
 8024c88:	3b04      	subs	r3, #4
 8024c8a:	d0e1      	beq.n	8024c50 <strncmp+0xb0>
 8024c8c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8024c90:	d1de      	bne.n	8024c50 <strncmp+0xb0>
 8024c92:	460c      	mov	r4, r1
 8024c94:	4606      	mov	r6, r0
 8024c96:	3104      	adds	r1, #4
 8024c98:	3004      	adds	r0, #4
 8024c9a:	2b03      	cmp	r3, #3
 8024c9c:	4684      	mov	ip, r0
 8024c9e:	460f      	mov	r7, r1
 8024ca0:	d8d8      	bhi.n	8024c54 <strncmp+0xb4>
 8024ca2:	1e5d      	subs	r5, r3, #1
 8024ca4:	2b00      	cmp	r3, #0
 8024ca6:	d185      	bne.n	8024bb4 <strncmp+0x14>
 8024ca8:	7933      	ldrb	r3, [r6, #4]
 8024caa:	7922      	ldrb	r2, [r4, #4]
 8024cac:	e7ad      	b.n	8024c0a <strncmp+0x6a>
 8024cae:	4610      	mov	r0, r2
 8024cb0:	e7ac      	b.n	8024c0c <strncmp+0x6c>
 8024cb2:	1e5d      	subs	r5, r3, #1
 8024cb4:	e77e      	b.n	8024bb4 <strncmp+0x14>
 8024cb6:	4628      	mov	r0, r5
 8024cb8:	e7a8      	b.n	8024c0c <strncmp+0x6c>
 8024cba:	4618      	mov	r0, r3
 8024cbc:	e7a6      	b.n	8024c0c <strncmp+0x6c>
 8024cbe:	bf00      	nop

08024cc0 <critical_factorization>:
 8024cc0:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8024cc4:	2701      	movs	r7, #1
 8024cc6:	463c      	mov	r4, r7
 8024cc8:	2500      	movs	r5, #0
 8024cca:	f04f 36ff 	mov.w	r6, #4294967295
 8024cce:	1963      	adds	r3, r4, r5
 8024cd0:	428b      	cmp	r3, r1
 8024cd2:	eb00 0c06 	add.w	ip, r0, r6
 8024cd6:	d20d      	bcs.n	8024cf4 <critical_factorization+0x34>
 8024cd8:	f81c a004 	ldrb.w	sl, [ip, r4]
 8024cdc:	f810 8003 	ldrb.w	r8, [r0, r3]
 8024ce0:	45d0      	cmp	r8, sl
 8024ce2:	d22e      	bcs.n	8024d42 <critical_factorization+0x82>
 8024ce4:	2401      	movs	r4, #1
 8024ce6:	461d      	mov	r5, r3
 8024ce8:	1b9f      	subs	r7, r3, r6
 8024cea:	1963      	adds	r3, r4, r5
 8024cec:	428b      	cmp	r3, r1
 8024cee:	eb00 0c06 	add.w	ip, r0, r6
 8024cf2:	d3f1      	bcc.n	8024cd8 <critical_factorization+0x18>
 8024cf4:	f04f 0a01 	mov.w	sl, #1
 8024cf8:	6017      	str	r7, [r2, #0]
 8024cfa:	4654      	mov	r4, sl
 8024cfc:	2500      	movs	r5, #0
 8024cfe:	f04f 3cff 	mov.w	ip, #4294967295
 8024d02:	1963      	adds	r3, r4, r5
 8024d04:	4299      	cmp	r1, r3
 8024d06:	eb00 080c 	add.w	r8, r0, ip
 8024d0a:	d90e      	bls.n	8024d2a <critical_factorization+0x6a>
 8024d0c:	f818 8004 	ldrb.w	r8, [r8, r4]
 8024d10:	f810 9003 	ldrb.w	r9, [r0, r3]
 8024d14:	45c1      	cmp	r9, r8
 8024d16:	d91a      	bls.n	8024d4e <critical_factorization+0x8e>
 8024d18:	2401      	movs	r4, #1
 8024d1a:	461d      	mov	r5, r3
 8024d1c:	ebcc 0a03 	rsb	sl, ip, r3
 8024d20:	1963      	adds	r3, r4, r5
 8024d22:	4299      	cmp	r1, r3
 8024d24:	eb00 080c 	add.w	r8, r0, ip
 8024d28:	d8f0      	bhi.n	8024d0c <critical_factorization+0x4c>
 8024d2a:	f10c 0001 	add.w	r0, ip, #1
 8024d2e:	3601      	adds	r6, #1
 8024d30:	42b0      	cmp	r0, r6
 8024d32:	bf3c      	itt	cc
 8024d34:	46ba      	movcc	sl, r7
 8024d36:	4630      	movcc	r0, r6
 8024d38:	f8c2 a000 	str.w	sl, [r2]
 8024d3c:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
 8024d40:	4770      	bx	lr
 8024d42:	d00b      	beq.n	8024d5c <critical_factorization+0x9c>
 8024d44:	2701      	movs	r7, #1
 8024d46:	462e      	mov	r6, r5
 8024d48:	463c      	mov	r4, r7
 8024d4a:	19ed      	adds	r5, r5, r7
 8024d4c:	e7bf      	b.n	8024cce <critical_factorization+0xe>
 8024d4e:	d009      	beq.n	8024d64 <critical_factorization+0xa4>
 8024d50:	f04f 0a01 	mov.w	sl, #1
 8024d54:	46ac      	mov	ip, r5
 8024d56:	4654      	mov	r4, sl
 8024d58:	4455      	add	r5, sl
 8024d5a:	e7d2      	b.n	8024d02 <critical_factorization+0x42>
 8024d5c:	42bc      	cmp	r4, r7
 8024d5e:	d005      	beq.n	8024d6c <critical_factorization+0xac>
 8024d60:	3401      	adds	r4, #1
 8024d62:	e7b4      	b.n	8024cce <critical_factorization+0xe>
 8024d64:	4554      	cmp	r4, sl
 8024d66:	d005      	beq.n	8024d74 <critical_factorization+0xb4>
 8024d68:	3401      	adds	r4, #1
 8024d6a:	e7ca      	b.n	8024d02 <critical_factorization+0x42>
 8024d6c:	4627      	mov	r7, r4
 8024d6e:	461d      	mov	r5, r3
 8024d70:	2401      	movs	r4, #1
 8024d72:	e7ac      	b.n	8024cce <critical_factorization+0xe>
 8024d74:	46a2      	mov	sl, r4
 8024d76:	461d      	mov	r5, r3
 8024d78:	2401      	movs	r4, #1
 8024d7a:	e7c2      	b.n	8024d02 <critical_factorization+0x42>

08024d7c <two_way_long_needle>:
 8024d7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024d80:	f2ad 4d24 	subw	sp, sp, #1060	; 0x424
 8024d84:	4616      	mov	r6, r2
 8024d86:	4607      	mov	r7, r0
 8024d88:	460c      	mov	r4, r1
 8024d8a:	4610      	mov	r0, r2
 8024d8c:	4619      	mov	r1, r3
 8024d8e:	aa07      	add	r2, sp, #28
 8024d90:	461d      	mov	r5, r3
 8024d92:	f7ff ff95 	bl	8024cc0 <critical_factorization>
 8024d96:	ab07      	add	r3, sp, #28
 8024d98:	9001      	str	r0, [sp, #4]
 8024d9a:	f20d 411c 	addw	r1, sp, #1052	; 0x41c
 8024d9e:	1d1a      	adds	r2, r3, #4
 8024da0:	605d      	str	r5, [r3, #4]
 8024da2:	3308      	adds	r3, #8
 8024da4:	428b      	cmp	r3, r1
 8024da6:	6055      	str	r5, [r2, #4]
 8024da8:	d1f9      	bne.n	8024d9e <two_way_long_needle+0x22>
 8024daa:	b31d      	cbz	r5, 8024df4 <two_way_long_needle+0x78>
 8024dac:	7832      	ldrb	r2, [r6, #0]
 8024dae:	2301      	movs	r3, #1
 8024db0:	a808      	add	r0, sp, #32
 8024db2:	1e69      	subs	r1, r5, #1
 8024db4:	42ab      	cmp	r3, r5
 8024db6:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
 8024dba:	ea01 0203 	and.w	r2, r1, r3
 8024dbe:	d019      	beq.n	8024df4 <two_way_long_needle+0x78>
 8024dc0:	b13a      	cbz	r2, 8024dd2 <two_way_long_needle+0x56>
 8024dc2:	7872      	ldrb	r2, [r6, #1]
 8024dc4:	2302      	movs	r3, #2
 8024dc6:	f101 3eff 	add.w	lr, r1, #4294967295
 8024dca:	42ab      	cmp	r3, r5
 8024dcc:	f840 e022 	str.w	lr, [r0, r2, lsl #2]
 8024dd0:	d010      	beq.n	8024df4 <two_way_long_needle+0x78>
 8024dd2:	46a1      	mov	r9, r4
 8024dd4:	46a8      	mov	r8, r5
 8024dd6:	1c5c      	adds	r4, r3, #1
 8024dd8:	f816 c003 	ldrb.w	ip, [r6, r3]
 8024ddc:	5d32      	ldrb	r2, [r6, r4]
 8024dde:	1acd      	subs	r5, r1, r3
 8024de0:	3302      	adds	r3, #2
 8024de2:	1b0c      	subs	r4, r1, r4
 8024de4:	4543      	cmp	r3, r8
 8024de6:	f840 502c 	str.w	r5, [r0, ip, lsl #2]
 8024dea:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
 8024dee:	d1f2      	bne.n	8024dd6 <two_way_long_needle+0x5a>
 8024df0:	464c      	mov	r4, r9
 8024df2:	4645      	mov	r5, r8
 8024df4:	9907      	ldr	r1, [sp, #28]
 8024df6:	9a01      	ldr	r2, [sp, #4]
 8024df8:	4630      	mov	r0, r6
 8024dfa:	1871      	adds	r1, r6, r1
 8024dfc:	f000 fbfc 	bl	80255f8 <memcmp>
 8024e00:	2800      	cmp	r0, #0
 8024e02:	f040 80be 	bne.w	8024f82 <two_way_long_needle+0x206>
 8024e06:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8024e0a:	f8dd e004 	ldr.w	lr, [sp, #4]
 8024e0e:	9502      	str	r5, [sp, #8]
 8024e10:	f109 3bff 	add.w	fp, r9, #4294967295
 8024e14:	eb06 0c0b 	add.w	ip, r6, fp
 8024e18:	f8cd b00c 	str.w	fp, [sp, #12]
 8024e1c:	f1ce 0b01 	rsb	fp, lr, #1
 8024e20:	4622      	mov	r2, r4
 8024e22:	4682      	mov	sl, r0
 8024e24:	f105 39ff 	add.w	r9, r5, #4294967295
 8024e28:	f8cd c010 	str.w	ip, [sp, #16]
 8024e2c:	f8cd b014 	str.w	fp, [sp, #20]
 8024e30:	4604      	mov	r4, r0
 8024e32:	e008      	b.n	8024e46 <two_way_long_needle+0xca>
 8024e34:	b124      	cbz	r4, 8024e40 <two_way_long_needle+0xc4>
 8024e36:	9c07      	ldr	r4, [sp, #28]
 8024e38:	42a3      	cmp	r3, r4
 8024e3a:	d201      	bcs.n	8024e40 <two_way_long_needle+0xc4>
 8024e3c:	9902      	ldr	r1, [sp, #8]
 8024e3e:	1b0b      	subs	r3, r1, r4
 8024e40:	449a      	add	sl, r3
 8024e42:	2400      	movs	r4, #0
 8024e44:	462a      	mov	r2, r5
 8024e46:	9d02      	ldr	r5, [sp, #8]
 8024e48:	4455      	add	r5, sl
 8024e4a:	18b8      	adds	r0, r7, r2
 8024e4c:	2100      	movs	r1, #0
 8024e4e:	1aaa      	subs	r2, r5, r2
 8024e50:	f000 fb32 	bl	80254b8 <memchr>
 8024e54:	2800      	cmp	r0, #0
 8024e56:	f040 808e 	bne.w	8024f76 <two_way_long_needle+0x1fa>
 8024e5a:	2d00      	cmp	r5, #0
 8024e5c:	f000 808b 	beq.w	8024f76 <two_way_long_needle+0x1fa>
 8024e60:	1979      	adds	r1, r7, r5
 8024e62:	a808      	add	r0, sp, #32
 8024e64:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 8024e68:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 8024e6c:	2b00      	cmp	r3, #0
 8024e6e:	d1e1      	bne.n	8024e34 <two_way_long_needle+0xb8>
 8024e70:	9b01      	ldr	r3, [sp, #4]
 8024e72:	429c      	cmp	r4, r3
 8024e74:	bf28      	it	cs
 8024e76:	4623      	movcs	r3, r4
 8024e78:	454b      	cmp	r3, r9
 8024e7a:	d22a      	bcs.n	8024ed2 <two_way_long_needle+0x156>
 8024e7c:	eb07 010a 	add.w	r1, r7, sl
 8024e80:	f816 b003 	ldrb.w	fp, [r6, r3]
 8024e84:	5cca      	ldrb	r2, [r1, r3]
 8024e86:	4593      	cmp	fp, r2
 8024e88:	eb06 0003 	add.w	r0, r6, r3
 8024e8c:	d16f      	bne.n	8024f6e <two_way_long_needle+0x1f2>
 8024e8e:	ea6f 0c03 	mvn.w	ip, r3
 8024e92:	eb0c 0e09 	add.w	lr, ip, r9
 8024e96:	f01e 0f01 	tst.w	lr, #1
 8024e9a:	4602      	mov	r2, r0
 8024e9c:	d016      	beq.n	8024ecc <two_way_long_needle+0x150>
 8024e9e:	3301      	adds	r3, #1
 8024ea0:	454b      	cmp	r3, r9
 8024ea2:	d216      	bcs.n	8024ed2 <two_way_long_needle+0x156>
 8024ea4:	7840      	ldrb	r0, [r0, #1]
 8024ea6:	f811 b003 	ldrb.w	fp, [r1, r3]
 8024eaa:	3201      	adds	r2, #1
 8024eac:	4583      	cmp	fp, r0
 8024eae:	d00d      	beq.n	8024ecc <two_way_long_needle+0x150>
 8024eb0:	e05d      	b.n	8024f6e <two_way_long_needle+0x1f2>
 8024eb2:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8024eb6:	f811 c003 	ldrb.w	ip, [r1, r3]
 8024eba:	4584      	cmp	ip, r0
 8024ebc:	d157      	bne.n	8024f6e <two_way_long_needle+0x1f2>
 8024ebe:	3301      	adds	r3, #1
 8024ec0:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8024ec4:	f811 e003 	ldrb.w	lr, [r1, r3]
 8024ec8:	4586      	cmp	lr, r0
 8024eca:	d150      	bne.n	8024f6e <two_way_long_needle+0x1f2>
 8024ecc:	3301      	adds	r3, #1
 8024ece:	454b      	cmp	r3, r9
 8024ed0:	d3ef      	bcc.n	8024eb2 <two_way_long_needle+0x136>
 8024ed2:	f8dd b004 	ldr.w	fp, [sp, #4]
 8024ed6:	9b03      	ldr	r3, [sp, #12]
 8024ed8:	455c      	cmp	r4, fp
 8024eda:	bf28      	it	cs
 8024edc:	465b      	movcs	r3, fp
 8024ede:	d23d      	bcs.n	8024f5c <two_way_long_needle+0x1e0>
 8024ee0:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8024ee4:	eb07 0c0a 	add.w	ip, r7, sl
 8024ee8:	f816 100b 	ldrb.w	r1, [r6, fp]
 8024eec:	f81c 000b 	ldrb.w	r0, [ip, fp]
 8024ef0:	4281      	cmp	r1, r0
 8024ef2:	f040 80ca 	bne.w	802508a <two_way_long_needle+0x30e>
 8024ef6:	f8dd b010 	ldr.w	fp, [sp, #16]
 8024efa:	eb06 0804 	add.w	r8, r6, r4
 8024efe:	ebc8 010b 	rsb	r1, r8, fp
 8024f02:	07c8      	lsls	r0, r1, #31
 8024f04:	465a      	mov	r2, fp
 8024f06:	d524      	bpl.n	8024f52 <two_way_long_needle+0x1d6>
 8024f08:	9a04      	ldr	r2, [sp, #16]
 8024f0a:	f8dd e00c 	ldr.w	lr, [sp, #12]
 8024f0e:	f812 0c01 	ldrb.w	r0, [r2, #-1]
 8024f12:	f8dd b010 	ldr.w	fp, [sp, #16]
 8024f16:	9000      	str	r0, [sp, #0]
 8024f18:	f10e 31ff 	add.w	r1, lr, #4294967295
 8024f1c:	f10b 32ff 	add.w	r2, fp, #4294967295
 8024f20:	f81c 0001 	ldrb.w	r0, [ip, r1]
 8024f24:	f8dd b000 	ldr.w	fp, [sp]
 8024f28:	4583      	cmp	fp, r0
 8024f2a:	d117      	bne.n	8024f5c <two_way_long_needle+0x1e0>
 8024f2c:	460b      	mov	r3, r1
 8024f2e:	e010      	b.n	8024f52 <two_way_long_needle+0x1d6>
 8024f30:	f812 bc01 	ldrb.w	fp, [r2, #-1]
 8024f34:	f81c 2000 	ldrb.w	r2, [ip, r0]
 8024f38:	4593      	cmp	fp, r2
 8024f3a:	f101 32ff 	add.w	r2, r1, #4294967295
 8024f3e:	d10d      	bne.n	8024f5c <two_way_long_needle+0x1e0>
 8024f40:	4603      	mov	r3, r0
 8024f42:	3801      	subs	r0, #1
 8024f44:	f811 bc01 	ldrb.w	fp, [r1, #-1]
 8024f48:	f81c 1000 	ldrb.w	r1, [ip, r0]
 8024f4c:	458b      	cmp	fp, r1
 8024f4e:	d105      	bne.n	8024f5c <two_way_long_needle+0x1e0>
 8024f50:	4603      	mov	r3, r0
 8024f52:	1e58      	subs	r0, r3, #1
 8024f54:	4542      	cmp	r2, r8
 8024f56:	f102 31ff 	add.w	r1, r2, #4294967295
 8024f5a:	d1e9      	bne.n	8024f30 <two_way_long_needle+0x1b4>
 8024f5c:	3401      	adds	r4, #1
 8024f5e:	429c      	cmp	r4, r3
 8024f60:	f200 8095 	bhi.w	802508e <two_way_long_needle+0x312>
 8024f64:	9c07      	ldr	r4, [sp, #28]
 8024f66:	9a02      	ldr	r2, [sp, #8]
 8024f68:	44a2      	add	sl, r4
 8024f6a:	1b14      	subs	r4, r2, r4
 8024f6c:	e76a      	b.n	8024e44 <two_way_long_needle+0xc8>
 8024f6e:	f8dd b014 	ldr.w	fp, [sp, #20]
 8024f72:	44da      	add	sl, fp
 8024f74:	e764      	b.n	8024e40 <two_way_long_needle+0xc4>
 8024f76:	2000      	movs	r0, #0
 8024f78:	b009      	add	sp, #36	; 0x24
 8024f7a:	f50d 6d80 	add.w	sp, sp, #1024	; 0x400
 8024f7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024f82:	f8dd b004 	ldr.w	fp, [sp, #4]
 8024f86:	9a01      	ldr	r2, [sp, #4]
 8024f88:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8024f8c:	ebcb 0005 	rsb	r0, fp, r5
 8024f90:	4558      	cmp	r0, fp
 8024f92:	bf38      	it	cc
 8024f94:	4658      	movcc	r0, fp
 8024f96:	1c43      	adds	r3, r0, #1
 8024f98:	9801      	ldr	r0, [sp, #4]
 8024f9a:	9307      	str	r3, [sp, #28]
 8024f9c:	18b1      	adds	r1, r6, r2
 8024f9e:	f1c0 0301 	rsb	r3, r0, #1
 8024fa2:	f105 3bff 	add.w	fp, r5, #4294967295
 8024fa6:	9302      	str	r3, [sp, #8]
 8024fa8:	9501      	str	r5, [sp, #4]
 8024faa:	f04f 0a00 	mov.w	sl, #0
 8024fae:	f102 39ff 	add.w	r9, r2, #4294967295
 8024fb2:	4623      	mov	r3, r4
 8024fb4:	460d      	mov	r5, r1
 8024fb6:	9c01      	ldr	r4, [sp, #4]
 8024fb8:	4454      	add	r4, sl
 8024fba:	18f8      	adds	r0, r7, r3
 8024fbc:	2100      	movs	r1, #0
 8024fbe:	1ae2      	subs	r2, r4, r3
 8024fc0:	f000 fa7a 	bl	80254b8 <memchr>
 8024fc4:	2800      	cmp	r0, #0
 8024fc6:	d1d6      	bne.n	8024f76 <two_way_long_needle+0x1fa>
 8024fc8:	2c00      	cmp	r4, #0
 8024fca:	d0d4      	beq.n	8024f76 <two_way_long_needle+0x1fa>
 8024fcc:	193a      	adds	r2, r7, r4
 8024fce:	a908      	add	r1, sp, #32
 8024fd0:	f812 0c01 	ldrb.w	r0, [r2, #-1]
 8024fd4:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8024fd8:	2800      	cmp	r0, #0
 8024fda:	d14f      	bne.n	802507c <two_way_long_needle+0x300>
 8024fdc:	45d8      	cmp	r8, fp
 8024fde:	eb07 000a 	add.w	r0, r7, sl
 8024fe2:	d22a      	bcs.n	802503a <two_way_long_needle+0x2be>
 8024fe4:	f810 3008 	ldrb.w	r3, [r0, r8]
 8024fe8:	782a      	ldrb	r2, [r5, #0]
 8024fea:	429a      	cmp	r2, r3
 8024fec:	bf18      	it	ne
 8024fee:	4643      	movne	r3, r8
 8024ff0:	d147      	bne.n	8025082 <two_way_long_needle+0x306>
 8024ff2:	ea6f 0308 	mvn.w	r3, r8
 8024ff6:	eb03 010b 	add.w	r1, r3, fp
 8024ffa:	07c9      	lsls	r1, r1, #31
 8024ffc:	462a      	mov	r2, r5
 8024ffe:	4643      	mov	r3, r8
 8025000:	d518      	bpl.n	8025034 <two_way_long_needle+0x2b8>
 8025002:	f108 0301 	add.w	r3, r8, #1
 8025006:	455b      	cmp	r3, fp
 8025008:	d217      	bcs.n	802503a <two_way_long_needle+0x2be>
 802500a:	462a      	mov	r2, r5
 802500c:	f810 e003 	ldrb.w	lr, [r0, r3]
 8025010:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8025014:	458e      	cmp	lr, r1
 8025016:	d00d      	beq.n	8025034 <two_way_long_needle+0x2b8>
 8025018:	e033      	b.n	8025082 <two_way_long_needle+0x306>
 802501a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 802501e:	f810 c003 	ldrb.w	ip, [r0, r3]
 8025022:	458c      	cmp	ip, r1
 8025024:	d12d      	bne.n	8025082 <two_way_long_needle+0x306>
 8025026:	3301      	adds	r3, #1
 8025028:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 802502c:	f810 e003 	ldrb.w	lr, [r0, r3]
 8025030:	458e      	cmp	lr, r1
 8025032:	d126      	bne.n	8025082 <two_way_long_needle+0x306>
 8025034:	3301      	adds	r3, #1
 8025036:	455b      	cmp	r3, fp
 8025038:	d3ef      	bcc.n	802501a <two_way_long_needle+0x29e>
 802503a:	f1b9 3fff 	cmp.w	r9, #4294967295
 802503e:	464b      	mov	r3, r9
 8025040:	d09a      	beq.n	8024f78 <two_way_long_needle+0x1fc>
 8025042:	f816 1009 	ldrb.w	r1, [r6, r9]
 8025046:	f810 2009 	ldrb.w	r2, [r0, r9]
 802504a:	4291      	cmp	r1, r2
 802504c:	d115      	bne.n	802507a <two_way_long_needle+0x2fe>
 802504e:	f019 0f01 	tst.w	r9, #1
 8025052:	d00a      	beq.n	802506a <two_way_long_needle+0x2ee>
 8025054:	f109 33ff 	add.w	r3, r9, #4294967295
 8025058:	5cf1      	ldrb	r1, [r6, r3]
 802505a:	5cc2      	ldrb	r2, [r0, r3]
 802505c:	4291      	cmp	r1, r2
 802505e:	d004      	beq.n	802506a <two_way_long_needle+0x2ee>
 8025060:	e00b      	b.n	802507a <two_way_long_needle+0x2fe>
 8025062:	5cf1      	ldrb	r1, [r6, r3]
 8025064:	5cc2      	ldrb	r2, [r0, r3]
 8025066:	4291      	cmp	r1, r2
 8025068:	d107      	bne.n	802507a <two_way_long_needle+0x2fe>
 802506a:	1e5a      	subs	r2, r3, #1
 802506c:	2b00      	cmp	r3, #0
 802506e:	d083      	beq.n	8024f78 <two_way_long_needle+0x1fc>
 8025070:	5cb1      	ldrb	r1, [r6, r2]
 8025072:	5c82      	ldrb	r2, [r0, r2]
 8025074:	3b02      	subs	r3, #2
 8025076:	4291      	cmp	r1, r2
 8025078:	d0f3      	beq.n	8025062 <two_way_long_needle+0x2e6>
 802507a:	9807      	ldr	r0, [sp, #28]
 802507c:	4482      	add	sl, r0
 802507e:	4623      	mov	r3, r4
 8025080:	e799      	b.n	8024fb6 <two_way_long_needle+0x23a>
 8025082:	9a02      	ldr	r2, [sp, #8]
 8025084:	4492      	add	sl, r2
 8025086:	449a      	add	sl, r3
 8025088:	e7f9      	b.n	802507e <two_way_long_needle+0x302>
 802508a:	9b01      	ldr	r3, [sp, #4]
 802508c:	e766      	b.n	8024f5c <two_way_long_needle+0x1e0>
 802508e:	eb07 000a 	add.w	r0, r7, sl
 8025092:	e771      	b.n	8024f78 <two_way_long_needle+0x1fc>

08025094 <strstr>:
 8025094:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025098:	7803      	ldrb	r3, [r0, #0]
 802509a:	b089      	sub	sp, #36	; 0x24
 802509c:	4605      	mov	r5, r0
 802509e:	460f      	mov	r7, r1
 80250a0:	2b00      	cmp	r3, #0
 80250a2:	f000 8167 	beq.w	8025374 <strstr+0x2e0>
 80250a6:	780a      	ldrb	r2, [r1, #0]
 80250a8:	b19a      	cbz	r2, 80250d2 <strstr+0x3e>
 80250aa:	4684      	mov	ip, r0
 80250ac:	3101      	adds	r1, #1
 80250ae:	2401      	movs	r4, #1
 80250b0:	e002      	b.n	80250b8 <strstr+0x24>
 80250b2:	f811 2b01 	ldrb.w	r2, [r1], #1
 80250b6:	b15a      	cbz	r2, 80250d0 <strstr+0x3c>
 80250b8:	4293      	cmp	r3, r2
 80250ba:	bf14      	ite	ne
 80250bc:	2400      	movne	r4, #0
 80250be:	f004 0401 	andeq.w	r4, r4, #1
 80250c2:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
 80250c6:	460e      	mov	r6, r1
 80250c8:	2b00      	cmp	r3, #0
 80250ca:	d1f2      	bne.n	80250b2 <strstr+0x1e>
 80250cc:	7830      	ldrb	r0, [r6, #0]
 80250ce:	b920      	cbnz	r0, 80250da <strstr+0x46>
 80250d0:	b12c      	cbz	r4, 80250de <strstr+0x4a>
 80250d2:	4628      	mov	r0, r5
 80250d4:	b009      	add	sp, #36	; 0x24
 80250d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80250da:	2500      	movs	r5, #0
 80250dc:	e7f9      	b.n	80250d2 <strstr+0x3e>
 80250de:	1c68      	adds	r0, r5, #1
 80250e0:	7839      	ldrb	r1, [r7, #0]
 80250e2:	f7ff fb63 	bl	80247ac <strchr>
 80250e6:	1bf6      	subs	r6, r6, r7
 80250e8:	4680      	mov	r8, r0
 80250ea:	2800      	cmp	r0, #0
 80250ec:	d0f5      	beq.n	80250da <strstr+0x46>
 80250ee:	2e01      	cmp	r6, #1
 80250f0:	f000 80be 	beq.w	8025270 <strstr+0x1dc>
 80250f4:	19ad      	adds	r5, r5, r6
 80250f6:	42a8      	cmp	r0, r5
 80250f8:	bf94      	ite	ls
 80250fa:	ebc0 0405 	rsbls	r4, r0, r5
 80250fe:	2401      	movhi	r4, #1
 8025100:	2e1f      	cmp	r6, #31
 8025102:	d906      	bls.n	8025112 <strstr+0x7e>
 8025104:	4621      	mov	r1, r4
 8025106:	463a      	mov	r2, r7
 8025108:	4633      	mov	r3, r6
 802510a:	f7ff fe37 	bl	8024d7c <two_way_long_needle>
 802510e:	4605      	mov	r5, r0
 8025110:	e7df      	b.n	80250d2 <strstr+0x3e>
 8025112:	4631      	mov	r1, r6
 8025114:	aa07      	add	r2, sp, #28
 8025116:	4638      	mov	r0, r7
 8025118:	f7ff fdd2 	bl	8024cc0 <critical_factorization>
 802511c:	9907      	ldr	r1, [sp, #28]
 802511e:	4681      	mov	r9, r0
 8025120:	1879      	adds	r1, r7, r1
 8025122:	4638      	mov	r0, r7
 8025124:	464a      	mov	r2, r9
 8025126:	f000 fa67 	bl	80255f8 <memcmp>
 802512a:	2800      	cmp	r0, #0
 802512c:	f040 80a2 	bne.w	8025274 <strstr+0x1e0>
 8025130:	f109 3bff 	add.w	fp, r9, #4294967295
 8025134:	eb07 0e0b 	add.w	lr, r7, fp
 8025138:	f8cd b008 	str.w	fp, [sp, #8]
 802513c:	f1c9 0b01 	rsb	fp, r9, #1
 8025140:	f8cd 9010 	str.w	r9, [sp, #16]
 8025144:	4605      	mov	r5, r0
 8025146:	f8cd e00c 	str.w	lr, [sp, #12]
 802514a:	f8cd b014 	str.w	fp, [sp, #20]
 802514e:	4622      	mov	r2, r4
 8025150:	4681      	mov	r9, r0
 8025152:	19ac      	adds	r4, r5, r6
 8025154:	eb08 0002 	add.w	r0, r8, r2
 8025158:	2100      	movs	r1, #0
 802515a:	1aa2      	subs	r2, r4, r2
 802515c:	f000 f9ac 	bl	80254b8 <memchr>
 8025160:	2800      	cmp	r0, #0
 8025162:	d1ba      	bne.n	80250da <strstr+0x46>
 8025164:	2c00      	cmp	r4, #0
 8025166:	d0b8      	beq.n	80250da <strstr+0x46>
 8025168:	9b04      	ldr	r3, [sp, #16]
 802516a:	4599      	cmp	r9, r3
 802516c:	bf28      	it	cs
 802516e:	464b      	movcs	r3, r9
 8025170:	429e      	cmp	r6, r3
 8025172:	d92b      	bls.n	80251cc <strstr+0x138>
 8025174:	eb08 0003 	add.w	r0, r8, r3
 8025178:	5cf9      	ldrb	r1, [r7, r3]
 802517a:	5d42      	ldrb	r2, [r0, r5]
 802517c:	4291      	cmp	r1, r2
 802517e:	eb07 0003 	add.w	r0, r7, r3
 8025182:	d16e      	bne.n	8025262 <strstr+0x1ce>
 8025184:	ea6f 0c03 	mvn.w	ip, r3
 8025188:	eb0c 0e06 	add.w	lr, ip, r6
 802518c:	f01e 0f01 	tst.w	lr, #1
 8025190:	4602      	mov	r2, r0
 8025192:	eb08 0105 	add.w	r1, r8, r5
 8025196:	d016      	beq.n	80251c6 <strstr+0x132>
 8025198:	3301      	adds	r3, #1
 802519a:	429e      	cmp	r6, r3
 802519c:	d916      	bls.n	80251cc <strstr+0x138>
 802519e:	7840      	ldrb	r0, [r0, #1]
 80251a0:	f811 c003 	ldrb.w	ip, [r1, r3]
 80251a4:	3201      	adds	r2, #1
 80251a6:	4584      	cmp	ip, r0
 80251a8:	d00d      	beq.n	80251c6 <strstr+0x132>
 80251aa:	e05a      	b.n	8025262 <strstr+0x1ce>
 80251ac:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 80251b0:	f811 e003 	ldrb.w	lr, [r1, r3]
 80251b4:	4586      	cmp	lr, r0
 80251b6:	d154      	bne.n	8025262 <strstr+0x1ce>
 80251b8:	3301      	adds	r3, #1
 80251ba:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 80251be:	f811 c003 	ldrb.w	ip, [r1, r3]
 80251c2:	4584      	cmp	ip, r0
 80251c4:	d14d      	bne.n	8025262 <strstr+0x1ce>
 80251c6:	3301      	adds	r3, #1
 80251c8:	429e      	cmp	r6, r3
 80251ca:	d8ef      	bhi.n	80251ac <strstr+0x118>
 80251cc:	9b04      	ldr	r3, [sp, #16]
 80251ce:	9a02      	ldr	r2, [sp, #8]
 80251d0:	454b      	cmp	r3, r9
 80251d2:	f240 80d2 	bls.w	802537a <strstr+0x2e6>
 80251d6:	eb08 0e05 	add.w	lr, r8, r5
 80251da:	5cb9      	ldrb	r1, [r7, r2]
 80251dc:	f81e 0002 	ldrb.w	r0, [lr, r2]
 80251e0:	4281      	cmp	r1, r0
 80251e2:	f040 80ca 	bne.w	802537a <strstr+0x2e6>
 80251e6:	f8dd b00c 	ldr.w	fp, [sp, #12]
 80251ea:	eb07 0a09 	add.w	sl, r7, r9
 80251ee:	ebca 010b 	rsb	r1, sl, fp
 80251f2:	07c9      	lsls	r1, r1, #31
 80251f4:	465b      	mov	r3, fp
 80251f6:	d524      	bpl.n	8025242 <strstr+0x1ae>
 80251f8:	9b03      	ldr	r3, [sp, #12]
 80251fa:	f8dd b008 	ldr.w	fp, [sp, #8]
 80251fe:	f813 0c01 	ldrb.w	r0, [r3, #-1]
 8025202:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8025206:	9001      	str	r0, [sp, #4]
 8025208:	f10b 31ff 	add.w	r1, fp, #4294967295
 802520c:	f8dd b004 	ldr.w	fp, [sp, #4]
 8025210:	f81e 0001 	ldrb.w	r0, [lr, r1]
 8025214:	4583      	cmp	fp, r0
 8025216:	f10c 33ff 	add.w	r3, ip, #4294967295
 802521a:	d117      	bne.n	802524c <strstr+0x1b8>
 802521c:	460a      	mov	r2, r1
 802521e:	e010      	b.n	8025242 <strstr+0x1ae>
 8025220:	f813 bc01 	ldrb.w	fp, [r3, #-1]
 8025224:	f81e 3000 	ldrb.w	r3, [lr, r0]
 8025228:	459b      	cmp	fp, r3
 802522a:	f101 33ff 	add.w	r3, r1, #4294967295
 802522e:	d10d      	bne.n	802524c <strstr+0x1b8>
 8025230:	4602      	mov	r2, r0
 8025232:	3801      	subs	r0, #1
 8025234:	f811 bc01 	ldrb.w	fp, [r1, #-1]
 8025238:	f81e 1000 	ldrb.w	r1, [lr, r0]
 802523c:	458b      	cmp	fp, r1
 802523e:	d105      	bne.n	802524c <strstr+0x1b8>
 8025240:	4602      	mov	r2, r0
 8025242:	1e50      	subs	r0, r2, #1
 8025244:	4553      	cmp	r3, sl
 8025246:	f103 31ff 	add.w	r1, r3, #4294967295
 802524a:	d1e9      	bne.n	8025220 <strstr+0x18c>
 802524c:	f109 0901 	add.w	r9, r9, #1
 8025250:	4591      	cmp	r9, r2
 8025252:	f200 8094 	bhi.w	802537e <strstr+0x2ea>
 8025256:	9a07      	ldr	r2, [sp, #28]
 8025258:	18ad      	adds	r5, r5, r2
 802525a:	ebc2 0906 	rsb	r9, r2, r6
 802525e:	4622      	mov	r2, r4
 8025260:	e777      	b.n	8025152 <strstr+0xbe>
 8025262:	f8dd b014 	ldr.w	fp, [sp, #20]
 8025266:	445d      	add	r5, fp
 8025268:	18ed      	adds	r5, r5, r3
 802526a:	f04f 0900 	mov.w	r9, #0
 802526e:	e7f6      	b.n	802525e <strstr+0x1ca>
 8025270:	4605      	mov	r5, r0
 8025272:	e72e      	b.n	80250d2 <strstr+0x3e>
 8025274:	ebc9 0306 	rsb	r3, r9, r6
 8025278:	454b      	cmp	r3, r9
 802527a:	bf38      	it	cc
 802527c:	464b      	movcc	r3, r9
 802527e:	1c58      	adds	r0, r3, #1
 8025280:	f1c9 0b01 	rsb	fp, r9, #1
 8025284:	eb07 0e09 	add.w	lr, r7, r9
 8025288:	eb08 0209 	add.w	r2, r8, r9
 802528c:	f109 35ff 	add.w	r5, r9, #4294967295
 8025290:	f8cd b00c 	str.w	fp, [sp, #12]
 8025294:	4623      	mov	r3, r4
 8025296:	9007      	str	r0, [sp, #28]
 8025298:	f04f 0a00 	mov.w	sl, #0
 802529c:	9202      	str	r2, [sp, #8]
 802529e:	4674      	mov	r4, lr
 80252a0:	46ab      	mov	fp, r5
 80252a2:	eb0a 0506 	add.w	r5, sl, r6
 80252a6:	eb08 0003 	add.w	r0, r8, r3
 80252aa:	2100      	movs	r1, #0
 80252ac:	1aea      	subs	r2, r5, r3
 80252ae:	f000 f903 	bl	80254b8 <memchr>
 80252b2:	2800      	cmp	r0, #0
 80252b4:	f47f af11 	bne.w	80250da <strstr+0x46>
 80252b8:	2d00      	cmp	r5, #0
 80252ba:	f43f af0e 	beq.w	80250da <strstr+0x46>
 80252be:	454e      	cmp	r6, r9
 80252c0:	bf98      	it	ls
 80252c2:	eb08 000a 	addls.w	r0, r8, sl
 80252c6:	d92a      	bls.n	802531e <strstr+0x28a>
 80252c8:	9b02      	ldr	r3, [sp, #8]
 80252ca:	7821      	ldrb	r1, [r4, #0]
 80252cc:	f813 000a 	ldrb.w	r0, [r3, sl]
 80252d0:	4281      	cmp	r1, r0
 80252d2:	d14a      	bne.n	802536a <strstr+0x2d6>
 80252d4:	ea6f 0209 	mvn.w	r2, r9
 80252d8:	1993      	adds	r3, r2, r6
 80252da:	07db      	lsls	r3, r3, #31
 80252dc:	4621      	mov	r1, r4
 80252de:	464a      	mov	r2, r9
 80252e0:	eb08 000a 	add.w	r0, r8, sl
 80252e4:	d518      	bpl.n	8025318 <strstr+0x284>
 80252e6:	f109 0201 	add.w	r2, r9, #1
 80252ea:	4296      	cmp	r6, r2
 80252ec:	d917      	bls.n	802531e <strstr+0x28a>
 80252ee:	4621      	mov	r1, r4
 80252f0:	f810 c002 	ldrb.w	ip, [r0, r2]
 80252f4:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80252f8:	459c      	cmp	ip, r3
 80252fa:	d00d      	beq.n	8025318 <strstr+0x284>
 80252fc:	e036      	b.n	802536c <strstr+0x2d8>
 80252fe:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8025302:	f810 e002 	ldrb.w	lr, [r0, r2]
 8025306:	459e      	cmp	lr, r3
 8025308:	d130      	bne.n	802536c <strstr+0x2d8>
 802530a:	3201      	adds	r2, #1
 802530c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8025310:	f810 c002 	ldrb.w	ip, [r0, r2]
 8025314:	459c      	cmp	ip, r3
 8025316:	d129      	bne.n	802536c <strstr+0x2d8>
 8025318:	3201      	adds	r2, #1
 802531a:	4296      	cmp	r6, r2
 802531c:	d8ef      	bhi.n	80252fe <strstr+0x26a>
 802531e:	f1bb 3fff 	cmp.w	fp, #4294967295
 8025322:	465b      	mov	r3, fp
 8025324:	f43f aef3 	beq.w	802510e <strstr+0x7a>
 8025328:	f817 100b 	ldrb.w	r1, [r7, fp]
 802532c:	f810 200b 	ldrb.w	r2, [r0, fp]
 8025330:	4291      	cmp	r1, r2
 8025332:	d116      	bne.n	8025362 <strstr+0x2ce>
 8025334:	f01b 0f01 	tst.w	fp, #1
 8025338:	d00a      	beq.n	8025350 <strstr+0x2bc>
 802533a:	f10b 33ff 	add.w	r3, fp, #4294967295
 802533e:	5cf9      	ldrb	r1, [r7, r3]
 8025340:	5cc2      	ldrb	r2, [r0, r3]
 8025342:	4291      	cmp	r1, r2
 8025344:	d004      	beq.n	8025350 <strstr+0x2bc>
 8025346:	e00c      	b.n	8025362 <strstr+0x2ce>
 8025348:	5cf9      	ldrb	r1, [r7, r3]
 802534a:	5cc2      	ldrb	r2, [r0, r3]
 802534c:	4291      	cmp	r1, r2
 802534e:	d108      	bne.n	8025362 <strstr+0x2ce>
 8025350:	1e5a      	subs	r2, r3, #1
 8025352:	2b00      	cmp	r3, #0
 8025354:	f43f aedb 	beq.w	802510e <strstr+0x7a>
 8025358:	5cb9      	ldrb	r1, [r7, r2]
 802535a:	5c82      	ldrb	r2, [r0, r2]
 802535c:	3b02      	subs	r3, #2
 802535e:	4291      	cmp	r1, r2
 8025360:	d0f2      	beq.n	8025348 <strstr+0x2b4>
 8025362:	9807      	ldr	r0, [sp, #28]
 8025364:	4482      	add	sl, r0
 8025366:	462b      	mov	r3, r5
 8025368:	e79b      	b.n	80252a2 <strstr+0x20e>
 802536a:	464a      	mov	r2, r9
 802536c:	9803      	ldr	r0, [sp, #12]
 802536e:	4482      	add	sl, r0
 8025370:	4492      	add	sl, r2
 8025372:	e7f8      	b.n	8025366 <strstr+0x2d2>
 8025374:	460e      	mov	r6, r1
 8025376:	2401      	movs	r4, #1
 8025378:	e6a8      	b.n	80250cc <strstr+0x38>
 802537a:	9a04      	ldr	r2, [sp, #16]
 802537c:	e766      	b.n	802524c <strstr+0x1b8>
 802537e:	4445      	add	r5, r8
 8025380:	e6a7      	b.n	80250d2 <strstr+0x3e>
 8025382:	bf00      	nop

08025384 <stat>:
 8025384:	b410      	push	{r4}
 8025386:	f646 3380 	movw	r3, #27520	; 0x6b80
 802538a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802538e:	4604      	mov	r4, r0
 8025390:	6818      	ldr	r0, [r3, #0]
 8025392:	460a      	mov	r2, r1
 8025394:	4621      	mov	r1, r4
 8025396:	bc10      	pop	{r4}
 8025398:	f000 b98a 	b.w	80256b0 <_stat_r>

0802539c <__tz_lock>:
 802539c:	4770      	bx	lr
 802539e:	bf00      	nop

080253a0 <__tz_unlock>:
 80253a0:	4770      	bx	lr
 80253a2:	bf00      	nop

080253a4 <_close_r>:
 80253a4:	b538      	push	{r3, r4, r5, lr}
 80253a6:	4c07      	ldr	r4, [pc, #28]	; (80253c4 <_close_r+0x20>)
 80253a8:	2300      	movs	r3, #0
 80253aa:	4605      	mov	r5, r0
 80253ac:	4608      	mov	r0, r1
 80253ae:	6023      	str	r3, [r4, #0]
 80253b0:	f7df fd78 	bl	8004ea4 <_close>
 80253b4:	1c43      	adds	r3, r0, #1
 80253b6:	d000      	beq.n	80253ba <_close_r+0x16>
 80253b8:	bd38      	pop	{r3, r4, r5, pc}
 80253ba:	6821      	ldr	r1, [r4, #0]
 80253bc:	2900      	cmp	r1, #0
 80253be:	d0fb      	beq.n	80253b8 <_close_r+0x14>
 80253c0:	6029      	str	r1, [r5, #0]
 80253c2:	bd38      	pop	{r3, r4, r5, pc}
 80253c4:	2000664c 	.word	0x2000664c

080253c8 <div>:
 80253c8:	b410      	push	{r4}
 80253ca:	2900      	cmp	r1, #0
 80253cc:	fb91 f4f2 	sdiv	r4, r1, r2
 80253d0:	fb02 1314 	mls	r3, r2, r4, r1
 80253d4:	db05      	blt.n	80253e2 <div+0x1a>
 80253d6:	2b00      	cmp	r3, #0
 80253d8:	db08      	blt.n	80253ec <div+0x24>
 80253da:	6004      	str	r4, [r0, #0]
 80253dc:	6043      	str	r3, [r0, #4]
 80253de:	bc10      	pop	{r4}
 80253e0:	4770      	bx	lr
 80253e2:	2b00      	cmp	r3, #0
 80253e4:	ddf9      	ble.n	80253da <div+0x12>
 80253e6:	3c01      	subs	r4, #1
 80253e8:	189b      	adds	r3, r3, r2
 80253ea:	e7f6      	b.n	80253da <div+0x12>
 80253ec:	3401      	adds	r4, #1
 80253ee:	1a9b      	subs	r3, r3, r2
 80253f0:	e7f3      	b.n	80253da <div+0x12>
 80253f2:	bf00      	nop

080253f4 <__sflags>:
 80253f4:	b470      	push	{r4, r5, r6}
 80253f6:	780b      	ldrb	r3, [r1, #0]
 80253f8:	2b72      	cmp	r3, #114	; 0x72
 80253fa:	d021      	beq.n	8025440 <__sflags+0x4c>
 80253fc:	2b77      	cmp	r3, #119	; 0x77
 80253fe:	d01a      	beq.n	8025436 <__sflags+0x42>
 8025400:	2b61      	cmp	r3, #97	; 0x61
 8025402:	d004      	beq.n	802540e <__sflags+0x1a>
 8025404:	2116      	movs	r1, #22
 8025406:	6001      	str	r1, [r0, #0]
 8025408:	2000      	movs	r0, #0
 802540a:	bc70      	pop	{r4, r5, r6}
 802540c:	4770      	bx	lr
 802540e:	f44f 7502 	mov.w	r5, #520	; 0x208
 8025412:	2401      	movs	r4, #1
 8025414:	f44f 7084 	mov.w	r0, #264	; 0x108
 8025418:	784b      	ldrb	r3, [r1, #1]
 802541a:	b14b      	cbz	r3, 8025430 <__sflags+0x3c>
 802541c:	2b2b      	cmp	r3, #43	; 0x2b
 802541e:	d018      	beq.n	8025452 <__sflags+0x5e>
 8025420:	788e      	ldrb	r6, [r1, #2]
 8025422:	2e2b      	cmp	r6, #43	; 0x2b
 8025424:	d015      	beq.n	8025452 <__sflags+0x5e>
 8025426:	2b62      	cmp	r3, #98	; 0x62
 8025428:	d00e      	beq.n	8025448 <__sflags+0x54>
 802542a:	7889      	ldrb	r1, [r1, #2]
 802542c:	2962      	cmp	r1, #98	; 0x62
 802542e:	d00b      	beq.n	8025448 <__sflags+0x54>
 8025430:	432c      	orrs	r4, r5
 8025432:	6014      	str	r4, [r2, #0]
 8025434:	e7e9      	b.n	802540a <__sflags+0x16>
 8025436:	f44f 65c0 	mov.w	r5, #1536	; 0x600
 802543a:	2401      	movs	r4, #1
 802543c:	2008      	movs	r0, #8
 802543e:	e7eb      	b.n	8025418 <__sflags+0x24>
 8025440:	2500      	movs	r5, #0
 8025442:	462c      	mov	r4, r5
 8025444:	2004      	movs	r0, #4
 8025446:	e7e7      	b.n	8025418 <__sflags+0x24>
 8025448:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
 802544c:	432c      	orrs	r4, r5
 802544e:	6014      	str	r4, [r2, #0]
 8025450:	e7db      	b.n	802540a <__sflags+0x16>
 8025452:	f020 001c 	bic.w	r0, r0, #28
 8025456:	f040 0010 	orr.w	r0, r0, #16
 802545a:	2402      	movs	r4, #2
 802545c:	e7e3      	b.n	8025426 <__sflags+0x32>
 802545e:	bf00      	nop

08025460 <__gettzinfo>:
 8025460:	f646 308c 	movw	r0, #27532	; 0x6b8c
 8025464:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8025468:	4770      	bx	lr
 802546a:	bf00      	nop

0802546c <_isatty_r>:
 802546c:	b538      	push	{r3, r4, r5, lr}
 802546e:	4c07      	ldr	r4, [pc, #28]	; (802548c <_isatty_r+0x20>)
 8025470:	2300      	movs	r3, #0
 8025472:	4605      	mov	r5, r0
 8025474:	4608      	mov	r0, r1
 8025476:	6023      	str	r3, [r4, #0]
 8025478:	f7e0 f9c2 	bl	8005800 <_isatty>
 802547c:	1c43      	adds	r3, r0, #1
 802547e:	d000      	beq.n	8025482 <_isatty_r+0x16>
 8025480:	bd38      	pop	{r3, r4, r5, pc}
 8025482:	6821      	ldr	r1, [r4, #0]
 8025484:	2900      	cmp	r1, #0
 8025486:	d0fb      	beq.n	8025480 <_isatty_r+0x14>
 8025488:	6029      	str	r1, [r5, #0]
 802548a:	bd38      	pop	{r3, r4, r5, pc}
 802548c:	2000664c 	.word	0x2000664c

08025490 <_lseek_r>:
 8025490:	b538      	push	{r3, r4, r5, lr}
 8025492:	4c08      	ldr	r4, [pc, #32]	; (80254b4 <_lseek_r+0x24>)
 8025494:	4605      	mov	r5, r0
 8025496:	4608      	mov	r0, r1
 8025498:	4611      	mov	r1, r2
 802549a:	461a      	mov	r2, r3
 802549c:	2300      	movs	r3, #0
 802549e:	6023      	str	r3, [r4, #0]
 80254a0:	f7df fee8 	bl	8005274 <_lseek>
 80254a4:	1c43      	adds	r3, r0, #1
 80254a6:	d000      	beq.n	80254aa <_lseek_r+0x1a>
 80254a8:	bd38      	pop	{r3, r4, r5, pc}
 80254aa:	6821      	ldr	r1, [r4, #0]
 80254ac:	2900      	cmp	r1, #0
 80254ae:	d0fb      	beq.n	80254a8 <_lseek_r+0x18>
 80254b0:	6029      	str	r1, [r5, #0]
 80254b2:	bd38      	pop	{r3, r4, r5, pc}
 80254b4:	2000664c 	.word	0x2000664c

080254b8 <memchr>:
 80254b8:	0783      	lsls	r3, r0, #30
 80254ba:	b4f0      	push	{r4, r5, r6, r7}
 80254bc:	b2c9      	uxtb	r1, r1
 80254be:	f000 8096 	beq.w	80255ee <memchr+0x136>
 80254c2:	1e53      	subs	r3, r2, #1
 80254c4:	2a00      	cmp	r2, #0
 80254c6:	f000 8094 	beq.w	80255f2 <memchr+0x13a>
 80254ca:	7802      	ldrb	r2, [r0, #0]
 80254cc:	428a      	cmp	r2, r1
 80254ce:	d00b      	beq.n	80254e8 <memchr+0x30>
 80254d0:	1c42      	adds	r2, r0, #1
 80254d2:	07d8      	lsls	r0, r3, #31
 80254d4:	d51a      	bpl.n	802550c <memchr+0x54>
 80254d6:	f012 0f03 	tst.w	r2, #3
 80254da:	4610      	mov	r0, r2
 80254dc:	d01c      	beq.n	8025518 <memchr+0x60>
 80254de:	7814      	ldrb	r4, [r2, #0]
 80254e0:	3b01      	subs	r3, #1
 80254e2:	3201      	adds	r2, #1
 80254e4:	428c      	cmp	r4, r1
 80254e6:	d111      	bne.n	802550c <memchr+0x54>
 80254e8:	bcf0      	pop	{r4, r5, r6, r7}
 80254ea:	4770      	bx	lr
 80254ec:	2b00      	cmp	r3, #0
 80254ee:	d07c      	beq.n	80255ea <memchr+0x132>
 80254f0:	7812      	ldrb	r2, [r2, #0]
 80254f2:	3b01      	subs	r3, #1
 80254f4:	428a      	cmp	r2, r1
 80254f6:	d0f7      	beq.n	80254e8 <memchr+0x30>
 80254f8:	f014 0f03 	tst.w	r4, #3
 80254fc:	4620      	mov	r0, r4
 80254fe:	f104 0201 	add.w	r2, r4, #1
 8025502:	d009      	beq.n	8025518 <memchr+0x60>
 8025504:	7824      	ldrb	r4, [r4, #0]
 8025506:	3b01      	subs	r3, #1
 8025508:	428c      	cmp	r4, r1
 802550a:	d0ed      	beq.n	80254e8 <memchr+0x30>
 802550c:	f012 0f03 	tst.w	r2, #3
 8025510:	4610      	mov	r0, r2
 8025512:	f102 0401 	add.w	r4, r2, #1
 8025516:	d1e9      	bne.n	80254ec <memchr+0x34>
 8025518:	2b03      	cmp	r3, #3
 802551a:	d93f      	bls.n	802559c <memchr+0xe4>
 802551c:	6804      	ldr	r4, [r0, #0]
 802551e:	ea41 2501 	orr.w	r5, r1, r1, lsl #8
 8025522:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8025526:	ea85 0704 	eor.w	r7, r5, r4
 802552a:	f1a7 3201 	sub.w	r2, r7, #16843009	; 0x1010101
 802552e:	ea22 0207 	bic.w	r2, r2, r7
 8025532:	1f1e      	subs	r6, r3, #4
 8025534:	1d04      	adds	r4, r0, #4
 8025536:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 802553a:	f3c6 0780 	ubfx	r7, r6, #2, #1
 802553e:	d12d      	bne.n	802559c <memchr+0xe4>
 8025540:	2e03      	cmp	r6, #3
 8025542:	4633      	mov	r3, r6
 8025544:	d929      	bls.n	802559a <memchr+0xe2>
 8025546:	b167      	cbz	r7, 8025562 <memchr+0xaa>
 8025548:	4620      	mov	r0, r4
 802554a:	3404      	adds	r4, #4
 802554c:	6806      	ldr	r6, [r0, #0]
 802554e:	ea85 0206 	eor.w	r2, r5, r6
 8025552:	f1a2 3601 	sub.w	r6, r2, #16843009	; 0x1010101
 8025556:	ea26 0202 	bic.w	r2, r6, r2
 802555a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 802555e:	d019      	beq.n	8025594 <memchr+0xdc>
 8025560:	e01c      	b.n	802559c <memchr+0xe4>
 8025562:	1d26      	adds	r6, r4, #4
 8025564:	4620      	mov	r0, r4
 8025566:	6824      	ldr	r4, [r4, #0]
 8025568:	ea85 0204 	eor.w	r2, r5, r4
 802556c:	f1a2 3401 	sub.w	r4, r2, #16843009	; 0x1010101
 8025570:	ea24 0202 	bic.w	r2, r4, r2
 8025574:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8025578:	d110      	bne.n	802559c <memchr+0xe4>
 802557a:	6834      	ldr	r4, [r6, #0]
 802557c:	ea85 0204 	eor.w	r2, r5, r4
 8025580:	f1a2 3401 	sub.w	r4, r2, #16843009	; 0x1010101
 8025584:	ea24 0202 	bic.w	r2, r4, r2
 8025588:	3b04      	subs	r3, #4
 802558a:	1d34      	adds	r4, r6, #4
 802558c:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8025590:	4630      	mov	r0, r6
 8025592:	d103      	bne.n	802559c <memchr+0xe4>
 8025594:	3b04      	subs	r3, #4
 8025596:	2b03      	cmp	r3, #3
 8025598:	d8e3      	bhi.n	8025562 <memchr+0xaa>
 802559a:	4620      	mov	r0, r4
 802559c:	1e5d      	subs	r5, r3, #1
 802559e:	b323      	cbz	r3, 80255ea <memchr+0x132>
 80255a0:	7803      	ldrb	r3, [r0, #0]
 80255a2:	428b      	cmp	r3, r1
 80255a4:	d0a0      	beq.n	80254e8 <memchr+0x30>
 80255a6:	1c43      	adds	r3, r0, #1
 80255a8:	2200      	movs	r2, #0
 80255aa:	07e8      	lsls	r0, r5, #31
 80255ac:	d514      	bpl.n	80255d8 <memchr+0x120>
 80255ae:	4618      	mov	r0, r3
 80255b0:	2201      	movs	r2, #1
 80255b2:	7804      	ldrb	r4, [r0, #0]
 80255b4:	3301      	adds	r3, #1
 80255b6:	428c      	cmp	r4, r1
 80255b8:	d096      	beq.n	80254e8 <memchr+0x30>
 80255ba:	4295      	cmp	r5, r2
 80255bc:	4618      	mov	r0, r3
 80255be:	f103 0401 	add.w	r4, r3, #1
 80255c2:	f102 0202 	add.w	r2, r2, #2
 80255c6:	d00e      	beq.n	80255e6 <memchr+0x12e>
 80255c8:	781b      	ldrb	r3, [r3, #0]
 80255ca:	428b      	cmp	r3, r1
 80255cc:	d08c      	beq.n	80254e8 <memchr+0x30>
 80255ce:	1c63      	adds	r3, r4, #1
 80255d0:	4620      	mov	r0, r4
 80255d2:	7824      	ldrb	r4, [r4, #0]
 80255d4:	428c      	cmp	r4, r1
 80255d6:	d087      	beq.n	80254e8 <memchr+0x30>
 80255d8:	4295      	cmp	r5, r2
 80255da:	4618      	mov	r0, r3
 80255dc:	f103 0401 	add.w	r4, r3, #1
 80255e0:	f102 0202 	add.w	r2, r2, #2
 80255e4:	d1f0      	bne.n	80255c8 <memchr+0x110>
 80255e6:	2000      	movs	r0, #0
 80255e8:	e77e      	b.n	80254e8 <memchr+0x30>
 80255ea:	4618      	mov	r0, r3
 80255ec:	e77c      	b.n	80254e8 <memchr+0x30>
 80255ee:	4613      	mov	r3, r2
 80255f0:	e792      	b.n	8025518 <memchr+0x60>
 80255f2:	4610      	mov	r0, r2
 80255f4:	e778      	b.n	80254e8 <memchr+0x30>
 80255f6:	bf00      	nop

080255f8 <memcmp>:
 80255f8:	2a03      	cmp	r2, #3
 80255fa:	b4f0      	push	{r4, r5, r6, r7}
 80255fc:	d931      	bls.n	8025662 <memcmp+0x6a>
 80255fe:	ea41 0300 	orr.w	r3, r1, r0
 8025602:	079c      	lsls	r4, r3, #30
 8025604:	d12e      	bne.n	8025664 <memcmp+0x6c>
 8025606:	6806      	ldr	r6, [r0, #0]
 8025608:	680f      	ldr	r7, [r1, #0]
 802560a:	1f15      	subs	r5, r2, #4
 802560c:	1d03      	adds	r3, r0, #4
 802560e:	1d0c      	adds	r4, r1, #4
 8025610:	42be      	cmp	r6, r7
 8025612:	f3c5 0c80 	ubfx	ip, r5, #2, #1
 8025616:	d124      	bne.n	8025662 <memcmp+0x6a>
 8025618:	2d03      	cmp	r5, #3
 802561a:	462a      	mov	r2, r5
 802561c:	d91f      	bls.n	802565e <memcmp+0x66>
 802561e:	f1bc 0f00 	cmp.w	ip, #0
 8025622:	d008      	beq.n	8025636 <memcmp+0x3e>
 8025624:	6825      	ldr	r5, [r4, #0]
 8025626:	681e      	ldr	r6, [r3, #0]
 8025628:	4621      	mov	r1, r4
 802562a:	4618      	mov	r0, r3
 802562c:	3404      	adds	r4, #4
 802562e:	3304      	adds	r3, #4
 8025630:	42ae      	cmp	r6, r5
 8025632:	d011      	beq.n	8025658 <memcmp+0x60>
 8025634:	e015      	b.n	8025662 <memcmp+0x6a>
 8025636:	4618      	mov	r0, r3
 8025638:	4621      	mov	r1, r4
 802563a:	6823      	ldr	r3, [r4, #0]
 802563c:	6804      	ldr	r4, [r0, #0]
 802563e:	1d05      	adds	r5, r0, #4
 8025640:	1d0e      	adds	r6, r1, #4
 8025642:	429c      	cmp	r4, r3
 8025644:	d10d      	bne.n	8025662 <memcmp+0x6a>
 8025646:	4628      	mov	r0, r5
 8025648:	4631      	mov	r1, r6
 802564a:	6835      	ldr	r5, [r6, #0]
 802564c:	6806      	ldr	r6, [r0, #0]
 802564e:	3a04      	subs	r2, #4
 8025650:	1d03      	adds	r3, r0, #4
 8025652:	1d0c      	adds	r4, r1, #4
 8025654:	42ae      	cmp	r6, r5
 8025656:	d104      	bne.n	8025662 <memcmp+0x6a>
 8025658:	3a04      	subs	r2, #4
 802565a:	2a03      	cmp	r2, #3
 802565c:	d8eb      	bhi.n	8025636 <memcmp+0x3e>
 802565e:	4621      	mov	r1, r4
 8025660:	4618      	mov	r0, r3
 8025662:	b31a      	cbz	r2, 80256ac <memcmp+0xb4>
 8025664:	7803      	ldrb	r3, [r0, #0]
 8025666:	780c      	ldrb	r4, [r1, #0]
 8025668:	42a3      	cmp	r3, r4
 802566a:	d10a      	bne.n	8025682 <memcmp+0x8a>
 802566c:	1e55      	subs	r5, r2, #1
 802566e:	2200      	movs	r2, #0
 8025670:	07eb      	lsls	r3, r5, #31
 8025672:	d514      	bpl.n	802569e <memcmp+0xa6>
 8025674:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8025678:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802567c:	2201      	movs	r2, #1
 802567e:	42a3      	cmp	r3, r4
 8025680:	d00d      	beq.n	802569e <memcmp+0xa6>
 8025682:	1b18      	subs	r0, r3, r4
 8025684:	e010      	b.n	80256a8 <memcmp+0xb0>
 8025686:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 802568a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802568e:	42a3      	cmp	r3, r4
 8025690:	d1f7      	bne.n	8025682 <memcmp+0x8a>
 8025692:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8025696:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802569a:	42a3      	cmp	r3, r4
 802569c:	d1f1      	bne.n	8025682 <memcmp+0x8a>
 802569e:	42aa      	cmp	r2, r5
 80256a0:	f102 0202 	add.w	r2, r2, #2
 80256a4:	d1ef      	bne.n	8025686 <memcmp+0x8e>
 80256a6:	2000      	movs	r0, #0
 80256a8:	bcf0      	pop	{r4, r5, r6, r7}
 80256aa:	4770      	bx	lr
 80256ac:	4610      	mov	r0, r2
 80256ae:	e7fb      	b.n	80256a8 <memcmp+0xb0>

080256b0 <_stat_r>:
 80256b0:	b538      	push	{r3, r4, r5, lr}
 80256b2:	4c08      	ldr	r4, [pc, #32]	; (80256d4 <_stat_r+0x24>)
 80256b4:	2300      	movs	r3, #0
 80256b6:	4605      	mov	r5, r0
 80256b8:	4608      	mov	r0, r1
 80256ba:	4611      	mov	r1, r2
 80256bc:	6023      	str	r3, [r4, #0]
 80256be:	f7df ff4d 	bl	800555c <_stat>
 80256c2:	1c43      	adds	r3, r0, #1
 80256c4:	d000      	beq.n	80256c8 <_stat_r+0x18>
 80256c6:	bd38      	pop	{r3, r4, r5, pc}
 80256c8:	6821      	ldr	r1, [r4, #0]
 80256ca:	2900      	cmp	r1, #0
 80256cc:	d0fb      	beq.n	80256c6 <_stat_r+0x16>
 80256ce:	6029      	str	r1, [r5, #0]
 80256d0:	bd38      	pop	{r3, r4, r5, pc}
 80256d2:	bf00      	nop
 80256d4:	2000664c 	.word	0x2000664c
